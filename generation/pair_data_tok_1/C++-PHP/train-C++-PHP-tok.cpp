bool isEven ( int arr [ ] , int n , int r ) {
if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; }
else {
int oddCount = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; }
return false ; }
int main ( ) { int arr [ ] = { 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int r = 2 ; if ( isEven ( arr , n , r ) ) cout << " Even " ; else cout << " Odd " ; return 0 ; }
void solve ( int a [ ] , int n ) { int ones = 0 , twos = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] == 1 ) ones ++ ;
else twos ++ ; } int ind = 0 ;
if ( twos ) a [ ind ++ ] = 2 ;
bool evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ;
for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ;
for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ;
if ( evenOnes ) a [ ind ++ ] = 1 ;
for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; }
int main ( ) { int a [ ] = { 1 , 2 , 1 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; solve ( a , n ) ; return 0 ; }
void CreateArray ( int N , int even , int odd ) { int temp = -1 ; int OddPreSums ;
for ( int i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } }
if ( temp == -1 ) { cout << temp << endl ; } else {
int EvenPreSums = ( N + 1 ) - OddPreSums ; int e = 1 ; int o = 0 ;
int CurrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) {
if ( CurrSum % 2 == 0 ) {
if ( e < EvenPreSums ) { e ++ ; cout << "0 ▁ " ; } else { o ++ ;
cout << "1 ▁ " ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; cout << "1 ▁ " ; CurrSum ++ ; } else { o ++ ;
cout << "0 ▁ " ; } } } cout << endl ; } }
int main ( ) { int N = 15 ; int even = 60 , odd = 60 ; CreateArray ( N , even , odd ) ; return 0 ; }
int findX ( int A , int B ) { int j = 0 , x = 0 ;
while ( A B ) {
if ( ( A & 1 ) && ( B & 1 ) ) {
x += ( 1 << j ) ; }
A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; }
int main ( ) { int A = 2 , B = 3 ; int X = findX ( A , B ) ; cout << " X ▁ = ▁ " << X << " , ▁ Sum ▁ = ▁ " << ( A ^ X ) + ( B ^ X ) ; return 0 ; }
bool isSumEqual ( int ar [ ] , int n ) { int sum = 0 ;
for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ;
if ( sum == ar [ n - 1 ] ) return true ; return false ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isSumEqual ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int perfectSquares ( int a , int b ) {
return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; }
int countOnes ( int arr [ ] , int n ) { return perfectSquares ( 1 , n ) ; }
int N = 10 ;
int arr [ 10 ] = { 0 } ; cout << countOnes ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
void printPosition ( int A [ ] , int B [ ] , int sizeOfA , int sizeOfB ) {
for ( int i = 1 ; i < sizeOfA ; i ++ ) A [ i ] += A [ i - 1 ] ;
for ( int i = 0 ; i < sizeOfB ; i ++ ) {
int row = lower_bound ( A , A + sizeOfA , B [ i ] ) - A ;
int boxNumber = ( row >= 1 ) ? B [ i ] - A [ row - 1 ] : B [ i ] ;
cout << row + 1 << " , ▁ " << boxNumber << " STRNEWLINE " ; } }
int main ( ) { int A [ ] = { 2 , 2 , 2 , 2 } ; int B [ ] = { 1 , 2 , 3 , 4 } ; int sizeOfA = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int sizeOfB = sizeof ( B ) / sizeof ( B [ 0 ] ) ; printPosition ( A , B , sizeOfA , sizeOfB ) ; return 0 ; }
void primeFactors ( int n , int freq [ ] ) { int cnt = 0 ;
while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ;
for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { cnt = 0 ;
while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; }
if ( n > 2 ) freq [ n ] = 1 ; }
int getMaximumPower ( int n , int m ) {
int freq1 [ n + 1 ] , freq2 [ m + 1 ] ; memset ( freq1 , 0 , sizeof freq1 ) ; memset ( freq2 , 0 , sizeof freq2 ) ;
primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; int maxi = 0 ;
for ( int i = 2 ; i <= m ; i ++ ) {
if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ;
if ( freq2 [ i ] > freq1 [ i ] ) return 0 ;
if ( freq2 [ i ] ) {
maxi = max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; }
int main ( ) { int n = 48 , m = 4 ; cout << getMaximumPower ( n , m ) ; return 0 ; }
void findDivisors ( int n ) {
int div [ n + 1 ] ; memset ( div , 0 , sizeof div ) ;
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; }
for ( int i = 1 ; i <= n ; i ++ ) cout << div [ i ] << " ▁ " ; }
int main ( ) { int n = 10 ; findDivisors ( n ) ; return 0 ; }
int decideWinner ( int a [ ] , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] % 4 == 0 ) count0 ++ ;
else if ( a [ i ] % 4 == 1 ) count1 ++ ;
else if ( a [ i ] % 4 == 2 ) count2 ++ ;
else if ( a [ i ] % 4 == 3 ) count3 ++ ; }
if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; }
int main ( ) { int a [ ] = { 4 , 8 , 5 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( decideWinner ( a , n ) == 1 ) cout << " X ▁ wins " ; else cout << " Y ▁ wins " ; return 0 ; }
int CntDivbyX ( int arr [ ] , int n , int x ) {
int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
number = ( number * 2 + arr [ i ] ) % x ;
if ( number == 0 ) count += 1 ; } return count ; }
int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 2 ; cout << CntDivbyX ( arr , n , x ) ; return 0 ; }
int numLen ( int K ) {
if ( K % 2 == 0 K % 5 == 0 ) return -1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) {
number = ( number * 10 + 1 ) % K ;
if ( number == 0 ) return len ; } return -1 ; }
int main ( ) { int K = 7 ; cout << numLen ( K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE const ll max_Element = 1e6 + 5 ;
int sum1 [ max_Element ] , sum2 [ max_Element ] , sum3 [ max_Element ] ;
void precomputation ( int arr [ ] , int n ) {
for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i )
sum1 [ j ] += i ;
for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i )
sum2 [ j ] += ( sum1 [ j ] - i ) * i ;
for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ;
for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ;
for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ;
for ( int i = 0 ; i < n ; i ++ ) cout << sum3 [ arr [ i ] ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 9 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
precomputation ( arr , n ) ; return 0 ; }
int fib ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2 ; return round ( pow ( phi , n ) / sqrt ( 5 ) ) ; }
int calculateSum ( int l , int r ) {
int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; }
int main ( ) { int l = 4 , r = 8 ; cout << calculateSum ( l , r ) ; return 0 ; }
void printBalancedExpression ( int a , int b , int c , int d ) {
if ( ( a == d && a ) || ( a == 0 && c == 0 && d == 0 ) ) {
for ( int i = 1 ; i <= a ; i ++ ) cout << " ( ( " ;
for ( int i = 1 ; i <= c ; i ++ ) cout << " ) ( " ;
for ( int i = 1 ; i <= d ; i ++ ) cout << " ) ) " ;
for ( int i = 1 ; i <= b ; i ++ ) cout << " ( ) " ; }
else cout < < -1 ; }
int main ( ) { int a = 3 , b = 1 , c = 4 , d = 3 ; printBalancedExpression ( a , b , c , d ) ; return 0 ; }
ll factorial ( int f ) { ll fact = 1 ; for ( int i = 2 ; i <= f ; i ++ ) fact *= ( ll ) i ; return fact ; }
ll findPermutation ( int N , int M ) { ll permutation = factorial ( N + M - 1 ) / ( factorial ( N ) * factorial ( M - 1 ) ) ; return permutation ; }
int main ( ) { int N = 3 , M = 3 ; cout << findPermutation ( N , M ) ; return 0 ; }
int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; }
int main ( ) { int n = 4 ; cout << maxValue ( n ) ; return 0 ; }
void findCount ( int n ) { ull a = 1 , b = 0 , c = 0 ;
int x = n / 60 ; a = ( ull ) pow ( 32 , x ) ;
x = 60 * x ; for ( int i = x + 1 ; i <= n ; i ++ ) {
if ( i % 2 == 0 ) { b += a ; a = 0 ; }
if ( i % 5 == 0 ) { c += b ; b = 0 ; }
if ( i % 12 == 0 ) { a += ( 2 * c ) ; c = 0 ; } }
cout << " a ▁ = ▁ " << a << " , ▁ " ; cout << " b ▁ = ▁ " << b << " , ▁ " ; cout << " c ▁ = ▁ " << c ; }
int main ( ) { int n = 72 ; findCount ( n ) ; return 0 ; }
int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; }
int gcdOfFactorial ( int arr [ ] , int n ) {
int minm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minm = minm > arr [ i ] ? arr [ i ] : minm ;
return factorial ( minm ) ; }
int main ( ) { int arr [ ] = { 9 , 12 , 122 , 34 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << gcdOfFactorial ( arr , n ) ; return 0 ; }
ll sum ( int n ) {
if ( n == 1 ) return 1 ; else
return ( ( ll ) pow ( n , n ) + sum ( n - 1 ) ) ; }
int main ( ) { int n = 2 ; cout << sum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; const int mod = 1000000007 ;
ll power ( ll a , ll n ) { if ( n == 0 ) return 1 ; ll p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n & 1 ) p = ( p * a ) % mod ; return p ; }
int countPermutations ( int n ) {
if ( n == 1 ) { return 0 ; }
return ( power ( 2 , n - 1 ) - 2 ) % mod ; }
int main ( ) { int n = 5 ; cout << countPermutations ( n ) ; return 0 ; }
long long numbers ( int n ) { return ( long long ) ( pow ( 2 , n + 1 ) ) - 2 ; }
int main ( ) { int n = 2 ; cout << numbers ( n ) ; return 0 ; }
long long NumberofWays ( int n ) { long long x = ( 1LL * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; long long y = ( 1LL * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) ; return ( 1LL * x * y ) ; }
int main ( ) { int n = 4 ; cout << NumberofWays ( n ) ; return 0 ; }
int nthTerm ( int N ) { int nth = 0 ;
nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; }
int main ( ) { int N = 5 ; cout << nthTerm ( N ) << endl ; return 0 ; }
void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) {
cout << ( ( 2 * i ) - 1 ) << " ▁ " ; i ++ ; } }
int main ( ) { int n = 3 ; findNumbers ( n ) ; }
void findMissingNums ( int even [ ] , int sizeEven , int odd [ ] , int sizeOdd ) {
int minEven = INT_MAX ; int maxEven = INT_MIN ; int minOdd = INT_MAX ; int maxOdd = INT_MIN ;
int sumEvenArr = 0 , sumOddArr = 0 ;
for ( int i = 0 ; i < sizeEven ; i ++ ) { minEven = min ( minEven , even [ i ] ) ; maxEven = max ( maxEven , even [ i ] ) ; sumEvenArr += even [ i ] ; }
for ( int i = 0 ; i < sizeOdd ; i ++ ) { minOdd = min ( minOdd , odd [ i ] ) ; maxOdd = max ( maxOdd , odd [ i ] ) ; sumOddArr += odd [ i ] ; }
int totalTerms = 0 , reqSum = 0 ;
totalTerms = minEven / 2 ;
int evenSumMin = totalTerms * ( totalTerms + 1 ) ;
totalTerms = maxEven / 2 ;
int evenSumMax = totalTerms * ( totalTerms + 1 ) ;
reqSum = evenSumMax - evenSumMin + minEven ;
cout << " Even ▁ = ▁ " << reqSum - sumEvenArr << " STRNEWLINE " ;
totalTerms = ( minOdd / 2 ) + 1 ;
int oddSumMin = totalTerms * totalTerms ;
totalTerms = ( maxOdd / 2 ) + 1 ;
int oddSumMax = totalTerms * totalTerms ;
reqSum = oddSumMax - oddSumMin + minOdd ;
cout << " Odd ▁ = ▁ " << reqSum - sumOddArr ; }
int main ( ) { int even [ ] = { 6 , 4 , 8 , 14 , 10 } ; int sizeEven = sizeof ( even ) / sizeof ( even [ 0 ] ) ; int odd [ ] = { 7 , 5 , 3 , 11 , 13 } ; int sizeOdd = sizeof ( odd ) / sizeof ( odd [ 0 ] ) ; findMissingNums ( even , sizeEven , odd , sizeOdd ) ; return 0 ; }
int findMinimum ( int x , int y ) {
int low = 0 , high = y ; while ( low <= high ) {
int mid = ( low + high ) >> 1 ;
if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; }
int main ( ) { int x = 6 , y = 5 ; cout << findMinimum ( x , y ) ; return 0 ; }
int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; }
int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) {
if ( i % 2 == 0 && sumOfDigits ( i ) % 3 == 0 ) count ++ ; }
return count ; }
int main ( ) { int l = 1000 , r = 6000 ; cout << countNumbers ( l , r ) ; return 0 ; }
int findMinSum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; }
int main ( ) { int arr [ ] = { 3 , 5 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSum ( arr , n ) ; return 0 ; }
int maxLenSubArr ( int a [ ] , int n ) { int count , j ; int cm = 1 , max = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( int i = 0 ; i < n - 1 ; ) { count = 1 ;
if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) {
for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; }
int main ( ) { int arr [ ] = { 6 , 1 , 6 , 6 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxLenSubArr ( arr , n ) ; return 0 ; }
ll minSum ( int arr [ ] , int n , int x ) { ll sum = 0 ;
int largestDivisible = -1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) {
sum += arr [ i ] ;
if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ;
if ( arr [ i ] < minimum ) minimum = arr [ i ] ; }
if ( largestDivisible == -1 ) return sum ;
ll sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ;
return min ( sum , sumAfterOperation ) ; }
int main ( ) { int arr [ ] = { 5 , 5 , 5 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; cout << minSum ( arr , n , x ) ; return 0 ; }
int maxAND ( int L , int R ) {
if ( L == R ) return L ;
else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } }
int main ( ) { int L = 1 , R = 632 ; cout << maxAND ( L , R ) ; return 0 ; }
bool checkSpecialPrime ( bool * sieve , int num ) {
while ( num ) {
if ( ! sieve [ num ] ) { return false ; }
num /= 10 ; }
return true ; }
void findSpecialPrime ( int N ) { bool sieve [ N * 10 ] ;
memset ( sieve , true , sizeof ( sieve ) ) ; sieve [ 0 ] = sieve [ 1 ] = false ; for ( long long i = 2 ; i <= N * 10 ; i ++ ) { if ( sieve [ i ] ) { for ( long long j = i * i ; j <= N * 10 ; j += i ) { sieve [ j ] = false ; } } }
while ( true ) {
if ( checkSpecialPrime ( sieve , N ) ) {
cout << N << ' ' ; break ; }
else N ++ ; } }
int main ( ) { int N = 379 ; findSpecialPrime ( N ) ; N = 100 ; findSpecialPrime ( N ) ; return 0 ; }
int minMoves ( long long n ) {
string s = to_string ( n ) ;
int ans = INT_MAX ;
int len = s . size ( ) ;
for ( int i = 0 ; i < len ; ++ i ) { for ( int j = 0 ; j < len ; ++ j ) { if ( i == j ) continue ;
string t = s ; int cur = 0 ;
for ( int k = i ; k < len - 1 ; ++ k ) { swap ( t [ k ] , t [ k + 1 ] ) ; ++ cur ; }
for ( int k = j - ( j > i ) ; k < len - 2 ; ++ k ) { swap ( t [ k ] , t [ k + 1 ] ) ; ++ cur ; }
int pos = -1 ; for ( int k = 0 ; k < len ; ++ k ) { if ( t [ k ] != '0' ) { pos = k ; break ; } }
for ( int k = pos ; k > 0 ; -- k ) { swap ( t [ k ] , t [ k - 1 ] ) ; ++ cur ; }
long long nn = atoll ( t . c_str ( ) ) ;
if ( nn % 25 == 0 ) ans = min ( ans , cur ) ; } }
if ( ans == INT_MAX ) return -1 ; return ans ; }
int main ( ) { long long n = 509201 ; cout << minMoves ( n ) ; return 0 ; }
int getMaxNum ( int a , int b , int c ) {
if ( b % c == 0 ) return b ;
int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return -1 ; }
int main ( ) { int a = 2 , b = 10 , c = 3 ; cout << getMaxNum ( a , b , c ) ; return 0 ; }
int countSquares ( int row , int column ) {
int topLeft = min ( row , column ) - 1 ;
int bottomRight = 8 - max ( row , column ) ;
int topRight = min ( row , 9 - column ) - 1 ;
int bottomLeft = 8 - max ( row , 9 - column ) ;
return ( topLeft + topRight + bottomRight + bottomLeft ) ; }
int row = 4 , column = 4 ; cout << countSquares ( row , column ) ; return 0 ; }
bool canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) {
if ( pawnX - bishopX == pawnY - bishopY ) return true ;
else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; }
int bishopX = 5 , bishopY = 5 ;
int pawnX = 1 , pawnY = 1 ; if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005
int primeFactors [ N ] ;
void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ )
if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i )
primeFactors [ j ] = primeFactors [ j / i ] + 1 ;
for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; }
findPrimeFactors ( ) ; int a = 6 , b = 3 ;
cout << primeFactors [ a ] - primeFactors [ b ] ; return 0 ; }
int digitSum ( int n ) { int ans = 0 ; while ( n ) { ans += n % 10 ; n /= 10 ; } return ans ; }
int findInt ( int n , int m ) { int minDigit = floor ( m / 9 ) ;
int start = pow ( 10 , minDigit ) - ( int ) pow ( 10 , minDigit ) % n ; while ( start < INT_MAX ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return -1 ; }
int main ( ) { int n = 13 , m = 32 ; cout << findInt ( n , m ) ; return 0 ; }
int smallestDivisor ( int n ) { int mx = sqrt ( n ) ; for ( int i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; }
int maxSum ( int n ) { long long res = n ; while ( n > 1 ) { int divi = smallestDivisor ( n ) ; n /= divi ; res += n ; } return res ; }
int main ( ) { int n = 34 ; cout << maxSum ( n ) ; return 0 ; }
bool isPossible ( int n , int k , int arr [ ] ) {
int sum = arr [ 0 ] , maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; }
int main ( ) { int k = 8 ; int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isPossible ( n , k , arr ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ;
for ( int i = 0 ; i <= n ; i += a ) {
for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) ( c ) ;
if ( floor ( z ) == ceil ( z ) ) { int x = i / a ; int y = j / b ; maxVal = max ( maxVal , x + y + ( int ) z ) ; } } } return maxVal ; }
int main ( ) { int n = 10 , a = 5 , b = 3 , c = 4 ;
cout << maxResult ( n , a , b , c ) ; return 0 ; }
bool EqualNumbers ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) {
while ( a [ i ] % 2 == 0 ) a [ i ] /= 2 ;
while ( a [ i ] % 3 == 0 ) a [ i ] /= 3 ; if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; }
int main ( ) { int a [ ] = { 50 , 75 , 150 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( EqualNumbers ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
long max_gcd ( long n , long p ) { int count = 0 ; long gcd = 1 ;
while ( p % 2 == 0 ) {
p >>= 1 ; count ++ ; }
if ( count > 0 ) gcd *= ( long ) pow ( 2 , count / n ) ;
for ( long i = 3 ; i <= sqrt ( p ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = p / i ; } if ( count > 0 ) { gcd *= ( long ) pow ( i , count / n ) ; } }
if ( p > 2 ) gcd *= ( long ) pow ( p , 1 / n ) ;
return gcd ; }
int main ( ) { long n = 3 ; long p = 80 ; cout << max_gcd ( n , p ) ; }
int getMinNum ( int a , int b , int c ) {
if ( c < a c > b ) return c ;
int x = ( ( b / c ) * c ) + c ; return x ; }
int main ( ) { int a = 2 , b = 4 , c = 4 ; cout << getMinNum ( a , b , c ) ; return 0 ; }
int countPairs ( int n ) {
if ( n == 2 ) return 4 ;
int num = ( ( n / 2 ) + 1 ) ;
int max = n % num ;
int count = n - max ; return count ; }
int main ( ) { int n = 5 ; cout << countPairs ( n ) ; }
int checkSub ( string sub , string s ) { int j = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) if ( sub [ j ] == s [ i ] ) j ++ ; return j == ( int ) sub . size ( ) ; }
int getMultiple ( string s ) {
for ( int i = 0 ; i < 1e3 ; i += 8 ) {
if ( checkSub ( to_string ( i ) , s ) ) return i ; } return -1 ; }
int main ( ) { string s = "3454" ; cout << getMultiple ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float sum ( float n ) {
if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; }
int main ( ) { cout << ( sum ( 8 ) ) << endl ; cout << ( sum ( 10 ) ) << endl ; return 0 ; }
pair < double , double > findingValues ( double m , double n , double mth , double nth ) {
double d = ( abs ( mth - nth ) ) / abs ( ( m - 1 ) - ( n - 1 ) ) ;
double a = mth - ( ( m - 1 ) * d ) ;
return make_pair ( a , d ) ; }
double findSum ( int m , int n , int mth , int nth , int p ) { pair < double , double > ad ;
ad = findingValues ( m , n , mth , nth ) ; double a = ad . first , d = ad . second ;
double sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 ;
return sum ; }
int main ( ) { double m = 6 , n = 10 , mTerm = 12 , nTerm = 20 , p = 5 ; cout << findSum ( m , n , mTerm , nTerm , p ) << endl ; return 0 ; }
void powerfulIntegers ( int x , int y , int bound ) {
set < int > s ; vector < int > powersOfY ; int i ;
powersOfY . push_back ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . push_back ( i ) ; i = 0 ; while ( true ) {
int xPowI = pow ( x , i ) ; for ( auto j = powersOfY . begin ( ) ; j != powersOfY . end ( ) ; ++ j ) { int num = xPowI + * j ;
if ( num <= bound ) s . insert ( num ) ;
else break ; }
if ( xPowI >= bound x == 1 ) break ;
i ++ ; }
set < int > :: iterator itr ; for ( itr = s . begin ( ) ; itr != s . end ( ) ; itr ++ ) { cout << * itr << " ▁ " ; } }
int main ( ) { int x = 2 , y = 3 , bound = 10 ;
powerfulIntegers ( x , y , bound ) ; return 0 ; }
void candies ( int n , int k ) {
int count = 0 ;
int ind = 1 ;
int arr [ k ] ; memset ( arr , 0 , sizeof ( arr ) ) ; while ( n ) {
int f1 = ( ind - 1 ) * k ; int f2 = ind * k ;
int sum1 = ( f1 * ( f1 + 1 ) ) / 2 ; int sum2 = ( f2 * ( f2 + 1 ) ) / 2 ;
int res = sum2 - sum1 ;
if ( res <= n ) { count ++ ; n -= res ; ind ++ ; }
{ int i = 0 ;
int term = ( ( ind - 1 ) * k ) + 1 ;
while ( n > 0 ) {
if ( term <= n ) { arr [ i ++ ] = term ; n -= term ; term ++ ; }
else { arr [ i ++ ] = n ; n = 0 ; } } } }
for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ;
for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int n = 10 , k = 3 ; candies ( n , k ) ; return 0 ; }
void candies ( int n , int k ) {
int count = 0 ;
int ind = 1 ;
int arr [ k ] ; memset ( arr , 0 , sizeof ( arr ) ) ; int low = 0 , high = n ;
while ( low <= high ) {
int mid = ( low + high ) >> 1 ; int sum = ( mid * ( mid + 1 ) ) >> 1 ;
if ( sum <= n ) {
count = mid / k ;
low = mid + 1 ; } else {
high = mid - 1 ; } }
int last = ( count * k ) ;
n -= ( last * ( last + 1 ) ) / 2 ; int i = 0 ;
int term = ( count * k ) + 1 ; while ( n ) { if ( term <= n ) { arr [ i ++ ] = term ; n -= term ; term ++ ; } else { arr [ i ] += n ; n = 0 ; } }
for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ;
for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int n = 7 , k = 4 ; candies ( n , k ) ; return 0 ; }
int printSmallest ( int a [ 3 ] ) { int sum , sum1 ;
sort ( a , a + 3 ) ; int i , j , k , num ;
for ( int i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] % 3 == 0 ) return a [ i ] ; }
for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) {
num = ( a [ i ] * 10 ) + a [ j ] ; if ( num % 3 == 0 ) return num ; } }
return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] ; }
int main ( ) { int arr [ ] = { 7 , 7 , 1 } ; cout << printSmallest ( arr ) ; return 0 ; }
void updateMatrix ( int n , int q [ 3 ] [ 4 ] ) { int i , j ; int mat [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) mat [ i ] [ j ] = 0 ; for ( i = 0 ; i < 3 ; i ++ ) { int X1 = q [ i ] [ 0 ] ; int Y1 = q [ i ] [ 1 ] ; int X2 = q [ i ] [ 2 ] ; int Y2 = q [ i ] [ 3 ] ;
mat [ X1 ] [ Y1 ] ++ ;
if ( Y2 + 1 < n ) mat [ X2 ] [ Y2 + 1 ] -- ; else if ( X2 + 1 < n ) mat [ X2 + 1 ] [ 0 ] -- ; }
int sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { sum += mat [ i ] [ j ] ;
cout << sum << " ▁ " ; }
cout << endl ; } }
int n = 5 ;
int q [ 3 ] [ 4 ] = { { 0 , 0 , 1 , 2 } , { 1 , 2 , 3 , 4 } , { 1 , 4 , 3 , 4 } } ; updateMatrix ( n , q ) ; return 0 ; }
void printArr ( float arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
void replaceMax ( float arr [ ] , int n ) {
float max = * std :: max_element ( arr , arr + n ) ;
float min = * std :: min_element ( arr , arr + n ) ;
float range = max - min ; float coeffOfRange = range / ( max + min ) ;
for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } }
printArr ( arr , n ) ; }
int main ( ) { float arr [ ] = { 15 , 16 , 10 , 9 , 6 , 7 , 17 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; replaceMax ( arr , n ) ; return 0 ; }
void divide ( int a , int b ) {
for ( int i = 2 ; i <= min ( a , b ) ; i ++ ) {
while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } cout << " A ▁ = ▁ " << a << " , ▁ B ▁ = ▁ " << b << endl ; }
int main ( ) { int A = 10 , B = 15 ;
divide ( A , B ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void commDiv ( int a , int b ) {
int n = gcd ( a , b ) ; a = a / n ; b = b / n ; cout << " A ▁ = ▁ " << a << " , ▁ B ▁ = ▁ " << b << endl ; }
int main ( ) { int a = 10 , b = 15 ; commDiv ( a , b ) ; return 0 ; }
int minAbsDiff ( int n ) {
int left = 1 << ( ( int ) floor ( log2 ( n ) ) ) ;
int right = left * 2 ;
return min ( ( n - left ) , ( right - n ) ) ; }
int main ( ) { int n = 15 ; cout << minAbsDiff ( n ) ; return 0 ; }
double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; }
int main ( ) { double p = 1 , q = 2 , r = 1 , s = 2 ;
cout << fixed << setprecision ( 9 ) << find_probability ( p , q , r , s ) ; return 0 ; }
void FindAllElements ( int n , int k ) {
int sum = k ;
int A [ k ] ; fill ( A , A + k , 1 ) ; for ( int i = k - 1 ; i >= 0 ; -- i ) {
while ( sum + A [ i ] <= n ) {
sum += A [ i ] ; A [ i ] *= 2 ; } }
if ( sum != n ) { cout << " Impossible " ; }
else { for ( int i = 0 ; i < k ; ++ i ) cout << A [ i ] << ' ▁ ' ; } }
int main ( ) { int n = 12 ; int k = 6 ; FindAllElements ( n , k ) ; return 0 ; }
int removeZero ( int n ) {
int res = 0 ;
int d = 1 ;
while ( n > 0 ) {
if ( n % 10 != 0 ) {
res += ( n % 10 ) * d ; d *= 10 ; }
n /= 10 ; }
return res ; }
bool isEqual ( int a , int b ) {
if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; }
int main ( ) { int a = 105 , b = 106 ; isEqual ( a , b ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void sumArray ( int arr [ ] , int n ) {
int leftSum [ n ] , rightSum [ n ] , Sum [ n ] , i , j ;
leftSum [ 0 ] = 0 ;
rightSum [ n - 1 ] = 0 ;
for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ;
for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ;
for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ;
for ( i = 0 ; i < n ; i ++ ) cout << Sum [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 3 , 6 , 4 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sumArray ( arr , n ) ; return 0 ; }
int minimumX ( int n , int k ) { int mini = INT_MAX ;
for ( int i = 1 ; i * i <= n ; i ++ ) {
if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ;
int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ;
if ( res == n ) mini = min ( num2 , mini ) ; } } return mini ; }
int main ( ) { int n = 4 , k = 6 ; cout << minimumX ( n , k ) << endl ; n = 5 , k = 5 ; cout << minimumX ( n , k ) << endl ; return 0 ; }
int minimumX ( int n , int k ) { int ans = INT_MAX ;
for ( int rem = k - 1 ; rem > 0 ; rem -- ) {
if ( n % rem == 0 ) ans = min ( ans , rem + ( n / rem ) * k ) ; } return ans ; }
int main ( ) { int n = 4 , k = 6 ; cout << minimumX ( n , k ) << endl ; n = 5 , k = 5 ; cout << minimumX ( n , k ) << endl ; return 0 ; }
int getHermiteNumber ( int n ) {
if ( n == 0 ) return 1 ; if ( n == 1 ) return 0 ; else return -2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; }
int main ( ) { int n = 6 ;
cout << getHermiteNumber ( n ) ; return 0 ; }
void find ( int n ) {
int b = n ; int a = b * ( n - 1 ) ;
if ( a * b > n && a / b < n ) { cout << " a ▁ = ▁ " << a << " , ▁ b ▁ = ▁ " << b ; }
else cout < < -1 << endl ; }
int main ( ) { int n = 10 ; find ( n ) ; return 0 ; }
bool isPerfect ( int N ) { if ( ( sqrt ( N ) - floor ( sqrt ( N ) ) ) != 0 ) return false ; return true ; }
void getClosestPerfectSquare ( int N ) { if ( isPerfect ( N ) ) { cout << N << " ▁ " << "0" << endl ; return ; }
int aboveN = -1 , belowN = -1 ; int n1 ;
n1 = N + 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; }
n1 = N - 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; }
int diff1 = aboveN - N ; int diff2 = N - belowN ; if ( diff1 > diff2 ) cout << belowN << " ▁ " << diff2 ; else cout << aboveN << " ▁ " << diff1 ; }
int main ( ) { int N = 1500 ; getClosestPerfectSquare ( N ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void lowest ( int & den3 , int & num3 ) {
int common_factor = gcd ( num3 , den3 ) ;
den3 = den3 / common_factor ; num3 = num3 / common_factor ; }
void addFraction ( int num1 , int den1 , int num2 , int den2 , int & num3 , int & den3 ) {
den3 = gcd ( den1 , den2 ) ;
den3 = ( den1 * den2 ) / den3 ;
num3 = ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ;
lowest ( den3 , num3 ) ; }
int main ( ) { int num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 , den3 , num3 ; addFraction ( num1 , den1 , num2 , den2 , num3 , den3 ) ; printf ( " % d / % d ▁ + ▁ % d / % d ▁ is ▁ equal ▁ to ▁ % d / % d STRNEWLINE " , num1 , den1 , num2 , den2 , num3 , den3 ) ; return 0 ; }
int findLargestDivisor ( int n ) { for ( int i = 2 ; i < sqrt ( n ) + 1 ; i ++ ) {
while ( n % ( i * i ) == 0 ) { n = n / i ; } }
return n ; }
int main ( ) { int n = 12 ; cout << findLargestDivisor ( n ) << endl ; n = 97 ; cout << findLargestDivisor ( n ) << endl ; return 0 ; }
bool checkIsAP ( int arr [ ] , int n ) { if ( n == 1 ) return true ;
sort ( arr , arr + n ) ;
int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; }
int main ( ) { int arr [ ] = { 20 , 15 , 5 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ( checkIsAP ( arr , n ) ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; return 0 ; }
bool isTriPerfect ( int n ) {
int sum = 1 + n ;
int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; }
if ( sum == 3 * n and n != 1 ) return true ; else false ; }
int main ( ) { int n = 120 ; if ( isTriPerfect ( n ) ) cout << n << " ▁ is ▁ a ▁ Triperfect ▁ number " ; }
int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; }
int main ( ) { int N = 14 ; int X = 3 , Y = 5 ; cout << sum ( N , X , Y ) ; return 0 ; }
int findTwoThreePrime ( int l , int r ) {
if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ;
while ( num % 2 == 0 ) num /= 2 ;
while ( num % 3 == 0 ) num /= 3 ;
if ( num == 1 ) count ++ ; } return count ; }
int main ( ) { int l = 1 , r = 10 ; cout << findTwoThreePrime ( l , r ) ; return 0 ; }
string getNumber ( string s ) { int number_of_digits = s . length ( ) ; int freq [ 10 ] = { 0 } ;
for ( int i = 0 ; i < number_of_digits ; i ++ ) { if ( s [ i ] == '1' s [ i ] == '2' s [ i ] == '3' s [ i ] == '5' s [ i ] == '7' ) { freq [ s [ i ] - 48 ] += 1 ; }
if ( s [ i ] == '4' ) { freq [ 2 ] += 2 ; freq [ 3 ] ++ ; }
if ( s [ i ] == '6' ) { freq [ 5 ] ++ ; freq [ 3 ] ++ ; }
if ( s [ i ] == '8' ) { freq [ 7 ] ++ ; freq [ 2 ] += 3 ; }
if ( s [ i ] == '9' ) { freq [ 7 ] ++ ; freq [ 3 ] += 2 ; freq [ 2 ] ++ ; } }
string t = " " ;
if ( freq [ 1 ] == number_of_digits || freq [ 0 ] == number_of_digits || ( freq [ 0 ] + freq [ 1 ] ) == number_of_digits ) { return s ; } else {
for ( int i = 9 ; i >= 2 ; i -- ) { int ctr = freq [ i ] ; while ( ctr -- ) { t += ( char ) ( i + 48 ) ; } } return t ; } }
int main ( ) { string s = "1280" ; cout << getNumber ( s ) ; return 0 ; }
int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
void icanobifNumbers ( int N ) {
int first = 0 , second = 1 ; if ( N == 1 ) cout << first ; else if ( N == 2 ) cout << first << " ▁ " << second ; else {
cout << first << " ▁ " << second << " ▁ " ; for ( int i = 3 ; i <= N ; i ++ ) {
int x = reversDigits ( first ) ; int y = reversDigits ( second ) ; cout << x + y << " ▁ " ; int temp = second ; second = x + y ; first = temp ; } } }
int main ( ) { int N = 12 ; icanobifNumbers ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int addNDigits ( int a , int b , int n ) { int num = a ;
for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } }
if ( num == a ) return -1 ;
for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; }
int main ( ) { int a = 5 , b = 3 , n = 3 ; cout << addNDigits ( a , b , n ) ; return 0 ; }
int Triplets ( int n ) {
int ans = 0 ;
for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ;
int y = sqrt ( x ) ;
if ( y * y == x && y <= n ) ++ ans ; } } return ans ; }
int main ( ) { int n = 10 ;
cout << Triplets ( n ) ; return 0 ; }
int solve ( int n , int base ) {
int sum = 0 ; while ( n > 0 ) {
int remainder = n % base ;
sum += remainder ; n = n / base ; } return sum ; }
void SumsOfDigits ( int n ) {
int sum = 0 ;
for ( int base = 2 ; base <= n / 2 ; ++ base ) sum += solve ( n , base ) ; cout << sum ; }
int main ( ) { int n = 8 ; SumsOfDigits ( n ) ; return 0 ; }
bool checkPerfectcube ( int n ) {
int d = cbrt ( n ) ;
if ( d * d * d == n ) return true ; return false ; }
int largestNonPerfectcubeNumber ( int a [ ] , int n ) {
int maxi = -1 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( ! checkPerfectcube ( a [ i ] ) ) maxi = max ( a [ i ] , maxi ) ; } return maxi ; }
int main ( ) { int a [ ] = { 16 , 64 , 25 , 2 , 3 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << largestNonPerfectcubeNumber ( a , n ) ; return 0 ; }
void checkIfPossibleRec ( int x , int a , int b , bool isPossible [ ] , int n ) {
if ( x > n ) return ;
if ( isPossible [ x ] ) return ;
isPossible [ x ] = true ;
checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; } bool checkPossible ( int n , int a , int b ) { bool isPossible [ n + 1 ] = { false } ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; }
int main ( ) { int a = 3 , b = 7 , n = 8 ; if ( checkPossible ( a , b , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int sumOdd ( int n ) { int terms = ( n + 1 ) / 2 ; int sum = terms * terms ; return sum ; }
int suminRange ( int l , int r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; }
int main ( ) { int l = 2 , r = 5 ; cout << " Sum ▁ of ▁ odd ▁ natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " << suminRange ( l , r ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int sumcommDiv ( int a , int b ) {
int n = gcd ( a , b ) ;
int sum = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) {
if ( n % i == 0 ) {
if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; }
int main ( ) { int a = 10 , b = 15 ; cout << " Sum ▁ = ▁ " << sumcommDiv ( a , b ) ; return 0 ; }
string checkNumber ( int N ) { int temp = N ; while ( temp > 0 ) {
if ( temp % 1000 == 144 ) temp /= 1000 ; else if ( temp % 100 == 14 ) temp /= 100 ; else if ( temp % 10 == 1 ) temp /= 10 ; else { return " NO " ; } } return " YES " ; }
int main ( ) { int N = 1414 ; cout << checkNumber ( N ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int getResult ( int n ) { if ( n & 1 ) return 1 ; return -1 ; }
int main ( ) { int n = 3 ; cout << getResult ( n ) ; }
void findAandB ( double N ) { double val = N * N - 4.0 * N ;
if ( val < 0 ) { cout << " NO " ; return ; }
double a = ( N + sqrt ( val ) ) / 2.0 ; double b = ( N - sqrt ( val ) ) / 2.0 ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; }
int main ( ) { double N = 69.0 ; findAandB ( N ) ; return 0 ; }
int minOperations ( int A [ ] , int n ) { if ( n & 1 ) return -1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { A [ i ] == 0 ? zeros ++ : ones ++ ;
if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } }
if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ;
if ( zeros == ones ) return consZeros ; else return -1 ; }
int main ( ) { int A [ ] = { 1 , 1 , 0 , 0 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minOperations ( A , n ) ; return 0 ; }
int countdig ( int m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( m / 10 ) ; }
int countSteps ( int x ) {
int c = 0 ; int last = x ;
while ( last ) {
int digits = countdig ( last ) ;
digits -= 1 ;
int divisor = pow ( 10 , digits ) ;
int first = last / divisor ;
int lastnumber = first * divisor ;
int skipped = ( last - lastnumber ) / first ; skipped += 1 ;
c += skipped ;
last = last - ( first * skipped ) ; } return c ; }
int main ( ) { int n = 14 ; cout << countSteps ( n ) ; return 0 ; }
ll power ( ll x , ll y , ll p ) {
while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; } ll gcd ( ll a , ll b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
ll powerGCD ( ll a , ll b , ll n ) { ll e = power ( a , n , b ) ; return gcd ( e , b ) ; }
int main ( ) { ll a = 5 , b = 4 , n = 2 ; cout << powerGCD ( a , b , n ) ; return 0 ; }
bool allOddDigits ( int n ) {
while ( n ) {
if ( ( n % 10 ) % 2 == 0 ) return false ; n /= 10 ; }
return true ; }
int largestNumber ( int n ) { if ( n % 2 == 0 ) n -- ;
for ( int i = n ; ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; }
int main ( ) { int N = 23 ; cout << largestNumber ( N ) ; return 0 ; }
int countNumbers ( int N ) { return int ( sqrt ( N ) ) - 1 ; }
int main ( ) { int N = 36 ; cout << countNumbers ( N ) ; return 0 ; }
int countOrderedPairs ( int N ) {
int count_pairs = 0 ;
for ( int i = 1 ; i <= sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; }
count_pairs *= 2 ;
count_pairs -= int ( sqrt ( N - 1 ) ) ;
return count_pairs ; }
int main ( ) { int N = 5 ;
cout << countOrderedPairs ( N ) ; return 0 ; }
void pairwiseDifference ( int arr [ ] , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) {
diff = abs ( arr [ i ] - arr [ i + 1 ] ) ; cout << diff << " ▁ " ; } }
int main ( ) { int arr [ ] = { 4 , 10 , 15 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pairwiseDifference ( arr , n ) ; return 0 ; }
long long sumAP ( long long n , long long d ) {
n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
long long sumMultiples ( long long n ) {
n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; }
int main ( ) { long long n = 20 ; cout << sumMultiples ( n ) ; return 0 ; }
int markingScheme ( int N , int answerKey [ ] , int studentAnswer [ ] ) { int positive = 0 , negative = 0 , notattempt = 0 ; for ( int i = 0 ; i < N ; i ++ ) {
if ( studentAnswer [ i ] == 0 ) notattempt ++ ;
else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ;
else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; }
return ( positive * 3 ) + ( negative * -1 ) ; }
int main ( ) { int answerKey [ ] = { 1 , 2 , 3 , 4 , 1 } ; int studentAnswer [ ] = { 1 , 2 , 3 , 4 , 0 } ; int N = sizeof ( answerKey ) / sizeof ( answerKey [ 0 ] ) ; cout << markingScheme ( N , answerKey , studentAnswer ) ; return 0 ; }
#include " cstring " NEW_LINE #include <iostream> NEW_LINE using namespace std ; #define MAX  10000
bool prime [ MAX + 1 ] ; void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
int solve ( int n ) {
int count = 0 , num = 1 ;
long long int prod = 1 ; while ( count < n ) {
if ( prime [ num ] ) { prod *= num ;
count ++ ; }
num ++ ; } return prod ; }
SieveOfEratosthenes ( ) ; int n = 5 ;
cout << solve ( n ) ; return 0 ; }
int Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ;
if ( l % k == 0 ) div_count ++ ;
return ( div_count > 1 ) ; }
int main ( ) { int l = 30 , r = 70 , k = 10 ; if ( Check_is_possible ( l , r , k ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; return 0 ; }
int nth_group ( int n ) { return n * ( 2 * pow ( n , 2 ) + 1 ) ; }
int main ( ) { int N = 5 ; cout << nth_group ( N ) ; return 0 ; }
void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) cout << " NO " ; else cout << " YES " ; }
int main ( ) { int a = 2 , b = 4 , c = 2 ; printPossible ( a , b , c ) ; return 0 ; }
void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; cout << r ; }
int main ( ) { int N = 5 ; Sum_upto_nth_Term ( N ) ; return 0 ; }
int CalculateDifference ( int arr [ ] , int n ) {
int max_val = * max_element ( arr , arr + n ) ;
vector < bool > prime ( max_val + 1 , true ) ;
prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } }
int S1 = 0 , S2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) {
S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) {
S2 += arr [ i ] ; } }
return abs ( S2 - S1 ) ; }
int arr [ ] = { 1 , 3 , 5 , 10 , 15 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << CalculateDifference ( arr , n ) ; return 0 ; }
int numberOfDivisors ( int num ) { int c = 0 ;
for ( int i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; }
int countNumbers ( int n ) { int c = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) {
if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; }
int main ( ) { int n = 1000 ; cout << countNumbers ( n ) ; return 0 ; }
int numberOfDistinct ( int n ) { int ans = 0 ;
for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; }
int main ( ) { int n = 3 ; cout << numberOfDistinct ( n ) ; return 0 ; }
int NumberOfRectangles ( int n , int m ) {
if ( n % 2 == 0 ) return ( n / 2 ) * m ;
else if ( m % 2 == 0 ) return ( m / 2 ) * n ;
return ( n * m - 1 ) / 2 ; }
int main ( ) { int n = 3 , m = 3 ;
cout << NumberOfRectangles ( n , m ) ; return 0 ; }
long findNumUtil ( long res , int a , int aCount , int b , int bCount , int n ) { if ( res > 1e11 ) return 1e11 ;
if ( aCount == bCount && res >= n ) return res ;
return min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; }
int findNum ( int n , int a , int b ) { int result = 0 ; int aCount = 0 ; int bCount = 0 ; return findNumUtil ( result , a , aCount , b , bCount , n ) ; }
int main ( ) { int N = 4500 ; int A = 4 ; int B = 7 ; cout << findNum ( N , A , B ) ; return 0 ; }
int main ( ) { int n = 7 , k = 3 ; if ( n % k == 0 ) cout << n / k << " ▁ " << n / k ; else cout << ( ( n - ( n % k ) ) / k ) << " ▁ " << ( ( ( n - ( n % k ) ) / k ) + 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { float m = 50 , n = 5 , x = 67 , h = 2927 ;
int z = ( ceil ( h / 60 * 1.0 ) ) ; if ( z <= n ) cout << z * m ; else cout << n * m + ( z - n ) * x ; return 0 ; }
double sumProductDifference ( int a , int b , int c , int d , int e ) {
double rootSum = ( double ) ( -1 * b ) / a ;
double rootProduct = ( double ) e / a ;
return abs ( rootSum - rootProduct ) ; }
int main ( ) { cout << sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ; return 0 ; }
int numberOfSolutions ( int n ) {
int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + n ^ x ) ++ c ; return c ; }
int main ( ) { int n = 3 ; cout << numberOfSolutions ( n ) ; return 0 ; }
int minimumLectures ( int m , int n ) { int ans = 0 ;
if ( n < ( int ) ceil ( 0.75 * m ) ) ans = ( int ) ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; }
int main ( ) { int M = 9 , N = 1 ; cout << minimumLectures ( M , N ) ; return 0 ; }
int countNumbers ( int N ) { return ( pow ( 10 , N ) - pow ( 8 , N ) ) / 2 ; }
int main ( ) { int n = 5 ; cout << countNumbers ( n ) << endl ; return 0 ; }
int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; }
int n = 3 ;
cout << " Sum ▁ = ▁ " << calculateSum ( n ) ; return 0 ; }
void checkSolution ( int a , int b , int c ) {
if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) cout << "2 ▁ solutions " ;
else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) cout << "1 ▁ solution " ;
else cout < < " No ▁ solutions " ; }
int main ( ) { int a = 2 , b = 5 , c = 2 ; checkSolution ( a , b , c ) ; return 0 ; }
long Bits ( int kilobytes ) { long Bits = 0 ;
Bits = kilobytes * 8192 ; return Bits ; }
long Bytes ( int kilobytes ) { long Bytes = 0 ;
Bytes = kilobytes * 1024 ; return Bytes ; }
int main ( ) { int kilobytes = 1 ; cout << kilobytes << " ▁ Kilobytes ▁ = ▁ " << Bytes ( kilobytes ) << " ▁ Bytes ▁ and ▁ " << Bits ( kilobytes ) << " ▁ Bits . " ; return 0 ; }
int n = 3 ;
int a [ ] = { 1 , 2 , 3 } ;
int i = 0 ;
long sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; }
long x = sum / n ;
if ( x * n == sum ) cout << x << endl ; else cout << ( " - 1" ) << endl ; return 0 ; }
double findSum ( ll n ) {
return sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; }
ll n = 10 ; cout << findSum ( n ) << endl ; return 0 ; }
int sum ( int x , int y , int n ) {
int sum1 = ( pow ( x , 2 ) * ( pow ( x , 2 * n ) - 1 ) ) / ( pow ( x , 2 ) - 1 ) ;
int sum2 = ( x * y * ( pow ( x , n ) * pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; }
int main ( ) { int x = 2 , y = 2 , n = 2 ;
cout << sum ( x , y , n ) ; return 0 ; }
void printPair ( int g , int l ) { cout << g << " ▁ " << l ; }
int main ( ) { int g = 3 , l = 12 ; printPair ( g , l ) ; return 0 ; }
int calculateSum ( int n ) {
int a1 = 1 , a2 = 2 ;
int r = 2 ;
int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ; }
int n = 5 ;
cout << " Sum ▁ = ▁ " << calculateSum ( n ) ; return 0 ; }
bool ispower ( ll n ) { if ( n < 125 ) return ( n == 1 n == 5 n == 25 ) ; if ( n % 125 != 0 ) return false ; else return ispower ( n / 125 ) ; }
ll number ( string s , int i , int j ) { ll ans = 0 ; for ( int x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s [ x ] - '0' ) ; } return ans ; }
int minCuts ( string s , int n ) { int dp [ n + 1 ] ;
memset ( dp , n + 1 , sizeof ( dp ) ) ; dp [ 0 ] = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) {
if ( s [ i - 1 ] == '0' ) continue ; for ( int j = 0 ; j < i ; j ++ ) {
if ( s [ j ] == '0' ) continue ;
ll num = number ( s , j , i ) ;
if ( ! ispower ( num ) ) continue ;
dp [ i ] = min ( dp [ i ] , dp [ j ] + 1 ) ; } }
return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : -1 ) ; }
int main ( ) { string s = "101101101" ; int n = s . length ( ) ; cout << minCuts ( s , n ) ; return 0 ; }
int MinOfCubed ( int k ) {
if ( k < 8 ) return k ;
int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; }
int main ( ) { int num = 15 ; cout << MinOfCubed ( num ) ; return 0 ; }
int MinOfCubedDP ( int k ) { int * DP = new int [ k + 1 ] , j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = INT_MAX ;
while ( j <= i ) {
if ( j == i ) DP [ i ] = 1 ;
else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ;
t ++ ; j = t * t * t ; }
t = j = 1 ; } return DP [ k ] ; }
int main ( ) { int num = 15 ; cout << MinOfCubedDP ( num ) ; return 0 ; }
int maxSum ( int a [ ] , int n ) { int ans = 0 ; int * arr = new int [ n + 1 ] ;
for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ;
int * * dp = new int * [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = new int [ 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) {
dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ;
dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ;
if ( i >= 2 ) dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ;
if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ;
if ( i >= 3 ) dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ;
ans = max ( ans , dp [ i ] [ 0 ] ) ; ans = max ( ans , dp [ i ] [ 1 ] ) ; ans = max ( ans , dp [ i ] [ 2 ] ) ; }
return ans ; }
int main ( ) { int arr [ ] = { -5 , 3 , 2 , 7 , -8 , 3 , 7 , -9 , 10 , 12 , -6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) ; return 0 ; }
int MinimumCost ( int a [ ] , int n , int x ) {
for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = min ( a [ i ] , 2 * a [ i - 1 ] ) ; } int ind = 0 ; int sum = 0 ;
while ( x ) {
if ( x & 1 ) sum += a [ ind ] ;
ind ++ ;
x = x >> 1 ; } return sum ; }
int main ( ) { int a [ ] = { 20 , 50 , 60 , 90 } ; int x = 7 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinimumCost ( a , n , x ) ; return 0 ; }
int countWays ( int n , int l , int r ) { int tL = l , tR = r ;
int L [ 2 ] = { 0 } , R [ 2 ] = { 0 } ; L [ l % 2 ] = l , R [ r % 2 ] = r ; l ++ , r -- ; if ( l <= tR && r >= tL ) L [ l % 2 ] = l , R [ r % 2 ] = r ;
int cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] && L [ 0 ] ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] && L [ 1 ] ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; int dp [ n ] [ 2 ] ;
dp [ 1 ] [ 0 ] = cnt0 ; dp [ 1 ] [ 1 ] = cnt1 ; for ( int i = 2 ; i <= n ; i ++ ) {
dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) ;
dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) ; }
return dp [ n ] [ 0 ] ; }
int main ( ) { int n = 2 , l = 1 , r = 3 ; cout << countWays ( n , l , r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int M = 1001 ; const int MOD = 998244353 ; int dp [ M ] [ M ] ;
int solve ( int idx , int diff , int N , int M , int K ) {
if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; }
if ( dp [ idx ] [ diff ] != -1 ) return dp [ idx ] [ diff ] ;
int ans = solve ( idx + 1 , diff , N , M , K ) ;
ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx ] [ diff ] = ans % MOD ; }
int main ( ) { int N = 3 , M = 3 , K = 0 ; memset ( dp , -1 , sizeof ( dp ) ) ;
cout << ( M * solve ( 2 , 0 , N , M , K ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3
int maxPathSum ( int tri [ ] [ N ] ) { int ans = 0 ;
for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) {
if ( j - 1 >= 0 ) tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = max ( ans , tri [ i ] [ j ] ) ; } }
return ans ; }
int main ( ) { int tri [ N ] [ N ] = { { 1 , 5 , 3 } , { 4 , 8 , 0 } , { 1 , 0 , 0 } } ; cout << maxPathSum ( tri ) ; return 0 ; }
int subsetXOR ( int arr [ ] , int n , int K ) {
int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ;
int m = ( 1 << ( int ) ( log2 ( max_ele ) + 1 ) ) - 1 ;
int dp [ n + 1 ] [ m + 1 ] [ n + 1 ] ;
for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) dp [ i ] [ j ] [ k ] = 0 ;
for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ;
for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( k != 0 ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } }
int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int k = 1 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << subsetXOR ( arr , n , k ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int get_max_splits ( string num_string ) {
int count = 0 , current_num ;
int running_sum = 0 ; for ( int i = 0 ; i < num_string . length ( ) ; i ++ ) { current_num = num_string [ i ] - '0' ; running_sum += current_num ;
if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; }
int main ( ) { cout << get_max_splits ( "12345" ) << endl ; return 0 ; }
int findMinimumCost ( int n , int x , int y ) { int * dp = new int [ n + 1 ] ;
dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i & 1 ) {
dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else {
dp [ i ] = min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; }
int main ( ) { int n = 4 , x = 2 , y = 1 ; cout << findMinimumCost ( n , x , y ) ; return 0 ; }
int nCr ( int n , int r ) { int ans = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; i ++ ) { ans *= ( n - i ) ; ans /= ( i + 1 ) ; } return ans ; }
int countDerangements ( int n ) { int der [ n + 1 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; }
ll countPermutations ( int n , int k ) { ll ans = 0 ; for ( int i = n - k ; i <= n ; i ++ ) {
int ways = nCr ( n , i ) ;
ans += ways * countDerangements ( n - i ) ; } return ans ; }
int main ( ) { int n = 5 , k = 3 ; cout << countPermutations ( n , k ) ; return 0 ; }
int squares ( int i ) { if ( ( i & 1 ) == 1 ) return i / 4 * 2 + 1 ; else return ( i - 1 ) / 4 * 2 + 2 ; }
long bishop_placements ( int n , int k ) {
if ( k > 2 * n - 1 ) return 0 ;
long dp [ n * 2 ] [ k + 1 ] ;
for ( int i = 0 ; i < n * 2 ; i ++ ) { for ( int j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < n * 2 ; i ++ ) dp [ i ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = 1 ;
for ( int i = 2 ; i < n * 2 ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) { dp [ i ] [ j ] = dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ; } }
long ans = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ; } return ans ; }
int main ( ) { int n = 2 ; int k = 2 ; long ans = bishop_placements ( n , k ) ; cout << ( ans ) ; }
int countStaircases ( int N ) {
for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { memo [ i ] [ j ] = 0 ; } }
memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 ; for ( int i = 5 ; i <= N ; i ++ ) { for ( int j = 2 ; j <= i ; j ++ ) {
if ( j == 2 ) { memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 ; }
else { memo [ i ] [ j ] = memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ; } } }
int answer = 0 ; for ( int i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N ] [ i ] ; return answer ; }
int main ( ) { int N = 7 ; cout << countStaircases ( N ) ; return 0 ; }
int countPaths ( int m , int n ) {
if ( m == 1 n == 1 ) return 1 ;
return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; }
int main ( ) { int n = 5 ; int m = 5 ; cout << countPaths ( n , m ) ; return 0 ; }
int countPaths ( int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; }
int main ( ) { int n = 5 ; int m = 5 ; cout << countPaths ( n , m ) ; return 0 ; }
unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ;
if ( k > n - k ) k = n - k ;
for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
unsigned long int catalan ( unsigned int n ) {
unsigned long int c = binomialCoeff ( 2 * n , n ) ;
return c / ( n + 1 ) ; }
int main ( ) { int n = 3 ; cout << catalan ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void alternateFib ( int n ) { if ( n < 0 ) return ;
int f1 = 0 ; int f2 = 1 ; cout << f1 << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) cout << f3 << " ▁ " ; f1 = f2 ; f2 = f3 ; } }
int main ( ) { int N = 15 ; alternateFib ( N ) ; return 0 ; }
int totalWays ( int N , int M , int X ) {
int dp [ N + 1 ] [ 2 ] ;
if ( X == 1 ) {
dp [ 0 ] [ 0 ] = 1 ; } else {
dp [ 0 ] [ 1 ] = 0 ; }
if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; }
else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; }
for ( int i = 2 ; i < N ; i ++ ) {
dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ;
dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; }
return dp [ N - 1 ] [ 0 ] ; }
int main ( ) { int N = 4 , M = 3 , X = 2 ; cout << totalWays ( N , M , X ) << endl ; return 0 ; }
int fib ( int n ) {
if ( n <= 1 ) return n ;
return fib ( n - 1 ) + fib ( n - 2 ) ; }
int main ( ) { int n = 6 ; printf ( " % d " , fib ( n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100
int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ;
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int sumOfproduct ( int n ) { return binomialCoeff ( 2 * n , n - 1 ) ; }
int main ( ) { int n = 3 ; cout << sumOfproduct ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using std :: cout ; void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) cout << a << " ▁ " ; if ( n >= 1 ) cout << b << " ▁ " ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; cout << c << " ▁ " ; a = b ; b = c ; } }
int main ( ) { fib ( 9 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll pre_compute ( ll a [ ] , ll n , ll index , ll k ) { ll dp [ n ] [ n ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; }
for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } }
return dp [ index ] [ k ] ; }
int main ( ) { ll a [ ] = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; ll n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; ll index = 4 , k = 6 ; printf ( " % lld " , pre_compute ( a , n , index , k ) ) ; return 0 ; }
int gen ( int n ) { int S [ n + 1 ] ; S [ 0 ] = 0 ; S [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) {
if ( i % 2 == 0 ) S [ i ] = 4 * S [ i / 2 ] ;
else S [ i ] = 4 * S [ i / 2 ] + 1 ; } return S [ n ] ; }
void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << gen ( i ) << " ▁ " ; cout << " STRNEWLINE " ; }
int main ( ) { int n = 15 ; cout << " First ▁ " << n << " ▁ terms ▁ of ▁ " << " Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ STRNEWLINE " ; moserDeBruijn ( n ) ; return 0 ; }
int LCSubStr ( string X , string Y ) {
int m = X . length ( ) ; int n = Y . length ( ) ;
int result = 0 ;
int len [ 2 ] [ n ] ;
int currRow = 0 ;
for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow ] [ j ] = len [ 1 - currRow ] [ j - 1 ] + 1 ; result = max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } }
currRow = 1 - currRow ; } return result ; }
int main ( ) { string X = " GeeksforGeeks " ; string Y = " GeeksQuiz " ; cout << LCSubStr ( X , Y ) ; return 0 ; }
int minimalSteps ( string s , int n ) { int dp [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = INT_MAX ;
string s1 = " " , s2 = " " ;
dp [ 0 ] = 1 ; s1 += s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s [ i ] ;
s2 = s . substr ( i + 1 , i + 1 ) ;
dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) ;
if ( s1 == s2 ) dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; }
int main ( ) { string s = " aaaaaaaa " ; int n = s . length ( ) ;
cout << minimalSteps ( s , n ) ; return 0 ; }
void printGolomb ( int n ) { int dp [ n + 1 ] ;
dp [ 1 ] = 1 ; cout << dp [ 1 ] << " ▁ " ;
for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; cout << dp [ i ] << " ▁ " ; } }
int main ( ) { int n = 9 ; printGolomb ( n ) ; return 0 ; }
int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
current_sum += ( str [ i ] == '0' ? 1 : -1 ) ; if ( current_sum < 0 ) current_sum = 0 ;
max_sum = max ( current_sum , max_sum ) ; }
return max_sum == 0 ? -1 : max_sum ; }
int main ( ) { string s = "11000010001" ; int n = 11 ; cout << findLength ( s , n ) << endl ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE int static const DP_s = 9 ; int getNumStrictMonotone ( int len ) {
int DP [ len ] [ DP_s ] ; memset ( DP , 0 , sizeof ( DP ) ) ;
for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ;
for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; }
int main ( ) { std :: cout << getNumStrictMonotone ( 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int chordCnt ( int A ) {
int n = 2 * A ;
int dpArray [ n + 1 ] = { 0 } ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } }
return dpArray [ n ] ; }
int main ( ) { int N ; N = 2 ; cout << chordCnt ( N ) << ' ' ; N = 1 ; cout << chordCnt ( N ) << ' ' ; N = 4 ; cout << chordCnt ( N ) << ' ' ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define row  5 NEW_LINE #define col  5
bool isPath ( int arr [ row ] [ col ] ) {
arr [ 0 ] [ 0 ] = 1 ;
for ( int i = 1 ; i < row ; i ++ ) if ( arr [ i ] [ 0 ] != -1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( int j = 1 ; j < col ; j ++ ) if ( arr [ 0 ] [ j ] != -1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ;
for ( int i = 1 ; i < row ; i ++ ) for ( int j = 1 ; j < col ; j ++ ) if ( arr [ i ] [ j ] != -1 ) arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ;
return ( arr [ row - 1 ] [ col - 1 ] == 1 ) ; }
int arr [ row ] [ col ] = { { 0 , 0 , 0 , -1 , 0 } , { -1 , 0 , 0 , -1 , -1 } , { 0 , 0 , 0 , -1 , 0 } , { -1 , 0 , -1 , 0 , -1 } , { 0 , 0 , -1 , 0 , 0 } } ;
if ( isPath ( arr ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int nswp ( int n ) {
if ( n == 0 n == 1 ) return 1 ;
return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; }
int main ( ) { int n = 3 ; cout << nswp ( n ) << endl ; return 0 ; }
int nswp ( int n ) { int dp [ n + 1 ] ;
dp [ 0 ] = dp [ 1 ] = 1 ;
for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; }
int main ( ) { int n = 3 ; cout << nswp ( n ) << endl ; return 0 ; }
int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ;
for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ;
else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( X [ i - 1 ] - '0' ) ;
else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; }
int findMinCost ( char X [ ] , char Y [ ] ) {
int m = strlen ( X ) , n = strlen ( Y ) ;
int cost = 0 ;
for ( int i = 0 ; i < m ; ++ i ) cost += X [ i ] - '0' ; for ( int i = 0 ; i < n ; ++ i ) cost += Y [ i ] - '0' ; return cost - lcs ( X , Y , m , n ) ; }
int main ( ) { char X [ ] = "3759" ; char Y [ ] = "9350" ; cout << " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ " << " identical ▁ is ▁ = ▁ " << findMinCost ( X , Y ) ; return 0 ; }
bool isSubSeqDivisible ( string str ) { int n = str . length ( ) ; int dp [ n + 1 ] [ 10 ] ; memset ( dp , 0 , sizeof ( dp ) ) ;
int arr [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = str [ i - 1 ] - '0' ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j < 8 ; j ++ ) {
if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ;
if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) {
if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; }
int main ( ) { string str = "3144" ; if ( isSubSeqDivisible ( str ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxLength ( char s [ ] , int n ) { int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ;
for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ( ' && s [ i + 1 ] == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ;
for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ( ' && s [ j ] == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; }
int main ( ) { char s [ ] = " ( ) ( ( ( ( ( ( ) " ; int n = strlen ( s ) ; cout << maxLength ( s , n ) << endl ; return 0 ; }
int smallestSumSubarr ( int arr [ ] , int n ) {
int min_ending_here = INT_MAX ;
int min_so_far = INT_MAX ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ;
else min_ending_here += arr [ i ] ;
min_so_far = min ( min_so_far , min_ending_here ) ; }
return min_so_far ; }
int main ( ) { int arr [ ] = { 3 , -4 , 2 , -3 , -1 , 7 , -5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Smallest ▁ sum : ▁ " << smallestSumSubarr ( arr , n ) ; return 0 ; }
long countWays ( int n , int k ) {
long total = k ; int mod = 1000000007 ;
int same = 0 , diff = k ;
for ( int i = 2 ; i <= n ; i ++ ) {
same = diff ;
diff = total * ( k - 1 ) ; diff = diff % mod ;
total = ( same + diff ) % mod ; } return total ; }
int main ( ) { int n = 3 , k = 2 ; cout << countWays ( n , k ) << endl ; return 0 ; }
int sumOfSubstrings ( string num ) {
long long int mf = 1 ; for ( int i = num . size ( ) - 1 ; i >= 0 ; i -- ) {
sum += ( num [ i ] - '0' ) * ( i + 1 ) * mf ;
mf = mf * 10 + 1 ; } return sum ; }
int main ( ) { string num = "6759" ; cout << sumOfSubstrings ( num ) << endl ; return 0 ; }
int maxSumWithK ( int a [ ] , int n , int k ) {
int maxSum [ n ] ; maxSum [ 0 ] = a [ 0 ] ;
int curr_max = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; }
int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += a [ i ] ;
int result = sum ; for ( int i = k ; i < n ; i ++ ) {
sum = sum + a [ i ] - a [ i - k ] ;
result = max ( result , sum ) ;
result = max ( result , sum + maxSum [ i - k ] ) ; } return result ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 , -10 , -3 } ; int k = 4 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxSumWithK ( a , n , k ) ; return 0 ; }
int countWays ( int arr [ ] , int m , int N ) { int count [ N + 1 ] ; memset ( count , 0 , sizeof ( count ) ) ;
count [ 0 ] = 1 ;
for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < m ; j ++ )
if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ;
return count [ N ] ; }
int main ( ) { int arr [ ] = { 1 , 5 , 6 } ; int m = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int N = 7 ; cout << " Total ▁ number ▁ of ▁ ways ▁ = ▁ " << countWays ( arr , m , N ) ; return 0 ; }
int getTotalNumberOfSequences ( int m , int n ) {
if ( m < n ) return 0 ;
if ( n == 0 ) return 1 ;
return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; }
int main ( ) { int m = 10 ; int n = 4 ; cout << " Total ▁ number ▁ of ▁ possible ▁ sequences ▁ " << getTotalNumberOfSequences ( m , n ) ; return 0 ; }
int getTotalNumberOfSequences ( int m , int n ) {
int T [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) {
if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ;
else if ( i < j ) T [ i ] [ j ] = 0 ;
else if ( j == 1 ) T [ i ] [ j ] = i ;
else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; }
int main ( ) { int m = 10 ; int n = 4 ; printf ( " Total ▁ number ▁ of ▁ possible ▁ sequences ▁ % d " , getTotalNumberOfSequences ( m , n ) ) ; return 0 ; }
int lis ( int arr [ ] , int n ) { int result = 0 ; int lis [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ;
for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ;
for ( int i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; }
int minimumNumberOfDeletions ( int arr [ ] , int n ) {
int len = lis ( arr , n ) ;
return ( n - len ) ; }
int main ( ) { int arr [ ] = { 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ " << minimumNumberOfDeletions ( arr , n ) ; return 0 ; }
int lps ( string str ) { int n = str . size ( ) ;
int L [ n ] [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ;
for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } }
return L [ 0 ] [ n - 1 ] ; }
int minimumNumberOfDeletions ( string str ) { int n = str . size ( ) ;
int len = lps ( str ) ;
return ( n - len ) ; }
int main ( ) { string str = " geeksforgeeks " ; cout << " Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ " << minimumNumberOfDeletions ( str ) ; return 0 ; }
int offeringNumber ( int n , int templeHeight [ ] ) {
for ( int i = 0 ; i < n ; ++ i ) {
int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; }
for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; }
sum += max ( right , left ) + 1 ; } return sum ; }
int main ( ) { int arr1 [ 3 ] = { 1 , 2 , 2 } ; cout << offeringNumber ( 3 , arr1 ) << " STRNEWLINE " ; int arr2 [ 6 ] = { 1 , 4 , 3 , 6 , 2 , 1 } ; cout << offeringNumber ( 6 , arr2 ) << " STRNEWLINE " ; return 0 ; }
bool modularSum ( int arr [ ] , int n , int m ) { if ( n > m ) return true ;
bool DP [ m ] ; memset ( DP , false , m ) ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( DP [ 0 ] ) return true ;
bool temp [ m ] ; memset ( temp , false , m ) ;
for ( int j = 0 ; j < m ; j ++ ) {
if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false )
temp [ ( j + arr [ i ] ) % m ] = true ; } }
for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ;
DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; }
int main ( ) { int arr [ ] = { 1 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 5 ; modularSum ( arr , n , m ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; return 0 ; }
int maxSum ( int tri [ ] [ 3 ] , int n ) {
if ( n > 1 ) tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] ; tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] ;
for ( int i = 2 ; i < n ; i ++ ) { tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] ; tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] ;
for ( int j = 1 ; j < i ; j ++ ) {
if ( tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ) tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] ; else tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ; } }
int max = tri [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 ] [ i ] ) max = tri [ n - 1 ] [ i ] ; } return max ; }
int main ( ) { int tri [ 3 ] [ 3 ] = { { 1 } , { 2 , 1 } , { 3 , 3 , 2 } } ; cout << maxSum ( tri , 3 ) ; return 0 ; }
int maximumDifferenceSum ( int arr [ ] , int N ) {
int dp [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) {
dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) ;
dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; }
int main ( ) { int arr [ ] = { 3 , 2 , 1 , 4 , 5 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumDifferenceSum ( arr , N ) << endl ; return 0 ; }
#define N  8
int dx [ ] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 } ; int dy [ ] = { 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 } ;
bool inside ( int x , int y ) { return ( x >= 0 and x < N and y > = 0 and y < N ) ; }
double findProb ( int start_x , int start_y , int steps ) {
double dp1 [ N ] [ N ] [ steps + 1 ] ;
for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) dp1 [ i ] [ j ] [ 0 ] = 1 ;
for ( int s = 1 ; s <= steps ; ++ s ) {
for ( int x = 0 ; x < N ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) { double prob = 0.0 ;
for ( int i = 0 ; i < 8 ; ++ i ) { int nx = x + dx [ i ] ; int ny = y + dy [ i ] ;
if ( inside ( nx , ny ) ) prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 ; }
dp1 [ x ] [ y ] [ s ] = prob ; } } }
return dp1 [ start_x ] [ start_y ] [ steps ] ; }
int K = 3 ;
cout << findProb ( 0 , 0 , K ) << endl ; return 0 ; }
int countSubarray ( int arr [ ] , int n , int k ) {
int s = 0 ;
int i = 0 ; while ( i < n ) {
if ( arr [ i ] > k ) { i ++ ; continue ; }
int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; }
s += ( ( count * ( count + 1 ) ) / 2 ) ; } return ( n * ( n + 1 ) / 2 - s ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int k = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countSubarray ( arr , n , k ) ; return 0 ; }
int nCr ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ; int i , j ;
for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) {
if ( j == 0 j == i ) C [ i ] [ j ] = 1 ;
else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
double resultOfAllSubsets ( int arr [ ] , int N ) {
int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ;
for ( int n = 1 ; n <= N ; n ++ )
result += ( double ) ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; }
int main ( ) { int arr [ ] = { 2 , 3 , 5 , 7 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << resultOfAllSubsets ( arr , N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int arr [ ] = { 100 , 1000 , 100 , 1000 , 1 } ; int sum [ 10000 ] ;
int maxSumWO3Consec ( int n ) { if ( sum [ n ] != -1 ) return sum [ n ] ;
if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ;
return sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; }
int main ( ) { int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; memset ( sum , -1 , sizeof ( sum ) ) ; cout << maxSumWO3Consec ( n ) ; return 0 ; }
int maxSumPair ( int arr [ ] , int N , int k ) { int maxSum = 0 ;
sort ( arr , arr + N ) ;
for ( int i = N - 1 ; i > 0 ; -- i ) {
if ( arr [ i ] - arr [ i - 1 ] < k ) {
maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ;
-- i ; } } return maxSum ; }
int main ( ) { int arr [ ] = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 4 ; cout << maxSumPair ( arr , N , K ) ; return 0 ; }
int countGroups ( int position , int previous_sum , int length , char * num ) {
if ( position == length ) return 1 ; int res = 0 ;
int sum = 0 ;
for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ;
if ( sum >= previous_sum )
res += countGroups ( i + 1 , sum , length , num ) ; }
return res ; }
int main ( ) { char num [ ] = "1119" ; int len = strlen ( num ) ; cout << countGroups ( 0 , 0 , len , num ) ; return 0 ; }
int count ( string a , string b ) { int m = a . length ( ) ; int n = b . length ( ) ;
int lookup [ m + 1 ] [ n + 1 ] = { { 0 } } ;
for ( int i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ;
for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) {
if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else
lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; }
int main ( ) { string a = " GeeksforGeeks " ; string b = " Gks " ; cout << count ( a , b ) ; return 0 ; }
int lcs ( string & X , string & Y ) {
int m = X . length ( ) , n = Y . length ( ) ; int L [ 2 ] [ n + 1 ] ;
bool bi ; for ( int i = 0 ; i <= m ; i ++ ) {
bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } }
return L [ bi ] [ n ] ; }
int main ( ) { string X = " AGGTAB " ; string Y = " GXTXAYB " ; printf ( " Length ▁ of ▁ LCS ▁ is ▁ % d STRNEWLINE " , lcs ( X , Y ) ) ; return 0 ; }
int subsetXOR ( int arr [ ] , int n , int k ) {
int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ;
int m = ( 1 << ( int ) ( log2 ( max_ele ) + 1 ) ) - 1 ; if ( k > m ) return 0 ;
for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = 0 ;
dp [ 0 ] [ 0 ] = 1 ;
for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ;
return dp [ n ] [ k ] ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ subsets ▁ is ▁ " << subsetXOR ( arr , n , k ) ; return 0 ; }
int countSol ( int coeff [ ] , int start , int end , int rhs ) {
if ( rhs == 0 ) return 1 ;
int result = 0 ;
for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; }
int main ( ) { int coeff [ ] = { 2 , 2 , 5 } ; int rhs = 4 ; int n = sizeof ( coeff ) / sizeof ( coeff [ 0 ] ) ; cout << countSol ( coeff , 0 , n - 1 , rhs ) ; return 0 ; }
int steps ( int source , int step , int dest ) {
if ( abs ( source ) > ( dest ) ) return INT_MAX ; if ( source == dest ) return step ;
int pos = steps ( source + step + 1 , step + 1 , dest ) ;
int neg = steps ( source - step - 1 , step + 1 , dest ) ;
return min ( pos , neg ) ; }
int main ( ) { int dest = 11 ; cout << " No . ▁ of ▁ steps ▁ required ▁ to ▁ reach ▁ " << dest << " ▁ is ▁ " << steps ( 0 , 0 , dest ) ; return 0 ; }
int lcs ( int i , int j , int count ) { if ( i == 0 j == 0 ) return count ; if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; }
int main ( ) { int n , m ; X = " abcdxyz " ; Y = " xyzabcd " ; n = X . size ( ) ; m = Y . size ( ) ; cout << lcs ( n , m , 0 ) ; return 0 ; }
int no_of_characters ( int M ) {
int k = 1 ;
while ( true ) {
if ( pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; }
return k ; }
void print_string ( int M ) { int k , num , N ;
k = no_of_characters ( M ) ;
N = M - ( pow ( 2 , k ) - 2 ) ;
while ( k > 0 ) { num = pow ( 2 , k - 1 ) ; if ( num >= N ) cout << " A " ; else { cout << " B " ; N -= num ; } k -- ; }
cout << endl ; }
int main ( ) { int M ; M = 30 ; print_string ( M ) ; M = 55 ; print_string ( M ) ; M = 100 ; print_string ( M ) ; return 0 ; }
string updateString ( string S , string A , string B ) { int l = A . length ( ) ;
for ( int i = 0 ; i + l <= S . length ( ) ; i ++ ) {
string curr = S . substr ( i , i + l ) ;
if ( curr == A ) {
string new_string = " " ; new_string += S . substr ( 0 , i ) + B + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } else {
string new_string = " " ; new_string += S . substr ( 0 , i ) + A + S . substr ( i + l , S . length ( ) ) ; S = new_string ; i += l - 1 ; } }
return S ; }
int main ( ) { string S = " aab " ; string A = " aa " ; string B = " bb " ; cout << ( updateString ( S , A , B ) ) << endl ; }
void printPattern ( int n , int m ) {
if ( m > 2 * ( n + 1 ) m < n - 1 ) { cout << " - 1" ; }
else if ( abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { cout << "01" ; n -- ; m -- ; } if ( n != 0 ) { cout << "0" ; } if ( m != 0 ) { cout << "1" ; } } else { while ( m - n > 1 && n > 0 ) { cout << "110" ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { cout << "10" ; n -- ; m -- ; } while ( m > 0 ) { cout << "1" ; m -- ; } } }
int main ( ) { int n = 4 , m = 8 ; printPattern ( n , m ) ; return 0 ; }
int countDecreasing ( int A [ ] , int n ) {
int len = 1 ;
for ( int i = 0 ; i < n - 1 ; ++ i ) {
if ( A [ i + 1 ] < A [ i ] ) len ++ ;
else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } }
if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
int main ( ) { int A [ ] = { 100 , 3 , 1 , 13 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << countDecreasing ( A , n ) ; return 0 ; }
int minimumChar ( string S1 , string S2 ) {
int n = S1 . size ( ) , m = S2 . size ( ) ; int ans = INT_MAX ;
for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ;
for ( int j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } }
ans = min ( minRemovedChar , ans ) ; }
return ans ; }
int main ( ) { string S1 = " abc " ; string S2 = " paxzk " ; cout << minimumChar ( S1 , S2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countFreq ( string & pat , string & txt ) { int M = pat . length ( ) ; int N = txt . length ( ) ; int res = 0 ;
for ( int i = 0 ; i <= N - M ; i ++ ) {
int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ;
if ( j == M ) { res ++ ; j = 0 ; } } return res ; }
int main ( ) { string txt = " dhimanman " ; string pat = " man " ; cout << countFreq ( pat , txt ) ; return 0 ; }
void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int i = 0 ; while ( i <= N - M ) { int j ;
for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ;
{ cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else
i = i + j ; } }
int main ( ) { string txt = " ABCEABCDABCEABCD " ; string pat = " ABCD " ; search ( pat , txt ) ; return 0 ; }
void printMatrix ( int n , int m ) {
if ( n < 5 m < 5 ) { cout << -1 ; return ; }
string s = " aeiou " ;
for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = 0 ; j < m ; j ++ ) { cout << s [ j % 5 ] << " ▁ " ; } cout << endl ; char c = s [ 0 ] ;
for ( int i = 0 ; i < 4 ; i ++ ) { s [ i ] = s [ i + 1 ] ; } s [ 4 ] = c ; } }
int main ( ) { int n = 5 , m = 5 ; printMatrix ( n , m ) ; return 0 ; }
const int minOperations ( int n , string a , string b , string c ) {
int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a [ i ] ; char y = b [ i ] ; char z = c [ i ] ;
if ( x == y && y == z ) ;
else if ( x == y y == z x == z ) { ans ++ ; }
else { ans += 2 ; } }
return ans ; }
int main ( ) { string a = " place " ; string b = " abcde " ; string c = " plybe " ; int n = a . size ( ) ; cout << minOperations ( n , a , b , c ) ; return 0 ; }
bool check ( string s ) { int n = s . size ( ) ;
for ( int i = 0 ; i < n - 1 ; i ++ ) {
if ( s [ i ] > s [ i + 1 ] ) return true ; }
return false ; }
int main ( ) { string s = " geeksforgeeks " ; if ( check ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int countSubStr ( string str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) {
res += ( ( count + 1 ) * ( n - i ) ) ;
count = 0 ; } else count ++ ; } return res ; }
int main ( ) { string str = " abcabc " ; int n = str . length ( ) ; char x = ' c ' ; cout << countSubStr ( str , n , x ) ; return 0 ; }
int countSubStr ( string str , int n ) { int len = str . length ( ) ; return ( len - n + 1 ) ; }
int main ( ) { string str = " geeksforgeeks " ; int n = 5 ; cout << countSubStr ( str , n ) ; return 0 ; }
int countSubstrings ( string s , char c ) {
int n = s . length ( ) ; int cnt = 0 ; int sum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( s [ i ] != c ) cnt ++ ; else {
sum += ( cnt * ( cnt + 1 ) ) / 2 ;
cnt = 0 ; } }
sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; }
int main ( ) { string s = " baa " ; char c = ' b ' ; cout << countSubstrings ( s , c ) ; return 0 ; }
bool isPalindrome ( string s ) { int i = 0 ; int j = s . length ( ) - 1 ; while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; }
int getIndex ( string S1 , string S2 , int n ) { string S = " " ; for ( int i = 0 ; i < n ; i ++ ) {
S = S + S1 [ i ] ; string Temp = " " ;
for ( int j = i + 1 ; j < n ; j ++ ) Temp += S2 [ j ] ;
if ( isPalindrome ( S + Temp ) ) { return i ; } } return -1 ; }
int main ( ) { string S1 = " abcdf " , S2 = " sfgba " ; int n = S1 . length ( ) ; cout << getIndex ( S1 , S2 , n ) ; return 0 ; }
bool valid ( int cnt [ ] ) {
for ( int i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; }
string getGoodString ( string s , int n ) {
if ( n < 26 ) return " - 1" ;
for ( int i = 25 ; i < n ; i ++ ) {
int cnt [ 26 ] = { 0 } ;
for ( int j = i ; j >= i - 25 ; j -- ) { cnt [ s [ j ] - ' a ' ] ++ ; }
if ( valid ( cnt ) ) {
int cur = 0 ; while ( cnt [ cur ] > 0 ) cur ++ ; for ( int j = i - 25 ; j <= i ; j ++ ) {
if ( s [ j ] == ' ? ' ) { s [ j ] = cur + ' a ' ; cur ++ ;
while ( cnt [ cur ] > 0 ) cur ++ ; } }
return s ; } } return " - 1" ; }
int main ( ) { string s = " abcdefghijkl ? nopqrstuvwxy ? " ; int n = s . length ( ) ; cout << getGoodString ( s , n ) ; return 0 ; }
bool isVowel ( char c ) { c = tolower ( c ) ; if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) return true ; return false ; }
string swapRepeated ( string str ) {
for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) {
if ( ( isVowel ( str [ i ] ) && isVowel ( str [ i + 1 ] ) ) || ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i + 1 ] ) ) )
swap ( str [ i ] , str [ i + 1 ] ) ; } return str ; }
int main ( ) { string str = " geeksforgeeks " ; cout << swapRepeated ( str ) ; return 0 ; }
string largestPalinSub ( string s ) { string res ; char mx = s [ 0 ] ;
for ( int i = 1 ; i < s . length ( ) ; i ++ ) mx = max ( mx , s [ i ] ) ;
for ( int i = 0 ; i < s . length ( ) ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; }
int main ( ) { string s = " geeksforgeeks " ; cout << largestPalinSub ( s ) ; }
void printString ( string str , int n ) {
int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ;
bool used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = 1 ;
for ( int j = 0 ; j < ones ; j ++ ) cout << "1" ; }
if ( str [ i ] != '1' ) cout << str [ i ] ; }
if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) cout << "1" ; }
int main ( ) { string str = "100210" ; int n = str . length ( ) ; printString ( str , n ) ; return 0 ; }
int findPermutation ( string str , int k ) { bool has [ 26 ] = { false } ;
int cnt = 0 ;
for ( int i = 0 ; i < str . length ( ) ; i ++ ) {
if ( ! has [ str [ i ] - ' a ' ] ) {
cnt ++ ;
has [ str [ i ] - ' a ' ] = true ; } } long long int ans = 1 ;
for ( int i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( int i = cnt - k ; i > 1 ; i -- ) ans /= i ;
return ans ; }
int main ( ) { string str = " geeksforgeeks " ; int k = 4 ; cout << findPermutation ( str , k ) ; return 0 ; }
int product ( int x ) { int prod = 1 ; while ( x ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; }
int findNumber ( int l , int r ) {
string a = to_string ( l ) ; string b = to_string ( r ) ;
int ans = r ; for ( int i = 0 ; i < b . size ( ) ; i ++ ) { if ( b [ i ] == '0' ) continue ;
string curr = b ; curr [ i ] = ( ( curr [ i ] - '0' ) - 1 ) + '0' ;
for ( int j = i + 1 ; j < curr . size ( ) ; j ++ ) curr [ j ] = '9' ;
int num = 0 ; for ( auto c : curr ) num = num * 10 + ( c - '0' ) ;
if ( num >= l && product ( ans ) < product ( num ) ) ans = num ; } return ans ; }
int main ( ) { int l = 1 , r = 10 ; cout << findNumber ( l , r ) << endl ; l = 51 , r = 62 ; cout << findNumber ( l , r ) << endl ; return 0 ; }
int constructBinString ( int a , int b , int x ) { int d , i ;
d = x / 2 ;
if ( x % 2 == 0 && x / 2 != a ) { d -- ; cout << 0 ; a -- ; }
for ( i = 0 ; i < d ; i ++ ) cout << "10" ;
a = a - d ; b = b - d ;
for ( i = 0 ; i < b ; i ++ ) { cout << "1" ; }
for ( i = 0 ; i < a ; i ++ ) { cout << "0" ; } }
int main ( ) { int a = 4 , b = 3 , x = 2 ; constructBinString ( a , b , x ) ; return 0 ; }
int matchPattern ( string s ) { int count = 0 ; int n = s . length ( ) ;
int i = 0 ; while ( i < n ) {
while ( i < n && s [ i ] == ' a ' ) { count ++ ; i ++ ; }
while ( i < n && s [ i ] == ' b ' ) { count -- ; i ++ ; }
if ( count != 0 ) return false ; } return true ; }
int main ( ) { string s = " bb " ; if ( matchPattern ( s ) == true ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int maximum_one ( string s , int n ) {
int cnt_one = 0 ; int max_cnt = 0 , temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) { cnt_one ++ ; temp ++ ; } else { max_cnt = max ( temp , max_cnt ) ; temp = 0 ; } } max_cnt = max ( max_cnt , temp ) ;
int left [ n ] , right [ n ] ; if ( s [ 0 ] == '1' ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s [ n - 1 ] == '1' ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ;
for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) left [ i ] = left [ i - 1 ] + 1 ;
else left [ i ] = 0 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } for ( int i = 1 ; i < n - 1 ; i ++ ) {
if ( s [ i ] == '0' ) {
int sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) max_cnt = max ( max_cnt , sum + 1 ) ; else max_cnt = max ( max_cnt , sum ) ; } } return max_cnt ; }
string s = "111011101" ; cout << maximum_one ( s , s . length ( ) ) ; return 0 ; }
int maxFreq ( string s , int a , int b ) {
int fre [ 10 ] = { 0 } ;
int n = s . size ( ) ;
if ( a > b ) swap ( a , b ) ;
for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - '0' ] ++ ;
if ( fre [ a ] == 0 and fre [ b ] == 0 ) return -1 ;
else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; }
int main ( ) { int a = 4 , b = 7 ; string s = "47744" ; cout << maxFreq ( s , a , b ) ; return 0 ; }
void convert ( int n , string a , string b ) {
int l [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) l [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) {
if ( a [ i ] != b [ i ] ) l [ i ] = 1 ; }
int cc = 0 ;
int vl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( l [ i ] == 0 ) { if ( vl != 0 ) cc += 1 ; vl = 0 ; } else vl += 1 ; }
if ( vl != 0 ) cc += 1 ; cout << cc << endl ; }
int main ( ) { string a = "101010" ; string b = "110011" ; int n = a . length ( ) ; convert ( n , a , b ) ; return 0 ; }
int countWays ( string s1 , string s2 , int n ) { int a , b , c , d ; a = b = c = d = 0 ;
int result = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { if ( s2 [ i ] == '0' ) { if ( s1 [ i ] == '0' ) { c ++ ; } else { d ++ ; } } else { if ( s1 [ i ] == '0' ) { a ++ ; } else { b ++ ; } } }
result = a * d + b * c + c * d ; return result ; }
int main ( ) { int n = 5 ; string s1 = "01011" ; string s2 = "11001" ; cout << countWays ( s1 , s2 , n ) ; return 0 ; }
int returnWinner ( string s , int l ) {
int freq [ 26 ] ; memset ( freq , 0 , sizeof freq ) ;
for ( int i = 0 ; i < l ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; } int cnt = 0 ;
for ( int i = 0 ; i < 26 ; i ++ ) {
if ( freq [ i ] & 1 ) cnt ++ ; }
if ( cnt == 0 cnt & 1 ) return 1 ; else return 2 ; }
int main ( ) { string s = " abaaab " ; int l = s . length ( ) ;
int winner = returnWinner ( s , l ) ; cout << " Player - " << winner ; return 0 ; }
void maxProductSum ( string str , int m ) { int n = str . length ( ) ; int maxProd = INT_MIN , maxSum = INT_MIN ; for ( int i = 0 ; i <= n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str [ j ] - '0' ) ; sum = sum + ( str [ j ] - '0' ) ; } maxProd = max ( maxProd , product ) ; maxSum = max ( maxSum , sum ) ; } cout << " Maximum ▁ Product ▁ = ▁ " << maxProd ; cout << " Maximum Sum = " }
int main ( ) { string str = "3605356297" ; int m = 3 ; maxProductSum ( str , m ) ; }
int maxLength ( string s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = INT_MIN ;
s = s + '1' ;
for ( int i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == ' o ' ) coun ++ ; else {
if ( coun > max_length ) { right = 0 ; left = 0 ;
if ( s [ i ] == ' x ' ) right = 1 ;
if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == ' x ' ) ) left = 1 ;
coun = ceil ( ( double ) coun / ( right + left ) ) ; max_length = max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; }
int main ( ) { string s = " oooxoooooooooxooo " ; int n = s . size ( ) ; cout << maxLength ( s , n ) ; return 0 ; }
bool areVowelsInOrder ( string s ) { int n = s . length ( ) ;
char c = ( char ) 64 ;
for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) {
if ( s [ i ] < c ) return false ; else {
c = s [ i ] ; } } } return true ; }
int main ( ) { string s = " aabbbddeecc " ;
if ( areVowelsInOrder ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int Remainder ( string str , int R ) {
int len = str . length ( ) ; int Num , Rem = 0 ;
for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - '0' ) ; Rem = Num % R ; }
return Rem ; }
string str = "13589234356546756" ;
int R = 13 ;
cout << Remainder ( str , R ) ; return 0 ; }
int count_carry ( string a , string b ) {
int carry = 0 ;
int count = 0 ;
int len_a = a . length ( ) , len_b = b . length ( ) ; while ( len_a != 0 len_b != 0 ) {
int x = 0 , y = 0 ; if ( len_a > 0 ) { x = a [ len_a - 1 ] - '0' ; len_a -- ; } if ( len_b > 0 ) { y = b [ len_b - 1 ] - '0' ; len_b -- ; }
int sum = x + y + carry ;
if ( sum >= 10 ) { carry = 1 ; count ++ ; }
else carry = 0 ; } return count ; }
int main ( ) { string a = "9555" , b = "555" ; int count = count_carry ( a , b ) ; if ( count == 0 ) cout << "0 STRNEWLINE " ; else if ( count == 1 ) cout << "1 STRNEWLINE " ; else cout << count << " STRNEWLINE " ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; bool isInGivenBase ( string str , int base ) {
if ( base > 16 ) return false ;
else if ( base <= 10 ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( str [ i ] >= '0' and str [ i ] < ( '0' + base ) ) ) return false ; }
else { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( ! ( ( str [ i ] >= '0' && str [ i ] < ( '0' + base ) ) || ( str [ i ] >= ' A ' && str [ i ] < ( ' A ' + base - 10 ) ) ) ) return false ; } return true ; }
int main ( ) { string str = " AF87" ; if ( isInGivenBase ( str , 16 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printIndex ( string str , string s ) { bool flag = false ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . substr ( i , s . length ( ) ) == s ) { cout << i << " ▁ " ; flag = true ; } } if ( flag == false ) cout << " NONE " ; }
int main ( ) { string str1 = " GeeksforGeeks " ; string str2 = " Geeks " ; printIndex ( str1 , str2 ) ; return 0 ; }
int matchClosing ( char X [ ] , int start , int end , char open , char close ) { int c = 1 ; int i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) c ++ ; else if ( X [ i ] == close ) c -- ; if ( c == 0 ) return i ; i ++ ; } return i ; }
int matchingOpening ( char X [ ] , int start , int end , char open , char close ) { int c = -1 ; int i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) c ++ ; else if ( X [ i ] == close ) c -- ; if ( c == 0 ) return i ; i -- ; } return -1 ; }
bool isBalanced ( char X [ ] , int n ) {
int i , j , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) {
if ( X [ i ] == ' ( ' ) j = matchClosing ( X , i , n - 1 , ' ( ' , ' ) ' ) ; else if ( X [ i ] == ' { ' ) j = matchClosing ( X , i , n - 1 , ' { ' , ' } ' ) ; else if ( X [ i ] == ' [ ' ) j = matchClosing ( X , i , n - 1 , ' [ ' , ' ] ' ) ;
else { if ( X [ i ] == ' ) ' ) j = matchingOpening ( X , 0 , i , ' ( ' , ' ) ' ) ; else if ( X [ i ] == ' } ' ) j = matchingOpening ( X , 0 , i , ' { ' , ' } ' ) ; else if ( X [ i ] == ' ] ' ) j = matchingOpening ( X , 0 , i , ' [ ' , ' ] ' ) ;
if ( j < 0 j > = i ) return false ;
continue ; }
if ( j >= n j < 0 ) return false ;
start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == ' ( ' ) { x = matchClosing ( X , k , end , ' ( ' , ' ) ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ) ' ) { x = matchingOpening ( X , start , k , ' ( ' , ' ) ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' { ' ) { x = matchClosing ( X , k , end , ' { ' , ' } ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' } ' ) { x = matchingOpening ( X , start , k , ' { ' , ' } ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' [ ' ) { x = matchClosing ( X , k , end , ' [ ' , ' ] ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ] ' ) { x = matchingOpening ( X , start , k , ' [ ' , ' ] ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; }
int main ( ) { char X [ ] = " [ ( ) ] ( ) " ; int n = 6 ; if ( isBalanced ( X , n ) ) printf ( " Yes STRNEWLINE " ) ; else printf ( " No STRNEWLINE " ) ; char Y [ ] = " [ [ ( ) ] ] ) " ; n = 7 ; if ( isBalanced ( Y , n ) ) printf ( " Yes STRNEWLINE " ) ; else printf ( " No STRNEWLINE " ) ; return 0 ; }
string possibleToSort ( int * arr , int n , string str ) { int max_element = -1 ; for ( long i = 0 ; i < str . size ( ) ; i ++ ) {
max_element = max ( max_element , arr [ i ] ) ;
if ( str [ i ] == '0' ) {
if ( max_element > i + 1 ) return " No " ; } }
return " Yes " ; }
int main ( ) { int arr [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; string str = "01110" ; cout << possibleToSort ( arr , n , str ) ; return 0 ; }
bool isPrimeString ( string str ) { int len = str . length ( ) , n = 0 ; for ( int i = 0 ; i < len ; i ++ ) n += ( int ) str [ i ] ;
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int main ( ) { string str = " geekRam " ; if ( isPrimeString ( str ) ) cout << " Yes " << endl ; else cout << " No " << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 256 ;
long long int fact ( int n ) { long long int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int countPalinPermutations ( string & str ) {
int n = str . length ( ) ; int freq [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] ] ++ ;
long long int res = fact ( n / 2 ) ;
bool oddFreq = false ;
for ( int i = 0 ; i < MAX ; i ++ ) { int half = freq [ i ] / 2 ;
if ( freq [ i ] % 2 != 0 ) {
if ( oddFreq == true ) return 0 ; oddFreq = true ; }
res = res / fact ( half ) ; } return res ; }
int main ( ) { string str = " gffg " ; cout << countPalinPermutations ( str ) ; return 0 ; }
bool checkPalindrome ( string str ) { int n = str . length ( ) ;
int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ;
return ( count <= 1 ) ; }
int main ( ) { string str = " abccaa " ; if ( checkPalindrome ( str ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
int evenDecimalValue ( string str , int n ) {
int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( str [ i ] == '0' ) {
result += ( n - i ) ; } } return result ; }
int main ( ) { string str = "10010" ; int n = 5 ; cout << evenDecimalValue ( str , n ) << endl ; return 0 ; }
int countSubstr ( string s ) { int n = s . length ( ) ;
int auxArr [ n ] = { 0 } ; if ( s [ 0 ] == '1' ) auxArr [ 0 ] = 1 ;
for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; }
int count = 0 ;
for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == '1' ) count += auxArr [ i ] ; return count ; }
int main ( ) { string s = "1101" ; cout << countSubstr ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 256 ; bool canMakeStr2 ( string str1 , string str2 ) {
int count [ MAX ] = { 0 } ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count [ str1 [ i ] ] ++ ;
for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false ; count [ str2 [ i ] ] -- ; } return true ; }
int main ( ) { string str1 = " geekforgeeks " ; string str2 = " for " ; if ( canMakeStr2 ( str1 , str2 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
void finalPosition ( string move ) { int l = move . size ( ) ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ;
for ( int i = 0 ; i < l ; i ++ ) {
if ( move [ i ] == ' U ' ) countUp ++ ; else if ( move [ i ] == ' D ' ) countDown ++ ; else if ( move [ i ] == ' L ' ) countLeft ++ ; else if ( move [ i ] == ' R ' ) countRight ++ ; }
cout << " Final ▁ Position : ▁ ( " << ( countRight - countLeft ) << " , ▁ " << ( countUp - countDown ) << " ) " << endl ; }
int main ( ) { string move = " UDDLLRUUUDUURUDDUULLDRRRR " ; finalPosition ( move ) ; return 0 ; }
int maxbalancedprefix ( char str [ ] , int n ) { int sum = 0 ; int maxi = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( str [ i ] == ' ( ' ) sum += 1 ;
else sum -= 1 ;
if ( sum < 0 ) break ;
if ( sum == 0 ) maxi = i + 1 ; } return maxi ; }
int main ( ) { char str [ ] = " ( ( ( ) ( ) ) ( ) ) ( ( " ; int n = strlen ( str ) ; cout << maxbalancedprefix ( str , n ) << endl ; return 0 ; }
int cost ( string str ) {
int len = str . length ( ) ;
int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str [ i ] != str [ j ] ) res += min ( str [ i ] , str [ j ] ) - ' a ' + 1 ; return res ; }
int main ( ) { string str = " abcdef " ; cout << cost ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 256 ; bool isPresent ( string s , string q ) {
int freq [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) freq [ s [ i ] ] ++ ;
for ( int i = 0 ; i < q . length ( ) ; i ++ ) { freq [ q [ i ] ] -- ; if ( freq [ q [ i ] ] < 0 ) return false ; } return true ; }
int main ( ) { string s = " abctd " ; string q = " cat " ; if ( isPresent ( s , q ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int countReduce ( string & str ) { int n = str . length ( ) ; int res = 0 ;
for ( int i = 0 ; i < n / 2 ; i ++ ) res += abs ( str [ i ] - str [ n - i - 1 ] ) ; return res ; }
int main ( ) { string str = " abcd " ; cout << countReduce ( str ) ; return 0 ; }
int calculate ( string s ) {
int ans = 6 ;
for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) {
int c = 0 ;
if ( i != s [ 0 ] - '0' ) c ++ ;
if ( j != s [ 1 ] - '0' ) c ++ ;
if ( k != s [ 2 ] - '0' ) c ++ ;
if ( l != s [ 3 ] - '0' ) c ++ ;
if ( m != s [ 4 ] - '0' ) c ++ ;
if ( n != s [ 5 ] - '0' ) c ++ ;
if ( c < ans ) ans = c ; } } } } } } }
return ans ; }
string s = "123456" ;
cout << calculate ( s ) ; }
bool makeAndCheckString ( vector < string > words , string str ) { int n = words . size ( ) ; bool first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) {
if ( words [ i ] == str ) return true ;
if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ;
if ( first && second ) return true ; } return false ; }
int main ( ) { string str = " ya " ; vector < string > words = { " ah " , " oy " , " to " , " ha " } ; if ( makeAndCheckString ( words , str ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool sentencePalindrome ( string str ) { int l = 0 , h = str . length ( ) - 1 ;
for ( int i = 0 ; i <= h ; i ++ ) str [ i ] = tolower ( str [ i ] ) ;
while ( l <= h ) {
if ( ! ( str [ l ] >= ' a ' && str [ l ] <= ' z ' ) ) l ++ ;
else if ( ! ( str [ h ] >= ' a ' && str [ h ] <= ' z ' ) ) h -- ;
else if ( str [ l ] == str [ h ] ) l ++ , h -- ;
else return false ; }
return true ; }
int main ( ) { string str = " Too ▁ hot ▁ to ▁ hoot . " ; if ( sentencePalindrome ( str ) ) cout << " Sentence ▁ is ▁ palindrome . " ; else cout << " Sentence ▁ is ▁ not ▁ palindrome . " ; return 0 ; }
int xorZero ( string str ) { int one_count = 0 , zero_count = 0 ; int n = str . length ( ) ;
for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) one_count ++ ; else zero_count ++ ;
if ( one_count % 2 == 0 ) return zero_count ; return one_count ; }
int main ( ) { string str = "11111" ; cout << xorZero ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ;
bool checkCorrectOrNot ( string s ) {
int count [ MAX_CHAR ] = { 0 } ;
int n = s . length ( ) ; if ( n == 1 ) return true ;
for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) {
count [ s [ i ] - ' a ' ] ++ ;
count [ s [ j ] - ' a ' ] -- ; }
for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; }
string s = " abab " ; if ( checkCorrectOrNot ( s ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool uniqueCharacters ( string str ) {
int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int bitAtIndex = str [ i ] - ' a ' ;
if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; }
checker = checker | ( 1 << bitAtIndex ) ; }
return true ; }
int main ( ) { string str = " geeksforgeeks " ; if ( uniqueCharacters ( str ) ) { cout << " The ▁ String ▁ " << str << " ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE " ; } else { cout << " The ▁ String ▁ " << str << " ▁ has ▁ duplicate ▁ characters STRNEWLINE " ; } return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void isKthBitSet ( int n , int k ) { if ( n & ( 1 << ( k - 1 ) ) ) cout << " SET " ; else cout << " NOT ▁ SET " ; }
int main ( ) { int n = 5 , k = 1 ; isKthBitSet ( n , k ) ; return 0 ; }
bool isPalRec ( char str [ ] , int s , int e ) {
if ( s == e ) return true ;
if ( str [ s ] != str [ e ] ) return false ;
if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } bool isPalindrome ( char str [ ] ) { int n = strlen ( str ) ;
if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; }
int main ( ) { char str [ ] = " geeg " ; if ( isPalindrome ( str ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
const int MAX_CHAR = 26 ; int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ;
int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; }
int main ( ) { string s ( " abcab " ) ; cout << countSubstringWithEqualEnds ( s ) ; return 0 ; }
char maxRepeating ( string str ) { int n = str . length ( ) ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ;
else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; }
int main ( ) { string str = " aaaabbaaccde " ; cout << maxRepeating ( str ) ; return 0 ; }
void query ( char s [ ] , int i , int j ) { int n = strlen ( s ) ;
i %= n ; j %= n ;
( s [ i ] == s [ j ] ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; }
int main ( ) { char X [ ] = " geeksforgeeks " ; query ( X , 0 , 8 ) ; query ( X , 8 , 13 ) ; query ( X , 6 , 15 ) ; return 0 ; }
int countPairs ( string str ) { int result = 0 ; int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ )
if ( abs ( str [ i ] - str [ j ] ) == abs ( i - j ) ) result ++ ; return result ; }
int main ( ) { string str = " geeksforgeeks " ; cout << countPairs ( str ) ; return 0 ; }
void longestString ( string str1 , string str2 ) { int count1 [ 26 ] = { 0 } , count2 [ 26 ] = { 0 } ;
for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ;
string result ; for ( int i = 0 ; i < 26 ; i ++ )
for ( int j = 1 ; j <= min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) result . push_back ( ' a ' + i ) ; cout << result ; }
int main ( ) { string str1 = " geeks " , str2 = " cake " ; longestString ( str1 , str2 ) ; return 0 ; }
int countkDist ( string str , int k ) { int n = str . length ( ) ;
int res = 0 ;
int cnt [ 26 ] ;
for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ;
memset ( cnt , 0 , sizeof ( cnt ) ) ;
for ( int j = i ; j < n ; j ++ ) {
if ( cnt [ str [ j ] - ' a ' ] == 0 ) dist_count ++ ;
cnt [ str [ j ] - ' a ' ] ++ ;
if ( dist_count == k ) res ++ ; if ( dist_count > k ) break ; } } return res ; }
int main ( ) { string str = " abcbaa " ; int k = 3 ; cout << " Total ▁ substrings ▁ with ▁ exactly ▁ " << k << " ▁ distinct ▁ characters ▁ : " << countkDist ( str , k ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; long int removeRecur ( long int n ) {
int prev_digit = n % 10 ;
long int pow = 10 ; long int res = prev_digit ;
while ( n ) {
int curr_digit = n % 10 ; if ( curr_digit != prev_digit ) {
res += curr_digit * pow ;
prev_digit = curr_digit ; pow *= 10 ; }
n = n / 10 ; } return res ; }
int main ( ) { long int n = 12224 ; cout << removeRecur ( n ) ; return 0 ; }
void printTheArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } cout << endl ; }
void generateAllBinaryStrings ( int n , int arr [ ] , int i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; }
arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ;
arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; }
int main ( ) { int n = 4 ; int arr [ n ] ;
generateAllBinaryStrings ( n , arr , 0 ) ; return 0 ; }
int firstDigit ( int n ) {
while ( n >= 10 ) { n /= 10 ; }
return n ; }
int getCount ( int n ) { int count = 1 ; while ( n != 0 ) { int leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; }
int getLargestNumber ( int k ) { int left = k ; int right = k * 10 ; int mid = ( left + right ) / 2 ;
int len = getCount ( mid ) ;
while ( len != k ) {
mid = ( left + right ) / 2 ;
len = getCount ( mid ) ; if ( len > k ) {
right = mid ; } else {
left = mid ; } }
while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; }
int main ( ) { int k = 3 ; cout << getLargestNumber ( k ) ; return 0 ; }
void diameter ( double r ) { cout << " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " << " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " << 2 * r << endl ; }
double r = 4 ;
diameter ( r ) ; return 0 ; }
double getSlope ( double m ) { return m ; }
int main ( ) { double m = 2 ; cout << getSlope ( m ) ; return 0 ; }
LLI totalTriangles ( LLI h , LLI v ) {
if ( h == 0 && v == 0 ) return 1 ;
if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ;
if ( v == 0 ) return ( h + 1 ) ;
LLI Total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return Total ; }
int main ( ) { int h = 2 , v = 2 ; cout << totalTriangles ( h , v ) ; return 0 ; }
float sph ( float r , float R , float h ) {
if ( r < 0 && R < 0 && h < 0 ) return -1 ;
float x = r ;
float V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 ; return V ; }
int main ( ) { float r = 5 , R = 8 , h = 11 ; cout << sph ( r , R , h ) << endl ; return 0 ; }
bool checkOrtho ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int m1 , m2 ;
if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ;
else if ( x2 - x1 == 0 ) { m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m2 == 0 ) return true ; else return false ; }
else if ( x4 - x3 == 0 ) { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; if ( m1 == 0 ) return true ; else return false ; } else {
m1 = ( y2 - y1 ) / ( x2 - x1 ) ; m2 = ( y4 - y3 ) / ( x4 - x3 ) ;
if ( m1 * m2 == -1 ) return true ; else return false ; } }
int main ( ) { int x1 = 0 , y1 = 4 , x2 = 0 , y2 = -9 ; int x3 = 2 , y3 = 0 , x4 = -1 , y4 = 0 ; checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ? cout << " Yes " : cout << " No " ; return 0 ; }
float pentdiagonal ( float a ) {
if ( a < 0 ) return -1 ;
float d = 1.22 * a ; return d ; }
int main ( ) { float a = 6 ; cout << pentdiagonal ( a ) << endl ; return 0 ; }
float hexagonArea ( float d ) {
return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 ; }
int main ( ) { float d = 10 ; cout << " Area ▁ of ▁ hexagon : ▁ " << hexagonArea ( d ) ; return 0 ; }
int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; }
int main ( ) { int n = 6 , m = 6 , a = 4 ;
cout << Squares ( n , m , a ) ; return 0 ; }
float octadiagonal ( float a ) {
if ( a < 0 ) return -1 ;
return a * sqrt ( 4 + ( 2 * sqrt ( 2 ) ) ) ; }
int main ( ) { float a = 4 ; cout << octadiagonal ( a ) << endl ; return 0 ; }
void CalPeri ( ) { int s = 5 , Perimeter ; Perimeter = 10 * s ; cout << " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ " << Perimeter ; }
int main ( ) { CalPeri ( ) ; return 0 ; }
double findEdges ( double s1 , double s2 , double s3 ) {
double a = sqrt ( s1 * s2 / s3 ) ; double b = sqrt ( s3 * s1 / s2 ) ; double c = sqrt ( s3 * s2 / s1 ) ;
double sum = a + b + c ;
return 4 * sum ; }
double s1 , s2 , s3 ; s1 = 65 , s2 = 156 , s3 = 60 ; cout << findEdges ( s1 , s2 , s3 ) ; return 0 ; }
int findMaximumPieces ( int n ) {
int x = n / 2 ;
return ( ( x + 1 ) * ( n - x + 1 ) ) ; }
int n = 3 ;
cout << " Max ▁ number ▁ of ▁ pieces ▁ for ▁ n ▁ = ▁ " << n << " ▁ is ▁ " << findMaximumPieces ( 3 ) ; return 0 ; }
void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ;
if ( a * x + b * y + c * z + d == 0 ) cout << " Coplanar " << endl ; else cout << " Not ▁ Coplanar " << endl ; }
int main ( ) { int x1 = 3 ; int y1 = 2 ; int z1 = -5 ; int x2 = -1 ; int y2 = 4 ; int z2 = -3 ; int x3 = -3 ; int y3 = 8 ; int z3 = -5 ; int x4 = -3 ; int y4 = 2 ; int z4 = 1 ;
equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; return 0 ; }
void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = 3.14159 ; float A = ( 180 / pi ) * ( acos ( d ) ) ; cout << " Angle ▁ is ▁ " << A << " ▁ degree " ; }
int main ( ) { float a1 = 1 ; float b1 = 1 ; float c1 = 2 ; float d1 = 1 ; float a2 = 2 ; float b2 = -1 ; float c2 = 1 ; float d2 = -4 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ; return 0 ; }
void mirror_point ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << " ▁ x3 ▁ = ▁ " << x3 ; cout << " ▁ y3 ▁ = ▁ " << y3 ; cout << " ▁ z3 ▁ = ▁ " << z3 ; }
int main ( ) { float a = 1 ; float b = -2 ; float c = 0 ; float d = 0 ; float x1 = -1 ; float y1 = 3 ; float z1 = 4 ;
mirror_point ( a , b , c , d , x1 , y1 , z1 ) ; return 0 ; }
int countRectangles ( int radius ) { int rectangles = 0 ;
int diameter = 2 * radius ;
int diameterSquare = diameter * diameter ;
for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) {
int diagonalLengthSquare = ( a * a + b * b ) ;
if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; }
int radius = 2 ; int totalRectangles ; totalRectangles = countRectangles ( radius ) ; cout << totalRectangles << " ▁ rectangles ▁ can ▁ be " << " cut ▁ from ▁ a ▁ circle ▁ of ▁ Radius ▁ " << radius ; return 0 ; }
int simi_aaa ( int a1 [ ] , int a2 [ ] ) { sort ( a1 , a1 + 3 ) ; sort ( a2 , a2 + 3 ) ;
if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; }
int simi_sas ( int s1 [ ] , int s2 [ ] , int a1 [ ] , int a2 [ ] ) { sort ( a1 , a1 + 3 ) ; sort ( a2 , a2 + 3 ) ; sort ( s1 , s1 + 3 ) ; sort ( s2 , s2 + 3 ) ;
if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) {
if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; }
int simi_sss ( int s1 [ ] , int s2 [ ] ) { sort ( s1 , s1 + 3 ) ; sort ( s2 , s2 + 3 ) ;
if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; }
int main ( ) { int s1 [ ] = { 2 , 3 , 3 } ; int s2 [ ] = { 4 , 6 , 6 } ; int a1 [ ] = { 80 , 60 , 40 } ; int a2 [ ] = { 40 , 60 , 80 } ;
int aaa = simi_aaa ( a1 , a2 ) ;
int sss = simi_sss ( s1 , s2 ) ;
int sas = simi_sas ( s1 , s2 , a1 , a2 ) ;
if ( aaa == 1 sss == 1 sas == 1 ) { cout << " Triangles ▁ are ▁ " << " similar ▁ by ▁ " ; if ( aaa == 1 ) cout << " AAA ▁ " ; if ( sss == 1 ) cout << " SSS ▁ " ; if ( sas == 1 ) cout << " SAS . " ; } else cout << " Triangles ▁ are ▁ " << " not ▁ similar " ; return 0 ; }
int center_pentadecagonal_num ( long int n ) {
return ( 15 * n * n - 15 * n + 2 ) / 2 ; }
int main ( ) { long int n = 3 ; cout << n << " th ▁ number ▁ : ▁ " << center_pentadecagonal_num ( n ) ; cout << endl ; n = 10 ; cout << n << " th ▁ number ▁ : ▁ " << center_pentadecagonal_num ( n ) ; return 0 ; }
int center_nonadecagon_num ( long int n ) {
return ( 19 * n * n - 19 * n + 2 ) / 2 ; }
int main ( ) { long int n = 2 ; cout << n << " th ▁ centered ▁ nonadecagonal ▁ number ▁ : ▁ " << center_nonadecagon_num ( n ) ; cout << endl ; n = 7 ; cout << n << " th ▁ centered ▁ nonadecagonal ▁ number ▁ : ▁ " << center_nonadecagon_num ( n ) ; return 0 ; }
int hendecagonal_num ( int n ) {
return ( 9 * n * n - 7 * n ) / 2 ; }
int main ( ) { int n = 3 ; cout << n << " rd ▁ Hendecagonal ▁ number : ▁ " ; cout << hendecagonal_num ( n ) ; cout << endl ; n = 10 ; cout << n << " th ▁ Hendecagonal ▁ number : ▁ " ; cout << hendecagonal_num ( n ) ; return 0 ; }
int cen_octagonalnum ( long int n ) {
return ( 4 * n * n - 4 * n + 1 ) ; }
int main ( ) { long int n = 6 ; cout << n << " th ▁ centered " << " ▁ octagonal ▁ number ▁ : ▁ " ; cout << cen_octagonalnum ( n ) ; cout << endl ; n = 11 ; cout << n << " th ▁ centered " << " ▁ octagonal ▁ number ▁ : ▁ " ; cout << cen_octagonalnum ( n ) ; return 0 ; }
bool isValid ( int arr [ ] , int i , int j , int m , int c ) {
if ( i == j ) return false ;
int lhs = arr [ j ] ; int rhs = m * arr [ i ] + c ; return ( lhs == rhs ) ; }
int findOrderedPoints ( int arr [ ] , int n , int m , int c ) { int counter = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
int firstIndex = i , secondIndex = j ;
if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
int m = 1 , c = 1 ; cout << findOrderedPoints ( arr , n , m , c ) ; return 0 ; }
bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) {
int dis = sqrt ( x1 * x1 + y1 * y1 ) ;
return ( dis - r1 >= R && dis + r1 <= r ) ; }
int r = 8 , R = 4 , r1 = 2 , x1 = 6 , y1 = 0 ; if ( checkcircle ( r , R , r1 , x1 , y1 ) ) cout << " yes " << endl ; else cout << " no " << endl ; return 0 ; }
double surface_area_octahedron ( double side ) { return ( 2 * ( sqrt ( 3 ) ) * ( side * side ) ) ; }
int main ( ) { double side = 7 ; cout << " Surface ▁ area ▁ of ▁ octahedron ▁ = " << surface_area_octahedron ( side ) << endl ; }
int nCk ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ;
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int count_Straightlines ( int n , int m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; }
int main ( ) { int n = 4 , m = 3 ; cout << count_Straightlines ( n , m ) ; return 0 ; }
double vol_of_dodecahedron ( int side ) { return ( ( ( 15 + ( 7 * ( sqrt ( 5 ) ) ) ) / 4 ) * ( pow ( side , 3 ) ) ) ; }
int main ( ) { int side = 4 ; cout << " Volume ▁ of ▁ dodecahedron ▁ = ▁ " << vol_of_dodecahedron ( side ) ; }
void overflow ( int H , int r , int h , int N , int R ) {
float tank_cap = 3.14 * r * r * H ;
float water_vol = 3.14 * r * r * h ;
float balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ;
float vol = water_vol + balls_vol ;
if ( vol > tank_cap ) { cout << " Overflow " << endl ; } else { cout << " Not ▁ in ▁ overflow ▁ state " << endl ; } }
int H = 10 , r = 5 , h = 5 , N = 2 , R = 2 ;
overflow ( H , r , h , N , R ) ; return 0 ; }
float volume ( int radius , int height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; }
void check_and_print ( float required_time , float given_time ) { if ( required_time < given_time ) cout << " Overflow " ; else if ( required_time > given_time ) cout << " Underflow " ; else cout << " Filled " ; }
int radius = 5 ,
height = 10 ,
rate_of_flow = 10 ;
float given_time = 70.0 ;
float required_time = volume ( radius , height ) / rate_of_flow ;
check_and_print ( required_time , given_time ) ; return 0 ; }
float cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ;
n = n * ( 3.142 / 180.0 ) ; x1 = 1 ;
cosx = x1 ;
cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; return cosx ; }
float third_side ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; }
int main ( ) { float c = 49 ; int a = 5 , b = 8 ;
cout << third_side ( a , b , c ) ; return 0 ; }
void fitOrNotFit ( int R , int r , int x , int y , int rad ) {
double val = sqrt ( pow ( x , 2 ) + pow ( y , 2 ) ) ;
if ( val + rad <= R && val - rad >= R - r ) cout << " Fits STRNEWLINE " ; else cout << " Doesn ' t ▁ Fit STRNEWLINE " ; }
int R = 8 , r = 4 ;
int x = 5 , y = 3 , rad = 3 ; fitOrNotFit ( R , r , x , y , rad ) ; return 0 ; }
bool checkPolygonWithMidpoints ( int arr [ ] , int N , int midpoints ) {
for ( int j = 0 ; j < midpoints ; j ++ ) { int val = 1 ;
for ( int k = j ; k < N ; k += midpoints ) {
val &= arr [ k ] ; }
if ( val && N / midpoints > 2 ) { cout << " Polygon ▁ possible ▁ with ▁ side ▁ length ▁ " << << ( N / midpoints ) << endl ; return true ; } } return false ; }
void isPolygonPossible ( int arr [ ] , int N ) {
int limit = sqrt ( N ) ; for ( int i = 1 ; i <= limit ; i ++ ) {
if ( N % i == 0 ) {
if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , ( N / i ) ) ) return ; } } cout << " Not ▁ possiblen " ; }
int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isPolygonPossible ( arr , N ) ; return 0 ; }
float squareRoot ( float n ) {
float x = n ; float y = 1 ; float e = 0.000001 ;
while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; }
int findMaximumHeight ( int N ) {
int n = 1 + 8 * N ; int maxH = ( -1 + squareRoot ( n ) ) / 2 ; return maxH ; }
int main ( ) { int N = 12 ; cout << findMaximumHeight ( N ) << endl ; return 0 ; }
void calculateSpan ( int price [ ] , int n , int S [ ] ) {
S [ 0 ] = 1 ;
for ( int i = 1 ; i < n ; i ++ ) {
S [ i ] = 1 ;
for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int price [ ] = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; int S [ n ] ;
calculateSpan ( price , n , S ) ;
void printNGE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << " ▁ - - ▁ " << next << endl ; } }
int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNGE ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod ) { if ( n == 1 ) { cout << " Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ " << from_rod << " ▁ to ▁ rod ▁ " << to_rod << endl ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; cout << " Move ▁ disk ▁ " << n << " ▁ from ▁ rod ▁ " << from_rod << " ▁ to ▁ rod ▁ " << to_rod << endl ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; }
int n = 4 ;
towerOfHanoi ( n , ' A ' , ' C ' , ' B ' ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMaxOfMin ( int arr [ ] , int n ) {
for ( int k = 1 ; k <= n ; k ++ ) {
int maxOfMin = INT_MIN ;
for ( int i = 0 ; i <= n - k ; i ++ ) {
int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; }
if ( min > maxOfMin ) maxOfMin = min ; }
cout << maxOfMin << " ▁ " ; } }
int main ( ) { int arr [ ] = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMaxOfMin ( arr , n ) ; return 0 ; }
stack < int > st ;
void push_digits ( int number ) { while ( number != 0 ) { st . push ( number % 10 ) ; number = number / 10 ; } }
int reverse_number ( int number ) {
push_digits ( number ) ; int reverse = 0 ; int i = 1 ;
while ( ! st . empty ( ) ) { reverse = reverse + ( st . top ( ) * i ) ; st . pop ( ) ; i = i * 10 ; }
return reverse ; }
int main ( ) { int number = 39997 ;
cout << reverse_number ( number ) ; return 0 ; }
void heapify ( int arr [ ] , int n , int i ) {
int largest = i ;
int l = 2 * i + 1 ;
int r = 2 * i + 2 ;
if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ;
if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ;
if ( largest != i ) { swap ( arr [ i ] , arr [ largest ] ) ;
heapify ( arr , n , largest ) ; } }
void heapSort ( int arr [ ] , int n ) {
for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ;
for ( int i = n - 1 ; i > 0 ; i -- ) {
swap ( arr [ 0 ] , arr [ i ] ) ;
heapify ( arr , i , 0 ) ; } }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; cout << " STRNEWLINE " ; }
int main ( ) { int arr [ ] = { 12 , 11 , 13 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; heapSort ( arr , n ) ; cout << " Sorted ▁ array ▁ is ▁ STRNEWLINE " ; printArray ( arr , n ) ; }
bool isHeap ( int arr [ ] , int i , int n ) {
if ( i >= ( n - 2 ) / 2 ) return true ;
if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) return true ; return false ; }
int main ( ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) - 1 ; isHeap ( arr , 0 , n ) ? printf ( " Yes " ) : printf ( " No " ) ; return 0 ; }
bool isHeap ( int arr [ ] , int n ) {
for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) {
if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ;
if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; }
int main ( ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; isHeap ( arr , n ) ? printf ( " Yes " ) : printf ( " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void generate_derangement ( int N ) {
int S [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ;
int D [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N && i % N != 0 ) {
int temp = D [ N ] ; D [ N ] = D [ N - 1 ] ; D [ N - 1 ] = temp ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } }
for ( int i = 1 ; i <= N ; i ++ ) printf ( " % d ▁ " , D [ i ] ) ; printf ( " STRNEWLINE " ) ; }
int main ( ) { generate_derangement ( 10 ) ; return 0 ; }
int Profit ( int costPrice , int sellingPrice ) { int profit = ( sellingPrice - costPrice ) ; return profit ; }
int Loss ( int costPrice , int sellingPrice ) { int Loss = ( costPrice - sellingPrice ) ; return Loss ; }
int main ( ) { int costPrice = 1500 , sellingPrice = 2000 ; if ( sellingPrice == costPrice ) cout << " No ▁ profit ▁ nor ▁ Loss " ; else if ( sellingPrice > costPrice ) cout << Profit ( costPrice , sellingPrice ) << " ▁ Profit ▁ " ; else cout << Loss ( costPrice , sellingPrice ) << " ▁ Loss ▁ " ; return 0 ; }
int nextPerfectSquare ( int N ) { int nextN = floor ( sqrt ( N ) ) + 1 ; return nextN * nextN ; }
int main ( ) { int n = 35 ; cout << nextPerfectSquare ( n ) ; return 0 ; }
void printSubstrings ( int n ) {
int s = log10 ( n ) ;
int d = ( int ) ( pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n ) {
while ( d ) { cout << n / d << endl ; d = d / 10 ; }
n = n % k ;
k = k / 10 ; d = k ; } }
int main ( ) { int n = 123 ; printSubstrings ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE const ll MOD = 1e9 + 7 ;
ll powerLL ( ll x , ll n ) { ll result = 1 ; while ( n ) { if ( n & 1 ) result = result * x % MOD ; n = n / 2 ; x = x * x % MOD ; } return result ; }
ll powerStrings ( string sa , string sb ) {
ll a = 0 , b = 0 ;
for ( int i = 0 ; i < sa . length ( ) ; i ++ ) a = ( a * 10 + ( sa [ i ] - '0' ) ) % MOD ;
for ( int i = 0 ; i < sb . length ( ) ; i ++ ) b = ( b * 10 + ( sb [ i ] - '0' ) ) % ( MOD - 1 ) ;
return powerLL ( a , b ) ; }
string sa = "2" , sb = "3" ; cout << powerStrings ( sa , sb ) << endl ; return 0 ; }
bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; }
int previousPowerOfTwo ( int n ) { while ( n & n - 1 ) { n = n & n - 1 ; } return n ; }
bool checkSum ( int n ) {
if ( n == 0 n == 1 ) return false ;
else if ( isPowerOfTwo ( n ) ) { cout << " ▁ " << n / 2 << " ▁ " << n / 2 ; return true ; } else {
int x = previousPowerOfTwo ( n ) ; int y = n - x ; if ( isPowerOfTwo ( y ) ) { cout << " ▁ " << x << " ▁ " << y ; return true ; } } return false ; }
int main ( ) { int n1 = 20 ; if ( checkSum ( n1 ) == false ) cout << " No " ; cout << endl ; int n2 = 11 ; if ( checkSum ( n2 ) == false ) cout << " No " ; return 0 ; }
int complement ( int num ) { int i , len = 0 , temp , comp ;
temp = num ; while ( 1 ) { len ++ ; num = num / 10 ; if ( abs ( num ) == 0 ) break ; }
num = temp ;
comp = pow ( 10 , len ) - num ; return comp ; }
int main ( ) { cout << complement ( 25 ) << endl ; cout << complement ( 456 ) ; return 0 ; }
int gcd ( int a , int b ) {
if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ;
if ( a == b ) return a ;
if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int main ( ) { int a = 0 , b = 56 ; cout << " GCD ▁ of ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << gcd ( a , b ) ; return 0 ; }
long long int calculateSum ( int n ) {
long long int sum = 0 ;
for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; }
int main ( ) { int n = 10 ; cout << " ▁ Sum ▁ of ▁ all ▁ elements : " << calculateSum ( n ) ; return 0 ; }
int findAllSequence ( int N ) {
if ( N % 2 == 0 ) { return pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ; }
else { return pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ; } }
int main ( ) { int N = 2 ; cout << findAllSequence ( N ) << endl ; return 0 ; }
int countOnes ( int n ) {
int count = 1 ;
int rem = 1 ;
while ( rem != 0 ) {
rem = ( rem * 10 + 1 ) % n ; count ++ ; }
return count ; }
int main ( ) { int n = 13 ;
cout << countOnes ( n ) ; }
int largestNum ( int a , int b ) { return a * ( bool ) ( a / b ) + b * ( bool ) ( b / a ) ; }
int main ( ) { int a = 22 , b = 1231 ; cout << largestNum ( a , b ) ; return 0 ; }
int gcd ( int a , int b ) { int c = a % b ; while ( c != 0 ) { a = b ; b = c ; c = a % b ; } return b ; }
int numberOfmeet ( int a , int b ) { int ans ;
if ( a > b ) ans = a - b ; else ans = b - a ;
if ( a < 0 ) a = a * ( -1 ) ; if ( b < 0 ) b = b * ( -1 ) ; return ans / gcd ( a , b ) ; }
int main ( ) { int a = 1 , b = -1 ; cout << numberOfmeet ( a , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printGreater ( double x , double y ) { long double X = y * log ( x ) ; long double Y = x * log ( y ) ; if ( abs ( X - Y ) < 1e-9 ) { cout << " Equal " ; } else if ( X > Y ) { cout << x << " ^ " << y ; } else { cout << y << " ^ " << x ; } }
int main ( ) { double x = 5 , y = 8 ; printGreater ( x , y ) ; return 0 ; }
int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; }
int main ( ) { int n = 4 ; cout << sumOfSeries ( n ) ; return 0 ; }
long long int mulmod ( long long int a , long long int b , long long int mod ) {
a = a % mod ; while ( b > 0 ) {
if ( b % 2 == 1 ) res = ( res + a ) % mod ;
a = ( a * 2 ) % mod ;
b /= 2 ; }
return res % mod ; }
long long int findProduct ( long long int N ) {
long long int product = 1 , fact = 1 ; long long int MOD = 1e9 + 7 ; for ( int i = 1 ; i <= N ; i ++ ) {
fact = mulmod ( fact , i , MOD ) ;
product = mulmod ( product , fact , MOD ) ;
if ( product == 0 ) return 0 ; } return product ; }
int main ( ) { long long int N = 3 ; cout << findProduct ( N ) << endl ; N = 5 ; cout << findProduct ( N ) << endl ; return 0 ; }
int divSum ( int n ) {
long long int sum = 1 ;
for ( long long int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + n / i ; return sum ; }
bool areEquivalent ( int num1 , int num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; }
int main ( ) { int num1 = 559 , num2 = 703 ; areEquivalent ( num1 , num2 ) ? cout << " Equivalent " : cout << " Not ▁ Equivalent " ; return 0 ; }
int dodecahedral_num ( int n ) {
return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; }
int main ( ) { int n = 5 ;
cout << n << " th ▁ Dodecahedral ▁ number : ▁ " ; cout << dodecahedral_num ( n ) ; return 0 ; }
int bit ( int x ) { int ans = 0 ; while ( x ) { x /= 2 ; ans ++ ; } return ans ; }
bool check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; }
int bs ( int n ) { int l = 1 , r = sqrt ( n ) ;
while ( l < r ) {
int m = ( l + r ) / 2 ;
if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; } int countDivisor ( int n ) { return n - bs ( n ) + 1 ; }
int main ( ) { int n = 5 ; cout << countDivisor ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool everMeet ( int x1 , int x2 , int v1 , int v2 ) {
if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ;
if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; }
while ( x1 >= x2 ) { if ( x1 == x2 ) return true ;
x1 = x1 + v1 ;
x2 = x2 + v2 ; } return false ; }
int main ( ) { int x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) printf ( " Yes " ) ; else printf ( " No " ) ; return 0 ; }
string check ( long int k , int d0 , int d1 ) {
long int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ;
int a = ( k - 3 ) % 4 ;
int x ; switch ( a ) {
case 0 : x = 0 ; break ;
case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ;
case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ;
case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; }
long int sum = d0 + d1 + ( ( k - 3 ) / 4 ) * s + x ;
if ( sum % 3 == 0 ) return " YES " ; return " NO " ; }
int main ( ) { long int k , d0 , d1 ; k = 13 ; d0 = 8 ; d1 = 1 ; cout << check ( k , d0 , d1 ) << endl ; k = 5 ; d0 = 3 ; d1 = 4 ; cout << check ( k , d0 , d1 ) << endl ; return 0 ; }
int a = 4 ; int b = 3 ; int val = ( a / b ) + ( ( a % b ) != 0 ) ; cout << " The ▁ ceiling ▁ value ▁ of ▁ 4/3 ▁ is ▁ " << val << endl ;
a = 6 ; b = 3 ; val = ( a / b ) + ( ( a % b ) != 0 ) ; cout << " The ▁ ceiling ▁ value ▁ of ▁ 6/3 ▁ is ▁ " << val << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printCollatz ( int n ) {
while ( n != 1 ) { cout << n << " ▁ " ;
if ( n & 1 ) n = 3 * n + 1 ;
else n = n / 2 ; }
cout << n ; }
int main ( ) { printCollatz ( 6 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void block ( long int x ) { vector < long int > v ;
cout << " Blocks ▁ for ▁ " << x << " ▁ : ▁ " ; while ( x > 0 ) { v . push_back ( x % 2 ) ; x = x / 2 ; }
for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] == 1 ) { cout << i ; if ( i != v . size ( ) - 1 ) cout << " , ▁ " ; } } cout << endl ; }
int main ( ) { block ( 71307 ) ; block ( 1213 ) ; block ( 29 ) ; block ( 100 ) ; return 0 ; }
void findNumberOfDigits ( long n , int base ) {
int dig = ( int ) ( floor ( log ( n ) / log ( base ) ) + 1 ) ;
cout << " The ▁ Number ▁ of ▁ digits ▁ of ▁ " << " Number ▁ " << n << " ▁ in ▁ base ▁ " << base << " ▁ is ▁ " << dig ; }
long n = 1446 ; int base = 7 ;
findNumberOfDigits ( n , base ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isValidNesbitt ( double a , double b , double c ) {
double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; }
int main ( ) { double a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) ) cout << " Nesbitt ' s ▁ inequality ▁ satisfied . " << " for ▁ real ▁ numbers ▁ " << a << " , ▁ " << b << " , ▁ " << c << " STRNEWLINE " ; else cout << " Not ▁ satisfied " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printCubeFree ( int n ) {
bool cubFree [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ;
for ( int i = 2 ; i * i * i <= n ; i ++ ) {
if ( cubFree [ i ] ) {
for ( int multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } }
for ( int i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) cout << i << " ▁ " ; } }
int main ( ) { printCubeFree ( 20 ) ; return 0 ; }
int isTriangular ( int num ) { if ( num < 0 ) return false ;
int c = ( -2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return -1 ;
float root1 = ( - b + sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - sqrt ( d ) ) / ( 2 * a ) ;
if ( root1 > 0 && floor ( root1 ) == root1 ) return root1 ;
if ( root2 > 0 && floor ( root2 ) == root2 ) return root2 ; return -1 ; }
int isPerfectSquare ( long double x ) {
long double sr = sqrt ( x ) ;
if ( ( sr - floor ( sr ) ) == 0 ) return floor ( sr ) ; else return -1 ; }
int findS ( int s ) { int sr = isPerfectSquare ( s ) ; if ( sr == -1 ) return -1 ; return isTriangular ( sr ) ; }
int main ( ) { int s = 9 ; int n = findS ( s ) ; n == -1 ? cout << " - 1" : cout << n ; return 0 ; }
int trickyCase ( string s , int index ) { int index1 = -1 ;
for ( int i = index - 1 ; i >= 0 ; i -- ) {
int digit = s [ i ] - '0' ;
if ( digit != 8 ) { index1 = i ; break ; } }
if ( index1 == -1 ) return 2 * pow ( 10 , s . length ( ) ) ; int num = 0 ;
for ( int i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ;
if ( s [ index1 ] % 2 == 0 ) num = num * 10 + ( s [ index1 ] - '0' + 2 ) ; else num = num * 10 + ( s [ index1 ] - '0' + 1 ) ;
for ( int i = index1 + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 ; return num ; }
int smallestNumber ( int n ) { int num = 0 ; string s = " " ; int duplicate = n ;
while ( n ) { s = char ( n % 10 + 48 ) + s ; n /= 10 ; } int index = -1 ;
for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int digit = s [ i ] - '0' ; if ( digit & 1 ) { index = i ; break ; } }
if ( index == -1 ) return duplicate ;
if ( s [ index ] == '9' ) { num = trickyCase ( s , index ) ; return num ; }
for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ;
num = num * 10 + ( s [ index ] - '0' + 1 ) ;
for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 ; return num ; }
int main ( ) { int N = 2397 ; cout << smallestNumber ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) {
int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ;
if ( sum == 10 ) count ++ ;
if ( count == n ) return curr ; } return -1 ; }
int main ( ) { printf ( " % d STRNEWLINE " , findNth ( 5 ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int findSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; }
int main ( ) { int n = 5 ; cout << findSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int findSum ( int n ) { long long int multiTerms = n * ( n + 1 ) / 2 ;
long long int sum = multiTerms ;
for ( int i = 2 ; i <= n ; i ++ ) {
multiTerms = multiTerms - ( i - 1 ) ;
sum = sum + multiTerms * i ; } return sum ; }
int main ( ) { int n = 5 ; cout << findSum ( n ) ; return 0 ; }
int totalSumDivisibleByNum ( int digit , int number ) {
int firstnum = pow ( 10 , digit - 1 ) ; int lastnum = pow ( 10 , digit ) ;
firstnum = ( firstnum - firstnum % number ) + number ;
lastnum = ( lastnum - lastnum % number ) ;
int count = ( ( lastnum - firstnum ) / number + 1 ) ;
return ( ( lastnum + firstnum ) * count ) / 2 ; }
int main ( ) { int n = 3 , number = 7 ; cout << totalSumDivisibleByNum ( n , number ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Nth_of_AP ( int a , int d , int N ) {
return ( a + ( N - 1 ) * d ) ; }
int a = 2 ;
int d = 1 ;
int N = 5 ;
cout << " The ▁ " << N << " th ▁ term ▁ of ▁ the ▁ series ▁ is ▁ : ▁ " << Nth_of_AP ( a , d , N ) ; return 0 ; }
bool checkFibinnary ( int n ) {
int prev_last = 0 ; while ( n ) {
if ( ( n & 1 ) && prev_last ) return false ;
prev_last = n & 1 ;
n >>= 1 ; } return true ; }
int main ( ) { int n = 10 ; if ( checkFibinnary ( n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int sumOfSeries ( int n ) { return 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ; }
int main ( ) { int n = 2 ; cout << sumOfSeries ( n ) ; return 0 ; }
int Nonagonal ( int n ) {
return n * ( 7 * n - 5 ) / 2 ; }
int main ( ) { int n = 10 ; cout << Nonagonal ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool divisibleBy20 ( string num ) {
int lastTwoDigits = stoi ( num . substr ( num . length ( ) - 2 , num . length ( ) - 1 ) ) ;
return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; }
int main ( ) { string num = "63284689320" ; if ( divisibleBy20 ( num ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isDvisibleBy12 ( string num ) {
if ( num . length ( ) >= 3 ) {
int d1 = ( int ) num [ num . length ( ) - 1 ] ;
if ( d1 % 2 != 0 ) return ( 0 ) ;
int d2 = ( int ) num [ num . length ( ) - 2 ] ;
int sum = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else {
int number = stoi ( num ) ; return ( number % 12 == 0 ) ; } }
int main ( ) { string num = "12244824607284961224" ; if ( isDvisibleBy12 ( num ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool check ( int n ) {
int d = sqrt ( n ) ;
if ( d * d == n ) return true ; return false ; }
int largestNonPerfectSquareNumber ( int a [ ] , int n ) {
int maxi = -1 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( ! check ( a [ i ] ) ) maxi = max ( a [ i ] , maxi ) ; } return maxi ; }
int main ( ) { int a [ ] = { 16 , 20 , 25 , 2 , 3 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
cout << largestNonPerfectSquareNumber ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printAP ( int a , int d , int n ) {
int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { cout << curr_term << " ▁ " ; curr_term = curr_term + d ; } }
int a = 2 ;
int d = 1 ;
int n = 5 ; printAP ( a , d , n ) ; return 0 ; }
#include <assert.h> NEW_LINE #include <math.h> NEW_LINE #include <stdio.h> NEW_LINE void printNonSquare ( int n ) { int curr_count = 2 , num = 2 , count = 0 ; while ( count < n ) {
for ( int i = 0 ; i < curr_count && count < n ; i ++ ) { printf ( " % d ▁ " , num ) ; count ++ ; num ++ ; }
num ++ ;
curr_count += 2 ; } }
int main ( ) { int n = 10 ; printNonSquare ( n ) ; return 0 ; }
int countZeros ( int a [ ] , int n ) { int count2 = 0 , count5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
while ( a [ i ] % 2 == 0 ) { a [ i ] = a [ i ] / 2 ; count2 ++ ; }
while ( a [ i ] % 5 == 0 ) { a [ i ] = a [ i ] / 5 ; count5 ++ ; } }
return ( count2 < count5 ) ? count2 : count5 ; }
int main ( ) { int a [ ] = { 10 , 100 , 20 , 30 , 50 , 90 , 12 , 80 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countZeros ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; }
int main ( ) { cout << squareSum ( 8 ) ; return 0 ; }
unsigned pwr [ 10 ] ;
bool isMunchhausen ( unsigned n ) { unsigned sum = 0 ; int temp = n ; while ( temp ) { sum += pwr [ ( temp % 10 ) ] ; temp /= 10 ; } return ( sum == n ) ; } void printMunchhausenNumbers ( int n ) {
for ( int i = 0 ; i < 10 ; i ++ ) pwr [ i ] = ( unsigned ) pow ( ( float ) i , ( float ) i ) ;
for ( unsigned i = 1 ; i <= n ; i ++ )
if ( isMunchhausen ( i ) ) cout << i << " STRNEWLINE " ; }
int main ( ) { int n = 10000 ; printMunchhausenNumbers ( n ) ; return 0 ; }
int kthdigit ( int a , int b , int k ) {
int p = pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) {
int rem = p % 10 ;
count ++ ;
if ( count == k ) return rem ;
p = p / 10 ; } return 0 ; }
int main ( ) { int a = 5 , b = 2 ; int k = 1 ; cout << kthdigit ( a , b , k ) ; return 0 ; }
long digSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
long PowDigSum ( long n , long x ) {
long sum = digSum ( n ) ;
long rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( ( long ) pow ( sum , 6 ) ) ; else return digSum ( ( long ) pow ( sum , rem ) ) ; }
int main ( ) { int n = 33333 ; int x = 332654 ; cout << PowDigSum ( n , x ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int maxArea ( int A [ ] , int len ) { int l = 0 ; int r = len - 1 ; int area = 0 ; while ( l < r ) {
area = max ( area , min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; }
int main ( ) { int a [ ] = { 1 , 5 , 4 , 3 } ; int b [ ] = { 3 , 1 , 2 , 4 , 5 } ; int len1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxArea ( a , len1 ) ; int len2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << endl << maxArea ( b , len2 ) ; }
int mobius ( int n ) { int p = 0 ;
if ( n % 2 == 0 ) { n = n / 2 ; p ++ ;
if ( n % 2 == 0 ) return 0 ; }
for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) {
if ( n % i == 0 ) { n = n / i ; p ++ ;
if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? -1 : 1 ; }
int main ( ) { int N = 17 ; cout << " Mobius ▁ Functions ▁ M ( N ) ▁ at ▁ N ▁ = ▁ " << N << " ▁ is : ▁ " << mobius ( N ) << endl ; cout << " Mobius ▁ Functions ▁ M ( N ) ▁ at ▁ N ▁ = ▁ " << 25 << " ▁ is : ▁ " << mobius ( 25 ) << endl ; cout << " Mobius ▁ Functions ▁ M ( N ) ▁ at ▁ N ▁ = ▁ " << 6 << " ▁ is : ▁ " << mobius ( 6 ) << endl ; }
int factorial ( int start , int end ) { int res = 1 ; for ( int i = start ; i <= end ; i ++ ) res *= i ; return res ; }
int sumofsquare ( int n ) { return factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ; }
int main ( ) { int n = 4 ; cout << sumofsquare ( n ) << endl ; return 0 ; }
double PHI = 1.6180339 ;
int fib ( int n ) {
if ( n < 6 ) return f [ n ] ;
int t = 5 , fn = 5 ; while ( t < n ) { fn = round ( fn * PHI ) ; t ++ ; } return fn ; }
int main ( ) { int n = 9 ; cout << n << " th ▁ Fibonacci ▁ Number ▁ = ▁ " << fib ( n ) << endl ; return 0 ; }
float func ( float x , float y ) { return ( x + y + x * y ) ; }
void euler ( float x0 , float y , float h , float x ) { float temp = -0 ;
while ( x0 < x ) { temp = y ; y = y + h * func ( x0 , y ) ; x0 = x0 + h ; }
cout << " Approximate ▁ solution ▁ at ▁ x ▁ = ▁ " << x << " ▁ is ▁ " << y << endl ; }
float x0 = 0 ; float y0 = 1 ; float h = 0.025 ;
float x = 0.1 ; euler ( x0 , y0 , h , x ) ; return 0 ; }
void solution ( int a , int b , int n ) {
for ( int i = 0 ; i * a <= n ; i ++ ) {
if ( ( n - ( i * a ) ) % b == 0 ) { cout << " x ▁ = ▁ " << i << " , ▁ y ▁ = ▁ " << ( n - ( i * a ) ) / b ; return ; } } cout << " No ▁ solution " ; }
int main ( ) { int a = 2 , b = 3 , n = 7 ; solution ( a , b , n ) ; return 0 ; }
int binomialCoeffSum ( int n ) { return ( 1 << n ) ; }
int main ( ) { int n = 4 ; printf ( " % d " , binomialCoeffSum ( n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void precisionCompute ( int x , int y , int n ) {
if ( y == 0 ) { cout << " Infinite " << endl ; return ; } if ( x == 0 ) { cout << 0 << endl ; return ; } if ( n <= 0 ) {
cout << x / y << endl ; return ; }
if ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) { cout << " - " ; x = x > 0 ? x : - x ; y = y > 0 ? y : - y ; }
int d = x / y ;
for ( int i = 0 ; i <= n ; i ++ ) { cout << d ; x = x - ( y * d ) ; if ( x == 0 ) break ; x = x * 10 ; d = x / y ; if ( i == 0 ) cout << " . " ; } }
int main ( ) { int x = 22 , y = 7 , n = 15 ; precisionCompute ( x , y , n ) ; return 0 ; }
void quadrant ( int x , int y ) { if ( x > 0 and y > 0 ) cout << " lies ▁ in ▁ First ▁ quadrant " ; else if ( x < 0 and y > 0 ) cout << " lies ▁ in ▁ Second ▁ quadrant " ; else if ( x < 0 and y < 0 ) cout << " lies ▁ in ▁ Third ▁ quadrant " ; else if ( x > 0 and y < 0 ) cout << " lies ▁ in ▁ Fourth ▁ quadrant " ; else if ( x == 0 and y > 0 ) cout << " lies ▁ at ▁ positive ▁ y ▁ axis " ; else if ( x == 0 and y < 0 ) cout << " lies ▁ at ▁ negative ▁ y ▁ axis " ; else if ( y == 0 and x < 0 ) cout << " lies ▁ at ▁ negative ▁ x ▁ axis " ; else if ( y == 0 and x > 0 ) cout << " lies ▁ at ▁ positive ▁ x ▁ axis " ; else cout << " lies ▁ at ▁ origin " ; }
int main ( ) { int x = 1 , y = 1 ;
quadrant ( x , y ) ; return 0 ; }
bool checkDigits ( int n ) {
while ( n ) { int dig = n % 10 ;
if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n /= 10 ; } return true ; }
bool prime ( int n ) { if ( n == 1 ) return false ;
for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
int isFullPrime ( int n ) {
return ( checkDigits ( n ) && prime ( n ) ) ; }
int main ( ) { int n = 53 ; if ( isFullPrime ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  500 NEW_LINE using namespace std ; int nthSHN ( int n , int dp [ ] ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != -1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; }
int main ( ) { int n = 6 ; int dp [ MAX ] ; memset ( dp , -1 , sizeof dp ) ; cout << nthSHN ( n , dp ) << endl ; return 0 ; }
int evenSum ( int n ) { int curr = 2 , sum = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ;
curr += 2 ; }
return sum ; }
int main ( ) { int n = 20 ; cout << " Sum ▁ of ▁ first ▁ " << n << " ▁ Even ▁ numbers ▁ is : ▁ " << evenSum ( n ) ; return 0 ; }
int evenSum ( int n ) {
return ( n * ( n + 1 ) ) ; }
int main ( ) { int n = 20 ; cout << " Sum ▁ of ▁ first ▁ " << n << " ▁ Even ▁ numbers ▁ is : ▁ " << evenSum ( n ) ; return 0 ; }
double kmphTOmph ( double kmph ) { return 0.6214 * kmph ; }
double mphTOkmph ( double mph ) { return mph * 1.60934 ; }
int main ( ) { double kmph = 150 ; double mph = 100 ; cout << " the ▁ speed ▁ in ▁ mph ▁ is ▁ " << kmphTOmph ( kmph ) << endl ; cout << " the ▁ speed ▁ in ▁ kmph ▁ is ▁ " << mphTOkmph ( mph ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findNumber ( int arr [ ] , int n ) {
int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ;
for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return -1 ; }
int main ( ) { int arr [ ] = { 2 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findNumber ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; vector < int > primes ;
void SieveofEratosthenes ( int n ) { bool visited [ n ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( int j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . push_back ( i ) ; } } bool specialPrimeNumbers ( int n , int k ) { SieveofEratosthenes ( n ) ; int count = 0 ; for ( int i = 0 ; i < primes . size ( ) ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) {
if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) { count ++ ; break ; } }
if ( count == k ) return true ; } return false ; }
int main ( ) { int n = 27 , k = 2 ; if ( specialPrimeNumbers ( n , k ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
void factorize ( long long n ) { int count = 0 ;
while ( ! ( n % 2 ) ) {
count ++ ; }
if ( count ) cout << 2 << " ▁ " << count << endl ;
for ( long long i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count ) cout << i << " ▁ " << count << endl ; }
if ( n > 2 ) cout << n << " ▁ " << 1 << endl ; }
int main ( ) { long long n = 1000000000000000000 ; factorize ( n ) ; return 0 ; }
int minimumMoves ( int A [ ] , int N ) {
int one = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ;
if ( one != 0 ) return N - one ;
int minimum = INT_MAX ; for ( int i = 0 ; i < N ; i ++ ) {
int g = A [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = min ( minimum , j - i ) ; break ; } } }
if ( minimum == INT_MAX ) return -1 ; else
return N + minimum - 1 ; }
int main ( ) { int A [ ] = { 2 , 4 , 3 , 9 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minimumMoves ( A , N ) ; return 0 ; }
void series ( int n , int d ) {
if ( d == 0 ) {
for ( int i = 0 ; i < n ; i ++ ) cout << "0 ▁ " ; cout << endl ; return ; }
if ( n % 2 == 0 ) {
for ( int i = 1 ; i <= n ; i ++ ) { cout << pow ( -1 , i ) * d << " ▁ " ; } cout << endl ; }
else {
float m = n ; float r = ( m / ( m - 1 ) ) ; float g = ( float ) ( d * ( float ) sqrtf ( r ) ) ;
cout << "0 ▁ " ;
for ( int i = 1 ; i < n ; i ++ ) { cout << pow ( -1 , i ) * g << " ▁ " ; } cout << endl ; } }
int main ( ) { int n = 3 , d = 3 ; series ( n , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { string str = to_string ( i ) ; countr += count ( str . begin ( ) , str . end ( ) , '1' ) ; } return countr ; }
int main ( ) { int n = 13 ; cout << countDigitOne ( n ) << endl ; n = 131 ; cout << countDigitOne ( n ) << endl ; n = 159 ; cout << countDigitOne ( n ) << endl ; return 0 ; }
long exponentiation ( long base , long exp ) { long t = 1L ; while ( exp > 0 ) {
if ( exp % 2 != 0 ) t = ( t * base ) % N ; base = ( base * base ) % N ; exp /= 2 ; } return t % N ; }
int main ( ) { long base = 5 ; long exp = 100000 ; long modulo = exponentiation ( base , exp ) ; cout << ( modulo ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int x ) { if ( x <= 1 ) return 1 ; int res = 2 ; for ( int i = 3 ; i <= x ; i ++ ) res = res * i ; return res ; } int gcdOfFactorial ( int m , int n ) { return factorial ( min ( m , n ) ) ; }
int main ( ) { int m = 5 , n = 9 ; cout << gcdOfFactorial ( m , n ) ; return 0 ; }
int recDigSum ( int n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } }
void check ( int n ) {
n = recDigSum ( n ) ;
if ( n == 2 or n == 3 or n == 5 or n == 7 ) cout << " Yes " ; else cout << " No " ; }
int main ( ) { int n = 5602 ; check ( n ) ; }
int findNumber ( int n ) {
int x = ( int ) floor ( ( -1 + sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ;
int base = ( x * ( x + 1 ) ) / 2 + 1 ;
return n - base + 1 ; }
int main ( ) { int n = 55 ; cout << findNumber ( n ) << endl ; return 0 ; }
int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; }
int main ( ) { int n = 10 ; cout << weightedMean ( n ) ; return 0 ; }
void calculate ( int a [ ] , int b [ ] , int n , int m ) { int mul = 1 ;
for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ;
for ( int i = 0 ; i < n ; i ++ ) { int x = floor ( a [ i ] / mul ) ; cout << x << " ▁ " ; } }
int main ( ) { int a [ ] = { 5 , 100 , 8 } ; int b [ ] = { 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; calculate ( a , b , n , m ) ; return 0 ; }
void print ( int n ) {
cout << n + n / 2 << endl ;
for ( int i = 2 ; i <= n ; i += 2 ) cout << i << " ▁ " ;
for ( int i = 1 ; i <= n ; i += 2 ) cout << i << " ▁ " ;
for ( int i = 2 ; i <= n ; i += 2 ) cout << i << " ▁ " ; }
int main ( ) { int n = 3 ; print ( n ) ; return 0 ; }
int digitLCM ( int n ) { int lcm = 1 ; while ( n > 0 ) { lcm = boost :: math :: lcm ( n % 10 , lcm ) ;
if ( lcm == 0 ) return 0 ; n = n / 10 ; } return lcm ; }
int main ( ) { long n = 397 ; cout << digitLCM ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <time.h> NEW_LINE #define e  2.71828 NEW_LINE using namespace std ;
int roundNo ( float num ) { return num < 0 ? num - 0.5 : num + 0.5 ; }
void printBestCandidate ( int candidate [ ] , int n ) {
int sample_size = roundNo ( n / e ) ; cout << " Sample size is "
int best = 0 ; for ( int i = 1 ; i < sample_size ; i ++ ) if ( candidate [ i ] > candidate [ best ] ) best = i ;
for ( int i = sample_size ; i < n ; i ++ ) if ( candidate [ i ] >= candidate [ best ] ) { best = i ; break ; } if ( best >= sample_size ) cout << endl << " Best ▁ candidate ▁ found ▁ is ▁ " << best + 1 << " ▁ with ▁ talent ▁ " << candidate [ best ] << endl ; else cout << " Couldn ' t ▁ find ▁ a ▁ best ▁ candidate STRNEWLINE " ; }
int main ( ) { int n = 8 ;
int candidate [ n ] ;
srand ( time ( 0 ) ) ; for ( int i = 0 ; i < n ; i ++ ) candidate [ i ] = 1 + rand ( ) % 8 ; cout << " Candidate ▁ : ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << i + 1 << " ▁ " ; cout << endl ; cout << " ▁ Talents ▁ : ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << candidate [ i ] << " ▁ " ; printBestCandidate ( candidate , n ) ; return 0 ; }
float u_cal ( float u , int n ) { float temp = u ; for ( int i = 1 ; i < n ; i ++ ) temp = temp * ( u + i ) ; return temp ; }
int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; }
int n = 5 ; float x [ ] = { 1891 , 1901 , 1911 , 1921 , 1931 } ;
float y [ n ] [ n ] ; y [ 0 ] [ 0 ] = 46 ; y [ 1 ] [ 0 ] = 66 ; y [ 2 ] [ 0 ] = 81 ; y [ 3 ] [ 0 ] = 93 ; y [ 4 ] [ 0 ] = 101 ;
for ( int i = 1 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= i ; j -- ) y [ j ] [ i ] = y [ j ] [ i - 1 ] - y [ j - 1 ] [ i - 1 ] ; }
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) cout << setw ( 4 ) << y [ i ] [ j ] << " TABSYMBOL " ; cout << endl ; }
float value = 1925 ;
float sum = y [ n - 1 ] [ 0 ] ; float u = ( value - x [ n - 1 ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { sum = sum + ( u_cal ( u , i ) * y [ n - 1 ] [ i ] ) / fact ( i ) ; } cout << " Value at " ▁ < < ▁ value ▁ < < ▁ " is " << sum << endl ; return 0 ; }
int sumDigitSquare ( int n ) { int sq = 0 ; while ( n ) { int digit = n % 10 ; sq += digit * digit ; n = n / 10 ; } return sq ; }
bool isHappy ( int n ) {
while ( 1 ) {
if ( n == 1 ) return true ;
n = sumDigitSquare ( n ) ;
if ( n == 4 ) return false ; } return false ; }
int main ( ) { int n = 23 ; if ( isHappy ( n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned long long findSumSubsets ( int n ) {
return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; }
int main ( ) { int n = 3 ; cout << findSumSubsets ( n ) ; return 0 ; }
int findMin ( int a [ ] , int n ) {
double sum = 0 ; for ( int i = 0 ; i < n ; i ++ )
int x = exp ( sum / n ) ;
return x + 1 ; }
int a [ ] = { 3 , 2 , 1 , 4 } ;
int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
cout << findMin ( a , n ) ; }
int countdigits ( int N ) { int count = 0 ; while ( N ) { count ++ ; N = N / 10 ; } return count ; }
void cyclic ( int N ) { int num = N ; int n = countdigits ( N ) ; while ( 1 ) { cout << num << endl ;
int rem = num % 10 ; int div = num / 10 ; num = ( pow ( 10 , n - 1 ) ) * rem + div ;
if ( num == N ) break ; } }
int main ( ) { int N = 5674 ; cyclic ( N ) ; return 0 ; }
bool isPrime ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool checkCircular ( int N ) {
int count = 0 , temp = N ; while ( temp ) { count ++ ; temp /= 10 ; } int num = N ; while ( isPrime ( num ) ) {
int rem = num % 10 ; int div = num / 10 ; num = ( pow ( 10 , count - 1 ) ) * rem + div ;
if ( num == N ) return true ; } return false ; }
int main ( ) { int N = 1193 ; if ( checkCircular ( N ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
bool sackRace ( int p1 , int s1 , int p2 , int s2 ) {
return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; }
int main ( ) { int p1 = 4 , s1 = 4 , p2 = 8 , s2 = 2 ; sackRace ( p1 , s1 , p2 , s2 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; void solve ( int n ) {
float a = ( float ) n / 2 ;
if ( n % 2 != 0 )
cout << ceil ( a ) - 1 << " ▁ " << floor ( a ) + 1 << endl ; else {
if ( ( int ) a % 2 == 0 ) {
cout << ceil ( a ) - 1 << " ▁ " << floor ( a ) + 1 << endl ; } else {
cout << ceil ( a ) - 2 << " ▁ " << floor ( a ) + 2 << endl ; } } }
int main ( ) { int n = 34 ; solve ( n ) ; return 0 ; }
float P = 1 , R = 1 , T = 1 ;
float SI = ( P * T * R ) / 100 ;
cout << " Simple ▁ Interest ▁ = ▁ " << SI ; return 0 ; }
int countDigits ( int a , int b ) { int count = 0 ;
int p = abs ( a * b ) ;
if ( p == 0 ) return 1 ;
while ( p > 0 ) { count ++ ; p = p / 10 ; }
return count ; }
int main ( ) { int a = 33 ; int b = -24 ; cout << " Number ▁ of ▁ digits ▁ = ▁ " << countDigits ( a , b ) ; return 0 ; }
void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) cout << "1" ; else cout << "0" ; }
int mul = pow ( a , b ) ; int ans = mul / x ;
int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ;
cout << ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; }
int main ( ) { int a = 349 , b = 1 , x = 4 ; multiple ( a , b , x ) ; return 0 ; }
int maxSum ( int n ) {
if ( n == 1 ) return 1 ;
else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; }
int main ( ) { int n = 3 ; cout << maxSum ( n ) ; return 0 ; }
int minNum ( int arr [ ] , int n ) {
bool odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minNum ( arr , n ) << " n " ; return 0 ; }
bool checkJumbled ( int num ) {
if ( num / 10 == 0 ) return true ;
while ( num != 0 ) {
if ( num / 10 == 0 ) return true ;
int digit1 = num % 10 ;
int digit2 = ( num / 10 ) % 10 ;
if ( abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; }
return true ; }
int num = -1234 ; if ( checkJumbled ( num ) ) cout << " True ▁ STRNEWLINE " ; else cout << " False ▁ STRNEWLINE " ;
num = -1247 ; if ( checkJumbled ( num ) ) cout << " True ▁ STRNEWLINE " ; else cout << " False ▁ STRNEWLINE " ; return 0 ; }
int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ;
n = n >> 1 ; } return pos ; }
int josephify ( int n ) {
int position = msbPos ( n ) ;
int j = 1 << ( position - 1 ) ;
n = n ^ j ;
n = n << 1 ;
n = n | 1 ; return n ; }
int main ( ) { int n = 41 ; cout << josephify ( n ) ; return 0 ;
int countXorPair ( int arr [ ] , int n ) {
int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ )
if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; }
return count ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countXorPair ( arr , n ) ; return 0 ; }
int powmod ( int x , int y , int p ) {
while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) sqrt ( m ) + 1 ; unordered_map < int , int > value ;
for ( int i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( int j = 0 ; j < n ; ++ j ) {
int cur = ( powmod ( a , j , m ) * b ) % m ;
if ( value [ cur ] ) { int ans = value [ cur ] * n - j ;
if ( ans < m ) return ans ; } } return -1 ; }
int main ( ) { int a = 2 , b = 3 , m = 5 ; cout << discreteLogarithm ( a , b , m ) << endl ; a = 3 , b = 7 , m = 11 ; cout << discreteLogarithm ( a , b , m ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) sqrt ( m ) + 1 ;
int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; unordered_map < int , int > value ;
for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( ! value [ cur ] ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) {
if ( value [ cur ] ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return -1 ; }
int main ( ) { int a = 2 , b = 3 , m = 5 ; cout << discreteLogarithm ( a , b , m ) << endl ; a = 3 , b = 7 , m = 11 ; cout << discreteLogarithm ( a , b , m ) ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; string nthprimedigitsnumber ( int number ) { int rem ; string num ; while ( number ) {
rem = number % 4 ; switch ( rem ) {
case 1 : num . push_back ( '2' ) ; break ;
case 2 : num . push_back ( '3' ) ; break ;
case 3 : num . push_back ( '5' ) ; break ;
case 0 : num . push_back ( '7' ) ; break ; } if ( number % 4 == 0 ) number -- ; number = number / 4 ; } reverse ( num . begin ( ) , num . end ( ) ) ; return num ; }
int main ( ) { int number = 21 ; cout << nthprimedigitsnumber ( 10 ) << " STRNEWLINE " ; cout << nthprimedigitsnumber ( 21 ) << " STRNEWLINE " ; return 0 ; }
int countPairs ( int N ) { int count = 0 ;
for ( int i = 1 ; i <= cbrt ( N ) ; i ++ ) {
int cb = i * i * i ;
int diff = N - cb ;
int cbrtDiff = cbrt ( diff ) ;
if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; }
return count ; }
for ( int i = 1 ; i <= 10 ; i ++ ) cout << " For ▁ n ▁ = ▁ " << i << " , ▁ " << countPairs ( i ) << " ▁ pair ▁ exists STRNEWLINE " ; return 0 ; }
void printEqualModNumbers ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int d = arr [ n - 1 ] - arr [ 0 ] ;
if ( d == 0 ) { cout << " Infinite ▁ solution " ; return ; }
vector < int > v ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . push_back ( i ) ; if ( i != d / i ) v . push_back ( d / i ) ; } }
for ( int i = 0 ; i < v . size ( ) ; i ++ ) { int temp = arr [ 0 ] % v [ i ] ;
int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ;
if ( j == n ) cout << v [ i ] << " ▁ " ; } }
int main ( ) { int arr [ ] = { 38 , 6 , 34 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printEqualModNumbers ( arr , n ) ; return 0 ; }
int FirstDigit ( int arr [ ] , int n ) {
double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + log10 ( arr [ i ] * 1.0 ) ;
double fract_S = S - floor ( S ) ;
int ans = pow ( 10 , fract_S ) ; return ans ; }
int main ( ) { int arr [ ] = { 5 , 8 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << FirstDigit ( arr , n ) << endl ; return 0 ; }
int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) {
int d = temp % 10 ; temp /= 10 ;
if ( d > 0 && n % d == 0 ) count ++ ; } return count ; }
int main ( ) { int n = 1012 ; cout << countDigit ( n ) << endl ; return 0 ; }
int makeOdd ( int n ) {
if ( n % 2 != 0 ) return 1 ;
int resul = 1 ; while ( n % 2 == 0 ) { n /= 2 ; resul *= 2 ; } return resul ; }
int main ( ) { int n = 36 ; cout << makeOdd ( n ) ; return 0 ; }
int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; }
int main ( ) { int n = 9 , x = 4 ; printf ( " % d " , closestMultiple ( n , x ) ) ; return 0 ; }
void printCubes ( int a , int b ) {
int acrt = cbrt ( a ) ; int bcrt = cbrt ( b ) ;
for ( int i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) cout << i * i * i << " ▁ " ; }
int main ( ) { int a = 24 , b = 576 ; cout << " Perfect ▁ cubes ▁ in ▁ given ▁ range : STRNEWLINE " << printCubes ( a , b ) ; return 0 ; }
int number0f2s ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = n / 10 ; } return count ; }
int numberOf2sinRange ( int n ) {
int count = 0 ;
for ( int i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; }
int main ( ) { cout << numberOf2sinRange ( 22 ) ; cout << endl ; cout << numberOf2sinRange ( 100 ) ; return 0 ; }
int minToggle ( int arr [ ] , int n ) { int zero [ n + 1 ] ; zero [ 0 ] = 0 ;
for ( int i = 1 ; i <= n ; ++ i ) {
if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; }
int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; }
int main ( ) { int arr [ ] = { 1 , 0 , 1 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minToggle ( arr , n ) << " STRNEWLINE " ; return 0 ; }
bool check ( string str ) { int n = str . length ( ) ;
if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ;
int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ;
return ( digitSum % 3 == 0 ) ; }
int main ( ) { string str = "1332" ; check ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int res = 0 ; int checkRecursive ( int num , int x , int k , int n ) { if ( x == 0 ) res ++ ; int r = ( int ) floor ( pow ( num , 1.0 / n ) ) ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - ( int ) pow ( i , n ) , i , n ) ; } return res ; }
int check ( int x , int n ) { return checkRecursive ( x , x , 0 , n ) ; }
int main ( ) { cout << ( check ( 10 , 2 ) ) ; return 0 ; }
int reverseNum ( int n ) { int rem , rev = 0 ; while ( n ) { rem = n % 10 ; rev = rev * 10 + rem ; n /= 10 ; } return rev ; }
bool isPalindrom ( int num ) { return num == reverseNum ( num ) ; }
int nthPalindrome ( int n , int k ) {
int num = ( int ) pow ( 10 , k - 1 ) ; while ( true ) {
if ( isPalindrom ( num ) ) -- n ;
if ( ! n ) break ;
++ num ; } return num ; }
int main ( ) { int n = 6 , k = 5 ; printf ( " % dth ▁ palindrome ▁ of ▁ % d ▁ digit ▁ = ▁ % d STRNEWLINE " , n , k , nthPalindrome ( n , k ) ) ; n = 10 , k = 6 ; printf ( " % dth ▁ palindrome ▁ of ▁ % d ▁ digit ▁ = ▁ % d " , n , k , nthPalindrome ( n , k ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nthPalindrome ( int n , int k ) {
int temp = ( k & 1 ) ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) pow ( 10 , temp ) ; palindrome += n - 1 ;
printf ( " % d " , palindrome ) ;
if ( k & 1 ) palindrome /= 10 ;
while ( palindrome ) { printf ( " % d " , palindrome % 10 ) ; palindrome /= 10 ; } printf ( " STRNEWLINE " ) ; }
int main ( ) { int n = 6 , k = 5 ; printf ( " % dth ▁ palindrome ▁ of ▁ % d ▁ digit ▁ = ▁ " , n , k ) ; nthPalindrome ( n , k ) ; n = 10 , k = 6 ; printf ( " % dth ▁ palindrome ▁ of ▁ % d ▁ digit ▁ = ▁ " , n , k ) ; nthPalindrome ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001
long long phi [ MAX ] , result [ MAX ] ;
void computeTotient ( ) {
phi [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( ! phi [ i ] ) { phi [ i ] = i - 1 ; for ( int j = ( i << 1 ) ; j < MAX ; j += i ) { if ( ! phi [ j ] ) phi [ j ] = j ; phi [ j ] = ( phi [ j ] / i ) * ( i - 1 ) ; } } } }
void sumOfGcdPairs ( ) {
computeTotient ( ) ; for ( int i = 1 ; i < MAX ; ++ i ) {
for ( int j = 2 ; i * j < MAX ; ++ j ) result [ i * j ] += i * phi [ j ] ; }
for ( int i = 2 ; i < MAX ; i ++ ) result [ i ] += result [ i - 1 ] ; }
sumOfGcdPairs ( ) ; int N = 4 ; cout << " Summation ▁ of ▁ " << N << " ▁ = ▁ " << result [ N ] << endl ; ; N = 12 ; cout << " Summation ▁ of ▁ " << N << " ▁ = ▁ " << result [ N ] << endl ; N = 5000 ; cout << " Summation ▁ of ▁ " << N << " ▁ = ▁ " << result [ N ] ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ;
vector < int > solve ( int v [ ] ) { vector < int > res ;
int all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] ;
res . push_back ( all3 - v [ 1 ] * 2 ) ; res . push_back ( all3 - v [ 2 ] * 2 ) ; res . push_back ( all3 - v [ 0 ] * 2 ) ; return res ; }
void findVertex ( int xmid [ ] , int ymid [ ] ) {
vector < int > V1 = solve ( xmid ) ;
vector < int > V2 = solve ( ymid ) ;
for ( int i = 0 ; i < 3 ; i ++ ) cout << V1 [ i ] << " ▁ " << V2 [ i ] << endl ; }
int main ( ) { int xmid [ N ] = { 5 , 4 , 5 } ; int ymid [ N ] = { 3 , 4 , 5 } ; findVertex ( xmid , ymid ) ; return 0 ; }
int nthElement ( int a , int b , int n ) { vector < int > seq ;
for ( int i = 1 ; i <= n ; i ++ ) seq . push_back ( a * i ) ;
sort ( seq . begin ( ) , seq . end ( ) ) ;
for ( int i = 1 , k = n ; i <= n && k ; i ++ ) {
if ( ! binary_search ( seq . begin ( ) , seq . end ( ) , b * i ) ) {
seq . push_back ( b * i ) ; sort ( seq . begin ( ) , seq . end ( ) ) ; k -- ; } } return seq [ n - 1 ] ; }
int main ( ) { int a = 3 , b = 5 , n = 5 ; cout << nthElement ( a , b , n ) << endl ; return 0 ; }
int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ; }
int countGCD ( int L , int R , int g ) {
L = ( L + g - 1 ) / g ; R = R / g ;
int ans = 0 ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; }
int main ( ) { int L = 1 , R = 11 , g = 5 ; cout << countGCD ( L , R , g ) << endl ; return 0 ; }
int dig [ ] = { 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 } ; int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ;
if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; }
int main ( ) { int n = 14 ; cout << lastNon0Digit ( n ) ; return 0 ; }
int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; }
int firstFactorialDivisibleNumber ( int x ) {
int new_x = x ; for ( i = 1 ; i < x ; i ++ ) {
new_x /= gcd ( i , new_x ) ;
if ( new_x == 1 ) break ; } return i ; }
int main ( void ) { int x = 16 ; cout << firstFactorialDivisibleNumber ( x ) ; return 0 ; }
void sieve ( bool prime [ ] , int n ) { prime [ 0 ] = prime [ 1 ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } }
int maxDigitInPrimes ( int L , int R ) { bool prime [ R + 1 ] ; memset ( prime , 0 , sizeof ( prime ) ) ;
sieve ( prime , R ) ;
int freq [ 10 ] = { 0 } ; int val ;
for ( int i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) {
while ( p ) { freq [ p % 10 ] ++ ; p /= 10 ; } } }
int max = freq [ 0 ] , ans = 0 ; for ( int j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ( max != 0 ) ? ans : -1 ; }
int main ( ) { int L = 1 , R = 20 ; cout << maxDigitInPrimes ( L , R ) << endl ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int commDiv ( int a , int b ) {
int n = gcd ( a , b ) ;
int result = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) {
if ( n % i == 0 ) {
if ( n / i == i ) result += 1 ; else result += 2 ; } } return result ; }
int main ( ) { int a = 12 , b = 24 ; cout << commDiv ( a , b ) ; return 0 ; }
ll spellsCount ( string num ) { int n = num . length ( ) ;
ll result = 1 ;
for ( int i = 0 ; i < n ; i ++ ) {
int count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; }
result = result * pow ( 2 , count - 1 ) ; } return result ; }
int main ( ) { string num = "11112" ; cout << spellsCount ( num ) ; return 0 ; }
int numSquareSum ( int n ) { int squareSum = 0 ; while ( n ) { squareSum += ( n % 10 ) * ( n % 10 ) ; n /= 10 ; } return squareSum ; }
bool isHappynumber ( int n ) { int slow , fast ;
slow = fast = n ; do {
slow = numSquareSum ( slow ) ;
fast = numSquareSum ( numSquareSum ( fast ) ) ; } while ( slow != fast ) ;
return ( slow == 1 ) ; }
int main ( ) { int n = 13 ; if ( isHappynumber ( n ) ) cout << n << " ▁ is ▁ a ▁ Happy ▁ number STRNEWLINE " ; else cout << n << " ▁ is ▁ not ▁ a ▁ Happy ▁ number STRNEWLINE " ; }
vector < ull > allPrimes ;
void sieve ( int n ) {
vector < bool > prime ( n + 1 , true ) ;
for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } }
for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push_back ( p ) ; }
ull factorialDivisors ( ull n ) {
ull result = 1 ;
for ( int i = 0 ; i < allPrimes . size ( ) ; i ++ ) {
ull p = allPrimes [ i ] ;
ull exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * allPrimes [ i ] ; }
result = result * ( exp + 1 ) ; }
return result ; }
int main ( ) { cout << factorialDivisors ( 6 ) ; return 0 ; }
int nonFibonacci ( int n ) {
int prevPrev = 1 , prev = 2 , curr = 3 ;
while ( n > 0 ) {
prevPrev = prev ; prev = curr ; curr = prevPrev + prev ;
n = n - ( curr - prev - 1 ) ; }
n = n + ( curr - prev - 1 ) ;
return prev + n ; }
int main ( ) { cout << nonFibonacci ( 5 ) ; return 0 ; }
int gcd ( int a , int b ) {
if ( a == 0 ) return b ; if ( b == 0 ) return a ;
int k ; for ( k = 0 ; ( ( a b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; }
while ( ( a & 1 ) == 0 ) a >>= 1 ;
do {
while ( ( b & 1 ) == 0 ) b >>= 1 ;
if ( a > b ) swap ( a , b ) ; b = ( b - a ) ; } while ( b != 0 ) ;
return a << k ; }
int main ( ) { int a = 34 , b = 17 ; printf ( " Gcd ▁ of ▁ given ▁ numbers ▁ is ▁ % d STRNEWLINE " , gcd ( a , b ) ) ; return 0 ; }
void findNDigitNumsUtil ( int n , char * out , int index , int evenSum , int oddSum ) {
if ( index > n ) return ;
if ( index == n ) {
if ( abs ( evenSum - oddSum ) == 1 ) { out [ index ] = ' ▁ ' ; cout << out ; } return ; }
if ( index & 1 ) { for ( int i = 0 ; i <= 9 ; i ++ ) { out [ index ] = i + '0' ; findNDigitNumsUtil ( n , out , index + 1 , evenSum , oddSum + i ) ; } }
{ for ( int i = 0 ; i <= 9 ; i ++ ) { out [ index ] = i + '0' ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } } }
int findNDigitNums ( int n ) {
char out [ n + 1 ] ;
int index = 0 ;
int evenSum = 0 , oddSum = 0 ;
for ( int i = 1 ; i <= 9 ; i ++ ) { out [ index ] = i + '0' ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } }
int main ( ) { int n = 3 ; findNDigitNums ( n ) ; return 0 ; }
string one [ ] = { " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " } ;
string ten [ ] = { " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " } ;
string numToWords ( int n , string s ) { string str = " " ;
if ( n > 19 ) str += ten [ n / 10 ] + one [ n % 10 ] ; else str += one [ n ] ;
if ( n ) str += s ; return str ; }
string convertToWords ( long n ) {
string out ;
out += numToWords ( ( n / 10000000 ) , " crore ▁ " ) ;
out += numToWords ( ( ( n / 100000 ) % 100 ) , " lakh ▁ " ) ;
out += numToWords ( ( ( n / 1000 ) % 100 ) , " thousand ▁ " ) ;
out += numToWords ( ( ( n / 100 ) % 10 ) , " hundred ▁ " ) ; if ( n > 100 && n % 100 ) out += " and ▁ " ;
out += numToWords ( ( n % 100 ) , " " ) ; return out ; }
long n = 438237764 ;
cout << convertToWords ( n ) << endl ; return 0 ; }
int gcd ( int a , int b ) { return ( a % b == 0 ) ? abs ( b ) : gcd ( b , a % b ) ; }
bool isPossible ( int a , int b , int c ) { return ( c % gcd ( a , b ) == 0 ) ; }
int a = 3 , b = 6 , c = 9 ; isPossible ( a , b , c ) ? cout << " Possible STRNEWLINE " : cout << " Not ▁ Possible STRNEWLINE " ;
a = 3 , b = 6 , c = 8 ; isPossible ( a , b , c ) ? cout << " Possible STRNEWLINE " : cout << " Not ▁ Possible STRNEWLINE " ;
a = 2 , b = 5 , c = 1 ; isPossible ( a , b , c ) ? cout << " Possible STRNEWLINE " : cout << " Not ▁ Possible STRNEWLINE " ; return 0 ; }
void farey ( int n ) {
double x1 = 0 , y1 = 1 , x2 = 1 , y2 = n ; printf ( " % .0f / % . 0f ▁ % .0f / % . 0f " , x1 , y1 , x2 , y2 ) ;
while ( y != 1.0 ) {
x = floor ( ( y1 + n ) / y2 ) * x2 - x1 ; y = floor ( ( y1 + n ) / y2 ) * y2 - y1 ;
printf ( " ▁ % .0f / % . 0f " , x , y ) ;
x1 = x2 , x2 = x , y1 = y2 , y2 = y ; } }
int main ( ) { int n = 7 ; cout << " Farey ▁ Sequence ▁ of ▁ order ▁ " << n << " ▁ is STRNEWLINE " ; farey ( n ) ; return 0 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; }
void findSmallest ( int a , int b ) {
int lcm = ( a * b ) / gcd ( a , b ) ; cout << " x ▁ = ▁ " << lcm / a << " y = " }
int main ( ) { int a = 25 , b = 35 ; findSmallest ( a , b ) ; return 0 ; }
int power ( int x , unsigned int y , int p ) {
while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
int modInverse ( int a , int p ) { return power ( a , p - 2 , p ) ; }
int modFact ( int n , int p ) {
if ( p <= n ) return 0 ;
int res = ( p - 1 ) ;
for ( int i = n + 1 ; i < p ; i ++ ) res = ( res * modInverse ( i , p ) ) % p ; return res ; }
int main ( ) { int n = 25 , p = 29 ; cout << modFact ( n , p ) ; return 0 ; }
int countWays ( int n ) {
for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; }
int main ( ) { int n = 8 ; cout << countWays ( n ) ; return 0 ; }
int pairAndSum ( int arr [ ] , int n ) {
for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; }
int main ( ) { int arr [ ] = { 5 , 10 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << pairAndSum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) {
if ( n <= 1 ) return false ;
for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
int main ( ) { isPrime ( 11 ) ? cout << " ▁ true STRNEWLINE " : cout << " ▁ false STRNEWLINE " ; isPrime ( 15 ) ? cout << " ▁ true STRNEWLINE " : cout << " ▁ false STRNEWLINE " ; return 0 ; }
void computeTotient ( int n ) {
long long phi [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ )
for ( int p = 2 ; p <= n ; p ++ ) {
if ( phi [ p ] == p ) {
phi [ p ] = p - 1 ;
for ( int i = 2 * p ; i <= n ; i += p ) {
phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } }
for ( int i = 1 ; i <= n ; i ++ ) cout << " Totient ▁ of ▁ " << i << " ▁ is ▁ " << phi [ i ] << endl ; }
int main ( ) { int n = 12 ; computeTotient ( n ) ; return 0 ; }
int sumBetweenTwoKth ( int arr [ ] , int n , int k1 , int k2 ) {
sort ( arr , arr + n ) ;
int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; }
int main ( ) { int arr [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; int k1 = 3 , k2 = 6 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumBetweenTwoKth ( arr , n , k1 , k2 ) ; return 0 ; }
int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ;
while ( n ) { pow = pow * 5 ;
if ( n & 1 ) answer += pow ;
} return answer ; }
int main ( ) { int n = 5 ; cout << " nth ▁ magic ▁ number ▁ is ▁ " << nthMagicNo ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; unsigned countOfMultiples ( unsigned n ) {
return ( n / 3 + n / 5 - n / 15 ) ; }
int main ( ) { cout << countOfMultiples ( 6 ) << endl ; cout << countOfMultiples ( 16 ) << endl ; return 0 ; }
int gcd ( int a , int b ) {
if ( a == 0 ) return b ; if ( b == 0 ) return a ;
if ( a == b ) return a ;
if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int main ( ) { int a = 98 , b = 56 ; cout << " GCD ▁ of ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << gcd ( a , b ) ; return 0 ; }
bool isDefeat ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == '0' && s2 [ i ] == '1' ) || ( s1 [ i ] == '1' && s2 [ i ] == '0' ) ) continue ; else if ( ( s1 [ i ] == '0' && s2 [ i ] == ' Z ' ) || ( s1 [ i ] == ' Z ' && s2 [ i ] == '0' ) ) continue ; else { return true ; } } return false ; }
int main ( ) { string s1 = { "01001101ZZ " } ; string s2 = { "10Z1001000" } ;
int n = 10 ; if ( isDefeat ( s1 , s2 , n ) ) cout << " Defeat " ; else cout << " Victory " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  3
bool check ( int a [ N ] [ M ] , int b [ N ] [ M ] ) {
for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) {
if ( a [ i ] [ j ] != b [ i ] [ j ] ) {
a [ i ] [ j ] ^= 1 ; a [ 0 ] [ 0 ] ^= 1 ; a [ 0 ] [ j ] ^= 1 ; a [ i ] [ 0 ] ^= 1 ; } } }
for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) {
if ( a [ i ] [ j ] != b [ i ] [ j ] ) return false ; } } return true ; }
int a [ N ] [ N ] = { { 0 , 1 , 0 } , { 0 , 1 , 0 } , { 1 , 0 , 0 } } ;
int b [ N ] [ N ] = { { 1 , 0 , 0 } , { 1 , 0 , 0 } , { 1 , 0 , 0 } } ; if ( check ( a , b ) ) cout << " Yes " ; else cout << " No " ; }
int FindIndexKthBit ( int n , int k ) { int cnt = 0 ; int ind = 0 ;
while ( n ) {
if ( n & 1 ) cnt ++ ;
if ( cnt == k ) return ind ;
ind ++ ;
n = n >> 1 ; } return -1 ; }
int main ( ) { int n = 15 , k = 3 ; int ans = FindIndexKthBit ( n , k ) ; if ( ans != -1 ) cout << ans ; else cout << " No ▁ k - th ▁ set ▁ bit " ; return 0 ; }
int minDistance ( int n1 , int n2 ) {
int bitCount1 = floor ( log2 ( n1 ) ) + 1 ; int bitCount2 = floor ( log2 ( n2 ) ) + 1 ;
int bitDiff = abs ( bitCount1 - bitCount2 ) ; int maxBitCount = max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * pow ( 2 , bitDiff ) ; } else { n1 = n1 * pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ;
int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; }
int main ( ) { int n1 = 12 , n2 = 5 ; cout << minDistance ( n1 , n2 ) ; return 0 ; }
int printMaxAfterRemoval ( string s ) { bool flag = false ; int n = s . length ( ) ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( s [ i ] == '0' && flag == false ) { flag = true ; continue ; } else cout << s [ i ] ; } }
string s = "1001" ;
printMaxAfterRemoval ( s ) ; }
int bitPos ( int n1 , int n2 ) {
if ( n1 == n2 ) return 0 ;
int bitCount1 = floor ( log2 ( n1 ) ) + 1 ; int bitCount2 = floor ( log2 ( n2 ) ) + 1 ;
int bitDiff = abs ( bitCount1 - bitCount2 ) ; int maxBitCount = max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * pow ( 2 , bitDiff ) ; } else { n1 = n1 * pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; }
int main ( ) { int n1 = 53 , n2 = 55 ; cout << bitPos ( n1 , n2 ) ; return 0 ; }
int countOddPair ( int A [ ] , int N ) {
int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ;
int evenPairCount = count * ( count - 1 ) / 2 ;
int totPairs = N * ( N - 1 ) / 2 ;
return totPairs - evenPairCount ; }
int main ( ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << countOddPair ( A , N ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void ReplaceElements ( int arr [ ] , int n ) {
if ( n <= 1 ) return ;
int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ;
for ( int i = 1 ; i < n - 1 ; i ++ ) {
int curr = arr [ i ] ;
arr [ i ] = prev ^ arr [ i + 1 ] ;
prev = curr ; }
arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; }
int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ReplaceElements ( arr , n ) ;
for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
int OR ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; }
int main ( ) { int a [ ] = { 1 , 4 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
cout << OR ( a , n ) ; return 0 ; }
int bit ( int n ) { int count = 0 ; while ( n ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
int maxSumOfBits ( int arr [ ] , int n ) {
for ( int i = 0 ; i < n ; i ++ ) {
arr [ i ] = bit ( arr [ i ] ) ; } int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; for ( int i = 1 ; i < n ; i ++ ) {
excl_new = ( incl > excl ) ? incl : excl ;
incl = excl + arr [ i ] ; excl = excl_new ; }
return ( ( incl > excl ) ? incl : excl ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSumOfBits ( arr , n ) ; return 0 ; }
char increment ( unsigned char i ) {
i = - ( ~ i ) ; return i ; }
int main ( ) { char n = ' a ' ; cout << increment ( n ) ; return 0 ; }
int findOddPair ( int A [ ] , int N ) { int i , count = 0 ;
for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; }
return count * ( N - count ) ; }
int main ( ) { int a [ ] = { 5 , 4 , 7 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
cout << findOddPair ( a , n ) << endl ; return 0 ; }
int MSBPosition ( long long int N ) { int msb_p = -1 ; while ( N ) { N = N >> 1 ; msb_p ++ ; } return msb_p ; }
long long int findBitwiseOR ( long long int L , long long int R ) { long long int res = 0 ;
int msb_p1 = MSBPosition ( L ) ;
int msb_p2 = MSBPosition ( R ) ; while ( msb_p1 == msb_p2 ) { long long int res_val = ( 1 << msb_p1 ) ;
res += res_val ; L -= res_val ; R -= res_val ;
msb_p1 = MSBPosition ( L ) ; msb_p2 = MSBPosition ( R ) ; }
msb_p1 = max ( msb_p1 , msb_p2 ) ;
for ( int i = msb_p1 ; i >= 0 ; i -- ) { long long int res_val = ( 1 << i ) ; res += res_val ; } return res ; }
int main ( ) { int L = 12 , R = 18 ; cout << findBitwiseOR ( L , R ) << endl ; return 0 ; }
int maxOR ( long long arr [ ] , int n , int k , int x ) { long long preSum [ n + 1 ] , suffSum [ n + 1 ] ; long long res , pow = 1 ;
for ( int i = 0 ; i < k ; i ++ ) pow *= x ;
preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ;
suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ;
res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; }
int main ( ) { long long arr [ ] = { 1 , 2 , 4 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 , x = 3 ; cout << maxOR ( arr , n , k , x ) << " STRNEWLINE " ; return 0 ; }
int turnOnK ( int n , int k ) {
if ( k <= 0 ) return n ;
return ( n | ( 1 << ( k - 1 ) ) ) ; }
int main ( ) { int n = 4 ; int k = 2 ; cout << turnOnK ( n , k ) ; return 0 ; }
int minSum ( int a [ ] , int n ) {
sort ( a , a + n ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; }
int main ( ) { int arr [ ] = { 5 , 3 , 0 , 7 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ required ▁ sum ▁ is ▁ " << minSum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printKthBit ( unsigned int n , unsigned int k ) { cout << ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; }
int main ( ) { unsigned int n = 13 , k = 2 ;
printKthBit ( n , k ) ; return 0 ; }
int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } int countOfOddsPascal ( int n ) {
int c = countSetBits ( n ) ;
return pow ( 2 , c ) ; }
int main ( ) { int n = 20 ; cout << countOfOddsPascal ( n ) ; return 0 ; }
void ansQueries ( int prefeven [ ] , int prefodd [ ] , int l , int r ) {
if ( ( r - l + 1 ) % 2 == 0 ) cout << "0" ;
else {
if ( l % 2 == 0 ) cout << ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ;
else cout < < ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; } cout << endl ; }
void wrapper ( int arr [ ] , int n , int l [ ] , int r [ ] , int q ) { int prefodd [ N ] = { 0 } , prefeven [ N ] = { 0 } ;
for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } int i = 0 ; while ( i != q ) { query ( prefeven , prefodd , l [ i ] , r [ i ] ) ; i ++ ; } }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int l [ ] = { 1 , 1 , 2 } ; int r [ ] = { 2 , 3 , 4 } ; int q = sizeof ( l ) / sizeof ( l [ 0 ] ) ; ansQueries ( arr , n , l , r , q ) ; return 0 ; }
int solve ( int p [ ] , int n ) { int G = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( p [ i ] & 1 )
G ^= ( p [ i ] + 1 ) ;
G ^= ( p [ i ] - 1 ) ; } return G ; }
int n = 3 ;
int p [ 3 ] = { 32 , 49 , 58 } ;
int res = solve ( p , n ) ;
cout << " Player ▁ 2 ▁ wins " ;
cout << " Player ▁ 1 ▁ wins " ; return 0 ; }
int checkBit ( int pattern , int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; }
int maxAND ( int arr [ ] , int n ) { int res = 0 , count ;
for ( int bit = 31 ; bit >= 0 ; bit -- ) {
count = checkBit ( res | ( 1 << bit ) , arr , n ) ;
if ( count >= 2 ) res |= ( 1 << bit ) ; } return res ; }
int main ( ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ AND ▁ Value ▁ = ▁ " << maxAND ( arr , n ) ; return 0 ; }
bool checkPowerof8 ( int n ) {
double i = log ( n ) / log ( 8 ) ;
return ( i - trunc ( i ) < 0.000001 ) ; }
int main ( ) { int n = 65 ; checkPowerof8 ( n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
bool bit_anagram_check ( ull a ) {
return ( _popcnt64 ( a ) == ( ULL_SIZE >> 1 ) ) ; }
int main ( ) { ull a = 4294967295 ; cout << bit_anagram_check ( a ) << endl ; return 0 ; }
int findSum ( int n ) { int sum = 0 ;
for ( int i = 1 ; ( 1 << i ) < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ;
if ( num <= n ) sum += num ; } }
return sum ; }
int main ( ) { int n = 10 ; cout << findSum ( n ) ; return 0 ; }
int posOfRightMostDiffBit ( int m , int n ) { return ffs ( m ^ n ) ; }
int main ( ) { int m = 52 , n = 4 ; cout << " Position ▁ = ▁ " << posOfRightMostDiffBit ( m , n ) ; return 0 ; }
int setKthBit ( int n , int k ) {
return ( ( 1 << k ) n ) ; }
int main ( ) { int n = 10 , k = 2 ; cout << " Kth ▁ bit ▁ set ▁ number ▁ = ▁ " << setKthBit ( n , k ) ; return 0 ; }
void reverseArray ( int arr [ ] , int n ) {
int x = ( INT_MIN / INT_MAX ) ;
for ( int i = 0 ; i < n / 2 ; i ++ )
swap ( arr [ i ] , arr [ n + ( x * i ) + x ] ) ; }
int main ( ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; reverseArray ( arr , n ) ;
for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
void reverseArray ( int arr [ ] , int n ) {
for ( int i = 0 ; i < n / 2 ; i ++ )
swap ( arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] ) ; }
int main ( ) { int arr [ ] = { 5 , 3 , 7 , 2 , 1 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; reverseArray ( arr , n ) ;
for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
int maxXORInRange ( int L , int R ) {
int LXR = L ^ R ;
int msbPos = 0 ; while ( LXR ) { msbPos ++ ; LXR >>= 1 ; }
int maxXOR = 0 ; int two = 1 ; while ( msbPos -- ) { maxXOR += two ; two <<= 1 ; } return maxXOR ; }
int main ( ) { int L = 8 ; int R = 20 ; cout << maxXORInRange ( L , R ) << endl ; return 0 ; }
unsigned int CountZeroBit ( int n ) { unsigned int count = 0 ; while ( n ) { if ( ! ( n & 1 ) ) count ++ ; n >>= 1 ; } return count ; }
int CountORandSumEqual ( int N ) {
int count = CountZeroBit ( N ) ;
return ( 1 << count ) ; }
int main ( ) { int N = 10 ; cout << CountORandSumEqual ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNumbers ( int n ) {
int k = 0 ;
while ( n > 0 ) {
if ( ( n & 1 ) == 0 ) count += pow ( 2 , k ) ;
k += 1 ;
n >>= 1 ; } return count ; }
int main ( ) { int n = 11 ; cout << countNumbers ( n ) << endl ; return 0 ; }
bool isMultipleOf4 ( int n ) { if ( n == 1 ) return false ;
int XOR = 0 ; for ( int i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ;
return ( XOR == n ) ; }
for ( int n = 0 ; n <= 42 ; n ++ ) if ( isMultipleOf4 ( n ) ) cout << n << " ▁ " ; return 0 ; }
bool isMultipleOf4 ( long long n ) { if ( n == 0 ) return true ; return ( ( ( n >> 2 ) << 2 ) == n ) ; }
for ( int n = 0 ; n <= 42 ; n ++ ) if ( isMultipleOf4 ( n ) ) cout << n << " ▁ " ; return 0 ; }
int countSetBits ( int x ) { unsigned int count = 0 ; while ( x ) { x &= ( x - 1 ) ; count ++ ; } return count ; }
int ceilLog2 ( int x ) { int count = 0 ; x -- ; while ( x > 0 ) { x = x >> 1 ; count ++ ; } return count ; }
bool isBleak ( int n ) {
for ( int x = n - ceilLog2 ( n ) ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; }
int main ( ) { isBleak ( 3 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isBleak ( 4 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
int countStrings ( int n ) {
int a [ n ] , b [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; }
return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; }
int main ( ) { cout << countStrings ( 5 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE #define M  4 NEW_LINE using namespace std ;
void printDistance ( int mat [ N ] [ M ] ) { int ans [ N ] [ M ] ;
for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i ] [ j ] = INT_MAX ;
for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) {
for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) {
if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) ; } }
for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) cout << ans [ i ] [ j ] << " ▁ " ; cout << endl ; } }
int main ( ) { int mat [ N ] [ M ] = { 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 1 , 0 } ; printDistance ( mat ) ; return 0 ; }
bool isMinHeap ( int level [ ] , int n ) {
for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) {
if ( level [ i ] > level [ 2 * i + 1 ] ) return false ; if ( 2 * i + 2 < n ) {
if ( level [ i ] > level [ 2 * i + 2 ] ) return false ; } } return true ; }
int main ( ) { int level [ ] = { 10 , 15 , 14 , 25 , 30 } ; int n = sizeof ( level ) / sizeof ( level [ 0 ] ) ; if ( isMinHeap ( level , n ) ) cout << " True " ; else cout << " False " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int mostFrequent ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int max_count = 1 , res = arr [ 0 ] , curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } }
if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
int main ( ) { int arr [ ] = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << mostFrequent ( arr , n ) ; return 0 ; }
bool areDisjoint ( int set1 [ ] , int set2 [ ] , int m , int n ) {
for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( set1 [ i ] == set2 [ j ] ) return false ;
return true ; }
int main ( ) { int set1 [ ] = { 12 , 34 , 11 , 9 , 3 } ; int set2 [ ] = { 7 , 2 , 1 , 5 } ; int m = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; int n = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; areDisjoint ( set1 , set2 , m , n ) ? cout << " Yes " : cout << " ▁ No " ; return 0 ; }
void findMissing ( int a [ ] , int b [ ] , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) cout << a [ i ] << " ▁ " ; } }
int main ( ) { int a [ ] = { 1 , 2 , 6 , 3 , 4 , 5 } ; int b [ ] = { 2 , 4 , 3 , 1 , 0 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 1 ] ) ; findMissing ( a , b , n , m ) ; return 0 ; }
bool areEqual ( int arr1 [ ] , int arr2 [ ] , int n , int m ) {
if ( n != m ) return false ;
sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + m ) ;
for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ;
return true ; }
int main ( ) { int arr1 [ ] = { 3 , 5 , 2 , 5 , 2 } ; int arr2 [ ] = { 2 , 3 , 5 , 5 , 2 } ; int n = sizeof ( arr1 ) / sizeof ( int ) ; int m = sizeof ( arr2 ) / sizeof ( int ) ; if ( areEqual ( arr1 , arr2 , n , m ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool isProduct ( int arr [ ] , int n , int x ) {
for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; }
int main ( ) { int arr [ ] = { 10 , 20 , 9 , 40 } ; int x = 400 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; isProduct ( arr , n , x ) ? cout << " Yesn " : cout << " Non " ; x = 190 ; isProduct ( arr , n , x ) ? cout << " Yesn " : cout << " Non " ; return 0 ; }
int findGreatest ( int arr [ ] , int n ) { int result = -1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = max ( result , arr [ i ] ) ; return result ; }
int main ( ) { int arr [ ] = { 30 , 10 , 9 , 3 , 35 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findGreatest ( arr , n ) ; return 0 ; }
int getPairsCount ( int arr [ ] , int n , int sum ) {
int count = 0 ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; }
int main ( ) { int arr [ ] = { 1 , 5 , 7 , -1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; cout << " Count ▁ of ▁ pairs ▁ is ▁ " << getPairsCount ( arr , n , sum ) ; return 0 ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ;
for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ )
if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ;
return count ; }
int main ( ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int arr2 [ ] = { 2 , 3 , 5 , 8 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int x = 10 ; cout << " Count ▁ = ▁ " << countPairs ( arr1 , arr2 , m , n , x ) ; return 0 ; }
bool isPresent ( int arr [ ] , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ;
if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; }
return false ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) {
int value = x - arr1 [ i ] ;
if ( isPresent ( arr2 , 0 , n - 1 , value ) ) count ++ ; }
return count ; }
int main ( ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int arr2 [ ] = { 2 , 3 , 5 , 8 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int x = 10 ; cout << " Count ▁ = ▁ " << countPairs ( arr1 , arr2 , m , n , x ) ; return 0 ; }
int countPairs ( int arr1 [ ] , int arr2 [ ] , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ;
while ( l < m && r >= 0 ) {
if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; }
else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ;
else r -- ; }
return count ; }
int main ( ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int arr2 [ ] = { 2 , 3 , 5 , 8 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int x = 10 ; cout << " Count ▁ = ▁ " << countPairs ( arr1 , arr2 , m , n , x ) ; return 0 ; }
bool isPresent ( int arr [ ] , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ;
if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; }
return false ; }
int countQuadruples ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int arr4 [ ] , int n , int x ) { int count = 0 ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) {
int T = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ;
if ( isPresent ( arr4 , 0 , n , x - T ) )
count ++ ; }
return count ; }
int arr1 [ ] = { 1 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 7 , 8 } ; int arr3 [ ] = { 1 , 4 , 6 , 10 } ; int arr4 [ ] = { 2 , 4 , 7 , 8 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int x = 30 ; cout << " Count ▁ = ▁ " << countQuadruples ( arr1 , arr2 , arr3 , arr4 , n , x ) ; return 0 ; }
int countPairs ( int arr [ ] , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ;
for ( int k = 0 ; k < n ; k ++ ) {
if ( arr [ k ] == product ) { result ++ ; break ; } } } }
return result ; }
int main ( ) { int arr [ ] = { 6 , 2 , 4 , 12 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; }
int main ( ) { int n = 9 ; printf ( " % d " , fib ( n ) ) ; getchar ( ) ; return 0 ; }
unsigned factTR ( unsigned int n , unsigned int a ) { if ( n == 1 ) return a ; return factTR ( n - 1 , n * a ) ; }
unsigned int fact ( unsigned int n ) { return factTR ( n , 1 ) ; }
int main ( ) { cout << fact ( 5 ) ; return 0 ; }
void findPairs ( int arr1 [ ] , int arr2 [ ] , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) cout << arr1 [ i ] << " ▁ " << arr2 [ j ] << endl ; }
int main ( ) { int arr1 [ ] = { 1 , 2 , 3 , 7 , 5 , 4 } ; int arr2 [ ] = { 0 , 7 , 4 , 3 , 2 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( int ) ; int m = sizeof ( arr2 ) / sizeof ( int ) ; int x = 8 ; findPairs ( arr1 , arr2 , n , m , x ) ; return 0 ; }
void findPair ( int arr [ ] , int n ) { bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { cout << arr [ i ] << " ▁ " << arr [ j ] << endl ; found = true ; } } } } if ( found == false ) cout << " Not ▁ exist " << endl ; }
int main ( ) { int arr [ ] = { 10 , 4 , 8 , 13 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findPair ( arr , n ) ; return 0 ; }
bool printPairs ( int arr [ ] , int n , int k ) { bool isPairFound = true ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
if ( i != j && arr [ i ] % arr [ j ] == k ) { cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << " ▁ " ; isPairFound = true ; } } } return isPairFound ; }
int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; if ( printPairs ( arr , n , k ) == false ) cout << " No ▁ such ▁ pair ▁ exists " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ASCII_SIZE  256 NEW_LINE using namespace std ; char getMaxOccuringChar ( char * str ) {
int count [ ASCII_SIZE ] = { 0 } ;
int len = strlen ( str ) ;
int max = 0 ;
for ( int i = 0 ; i < len ; i ++ ) { count [ str [ i ] ] ++ ; if ( max < count [ str [ i ] ] ) { max = count [ str [ i ] ] ; result = str [ i ] ; } } return result ; }
int main ( ) { char str [ ] = " sample ▁ string " ; cout << " Max ▁ occurring ▁ character ▁ is ▁ " << getMaxOccuringChar ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstNonRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return -1 ; }
int main ( ) { int arr [ ] = { 9 , 4 , 9 , 6 , 7 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << firstNonRepeating ( arr , n ) ; return 0 ; }
void subarrayDivisibleByK ( int arr [ ] , int n , int k ) {
map < int , int > mp ;
int s = 0 , e = 0 , maxs = 0 , maxe = 0 ;
mp [ arr [ 0 ] % k ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ;
while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] -- ; s ++ ; }
mp [ mod ] ++ ; e ++ ;
if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e ; maxs = s ; } } cout << " The ▁ maximum ▁ size ▁ is ▁ " << maxe - maxs + 1 << " ▁ and ▁ " " the ▁ subarray ▁ is ▁ as ▁ follows STRNEWLINE " ; for ( int i = maxs ; i <= maxe ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int k = 3 ; int arr [ ] = { 5 , 10 , 15 , 20 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; subarrayDivisibleByK ( arr , n , k ) ; return 0 ; }
bool findTriplet ( int a1 [ ] , int a2 [ ] , int a3 [ ] , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; }
int main ( ) { int a1 [ ] = { 1 , 2 , 3 , 4 , 5 } ; int a2 [ ] = { 2 , 3 , 6 , 1 , 2 } ; int a3 [ ] = { 3 , 2 , 4 , 5 , 6 } ; int sum = 9 ; int n1 = sizeof ( a1 ) / sizeof ( a1 [ 0 ] ) ; int n2 = sizeof ( a2 ) / sizeof ( a2 [ 0 ] ) ; int n3 = sizeof ( a3 ) / sizeof ( a3 [ 0 ] ) ; findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) ? cout << " Yes " : cout << " No " ; return 0 ; }
int minInsertion ( string str ) {
int n = str . length ( ) ;
int res = 0 ;
int count [ 26 ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < 26 ; i ++ ) if ( count [ i ] % 2 == 1 ) res ++ ;
return ( res == 0 ) ? 0 : res - 1 ; }
int main ( ) { string str = " geeksforgeeks " ; cout << minInsertion ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findDiff ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) {
if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = max ( max_count , count ) ; min_count = min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; }
int main ( ) { int arr [ ] = { 7 , 8 , 4 , 5 , 4 , 1 , 1 , 7 , 7 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findDiff ( arr , n ) << " STRNEWLINE " ; return 0 ; }
int maxDiff ( int arr [ ] , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { bool isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) {
if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return abs ( SubsetSum_1 - SubsetSum_2 ) ; }
int main ( ) { int arr [ ] = { 4 , 2 , -3 , 3 , -2 , -2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ Difference ▁ = ▁ " << maxDiff ( arr , n ) ; return 0 ; }
int maxDiff ( int arr [ ] , int n ) { int result = 0 ;
sort ( arr , arr + n ) ;
for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += abs ( arr [ i ] ) ; else i ++ ; }
if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += abs ( arr [ n - 1 ] ) ;
return result ; }
int main ( ) { int arr [ ] = { 4 , 2 , -3 , 3 , -2 , -2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ Difference ▁ = ▁ " << maxDiff ( arr , n ) ; return 0 ; }
void printAllAPTriplets ( int arr [ ] , int n ) { unordered_set < int > s ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) {
int diff = arr [ j ] - arr [ i ] ; if ( s . find ( arr [ i ] - diff ) != s . end ( ) ) cout << arr [ i ] - diff << " ▁ " << arr [ i ] << " ▁ " << arr [ j ] << endl ; } s . insert ( arr [ i ] ) ; } }
int main ( ) { int arr [ ] = { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAllAPTriplets ( arr , n ) ; return 0 ; }
void printAllAPTriplets ( int arr [ ] , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) {
for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) {
if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { cout << arr [ j ] << " ▁ " << arr [ i ] << " ▁ " << arr [ k ] << endl ;
k ++ ; j -- ; }
else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } }
int main ( ) { int arr [ ] = { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printAllAPTriplets ( arr , n ) ; return 0 ; }
int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ;
for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] * arr [ j ] * arr [ k ] == m ) count ++ ; return count ; }
int main ( ) { int arr [ ] = { 1 , 4 , 6 , 2 , 3 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 24 ; cout << countTriplets ( arr , n , m ) ; return 0 ; }
int countPairs ( int arr [ ] , int n ) { int ans = 0 ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ )
if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; }
int main ( ) { int arr [ ] = { 1 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) << endl ; return 0 ; }
void preCalculate ( int binary [ ] , int n , pair < int , int > left [ ] ) { int count1 = 0 , count0 = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
left [ i ] . first = count1 ; left [ i ] . second = count0 ;
if ( binary [ i ] ) count1 ++ ; else count0 ++ ; } }
int main ( ) { int binary [ ] = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( binary ) / sizeof ( binary [ 0 ] ) ; pair < int , int > left [ n ] ; preCalculate ( binary , n , left ) ;
int queries [ ] = { 0 , 1 , 2 , 4 } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ;
for ( int i = 0 ; i < q ; i ++ ) cout << left [ queries [ i ] ] . first << " ▁ ones ▁ " << left [ queries [ i ] ] . second << " ▁ zeros STRNEWLINE " ; return 0 ; }
static int pos1 = -1 ;
static int pos2 = -1 ;
bool equiSumUtil ( int arr [ ] , int n ) {
int pre [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; pre [ i ] = sum ; }
int suf [ n ] ; sum = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; suf [ i ] = sum ; }
int total_sum = sum ; int i = 0 , j = n - 1 ; while ( i < j - 1 ) { if ( pre [ i ] == total_sum / 3 ) { pos1 = i ; } if ( suf [ j ] == total_sum / 3 ) { pos2 = j ; } if ( pos1 != -1 && pos2 != -1 ) {
if ( suf [ pos1 + 1 ] - suf [ pos2 ] == total_sum / 3 ) { return true ; } else { return false ; } } if ( pre [ i ] < suf [ j ] ) { i ++ ; } else { j -- ; } } return false ; } void equiSum ( int arr [ ] , int n ) { bool ans = equiSumUtil ( arr , n ) ; if ( ans ) { cout << " First ▁ Segment ▁ : ▁ " ; for ( int i = 0 ; i <= pos1 ; i ++ ) { cout << arr [ i ] << " ▁ " ; } cout << endl ; cout << " Second ▁ Segment ▁ : ▁ " ; for ( int i = pos1 + 1 ; i < pos2 ; i ++ ) { cout << arr [ i ] << " ▁ " ; } cout << endl ; cout << " Third ▁ Segment ▁ : ▁ " ; for ( int i = pos2 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } cout << endl ; } else { cout << " Array ▁ cannot ▁ be ▁ divided ▁ into ▁ three ▁ equal ▁ sum ▁ segments " ; } }
int main ( ) { int arr [ ] = { 1 , 3 , 6 , 2 , 7 , 1 , 2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; equiSum ( arr , n ) ; return 0 ; }
int getRightMin ( int arr [ ] , int n ) {
int min = arr [ 0 ] ; int rightMin = 0 ; int i = 1 ; while ( i < n ) {
if ( arr [ i ] == min ) rightMin = i ; i *= 2 ; } i = rightMin + 1 ;
while ( i < n && arr [ i ] == min ) { rightMin = i ; i ++ ; } return rightMin ; }
int getLeftMax ( int arr [ ] , int n ) {
int max = arr [ n - 1 ] ; int leftMax = n - 1 ; int i = n - 2 ; while ( i > 0 ) {
if ( arr [ i ] == max ) leftMax = i ; i /= 2 ; } i = leftMax - 1 ;
while ( i >= 0 && arr [ i ] == max ) { leftMax = i ; i -- ; } return leftMax ; }
int main ( ) { int arr [ ] = { 0 , 0 , 1 , 2 , 5 , 5 , 6 , 8 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << " Minimum ▁ left ▁ : ▁ " << 0 << " STRNEWLINE " ; cout << " Minimum ▁ right ▁ : ▁ " << getRightMin ( arr , n ) << " STRNEWLINE " ; cout << " Maximum ▁ left ▁ : ▁ " << getLeftMax ( arr , n ) << " STRNEWLINE " ;
cout << " Maximum ▁ right ▁ : ▁ " << ( n - 1 ) ; }
int countNum ( int arr [ ] , int n ) { int count = 0 ;
sort ( arr , arr + n ) ;
for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; }
int main ( ) { int arr [ ] = { 3 , 5 , 8 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countNum ( arr , n ) << endl ; return 0 ; }
int countSubarrays ( int arr [ ] , int n ) {
int difference = 0 ; int ans = 0 ;
fill_n ( hash_positive , n + 1 , 0 ) ; fill_n ( hash_negative , n + 1 , 0 ) ;
hash_positive [ 0 ] = 1 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( arr [ i ] & 1 == 1 ) difference ++ ; else difference -- ;
if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; }
else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } }
return ans ; }
int main ( ) { int arr [ ] = { 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << " Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays " " ▁ are ▁ " << countSubarrays ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100
bool search ( int mat [ ] [ MAX ] , int m , int n , int x ) {
int i = m - 1 , j = 0 ; while ( i >= 0 && j < n ) { if ( mat [ i ] [ j ] == x ) return true ; if ( mat [ i ] [ j ] > x ) i -- ;
else j ++ ; } return false ; }
int main ( ) { int mat [ ] [ MAX ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , { 50 , 60 , 70 , 80 } , } ; if ( search ( mat , 5 , 4 , 29 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printGreaterCount ( string str ) { int len = str . length ( ) , right [ len ] = { 0 } ; for ( int i = 0 ; i < len ; i ++ ) for ( int j = i + 1 ; j < len ; j ++ ) if ( str [ i ] < str [ j ] ) right [ i ] ++ ; for ( int i = 0 ; i < len ; i ++ ) cout << right [ i ] << " ▁ " ; }
int main ( ) { string str = " abcd " ; printGreaterCount ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int appearsNBy3 ( int arr [ ] , int n ) { int count1 = 0 , count2 = 0 ;
int first = INT_MAX , second = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) {
if ( first == arr [ i ] ) count1 ++ ;
else if ( second == arr [ i ] ) count2 ++ ; else if ( count1 == 0 ) { count1 ++ ; first = arr [ i ] ; } else if ( count2 == 0 ) { count2 ++ ; second = arr [ i ] ; }
else { count1 -- ; count2 -- ; } } count1 = 0 ; count2 = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == first ) count1 ++ ; else if ( arr [ i ] == second ) count2 ++ ; } if ( count1 > n / 3 ) return first ; if ( count2 > n / 3 ) return second ; return -1 ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << appearsNBy3 ( arr , n ) << endl ; return 0 ; }
int count4Divisibiles ( int arr [ ] , int n ) {
int freq [ 4 ] = { 0 , 0 , 0 , 0 } ;
for ( int i = 0 ; i < n ; i ++ ) ++ freq [ arr [ i ] % 4 ] ;
int ans = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ;
ans += freq [ 2 ] * ( freq [ 2 ] - 1 ) / 2 ;
ans += freq [ 1 ] * freq [ 3 ] ; return ans ; }
int main ( ) { int arr [ ] = { 2 , 2 , 1 , 7 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << count4Divisibiles ( arr , n ) ; return 0 ; }
int countMaxSetBits ( int left , int right ) {
int max_count = -1 , num ; for ( int i = left ; i <= right ; ++ i ) { int temp = i , cnt = 0 ;
while ( temp ) { if ( temp & 1 ) ++ cnt ; temp >>= 1 ; }
if ( cnt > max_count ) { max_count = cnt ; num = i ; } } return num ; }
int main ( ) { int l = 1 , r = 5 ; cout << countMaxSetBits ( l , r ) << " STRNEWLINE " ; l = 1 , r = 10 ; cout << countMaxSetBits ( l , r ) ; return 0 ; }
int recaman ( int n ) {
arr [ 0 ] = 0 ; printf ( " % d , ▁ " , arr [ 0 ] ) ;
for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) {
if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; printf ( " % d , ▁ " , arr [ i ] ) ; } }
int main ( ) { int n = 17 ; recaman ( n ) ; return 0 ; }
void recaman ( int n ) { if ( n <= 0 ) return ;
printf ( " % d , ▁ " , 0 ) ; unordered_set < int > s ; s . insert ( 0 ) ;
int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ;
if ( curr < 0 || s . find ( curr ) != s . end ( ) ) curr = prev + i ; s . insert ( curr ) ; printf ( " % d , ▁ " , curr ) ; prev = curr ; } }
int main ( ) { int n = 17 ; recaman ( n ) ; return 0 ; }
int findArea ( int arr [ ] , int n ) {
sort ( arr , arr + n , greater < int > ( ) ) ;
int dimension [ 2 ] = { 0 , 0 } ;
for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ )
if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ;
return ( dimension [ 0 ] * dimension [ 1 ] ) ; }
int main ( ) { int arr [ ] = { 4 , 2 , 1 , 4 , 6 , 6 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findArea ( arr , n ) ; return 0 ; }
bool pairInSortedRotated ( int arr [ ] , int n , int x ) {
int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;
int l = ( i + 1 ) % n ;
int r = i ;
while ( l != r ) {
if ( arr [ l ] + arr [ r ] == x ) return true ;
if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ;
else r = ( n + r - 1 ) % n ; } return false ; }
int main ( ) { int arr [ ] = { 11 , 15 , 6 , 8 , 9 , 10 } ; int sum = 16 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( pairInSortedRotated ( arr , n , sum ) ) cout << " Array ▁ has ▁ two ▁ elements ▁ with ▁ sum ▁ 16" ; else cout << " Array ▁ doesn ' t ▁ have ▁ two ▁ elements ▁ with ▁ sum ▁ 16 ▁ " ; return 0 ; }
int pairsInSortedRotated ( int arr [ ] , int n , int x ) {
int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ;
int l = ( i + 1 ) % n ;
int r = i ;
int cnt = 0 ;
while ( l != r ) {
if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ;
if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; }
else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ;
else r = ( n + r - 1 ) % n ; } return cnt ; }
int main ( ) { int arr [ ] = { 11 , 15 , 6 , 7 , 9 , 10 } ; int sum = 16 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << pairsInSortedRotated ( arr , n , sum ) ; return 0 ; }
int maxSum ( int arr [ ] , int n ) {
int arrSum = 0 ;
int currVal = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arrSum = arrSum + arr [ i ] ; currVal = currVal + ( i * arr [ i ] ) ; }
int maxVal = currVal ;
for ( int j = 1 ; j < n ; j ++ ) { currVal = currVal + arrSum - n * arr [ n - j ] ; if ( currVal > maxVal ) maxVal = currVal ; }
return maxVal ; }
int main ( void ) { int arr [ ] = { 10 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Max sum is " return 0 ; }
int maxSum ( int arr [ ] , int n ) {
int res = INT_MIN ;
for ( int i = 0 ; i < n ; i ++ ) {
int curr_sum = 0 ;
for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; }
res = max ( res , curr_sum ) ; } return res ; }
int main ( ) { int arr [ ] = { 8 , 3 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n ) {
int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ;
int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ;
int res = curr_val ;
for ( int i = 1 ; i < n ; i ++ ) {
int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ;
curr_val = next_val ;
res = max ( res , next_val ) ; } return res ; }
int main ( ) { int arr [ ] = { 8 , 3 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) << endl ; return 0 ; }
int countRotations ( int arr [ ] , int n ) {
int min = arr [ 0 ] , min_index ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; }
int main ( ) { int arr [ ] = { 15 , 18 , 2 , 3 , 6 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countRotations ( arr , n ) ; return 0 ; }
int countRotations ( int arr [ ] , int low , int high ) {
if ( high < low ) return 0 ;
if ( high == low ) return low ;
int mid = low + ( high - low ) / 2 ;
if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ;
if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ;
if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; }
int main ( ) { int arr [ ] = { 15 , 18 , 2 , 3 , 6 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countRotations ( arr , 0 , n - 1 ) ; return 0 ; }
void preprocess ( int arr [ ] , int n , int temp [ ] ) {
for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = temp [ i + n ] = arr [ i ] ; }
void leftRotate ( int arr [ ] , int n , int k , int temp [ ] ) {
int start = k % n ;
for ( int i = start ; i < start + n ; i ++ ) cout << temp [ i ] << " ▁ " ; cout << endl ; }
int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int temp [ 2 * n ] ; preprocess ( arr , n , temp ) ; int k = 2 ; leftRotate ( arr , n , k , temp ) ; k = 3 ; leftRotate ( arr , n , k , temp ) ; k = 4 ; leftRotate ( arr , n , k , temp ) ; return 0 ; }
void leftRotate ( int arr [ ] , int n , int k ) {
for ( int i = k ; i < k + n ; i ++ ) cout << arr [ i % n ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; leftRotate ( arr , n , k ) ; cout << endl ; k = 3 ; leftRotate ( arr , n , k ) ; cout << endl ; k = 4 ; leftRotate ( arr , n , k ) ; cout << endl ; return 0 ; }
void reverseArray ( int arr [ ] , int start , int end ) { while ( start < end ) { std :: swap ( arr [ start ] , arr [ end ] ) ; start ++ ; end -- ; } }
void rightRotate ( int arr [ ] , int d , int n ) { reverseArray ( arr , 0 , n - 1 ) ; reverseArray ( arr , 0 , d - 1 ) ; reverseArray ( arr , d , n - 1 ) ; }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) std :: cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; rightRotate ( arr , k , n ) ; printArray ( arr , n ) ; return 0 ; }
int maxHamming ( int arr [ ] , int n ) {
int brr [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ;
int maxHam = 0 ;
for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ;
if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; }
int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxHamming ( arr , n ) ; return 0 ; }
void leftRotate ( int arr [ ] , int n , int k ) {
int mod = k % n ;
for ( int i = 0 ; i < n ; i ++ ) cout << ( arr [ ( mod + i ) % n ] ) << " ▁ " ; cout << " STRNEWLINE " ; }
int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ;
leftRotate ( arr , n , k ) ; k = 3 ;
leftRotate ( arr , n , k ) ; k = 4 ;
leftRotate ( arr , n , k ) ; return 0 ; }
int findElement ( int arr [ ] , int ranges [ ] [ 2 ] , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) {
int left = ranges [ i ] [ 0 ] ; int right = ranges [ i ] [ 1 ] ;
if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } }
return arr [ index ] ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ;
int rotations = 2 ;
int ranges [ rotations ] [ 2 ] = { { 0 , 2 } , { 0 , 3 } } ; int index = 1 ; cout << findElement ( arr , ranges , rotations , index ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void splitArr ( int arr [ ] , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) {
int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } }
int main ( ) { int arr [ ] = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int position = 2 ; splitArr ( arr , 6 , position ) ; for ( int i = 0 ; i < n ; ++ i ) printf ( " % d ▁ " , arr [ i ] ) ; return 0 ; }
void sort_shell_metzner ( int arr [ ] , int n ) {
m = n ; while ( m > 0 ) {
m /= 2 ;
k = n - m ;
j = 0 ; do {
i = j ; do {
l = i + m ;
if ( arr [ i ] > arr [ l ] ) { swap ( arr [ i ] , arr [ l ] ) ;
i -= m ; } else break ; } while ( i >= 0 ) ;
j ++ ; } while ( j <= k ) ; } }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 0 , -2 , 8 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
sort_shell_metzner ( arr , n ) ;
printArray ( arr , n ) ; return 0 ; }
void rearrangeArr ( int arr [ ] , int n ) {
int evenPos = n / 2 ;
int oddPos = n - evenPos ; int tempArr [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ;
sort ( tempArr , tempArr + n ) ; int j = oddPos - 1 ;
for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ;
for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; }
for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrangeArr ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MaxSumDifference ( int a [ ] , int n ) {
vector < int > finalSequence ;
sort ( a , a + n ) ;
for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . push_back ( a [ i ] ) ; finalSequence . push_back ( a [ n - i - 1 ] ) ; }
if ( n % 2 != 0 ) finalSequence . push_back ( a [ n / 2 ] ) ;
int MaximumSum = 0 ;
for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ; }
MaximumSum = MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ;
return MaximumSum ; }
int main ( ) { int a [ ] = { 1 , 2 , 4 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MaxSumDifference ( a , n ) << endl ; }
int minSwap ( int * arr , int n , int k ) {
int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ;
int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ;
int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) {
if ( arr [ i ] > k ) -- bad ;
if ( arr [ j ] > k ) ++ bad ;
ans = min ( ans , bad ) ; } return ans ; }
int main ( ) { int arr [ ] = { 2 , 1 , 5 , 6 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << minSwap ( arr , n , k ) << " STRNEWLINE " ; int arr1 [ ] = { 2 , 7 , 9 , 5 , 8 , 7 , 4 } ; n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; k = 5 ; cout << minSwap ( arr1 , n , k ) ; return 0 ; }
int maxProductSubarrayOfSizeK ( int A [ ] , int n , int k ) {
sort ( A , A + n ) ;
int product = 1 ;
if ( A [ n - 1 ] == 0 && ( k & 1 ) ) return 0 ;
if ( A [ n - 1 ] <= 0 && ( k & 1 ) ) { for ( int i = n - 1 ; i >= n - k ; i -- ) product *= A [ i ] ; return product ; }
int i = 0 ;
int j = n - 1 ;
if ( k & 1 ) { product *= A [ j ] ; j -- ; k -- ; }
k >>= 1 ;
for ( int itr = 0 ; itr < k ; itr ++ ) {
int left_product = A [ i ] * A [ i + 1 ] ;
int right_product = A [ j ] * A [ j - 1 ] ;
if ( left_product > right_product ) { product *= left_product ; i += 2 ; } else { product *= right_product ; j -= 2 ; } }
return product ; }
int main ( ) { int A [ ] = { 1 , 2 , -1 , -3 , -6 , 4 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int k = 4 ; cout << maxProductSubarrayOfSizeK ( A , n , k ) ; return 0 ; }
void reorder ( int arr [ ] , int index [ ] , int n ) { int temp [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ;
for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } }
int main ( ) { int arr [ ] = { 50 , 40 , 70 , 60 , 90 } ; int index [ ] = { 3 , 0 , 4 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; reorder ( arr , index , n ) ; cout << " Reordered ▁ array ▁ is : ▁ STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << " Modified Index array is : " for ( int i = 0 ; i < n ; i ++ ) cout << index [ i ] << " ▁ " ; return 0 ; }
int numofsubset ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
for ( int i = 0 ; i < n - 1 ; i ++ ) {
if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; } return count ; }
int main ( ) { int arr [ ] = { 100 , 56 , 5 , 6 , 102 , 58 , 101 , 57 , 7 , 103 , 59 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << numofsubset ( arr , n ) << endl ; return 0 ; }
void gnomeSort ( int arr [ ] , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { swap ( arr [ index ] , arr [ index - 1 ] ) ; index -- ; } } return ; }
int main ( ) { int arr [ ] = { 34 , 2 , 10 , -9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; gnomeSort ( arr , n ) ; printArray ( arr , n ) ; return ( 0 ) ; }
#include <iostream> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; void findMaxGuests ( int arrl [ ] , int exit [ ] , int n ) {
sort ( arrl , arrl + n ) ; sort ( exit , exit + n ) ;
int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ;
while ( i < n && j < n ) {
if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ;
if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; }
i ++ ; }
else
{ guests_in -- ; j ++ ; } } cout << " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " << max_guests << " ▁ at ▁ time ▁ " << time ; }
int main ( ) { int arrl [ ] = { 1 , 2 , 10 , 5 , 5 } ; int exit [ ] = { 4 , 5 , 12 , 9 , 12 } ; int n = sizeof ( arrl ) / sizeof ( arrl [ 0 ] ) ; findMaxGuests ( arrl , exit , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxOverlap ( vector < int > & start , vector < int > & end ) { int n = start . size ( ) ;
int maxa = * max_element ( start . begin ( ) , start . end ( ) ) ;
int maxb = * max_element ( end . begin ( ) , end . end ( ) ) ; int maxc = max ( maxa , maxb ) ; int x [ maxc + 2 ] ; memset ( x , 0 , sizeof x ) ; int cur = 0 , idx ;
for ( int i = 0 ; i < n ; i ++ ) {
++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } int maxy = INT_MIN ;
for ( int i = 0 ; i <= maxc ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) { maxy = cur ; idx = i ; } } cout << " Maximum ▁ value ▁ is ▁ " << maxy << " ▁ at ▁ position ▁ " << idx << endl ; }
int main ( ) { vector < int > start = { 13 , 28 , 29 , 14 , 40 , 17 , 3 } , end = { 107 , 95 , 111 , 105 , 70 , 127 , 74 } ; maxOverlap ( start , end ) ; return 0 ; }
void rearrange ( int arr [ ] , int n ) {
int temp [ n ] ;
int small = 0 , large = n - 1 ;
int flag = true ;
for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; }
for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Original ▁ Array STRNEWLINE " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; rearrange ( arr , n ) ; cout << " Modified Array " for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
void rearrange ( int arr [ ] , int n ) {
int max_idx = n - 1 , min_idx = 0 ;
int max_elem = arr [ n - 1 ] + 1 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; }
else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } }
for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Original ▁ Arrayn " ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; rearrange ( arr , n ) ; cout << " Modified Array " for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrange ( int arr [ ] , int n ) { int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { if ( i != j ) swap ( arr [ i ] , arr [ j ] ) ; j ++ ; } } }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; }
int main ( ) { int arr [ ] = { -1 , 2 , -3 , 4 , 5 , 6 , -7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrange ( arr , n ) ; printArray ( arr , n ) ; return 0 ; }
void segregateElements ( int arr [ ] , int n ) {
int temp [ n ] ;
int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ;
if ( j == n j == 0 ) return ;
for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ;
memcpy ( arr , temp , sizeof ( temp ) ) ; }
int main ( ) { int arr [ ] = { 1 , -1 , -3 , -2 , 7 , 5 , 11 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregateElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
void rearrange ( int * arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && arr [ i ] > arr [ i + 1 ] ) swap ( arr [ i ] , arr [ i + 1 ] ) ; if ( i % 2 != 0 && arr [ i ] < arr [ i + 1 ] ) swap ( arr [ i ] , arr [ i + 1 ] ) ; } }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; }
int main ( ) { int arr [ ] = { 6 , 4 , 2 , 1 , 8 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Before ▁ rearranging : ▁ STRNEWLINE " ; printArray ( arr , n ) ; rearrange ( arr , n ) ; cout << " After ▁ rearranging : ▁ STRNEWLINE " ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void rearrange ( int a [ ] , int size ) { int positive = 0 , negative = 1 ; while ( true ) {
while ( positive < size && a [ positive ] >= 0 ) positive += 2 ;
while ( negative < size && a [ negative ] <= 0 ) negative += 2 ;
if ( positive < size && negative < size ) swap ( a [ positive ] , a [ negative ] ) ;
else break ; } }
int main ( ) { int arr [ ] = { 1 , -3 , 5 , 6 , -3 , 6 , 7 , -4 , 9 , 10 } ; int n = ( sizeof ( arr ) / sizeof ( arr [ 0 ] ) ) ; rearrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
void arrayEvenAndOdd ( int arr [ ] , int n ) { int i = -1 , j = 0 ; int t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ;
swap ( arr [ i ] , arr [ j ] ) ; } j ++ ; }
for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 1 , 3 , 2 , 4 , 7 , 6 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( int ) ; arrayEvenAndOdd ( arr , n ) ; return 0 ; }
int largest ( int arr [ ] , int n ) { int i ;
int max = arr [ 0 ] ;
for ( i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; }
int main ( ) { int arr [ ] = { 10 , 324 , 45 , 90 , 9808 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Largest ▁ in ▁ given ▁ array ▁ is ▁ " << largest ( arr , n ) ; return 0 ; }
int largest ( int arr [ ] , int n ) { return * max_element ( arr , arr + n ) ; }
int main ( ) { int arr [ ] = { 10 , 324 , 45 , 90 , 9808 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largest ( arr , n ) ; return 0 ; }
double findMean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; }
double findMedian ( int a [ ] , int n ) {
sort ( a , a + n ) ;
if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
int main ( ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
cout << " Mean ▁ = ▁ " << findMean ( a , n ) << endl ; cout << " Median ▁ = ▁ " << findMedian ( a , n ) << endl ; return 0 ; }
void printSmall ( int arr [ ] , int n , int k ) {
for ( int i = k ; i < n ; ++ i ) {
int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } }
if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; }
arr [ k - 1 ] = arr [ i ] ; } }
for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; printSmall ( arr , n , k ) ; return 0 ; }
void print2largest ( int arr [ ] , int arr_size ) { int i , first , second ;
if ( arr_size < 2 ) { cout << " ▁ Invalid ▁ Input ▁ " ; return ; } first = second = INT_MIN ; for ( i = 0 ; i < arr_size ; i ++ ) {
if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; }
else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } if ( second == INT_MIN ) cout << " There ▁ is ▁ no ▁ second ▁ largest " " element STRNEWLINE " ; else cout << " The ▁ second ▁ largest ▁ element ▁ is ▁ " << second ; }
int main ( ) { int arr [ ] = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; print2largest ( arr , n ) ; return 0 ; }
int sumNodes ( int l ) {
int leafNodeCount = pow ( 2 , l - 1 ) ; int sumLastLevel = 0 ;
sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ;
int sum = sumLastLevel * l ; return sum ; }
int main ( ) { int l = 3 ; cout << sumNodes ( l ) ; return 0 ; }
void add ( int arr [ ] , int N , int lo , int hi , int val ) { arr [ lo ] += val ; if ( hi != N - 1 ) arr [ hi + 1 ] -= val ; }
void updateArray ( int arr [ ] , int N ) {
for ( int i = 1 ; i < N ; i ++ ) arr [ i ] += arr [ i - 1 ] ; }
void printArr ( int arr [ ] , int N ) { updateArray ( arr , N ) ; for ( int i = 0 ; i < N ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; }
int main ( ) { int N = 6 ; int arr [ N ] = { 0 } ;
add ( arr , N , 0 , 2 , 100 ) ; add ( arr , N , 1 , 5 , 100 ) ; add ( arr , N , 2 , 3 , 100 ) ; printArr ( arr , N ) ; return 0 ; }
void FillPrefixSuffix ( int prefix [ ] , int arr [ ] , int suffix [ ] , int n ) {
prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = __gcd ( prefix [ i - 1 ] , arr [ i ] ) ;
suffix [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix [ i ] = __gcd ( suffix [ i + 1 ] , arr [ i ] ) ; }
int GCDoutsideRange ( int l , int r , int prefix [ ] , int suffix [ ] , int n ) {
if ( l == 0 ) return suffix [ r + 1 ] ;
if ( r == n - 1 ) return prefix [ l - 1 ] ; return __gcd ( prefix [ l - 1 ] , suffix [ r + 1 ] ) ; }
int main ( ) { int arr [ ] = { 2 , 6 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int prefix [ n ] , suffix [ n ] ; FillPrefixSuffix ( prefix , arr , suffix , n ) ; int l = 0 , r = 0 ; cout << GCDoutsideRange ( l , r , prefix , suffix , n ) << endl ; l = 1 ; r = 1 ; cout << GCDoutsideRange ( l , r , prefix , suffix , n ) << endl ; l = 1 ; r = 2 ; cout << GCDoutsideRange ( l , r , prefix , suffix , n ) << endl ; return 0 ; }
int countInRange ( int arr [ ] , int n , int x , int y ) {
int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; }
int main ( ) { int arr [ ] = { 1 , 3 , 4 , 9 , 10 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
int i = 1 , j = 4 ; cout << countInRange ( arr , n , i , j ) << endl ; i = 9 , j = 12 ; cout << countInRange ( arr , n , i , j ) << endl ; return 0 ; }
int lowerIndex ( int arr [ ] , int n , int x ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; }
int upperIndex ( int arr [ ] , int n , int y ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; }
int countInRange ( int arr [ ] , int n , int x , int y ) {
int count = 0 ; count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; return count ; }
int main ( ) { int arr [ ] = { 1 , 4 , 4 , 9 , 10 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
sort ( arr , arr + n ) ;
int i = 1 , j = 4 ; cout << countInRange ( arr , n , i , j ) << endl ; i = 9 , j = 12 ; cout << countInRange ( arr , n , i , j ) << endl ; return 0 ; }
void precompute ( int arr [ ] , int n , int pre [ ] ) { memset ( pre , 0 , n * sizeof ( int ) ) ; pre [ n - 1 ] = arr [ n - 1 ] * pow ( 2 , 0 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) pre [ i ] = pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ; }
int decimalOfSubarr ( int arr [ ] , int l , int r , int n , int pre [ ] ) {
if ( r != n - 1 ) return ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ; return pre [ l ] / ( 1 << ( n - 1 - r ) ) ; }
int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int pre [ n ] ; precompute ( arr , n , pre ) ; cout << decimalOfSubarr ( arr , 2 , 4 , n , pre ) << endl ; cout << decimalOfSubarr ( arr , 4 , 5 , n , pre ) << endl ; return 0 ; }
int answerQuery ( int a [ ] , int n , int l , int r ) {
int count = 0 ;
l = l - 1 ;
for ( int i = l ; i < r ; i ++ ) { int element = a [ i ] ; int divisors = 0 ;
for ( int j = l ; j < r ; j ++ ) {
if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; }
if ( divisors == ( r - l ) ) count ++ ; }
return count ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int l = 1 , r = 4 ; cout << answerQuery ( a , n , l , r ) << endl ; l = 2 , r = 4 ; cout << answerQuery ( a , n , l , r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  2147483647 NEW_LINE int one [ 100001 ] [ 32 ] ;
void make_prefix ( int A [ ] , int n ) { for ( int j = 0 ; j < 32 ; j ++ ) one [ 0 ] [ j ] = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) { int a = A [ i - 1 ] ; for ( int j = 0 ; j < 32 ; j ++ ) { int x = pow ( 2 , j ) ;
if ( a & x ) one [ i ] [ j ] = 1 + one [ i - 1 ] [ j ] ; else one [ i ] [ j ] = one [ i - 1 ] [ j ] ; } } }
int Solve ( int L , int R ) { int l = L , r = R ; int tot_bits = r - l + 1 ;
int X = MAX ;
for ( int i = 0 ; i < 31 ; i ++ ) {
int x = one [ r ] [ i ] - one [ l - 1 ] [ i ] ;
if ( x >= tot_bits - x ) { int ith_bit = pow ( 2 , i ) ;
X = X ^ ith_bit ; } } return X ; }
int main ( ) { int n = 5 , q = 3 ; int A [ ] = { 210 , 11 , 48 , 22 , 133 } ; int L [ ] = { 1 , 4 , 2 } , R [ ] = { 3 , 14 , 4 } ; make_prefix ( A , n ) ; for ( int j = 0 ; j < q ; j ++ ) cout << Solve ( L [ j ] , R [ j ] ) << endl ; return 0 ; }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ;
for ( int i = 1 ; i <= a ; i ++ ) {
ans += b / n ;
ans += ( i % n + b % n ) >= n ? 1 : 0 ; }
return ans ; }
int main ( ) { int a = 5 , b = 13 , n = 3 ; cout << findCountOfPairs ( a , b , n ) ; return 0 ; }
for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ;
return 10 ; }
int main ( ) { int k = 15 ; int r = 2 ; cout << minItems ( k , r ) ; return 0 ; }
int answer_query ( int a [ ] , int n , int l , int r ) {
int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; }
int main ( ) { int a [ ] = { 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
int L , R ; L = 1 ; R = 8 ; cout << answer_query ( a , n , L , R ) << endl ;
L = 0 ; R = 4 ; cout << answer_query ( a , n , L , R ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 1000 ;
int prefixans [ N ] ;
int countIndex ( int a [ ] , int n ) {
for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == a [ i + 1 ] ) prefixans [ i ] = 1 ; if ( i != 0 ) prefixans [ i ] += prefixans [ i - 1 ] ; } }
int answer_query ( int l , int r ) { if ( l == 0 ) return prefixans [ r - 1 ] ; else return prefixans [ r - 1 ] - prefixans [ l - 1 ] ; }
int main ( ) { int a [ ] = { 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
countIndex ( a , n ) ; int L , R ;
L = 1 ; R = 8 ; cout << answer_query ( L , R ) << endl ;
L = 0 ; R = 4 ; cout << answer_query ( L , R ) << endl ; return 0 ; }
int primeSubarrays ( int A [ ] , int n ) { int max_val = int ( pow ( 10 , 7 ) ) ;
vector < bool > prime ( max_val + 1 , true ) ;
prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } }
int cnt = 0 ;
for ( int i = 0 ; i < n - 1 ; ++ i ) { int val = A [ i ] ; for ( int j = i + 1 ; j < n ; ++ j ) { val += A [ j ] ; if ( prime [ val ] ) ++ cnt ; } }
return cnt ; }
int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << primeSubarrays ( A , n ) ; return 0 ; }
int repeated_digit ( int n ) { unordered_set < int > s ;
while ( n != 0 ) { int d = n % 10 ;
if ( s . find ( d ) != s . end ( ) ) {
return 0 ; } s . insert ( d ) ; n = n / 10 ; }
return 1 ; }
int calculate ( int L , int R ) { int answer = 0 ;
for ( int i = L ; i < R + 1 ; ++ i ) {
answer = answer + repeated_digit ( i ) ; } return answer ; }
int main ( ) { int L = 1 , R = 100 ;
cout << calculate ( L , R ) ; return 0 ; }
int countMinSwaps ( string st ) { int min_swaps = 0 ;
int odd_0 = 0 , even_0 = 0 ;
int odd_1 = 0 , even_1 = 0 ; int n = st . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( st [ i ] == '1' ) even_1 ++ ; else even_0 ++ ; } else { if ( st [ i ] == '1' ) odd_1 ++ ; else odd_0 ++ ; } }
int cnt_swaps_1 = min ( even_0 , odd_1 ) ;
int cnt_swaps_2 = min ( even_1 , odd_0 ) ;
return min ( cnt_swaps_1 , cnt_swaps_2 ) ; }
int main ( ) { string st = "000111" ; cout << countMinSwaps ( st ) << endl ; return 0 ; }
long long int modpow ( long long int base , long long int exp , long long int modulus ) { base %= modulus ; long long int result = 1 ; while ( exp > 0 ) { if ( exp & 1 ) result = ( result * base ) % modulus ; base = ( base * base ) % modulus ; exp >>= 1 ; } return result ; }
int main ( ) { long long int n = 654654 , mod = 971 ; cout << ( ( ( modpow ( n , 6 , mod ) + modpow ( n , 2 , mod ) ) % mod + 355 ) % mod ) ; return 0 ; }
#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int main ( ) { int a [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int max_sum = maxSubArraySum ( a , n ) ; cout << " Maximum ▁ contiguous ▁ sum ▁ is ▁ " << max_sum ; return 0 ; }
#include <climits> NEW_LINE int maxSubarraySum ( int arr [ ] , int size ) { int max_ending_here = 0 , max_so_far = INT_MIN ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] <= max_ending_here + arr [ i ] ) { max_ending_here += arr [ i ] ; }
else { max_ending_here = arr [ i ] ; } if ( max_ending_here > max_so_far ) max_so_far = max_ending_here ; } return max_so_far ; }
int findMinRooms ( string slots [ ] , int n , int m ) {
int counts [ m ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ;
return * max_element ( counts , counts + m ) ; }
int main ( ) { int n = 3 , m = 7 ; string slots [ n ] = { "0101011" , "0011001" , "0110111" } ; cout << findMinRooms ( slots , n , m ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; }
int main ( ) { int a [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int max_sum = maxSubArraySum ( a , n ) ; cout << " Maximum ▁ contiguous ▁ sum ▁ is ▁ " << max_sum ; return 0 ; }
#include <iostream> NEW_LINE #include <climits> NEW_LINE using namespace std ; int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } cout << " Maximum ▁ contiguous ▁ sum ▁ is ▁ " << max_so_far << endl ; cout << " Starting ▁ index ▁ " << start << endl << " Ending ▁ index ▁ " << end << endl ; }
int main ( ) { int a [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int max_sum = maxSubArraySum ( a , n ) ; return 0 ; }
void countCurrency ( int amount ) { int notes [ 9 ] = { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 } ; int noteCounter [ 9 ] = { 0 } ;
for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = amount / notes [ i ] ; amount = amount - noteCounter [ i ] * notes [ i ] ; } }
cout << " Currency ▁ Count ▁ - > " << endl ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( noteCounter [ i ] != 0 ) { cout << notes [ i ] << " ▁ : ▁ " << noteCounter [ i ] << endl ; } } }
int main ( ) { int amount = 868 ; countCurrency ( amount ) ; return 0 ; }
int minSum ( int A [ ] , int n ) { int min_val = * min_element ( A , A + n ) ; return ( min_val * ( n - 1 ) ) ; }
int main ( ) { int A [ ] = { 3 , 6 , 2 , 8 , 7 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minSum ( A , n ) ; return 0 ; }
void NextFit ( int blockSize [ ] , int m , int processSize [ ] , int n ) {
int allocation [ n ] , j = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) {
allocation [ i ] = j ;
blockSize [ j ] -= processSize [ i ] ; break ; }
j = ( j + 1 ) % m ; } } cout << " Process No . Process Size Block no . " ; for ( int i = 0 ; i < n ; i ++ ) { cout << " ▁ " << i + 1 << " TABSYMBOL TABSYMBOL " << processSize [ i ] << " TABSYMBOL TABSYMBOL " ; if ( allocation [ i ] != -1 ) cout << allocation [ i ] + 1 ; else cout << " Not ▁ Allocated " ; cout << endl ; } }
int main ( ) { int blockSize [ ] = { 5 , 10 , 20 } ; int processSize [ ] = { 10 , 20 , 5 } ; int m = sizeof ( blockSize ) / sizeof ( blockSize [ 0 ] ) ; int n = sizeof ( processSize ) / sizeof ( processSize [ 0 ] ) ; NextFit ( blockSize , m , processSize , n ) ; return 0 ; }
void findMinAvgSubarray ( int arr [ ] , int n , int k ) {
if ( n < k ) return ;
int res_index = 0 ;
int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ;
int min_sum = curr_sum ;
for ( int i = k ; i < n ; i ++ ) {
curr_sum += arr [ i ] - arr [ i - k ] ;
if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } cout << " Subarray ▁ between ▁ [ " << res_index << " , ▁ " << res_index + k - 1 << " ] ▁ has ▁ minimum ▁ average " ; }
int main ( ) { int arr [ ] = { 3 , 7 , 90 , 20 , 10 , 50 , 40 } ;
int k = 3 ; int n = sizeof arr / sizeof arr [ 0 ] ; findMinAvgSubarray ( arr , n , k ) ; return 0 ; }
const int seg [ 10 ] = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ;
int computeSegment ( int x ) { if ( x == 0 ) return seg [ 0 ] ; int count = 0 ;
while ( x ) { count += seg [ x % 10 ] ; x /= 10 ; } return count ; } int elementMinSegment ( int arr [ ] , int n ) {
int minseg = computeSegment ( arr [ 0 ] ) ; int minindex = 0 ;
for ( int i = 1 ; i < n ; i ++ ) { int temp = computeSegment ( arr [ i ] ) ;
if ( temp < minseg ) { minseg = temp ; minindex = i ; } } return arr [ minindex ] ; }
int main ( ) { int arr [ ] = { 489 , 206 , 745 , 123 , 756 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << elementMinSegment ( arr , n ) << endl ; return 0 ; }
void findLargest ( int m , int s ) {
if ( s == 0 ) { ( m == 1 ) ? cout << " Largest ▁ number ▁ is ▁ " << 0 : cout << " Not ▁ possible " ; return ; }
if ( s > 9 * m ) { cout << " Not ▁ possible " ; return ; }
for ( int i = 0 ; i < m ; i ++ ) {
if ( s >= 9 ) { res [ i ] = 9 ; s -= 9 ; }
else { res [ i ] = s ; s = 0 ; } } cout << " Largest ▁ number ▁ is ▁ " ; for ( int i = 0 ; i < m ; i ++ ) cout << res [ i ] ; }
int main ( ) { int s = 9 , m = 2 ; findLargest ( m , s ) ; return 0 ; }
int minJumps ( int arr [ ] , int n ) {
if ( n == 1 ) return 0 ;
int res = INT_MAX ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { int sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != INT_MAX ) res = min ( res , sub_res + 1 ) ; } } return res ; }
int main ( ) { int arr [ ] = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ jumps ▁ to " ; cout << " ▁ reach ▁ the ▁ end ▁ is ▁ " << minJumps ( arr , n ) ; return 0 ; }
int minJumps ( int arr [ ] , int n ) {
int * jumps = new int [ n ] ; int min ;
jumps [ n - 1 ] = 0 ;
for ( int i = n - 2 ; i >= 0 ; i -- ) {
if ( arr [ i ] == 0 ) jumps [ i ] = INT_MAX ;
else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ;
else {
min = INT_MAX ;
for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; }
if ( min != INT_MAX ) jumps [ i ] = min + 1 ; else
jumps [ i ] = min ; } } return jumps [ 0 ] ; }
int main ( ) { int arr [ ] = { 1 , 3 , 6 , 1 , 0 , 9 } ; int size = sizeof ( arr ) / sizeof ( int ) ; cout << " Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach " << " ▁ end ▁ is ▁ " << minJumps ( arr , size ) ; return 0 ; }
int smallestSubWithSum ( int arr [ ] , int n , int x ) {
int curr_sum = 0 , min_len = n + 1 ;
int start = 0 , end = 0 ; while ( end < n ) {
while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ;
while ( curr_sum > x && start < n ) {
if ( end - start < min_len ) min_len = end - start ;
curr_sum -= arr [ start ++ ] ; } } return min_len ; }
int main ( ) { int arr1 [ ] = { 1 , 4 , 45 , 6 , 10 , 19 } ; int x = 51 ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int res1 = smallestSubWithSum ( arr1 , n1 , x ) ; ( res1 == n1 + 1 ) ? cout << " Not ▁ possible STRNEWLINE " : cout << res1 << endl ; int arr2 [ ] = { 1 , 10 , 5 , 2 , 7 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; x = 9 ; int res2 = smallestSubWithSum ( arr2 , n2 , x ) ; ( res2 == n2 + 1 ) ? cout << " Not ▁ possible STRNEWLINE " : cout << res2 << endl ; int arr3 [ ] = { 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; x = 280 ; int res3 = smallestSubWithSum ( arr3 , n3 , x ) ; ( res3 == n3 + 1 ) ? cout << " Not ▁ possible STRNEWLINE " : cout << res3 << endl ; return 0 ; }
int countMinOperations ( unsigned int target [ ] , int n ) {
int result = 0 ;
while ( 1 ) {
int zero_count = 0 ;
int i ; for ( i = 0 ; i < n ; i ++ ) {
if ( target [ i ] & 1 ) break ;
else if ( target [ i ] == 0 ) zero_count ++ ; }
if ( zero_count == n ) return result ;
if ( i == n ) {
for ( int j = 0 ; j < n ; j ++ ) target [ j ] = target [ j ] / 2 ; result ++ ; }
for ( int j = i ; j < n ; j ++ ) { if ( target [ j ] & 1 ) { target [ j ] -- ; result ++ ; } } } }
int main ( ) { unsigned int arr [ ] = { 16 , 16 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ number ▁ of ▁ steps ▁ required ▁ to ▁ " " get ▁ the ▁ given ▁ target ▁ array ▁ is ▁ " << countMinOperations ( arr , n ) ; return 0 ; }
int findMinOps ( int arr [ ] , int n ) {
int ans = 0 ;
for ( int i = 0 , j = n - 1 ; i <= j ; ) {
if ( arr [ i ] == arr [ j ] ) { i ++ ; j -- ; }
else if ( arr [ i ] > arr [ j ] ) {
j -- ; arr [ j ] += arr [ j + 1 ] ; ans ++ ; }
else { i ++ ; arr [ i ] += arr [ i - 1 ] ; ans ++ ; } } return ans ; }
int main ( ) { int arr [ ] = { 1 , 4 , 5 , 9 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ minimum ▁ operations ▁ is ▁ " << findMinOps ( arr , n ) << endl ; return 0 ; }
int findSmallest ( int arr [ ] , int n ) {
int res = 1 ;
for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; }
int main ( ) { int arr1 [ ] = { 1 , 3 , 4 , 5 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << findSmallest ( arr1 , n1 ) << endl ; int arr2 [ ] = { 1 , 2 , 6 , 10 , 11 , 15 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << findSmallest ( arr2 , n2 ) << endl ; int arr3 [ ] = { 1 , 1 , 1 , 1 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << findSmallest ( arr3 , n3 ) << endl ; int arr4 [ ] = { 1 , 1 , 3 , 4 } ; int n4 = sizeof ( arr4 ) / sizeof ( arr4 [ 0 ] ) ; cout << findSmallest ( arr4 , n4 ) << endl ; return 0 ; }
int findMinDiff ( int arr [ ] , int n ) {
int diff = INT_MAX ;
for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) < diff ) diff = abs ( arr [ i ] - arr [ j ] ) ;
return diff ; }
int main ( ) { int arr [ ] = { 1 , 5 , 3 , 19 , 18 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ difference ▁ is ▁ " << findMinDiff ( arr , n ) ; return 0 ; }
int findMinDiff ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int diff = INT_MAX ;
for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ;
return diff ; }
int main ( ) { int arr [ ] = { 1 , 5 , 3 , 19 , 18 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ difference ▁ is ▁ " << findMinDiff ( arr , n ) ; return 0 ; }
int main ( ) { int a = 2 , b = 10 ; int size = abs ( b - a ) + 1 ; int * array = new int [ size ] ;
for ( int i = a ; i <= b ; i ++ ) if ( i % 2 == 0 i % 5 == 0 ) array [ i - a ] = 1 ; cout << " MULTIPLES ▁ of ▁ 2 ▁ and ▁ 5 : STRNEWLINE " ; for ( int i = a ; i <= b ; i ++ ) if ( array [ i - a ] == 1 ) cout << i << " ▁ " ; return 0 ; }
int longestCommonSum ( bool arr1 [ ] , bool arr2 [ ] , int n ) {
int maxLen = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
int sum1 = 0 , sum2 = 0 ;
for ( int j = i ; j < n ; j ++ ) {
sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ;
if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; }
int main ( ) { bool arr1 [ ] = { 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; bool arr2 [ ] = { 1 , 1 , 1 , 1 , 1 , 0 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << " Length ▁ of ▁ the ▁ longest ▁ common ▁ span ▁ with ▁ same ▁ " " sum ▁ is ▁ " << longestCommonSum ( arr1 , arr2 , n ) ; return 0 ; }
#define NA  -1
void moveToEnd ( int mPlusN [ ] , int size ) { int j = size - 1 ; for ( int i = size - 1 ; i >= 0 ; i -- ) if ( mPlusN [ i ] != NA ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } }
int merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ;
int j = 0 ;
int k = 0 ;
while ( k < ( m + n ) ) {
if ( ( j == n ) || ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; }
else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; }
int mPlusN [ ] = { 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = sizeof ( N ) / sizeof ( N [ 0 ] ) ; int m = sizeof ( mPlusN ) / sizeof ( mPlusN [ 0 ] ) - n ;
moveToEnd ( mPlusN , m + n ) ;
merge ( mPlusN , N , m , n ) ;
printArray ( mPlusN , m + n ) ; return 0 ; }
bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) { int i , j ;
for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) j ++ ;
sort ( A + i , A + 1 + j ) ; i = j ; } }
for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; }
int main ( ) { int A [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; bool B [ ] = { 0 , 1 , 1 , 1 , 0 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( sortedAfterSwap ( A , B , n ) ) cout << " A ▁ can ▁ be ▁ sorted STRNEWLINE " ; else cout << " A ▁ can ▁ not ▁ be ▁ sorted STRNEWLINE " ; return 0 ; }
bool sortedAfterSwap ( int A [ ] , bool B [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { if ( A [ i ] != i + 1 ) swap ( A [ i ] , A [ i + 1 ] ) ; } }
for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return false ; } return true ; }
int main ( ) { int A [ ] = { 1 , 2 , 5 , 3 , 4 , 6 } ; bool B [ ] = { 0 , 1 , 1 , 1 , 0 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( sortedAfterSwap ( A , B , n ) ) cout << " A ▁ can ▁ be ▁ sorted STRNEWLINE " ; else cout << " A ▁ can ▁ not ▁ be ▁ sorted STRNEWLINE " ; return 0 ; }
void segregate0and1 ( int arr [ ] , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { swap ( arr [ type0 ] , arr [ type1 ] ) ; type1 -- ; } else { type0 ++ ; } } }
int main ( ) { int arr [ ] = { 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; segregate0and1 ( arr , n ) ; for ( int a : arr ) cout << a << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getInvCount ( int arr [ ] , int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }
int main ( ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " ▁ Number ▁ of ▁ inversions ▁ are ▁ " << getInvCount ( arr , n ) ; return 0 ; }
# include <bits/stdc++.h> NEW_LINE # include <stdlib.h> NEW_LINE # include <math.h> NEW_LINE using namespace std ; void minAbsSumPair ( int arr [ ] , int arr_size ) { int inv_count = 0 ; int l , r , min_sum , sum , min_l , min_r ;
if ( arr_size < 2 ) { cout << " Invalid ▁ Input " ; return ; }
min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( abs ( min_sum ) > abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } cout << " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are ▁ " << arr [ min_l ] << " ▁ and ▁ " << arr [ min_r ] ; }
int main ( ) { int arr [ ] = { 1 , 60 , -10 , 70 , -80 , 85 } ; minAbsSumPair ( arr , 6 ) ; return 0 ; }
bool increasing ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] >= a [ i + 1 ] ) return false ; return true ; }
bool decreasing ( int a [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] < a [ i + 1 ] ) return false ; return true ; } int shortestUnsorted ( int a [ ] , int n ) {
if ( increasing ( a , n ) == true || decreasing ( a , n ) == true ) return 0 ; else return 3 ; }
int main ( ) { int ar [ ] = { 7 , 9 , 10 , 8 , 11 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << shortestUnsorted ( ar , n ) ; return 0 ; }
void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) cout << arr1 [ i ++ ] << " ▁ " ; else if ( arr2 [ j ] < arr1 [ i ] ) cout << arr2 [ j ++ ] << " ▁ " ; else { cout << arr2 [ j ++ ] << " ▁ " ; i ++ ; } }
while ( i < m ) cout << arr1 [ i ++ ] << " ▁ " ; while ( j < n ) cout << arr2 [ j ++ ] << " ▁ " ; }
int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printUnion ( arr1 , arr2 , m , n ) ; return 0 ; }
void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { cout << arr2 [ j ] << " ▁ " ; i ++ ; j ++ ; } } }
int main ( ) { int arr1 [ ] = { 1 , 2 , 4 , 5 , 6 } ; int arr2 [ ] = { 2 , 3 , 5 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ;
printIntersection ( arr1 , arr2 , m , n ) ; return 0 ; }
void printUnion ( int arr1 [ ] , int arr2 [ ] , int m , int n ) {
if ( m > n ) { int * tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; }
sort ( arr1 , arr1 + m ) ; for ( int i = 0 ; i < m ; i ++ ) cout << arr1 [ i ] << " ▁ " ;
for ( int i = 0 ; i < n ; i ++ ) if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == -1 ) cout << arr2 [ i ] << " ▁ " ; }
void printIntersection ( int arr1 [ ] , int arr2 [ ] , int m , int n ) {
if ( m > n ) { int * tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; }
sort ( arr1 , arr1 + m ) ;
for ( int i = 0 ; i < n ; i ++ ) if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != -1 ) cout << arr2 [ i ] << " ▁ " ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ;
if ( arr [ mid ] == x ) return mid ;
if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ;
return binarySearch ( arr , mid + 1 , r , x ) ; }
return -1 ; }
int main ( ) { int arr1 [ ] = { 7 , 1 , 5 , 2 , 3 , 6 } ; int arr2 [ ] = { 3 , 8 , 6 , 20 , 7 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ;
cout << " Union ▁ of ▁ two ▁ arrays ▁ is ▁ n " ; printUnion ( arr1 , arr2 , m , n ) ; cout << " nIntersection ▁ of ▁ two ▁ arrays ▁ is ▁ n " ; printIntersection ( arr1 , arr2 , m , n ) ; return 0 ; }
void intersection ( int a [ ] , int b [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) { j ++ ; } else if ( b [ j ] > a [ i ] ) { i ++ ; } else {
cout << a [ i ] << " ▁ " ; i ++ ; j ++ ; } } }
int main ( ) { int a [ ] = { 1 , 3 , 2 , 3 , 3 , 4 , 5 , 5 , 6 } ; int b [ ] = { 3 , 3 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ;
sort ( a , a + n ) ; sort ( b , b + m ) ;
intersection ( a , b , n , m ) ; }
void sort012 ( int a [ ] , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : swap ( a [ lo ++ ] , a [ mid ++ ] ) ; break ; case 1 : mid ++ ; break ; case 2 : swap ( a [ mid ] , a [ hi -- ] ) ; break ; } } }
void printArray ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; sort012 ( arr , n ) ; cout << " array ▁ after ▁ segregation ▁ " ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUnsorted ( int arr [ ] , int n ) { int s = 0 , e = n - 1 , i , max , min ;
for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { cout << " The ▁ complete ▁ array ▁ is ▁ sorted " ; return ; }
for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; }
max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; }
for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } }
for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } }
cout << " The ▁ unsorted ▁ subarray ▁ which " << " ▁ makes ▁ the ▁ given ▁ array " << endl << " sorted ▁ lies ▁ between ▁ the ▁ indees ▁ " << s << " ▁ and ▁ " << e ; return ; } int main ( ) { int arr [ ] = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printUnsorted ( arr , arr_size ) ; getchar ( ) ; return 0 ; }
int findNumberOfTriangles ( int arr [ ] , int n ) {
qsort ( arr , n , sizeof ( arr [ 0 ] ) , comp ) ;
int count = 0 ;
for ( int i = 0 ; i < n - 2 ; ++ i ) {
int k = i + 2 ;
for ( int j = i + 1 ; j < n ; ++ j ) {
while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ;
if ( k > j ) count += k - j - 1 ; } } return count ; }
int main ( ) { int arr [ ] = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Total ▁ number ▁ of ▁ triangles ▁ possible ▁ is ▁ " << findNumberOfTriangles ( arr , size ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; }
int main ( ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " << countPairsWithDiffK ( arr , n , k ) ; return 0 ; }
int binarySearch ( int arr [ ] , int low , int high , int x ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return -1 ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 , i ;
sort ( arr , arr + n ) ;
for ( i = 0 ; i < n - 1 ; i ++ ) if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != -1 ) count ++ ; return count ; }
int main ( ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " << countPairsWithDiffK ( arr , n , k ) ; return 0 ; }
int countPairsWithDiffK ( int arr [ ] , int n , int k ) { int count = 0 ;
sort ( arr , arr + n ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ;
else r ++ ; } return count ; }
int main ( ) { int arr [ ] = { 1 , 5 , 3 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " << countPairsWithDiffK ( arr , n , k ) ; return 0 ; }
void constructArr ( int arr [ ] , int pair [ ] , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; }
int main ( ) { int pair [ ] = { 15 , 13 , 11 , 10 , 12 , 10 , 9 , 8 , 7 , 5 } ; int n = 5 ; int arr [ n ] ; constructArr ( arr , pair , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
void merge ( int ar1 [ ] , int ar2 [ ] , int m , int n ) {
for ( int i = n - 1 ; i >= 0 ; i -- ) {
int j , last = ar1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && ar1 [ j ] > ar2 [ i ] ; j -- ) ar1 [ j + 1 ] = ar1 [ j ] ;
if ( j != m - 2 last > ar2 [ i ] ) { ar1 [ j + 1 ] = ar2 [ i ] ; ar2 [ i ] = last ; } } }
int main ( ) { int ar1 [ ] = { 1 , 5 , 9 , 10 , 15 , 20 } ; int ar2 [ ] = { 2 , 3 , 8 , 13 } ; int m = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; merge ( ar1 , ar2 , m , n ) ; cout << " After ▁ Merging ▁ nFirst ▁ Array : ▁ " ; for ( int i = 0 ; i < m ; i ++ ) cout << ar1 [ i ] << " ▁ " ; cout << " nSecond ▁ Array : ▁ " ; for ( int i = 0 ; i < n ; i ++ ) cout << ar2 [ i ] << " ▁ " ; return 0 ; }
void gouldSequence ( int n ) {
for ( int row_num = 1 ; row_num <= n ; row_num ++ ) { int count = 1 ; int c = 1 ;
for ( int i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ;
if ( c % 2 == 1 ) count ++ ; }
cout << count << " ▁ " ; } }
int n = 16 ;
gouldSequence ( n ) ; return 0 ; }
int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) {
sort ( arr1 , arr1 + n1 ) ; sort ( arr2 , arr2 + n2 ) ;
return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; }
int main ( ) { int arr1 [ ] = { 10 , 2 , 3 , 6 , 4 , 1 } ; int arr2 [ ] = { 5 , 1 , 4 , 2 , 6 , 9 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n2 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << minMaxProduct ( arr1 , arr2 , n1 , n2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define M  100  NEW_LINE #define N  100  NEW_LINE using namespace std ;
int find_min_odd_cost ( int given [ M ] [ N ] , int m , int n ) { int floor [ M ] [ N ] = { { 0 } , { 0 } } ; int min_odd_cost = 0 ; int i , j , temp ; for ( j = 0 ; j < n ; j ++ ) floor [ 0 ] [ j ] = given [ 0 ] [ j ] ; for ( i = 1 ; i < m ; i ++ ) for ( j = 0 ; j < n ; j ++ ) {
if ( j == 0 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j + 1 ] ) ; }
else if ( j == n - 1 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; }
else {
temp = min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; temp = min ( temp , floor [ i - 1 ] [ j + 1 ] ) ; floor [ i ] [ j ] = given [ i ] [ j ] + temp ; } } min_odd_cost = INT_MAX ;
for ( j = 0 ; j < n ; j ++ ) { if ( floor [ n - 1 ] [ j ] % 2 == 1 ) { if ( min_odd_cost > floor [ n - 1 ] [ j ] ) min_odd_cost = floor [ n - 1 ] [ j ] ; } } if ( min_odd_cost == INT_MIN ) return -1 ; return min_odd_cost ; }
int main ( ) { int m = 5 , n = 5 ; int given [ M ] [ N ] = { { 1 , 2 , 3 , 4 , 6 } , { 1 , 2 , 3 , 4 , 5 } , { 1 , 2 , 3 , 4 , 5 } , { 1 , 2 , 3 , 4 , 5 } , { 100 , 2 , 3 , 4 , 5 } } ; cout << " Minimum ▁ odd ▁ cost ▁ is ▁ " << find_min_odd_cost ( given , m , n ) ; return 0 ; }
int minMaxProduct ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) {
int max = arr1 [ 0 ] ;
int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) {
if ( arr1 [ i ] > max ) max = arr1 [ i ] ;
if ( arr2 [ i ] < min ) min = arr2 [ i ] ; }
while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; }
int main ( ) { int arr1 [ ] = { 10 , 2 , 3 , 6 , 4 , 1 } ; int arr2 [ ] = { 5 , 1 , 4 , 2 , 6 , 9 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n2 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << minMaxProduct ( arr1 , arr2 , n1 , n2 ) << endl ; return 0 ; }
int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return -1 ; }
int main ( ) { int arr [ ] = { 12 , 34 , 10 , 6 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) cout << " Element ▁ not ▁ found " ; else cout << " Element ▁ Found ▁ at ▁ Position : ▁ " << position + 1 ; return 0 ; }
int insertSorted ( int arr [ ] , int n , int key , int capacity ) {
if ( n >= capacity ) return n ; arr [ n ] = key ; return ( n + 1 ) ; }
int main ( ) { int arr [ 20 ] = { 12 , 16 , 20 , 40 , 50 , 70 } ; int capacity = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int n = 6 ; int i , key = 26 ; cout << " Before Insertion : " for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ;
n = insertSorted ( arr , n , key , capacity ) ; cout << " After Insertion : " for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
int findElement ( int arr [ ] , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; }
int deleteElement ( int arr [ ] , int n , int key ) {
int pos = findElement ( arr , n , key ) ; if ( pos == - 1 ) { cout << " Element ▁ not ▁ found " ; return n ; }
int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; }
int main ( ) { int i ; int arr [ ] = { 10 , 50 , 30 , 40 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 30 ; cout << " Array ▁ before ▁ deletion STRNEWLINE " ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; n = deleteElement ( arr , n , key ) ; cout << " Array after deletion " ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
int binarySearch ( int arr [ ] , int low , int high , int key ) { if ( high < low ) return -1 ; int mid = ( low + high ) / 2 ;
if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; }
int main ( ) { int arr [ ] = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; key = 10 ; cout << " Index : ▁ " << binarySearch ( arr , 0 , n - 1 , key ) << endl ; return 0 ; }
int findSDSFunc ( int n ) {
DP [ 0 ] = 0 ; DP [ 1 ] = 1 ;
for ( int i = 2 ; i <= n ; i ++ ) {
if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ;
else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; }
int main ( ) { int n = 15 ; cout << findSDSFunc ( n ) << endl ; return 0 ; }
void findCommon ( int ar1 [ ] , int ar2 [ ] , int ar3 [ ] , int n1 , int n2 , int n3 ) {
int i = 0 , j = 0 , k = 0 ;
while ( i < n1 && j < n2 && k < n3 ) {
if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { cout << ar1 [ i ] << " ▁ " ; i ++ ; j ++ ; k ++ ; }
else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ;
else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ;
else k ++ ; } }
int main ( ) { int ar1 [ ] = { 1 , 5 , 10 , 20 , 40 , 80 } ; int ar2 [ ] = { 6 , 7 , 20 , 80 , 100 } ; int ar3 [ ] = { 3 , 4 , 15 , 20 , 30 , 70 , 80 , 120 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; int n3 = sizeof ( ar3 ) / sizeof ( ar3 [ 0 ] ) ; cout << " Common ▁ Elements ▁ are ▁ " ; findCommon ( ar1 , ar2 , ar3 , n1 , n2 , n3 ) ; return 0 ; }
int Jacobsthal ( int n ) { int dp [ n + 1 ] ;
dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; }
int Jacobsthal_Lucas ( int n ) { int dp [ n + 1 ] ;
dp [ 0 ] = 2 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; }
int main ( ) { int n = 5 ; cout << " Jacobsthal ▁ number : ▁ " << Jacobsthal ( n ) << endl ; cout << " Jacobsthal - Lucas ▁ number : ▁ " << Jacobsthal_Lucas ( n ) << endl ; return 0 ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return -1 ; }
int findPos ( int arr [ ] , int key ) { int l = 0 , h = 1 ; int val = arr [ 0 ] ;
while ( val < key ) {
l = h ;
h = 2 * h ;
val = arr [ h ] ; }
return binarySearch ( arr , l , h , key ) ; }
int main ( ) { int arr [ ] = { 3 , 5 , 7 , 9 , 10 , 90 , 100 , 130 , 140 , 160 , 170 } ; int ans = findPos ( arr , 10 ) ; if ( ans == -1 ) cout << " Element ▁ not ▁ found " ; else cout << " Element ▁ found ▁ at ▁ index ▁ " << ans ; return 0 ; }
long long answer ( int n ) {
if ( n == 1 ) return 10 ;
for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) {
if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ;
else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ;
else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } }
long long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; }
int main ( ) { int n = 2 ; cout << answer ( n ) ; return 0 ; }
int findSingle ( int ar [ ] , int ar_size ) {
int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; }
int main ( ) { int ar [ ] = { 2 , 3 , 5 , 4 , 5 , 3 , 4 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << " Element ▁ occurring ▁ once ▁ is ▁ " << findSingle ( ar , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 1001 ] [ 15001 ] ;
void computeDpArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 1 ; j <= 15000 ; ++ j ) {
if ( i == 0 ) dp [ i ] [ j ] = ( j == arr [ i ] ) ;
else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + ( arr [ i ] == j ) ; } } }
int countTripletSum ( int arr [ ] , int n ) { computeDpArray ( arr , n ) ;
int ans = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { for ( int j = i + 1 ; j < n - 1 ; ++ j ) { for ( int k = 1 ; k <= 24 ; ++ k ) { int cube = k * k * k ; int rem = cube - ( arr [ i ] + arr [ j ] ) ;
if ( rem > 0 ) ans += dp [ n - 1 ] [ rem ] - dp [ j ] [ rem ] ; } } } return ans ; }
int main ( ) { int arr [ ] = { 2 , 5 , 1 , 20 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countTripletSum ( arr , n ) ; return 0 ; }
bool isPresent ( int B [ ] , int m , int x ) { for ( int i = 0 ; i < m ; i ++ ) if ( B [ i ] == x ) return true ; return false ; }
int findMaxSubarraySumUtil ( int A [ ] , int B [ ] , int n , int m ) {
int max_so_far = INT_MIN , curr_max = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( isPresent ( B , m , A [ i ] ) ) { curr_max = 0 ; continue ; }
curr_max = max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; } return max_so_far ; }
void findMaxSubarraySum ( int A [ ] , int B [ ] , int n , int m ) { int maxSubarraySum = findMaxSubarraySumUtil ( A , B , n , m ) ;
if ( maxSubarraySum == INT_MIN ) { cout << " Maximum ▁ Subarray ▁ Sum ▁ cant ▁ be ▁ found " << endl ; } else { cout << " The ▁ Maximum ▁ Subarray ▁ Sum ▁ = ▁ " << maxSubarraySum << endl ; } }
int main ( ) { int A [ ] = { 3 , 4 , 5 , -4 , 6 } ; int B [ ] = { 1 , 8 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int m = sizeof ( B ) / sizeof ( B [ 0 ] ) ;
findMaxSubarraySum ( A , B , n , m ) ; return 0 ; }
int nonDecNums ( int n ) {
for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ;
for ( int i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ;
for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; }
int main ( ) { int n = 2 ; cout << " Non - decreasing ▁ digits ▁ = ▁ " << nonDecNums ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define mod  1000000007 NEW_LINE using namespace std ; long long int countBT ( int h ) { long long int dp [ h + 1 ] ;
dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; i ++ ) { dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % mod + dp [ i - 1 ] ) % mod ) % mod ; } return dp [ h ] ; }
int main ( ) { int h = 3 ; cout << " No . ▁ of ▁ balanced ▁ binary ▁ trees " " ▁ of ▁ height ▁ h ▁ is : ▁ " << countBT ( h ) << endl ; }
int equilibrium ( int arr [ ] , int n ) { int i , j ; int leftsum , rightsum ;
for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ;
for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ;
for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ;
if ( leftsum == rightsum ) return i ; }
return -1 ; }
int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << equilibrium ( arr , arr_size ) ; return 0 ; }
int countEndless ( bool input [ ] [ MAX ] , int n ) { bool row [ n ] [ n ] , col [ n ] [ n ] ;
for ( int j = 0 ; j < n ; j ++ ) {
bool isEndless = 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) {
if ( input [ i ] [ j ] == 0 ) isEndless = 0 ; col [ i ] [ j ] = isEndless ; } }
for ( int i = 0 ; i < n ; i ++ ) { bool isEndless = 1 ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == 0 ) isEndless = 0 ; row [ i ] [ j ] = isEndless ; } }
int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ )
if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; }
int main ( ) { bool input [ ] [ MAX ] = { { 1 , 0 , 1 , 1 } , { 0 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 } , { 0 , 1 , 1 , 0 } } ; int n = 4 ; cout << countEndless ( input , n ) ; return 0 ; }
int equilibrium ( int arr [ ] , int n ) {
int sum = 0 ;
int leftsum = 0 ;
for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) {
sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; }
return -1 ; }
int main ( ) { int arr [ ] = { -7 , 1 , 5 , 2 , -4 , 3 , 0 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " First ▁ equilibrium ▁ index ▁ is ▁ " << equilibrium ( arr , arr_size ) ; return 0 ; }
int toDigit ( char ch ) { return ( ch - '0' ) ; }
int sumOfSubstrings ( string num ) { int n = num . length ( ) ;
int sumofdigit [ n ] ;
sumofdigit [ 0 ] = toDigit ( num [ 0 ] ) ; int res = sumofdigit [ 0 ] ;
for ( int i = 1 ; i < n ; i ++ ) { int numi = toDigit ( num [ i ] ) ;
sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ;
res += sumofdigit [ i ] ; } return res ; }
int main ( ) { string num = "1234" ; cout << sumOfSubstrings ( num ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printLeaders ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; }
if ( j == size ) cout << arr [ i ] << " ▁ " ; } }
int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printLeaders ( arr , n ) ; return 0 ; }
void printLeaders ( int arr [ ] , int size ) { int max_from_right = arr [ size - 1 ] ;
cout << max_from_right << " ▁ " ; for ( int i = size - 2 ; i >= 0 ; i -- ) { if ( max_from_right < arr [ i ] ) { max_from_right = arr [ i ] ; cout << max_from_right << " ▁ " ; } } }
int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printLeaders ( arr , n ) ; return 0 ; }
int unboundedKnapsack ( int W , int n , int val [ ] , int wt [ ] ) {
int dp [ W + 1 ] ; memset ( dp , 0 , sizeof dp ) ;
for ( int i = 0 ; i <= W ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( wt [ j ] <= i ) dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; return dp [ W ] ; }
int main ( ) { int W = 100 ; int val [ ] = { 10 , 30 , 20 } ; int wt [ ] = { 5 , 10 , 15 } ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; cout << unboundedKnapsack ( W , n , val , wt ) ; return 0 ; }
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int i ;
if ( x <= arr [ low ] ) return low ;
for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ;
if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; }
return -1 ; }
int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) cout << " Ceiling ▁ of ▁ " << x << " ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " ; else cout << " ceiling ▁ of ▁ " << x << " ▁ is ▁ " << arr [ index ] ; return 0 ; }
int ceilSearch ( int arr [ ] , int low , int high , int x ) { int mid ;
if ( x <= arr [ low ] ) return low ;
if ( x > arr [ high ] ) return -1 ;
mid = ( low + high ) / 2 ;
if ( arr [ mid ] == x ) return mid ;
else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; }
else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } }
int main ( ) { int arr [ ] = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 20 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == -1 ) cout << " Ceiling ▁ of ▁ " << x << " ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " ; else cout << " ceiling ▁ of ▁ " << x << " ▁ is ▁ " << arr [ index ] ; return 0 ; }
double maxAverageOfPath ( int cost [ M ] [ M ] , int N ) { int dp [ N + 1 ] [ N + 1 ] ; dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;
for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ;
for ( int j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ;
for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ;
return ( double ) dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; }
int main ( ) { int cost [ M ] [ M ] = { { 1 , 2 , 3 } , { 6 , 5 , 4 } , { 7 , 3 , 9 } } ; printf ( " % f " , maxAverageOfPath ( cost , 3 ) ) ; return 0 ; }
int maxCost ( int mat [ ] [ MAX ] , int N ) {
int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ;
for ( int i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ;
for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;
int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ;
return result ; }
int main ( ) { int mat [ MAX ] [ MAX ] = { { 4 , 1 , 5 , 6 , 1 } , { 2 , 9 , 2 , 11 , 10 } , { 15 , 1 , 3 , 15 , 2 } , { 16 , 92 , 41 , 4 , 3 } , { 8 , 142 , 6 , 4 , 8 } } ; int N = 5 ; cout << " Maximum ▁ Path ▁ Sum ▁ : ▁ " << maxCost ( mat , N ) << endl ; return 0 ; }
int maxProfit ( int price [ ] , int n , int k ) {
int profit [ k + 1 ] [ n + 1 ] ;
for ( int i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ;
for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ;
for ( int i = 1 ; i <= k ; i ++ ) { int prevDiff = INT_MIN ; for ( int j = 1 ; j < n ; j ++ ) { prevDiff = max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k ] [ n - 1 ] ; }
int main ( ) { int k = 3 ; int price [ ] = { 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 } ; int n = sizeof ( price ) / sizeof ( price [ 0 ] ) ; cout << " Maximum ▁ profit ▁ is : ▁ " << maxProfit ( price , n , k ) ; return 0 ; }
int countSeq ( int n , int diff ) {
if ( abs ( diff ) > n ) return 0 ;
if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && abs ( diff ) == 1 ) return 1 ;
int res = countSeq ( n - 1 , diff + 1 ) +
2 * countSeq ( n - 1 , diff ) +
countSeq ( n - 1 , diff - 1 ) ; return res ; }
int main ( ) { int n = 2 ; cout << " Count ▁ of ▁ sequences ▁ is ▁ " << countSeq ( 2 , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000
int lookup [ MAX ] [ MAX ] ;
int countSeqUtil ( int n , int dif ) {
if ( abs ( dif ) > n ) return 0 ;
if ( n == 1 && dif == 0 ) return 2 ; if ( n == 1 && abs ( dif ) == 1 ) return 1 ;
if ( lookup [ n ] [ n + dif ] != -1 ) return lookup [ n ] [ n + dif ] ;
countSeqUtil ( n - 1 , dif + 1 ) +
2 * countSeqUtil ( n - 1 , dif ) +
countSeqUtil ( n - 1 , dif - 1 ) ;
return lookup [ n ] [ n + dif ] = res ; }
int countSeq ( int n ) {
return countSeqUtil ( n , 0 ) ; }
int main ( ) { int n = 2 ; cout << " Count ▁ of ▁ sequences ▁ is ▁ " << countSeq ( 2 ) ; return 0 ; }
int min ( int arr [ ] , int l , int h ) { int mn = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mn > arr [ i ] ) mn = arr [ i ] ; return mn ; }
int max ( int arr [ ] , int l , int h ) { int mx = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mx < arr [ i ] ) mx = arr [ i ] ; return mx ; }
int minRemovals ( int arr [ ] , int l , int h ) {
if ( l >= h ) return 0 ;
int mn = min ( arr , l , h ) ; int mx = max ( arr , l , h ) ;
if ( 2 * mn > mx ) return 0 ;
return min ( minRemovals ( arr , l + 1 , h ) , minRemovals ( arr , l , h - 1 ) ) + 1 ; }
int main ( ) { int arr [ ] = { 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minRemovals ( arr , 0 , n - 1 ) ; return 0 ; }
int numberOfPaths ( int m , int n ) {
int count [ m ] [ n ] ;
for ( int i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ;
for ( int j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ;
for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ )
} return count [ m - 1 ] [ n - 1 ] ; }
int main ( ) { cout << numberOfPaths ( 3 , 3 ) ; return 0 ; }
int max ( int a , int b ) { return ( a > b ) ? a : b ; } int max ( int a , int b , int c ) { return max ( a , max ( b , c ) ) ; }
int maxProd ( int n ) {
if ( n == 0 n == 1 ) return 0 ;
int max_val = 0 ; for ( int i = 1 ; i < n ; i ++ ) max_val = max ( max_val , i * ( n - i ) , maxProd ( n - i ) * i ) ;
return max_val ; }
int main ( ) { cout << " Maximum ▁ Product ▁ is ▁ " << maxProd ( 10 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define NUM_LINE  2 NEW_LINE #define NUM_STATION  4
int min ( int a , int b ) { return a < b ? a : b ; } int carAssembly ( int a [ ] [ NUM_STATION ] , int t [ ] [ NUM_STATION ] , int * e , int * x ) { int T1 [ NUM_STATION ] , T2 [ NUM_STATION ] , i ;
T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ;
T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ;
for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; }
return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; }
int main ( ) { int a [ ] [ NUM_STATION ] = { { 4 , 5 , 3 , 2 } , { 2 , 10 , 1 , 4 } } ; int t [ ] [ NUM_STATION ] = { { 0 , 7 , 4 , 5 } , { 0 , 9 , 2 , 8 } } ; int e [ ] = { 10 , 12 } , x [ ] = { 18 , 7 } ; cout << carAssembly ( a , t , e , x ) ; return 0 ; }
int LCSubStr ( char * X , char * Y , int m , int n ) {
int LCSuff [ m + 1 ] [ n + 1 ] ;
int result = 0 ;
for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCSuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 ; result = max ( result , LCSuff [ i ] [ j ] ) ; } else LCSuff [ i ] [ j ] = 0 ; } } return result ; }
int main ( ) { char X [ ] = " OldSite : GeeksforGeeks . org " ; char Y [ ] = " NewSite : GeeksQuiz . com " ; int m = strlen ( X ) ; int n = strlen ( Y ) ; cout << " Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ▁ " << LCSubStr ( X , Y , m , n ) ; return 0 ; }
int maxCrossingSum ( int arr [ ] , int l , int m , int h ) {
int sum = 0 ; int left_sum = INT_MIN ; for ( int i = m ; i >= l ; i -- ) { sum = sum + arr [ i ] ; if ( sum > left_sum ) left_sum = sum ; }
sum = 0 ; int right_sum = INT_MIN ; for ( int i = m + 1 ; i <= h ; i ++ ) { sum = sum + arr [ i ] ; if ( sum > right_sum ) right_sum = sum ; }
return max ( left_sum + right_sum , left_sum , right_sum ) ; }
int maxSubArraySum ( int arr [ ] , int l , int h ) {
if ( l == h ) return arr [ l ] ;
int m = ( l + h ) / 2 ;
return max ( maxSubArraySum ( arr , l , m ) , maxSubArraySum ( arr , m + 1 , h ) , maxCrossingSum ( arr , l , m , h ) ) ; }
int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max_sum = maxSubArraySum ( arr , 0 , n - 1 ) ; printf ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ % d STRNEWLINE " , max_sum ) ; getchar ( ) ; return 0 ; }
float findWater ( int i , int j , float X ) {
if ( j > i ) { printf ( " Incorrect ▁ Inputn " ) ; exit ( 0 ) ; }
float glass [ i * ( i + 1 ) / 2 ] ;
int index = 0 ; glass [ index ] = X ;
for ( int row = 1 ; row <= i ; ++ row ) {
for ( int col = 1 ; col <= row ; ++ col , ++ index ) {
X = glass [ index ] ;
glass [ index ] = ( X >= 1.0f ) ? 1.0f : X ;
X = ( X >= 1.0f ) ? ( X - 1 ) : 0.0f ;
glass [ index + row ] += X / 2 ; glass [ index + row + 1 ] += X / 2 ; } }
return glass [ i * ( i - 1 ) / 2 + j - 1 ] ; }
int main ( ) { int i = 2 , j = 2 ;
float X = 2.0 ; printf ( " Amount ▁ of ▁ water ▁ in ▁ jth ▁ glass ▁ of ▁ ith ▁ row ▁ is : ▁ % f " , findWater ( i , j , X ) ) ; return 0 ; }
int minPalPartion ( string str ) {
int n = str . length ( ) ;
int C [ n ] [ n ] ; bool P [ n ] [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; C [ i ] [ i ] = 0 ; }
for ( int L = 2 ; L <= n ; L ++ ) {
for ( int i = 0 ; i < n - L + 1 ; i ++ ) {
int j = i + L - 1 ;
if ( L == 2 ) P [ i ] [ j ] = ( str [ i ] == str [ j ] ) ; else P [ i ] [ j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 ] [ j - 1 ] ;
if ( P [ i ] [ j ] == true ) C [ i ] [ j ] = 0 ; else {
C [ i ] [ j ] = INT_MAX ; for ( int k = i ; k <= j - 1 ; k ++ ) C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) ; } } }
return C [ 0 ] [ n - 1 ] ; }
int main ( ) { string str = " ababbbabbababa " ; cout << " Min ▁ cuts ▁ needed ▁ for ▁ Palindrome " " ▁ Partitioning ▁ is ▁ " << minPalPartion ( str ) ; return 0 ; }
bool doMatch ( string A , string B ) { for ( int i = 0 ; i < A . length ( ) ; i ++ )
if ( A [ i ] != ' * ' && B [ i ] != ' * ' ) if ( A [ i ] != B [ i ] ) return false ; return true ; }
int main ( ) { string A = " gee * sforgeeks " ; string B = " geeksforgeeks " ; cout << doMatch ( A , B ) ; return 0 ; }
int nthTerm ( int N ) { return ( N + N * ( N - 1 ) ) / 2 ; }
int main ( ) { int N = 5 ; cout << nthTerm ( N ) ; return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; int countSubstrs ( string s1 , string s2 ) { int ans = 0 ; for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) {
string s3 ; for ( int j = i ; j < s1 . length ( ) ; j ++ ) { s3 += s1 [ j ] ;
if ( s2 . find ( s3 ) != string :: npos ) ans ++ ; } } return ans ; }
int main ( ) { string s1 = " aab " , s2 = " aaaab " ; cout << countSubstrs ( s1 , s2 ) ; return 0 ; }
int factorial ( int N ) { int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact = fact * i ;
return fact ; }
int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; }
int main ( ) { int N = 6 ; cout << nthTerm ( N ) ; return 0 ; }
int regexMatch ( string text , string pat ) { int lenText = text . length ( ) ; int letPat = pat . length ( ) ;
int i = 0 , j = 0 ;
while ( i < letPat ) {
if ( pat [ i ] != ' # ' ) {
if ( pat [ i ] != text [ j ] ) return false ;
i ++ ; j ++ ; }
else {
j ++ ;
while ( text [ j ] != pat [ i + 1 ] ) j ++ ;
i ++ ; } } return ( j == lenText ) ; }
int main ( ) { string str = " ABABABA " ; string pat = " A # B # A " ; if ( regexMatch ( str , pat ) ) cout << " yes " ; else cout << " no " ; return 0 ; }
void update ( int arr [ ] , int l , int r , int val ) { arr [ l ] += val ; arr [ r + 1 ] -= val ; }
int getElement ( int arr [ ] , int i ) {
int res = 0 ; for ( int j = 0 ; j <= i ; j ++ ) res += arr [ j ] ; return res ; }
int main ( ) { int arr [ ] = { 0 , 0 , 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int l = 2 , r = 4 , val = 2 ; update ( arr , l , r , val ) ;
int index = 4 ; cout << " Element ▁ at ▁ index ▁ " << index << " ▁ is ▁ " << getElement ( arr , index ) << endl ; l = 0 , r = 3 , val = 4 ; update ( arr , l , r , val ) ;
index = 3 ; cout << " Element ▁ at ▁ index ▁ " << index << " ▁ is ▁ " << getElement ( arr , index ) << endl ; return 0 ; }
int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ; }
int NumberOfWays ( int n , int x , int y ) { return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ; }
int main ( ) { int n = 5 , x = 4 , y = 2 ;
cout << NumberOfWays ( n , x , y ) ; return 0 ; }
int count_pairs ( int a [ ] , int b [ ] , int n , int m ) {
int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; }
for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; }
int pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) ;
return pairs ; }
int main ( ) { int a [ ] = { 9 , 14 , 6 , 2 , 11 } ; int b [ ] = { 8 , 4 , 7 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << count_pairs ( a , b , n , m ) ; return 0 ; }
int getValueOfF ( int n ) {
if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ;
while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; }
return 2 * cnt ; }
int main ( ) { int n = 20 ; cout << getValueOfF ( n ) ; return 0 ; }
int A_mod_B ( string N , int a ) {
int len = N . size ( ) ;
int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) ans = ( ans * 10 + ( int ) N [ i ] - '0' ) % a ; return ans % a ; }
int findMod ( string N ) {
int mod = A_mod_B ( N , 4 ) ; int ans = ( 1 + pow ( 2 , mod ) + pow ( 3 , mod ) + pow ( 4 , mod ) ) ; return ( ans % 5 ) ; }
int main ( ) { string N = "4" ; cout << findMod ( N ) ; return 0 ; }
void printElements ( int arr [ ] , int n ) {
for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) cout << arr [ i ] << " ▁ " ; } }
int main ( ) { int arr [ ] = { 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printElements ( arr , n ) ; return 0 ; }
int exponent ( int A , int B ) {
if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ;
long y ; if ( B % 2 == 0 ) { y = exponent ( A , B / 2 ) ; y = ( y * y ) ; }
else { y = A ; y = ( y * exponent ( A , B - 1 ) ) ; } return y ; }
int sum ( int k , int n ) { int sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; return sum ; }
int main ( ) { int n = 3 ; int K = 3 ; cout << sum ( K , n ) ; }
bool isPrime ( int x ) {
for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return 0 ; } return 1 ; }
int minimumCost ( int n ) {
if ( isPrime ( n ) ) return 1 ;
if ( n % 2 == 1 && isPrime ( n - 2 ) ) return 2 ;
if ( n % 2 == 0 ) return 2 ;
return 3 ; }
int main ( ) { int n = 6 ; cout << minimumCost ( n ) ; return 0 ; }
double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ;
amt_per_min = M - N ;
time_to_fill = V / amt_per_min ;
wasted_amt = N * time_to_fill ; return wasted_amt ; }
int main ( ) { double V , M , N ; V = 700 ; M = 10 ; N = 3 ; cout << wastedWater ( V , M , N ) << endl ; V = 1000 ; M = 100 ; N = 50 ; cout << wastedWater ( V , M , N ) << endl ; return 0 ; }
void nDigitPerfectCubes ( int n ) {
cout << pow ( ceil ( cbrt ( pow ( 10 , ( n - 1 ) ) ) ) , 3 ) << " ▁ " ;
cout << ( int ) pow ( ceil ( cbrt ( pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ; }
int main ( ) { int n = 3 ; nDigitPerfectCubes ( n ) ; return 0 ; }
int countNumbers ( int n ) { return ( n / 2520 ) ; }
int main ( ) { int n = 3000 ; cout << countNumbers ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE const int MAX = 100001 ; ll prefix [ MAX ] ;
void sieve_modified ( ) { for ( int i = 1 ; i < MAX ; i += 2 ) {
for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; }
for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; }
ll sumOddFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; }
int main ( ) { sieve_modified ( ) ; int l = 6 , r = 10 ; cout << sumOddFactors ( l , r ) ; return 0 ; }
#include <iostream> NEW_LINE #define n  3 NEW_LINE using namespace std ;
void preComputeXor ( int arr [ ] [ n ] , int prefix_xor [ ] [ n ] ) {
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) prefix_xor [ i ] [ j ] = arr [ i ] [ j ] ; else prefix_xor [ i ] [ j ] = ( prefix_xor [ i ] [ j - 1 ] ^ arr [ i ] [ j ] ) ; }
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) prefix_xor [ j ] [ i ] = ( prefix_xor [ j - 1 ] [ i ] ^ prefix_xor [ j ] [ i ] ) ; }
int ansQuerie ( int prefix_xor [ ] [ n ] , int x1 , int y1 , int x2 , int y2 ) {
int xor_1 = 0 , xor_2 = 0 , xor_3 = 0 ;
if ( x1 != 0 ) xor_1 = prefix_xor [ x1 - 1 ] [ y2 ] ; if ( y1 != 0 ) xor_2 = prefix_xor [ x2 ] [ y1 - 1 ] ; if ( x1 != 0 and y1 != 0 ) xor_3 = prefix_xor [ x1 - 1 ] [ y1 - 1 ] ;
return ( ( prefix_xor [ x2 ] [ y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) ; }
int main ( ) { int arr [ ] [ n ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ;
int prefix_xor [ n ] [ n ] ;
preComputeXor ( arr , prefix_xor ) ;
cout << ansQuerie ( prefix_xor , 1 , 1 , 2 , 2 ) << endl ; cout << ansQuerie ( prefix_xor , 1 , 2 , 2 , 2 ) << endl ; return 0 ; }
bool isDigitSumOne ( int nm ) {
if ( nm % 9 == 1 ) return true ; else return false ; }
void printValidNums ( int n ) { int cbrt_n = ( int ) cbrt ( n ) ; for ( int i = 1 ; i <= cbrt_n ; i ++ ) { int cube = pow ( i , 3 ) ;
if ( cube >= 1 && cube <= n && isDigitSumOne ( cube ) ) cout << cube << " ▁ " ; } }
int main ( ) { int n = 1000 ; printValidNums ( n ) ; return 0 ; }
long long countRhombi ( int h , int w ) { long long ct = 0 ;
for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 )
ct += ( h - i + 1 ) * ( w - j + 1 ) ;
return ct ; }
int main ( ) { int h = 2 , w = 2 ; cout << countRhombi ( h , w ) ; return 0 ; }
double calculateArea ( int x , int y ) {
double pi = 3.1415926536 ;
double arx = pi * x * x ;
double ary = pi * y * y ;
return arx - ary ; }
int main ( ) { int x = 2 ; int y = 1 ; cout << calculateArea ( x , y ) ; return 0 ; }
char getWinner ( int arr [ ] , int n ) {
int gcd = arr [ 0 ] ;
int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { gcd = __gcd ( gcd , arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } int totalMoves = ( maxEle / gcd ) - n ;
if ( totalMoves % 2 == 1 ) return ' A ' ; return ' B ' ; }
int main ( ) { int arr [ ] = { 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getWinner ( arr , n ) ; return 0 ; }
int countPairs ( int n ) {
int num = ( ( n / 2 ) + 1 ) ;
int max = n % num ;
int count = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) {
int val = ( ( n % i ) % j ) % n ;
if ( val == max ) count ++ ; } }
return count ; }
int main ( ) { int n = 5 ; cout << ( countPairs ( n ) ) ; }
string isDivisible ( long long int n ) { long long int temp = n ;
while ( n ) { int k = n % 10 ;
if ( temp % k == 0 ) return " YES " ; n /= 10 ; } return " NO " ; }
int main ( ) { long long int n = 9876543 ; cout << isDivisible ( n ) ; return 0 ; }
double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; }
int main ( ) { int n = 5 ; cout << " Sum ▁ is ▁ " << sum ( n ) ; return 0 ; }
set < int > ABUNDANT ( ) {
set < int > v ; for ( int i = 1 ; i < N ; i ++ ) {
int sum = 1 ; for ( int j = 2 ; j * j <= i ; j ++ ) {
if ( i % j == 0 ) { sum += j ;
if ( i / j != j ) sum += i / j ; } }
if ( sum > i ) v . insert ( i ) ; } return v ; }
void SumOfAbundant ( int n ) { set < int > v = ABUNDANT ( ) ; for ( int i = 1 ; i <= n ; i ++ ) {
if ( v . count ( i ) and v . count ( n - i ) ) { cout << i << " ▁ " << n - i ; return ; } }
cout << -1 ; }
int main ( ) { int n = 24 ; SumOfAbundant ( n ) ; return 0 ; }
int nthTermOfTheSeries ( int n ) {
if ( n % 2 == 0 ) nthTerm = pow ( n - 1 , 2 ) + n ;
else nthTerm = pow ( n + 1 , 2 ) + n ;
return nthTerm ; }
int main ( ) { int n ; n = 8 ; cout << nthTermOfTheSeries ( n ) << endl ; n = 12 ; cout << nthTermOfTheSeries ( n ) << endl ; n = 102 ; cout << nthTermOfTheSeries ( n ) << endl ; n = 999 ; cout << nthTermOfTheSeries ( n ) << endl ; n = 9999 ; cout << nthTermOfTheSeries ( n ) << endl ; return 0 ; }
float CPwithProfit ( int sellingPrice , int profit ) { float costPrice ;
costPrice = ( sellingPrice * 100.0 ) / ( 100 + profit ) ; return costPrice ; }
float CPwithLoss ( int sellingPrice , int loss ) { float costPrice ;
costPrice = ( sellingPrice * 100.0 ) / ( 100 - loss ) ; return costPrice ; }
int main ( ) { int SP , profit , loss ; SP = 1020 ; profit = 20 ; cout << " Cost ▁ Price ▁ = ▁ " << CPwithProfit ( SP , profit ) << endl ; SP = 900 ; loss = 10 ; cout << " Cost ▁ Price ▁ = ▁ " << CPwithLoss ( SP , loss ) << endl ; SP = 42039 ; profit = 8 ; cout << " Cost ▁ Price ▁ = ▁ " << CPwithProfit ( SP , profit ) << endl ; return 0 ; }
bool isNonHypotenuse ( int n ) {
while ( n % 2 == 0 ) { n = n / 2 ; }
for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) {
if ( n % i == 0 ) { if ( ( i - 1 ) % 4 == 0 ) return false ;
while ( n % i == 0 ) { n = n / i ; } } }
if ( n > 2 && ( n - 1 ) % 4 == 0 ) return false ; else return true ; }
void test ( int n ) { cout << " Testing ▁ for ▁ " << n << " ▁ : ▁ " ; if ( isNonHypotenuse ( n ) ) cout << " YES " << " STRNEWLINE " ; else cout << " NO " << " STRNEWLINE " ; }
int main ( ) { int n = 11 ; test ( n ) ; n = 10 ; test ( n ) ; return 0 ; }
string obtain_str ( ll n ) {
ll len = ( int ) log2 ( n + 1 ) ;
ll rel_ind = n + 1 - pow ( 2 , len ) ; ll i = 0 ; string str = " " ; for ( i = 0 ; i < len ; i ++ ) {
str += ' a ' ; } i = 0 ;
while ( rel_ind > 0 ) { if ( rel_ind % 2 == 1 ) str [ i ] = ' b ' ; rel_ind /= 2 ; i ++ ; }
reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
int main ( ) { ll n = 11 ; cout << obtain_str ( n ) ; return 0 ; }
void Nthterm ( int n ) {
int numerator = pow ( n , 2 ) - 1 ; int denomenator = 2 * n - 3 ; cout << numerator << " / " << denomenator ; }
int main ( ) { int n = 3 ; Nthterm ( n ) ; return 0 ; }
int getSum ( vector < int > arr , int p ) { return arr . size ( ) ; }
int main ( ) { vector < int > arr = { 5 , 6 , 8 } ; int p = 7 ; cout << getSum ( arr , p ) << endl ; return 0 ; }
int SquareCube ( long long int N ) { int cnt = 0 , i = 1 ; while ( int ( pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; }
int main ( ) { long long int N = 100000 ;
cout << SquareCube ( N ) ; return 0 ; }
ll getSum ( int n , int d ) { ll sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; }
int main ( ) { int n = 30 , d = 3 ; cout << getSum ( n , d ) ; return 0 ; }
long sum ( long N ) { long val = N * ( N + 1 ) ; val = val % MOD ; return val ; }
int sumX ( int N , int M , int K ) { for ( int i = 0 ; i < M ; i ++ ) { N = ( int ) sum ( K + N ) ; } N = N % MOD ; return N ; }
int main ( ) { int N = 1 , M = 2 , K = 3 ; cout << sumX ( N , M , K ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int Log2n ( unsigned int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; }
int main ( ) { unsigned int n = 32 ; cout << Log2n ( n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkIsHP ( vector < double > & arr ) { int n = arr . size ( ) ; if ( n == 1 ) { return true ; }
vector < int > rec ; for ( int i = 0 ; i < n ; i ++ ) { rec . push_back ( ( 1 / arr [ i ] ) ) ; }
sort ( rec . begin ( ) , rec . end ( ) ) ; int d = ( rec [ 1 ] ) - ( rec [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( rec [ i ] - rec [ i - 1 ] != d ) { return false ; } } return true ; }
vector < double > arr = { 1 / 5 , 1 / 10 , 1 / 15 , 1 / 20 , 1 / 25 } ;
if ( checkIsHP ( arr ) ) { cout << " Yes " << std :: endl ; } else { cout << " No " << endl ; } return 0 ; }
void printAMeans ( int A , int B , int N ) {
float d = ( float ) ( B - A ) / ( N + 1 ) ;
for ( int i = 1 ; i <= N ; i ++ ) cout << ( A + i * d ) << " ▁ " ; }
int main ( ) { int A = 20 , B = 32 , N = 5 ; printAMeans ( A , B , N ) ; return 0 ; }
void primeFactors ( int n ) {
while ( n % 2 == 0 ) { printf ( " % d ▁ " , 2 ) ; n = n / 2 ; }
for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) {
while ( n % i == 0 ) { printf ( " % d ▁ " , i ) ; n = n / i ; } }
if ( n > 2 ) printf ( " % d ▁ " , n ) ; }
int main ( ) { int n = 315 ; primeFactors ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
int startingPoint ( int Length , int Speed1 , int Speed2 ) { int result1 = 0 , result2 = 0 ;
int time1 = Length / Speed1 ; int time2 = Length / Speed2 ; result1 = __gcd ( time1 , time2 ) ;
result2 = time1 * time2 / ( result1 ) ; return result2 ; }
float firstTime ( int Length , int Speed1 , int Speed2 ) { float result = 0 ; int relativeSpeed = abs ( Speed1 - Speed2 ) ; result = ( ( float ) Length / relativeSpeed ) ; return result ; }
int main ( ) { int L = 30 , S1 = 5 , S2 = 2 ;
float first_Time = firstTime ( L , S1 , S2 ) ; int starting_Point = startingPoint ( L , S1 , S2 ) ; cout << " Met ▁ first ▁ time ▁ after ▁ " << first_Time << " ▁ hrs " << endl ; cout << " Met ▁ at ▁ starting ▁ point ▁ after ▁ " << starting_Point << " ▁ hrs " << endl ; return 0 ; }
bool CheckArray ( int arr [ ] , int n ) { int prod = 1 ;
for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ;
for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ;
return false ; }
int main ( ) { int arr [ ] = { 1 , 2 , 12 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( CheckArray ( arr , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int sum ( int a , int b ) {
int sum = 0 ;
for ( int i = 1 ; i <= min ( a , b ) ; i ++ )
if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; }
int main ( ) { int A = 10 , B = 15 ;
cout << " Sum ▁ = ▁ " << sum ( A , B ) << endl ; return 0 ; }
int minimumCuts ( int a [ ] , int n ) {
sort ( a , a + n ) ;
int gcd = a [ 1 ] - a [ 0 ] ; int s = gcd ; for ( int i = 2 ; i < n ; i ++ ) { gcd = __gcd ( gcd , a [ i ] - a [ i - 1 ] ) ; s += a [ i ] - a [ i - 1 ] ; }
if ( 360 - s > 0 ) gcd = __gcd ( gcd , 360 - s ) ; return ( 360 / gcd ) - n ; }
int main ( ) { int arr [ ] = { 30 , 60 , 180 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumCuts ( arr , n ) ; return 0 ; }
float SellingPrice ( float CP , float PP ) {
float P_decimal = 1 + ( PP / 100 ) ;
float res = P_decimal * CP ;
return res ; }
float C = 720 , P = 13 ;
cout << SellingPrice ( C , P ) ; return 0 ; }
int compositeProduct ( int arr [ ] , int n ) {
int max_val = * max_element ( arr , arr + n ) ;
vector < bool > prime ( max_val + 1 , true ) ;
prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p * p <= max_val ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } }
int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( ! prime [ arr [ i ] ] ) { product *= arr [ i ] ; } return product ; }
int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << compositeProduct ( arr , n ) ; return 0 ; }
int sum_odd ( int n ) { int sum = 0 , pos = 1 ; while ( n ) { if ( pos % 2 == 1 ) sum += n % 10 ; n = n / 10 ; pos ++ ; } return sum ; }
bool check_prime ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
int main ( ) { int n = 223 ;
int sum = sum_odd ( n ) ; if ( check_prime ( sum ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
int reverseNum ( int x ) { string s = to_string ( x ) ; reverse ( s . begin ( ) , s . end ( ) ) ; stringstream ss ( s ) ; int rev = 0 ; ss >> rev ; return rev ; } bool isMysteryNumber ( int n ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) {
int j = reverseNum ( i ) ; if ( i + j == n ) { cout << i << " ▁ " << j ; return true ; } } cout << " Not ▁ a ▁ Mystery ▁ Number " ; return false ; } int main ( ) { int n = 121 ; isMysteryNumber ( n ) ; return 0 ; }
#include " iostream " NEW_LINE using namespace std ; void ReplaceElements ( int arr [ ] , int n ) { int prod = 1 ;
for ( int i = 0 ; i < n ; ++ i ) { prod *= arr [ i ] ; }
for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = prod / arr [ i ] ; } }
int main ( ) { int arr [ ] = { 2 , 3 , 3 , 5 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ReplaceElements ( arr , n ) ;
for ( int i = 0 ; i < n ; ++ i ) { cout << arr [ i ] << " ▁ " ; } return 0 ; }
bool Check_is_possible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) {
if ( i % k == 0 ) count ++ ; }
return ( count > 1 ) ; }
int main ( ) { int l = 4 , r = 12 ; int k = 5 ; if ( Check_is_possible ( l , r , k ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; return 0 ; }
int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; }
int main ( ) { int N = 20 ; cout << sum ( N ) ; return 0 ; }
int fastPow ( int N , int K ) { if ( K == 0 ) return 1 ; int temp = fastPow ( N , K / 2 ) ; if ( K % 2 == 0 ) return temp * temp ; else return N * temp * temp ; } int countWays ( int N , int K ) { return K * fastPow ( K - 1 , N - 1 ) ; }
int main ( ) { int N = 3 , K = 3 ; cout << countWays ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumNth ( int A [ ] , int B [ ] , int m , int n ) { int res = 0 ;
if ( n == 1 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; }
else if ( n == 2 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else {
int f [ n ] ; f [ 0 ] = 0 , f [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( int i = 0 ; i < m ; i ++ ) {
res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; }
int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 4 , 5 , 6 } ; int n = 3 ; int m = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << sumNth ( A , B , m , n ) ; return 0 ; }
ll a = 5 ;
ll AC = a ;
ll CE = 2 * a ;
double shortestDistace = sqrt ( AC * AC + CE * CE ) ; cout << shortestDistace << endl ; return 0 ; }
int sum_of_series ( int n ) { int result = 0 ;
if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; }
else { result = ( n * ( n + 1 ) ) / 2 ; }
return result ; }
int n = 3 ;
cout << sum_of_series ( n ) << endl ;
n = 10 ;
cout << sum_of_series ( n ) << endl ; }
bool isPrime ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
bool isCousinPrime ( int n1 , int n2 ) {
if ( abs ( n1 - n2 ) != 4 ) return false ;
else return ( isPrime ( n1 ) && isPrime ( n2 ) ) ; }
int n1 = 7 , n2 = 11 ;
if ( isCousinPrime ( n1 , n2 ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; }
bool isThabitNumber ( int n ) {
n = n + 1 ;
if ( n % 3 == 0 ) n = n / 3 ; else return false ;
if ( isPowerOfTwo ( n ) ) return true ; else return false ; }
int main ( ) { int n = 47 ;
if ( isThabitNumber ( n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int findMinEqualSums ( int a [ ] , int N ) {
int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; }
int sum1 = 0 , sum2 = 0 ;
int min = INT_MAX ;
for ( int i = 0 ; i < N ; i ++ ) {
sum1 += a [ i ] ; sum2 = sum - sum1 ;
if ( abs ( sum1 - sum2 ) < min ) { min = abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; }
int main ( ) { int a [ ] = { 3 , 2 , 1 , 5 , 7 , 8 } ;
int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << ( findMinEqualSums ( a , N ) ) ; }
int CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ;
for ( int i = 2 ; i <= n ; ++ i ) { sum += ( double ) log ( i ) / ( double ) log ( 10 ) ; }
sum *= ( double ) n ;
}
int main ( ) { int N = 5 ; cout << CountDigits ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define MAX  200006 NEW_LINE #define CONS  32766
void calc ( ll a [ ] , ll b [ ] , ll lr [ ] , ll q , ll n ) { ll M , m , i , j , k , l , r , suma , sumb , cc ; cc = 0 ;
for ( i = 0 ; i < n - 1 ; ++ i ) { a [ i + 1 ] += a [ i ] ; b [ i + 1 ] += b [ i ] ; } while ( q -- ) {
l = lr [ cc ++ ] ; r = lr [ cc ++ ] ; l -= 2 ; r -= 1 ;
suma = a [ r ] ;
sumb = b [ r ] ; if ( l >= 0 ) { suma -= a [ l ] ; sumb -= b [ l ] ; }
M = max ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) ; M = max ( M , max ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) ;
m = min ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) ; m = min ( m , min ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) ; cout << ( M - m ) << " STRNEWLINE " ; } }
int main ( ) { ll n = 5 , q = 2 ; ll a [ 5 ] = { 0 , 7 , 3 , 4 , 5 } ; ll b [ 5 ] = { 0 , 3 , 1 , 2 , 3 } ; ll lr [ q * 2 ] ; lr [ 0 ] = 1 ; lr [ 1 ] = 1 ; lr [ 2 ] = 1 ; lr [ 3 ] = 3 ; calc ( a , b , lr , q , n ) ; return 0 ; }
int NthTerm ( long long n ) { long long x = ( 3 * n * n ) % mod ; return ( x - n + mod ) % mod ; }
long long N = 4 ;
cout << NthTerm ( N ) ; return 0 ; }
int power [ 31 ] ;
int pre [ 31 ] ;
void PowerOfTwo ( ) {
int x = 1 ; for ( int i = 0 ; i < 31 ; i ++ ) { power [ i ] = x ; x *= 2 ; }
pre [ 0 ] = 1 ; for ( int i = 1 ; i < 31 ; i ++ ) pre [ i ] = pre [ i - 1 ] + power [ i ] ; }
int Sum ( int n ) {
int ans = n * ( n + 1 ) / 2 ;
for ( int i = 0 ; i < 31 ; i ++ ) { if ( power [ i ] > n ) { ans -= 2 * pre [ i - 1 ] ; break ; } } return ans ; }
PowerOfTwo ( ) ; int n = 4 ;
cout << Sum ( n ) ; return 0 ; }
bool isPrime ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int main ( ) { int n = 17 ;
if ( isPrime ( n ) && ( n % 16 == 1 ) ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; }
int findNumber ( int n ) {
for ( int i = n - 1 ; > = 0 ; i -- ) {
int count [ 10 ] = { 0 } ;
int x = i ;
int count1 = 0 , count2 = 0 ;
while ( x ) { count [ x % 10 ] ++ ; x /= 10 ; count1 ++ ; }
for ( int j = 0 ; j < 10 ; j ++ ) { if ( count [ j ] == 1 ) count2 ++ ; } if ( count1 == count2 ) return i ; } }
int main ( ) { int n = 8490 ; cout << findNumber ( n ) ; return 0 ; }
bool SieveOfEratosthenes ( int n , bool isPrime [ ] ) {
isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( isPrime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
void findPrimePair ( int n ) { int flag = 0 ;
bool isPrime [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ;
for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] && isPrime [ x ] and x != i and x * i == n ) { cout << i << " ▁ " << x ; flag = 1 ; return ; } } if ( ! flag ) cout << " No ▁ such ▁ pair ▁ found " ; }
int main ( ) { int n = 39 ; findPrimePair ( n ) ; return 0 ; }
void solveProportion ( int a , int b1 , int b2 , int c ) { int A = a * b2 ; int B = b1 * b2 ; int C = b1 * c ;
int gcd = __gcd ( __gcd ( A , B ) , C ) ; cout << A / gcd << " : " << B / gcd << " : " << C / gcd ; }
a = 3 ; b1 = 4 ;
b2 = 8 ; c = 9 ;
solveProportion ( a , b1 , b2 , c ) ; return 0 ; }
int countDivisors ( int n , int k ) {
int count = 0 , i ;
for ( i = 1 ; i <= n ; i ++ ) {
if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; }
int main ( ) { int n = 12 , k = 3 ; cout << countDivisors ( n , k ) ; return 0 ; }
float volume ( float r , float h ) { return ( float ( 1 ) / float ( 3 ) ) * pi * r * r * h ; }
float surface_area ( float r , float s ) { return pi * r * s + pi * r * r ; }
int main ( ) { float radius = 5 ; float slant_height = 13 ; float height = 12 ; float vol , sur_area ;
cout << " Volume ▁ Of ▁ Cone ▁ : ▁ " << volume ( radius , height ) << endl ; cout << " Surface ▁ Area ▁ Of ▁ Cone ▁ : ▁ " << surface_area ( radius , slant_height ) ; return 0 ; }
int nthTerm ( int n ) {
return 6 * pow ( n , 2 ) - 4 * n - 2 ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) ; return 0 ; }
int nthTerm ( int n ) {
return pow ( n , 2 ) + 2 * n + 2 ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) ; return 0 ; }
int sum ( int n ) {
int ans = ( n * ( n - 1 ) ) / 2 ;
return ans ; }
int n = 5 ;
cout << sum ( n ) ; return 0 ; }
int getNthTerm ( long long int N ) {
return 4 * pow ( N , 2 ) - 3 * N + 2 ; }
long long int N = 10 ;
cout << getNthTerm ( N ) ; return 0 ; }
ll power ( ll x , unsigned long long y , ll p ) {
ll res = 1 ;
x = x % p ; while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
ll sumProd ( ll n , ll t ) {
ll dino = power ( t + 1 , MOD - 2 , MOD ) ;
unsigned long long ans = 1 ; for ( ll i = n + t + 1 ; i > n ; -- i ) ans = ( ans % MOD * i % MOD ) % MOD ;
ll tfact = 1 ; for ( int i = 1 ; i <= t ; ++ i ) tfact = ( tfact * i ) % MOD ;
ans = ans * dino - tfact + MOD ; return ans % MOD ; }
int main ( ) { ll n = 3 , t = 2 ;
cout << sumProd ( n , t ) ; return 0 ; }
int findSum ( int n ) {
return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ; }
int main ( ) { int n = 25 ; cout << findSum ( n ) ; return 0 ; }
long long int power ( long long int a , long long int b ) { long long int res = 1 ; while ( b ) { if ( b & 1 ) { res *= a ; res %= mod ; } b /= 2 ; a *= a ; a %= mod ; } return res ; }
long long int minPlayer ( long long int n , long long int k ) {
long long int num = ( ( power ( k , n ) - 1 ) + mod ) % mod ;
long long int den = ( power ( k - 1 , mod - 2 ) + mod ) % mod ;
long long int ans = ( ( ( num * den ) % mod ) * k ) % mod ; return ans ; }
int main ( ) { long long int n = 3 , k = 3 ; cout << minPlayer ( n , k ) ; return 0 ; }
void sieveOfEratosthenes ( int N , int s [ ] ) {
vector < bool > prime ( N + 1 , false ) ;
for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ;
for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) {
s [ i ] = i ;
for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ;
s [ i * j ] = i ; } } } } }
int findSum ( int N ) {
int s [ N + 1 ] ; int ans = 1 ;
sieveOfEratosthenes ( N , s ) ;
int currFactor = s [ N ] ;
int power = 1 ; while ( N > 1 ) { N /= s [ N ] ;
if ( currFactor == s [ N ] ) { power ++ ; continue ; } int sum = 0 ; for ( int i = 0 ; i <= power ; i ++ ) sum += pow ( currFactor , i ) ; ans *= sum ;
currFactor = s [ N ] ; power = 1 ; } return ans ; }
int main ( ) { int n = 12 ; cout << " Sum ▁ of ▁ the ▁ factors ▁ is ▁ : ▁ " ; cout << findSum ( n ) ; return 0 ; }
int countMultiples ( int n ) {
int multiple [ ] = { 2 , 3 , 5 } ; int count = 0 , mask = pow ( 2 , 3 ) ; for ( int i = 1 ; i < mask ; i ++ ) {
int prod = 1 ; for ( int j = 0 ; j < 3 ; j ++ ) {
if ( i & 1 << j ) prod = prod * multiple [ j ] ; }
if ( __builtin_popcount ( i ) % 2 == 1 ) count = count + n / prod ; else count = count - n / prod ; } return count ; }
int main ( ) { int n = 10 ; cout << countMultiples ( n ) << endl ; return 0 ; }
int findN ( int k ) {
int ans ;
if ( k == 0 ) ans = 3 ;
if ( k == 1 ) ans = 1 ;
else if ( k % 4 == 0 ) ans = k ;
else if ( k % 4 == 3 ) ans = k - 1 ;
else ans = -1 ; return ans ; }
int k = 7 ; int res = findN ( k ) ; if ( res == -1 ) cout << " Not ▁ possible " ; else cout << res ; return 0 ; }
int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; }
int main ( ) { int n = 4 ; cout << Circular ( n - 1 ) ; }
float calTime ( float arr [ ] , int n ) { float work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; }
int main ( ) { float arr [ ] = { 6.0 , 3.0 , 4.0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << calTime ( arr , n ) << " ▁ Hours " ; return 0 ; }
void printTwins ( int low , int high ) {
bool prime [ high + 1 ] , twin = false ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ;
for ( int p = 2 ; p <= floor ( sqrt ( high ) ) + 1 ; p ++ ) {
if ( prime [ p ] ) {
for ( int i = p * 2 ; i <= high ; i += p ) prime [ i ] = false ; } }
for ( int i = high ; i >= low ; i -- ) { if ( prime [ i ] && ( i - 2 >= low && prime [ i - 2 ] == true ) ) { cout << " Largest ▁ twins ▁ in ▁ given ▁ range : ▁ ( " << i - 2 << " , ▁ " << i << " ) " ; twin = true ; break ; } } if ( twin == false ) cout << " No ▁ such ▁ pair ▁ exists " << endl ; }
int main ( ) { printTwins ( 10 , 100 ) ; return 0 ; }
int prevComplement ( int n , int b ) { int maxDigit , maxNum = 0 , digits = 0 , num = n ;
while ( n != 0 ) { digits ++ ; n = n / 10 ; }
maxDigit = b - 1 ;
while ( digits -- ) { maxNum = maxNum * 10 + maxDigit ; }
return maxNum - num ; }
int complement ( int n , int b ) {
return prevComplement ( n , b ) + 1 ; }
int main ( ) { cout << prevComplement ( 25 , 7 ) << endl ; cout << complement ( 25 , 7 ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int main ( ) { int a = 2 ; int b = 4 ; cout << gcd ( a , b ) ; return 0 ; }
int MaximumDivisors ( int X , int Y ) {
int arr [ Y - X + 1 ] ;
int mx = INT_MIN ;
int cnt = 0 ; for ( int i = 1 ; i * i <= Y ; i ++ ) { int sq = i * i ; int first_divisible ;
if ( ( X / i ) * i >= X ) first_divisible = ( X / i ) * i ; else first_divisible = ( X / i + 1 ) * i ;
for ( int j = first_divisible ; j <= Y ; j += i ) { if ( j < sq ) continue ; else if ( j == sq ) arr [ j - X ] ++ ; else arr [ j - X ] += 2 ; } }
for ( int i = X ; i <= Y ; i ++ ) { if ( arr [ i - X ] > mx ) { cnt = 1 ; mx = arr [ i - X ] ; } else if ( arr [ i - X ] == mx ) cnt ++ ; } return cnt ; }
int main ( ) { int X = 1 , Y = 10 ; cout << MaximumDivisors ( X , Y ) << endl ; return 0 ; }
int power ( int x , int y , int p ) {
int res = 1 ;
x = x % p ; while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
int NearestElement ( int A , int D , int P ) {
if ( A == 0 ) return 0 ; else if ( D == 0 ) return -1 ; else { int X = power ( D , P - 2 , P ) ; return ( X * ( P - A ) ) % P ; } }
int main ( ) { int A = 4 , D = 9 , P = 11 ;
A %= P ; D %= P ;
cout << NearestElement ( A , D , P ) ; return 0 ; }
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ;
while ( 1 ) { flag = 1 ; x = ( int ) ( pow ( 2 , i ) ) ; p1 = x * p0 + ( x - 1 ) ;
for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; printf ( " % d ▁ " , p1 ) ; i ++ ; } }
int main ( ) { int p0 = 2 ; print ( p0 ) ; return 0 ; }
int findOddPair ( int A [ ] , int N ) { int i , j ;
int oddPair = 0 ;
for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) {
if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } }
return oddPair ; }
int main ( ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
cout << findOddPair ( a , n ) << endl ; return 0 ; }
long long int calculateSum ( int n ) {
long long int sum = 0 ;
sum = 1 << n ; return ( sum - 1 ) ; }
int main ( ) { int n = 10 ; cout << " ▁ Sum ▁ of ▁ all ▁ elements : " << calculateSum ( n ) ; return 0 ; }
void Divide ( int a , int b ) { long long dividend = ( long long ) a ; long long divisor = ( long long ) b ;
long long sign = ( dividend < 0 ) ^ ( divisor < 0 ) ? -1 : 1 ;
dividend = abs ( dividend ) ; divisor = abs ( divisor ) ;
if ( divisor == 0 ) { cout << " Cannot ▁ Divide ▁ by ▁ 0" << endl ; return ; } if ( dividend == 0 ) { cout << a << " ▁ / ▁ " << b << " ▁ is ▁ equal ▁ to ▁ : ▁ " << 0 << endl ; return ; } if ( divisor == 1 ) { cout << a << " ▁ / ▁ " << b << " ▁ is ▁ equal ▁ to ▁ : ▁ " << sign * dividend << endl ; return ; }
cout << a << " ▁ / ▁ " << b << " ▁ is ▁ equal ▁ to ▁ : ▁ " << sign * exp ( log ( dividend ) - log ( divisor ) ) << endl ; }
int main ( ) { int a = 10 , b = 5 ; Divide ( a , b ) ; a = 49 , b = -7 ; Divide ( a , b ) ; return 0 ; }
bool findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) ; if ( n == 1 ) return ( b & 1 ) ;
if ( ! ( a & 1 ) ) {
if ( ! ( b & 1 ) ) return false ;
else return ( n % 3 != 0 ) ; }
else {
if ( ! ( b & 1 ) ) return ( ( n - 1 ) % 3 != 0 ) ;
else return ( ( n + 1 ) % 3 != 0 ) ; } }
int main ( ) { int a = 2 , b = 4 ; int n = 3 ; ( findNature ( a , b , n ) ? ( cout << " Odd " << " ▁ " ) : ( cout << " Even " << " ▁ " ) ) ; return 0 ; }
string checkEqual ( string S ) {
for ( int i = 0 ; i < S . size ( ) ; i ++ ) { if ( S [ i ] != '1' && S [ i ] != '0' && S [ i ] != '8' ) { return " No " ; } } int start = 0 , end = S . size ( ) - 1 ;
while ( start < end ) {
if ( S [ start ] != S [ end ] ) { return " No " ; } start ++ ; end -- ; } return " Yes " ; }
int main ( ) { string S = "101" ; cout << checkEqual ( S ) << endl ; return 0 ; }
#include <stdio.h> NEW_LINE unsigned int Log2n ( unsigned int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; }
bool isPowerOfd ( unsigned int n , unsigned int d ) { int count = 0 ;
if ( n && ! ( n & ( n - 1 ) ) ) {
while ( n > 1 ) { n >>= 1 ; count += 1 ; }
return ( count % ( Log2n ( d ) ) == 0 ) ; }
return false ; }
int main ( ) { int n = 64 , d = 8 ; if ( isPowerOfd ( n , d ) ) printf ( " % d ▁ is ▁ a ▁ power ▁ of ▁ % d " , n , d ) ; else printf ( " % d ▁ is ▁ not ▁ a ▁ power ▁ of ▁ % d " , n , d ) ; return 0 ; }
int octahedral_num ( int n ) {
return n * ( 2 * n * n + 1 ) / 3 ; }
int main ( ) { int n = 5 ;
cout << n << " th ▁ Octahedral ▁ number : ▁ " ; cout << octahedral_num ( n ) ; return 0 ; }
int centeredTetrahedralNumber ( int n ) {
return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; }
int main ( ) { int n = 6 ; cout << centeredTetrahedralNumber ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void swap ( int a , int b , int c , int d ) {
a = a + b ; b = a - b ; a = a - b ;
b = b + c ; c = b - c ; b = b - c ;
c = c + d ; d = c - d ; c = c - d ; cout << " values ▁ after ▁ swapping ▁ are ▁ : ▁ " << endl ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; cout << " c ▁ = ▁ " << c << endl ; cout << " d ▁ = ▁ " << d << endl ; }
int a = 1 ; int b = 2 ; int c = 3 ; int d = 4 ; cout << " Values ▁ before ▁ swapping ▁ are ▁ : " << endl ; cout << " a ▁ = ▁ " << a << endl ; cout << " b ▁ = ▁ " << b << endl ; cout << " c ▁ = ▁ " << c << endl ; cout << " d ▁ = ▁ " << d << endl << endl ;
swap ( a , b , c , d ) ; return 0 ; }
int seriesSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; }
int main ( ) { int n = 4 ; cout << seriesSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE bool checkCentrosymmetricted ( int n , int m [ N ] [ N ] ) { int mid_row ;
if ( n & 1 ) mid_row = n / 2 + 1 ; else mid_row = n / 2 ;
for ( int i = 0 ; i < mid_row ; i ++ ) {
for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; }
int main ( ) { int n = 3 ; int m [ N ] [ N ] = { { 1 , 3 , 5 } , { 6 , 8 , 6 } , { 5 , 3 , 1 } } ; ( checkCentrosymmetricted ( n , m ) ? ( cout << " Yes " ) : ( cout << " No " ) ) ; return 0 ; }
int Centered_Triangular_num ( int n ) {
return ( 3 * n * n + 3 * n + 2 ) / 2 ; }
int n = 3 ; cout << Centered_Triangular_num ( n ) << endl ;
n = 12 ; cout << Centered_Triangular_num ( n ) << endl ; return 0 ; }
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] = { 0 } ; int i , j ;
for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , k ) ; j ++ ) {
if ( j == 0 j == i ) C [ i ] [ j ] = 1 ;
else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int k_Leaves ( int n , int k ) { int ans = ( binomialCoeff ( n , k ) * binomialCoeff ( n , k - 1 ) ) / n ; cout << " Number ▁ of ▁ trees ▁ having ▁ 4 ▁ edges " << " ▁ and ▁ exactly ▁ 2 ▁ leaves ▁ : ▁ " << ans << endl ; return 0 ; }
int numberOfNodes ( int n , int d ) { int ans = binomialCoeff ( 2 * n - 1 - d , n - 1 ) ; cout << " Number ▁ of ▁ nodes ▁ of ▁ degree ▁ 1 ▁ in " << " ▁ a ▁ tree ▁ having ▁ 4 ▁ edges ▁ : ▁ " << ans << endl ; return 0 ; }
int rootDegreeR ( int n , int r ) { int ans = r * binomialCoeff ( 2 * n - 1 - r , n - 1 ) ; ans = ans / n ; cout << " Number ▁ of ▁ trees ▁ having ▁ 4 ▁ edges " << " ▁ where ▁ root ▁ has ▁ degree ▁ 2 ▁ : ▁ " << ans << endl ; return 0 ; }
k_Leaves ( 3 , 2 ) ;
numberOfNodes ( 3 , 1 ) ;
rootDegreeR ( 3 , 2 ) ; return 0 ; }
int repUnitValue ( int n ) {
if ( n % 2 == 0 n % 5 == 0 ) return 0 ;
int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; }
int main ( ) { int n = 13 ; cout << repUnitValue ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
bool isSplittable ( int n , int m ) {
int total_sum = ( n * ( n + 1 ) ) / 2 ;
int sum_s1 = ( total_sum + m ) / 2 ;
int sum_s2 = total_sum - sum_s1 ;
if ( total_sum < m ) return false ;
if ( sum_s1 + sum_s2 == total_sum && sum_s1 - sum_s2 == m )
return ( __gcd ( sum_s1 , sum_s2 ) == 1 ) ;
return false ; }
int main ( ) { int n = 5 , m = 7 ;
if ( isSplittable ( n , m ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossibleToZero ( int a [ ] , int n ) {
int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ;
return ( num % 11 == 0 ) ; }
int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isPossibleToZero ( arr , n ) ) cout << " YES " ; else cout << " NO " ; }
bool isBlumInteger ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ;
for ( int i = 2 ; i * i <= n ; i ++ ) {
if ( prime [ i ] == true ) {
for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } }
for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) {
if ( ( n % i == 0 ) && ( ( i - 3 ) % 4 ) == 0 ) { int q = n / i ; return ( q != i && prime [ q ] && ( q - 3 ) % 4 == 0 ) ; } } } return false ; }
int n = 249 ; if ( isBlumInteger ( n ) ) cout << " Yes " ; else cout << " No " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int fact ( int n ) ; int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int main ( ) { int n = 5 , r = 3 ; cout << nCr ( n , r ) ; return 0 ; }
int summingSeries ( long n ) {
return pow ( n , 2 ) ; }
int main ( ) { int n = 100 ; cout << " The ▁ sum ▁ of ▁ n ▁ term ▁ is : ▁ " << summingSeries ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void find_sum_of_two_squares ( int a , int b ) { int ab = a * b ;
for ( int i = 0 ; i * i <= ab ; i ++ ) { for ( int j = i ; i * i + j * j <= ab ; j ++ ) {
if ( i * i + j * j == ab ) cout << i << " ^ 2 ▁ + ▁ " << j << " ^ 2 ▁ = ▁ " << ab << " STRNEWLINE " ; } } }
int a = 1 * 1 + 2 * 2 ;
int b = 3 * 3 + 4 * 4 ; cout << " Representation ▁ of ▁ a ▁ * ▁ b ▁ as ▁ sum " " ▁ of ▁ 2 ▁ squares : STRNEWLINE " ;
find_sum_of_two_squares ( a , b ) ; }
int tetrahedralNumber ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int main ( ) { int n = 5 ; cout << tetrahedralNumber ( n ) << endl ; return 0 ; }
void check_euler_four_square_identity ( int a , int b , int ab ) { int s = 0 ;
for ( int i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( int j = i ; j * j <= ab ; j ++ ) {
s = j * j + i * i ; for ( int k = j ; k * k <= ab ; k ++ ) {
s = k * k + j * j + i * i ; for ( int l = k ; l * l <= ab ; l ++ ) {
s = l * l + k * k + j * j + i * i ;
if ( s == ab ) {
show ( i ) ; show ( j ) ; show ( k ) ; show ( l ) ; cout << " " << " Product ▁ of ▁ " << a << " ▁ and ▁ " << b ; cout << " ▁ can ▁ be ▁ written " << " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " << " j , ▁ k , ▁ l STRNEWLINE " ; cout << ab << " ▁ = ▁ " ; cout << i << " * " << i << " ▁ + ▁ " ; cout << j << " * " << j << " ▁ + ▁ " ; cout << k << " * " << k << " ▁ + ▁ " ; cout << l << " * " << l << " STRNEWLINE " ; cout << " STRNEWLINE " ; } } } } } }
int ab = a * b ; check_euler_four_square_identity ( a , b , ab ) ; return 0 ; }
int calculateDivisors ( int A , int B ) { int N = ( A - B ) ; int noOfDivisors = 0 ; for ( int i = 1 ; i <= sqrt ( N ) ; i ++ ) {
if ( ( N % i ) == 0 ) {
if ( i > B ) noOfDivisors ++ ;
if ( ( N / i ) != i && ( N / i ) > B ) noOfDivisors ++ ; } } return noOfDivisors ; }
int numberOfPossibleWaysUtil ( int A , int B ) {
if ( A == B ) return -1 ;
if ( A < B ) return 0 ;
int noOfDivisors = 0 ; noOfDivisors = calculateDivisors ( A , B ) ; return noOfDivisors ; }
void numberOfPossibleWays ( int A , int B ) { int noOfSolutions = numberOfPossibleWaysUtil ( A , B ) ;
if ( noOfSolutions == -1 ) { cout << " For ▁ A ▁ = ▁ " << A << " ▁ and ▁ B ▁ = ▁ " << B << " , ▁ X ▁ can ▁ take ▁ Infinitely ▁ many ▁ values " " ▁ greater ▁ than ▁ " << A << " STRNEWLINE " ; } else { cout << " For ▁ A ▁ = ▁ " << A << " ▁ and ▁ B ▁ = ▁ " << B << " , ▁ X ▁ can ▁ take ▁ " << noOfSolutions << " ▁ values STRNEWLINE " ; } }
int main ( ) { int A = 26 , B = 2 ; numberOfPossibleWays ( A , B ) ; A = 21 , B = 5 ; numberOfPossibleWays ( A , B ) ; return 0 ; }
int powerNumbers ( int n ) { vector < int > v ; for ( ll i = 2 ; i * i * i <= n ; i ++ ) { ll j = i * i ; while ( j * i <= n ) { j *= i ;
ll s = sqrt ( j ) ; if ( s * s != j ) v . push_back ( j ) ; } }
sort ( v . begin ( ) , v . end ( ) ) ; v . erase ( unique ( v . begin ( ) , v . end ( ) ) , v . end ( ) ) ;
return v . size ( ) + ( ll ) sqrt ( n ) ; }
int main ( ) { cout << powerNumbers ( 50 ) ; return 0 ; }
int mean ( int a [ ] [ 3 ] , int n ) {
int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ;
return sum / ( n * n ) ; }
int variance ( int a [ ] [ 3 ] , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
a [ i ] [ j ] -= m ;
a [ i ] [ j ] *= a [ i ] [ j ] ; } }
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; }
int mat [ 3 ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ;
int m = mean ( mat , 3 ) ;
int var = variance ( mat , 3 , m ) ;
int dev = sqrt ( var ) ;
cout << " Mean : ▁ " << m << " STRNEWLINE " << " Variance : ▁ " << var << " STRNEWLINE " << " Deviation : ▁ " << dev << " STRNEWLINE " ; return 0 ; }
void printAMeans ( int A , int B , int N ) {
float d = ( float ) ( B - A ) / ( N + 1 ) ;
for ( int i = 1 ; i <= N ; i ++ ) cout << ( A + i * d ) << " ▁ " ; }
int main ( ) { int A = 20 , B = 32 , N = 5 ; printAMeans ( A , B , N ) ; return 0 ; }
int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; }
int main ( ) { cout << sumofseries ( 3 ) << endl ; return 0 ; }
bool isValid ( long long int i , long long int m ) {
long long int sq_i = sqrt ( i ) ;
long long int sq = min ( m , sq_i ) ;
for ( long long int j = 2 ; j <= sq ; j ++ ) if ( i % j == 0 ) return false ; return true ; }
void findLargestNum ( long long int n , long long int m ) {
for ( long long int i = n ; i > m ; i -- ) {
if ( isValid ( i , m ) ) {
cout << i << ' ' ; return ; } }
cout << " Number ▁ Doesn ' t ▁ Exists STRNEWLINE " ; }
int main ( ) { long long int n = 16 , m = 3 ; findLargestNum ( n , m ) ; return 0 ; }
bool isOrthogonal ( int a [ ] [ MAX ] , int m , int n ) { if ( m != n ) return false ;
int trans [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) trans [ i ] [ j ] = a [ j ] [ i ] ;
int prod [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int k = 0 ; k < n ; k ++ ) {
sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) ; } prod [ i ] [ j ] = sum ; } }
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && prod [ i ] [ j ] != 0 ) return false ; if ( i == j && prod [ i ] [ j ] != 1 ) return false ; } } return true ; }
int main ( ) { int a [ ] [ MAX ] = { { 1 , 0 , 0 } , { 0 , 1 , 0 } , { 0 , 0 , 1 } } ; if ( isOrthogonal ( a , 3 , 3 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquare ( long double x ) {
if ( x >= 0 ) { long long sr = sqrt ( x ) ;
return ( sr * sr == x ) ; } return false ; }
int main ( ) { long long x = 2502 ; if ( isPerfectSquare ( x ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * pow ( r , i ) ; cout << curr_term << " ▁ " ; } }
int a = 2 ;
int r = 3 ;
int n = 5 ; printGP ( a , r , n ) ; return 0 ; }
int getMSB ( int n ) {
n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ;
return ( ( n + 1 ) >> 2 ) ; }
void multiply ( int F [ 2 ] [ 2 ] , int M [ 2 ] [ 2 ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; }
void power ( int F [ 2 ] [ 2 ] , int n ) {
if ( n == 0 n == 1 ) return ;
int M [ 2 ] [ 2 ] = { 1 , 1 , 1 , 0 } ;
for ( int m = getMSB ( n ) ; m ; m = m >> 1 ) { multiply ( F , F ) ; if ( n & m ) { multiply ( F , M ) ; } } }
int fib ( int n ) { int F [ 2 ] [ 2 ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n - 1 ) ; return F [ 0 ] [ 0 ] ; }
int n = 6 ; cout << fib ( n ) << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SternSequenceFunc ( vector < int > & BrocotSequence , int n ) {
for ( int i = 1 ; BrocotSequence . size ( ) < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ;
BrocotSequence . push_back ( considered_element + precedent ) ;
BrocotSequence . push_back ( considered_element ) ; }
for ( int i = 0 ; i < 15 ; ++ i ) cout << BrocotSequence [ i ] << " ▁ " ; }
int main ( ) { int n = 15 ; vector < int > BrocotSequence ;
BrocotSequence . push_back ( 1 ) ; BrocotSequence . push_back ( 1 ) ; SternSequenceFunc ( BrocotSequence , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isRevDiffDivisible ( int x , int k ) {
int n = x ; int m = 0 ; int flag ; while ( x > 0 ) {
m = m * 10 + x % 10 ; x /= 10 ; } return ( abs ( n - m ) % k == 0 ) ; } int countNumbers ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( isRevDiffDivisible ( i , k ) ) ++ count ; return count ; }
int main ( ) { int l = 20 , r = 23 , k = 6 ; cout << countNumbers ( l , r , k ) << endl ; return 0 ; }
int divSum ( int n ) {
int result = 0 ;
for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) {
if ( n % i == 0 ) {
if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } }
return ( result + 1 ) ; }
bool areAmicable ( int x , int y ) { if ( divSum ( x ) != y ) return false ; return ( divSum ( y ) == x ) ; }
int main ( ) { int x = 220 , y = 284 ; if ( areAmicable ( x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool isPerfectSquare ( int n ) { if ( n < 0 ) return false ; int root = round ( sqrt ( n ) ) ) ; return n == root * root ; }
void printnonsquare ( int n ) {
int count = 0 ; for ( int i = 1 ; count < n ; ++ i ) {
if ( ! isPerfectSquare ( i ) ) { cout << i << " ▁ " ; count ++ ; } } }
int main ( ) { int n = 10 ; printnonsquare ( n ) ; return 0 ; }
int nonsquare ( int n ) { return n + ( int ) ( 0.5 + sqrt ( n ) ) ; } void printNonSquare ( int n ) {
for ( int i = 1 ; i <= n ; i ++ ) printf ( " % d ▁ " , nonsquare ( i ) ) ; }
int main ( ) { int n = 10 ; printNonSquare ( n ) ; return 0 ; }
Fraction maxFraction ( Fraction first , Fraction sec ) {
int a = first . num ; int b = first . den ; int c = sec . num ; int d = sec . den ;
int Y = a * d - b * c ; return ( Y > 0 ) ? first : sec ; }
int main ( ) { Fraction first = { 3 , 2 } ; Fraction sec = { 3 , 4 } ; Fraction res = maxFraction ( first , sec ) ; cout << res . num << " / " << res . den ; return 0 ; }
bool isPentagonal ( int N ) { int i = 1 , M ; do {
M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; }
int main ( ) { int N = 12 ; if ( isPentagonal ( N ) ) cout << N << " ▁ is ▁ pentagonal ▁ " << endl ; else cout << N << " ▁ is ▁ not ▁ pentagonal " << endl ; return 0 ; }
long long int fourthPowerSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; }
int main ( ) { int n = 6 ; cout << fourthPowerSum ( n ) << endl ; return 0 ; }
long long int fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; }
int main ( ) { int n = 6 ; cout << fourthPowerSum ( n ) << endl ; return 0 ; }
int unitnumber ( int x , int y ) {
x = x % 10 ;
if ( y != 0 ) y = y % 4 + 4 ;
return ( ( ( int ) ( pow ( x , y ) ) ) % 10 ) ; }
int main ( ) { int x = 133 , y = 5 ;
cout << unitnumber ( x , y ) ; return 0 ; }
int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; }
int main ( ) { int n = 12 ; cout << aliquotSum ( n ) ; return 0 ; }
float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int main ( ) { int n = 10 ; cout << AvgofSquareN ( n ) ; return 0 ; }
float func ( float x ) { return ( 1 / ( 1 + x * x ) ) ; }
float calculate ( float lower_limit , float upper_limit , int interval_limit ) { float value ; float interval_size = ( upper_limit - lower_limit ) / interval_limit ; float sum = func ( lower_limit ) + func ( upper_limit ) ;
for ( int i = 1 ; i < interval_limit ; i ++ ) { if ( i % 3 == 0 ) sum = sum + 2 * func ( lower_limit + i * interval_size ) ; else sum = sum + 3 * func ( lower_limit + i * interval_size ) ; } return ( 3 * interval_size / 8 ) * sum ; }
int main ( ) { int interval_limit = 10 ; float lower_limit = 1 ; float upper_limit = 10 ; float integral_res = calculate ( lower_limit , upper_limit , interval_limit ) ; cout << integral_res ; return 0 ; }
float focal_length ( float image_distance , float object_distance ) { return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) ; }
float image_distance = 2 ;
float object_distance = 50 ; cout << " Focal ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ " << focal_length ( image_distance , object_distance ) << " ▁ units ▁ . " ; return 0 ; }
bool check ( int n ) { int m = n ; while ( n ) { int r = n % 10 ; if ( r > 0 ) if ( ( m % r ) != 0 ) return false ; n /= 10 ; } return true ; }
int count ( int l , int r ) { int ans = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( check ( i ) ) ans += 1 ; return ans ; }
int main ( ) { int l = 10 , r = 20 ; cout << count ( l , r ) ; return 0 ; }
double sumOfTheSeries ( int n ) {
double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; }
int main ( ) { int n = 10 ; cout << sumOfTheSeries ( n ) ; return 0 ; }
long long int sum ( long long int n ) { long long int root = sqrt ( n ) ; long long int ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; }
int main ( ) { long long int n = 35 ; cout << sum ( n ) ; return 0 ; }
int sumOfTheSeries ( int n ) {
int sum_n = ( n * ( n + 1 ) / 2 ) ;
int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ;
return ( sum_n + sum_sq_n ) ; }
int main ( ) { int n = 5 ; cout << " Sum ▁ = ▁ " << sumOfTheSeries ( n ) ; return 0 ; }
int sumofsquare ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ;
for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) {
if ( j == 0 j == i ) C [ i ] [ j ] = 1 ;
else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } }
int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; }
int main ( ) { int n = 4 ; cout << sumofsquare ( n ) << endl ; return 0 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; }
int main ( ) { int n = 10 ;
cout << sumOfSeries ( n ) ; return 0 ; }
int evenSum ( int n ) { int C [ n + 1 ] [ n + 1 ] ; int i , j ;
for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= min ( i , n ) ; j ++ ) {
if ( j == 0 j == i ) C [ i ] [ j ] = 1 ;
else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } }
int sum = 0 ; for ( int i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; }
int main ( ) { int n = 4 ; cout << evenSum ( n ) << endl ; return 0 ; }
void checksum ( int n ) {
if ( n % 3 == 0 ) cout << n / 3 - 1 << " ▁ " << n / 3 << " ▁ " << n / 3 + 1 ;
else cout < < " - 1" ; }
int main ( ) { int n = 6 ; checksum ( n ) ; return 0 ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; }
int main ( ) { int n = 4 ; cout << " ▁ " << divisorSum ( n ) << endl ; n = 5 ; cout << " ▁ " << divisorSum ( n ) << endl ; return 0 ; }
double polite ( double n ) { n += 1 ; double base = 2 ; return n + ( log ( ( n + ( log ( n ) / log ( base ) ) ) ) ) / log ( base ) ; }
int main ( ) { double n = 7 ; cout << ( int ) polite ( n ) ; return 0 ; }
int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ;
if ( ( mid * ( mid + 1 ) ) == T ) return mid ;
if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ;
if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ;
else low = mid + 1 ; } return -1 ; }
int main ( ) { int T = 15 ;
int ans = solve ( 1 , T , 2 * T ) ;
if ( ans != -1 ) ans -- ; cout << " Number ▁ of ▁ stair ▁ steps ▁ = ▁ " << ans << endl ; return 0 ; }
bool isOverflow ( long long a , long long b ) {
if ( a == 0 b == 0 ) return false ; long long result = a * b ; if ( a == result / b ) return false ; else return true ; }
int main ( ) { long long a = 10000000000 , b = -10000000000 ; if ( isOverflow ( a , b ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; }
int main ( ) { int n = 20 ; cout << " ▁ Sum ▁ of ▁ first ▁ " << n << " ▁ Odd ▁ Numbers ▁ is : ▁ " << oddSum ( n ) ; return 0 ; }
int oddSum ( int n ) { return ( n * n ) ; }
int main ( ) { int n = 20 ; cout << " ▁ Sum ▁ of ▁ first ▁ " << n << " ▁ Odd ▁ Numbers ▁ is : ▁ " << oddSum ( n ) ; return 0 ; }
void printKPFNums ( int A , int B , int K ) {
bool prime [ B + 1 ] = { true } ; int p_factors [ B + 1 ] = { 0 } ; for ( int p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( int i = p ; i <= B ; i += p ) p_factors [ i ] ++ ;
for ( int i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) cout << i << " ▁ " ; }
int main ( ) { int A = 14 , B = 18 , K = 2 ; printKPFNums ( A , B , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100005 NEW_LINE bool prime [ MAX ] ; int prefix [ MAX ] , suffix [ MAX ] ;
void precompute ( int prefix [ ] , int suffix [ ] ) { memset ( prime , true , sizeof ( prime ) ) ;
for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < MAX ; j += i ) prime [ j ] = false ; } } prefix [ 1 ] = 1 ; suffix [ MAX - 1 ] = 1e9 + 7 ;
for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) prefix [ i ] = i ; else prefix [ i ] = prefix [ i - 1 ] ; }
for ( int i = MAX - 1 ; i > 1 ; i -- ) { if ( prime [ i ] ) suffix [ i ] = i ; else suffix [ i ] = suffix [ i + 1 ] ; } }
int query ( int prefix [ ] , int suffix [ ] , int L , int R ) { if ( prefix [ R ] < L suffix [ L ] > R ) return 0 ; else return prefix [ R ] - suffix [ L ] ; }
int main ( ) { int q = 3 ; int L [ ] = { 2 , 2 , 24 } ; int R [ ] = { 5 , 2 , 28 } ; precompute ( prefix , suffix ) ; for ( int i = 0 ; i < q ; i ++ ) cout << query ( prefix , suffix , L [ i ] , R [ i ] ) << endl ; return 0 ; }
double sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) total = total + ( pow ( x , i ) / i ) ; return total ; } } ;
int main ( ) { gfg g ; int x = 2 ; int n = 5 ; std :: cout << boost :: format ( " % .2f " ) % g . sum ( x , n ) ; return 0 ; }
bool isMember ( int a , int d , int x ) {
if ( d == 0 ) return ( x == a ) ;
return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; }
int main ( ) { int a = 1 , x = 7 , d = 3 ; if ( isMember ( a , d , x ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool sumSquare ( int n ) { for ( long i = 1 ; i * i <= n ; i ++ ) for ( long j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { cout << i << " ^ 2 ▁ + ▁ " << j << " ^ 2" << endl ; return true ; } return false ; }
int main ( ) { int n = 25 ; if ( sumSquare ( n ) ) cout << " Yes " ; else cout << " No " ; }
bool check ( long long a , long long b ) { long long int c = 0 ;
while ( a != 0 ) { c = c + a % 10 ; a = a / 10 ; } return ( c == b ) ; }
long long root ( long long n ) { bool found = 0 ; long long mx = 1e18 ;
for ( long long i = 0 ; i <= 90 ; i ++ ) {
long long s = i * i + 4 * n ; long long sq = sqrt ( s ) ;
if ( sq * sq == s && check ( ( sq - i ) / 2 , i ) ) { found = 1 ; mx = min ( mx , ( sq - i ) / 2 ) ; } }
if ( found ) return mx ; else return -1 ; }
int main ( ) { long long n = 110 ; cout << root ( n ) ; }
int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; }
int main ( ) { int n = 5 ; int power = 4 ; cout << calculate ( n , power ) ; }
bool coprime ( int a , int b ) { return ( __gcd ( a , b ) == 1 ) ; }
void pairSum ( int n ) { int mid = n / 2 ; for ( int i = mid ; i >= 1 ; i -- ) { if ( coprime ( i , n - i ) == 1 ) { cout << i << " ▁ " << n - i ; break ; } } }
int main ( ) { int n = 11 ; pairSum ( n ) ; return 0 ; }
void modBigNumber ( string num , ll m ) {
vector < int > vec ; ll mod = 0 ;
for ( int i = 0 ; i < num . size ( ) ; i ++ ) { int digit = num [ i ] - '0' ;
mod = mod * 10 + digit ;
int quo = mod / m ; vec . push_back ( quo ) ;
mod = mod % m ; } cout << " Remainder : " ▁ < < ▁ mod ▁ < < ▁ " " cout << " Quotient ▁ : ▁ " ;
bool zeroflag = 0 ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { if ( vec [ i ] == 0 && zeroflag == 0 ) continue ; zeroflag = 1 ; cout << vec [ i ] ; } return ; }
int main ( ) { string num = "14598499948265358486" ; ll m = 487 ; modBigNumber ( num , m ) ; return 0 ; }
const int N = 1e6 ; bool fourDiv [ N + 1 ] ; memset ( fourDiv , false , sizeof ( fourDiv ) ) ;
void fourDistinctFactors ( ) {
bool primeAll [ N + 1 ] ; memset ( primeAll , true , sizeof ( primeAll ) ) ; for ( int p = 2 ; p * p <= N ; p ++ ) {
if ( primeAll [ p ] == true ) {
for ( int i = p * 2 ; i <= N ; i += p ) primeAll [ i ] = false ; } }
vector < int > prime ; for ( int p = 2 ; p <= N ; p ++ ) if ( primeAll [ p ] ) prime . push_back ( p ) ;
for ( int i = 0 ; i < prime . size ( ) ; ++ i ) { int p = prime [ i ] ;
if ( 1LL * p * p * p <= N ) fourDiv [ p * p * p ] = true ; for ( int j = i + 1 ; j < prime . size ( ) ; ++ j ) { int q = prime [ j ] ; if ( 1LL * p * q > N ) break ;
fourDiv [ p * q ] = true ; } } }
int main ( ) { fourDistinctFactors ( ) ; int num = 10 ; if ( fourDiv [ num ] ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; num = 12 ; if ( fourDiv [ num ] ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int leonardo ( int n ) { int dp [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ; return dp [ n ] ; }
int main ( ) { cout << leonardo ( 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void Cholesky_Decomposition ( int matrix [ ] [ MAX ] , int n ) { int lower [ n ] [ n ] ; memset ( lower , 0 , sizeof ( lower ) ) ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { int sum = 0 ;
{ for ( int k = 0 ; k < j ; k ++ ) sum += pow ( lower [ j ] [ k ] , 2 ) ; lower [ j ] [ j ] = sqrt ( matrix [ j ] [ j ] - sum ) ; } else {
for ( int k = 0 ; k < j ; k ++ ) sum += ( lower [ i ] [ k ] * lower [ j ] [ k ] ) ; lower [ i ] [ j ] = ( matrix [ i ] [ j ] - sum ) / lower [ j ] [ j ] ; } } }
cout << setw ( 6 ) << " ▁ Lower ▁ Triangular " << setw ( 30 ) << " Transpose " << endl ; for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = 0 ; j < n ; j ++ ) cout << setw ( 6 ) << lower [ i ] [ j ] << " TABSYMBOL " ; cout << " TABSYMBOL " ;
for ( int j = 0 ; j < n ; j ++ ) cout << setw ( 6 ) << lower [ j ] [ i ] << " TABSYMBOL " ; cout << endl ; } }
int main ( ) { int n = 3 ; int matrix [ ] [ MAX ] = { { 4 , 12 , -16 } , { 12 , 37 , -43 } , { -16 , -43 , 98 } } ; Cholesky_Decomposition ( matrix , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; }
int main ( ) { float n = 20 ; float a = 2.5 , d = 1.5 ; cout << sumOfAP ( a , d , n ) ; return 0 ; }
int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; }
int main ( ) { int n = 5 ; cout << sumOfSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  10
int findValue ( int arr [ ] , int n ) { int ans = 0 ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ )
ans = max ( ans , abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ) ; return ans ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findValue ( arr , n ) << endl ; return 0 ; }
int findValue ( int arr [ ] , int n ) { int a [ n ] , b [ n ] , tmp ;
for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( arr [ i ] + i ) ; b [ i ] = ( arr [ i ] - i ) ; } int x = a [ 0 ] , y = a [ 0 ] ;
for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) x = a [ i ] ; if ( a [ i ] < y ) y = a [ i ] ; }
int ans1 = ( x - y ) ; x = b [ 0 ] ; y = b [ 0 ] ;
for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] > x ) x = b [ i ] ; if ( b [ i ] < y ) y = b [ i ] ; }
int ans2 = ( x - y ) ; return max ( ans1 , ans2 ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findValue ( arr , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countsubarray ( int array [ ] , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) {
if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) {
mul = mul * array [ j ] ;
if ( mul < k ) count ++ ; else break ; } } return count ; }
int main ( ) { int array [ ] = { 1 , 2 , 3 , 4 } ; int k = 10 ; int size = sizeof ( array ) / sizeof ( array [ 0 ] ) ; int count = countsubarray ( array , size , k ) ; cout << count << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000001 ; int factor [ MAX ] = { 0 } ;
void generatePrimeFactors ( ) { factor [ 1 ] = 1 ;
for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ;
for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ;
for ( int i = 3 ; i * i < MAX ; i ++ ) {
if ( factor [ i ] == i ) {
for ( int j = i * i ; j < MAX ; j += i ) {
if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ;
int dup = factor [ n ] ;
int c = 1 ;
int j = n / factor [ n ] ;
while ( j != 1 ) {
if ( factor [ j ] == dup ) c += 1 ;
else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; }
j = j / factor [ j ] ; }
ans = ans * ( c + 1 ) ; return ans ; }
generatePrimeFactors ( ) ; int a [ ] = { 10 , 30 , 100 , 450 , 987 } ; int q = sizeof ( a ) / sizeof ( a [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) cout << calculateNoOFactors ( a [ i ] ) << " ▁ " ; return 0 ; }
void digit_product_Sum ( int N ) {
int a [ N ] ;
int product = 1 ;
a [ 0 ] = 1 ;
for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; }
for ( int i = 0 ; i < N ; i ++ ) cout << a [ i ] << " ▁ " ; }
int N = 10 ;
digit_product_Sum ( N ) ; return 0 ; }
float geometricMean ( int arr [ ] , int n ) {
float product = 1 ;
for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ;
float gm = pow ( product , ( float ) 1 / n ) ; return gm ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << geometricMean ( arr , n ) ; return 0 ; }
bool productOfSingelDgt ( int n ) {
if ( n >= 0 && n <= 9 ) return true ;
int prime [ ] = { 2 , 3 , 5 , 7 } ;
for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ;
return ( n == 1 ) ; }
int main ( ) { int n = 24 ; productOfSingelDgt ( n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ;
else return ( ( n + 1 ) / 2 ) * n ; }
int main ( ) { int n = 5 ; cout << findSum ( n ) ; return 0 ; }
int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ;
bool arr [ N + 1 ] ; memset ( arr , true , sizeof ( arr ) ) ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) {
if ( arr [ p ] == true ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = false ;
prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; }
int main ( ) { int N = 500 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }
int n = 8 ;
int range = 12 ; for ( int i = 1 ; i <= range ; ++ i ) cout << n << " ▁ * ▁ " << i << " ▁ = ▁ " << n * i << endl ; return 0 ; }
bool isPalindrome ( int n ) {
int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ;
if ( leading != trailing ) return false ;
n = ( n % divisor ) / 10 ;
divisor = divisor / 100 ; } return true ; }
int main ( ) { isPalindrome ( 1001 ) ? cout << " Yes , ▁ it ▁ is ▁ Palindrome " : cout << " No , ▁ not ▁ Palindrome " ; return 0 ; }
bool check ( int n ) { if ( n <= 0 ) return false ;
return 1162261467 % n == 0 ; }
int main ( ) { int n = 9 ; if ( check ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
string printDemlo ( string str ) { int len = str . length ( ) ; string res = " " ;
for ( int i = 1 ; i <= len ; i ++ ) res += char ( i + '0' ) ; for ( int i = len - 1 ; i >= 1 ; i -- ) res += char ( i + '0' ) ; return res ; }
int main ( ) { string str = "111111" ; cout << printDemlo ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int NumberofTimes ( string str ) {
int temporary_sum = 0 , count = 0 ;
while ( str . length ( ) > 1 ) { temporary_sum = 0 ;
for ( int i = 0 ; i < str . length ( ) ; i ++ ) temporary_sum += ( str [ i ] - '0' ) ;
str = to_string ( temporary_sum ) ;
count ++ ; } return count ; }
int main ( ) { string s = "991" ; cout << NumberofTimes ( s ) ; return 0 ; }
int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } }
int main ( ) { int calculateLeaps ( int ) ; std :: cout << calculateLeaps ( 4 ) << std :: endl ; return 0 ; }
int power ( long long int x , long long int y , long long int p ) {
long long int res = 1 ;
while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
int numberOfDigits ( int x ) { int i = 0 ; while ( x ) { x /= 10 ; i ++ ; } return i ; }
void printLastKDigits ( int a , int b , int k ) { cout << " Last ▁ " << k ; cout << " ▁ digits ▁ of ▁ " << a ; cout << " ^ " << b << " ▁ = ▁ " ;
int temp = 1 ; for ( int i = 1 ; i <= k ; i ++ ) temp *= 10 ;
temp = power ( a , b , temp ) ;
for ( int i = 0 ; i < k - numberOfDigits ( temp ) ; i ++ ) cout << 0 ;
if ( temp ) cout << temp ; }
int main ( ) { int a = 11 ; int b = 3 ; int k = 2 ; printLastKDigits ( a , b , k ) ; return 0 ; }
int reverseDigits ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num /= 10 ; } return rev ; }
int square ( int num ) { return ( num * num ) ; }
bool checkAdamNumber ( int num ) {
int a = square ( num ) ; int b = square ( reverseDigits ( num ) ) ;
if ( a == reverseDigits ( b ) ) return true ; return false ; }
int main ( ) { int num = 12 ; if ( checkAdamNumber ( num ) ) cout << " Adam ▁ Number " ; else cout << " Not ▁ a ▁ Adam ▁ Number " ; return 0 ; }
#define P2 ( n )  n, n ^ 1, n ^ 1, n NEW_LINE #define P4 ( n )  P2(n), P2(n ^ 1), P2(n ^ 1), P2(n) NEW_LINE #define P6 ( n )  P4(n), P4(n ^ 1), P4(n ^ 1), P4(n) NEW_LINE #define LOOK_UP  P6(0), P6(1), P6(1), P6(0)
unsigned int table [ 256 ] = { LOOK_UP } ;
int Parity ( int num ) {
int max = 16 ;
while ( max >= 8 ) { num = num ^ ( num >> max ) ; max = max / 2 ; }
return table [ num & 0xff ] ; }
int main ( ) { unsigned int num = 1742346774 ;
bool result = Parity ( num ) ;
result ? std :: cout << " Odd ▁ Parity " : std :: cout << " Even ▁ Parity " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalDigits ( int n ) {
int number_of_digits = 0 ;
for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; }
int main ( ) { int n = 13 ; cout << totalDigits ( n ) << endl ; return 0 ; }
void numbersWith3Divisors ( int n ) { bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } }
cout << " Numbers ▁ with ▁ 3 ▁ divisors ▁ : STRNEWLINE " ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) cout << i * i << " ▁ " ; }
int main ( ) { int n = 96 ; numbersWith3Divisors ( n ) ; return 0 ; }
void decToHexa ( int n ) {
char hexaDeciNum [ 100 ] ;
int i = 0 ; while ( n != 0 ) {
int temp = 0 ;
temp = n % 16 ;
if ( temp < 10 ) { hexaDeciNum [ i ] = temp + 48 ; i ++ ; } else { hexaDeciNum [ i ] = temp + 55 ; i ++ ; } n = n / 16 ; }
for ( int j = i - 1 ; j >= 0 ; j -- ) cout << hexaDeciNum [ j ] ; }
int main ( ) { int n = 2545 ; decToHexa ( n ) ; return 0 ; }
void decToBinary ( int n ) {
int binaryNum [ 32 ] ;
int i = 0 ; while ( n > 0 ) {
binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; }
for ( int j = i - 1 ; j >= 0 ; j -- ) cout << binaryNum [ j ] ; }
int main ( ) { int n = 17 ; decToBinary ( n ) ; return 0 ; }
ll count_of_ways ( ll n ) { ll count ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; }
int main ( ) { ll n = 3 ; cout << count_of_ways ( n ) << endl ; return 0 ; }
int flipSign ( int a ) { int neg = 0 ;
int tmp = a < 0 ? 1 : -1 ; while ( a != 0 ) { neg += tmp ; a += tmp ; } return neg ; }
bool areDifferentSign ( int a , int b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; }
int sub ( int a , int b ) {
return a + flipSign ( b ) ; }
int mul ( int a , int b ) {
if ( a < b ) return mul ( b , a ) ;
int sum = 0 ; for ( int i = abs ( b ) ; i > 0 ; i -- ) sum += a ;
if ( b < 0 ) sum = flipSign ( sum ) ; return sum ; }
int division ( int a , int b ) {
int divisor = flipSign ( abs ( b ) ) ;
for ( dividend = abs ( a ) ; dividend >= abs ( divisor ) ; dividend += divisor ) quotient ++ ;
if ( areDifferentSign ( a , b ) ) quotient = flipSign ( quotient ) ; return quotient ; }
int main ( ) { cout << " Subtraction ▁ is ▁ " << sub ( 4 , -2 ) << endl ; cout << " Product ▁ is ▁ " << mul ( -9 , 6 ) << endl ; try { cout << " Division ▁ is ▁ " << division ( 8 , 2 ) ; } catch ( int k ) { cout << " ▁ Exception ▁ : - ▁ Divide ▁ by ▁ 0" ; } return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int numOfCombinations ( int arr [ ] , int N ) {
int C [ 3 ] = { 0 , 0 , 0 } ;
for ( int i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ;
return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; }
int main ( ) { int arr1 [ 6 ] = { 1 , 5 , 7 , 2 , 9 , 14 } ; cout << numOfCombinations ( arr1 , 6 ) << " STRNEWLINE " ; int arr2 [ 4 ] = { 3 , 6 , 9 , 12 } ; cout << numOfCombinations ( arr2 , 4 ) << " STRNEWLINE " ; return 0 ; }
bool isprime ( int x ) {
for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
bool isSumOfKprimes ( int N , int K ) {
if ( N < 2 * K ) return false ;
if ( K == 1 ) return isprime ( N ) ; if ( K == 2 ) {
if ( N % 2 == 0 ) return true ;
return isprime ( N - 2 ) ; }
return true ; }
int main ( ) { int n = 10 , k = 2 ; if ( isSumOfKprimes ( n , k ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
int FindLCM ( int a , int b ) { return ( a * b ) / __gcd ( a , b ) ; }
int rangeDivisor ( int m , int n , int a , int b ) {
int lcm = FindLCM ( a , b ) ; int a_divisor = n / a - ( m - 1 ) / a ; int b_divisor = n / b - ( m - 1 ) / b ;
int common_divisor = n / lcm - ( m - 1 ) / lcm ; int ans = a_divisor + b_divisor - common_divisor ; return ans ; }
int main ( ) { int m = 3 , n = 11 , a = 2 , b = 3 ; cout << rangeDivisor ( m , n , a , b ) << endl ; m = 11 , n = 1000000 , a = 6 , b = 35 ; cout << rangeDivisor ( m , n , a , b ) ; return 0 ; }
void printUnique ( int l , int r ) {
for ( int i = l ; i <= r ; i ++ ) { int num = i ; bool visited [ 10 ] = { false } ;
while ( num ) {
if ( visited [ num % 10 ] ) break ; visited [ num % 10 ] = true ; num = num / 10 ; }
if ( num == 0 ) cout << i << " ▁ " ; } }
int main ( ) { int l = 1 , r = 20 ; printUnique ( l , r ) ; return 0 ; }
int findMinZero ( int p ) { int first = 1 , second = 1 , number = 2 , next = 1 ; while ( next ) {
next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; }
int main ( ) { int p = 7 ; cout << " Minimal ▁ zero ▁ is : ▁ " << findMinZero ( p ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printCubes ( int a , int b ) {
for ( int i = a ; i <= b ; i ++ ) {
for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { cout << j * j * j << " ▁ " ; break ; } } } }
int main ( ) { int a = 1 , b = 100 ; cout << " Perfect ▁ cubes ▁ in ▁ given ▁ range : STRNEWLINE ▁ " ; printCubes ( a , b ) ; return 0 ; }
string toBinary ( double n ) {
if ( n >= 1 n <= 0 ) return " ERROR " ; string answer ; double frac = 0.5 ; answer . append ( " . " ) ; while ( n > 0 ) {
if ( answer . length ( ) >= 32 ) return " ERROR " ;
if ( n >= frac ) { answer . append ( "1" ) ; n = n - frac ; } else { answer . append ( "0" ) ; }
frac /= 2 ; } return answer ; }
double n = 0.625 ; string result = toBinary ( n ) ; cout << " ( 0" << result << " ) ▁ in ▁ base ▁ 2" << endl ; double m = 0.72 ; result = toBinary ( m ) ; cout << " ( " << result << " ) " << endl ; }
unsigned long long firstkdigits ( int n , int k ) { unsigned long long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ;
while ( ( int ) ( product / pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; }
int main ( ) { int n = 15 ; int k = 4 ; cout << firstkdigits ( n , k ) ; return 0 ; }
int check ( string str ) {
int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ;
return ( digitSum % 9 == 0 ) ; }
int main ( ) { string str = "99333" ; check ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) {
int res = 0 ;
for ( int i = 0 ; i < N ; i ++ )
for ( int j = i ; j < N ; j ++ )
for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; }
int main ( ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getTotalXorOfSubarrayXors ( arr , N ) ; return 0 ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) {
int res = 0 ;
for ( int i = 0 ; i < N ; i ++ ) {
int freq = ( i + 1 ) * ( N - i ) ;
if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; }
return res ; }
int main ( ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getTotalXorOfSubarrayXors ( arr , N ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findGCD ( int arr [ ] , int n ) { int result = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { result = gcd ( arr [ i ] , result ) ; if ( result == 1 ) { return 1 ; } } return result ; }
int main ( ) { int arr [ ] = { 2 , 4 , 6 , 8 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findGCD ( arr , n ) << endl ; return 0 ; }
int divSum ( int num ) {
int result = 0 ;
for ( int i = 1 ; i * i <= num ; ++ i ) {
if ( num % i == 0 ) {
if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return result ; }
bool isSuperPerfect ( int n ) {
int n1 = divSum ( n ) ;
return ( 2 * n == divSum ( n1 ) ) ; }
int main ( ) { int n = 16 ; cout << ( isSuperPerfect ( n ) ? " Yes STRNEWLINE " : " No STRNEWLINE " ) ; n = 6 ; cout << ( isSuperPerfect ( n ) ? " Yes STRNEWLINE " : " No STRNEWLINE " ) ; return 0 ; }
bool isRefactorableNumber ( int n ) {
int divCount = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) {
if ( n / i == i ) ++ divCount ;
else divCount += 2 ; } } return n % divCount == 0 ; }
int main ( ) { int n = 8 ; if ( isRefactorableNumber ( n ) ) puts ( " yes " ) ; else puts ( " no " ) ; n = 14 ; if ( isRefactorableNumber ( n ) ) puts ( " yes " ) ; else puts ( " no " ) ; return 0 ; }
bool isPerfectSquare ( int n ) { int sq = ( int ) sqrt ( n ) ; return ( n == sq * sq ) ; }
int countPerfectDivisors ( int n ) {
int count = 0 ;
for ( int i = 1 ; i * i <= n ; ++ i ) {
if ( n % i == 0 ) { if ( isPerfectSquare ( i ) ) ++ count ; if ( n / i != i && isPerfectSquare ( n / i ) ) ++ count ; } } return count ; }
int main ( ) { int n = 16 ; cout << " Total ▁ perfect ▁ divisors ▁ of ▁ " << n << " ▁ = ▁ " << countPerfectDivisors ( n ) << " STRNEWLINE " ; n = 12 ; cout << " Total ▁ perfect ▁ divisors ▁ of ▁ " << n << " ▁ = ▁ " << countPerfectDivisors ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void nearestGcd ( int arr [ ] , int n ) {
for ( int i = 0 ; i < n ; ++ i ) { int closest = -1 ;
for ( int j = i - 1 , k = i + 1 ; j > 0 k <= n ; -- j , ++ k ) { if ( j >= 0 && __gcd ( arr [ i ] , arr [ j ] ) > 1 ) { closest = j + 1 ; break ; } if ( k < n && __gcd ( arr [ i ] , arr [ k ] ) > 1 ) { closest = k + 1 ; break ; } }
cout << closest << " ▁ " ; } }
int main ( ) { int arr [ ] = { 2 , 9 , 4 , 3 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nearestGcd ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001
int prime [ MAX ] , countdiv [ MAX ] ;
void SieveOfEratosthenes ( ) { for ( int i = 2 ; i * i <= MAX ; ++ i ) { if ( ! prime [ i ] ) for ( int j = i * 2 ; j <= MAX ; j += i ) prime [ j ] = i ; }
for ( int i = 1 ; i < MAX ; ++ i ) if ( ! prime [ i ] ) prime [ i ] = i ; }
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int element = arr [ i ] ;
while ( element > 1 ) { int div = prime [ element ] ;
++ countdiv [ div ] ;
ans = max ( ans , countdiv [ div ] ) ; while ( element % div == 0 ) element /= div ; } } return ans ; }
SieveOfEratosthenes ( ) ; int arr [ ] = { 10 , 15 , 7 , 25 , 9 , 35 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largestGCDSubsequence ( arr , size ) ; return 0 ; }
int countOfBinaryNumberLessThanN ( int N ) {
queue < int > q ;
q . push ( 1 ) ; int cnt = 0 ; int t ;
while ( ! q . empty ( ) ) { t = q . front ( ) ; q . pop ( ) ;
if ( t <= N ) { cnt ++ ;
q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; }
int main ( ) { int N = 200 ; cout << countOfBinaryNumberLessThanN ( N ) ; return 0 ; }
int sumofproduct ( int n ) { int ans = 0 ;
for ( int x = 1 ; x <= n ; x ++ ) {
int y = n / x ;
ans += ( y * x ) ; } return ans ; }
int main ( ) { int n = 10 ; cout << sumofproduct ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int per ( int n ) { int a = 3 , b = 0 , c = 2 , i ; int m ; if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return c ; while ( n > 2 ) { m = a + b ; a = b ; b = c ; c = m ; n -- ; } return m ; }
int main ( ) { int n = 9 ; cout << per ( n ) ; return 0 ; }
cpp_int fact ( int n ) { cpp_int num = 1 ; for ( int i = 1 ; i <= n ; i ++ ) num = num * i ; return num ; }
int Special_Factorial_Number ( int k ) { for ( int i = 1 ; i <= k ; i ++ ) {
if ( ( fact ( i ) % k ) == 0 ) { return i ; } } }
int k = 16 ; cout << Special_Factorial_Number ( k ) ; }
int countMaxChoco ( int money , int price , int wrap ) {
if ( money < price ) return 0 ;
int choc = money / price ;
choc = choc + ( choc - 1 ) / ( wrap - 1 ) ; return choc ; }
int money = 15 ;
int price = 1 ;
int wrap = 3 ;
cout << countMaxChoco ( money , price , wrap ) ; return 0 ; }
int gcd ( int i , int j ) { if ( i == j ) return i ; if ( i > j ) return gcd ( i - j , j ) ; return gcd ( i , j - i ) ; }
bool ispossible ( int x , int y , int a , int b ) {
x = abs ( x ) , y = abs ( y ) , a = abs ( a ) , b = abs ( b ) ;
return ( gcd ( x , y ) == gcd ( a , b ) ) ; }
int main ( ) {
int x = 35 , y = 15 ; int a = 20 , b = 25 ; ( ispossible ( x , y , a , b ) ) ? ( cout << " Yes " ) : ( cout << " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ;
vector < int > primes ;
void sieveSundaram ( ) {
bool marked [ MAX / 2 + 1 ] = { 0 } ;
for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ;
primes . push_back ( 2 ) ;
for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; }
bool isEquidigital ( int n ) { if ( n == 1 ) return true ;
int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; }
int pDigit = 0 , count_exp = 0 , p ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) {
while ( n % primes [ i ] == 0 ) {
p = primes [ i ] ; n = n / p ;
count_exp ++ ; }
while ( p > 0 ) { pDigit ++ ; p = p / 10 ; }
while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } }
if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } }
return ( pDigit == sumDigits ) ; }
sieveSundaram ( ) ; cout << " Printing ▁ first ▁ few ▁ Equidigital ▁ Numbers " " ▁ using ▁ isEquidigital ( ) STRNEWLINE " ; for ( int i = 1 ; i < 20 ; i ++ ) if ( isEquidigital ( i ) ) cout << i << " ▁ " ; return 0 ; }
int getMaximumSumWithLCMN ( int N ) { int sum = 0 ; int LIM = sqrt ( N ) ;
for ( int i = 1 ; i <= LIM ; i ++ ) {
if ( N % i == 0 ) {
if ( i == ( N / i ) ) sum += i ; else sum += ( i + N / i ) ; } } return sum ; }
int main ( ) { int N = 12 ; cout << getMaximumSumWithLCMN ( N ) << endl ; return 0 ; }
long long lcm ( long long n ) { long long ans = 1 ; for ( long long i = 1 ; i <= n ; i ++ ) ans = ( ans * i ) / ( __gcd ( ans , i ) ) ; return ans ; }
int main ( ) { long long n = 20 ; cout << lcm ( n ) ; return 0 ; }
float y ( float x ) {
return 1 / ( 1 + x * x ) ; }
float trapezoidal ( float a , float b , float n ) {
float h = ( b - a ) / n ;
float s = y ( a ) + y ( b ) ;
for ( int i = 1 ; i < n ; i ++ ) s += 2 * y ( a + i * h ) ;
return ( h / 2 ) * s ; }
float x0 = 0 ; float xn = 1 ;
int n = 6 ; printf ( " Value ▁ of ▁ integral ▁ is ▁ % 6.4f STRNEWLINE " , trapezoidal ( x0 , xn , n ) ) ; return 0 ; }
long long numberOfDigits ( long long n ) { if ( n == 1 ) return 1 ;
long double d = ( n * log10 ( 1.6180339887498948 ) ) - ( ( log10 ( 5 ) ) / 2 ) ; return ceil ( d ) ; }
int main ( ) { long long i ; for ( i = 1 ; i <= 10 ; i ++ ) cout << " Number ▁ of ▁ Digits ▁ in ▁ F ( " << i << " ) ▁ - ▁ " << numberOfDigits ( i ) << " STRNEWLINE " ; return 0 ; }
int countOddSquares ( int n , int m ) { return ( int ) pow ( m , 0.5 ) - ( int ) pow ( n - 1 , 0.5 ) ; }
int main ( ) { int n = 5 , m = 100 ; cout << " Count ▁ is ▁ " << countOddSquares ( n , m ) ; return 0 ; }
bool isPower ( int x , long int y ) {
if ( x == 1 ) return ( y == 1 ) ;
long int pow = 1 ; while ( pow < y ) pow *= x ;
return ( pow == y ) ; }
check the result for true / false and printcout < < isPower ( 10 , 1 ) << endl ; cout << isPower ( 1 , 20 ) << endl ; cout << isPower ( 2 , 128 ) << endl ; cout << isPower ( 2 , 30 ) << endl ; return 0 ; }
int countSquares ( int a , int b ) { return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; }
int main ( ) { int a = 9 , b = 25 ; cout << " Count ▁ of ▁ squares ▁ is ▁ " << countSquares ( a , b ) ; return 0 ; }
int findCountUpto ( int d ) {
int GP1_Sum = 9 * ( ( pow ( 10 , d ) - 1 ) / 9 ) ; int GP2_Sum = 9 * ( ( pow ( 9 , d ) - 1 ) / 8 ) ; return GP1_Sum - GP2_Sum ; }
int main ( ) { int d = 1 ; cout << findCountUpto ( d ) << endl ; d = 2 ; cout << findCountUpto ( d ) << endl ; d = 4 ; cout << findCountUpto ( d ) << endl ; return 0 ; }
void countDivisors ( int n ) {
int count = 0 ;
for ( int i = 1 ; i <= sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 )
count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) cout << " Even " << endl ; else cout << " Odd " << endl ; }
int main ( ) { cout << " The ▁ count ▁ of ▁ divisor : ▁ " ; countDivisors ( 10 ) ; return 0 ; }
int largestPower ( int n , int p ) {
int x = 0 ;
while ( n ) { n /= p ; x += n ; } return x ; }
int power ( int x , int y , int p ) {
int res = 1 ; x = x % p ; while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int res = 1 ;
bool isPrime [ n + 1 ] ; memset ( isPrime , 1 , sizeof ( isPrime ) ) ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j <= n ; j += i ) isPrime [ j ] = 0 ; } }
for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime [ i ] ) {
int k = largestPower ( n , i ) ;
res = ( res * power ( i , k , p ) ) % p ; } } return res ; }
int main ( ) { int n = 25 , p = 29 ; cout << modFact ( n , p ) ; return 0 ; }
int countSquares ( int m , int n ) {
if ( n < m ) swap ( m , n ) ;
return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; }
int main ( ) { int m = 4 , n = 3 ; cout << " Count ▁ of ▁ squares ▁ is ▁ " << countSquares ( m , n ) ; }
int add ( int x , int y ) {
while ( y > 0 && y -- ) x ++ ;
while ( y < 0 && y ++ ) x -- ; return x ; }
int main ( ) { cout << add ( 43 , 23 ) << endl ; cout << add ( 43 , -23 ) << endl ; return 0 ; }
int countFact ( int low , int high ) {
int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; }
int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; }
return res ; }
int main ( ) { cout << " Count ▁ is ▁ " << countFact ( 2 , 720 ) ; return 0 ; }
int getPeriod ( int n ) {
int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ;
int d = rem ;
int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; }
int main ( ) { cout << getPeriod ( 3 ) << endl ; cout << getPeriod ( 7 ) << endl ; return 0 ; }
int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; }
int main ( ) { cout << getRemainder ( 100 , 7 ) ; return 0 ; }
double sum ( int n ) { double sum = 0 ; int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) {
fact *= i ;
sum += 1.0 / fact ; } return sum ; }
int main ( ) { int n = 5 ; cout << sum ( n ) ; return 0 ; }
void print ( int n , int k ) {
int rem = 1 ;
for ( int i = 0 ; i < k ; i ++ ) {
cout << ( 10 * rem ) / n ;
rem = ( 10 * rem ) % n ; } }
int main ( ) { int n = 7 , k = 3 ; print ( n , k ) ; cout << endl ; n = 21 , k = 4 ; print ( n , k ) ; return 0 ; }
class gfg { public : double sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } } ;
int main ( ) { gfg g ; int n = 5 ; cout << " Sum ▁ is ▁ " << g . sum ( n ) ; return 0 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int main ( ) { int a = 98 , b = 56 ; cout << " GCD ▁ of ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << gcd ( a , b ) ; return 0 ; }
void rearrange ( int arr [ ] , int n ) {
for ( int i = 0 ; i < n ; i ++ ) arr [ i ] += ( arr [ arr [ i ] ] % n ) * n ;
for ( int i = 0 ; i < n ; i ++ ) arr [ i ] /= n ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; }
int main ( ) { int arr [ ] = { 3 , 2 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Given ▁ array ▁ is ▁ STRNEWLINE " ; printArr ( arr , n ) ; rearrange ( arr , n ) ; cout << " Modified ▁ array ▁ is ▁ STRNEWLINE " ; printArr ( arr , n ) ; return 0 ; }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << " ▁ " << arr [ i ] ; cout << " STRNEWLINE " ; return ; }
void printSequencesRecur ( int arr [ ] , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } }
void printSequences ( int n , int k ) { int * arr = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; }
int main ( ) { int n = 3 ; int k = 2 ; printSequences ( n , k ) ; return 0 ; }
bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; }
int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) cout << n << " ▁ is ▁ multiple ▁ of ▁ 5" ; else cout << n << " ▁ is ▁ not ▁ a ▁ multiple ▁ of ▁ 5" ; return 0 ; }
void CalculatePairs ( int a [ ] , int n ) {
int cnt_zero = 0 ;
int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } long int total_XOR_pairs = cnt_zero * cnt_one ; long int total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; long int total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; cout << " cntXOR ▁ = ▁ " << total_XOR_pairs << endl ; cout << " cntAND ▁ = ▁ " << total_AND_pairs << endl ; cout << " cntOR ▁ = ▁ " << total_OR_pairs << endl ; }
int main ( ) { int a [ ] = { 1 , 3 , 4 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; CalculatePairs ( a , n ) ; return 0 ; }
void alternate ( int & a , int & b , int & x ) { x = a + b - x ; }
int main ( ) { int a = -10 ; int b = 15 ; int x = a ; cout << " x ▁ is ▁ : ▁ " << x ; alternate ( a , b , x ) ; cout << " After change " cout << " STRNEWLINE x ▁ is ▁ : ▁ " << x ; }
#include <iostream> NEW_LINE using namespace std ; int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; }
int main ( ) { int n = 48 ; cout << highestPowerOf2 ( n ) ; return 0 ; }
void isSubsetAndZero ( int array [ ] , int length , int N ) {
int arrAnd = array [ 0 ] ;
for ( int i = 1 ; i < length ; i ++ ) { arrAnd = arrAnd & array [ i ] ; }
if ( ( arrAnd & N ) == 0 ) cout << " YES " << endl ; else cout << " NO " << endl ; }
int main ( ) { int array [ ] = { 1 , 2 , 4 } ; int length = sizeof ( array ) / sizeof ( int ) ; int N = 3 ; isSubsetAndZero ( array , length , N ) ; }
bool findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ;
if ( y & 1 ) return 1 ; return 0 ; }
int main ( ) { ( findParity ( 9 ) == 0 ) ? cout << " Even ▁ Parity STRNEWLINE " : cout << " Odd ▁ Parity STRNEWLINE " ; ( findParity ( 13 ) == 0 ) ? cout << " Even ▁ Parity STRNEWLINE " : cout << " Odd ▁ Parity STRNEWLINE " ; return 0 ; }
bool allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) {
int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ;
int new_num = n & num ;
if ( num == new_num ) return true ;
return false ; }
bool bitsAreComplement ( unsigned int a , unsigned int b , unsigned int l , unsigned int r ) { unsigned int xor_value = a ^ b ; return allBitsSetInTheGivenRange ( xor_value , l , r ) ; }
int main ( ) { unsigned int a = 10 , b = 5 ; unsigned int l = 1 , r = 3 ; if ( bitsAreComplement ( a , b , l , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int calculateSum ( int n ) {
int sum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
sum = sum + ( 1 << i ) ; } return sum ; }
int main ( ) { int n = 10 ; cout << " Sum ▁ of ▁ series ▁ of ▁ power ▁ of ▁ 2 ▁ is ▁ : ▁ " << calculateSum ( n ) ; }
void printCombinations ( int a [ ] , int n , int m ) {
for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int sum = 0 ;
int num = 1 << ( n - 1 ) ;
for ( int j = 0 ; j < n ; j ++ ) {
if ( i & num ) sum += a [ j ] ; else sum += ( -1 * a [ j ] ) ;
num = num >> 1 ; } if ( sum % m == 0 ) {
num = 1 << ( n - 1 ) ;
for ( int j = 0 ; j < n ; j ++ ) {
if ( ( i & num ) ) cout << " + " << a [ j ] << " ▁ " ; else cout << " - " << a [ j ] << " ▁ " ;
num = num >> 1 ; } cout << endl ; } } }
int main ( ) { int a [ ] = { 3 , 5 , 6 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = 5 ; printCombinations ( a , n , m ) ; return 0 ; }
smallerNumsWithSameSetBits ( int n ) {
int temp = __builtin_popcount ( n ) ;
int count = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) {
if ( temp == __builtin_popcount ( i ) ) count ++ ; } return count ; }
int main ( ) { int n = 4 ; cout << smallerNumsWithSameSetBits ( n ) ; return 0 ; }
int multiplyWith4 ( int n ) {
return ( n << 2 ) ; }
int main ( ) { int n = 4 ; cout << multiplyWith4 ( n ) << endl ; return 0 ; }
int evenbitsetnumber ( int n ) {
int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) {
if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; }
return ( n res ) ; }
/ * Driver code * int main ( ) { int n = 10 ; cout << evenbitsetnumber ( n ) ; return 0 ; }
int getmsb ( int n ) {
n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ;
return ( n + 1 ) >> 1 ; }
int getevenbits ( int n ) {
n = getmsb ( n ) ;
n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ;
if ( n & 1 ) n = n >> 1 ;
return n ; }
int setallevenbits ( int n ) {
return n | getevenbits ( n ) ; }
int main ( ) { int n = 10 ; cout << setallevenbits ( n ) ; return 0 ; }
int oddbitsetnumber ( int n ) { int count = 0 ;
int res = 0 ;
for ( int temp = n ; temp > 0 ; temp >>= 1 ) {
if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; }
int main ( ) { int n = 10 ; cout << oddbitsetnumber ( n ) ; return 0 ; }
int getmsb ( int n ) {
n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ;
return ( n + 1 ) >> 1 ; }
int getevenbits ( int n ) { n = getmsb ( n ) ;
n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ;
if ( ( n & 1 ) == 0 ) n = n >> 1 ;
return n ; }
int setalloddbits ( int n ) {
return n | getevenbits ( n ) ; }
int main ( ) { int n = 10 ; cout << setalloddbits ( n ) ; return 0 ; }
void printNumHavingAltBitPatrn ( int n ) {
int curr_num = 1 ;
cout << curr_num << " ▁ " ;
while ( 1 ) {
curr_num <<= 1 ;
if ( n < curr_num ) break ;
cout << curr_num << " ▁ " ;
curr_num = ( ( curr_num ) << 1 ) ^ 1 ;
if ( n < curr_num ) break ;
cout << curr_num << " ▁ " ; } }
int main ( ) { int n = 50 ; printNumHavingAltBitPatrn ( n ) ; return 0 ; }
unsigned int perfectPowerOf2 ( unsigned int n ) {
unsigned int per_pow = 1 ; while ( n > 0 ) {
per_pow = per_pow << 1 ;
n = n >> 1 ; }
return per_pow ; }
int main ( ) { unsigned int n = 128 ; cout << " Perfect ▁ power ▁ of ▁ 2 ▁ greater ▁ than ▁ " << n << " : ▁ " << perfectPowerOf2 ( n ) ; return 0 ; }
#include <stdio.h> NEW_LINE void findUniquePair ( int arr [ ] , int n ) {
int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ;
int set_bit_no = XOR & ~ ( XOR - 1 ) ;
for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ;
else y = y ^ arr [ i ] ;
} printf ( " The ▁ unique ▁ pair ▁ is ▁ ( % d , ▁ % d ) " , x , y ) ; }
int main ( ) { int a [ ] = { 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; findUniquePair ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countUnsetBits ( int n ) { int x = n ;
n |= n >> 1 ;
n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ;
return __builtin_popcount ( x ^ n ) ; }
int main ( ) { int n = 17 ; cout << countUnsetBits ( n ) ; return 0 ; }
void toggle ( int & n ) {
int temp = 1 ;
while ( temp <= n ) {
n = n ^ temp ;
temp = temp << 1 ; } }
int main ( ) { int n = 10 ; toggle ( n ) ; cout << n ; return 0 ; }
int isKthBitSet ( int x , int k ) { return ( x & ( 1 << ( k - 1 ) ) ) ? 1 : 0 ; }
int leftmostSetBit ( int x ) { int count = 0 ; while ( x ) { count ++ ; x = x >> 1 ; } return count ; }
int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ;
while ( l > r ) {
if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; } int findNthPalindrome ( int n ) { int pal_count = 0 ;
int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) ) { pal_count ++ ; }
if ( pal_count == n ) break ; } return i ; }
int main ( ) { int n = 9 ;
cout << findNthPalindrome ( n ) ; }
bool LSB ( int num , int K ) { return ( num & ( 1 << ( K - 1 ) ) ) ; }
int main ( ) { int num = 10 , K = 4 ;
cout << LSB ( num , K ) ; return 0 ; }
void areSame ( int a , int b ) { if ( ! ( a - b ) ) cout << " Same " ; else cout << " Not ▁ Same " ; }
int main ( ) { areSame ( 10 , 20 ) ; return 0 ; }
int getRightMostSetBit ( int n ) {
if ( n == 0 ) return 0 ; return log2 ( n & - n ) + 1 ; }
int posOfRightMostDiffBit ( int m , int n ) {
return getRightMostSetBit ( m ^ n ) ; }
int main ( ) { int m = 52 , n = 24 ; cout << " Position ▁ of ▁ rightmost ▁ different ▁ bit : " << posOfRightMostDiffBit ( m , n ) << endl ; return 0 ; }
int getNext ( int n ) {
int c = n ; int c0 = 0 ; int c1 = 0 ; while ( ( ( c & 1 ) == 0 ) && ( c != 0 ) ) { c0 ++ ; c >>= 1 ; } while ( ( c & 1 ) == 1 ) { c1 ++ ; c >>= 1 ; }
if ( c0 + c1 == 31 c0 + c1 == 0 ) return -1 ; return n + ( 1 << c0 ) + ( 1 << ( c1 - 1 ) ) - 1 ; }
int n = 5 ; cout << getNext ( n ) ;
n = 8 ; cout << endl ; cout << getNext ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int totalFlips ( char * A , char * B , char * C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) {
if ( A [ i ] == B [ i ] && C [ i ] == '1' ) ++ count ;
else if ( A [ i ] != B [ i ] && C [ i ] == '0' ) ++ count ; } return count ; }
int N = 5 ; char a [ ] = "10100" ; char b [ ] = "00010" ; char c [ ] = "10011" ; cout << totalFlips ( a , b , c , N ) ; return 0 ; }
void swapThree ( int & a , int & b , int & c ) {
a = a ^ b ^ c ;
b = a ^ b ^ c ;
c = a ^ b ^ c ;
a = a ^ b ^ c ; }
int main ( ) { int a = 10 , b = 20 , c = 30 ; cout << " Before ▁ swapping ▁ a ▁ = ▁ " << a << " , ▁ b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ;
swapThree ( a , b , c ) ; cout << " After ▁ swapping ▁ a ▁ = ▁ " << a << " , ▁ b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; return 0 ; }
void findTwoMissingNumbers ( int arr [ ] , int n ) {
int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n - 2 ; i ++ ) XOR ^= arr [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) XOR ^= i ;
int set_bit_no = XOR & ~ ( XOR - 1 ) ;
for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ;
else y = y ^ arr [ i ] ;
} for ( int i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ;
else y = y ^ i ;
} printf ( " Two ▁ Missing ▁ Numbers ▁ are % d % d " }
int main ( ) { int arr [ ] = { 1 , 3 , 5 , 6 } ;
int n = 2 + sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTwoMissingNumbers ( arr , n ) ; return 0 ; }
int countSetBits ( int n ) { int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
char findProffesion ( int level , int pos ) {
int c = countSetBits ( pos - 1 ) ;
return ( c % 2 ) ? ' d ' : ' e ' ; }
int main ( void ) { int level = 3 , pos = 4 ; ( findProffesion ( level , pos ) == ' e ' ) ? cout << " Engineer " : cout << " Doctor " ; return 0 ; }
int rand2 ( ) {
return rand ( ) & 1 ; }
int rand3 ( ) {
int r = 2 * rand2 ( ) + rand2 ( ) ; if ( r < 3 ) return r ; return rand3 ( ) ; }
int main ( ) { srand ( time ( NULL ) ) ; for ( int i = 0 ; i < 100 ; i ++ ) cout << rand3 ( ) ; return 0 ; }
void findpair ( int l , int r ) {
int ans1 = l ; int ans2 = 2 * l ; cout << ans1 << " , ▁ " << ans2 << endl ; }
int main ( ) { int l = 1 , r = 10 ; findpair ( l , r ) ; }
bool ElementsCalculationFunc ( int pre [ ] , int maxx [ ] , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) {
if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; } void MaxNumberOfElements ( int a [ ] , int n , int k ) {
sort ( a , a + n ) ;
for ( int i = 0 ; i <= n ; ++ i ) { pre [ i ] = 0 ; maxx [ i ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) {
pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] ;
maxx [ i ] = max ( maxx [ i - 1 ] , a [ i - 1 ] ) ; }
int l = 1 , r = n , ans ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( ElementsCalculationFunc ( pre , maxx , mid - 1 , k , n ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; }
cout << ans << " STRNEWLINE " ; }
int main ( ) { int arr [ ] = { 2 , 4 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; MaxNumberOfElements ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_STR_LEN = 1000 ; bool P [ MAX_STR_LEN ] [ MAX_STR_LEN ] ; int Kpal [ MAX_STR_LEN ] ;
void checkSubStrPal ( string str , int n ) {
memset ( P , false , sizeof ( P ) ) ;
for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ;
for ( int i = 0 ; i < n - 1 ; i ++ ) if ( str [ i ] == str [ i + 1 ] ) P [ i ] [ i + 1 ] = true ;
for ( int gap = 2 ; gap < n ; gap ++ ) {
for ( int i = 0 ; i < n - gap ; i ++ ) {
int j = gap + i ;
if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; } } }
void countKPalindromes ( int i , int j , int k ) {
if ( i == j ) { Kpal [ k ] ++ ; return ; }
if ( P [ i ] [ j ] == false ) return ;
Kpal [ k ] ++ ;
int mid = ( i + j ) / 2 ;
if ( ( j - i + 1 ) % 2 == 1 ) mid -- ;
countKPalindromes ( i , mid , k + 1 ) ; } void printKPalindromes ( string s ) { memset ( Kpal , 0 , sizeof ( Kpal ) ) ;
int n = s . length ( ) ; checkSubStrPal ( s , n ) ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - i ; j ++ ) countKPalindromes ( j , j + i , 1 ) ;
for ( int i = 1 ; i <= n ; i ++ ) cout << Kpal [ i ] << " ▁ " ; cout << " STRNEWLINE " ; }
int main ( ) { string s = " abacaba " ; printKPalindromes ( s ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void countCountries ( int ans [ ] , int N ) { int total_countries = 0 , i = 0 ; bool invalid = false ; while ( i < N ) { int curr_size = ans [ i ] ;
int num = ans [ i ] ; while ( num > 0 ) {
if ( ans [ i ] != curr_size ) { cout << " Invalid ▁ Answer STRNEWLINE " ; return ; } else num -- ;
i ++ ; }
total_countries ++ ; } cout << " There ▁ are ▁ " << total_countries << " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . STRNEWLINE " ; }
int main ( ) { int ans [ ] = { 1 , 1 , 2 , 2 , 4 , 4 , 4 , 4 } ; int n = sizeof ( ans ) / sizeof ( ans [ 0 ] ) ; countCountries ( ans , n ) ; return 0 ; }
bool check_elements ( int arr [ ] , int n , int A , int B ) {
int range = B - A ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( abs ( arr [ i ] ) >= A && abs ( arr [ i ] ) <= B ) { int z = abs ( arr [ i ] ) - A ; if ( arr [ z ] > 0 ) { arr [ z ] = arr [ z ] * -1 ; } } }
int count = 0 ; for ( int i = 0 ; i <= range && i < n ; i ++ ) {
if ( arr [ i ] > 0 ) return false ; else count ++ ; } if ( count != ( range + 1 ) ) return false ;
return true ; }
int arr [ ] = { 1 , 4 , 5 , 2 , 7 , 8 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
int A = 2 , B = 5 ;
if ( check_elements ( arr , n , A , B ) ) cout << " Yes " ;
else cout < < " No " ; return 0 ; }
int findMinRec ( int A [ ] , int n ) {
if ( n == 1 ) return A [ 0 ] ; return min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; }
int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , -50 , 10 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << findMinRec ( A , n ) ; return 0 ; }
bool isPossible ( int arr [ ] , int n , int m , int curr_min ) { int studentsRequired = 1 ; int curr_sum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( arr [ i ] > curr_min ) return false ;
if ( curr_sum + arr [ i ] > curr_min ) {
studentsRequired ++ ;
curr_sum = arr [ i ] ;
if ( studentsRequired > m ) return false ; }
else curr_sum += arr [ i ] ; } return true ; }
int findPages ( int arr [ ] , int n , int m ) { long long sum = 0 ;
if ( n < m ) return -1 ;
for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;
int start = 0 , end = sum ; int result = INT_MAX ;
while ( start <= end ) {
int mid = ( start + end ) / 2 ; if ( isPossible ( arr , n , m , mid ) ) {
result = mid ;
end = mid - 1 ; } else
start = mid + 1 ; }
return result ; }
int arr [ ] = { 12 , 34 , 67 , 90 } ; int n = sizeof arr / sizeof arr [ 0 ] ;
cout << " Minimum ▁ number ▁ of ▁ pages ▁ = ▁ " << findPages ( arr , n , m ) << endl ; return 0 ; }
int countDistinct ( int arr [ ] , int n ) {
unordered_set < int > s ;
int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( s . find ( arr [ i ] ) == s . end ( ) ) { s . insert ( arr [ i ] ) ; res ++ ; } } return res ; }
int main ( ) { int arr [ ] = { 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDistinct ( arr , n ) ; return 0 ; }
static int findOptimalSolution ( int a [ ] , int N ) {
sort ( a , a + N ) ;
int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; }
int main ( ) { int a [ ] = { 1 , 4 , 2 , 3 , 9 } ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << ( findOptimalSolution ( a , N ) ) ; return 0 ; }
int number_of_tower ( int house [ ] , int range , int n ) {
sort ( house , house + n ) ;
int numOfTower = 0 ;
int i = 0 ; while ( i < n ) {
numOfTower ++ ;
int loc = house [ i ] + range ;
while ( i < n && house [ i ] <= loc ) i ++ ;
-- i ;
loc = house [ i ] + range ;
while ( i < n && house [ i ] <= loc ) i ++ ; }
return numOfTower ; }
int house [ ] = { 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 } ; int range = 2 ; int n = sizeof ( house ) / sizeof ( house [ 0 ] ) ;
cout << number_of_tower ( house , range , n ) ; }
bool isAlphabaticOrder ( string s ) {
int n = s . length ( ) ;
char c [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; }
sort ( c , c + n ) ;
for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; }
int main ( ) { string s = " aabbbcc " ;
if ( isAlphabaticOrder ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
void printOrder ( int arr [ ] , int n , int k ) {
sort ( arr , arr + k ) ;
sort ( arr + k , arr + n , greater < int > ( ) ) ; }
int arr [ ] = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , -1 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printOrder ( arr , n , k ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void descOrder ( string s ) { sort ( s . begin ( ) , s . end ( ) , greater < char > ( ) ) ; }
int main ( ) { string s = " geeksforgeeks " ;
return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ;
int findDuplicate ( int arr [ ] , int n , int k ) {
int freq [ MAX ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { cout << " Out ▁ of ▁ range " ; return -1 ; } freq [ arr [ i ] ] += 1 ; }
for ( int i = 0 ; i < MAX ; i ++ ) {
if ( freq [ i ] == k ) return i ; } return -1 ; }
int main ( ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = sizeof ( arr ) / ( sizeof ( arr [ 0 ] ) ) ; cout << findDuplicate ( arr , n , k ) ; return 0 ; }
void pendulumArrangement ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int op [ n ] ;
int mid = ( n - 1 ) / 2 ;
int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; }
if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ;
cout << " Pendulum ▁ arrangement : " << endl ; for ( i = 0 ; i < n ; i ++ ) cout << op [ i ] << " ▁ " ; cout << endl ; }
int arr [ ] = { 14 , 6 , 19 , 21 , 12 } ;
int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pendulumArrangement ( arr , n ) ; return 0 ; }
long long int minValue ( int A [ ] , int B [ ] , int n ) {
sort ( A , A + n ) ; sort ( B , B + n ) ;
long long int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; }
int main ( ) { int A [ ] = { 3 , 1 , 1 } ; int B [ ] = { 6 , 5 , 4 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minValue ( A , B , n ) << endl ; return 0 ; }
void printMaxNumber ( int n ) {
if ( n & 1 ) {
cout << "7" ;
for ( int i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) cout << "1" ; }
else {
for ( int i = 0 ; i < n / 2 ; i ++ ) cout << "1" ; } }
int main ( ) { int n = 5 ; printMaxNumber ( n ) ; return 0 ; }
int sorted_partitions ( int arr [ ] , int n ) {
int right_min [ n + 1 ] ; right_min [ n ] = INT8_MAX ; for ( int i = n - 1 ; i >= 0 ; i -- ) { right_min [ i ] = min ( right_min [ i + 1 ] , arr [ i ] ) ; }
int partitions = 0 ; for ( int current_max = arr [ 0 ] , i = 0 ; i < n ; i ++ ) { current_max = max ( current_max , arr [ i ] ) ;
if ( current_max <= right_min [ i + 1 ] ) partitions ++ ; } return partitions ; }
int main ( ) { int arr [ ] = { 3 , 1 , 2 , 4 , 100 , 7 , 9 } ;
int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int ans = sorted_partitions ( arr , n ) ; cout << ans << endl ; return 0 ; }
int getMinCost ( int arr [ ] , int n ) { int min_ele = * min_element ( arr , arr + n ) ; return min_ele * ( n - 1 ) ; }
int main ( ) { int arr [ ] = { 4 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMinCost ( arr , n ) << endl ; return 0 ; }
int main ( ) { string st = " NNNWEWESSS " ; int len = st . length ( ) ;
for ( int i = 0 ; i < len ; i ++ ) { if ( st [ i ] == ' N ' ) n += 1 ; if ( st [ i ] == ' S ' ) s += 1 ; if ( st [ i ] == ' W ' ) w += 1 ; if ( st [ i ] == ' E ' ) e += 1 ; } if ( n == s && w == e ) cout << ( " YES " ) << endl ; else cout << ( " NO " ) << endl ; }
int cost ( int a [ ] , int n ) {
return ( n - 1 ) * ( * min_element ( a , a + n ) ) ; }
int main ( ) { int a [ ] = { 4 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << cost ( a , n ) << endl ; return 0 ; }
int minCost ( int coin [ ] , int n , int k ) {
sort ( coin , coin + n ) ;
int coins_needed = ceil ( 1.0 * n / ( k + 1 ) ) ;
int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; }
int main ( ) { int coin [ ] = { 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 } ; int n = sizeof ( coin ) / sizeof ( coin [ 0 ] ) ; int k = 3 ; cout << minCost ( coin , n , k ) ; return 0 ; }
int countOddNumber ( int row_num ) {
unsigned int count = 0 ; while ( row_num ) { count += row_num & 1 ; row_num >>= 1 ; }
return ( 1 << count ) ; }
void gouldSequence ( int n ) {
for ( int row_num = 0 ; row_num < n ; row_num ++ ) { cout << countOddNumber ( row_num ) << " ▁ " ; } }
int n = 16 ;
gouldSequence ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countWays ( int n ) { int A [ n + 1 ] , B [ n + 1 ] ; A [ 0 ] = 1 , A [ 1 ] = 0 , B [ 0 ] = 0 , B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; } return A [ n ] ; }
int main ( ) { int n = 8 ; cout << countWays ( n ) ; return 0 ; }
int sequence ( int n ) { if ( n == 1 n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; }
int main ( ) { int n = 10 ; cout << sequence ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int numberOfWays ( int x ) {
if ( x == 0 x == 1 ) return 1 ;
else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; }
int main ( ) { int x = 3 ; cout << numberOfWays ( x ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int numberOfWays ( int x ) { int dp [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
int main ( ) { int x = 3 ; cout << numberOfWays ( x ) << endl ; return 0 ; }
int findLongestRepeatingSubSeq ( string str ) { int n = str . length ( ) ;
int dp [ n + 1 ] [ n + 1 ] ;
for ( int i = 0 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = 0 ; dp [ 0 ] [ i ] = 0 ; }
for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) {
if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;
int waysToArrange ( int N , int K , int k [ ] ) { int C [ N + 1 ] [ N + 1 ] ; int i , j ;
for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) {
if ( j == 0 j == i ) C [ i ] [ j ] = 1 ;
else C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } }
int dp [ K ] ;
int count = 0 ; dp [ 0 ] = 1 ;
for ( int i = 0 ; i < K ; i ++ ) {
dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; }
return dp [ K ] ; }
int main ( ) { int N = 4 ; int k [ ] = { 2 , 2 } ; int K = sizeof ( k ) / sizeof ( int ) ; cout << waysToArrange ( N , K , k ) << endl ; return 0 ; }
int minCells ( int mat [ SIZE ] [ SIZE ] , int m , int n ) {
int dp [ m ] [ n ] ;
for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = INT_MAX ;
dp [ 0 ] [ 0 ] = 1 ;
for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
if ( dp [ i ] [ j ] != INT_MAX && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ;
if ( dp [ i ] [ j ] != INT_MAX && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } }
if ( dp [ m - 1 ] [ n - 1 ] != INT_MAX ) return dp [ m - 1 ] [ n - 1 ] ;
return -1 ; }
int main ( ) { int mat [ SIZE ] [ SIZE ] = { { 2 , 3 , 2 , 1 , 4 } , { 3 , 2 , 5 , 8 , 2 } , { 1 , 1 , 2 , 2 , 1 } } ; int m = 3 , n = 5 ; cout << " Minimum ▁ number ▁ of ▁ cells ▁ = ▁ " << minCells ( mat , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ;
int cal ( int ones [ R + 1 ] [ C + 1 ] , int x , int y , int k ) { return ones [ x + k - 1 ] [ y + k - 1 ] - ones [ x - 1 ] [ y + k - 1 ] - ones [ x + k - 1 ] [ y - 1 ] + ones [ x - 1 ] [ y - 1 ] ; }
int sol ( int mat [ R ] [ C ] ) { int ans = 0 ;
int ones [ R + 1 ] [ C + 1 ] = { 0 } ; for ( int i = 1 ; i <= R ; i ++ ) for ( int j = 1 ; j <= C ; j ++ ) ones [ i ] [ j ] = ones [ i - 1 ] [ j ] + ones [ i ] [ j - 1 ] - ones [ i - 1 ] [ j - 1 ] + ( mat [ i - 1 ] [ j - 1 ] == 1 ) ;
for ( int k = 1 ; k <= min ( R , C ) ; k ++ ) for ( int i = 1 ; i + k - 1 <= R ; i ++ ) for ( int j = 1 ; j + k - 1 <= C ; j ++ ) ans = max ( ans , ( ones [ R ] [ C ] + k * k - 2 * cal ( ones , i , j , k ) ) ) ; return ans ; }
int main ( ) { int mat [ R ] [ C ] = { { 0 , 0 , 1 } , { 0 , 0 , 1 } , { 1 , 0 , 1 } } ; cout << sol ( mat ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinSteps ( int n ) { int table [ n + 1 ] ; table [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! ( i % 2 ) && ( i % 3 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , table [ i / 2 ] ) ; else if ( ! ( i % 3 ) && ( i % 2 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , table [ i / 3 ] ) ; else if ( ! ( i % 2 ) && ! ( i % 3 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , min ( table [ i / 2 ] , table [ i / 3 ] ) ) ; else table [ i ] = 1 + table [ i - 1 ] ; } return table [ n ] ; }
int main ( ) { int n = 14 ; cout << getMinSteps ( n ) ; return 0 ; }
int longestSubseqWithDiffOne ( int arr [ ] , int n ) {
int dp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ;
for ( int i = 1 ; i < n ; i ++ ) {
for ( int j = 0 ; j < i ; j ++ ) {
if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) ; } }
int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; }
int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestSubseqWithDiffOne ( arr , n ) ; return 0 ; }
unsigned long int catalanDP ( unsigned int n ) {
catalan [ 0 ] = catalan [ 1 ] = 1 ;
for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; }
return catalan [ n ] ; }
unsigned long int countWays ( unsigned long int n ) {
if ( n & 1 ) { cout << " Invalid " ; return 0 ; }
return catalanDP ( n / 2 ) ; }
int main ( ) { cout << countWays ( 6 ) << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100
int dp [ MAX ] [ MAX ] [ MAX ] [ 3 ] ;
int countWays ( int p , int q , int r , int last ) {
if ( p < 0 q < 0 r < 0 ) return 0 ;
if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ;
if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ;
if ( dp [ p ] [ q ] [ r ] [ last ] != -1 ) return dp [ p ] [ q ] [ r ] [ last ] ;
if ( last == 0 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ;
else if ( last == 1 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ;
dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return dp [ p ] [ q ] [ r ] [ last ] ; }
int countUtil ( int p , int q , int r ) {
}
int main ( ) { int p = 1 , q = 1 , r = 1 ; printf ( " % d " , countUtil ( p , q , r ) ) ; return 0 ; }
int countDer ( int n ) {
if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ;
return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; }
int main ( ) { int n = 4 ; cout << " Count ▁ of ▁ Derangements ▁ is ▁ " << countDer ( n ) ; return 0 ; }
int countDer ( int n ) {
der [ 1 ] = 0 ; der [ 2 ] = 1 ;
for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ;
return der [ n ] ; }
int main ( ) { int n = 4 ; cout << " Count ▁ of ▁ Derangements ▁ is ▁ " << countDer ( n ) ; return 0 ; }
int countSol ( int coeff [ ] , int n , int rhs ) {
int dp [ rhs + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] = 1 ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; }
int main ( ) { int coeff [ ] = { 2 , 2 , 5 } ; int rhs = 4 ; int n = sizeof ( coeff ) / sizeof ( coeff [ 0 ] ) ; cout << countSol ( coeff , n , rhs ) ; return 0 ; }
int maxProd ( int n ) {
if ( n == 2 n == 3 ) return ( n - 1 ) ;
int res = 1 ; while ( n > 4 ) { n -= 3 ;
res *= 3 ; }
return ( n * res ) ; }
int main ( ) { cout << " Maximum ▁ Product ▁ is ▁ " << maxProd ( 10 ) ; return 0 ; }
int findWays ( int m , int n , int x ) {
int table [ n + 1 ] [ x + 1 ] ;
for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ;
for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) for ( int k = 1 ; k <= m && k < j ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ;
return table [ n ] [ x ] ; }
int main ( ) { cout << findWays ( 4 , 2 , 1 ) << endl ; cout << findWays ( 2 , 2 , 3 ) << endl ; cout << findWays ( 6 , 3 , 8 ) << endl ; cout << findWays ( 4 , 2 , 5 ) << endl ; cout << findWays ( 4 , 3 , 5 ) << endl ; return 0 ; }
int lps ( char * seq , int i , int j ) {
if ( i == j ) return 1 ;
if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ;
if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ;
return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }
int main ( ) { char seq [ ] = " GEEKSFORGEEKS " ; int n = strlen ( seq ) ; cout << " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " << lps ( seq , 0 , n - 1 ) ; return 0 ; }
int findCount ( string str1 , string str2 ) { int len = str1 . size ( ) ; int len2 = str2 . size ( ) ; int ans = INT_MAX ;
int hash1 [ 26 ] = { 0 } , hash2 [ 26 ] = { 0 } ;
for ( int i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = min ( ans , hash1 [ i ] / hash2 [ i ] ) ;
return ans ; }
int main ( ) { string str1 = " geeksclassesatnoida " ; string str2 = " sea " ; cout << findCount ( str1 , str2 ) ; return 0 ; }
bool isVowel ( char c ) { string vowel = " aeiou " ; for ( int i = 0 ; i < vowel . length ( ) ; ++ i ) if ( vowel [ i ] == c ) return true ; return false ; }
bool printRLE ( string str , string typed ) { int n = str . length ( ) , m = typed . length ( ) ;
int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( str [ i ] != typed [ j ] ) return false ;
if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; }
int count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; }
int count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) return false ; } return true ; }
int main ( ) { string name = " alex " , typed = " aaalaeex " ; if ( printRLE ( name , typed ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
string censor ( string text , string word ) {
vector < string > word_list ; boost :: split ( word_list , text , boost :: is_any_of ( " \\ ▁ + " ) ) ;
string result = " " ;
string stars = " " ; for ( int i = 0 ; i < word . size ( ) ; i ++ ) stars += ' * ' ;
int index = 0 ; for ( string i : word_list ) { if ( i . compare ( word ) == 0 ) {
word_list [ index ] = stars ; } index ++ ; }
for ( string i : word_list ) { result += i + ' ▁ ' ; } return result ; }
int main ( ) { string extract = " GeeksforGeeks ▁ is ▁ a ▁ computer ▁ science ▁ " " portal ▁ for ▁ geeks . ▁ I ▁ am ▁ pursuing ▁ my ▁ " " major ▁ in ▁ computer ▁ science . ▁ " ; string cen = " computer " ; cout << ( censor ( extract , cen ) ) ; }
string getTime ( string s , int n ) {
string res ;
int h = stoi ( s . substr ( 0 , 2 ) ) ;
int m = stoi ( s . substr ( 3 , 2 ) ) ;
int rev_h = ( h % 10 ) * 10 + ( ( h % 100 ) - ( h % 10 ) ) / 10 ;
string rev_hs = to_string ( rev_h ) ; if ( h == 23 && m >= 32 ) { res = " - 1" ; }
else if ( m < rev_h ) { string temp ;
if ( h < 10 ) temp = "0" ; temp = temp + to_string ( h ) ;
if ( rev_h < 10 ) res = res + temp + " : 0" + rev_hs ; else res = res + temp + " : " + rev_hs ; } else {
h ++ ;
rev_h = ( h % 10 ) * 10 + ( ( h % 100 ) - ( h % 10 ) ) / 10 ; rev_hs = to_string ( rev_h ) ; string temp ;
if ( h < 10 ) temp = "0" ; temp = temp + to_string ( h ) ;
if ( rev_h < 10 ) res = res + temp + " : 0" + rev_hs ; else res = res + temp + " : " + rev_hs ; } return res ; }
int main ( ) { string s = "21:12" ; int n = s . length ( ) ; cout << getTime ( s , n ) ; return 0 ; }
int CountSubstring ( char str [ ] , int n ) {
int ans = ( n * ( n + 1 ) ) / 2 ;
int a_index = 0 ; int b_index = 0 ; int c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( str [ i ] == ' a ' ) { a_index = i + 1 ; ans -= min ( b_index , c_index ) ; }
else if ( str [ i ] == ' b ' ) { b_index = i + 1 ; ans -= min ( a_index , c_index ) ; }
else { c_index = i + 1 ; ans -= min ( a_index , b_index ) ; } } return ans ; }
int main ( ) { char str [ ] = " babac " ; int n = strlen ( str ) ; cout << CountSubstring ( str , n ) ; return 0 ; }
bool isValid ( string str , int len ) {
for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; }
return true ; }
int main ( ) { string str = "0110" ; int len = str . length ( ) ; if ( isValid ( str , len ) ) cout << " Valid " ; else cout << " Invalid " ; return 0 ; }
int check ( string s , int K ) {
for ( int ch = 0 ; ch < 26 ; ch ++ ) { char c = ' a ' + ch ;
int last = -1 ;
bool found = true ; for ( int i = 0 ; i < K ; i ++ ) if ( s [ i ] == c ) last = i ;
if ( last == -1 ) continue ;
for ( int i = K ; i < s . size ( ) ; i ++ ) { if ( s [ i ] == c ) last = i ;
if ( last <= ( i - K ) ) { found = false ; break ; } }
if ( found ) return 1 ; } return 0 ; }
int binarySearch ( string s ) { int low = 1 , high = ( int ) s . size ( ) ; int ans ; while ( low <= high ) { int mid = ( high + low ) >> 1 ;
if ( check ( s , mid ) ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
int32_t main ( ) { string s = " abcde " ; cout << binarySearch ( s ) << endl ; s = " aaaa " ; cout << binarySearch ( s ) << endl ; return 0 ; }
const int seg [ 10 ] = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ;
string LedRequired ( string s , int led ) { int count = 0 ;
for ( int i = 0 ; i < s . length ( ) ; ++ i ) { count += seg [ int ( s [ i ] ) - 48 ] ; } if ( count <= led ) return " YES " ; else return " NO " ; }
int main ( ) { string S = "123456789" ; int led = 20 ;
cout << LedRequired ( S , led ) << endl ; return 0 ; }
int vowel_calc ( string s ) { int n = s . length ( ) ; vector < int > arr ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 )
arr . push_back ( n ) ; else
arr . push_back ( ( n - i ) + arr [ i - 1 ] - i ) ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ )
if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) sum += arr [ i ] ;
return sum ; }
int main ( ) { string s = " daceh " ; cout << vowel_calc ( s ) << endl ; return 0 ; }
bool ispalindrome ( int x ) { int ans = 0 ; int temp = x ; while ( temp > 0 ) { ans = 10 * ans + temp % 10 ; temp = temp / 10 ; } return ans == x ; }
int SuperPalindromes ( int L , int R ) {
int LIMIT = 100000 ; int ans = 0 ;
for ( int i = 0 ; i < LIMIT ; i ++ ) {
string s = to_string ( i ) ; string rs = s . substr ( 0 , s . size ( ) - 1 ) ; reverse ( rs . begin ( ) , rs . end ( ) ) ;
string p = s + rs ; int p_sq = pow ( stoi ( p ) , 2 ) ; if ( p_sq > R ) break ; if ( p_sq >= L and ispalindrome ( p_sq ) ) ans = ans + 1 ; }
for ( int i = 0 ; i < LIMIT ; i ++ ) {
string s = to_string ( i ) ; string rs = s ; reverse ( rs . begin ( ) , rs . end ( ) ) ;
string p = s + rs ; int p_sq = pow ( stoi ( p ) , 2 ) ; if ( p_sq > R ) break ; if ( p_sq >= L and ispalindrome ( p_sq ) ) ans = ans + 1 ; }
return ans ; }
int main ( ) { string L = "4" ; string R = "1000" ;
printf ( " % d STRNEWLINE " , SuperPalindromes ( stoi ( L ) , stoi ( R ) ) ) ; return 0 ; }
void solve ( string s , int k ) {
int count = 0 , length = 0 , pos = 0 ;
map < char , int > m ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) {
m [ s [ i ] ] ++ ; length ++ ;
if ( length > k ) {
m [ s [ pos ++ ] ] -- ; length -- ; }
if ( length == k && m [ s [ i ] ] == length ) count ++ ; }
cout << count << endl ; }
int main ( ) { string s = " aaaabbbccdddd " ; int k = 4 ; solve ( s , k ) ; return 0 ; }
string str = " A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks " ;
for ( int i = 0 ; i < str . length ( ) ; ++ i ) {
if ( str [ i ] == ' ▁ ' ) { str [ i ] = ' - ' ; } }
cout << str << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
bool solve ( string n , int l ) {
if ( l < 3 ) { if ( stoi ( n ) % 8 == 0 ) return true ;
reverse ( n . begin ( ) , n . end ( ) ) ; if ( stoi ( n ) % 8 == 0 ) return true ; return false ; }
int hash [ 10 ] = { 0 } ; for ( int i = 0 ; i < l ; i ++ ) hash [ n [ i ] - '0' ] ++ ;
for ( int i = 104 ; i < 1000 ; i += 8 ) { int dup = i ;
int freq [ 10 ] = { 0 } ; freq [ dup % 10 ] ++ ; dup = dup / 10 ; freq [ dup % 10 ] ++ ; dup = dup / 10 ; freq [ dup % 10 ] ++ ; dup = i ;
if ( freq [ dup % 10 ] > hash [ dup % 10 ] ) continue ; dup = dup / 10 ; if ( freq [ dup % 10 ] > hash [ dup % 10 ] ) continue ; dup = dup / 10 ; if ( freq [ dup % 10 ] > hash [ dup % 10 ] ) continue ; return true ; }
return false ; }
int main ( ) { string number = "31462708" ; int l = number . length ( ) ; if ( solve ( number , l ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
string newString ( string s , int k ) {
string X = " " ;
while ( s . length ( ) > 0 ) { char temp = s [ 0 ] ;
for ( long long i = 1 ; i < k and i < s . length ( ) ; i ++ ) { if ( s [ i ] < temp ) { temp = s [ i ] ; } }
X = X + temp ;
for ( long long i = 0 ; i < k ; i ++ ) { if ( s [ i ] == temp ) { s . erase ( s . begin ( ) + i ) ; break ; } } } return X ; }
int main ( ) { string s = " gaurang " ; int k = 3 ; cout << newString ( s , k ) ; }
void strToBinary ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i <= n ; i ++ ) {
int val = int ( s [ i ] ) ;
string bin = " " ; while ( val > 0 ) { ( val % 2 ) ? bin . push_back ( '1' ) : bin . push_back ( '0' ) ; val /= 2 ; } reverse ( bin . begin ( ) , bin . end ( ) ) ; cout << bin << " ▁ " ; } }
int main ( ) { string s = " geeks " ; strToBinary ( s ) ; return 0 ; }
string printSequence ( string arr [ ] , string input ) { string output = " " ;
int n = input . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) {
if ( input [ i ] == ' ▁ ' ) output = output + "0" ; else {
int position = input [ i ] - ' A ' ; output = output + arr [ position ] ; } }
return output ; }
string str [ ] = { "2" , "22" , "222" , "3" , "33" , "333" , "4" , "44" , "444" , "5" , "55" , "555" , "6" , "66" , "666" , "7" , "77" , "777" , "7777" , "8" , "88" , "888" , "9" , "99" , "999" , "9999" } ; string input = " GEEKSFORGEEKS " ; cout << printSequence ( str , input ) ; return 0 ; }
bool isEven ( string s ) { int l = s . length ( ) ;
bool dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) {
if ( s [ i ] == '0' && dotSeen == false ) continue ;
if ( s [ i ] == ' . ' ) { dotSeen = true ; continue ; }
if ( ( s [ i ] - '0' ) % 2 == 0 ) return true ; return false ; } }
int main ( ) { string s = "100.70" ; if ( isEven ( s ) ) cout << " Even " ; else cout << " Odd " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define NO_OF_CHARS  256
int max_distinct_char ( string str , int n ) {
int count [ NO_OF_CHARS ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] ] ++ ; int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] != 0 ) max_distinct ++ ; return max_distinct ; } int smallesteSubstr_maxDistictChar ( string str ) {
int n = str . size ( ) ;
int max_distinct = max_distinct_char ( str , n ) ;
int minl = n ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { string subs = str . substr ( i , j ) ; int subs_lenght = subs . size ( ) ; int sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ;
if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; }
string str = " AABBBCBB " ; int len = smallesteSubstr_maxDistictChar ( str ) ; cout << " ▁ The ▁ length ▁ of ▁ the ▁ smallest ▁ substring " " ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ " " characters ▁ : ▁ " << len ; return 0 ; }
int evaluateBoolExpr ( string s ) { int n = s . length ( ) ;
for ( int i = 0 ; i < n ; i += 2 ) {
if ( s [ i + 1 ] == ' A ' ) { if ( s [ i + 2 ] == '0' s [ i ] == '0' ) s [ i + 2 ] = '0' ; else s [ i + 2 ] = '1' ; }
else if ( s [ i + 1 ] == ' B ' ) { if ( s [ i + 2 ] == '1' s [ i ] == '1' ) s [ i + 2 ] = '1' ; else s [ i + 2 ] = '0' ; }
else { if ( s [ i + 2 ] == s [ i ] ) s [ i + 2 ] = '0' ; else s [ i + 2 ] = '1' ; } } return s [ n - 1 ] - '0' ; }
int main ( ) { string s = "1C1B1B0A0" ; cout << evaluateBoolExpr ( s ) ; return 0 ; }
int FirstRepeated ( string str ) {
int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ;
if ( ( checker & ( 1 << val ) ) > 0 ) return i ;
checker |= ( 1 << val ) ; } return -1 ; }
int main ( ) { string s = " abcfdeacf " ; int i = FirstRepeated ( s ) ; if ( i != -1 ) cout << " Char ▁ = ▁ " << s [ i ] << " ▁ and ▁ Index ▁ = ▁ " << i ; else cout << " No ▁ repeated ▁ Char " ; return 0 ; }
int evenNumSubstring ( char str [ ] ) { int len = strlen ( str ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ;
if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
int main ( ) { char str [ ] = "1234" ; cout << evenNumSubstring ( str ) << endl ; return 0 ; }
bool isSubSequence ( string str1 , string str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ;
for ( int i = 0 ; i < n && j < m ; i ++ ) if ( str1 [ j ] == str2 [ i ] ) j ++ ;
return ( j == m ) ; }
string findLongestString ( vector < string > dict , string str ) { string result = " " ; int length = 0 ;
for ( string word : dict ) {
if ( length < word . length ( ) && isSubSequence ( word , str ) ) { result = word ; length = word . length ( ) ; } }
return result ; }
int main ( ) { vector < string > dict = { " ale " , " apple " , " monkey " , " plea " } ; string str = " abpcplea " ; cout << findLongestString ( dict , str ) << endl ; return 0 ; }
bool isEditDistanceOne ( string s1 , string s2 ) {
int m = s1 . length ( ) , n = s2 . length ( ) ;
if ( abs ( m - n ) > 1 ) return false ;
int i = 0 , j = 0 ; while ( i < m && j < n ) {
if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ;
if ( m > n ) i ++ ; else if ( m < n ) j ++ ;
{ i ++ ; j ++ ; }
count ++ ; }
{ i ++ ; j ++ ; } }
if ( i < m j < n ) count ++ ; return count == 1 ; }
int main ( ) { string s1 = " gfg " ; string s2 = " gf " ; isEditDistanceOne ( s1 , s2 ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSubStr ( char str [ ] ) {
int res = 0 ;
for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == '1' ) {
for ( int j = i + 1 ; str [ j ] != ' \0' ; j ++ ) if ( str [ j ] == '1' ) res ++ ; } } return res ; }
int main ( ) { char str [ ] = "00100101" ; cout << countSubStr ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int exponentMod ( int A , int B , int C ) {
if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ;
long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; }
else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; }
int main ( ) { int A = 2 , B = 5 , C = 13 ; cout << " Power ▁ is ▁ " << exponentMod ( A , B , C ) ; return 0 ; }
int power ( long long x , unsigned int y , int p ) {
int res = 1 ;
x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; }
int main ( ) { int x = 2 ; int y = 5 ; int p = 13 ; cout << " Power ▁ is ▁ " << power ( x , y , p ) ; return 0 ; }
float trianglearea ( float a ) {
if ( a < 0 ) return -1 ;
float area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / 4 ; return area ; }
int main ( ) { float a = 6 ; cout << trianglearea ( a ) << endl ; return 0 ; }
void equation_ellipse ( float x1 , float y1 , float a , float b , float c , float e ) { float t = a * a + b * b ; float a1 = t - e * ( a * a ) ; float b1 = t - e * ( b * b ) ; float c1 = ( -2 * t * x1 ) - ( 2 * e * c * a ) ; float d1 = ( -2 * t * y1 ) - ( 2 * e * c * b ) ; float e1 = -2 * e * a * b ; float f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; cout << fixed ; cout << setprecision ( 2 ) ; cout << " Equation ▁ of ▁ ellipse ▁ is ▁ STRNEWLINE " << a1 << " ▁ x ^ 2 ▁ + ▁ " << b1 << " ▁ y ^ 2 ▁ + ▁ " << c1 << " ▁ x ▁ + ▁ " << d1 << " ▁ y ▁ + ▁ " << e1 << " ▁ xy ▁ + ▁ " << f1 << " ▁ = ▁ 0" ; }
int main ( ) { float x1 = 1 , y1 = 1 , a = 1 , b = -1 , c = 3 , e = 0.5 * 0.5 ; equation_ellipse ( x1 , y1 , a , b , c , e ) ; return 0 ; }
float circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; }
int main ( ) { int a = 4 ; cout << circle_inscribed ( a ) ; return 0 ; }
void findVolume ( db u , db v , db w , db U , db V , db W , db b ) {
db uPow = pow ( u , 2 ) ; db vPow = pow ( v , 2 ) ; db wPow = pow ( w , 2 ) ; db UPow = pow ( U , 2 ) ; db VPow = pow ( V , 2 ) ; db WPow = pow ( W , 2 ) ; db a = 4 * ( uPow * vPow * wPow ) - uPow * pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; db vol = sqrt ( a ) ; vol /= b ; cout << fixed << setprecision ( 4 ) << vol ; }
db u = 1000 , v = 1000 , w = 1000 ; db U = 3 , V = 4 , W = 5 ; db b = 12 ; findVolume ( u , v , w , U , V , W , b ) ; return 0 ; }
void makePolygon ( float a ) {
float n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) cout << " YES " ; else cout << " NO " ; }
int main ( ) { float a = 90 ;
makePolygon ( a ) ; return 0 ; }
int getQuadrant ( int X , int Y , int R , int PX , int PY ) {
if ( PX == X && PY == Y ) return 0 ; int val = pow ( ( PX - X ) , 2 ) + pow ( ( PY - Y ) , 2 ) ;
if ( val > pow ( R , 2 ) ) return -1 ;
if ( PX > X && PY >= Y ) return 1 ;
if ( PX <= X && PY > Y ) return 2 ;
if ( PX < X && PY <= Y ) return 3 ;
if ( PX >= X && PY < Y ) return 4 ; }
int X = 0 , Y = 3 ;
int R = 2 ;
int PX = 1 , PY = 4 ; int ans = getQuadrant ( X , Y , R , PX , PY ) ; if ( ans == -1 ) cout << " Lies ▁ Outside ▁ the ▁ circle " << endl ; else if ( ans == 0 ) cout << " Coincides ▁ with ▁ centre " << endl ; else cout << ans << " ▁ Quadrant " << endl ; return 0 ; }
int hexadecagonalNum ( long int n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; }
int main ( ) { long int n = 5 ; cout << n << " th ▁ Hexadecagonal ▁ number ▁ : ▁ " ; cout << hexadecagonalNum ( n ) ; cout << endl ; n = 9 ; cout << n << " th ▁ Hexadecagonal ▁ number ▁ : ▁ " ; cout << hexadecagonalNum ( n ) ; return 0 ; }
int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; }
int main ( ) { int diameter = 5 ; int height = 10 ; cout << " Perimeter ▁ = ▁ " ; cout << perimeter ( diameter , height ) ; cout << " ▁ units STRNEWLINE " ; return 0 ; }
int ax = 5 , ay = 0 ;
int bx = 1 , by = 1 ;
int cx = 2 , cy = 5 ; cout << ax + bx - cx << " , ▁ " << ay + by - cy << endl ; cout << ax + cx - bx << " , ▁ " << ay + cy - by << endl ; cout << cx + bx - ax << " , ▁ " << cy + by - ax << endl ; return 0 ; }
float area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; }
bool check ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 , int x , int y ) {
float A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ;
float A1 = area ( x , y , x1 , y1 , x2 , y2 ) ;
float A2 = area ( x , y , x2 , y2 , x3 , y3 ) ;
float A3 = area ( x , y , x3 , y3 , x4 , y4 ) ;
float A4 = area ( x , y , x1 , y1 , x4 , y4 ) ;
return ( A == A1 + A2 + A3 + A4 ) ; }
if ( check ( 0 , 10 , 10 , 0 , 0 , -10 , -10 , 0 , 10 , 15 ) ) cout << " yes " ; else cout << " no " ; return 0 ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
int main ( ) { cout << findMaximumPieces ( 3 ) ; return 0 ; }
int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) {
int mat [ 2 ] [ W + 1 ] ; memset ( mat , 0 , sizeof ( mat ) ) ;
int i = 0 ;
while ( i < n ) {
int j = 0 ;
if ( i % 2 != 0 ) {
while ( ++ j <= W ) {
if ( wt [ i ] <= j ) mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ;
else mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } }
else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; else mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } i ++ ; }
return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; }
int main ( ) { int val [ ] = { 7 + D2 : N7 , 8 , 4 } , wt [ ] = { 3 , 8 , 6 } , W = 10 , n = 3 ; cout << KnapSack ( val , wt , n , W ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
void findNumbers ( int arr [ ] , int n ) {
sort ( arr , arr + n , greater < int > ( ) ) ; int freq [ arr [ 0 ] + 1 ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ;
int size = sqrt ( n ) ; int brr [ size ] = { 0 } , x , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] ] > 0 ) {
brr [ l ] = arr [ i ] ;
freq [ brr [ l ] ] -- ; l ++ ; for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) {
x = __gcd ( arr [ i ] , brr [ j ] ) ;
freq [ x ] -= 2 ; } } } } printArr ( brr , size ) ; }
int main ( ) { int arr [ ] = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5 , 5 , 5 , 7 , 10 , 12 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findNumbers ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void AlternateRearrange ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . push_back ( arr [ i ] ) ; else v2 . push_back ( arr [ i ] ) ; int index = 0 , i = 0 , j = 0 ; bool flag = false ;
if ( arr [ 0 ] % 2 == 0 ) flag = true ;
while ( index < n ) {
if ( flag == true ) { arr [ index ++ ] = v1 [ i ++ ] ; flag = ! flag ; }
else { arr [ index ++ ] = v2 [ j ++ ] ; flag = ! flag ; } }
for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 9 , 8 , 13 , 2 , 19 , 14 } ; int n = sizeof ( arr ) / sizeof ( int ) ; AlternateRearrange ( arr , n ) ; return 0 ; }
int getNumToAdd ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int d = arr [ 1 ] - arr [ 0 ] ; int numToAdd = -1 ; bool numAdded = false ; for ( int i = 2 ; i < n ; i ++ ) { int diff = arr [ i ] - arr [ i - 1 ] ;
if ( diff != d ) {
if ( numAdded ) return -1 ;
if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ;
numAdded = true ; }
else return -1 ; } }
if ( numToAdd == -1 ) return ( arr [ n - 1 ] + d ) ;
return numToAdd ; }
int main ( ) { int arr [ ] = { 1 , 3 , 5 , 7 , 11 , 13 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getNumToAdd ( arr , n ) ; }
int items ( int n , int a [ ] ) {
sort ( a , a + n ) ;
int z = a [ n - 1 ] ;
int x = 1 ;
int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ;
if ( s <= z ) x += 1 ; else break ; } return x ; }
int main ( ) { int n = 5 ; int a [ ] = { 5 , 3 , 1 , 5 , 6 } ; cout << items ( n , a ) ; }
int numBoxes ( int A [ ] , int n , int K ) {
sort ( A , A + n ) ;
int i = 0 , j = n - 1 ; int ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; }
int main ( ) { int A [ ] = { 3 , 2 , 2 , 1 } , K = 3 ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << numBoxes ( A , n , K ) ; return 0 ; }
int solve ( int N , int M , int cp [ ] , int sp [ ] ) { int profit [ N ] ;
for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ;
sort ( profit , profit + N , greater < int > ( ) ) ;
int sum = 0 ;
for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; }
int main ( ) { int N = 5 , M = 3 ; int CP [ ] = { 5 , 10 , 35 , 7 , 23 } ; int SP [ ] = { 11 , 10 , 0 , 9 , 19 } ; cout << solve ( N , M , CP , SP ) ; return 0 ; }
int findMaxNum ( int arr [ ] , int n ) {
sort ( arr , arr + n , greater < int > ( ) ) ; int num = arr [ 0 ] ;
for ( int i = 1 ; i < n ; i ++ ) { num = num * 10 + arr [ i ] ; } return num ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxNum ( arr , n ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int minimumSets ( int arr [ ] , int n , int key ) { int i , j ;
sort ( arr , arr + n ) ;
for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ;
return i ; }
int main ( ) { int arr [ ] = { 3 , 5 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int key = 5 ; cout << minimumSets ( arr , n , key ) ; return 0 ; }
int minimumBox ( int arr [ ] , int n ) { queue < int > q ;
queue < int > q ;
sort ( arr , arr + n ) ; q . push ( arr [ 0 ] ) ;
for ( int i = 1 ; i < n ; i ++ ) { int now = q . front ( ) ;
if ( arr [ i ] >= 2 * now ) q . pop ( ) ;
q . push ( arr [ i ] ) ; } return q . size ( ) ; }
int main ( ) { int arr [ ] = { 4 , 1 , 2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumBox ( arr , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void sortBinaryArray ( int a [ ] , int n ) { int j = -1 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] < 1 ) { j ++ ; swap ( a [ i ] , a [ j ] ) ; } } }
int main ( ) { int a [ ] = { 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; sortBinaryArray ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; return 0 ; }
int function findDuplicate ( $ arr , $ n , $ k ) {
int res = MAX + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) {
int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) count += 1 ;
if ( count == k ) res = min ( res , arr [ i ] ) ; } } return res ; }
int main ( ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = sizeof ( arr ) / ( sizeof ( arr [ 0 ] ) ) ; cout << findDuplicate ( arr , n , k ) ; return 0 ; }
sort ( arr , arr + n ) ;
int i = 0 ; while ( i < n ) { int j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return -1 ; }
int main ( ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = sizeof ( arr ) / ( sizeof ( arr [ 0 ] ) ) ; cout << findDuplicate ( arr , n , k ) ; return 0 ; }
bool checkForSorting ( int arr [ ] , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) {
if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) swap ( arr [ i ] , arr [ i + 1 ] ) ;
else return false ; } } return true ; }
int main ( ) { int arr [ ] = { 1 , 0 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkForSorting ( arr , n ) ) cout << " Yes " ; else cout << " No " ; }
int ksmallest ( int arr [ ] , int n , int k ) {
sort ( arr , arr + n ) ;
if ( k < arr [ 0 ] ) return k ;
if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ;
if ( k > arr [ n - 1 ] ) return k + n ;
if ( arr [ 0 ] == 1 ) k -- ;
else k -= ( arr [ 0 ] - 1 ) ;
for ( int i = 1 ; i < n ; i ++ ) {
int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; }
int main ( ) { int k = 1 ; int arr [ ] = { 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ksmallest ( arr , n , k ) ; return 0 ; }
bool isEven ( int n ) {
return ( ! ( n & 1 ) ) ; }
int main ( ) { int n = 101 ; isEven ( n ) ? cout << " Even " : cout << " Odd " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findSubsequenceCount ( string S , string T ) { int m = T . length ( ) , n = S . length ( ) ;
if ( m > n ) return 0 ;
int mat [ m + 1 ] [ n + 1 ] ;
for ( int i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ;
for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ;
for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) {
if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ;
else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } }
return mat [ m ] [ n ] ; }
int main ( ) { string T = " ge " ; string S = " geeksforgeeks " ; cout << findSubsequenceCount ( S , T ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string Check ( int a [ ] [ 2 ] , int b [ ] [ 2 ] , int n , int m ) {
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( a [ i ] [ j ] > b [ i ] [ j ] ) swap ( a [ i ] [ j ] , b [ i ] [ j ] ) ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m - 1 ; j ++ ) if ( a [ i ] [ j ] >= a [ i ] [ j + 1 ] b [ i ] [ j ] >= b [ i ] [ j + 1 ] ) return " No " ;
for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( a [ i ] [ j ] >= a [ i + 1 ] [ j ] b [ i ] [ j ] >= b [ i + 1 ] [ j ] ) return " No " ; return " Yes " ; }
int main ( ) { int n = 2 , m = 2 ; int a [ ] [ 2 ] = { { 2 , 10 } , { 11 , 5 } } ; int b [ ] [ 2 ] = { { 9 , 4 } , { 3 , 12 } } ; cout << ( Check ( a , b , n , m ) ) ; }
string smallestString ( int N , int A [ ] ) {
char ch = ' a ' ;
string S = " " ;
if ( N < 1 A [ 0 ] != 1 ) { S = " - 1" ; return S ; } S += ch ; ch ++ ;
for ( int i = 1 ; i < N ; i ++ ) { int diff = A [ i ] - A [ i - 1 ] ;
if ( diff > 1 diff < 0 A [ i ] > 26 ) { S = " - 1" ; return S ; }
else if ( diff == 0 ) S += ' a ' ;
else { S += ch ; ch ++ ; } }
return S ; }
int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << smallestString ( n , arr ) ; return 0 ; }
bool canBePicked ( int digits [ ] , int num ) { int copyDigits [ 10 ] ;
for ( int i = 0 ; i < 10 ; i ++ ) copyDigits [ i ] = digits [ i ] ; while ( num > 0 ) {
int digit = num % 10 ;
if ( copyDigits [ digit ] == 0 ) return false ;
else copyDigits [ digit ] -= 1 ;
num = floor ( num / 10 ) ; } return true ; }
int countAlphabets ( long n ) { int count = 0 ;
int digits [ 10 ] = { 0 } ; while ( n > 0 ) {
int digit = n % 10 ;
digits [ digit ] += 1 ;
n = floor ( n / 10 ) ; }
for ( int i = 97 ; i <= 122 ; i ++ ) if ( canBePicked ( digits , i ) ) count += 1 ;
for ( int i = 65 ; i < 91 ; i ++ ) if ( canBePicked ( digits , i ) ) count += 1 ;
return count ; }
int main ( ) { long n = 1623455078 ; cout << ( countAlphabets ( n ) ) ; }
void findTwoNumbers ( int sum , int gcd ) {
if ( __gcd ( gcd , sum - gcd ) == gcd && sum != gcd ) cout << " a ▁ = ▁ " << min ( gcd , sum - gcd ) << " , ▁ b ▁ = ▁ " << sum - min ( gcd , sum - gcd ) << endl ; else cout << -1 << endl ; }
int main ( ) { int sum = 8 ; int gcd = 2 ; findTwoNumbers ( sum , gcd ) ; return 0 ; }
int findMaxDistance ( int numOfCities , int station [ ] , int n ) {
bool hasStation [ numOfCities + 1 ] = { false } ;
for ( int city = 0 ; city < n ; city ++ ) { hasStation [ station [ city ] ] = true ; } int dist = 0 ; int maxDist = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { maxDist = min ( station [ i ] , maxDist ) ; } for ( int city = 0 ; city < numOfCities ; city ++ ) { if ( hasStation [ city ] == true ) { maxDist = max ( ( dist + 1 ) / 2 , maxDist ) ; dist = 0 ; } else dist += 1 ; } return max ( maxDist , dist ) ; }
int main ( ) { int numOfCities = 6 ; int station [ ] = { 3 , 1 } ; int n = sizeof ( station ) / sizeof ( station [ 0 ] ) ; cout << " Max ▁ Distance : " << findMaxDistance ( numOfCities , station , n ) ; }
void split ( int x , int n ) {
if ( x < n ) cout << " - 1" << " ▁ " ;
else if ( x % n == 0 ) { for ( int i = 0 ; i < n ; i ++ ) cout << ( x / n ) << " ▁ " ; } else {
int zp = n - ( x % n ) ; int pp = x / n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i >= zp ) cout << ( pp + 1 ) << " ▁ " ; else cout << pp << " ▁ " ; } } }
int main ( ) { int x = 5 ; int n = 3 ; split ( x , n ) ; }
long cal_minimum_time ( long X ) {
long t = 0 ; long sum = 0 ; while ( sum < X ) {
t ++ ;
sum = sum + t ; } return t ; }
int main ( ) { long n = 6 ; long ans = cal_minimum_time ( n ) ; cout << " The ▁ minimum ▁ time ▁ required ▁ is ▁ : ▁ " << ans ; return 0 ; }
int solve ( pair < int , int > v [ ] , int n ) {
int ans , ul , ll ;
ll = v [ 0 ] . first ; ul = v [ 0 ] . second ;
ans = 0 ;
for ( int i = 1 ; i < n ; i ++ ) {
if ( ( v [ i ] . first <= ul && v [ i ] . first >= ll ) || ( v [ i ] . second >= ll && v [ i ] . second <= ul ) ) {
if ( v [ i ] . first > ll ) { ll = v [ i ] . first ; } if ( v [ i ] . second < ul ) { ul = v [ i ] . second ; } }
else if ( v [ i ] . first > ul ) {
ans += abs ( ul - v [ i ] . first ) ; ul = v [ i ] . first ; ll = v [ i ] . first ; }
else if ( v [ i ] . second < ll ) {
ans += abs ( ll - v [ i ] . second ) ; ul = v [ i ] . second ; ll = v [ i ] . second ; } } return ans ; }
pair < int , int > v [ ] = { { 1 , 3 } , { 2 , 5 } , { 6 , 8 } , { 1 , 2 } , { 2 , 3 } } ; int n = sizeof ( v ) / sizeof ( v [ 0 ] ) ; cout << solve ( v , n ) << endl ; return 0 ; }
vector < string > preProcess ( long long int n ) { vector < string > preProcessedCubes ; for ( int i = 1 ; i * i * i <= n ; i ++ ) { long long int iThCube = i * i * i ;
string cubeString = to_string ( iThCube ) ; preProcessedCubes . push_back ( cubeString ) ; } return preProcessedCubes ; }
string findLargestCubeUtil ( string num , vector < string > preProcessedCubes ) {
reverse ( preProcessedCubes . begin ( ) , preProcessedCubes . end ( ) ) ; int totalCubes = preProcessedCubes . size ( ) ;
for ( int i = 0 ; i < totalCubes ; i ++ ) { string currCube = preProcessedCubes [ i ] ; int digitsInCube = currCube . length ( ) ; int index = 0 ; int digitsInNumber = num . length ( ) ; for ( int j = 0 ; j < digitsInNumber ; j ++ ) {
if ( num [ j ] == currCube [ index ] ) index ++ ; if ( digitsInCube == index ) return currCube ; } }
return " Not ▁ Possible " ; }
void findLargestCube ( long long int n ) {
vector < string > preProcessedCubes = preProcess ( n ) ;
string num = to_string ( n ) ; string ans = findLargestCubeUtil ( num , preProcessedCubes ) ; cout << " Largest ▁ Cube ▁ that ▁ can ▁ be ▁ formed ▁ from ▁ " << n << " ▁ is ▁ " << ans << endl ; }
int main ( ) { long long int n ; n = 4125 ; findLargestCube ( n ) ; n = 876 ; findLargestCube ( n ) ; return 0 ; }
string noAdjacentDup ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) {
if ( s [ i ] == s [ i - 1 ] ) {
s [ i ] = ' a ' ;
while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return s ; }
int main ( ) { string s = " geeksforgeeks " ; cout << noAdjacentDup ( s ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int winner ( int a [ ] , int n , int k ) {
if ( k >= n - 1 ) return n ;
int best = 0 , times = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] > best ) {
best = a [ i ] ;
if ( i )
} else
if ( times >= k ) return best ; }
return best ; }
int main ( ) { int a [ ] = { 2 , 1 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 2 ; cout << winner ( a , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100000 NEW_LINE #define bitscount  32 NEW_LINE using namespace std ;
int prefix_count [ bitscount ] [ MAX ] ;
void findPrefixCount ( int arr [ ] , int n ) {
for ( int i = 0 ; i < bitscount ; i ++ ) {
prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] ; } } }
int rangeOr ( int l , int r ) {
int ans = 0 ;
for ( int i = 0 ; i < bitscount ; i ++ ) {
int x ; if ( l == 0 ) x = prefix_count [ i ] [ r ] ; else x = prefix_count [ i ] [ r ] - prefix_count [ i ] [ l - 1 ] ;
if ( x != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; }
int main ( ) { int arr [ ] = { 7 , 5 , 3 , 5 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; findPrefixCount ( arr , n ) ; int queries [ ] [ 2 ] = { { 1 , 3 } , { 4 , 5 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) cout << rangeOr ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) << endl ; return 0 ; }
void BellmanFord ( int graph [ ] [ 3 ] , int V , int E , int src ) {
int dis [ V ] ; for ( int i = 0 ; i < V ; i ++ ) dis [ i ] = INT_MAX ;
dis [ src ] = 0 ;
for ( int i = 0 ; i < V - 1 ; i ++ ) { for ( int j = 0 ; j < E ; j ++ ) { if ( dis [ graph [ j ] [ 0 ] ] != INT_MAX && dis [ graph [ j ] [ 0 ] ] + graph [ j ] [ 2 ] < dis [ graph [ j ] [ 1 ] ] ) dis [ graph [ j ] [ 1 ] ] = dis [ graph [ j ] [ 0 ] ] + graph [ j ] [ 2 ] ; } }
for ( int i = 0 ; i < E ; i ++ ) { int x = graph [ i ] [ 0 ] ; int y = graph [ i ] [ 1 ] ; int weight = graph [ i ] [ 2 ] ; if ( dis [ x ] != INT_MAX && dis [ x ] + weight < dis [ y ] ) cout << " Graph ▁ contains ▁ negative " " ▁ weight ▁ cycle " << endl ; } cout << " Vertex ▁ Distance ▁ from ▁ Source " << endl ; for ( int i = 0 ; i < V ; i ++ ) cout << i << " TABSYMBOL TABSYMBOL " << dis [ i ] << endl ; }
int graph [ ] [ 3 ] = { { 0 , 1 , -1 } , { 0 , 2 , 4 } , { 1 , 2 , 3 } , { 1 , 3 , 2 } , { 1 , 4 , 2 } , { 3 , 2 , 5 } , { 3 , 1 , 1 } , { 4 , 3 , -3 } } ; BellmanFord ( graph , V , E , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int maxn = 16 ;
vector < int > precompute ( ) { vector < int > dp ( maxn , -1 ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < maxn ; ++ i ) {
for ( auto j : vector < int > { 4 , 6 , 9 } ) {
if ( i >= j && dp [ i - j ] != -1 ) { dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } } return dp ; }
int Maximum_Summands ( vector < int > dp , int n ) {
if ( n < maxn ) return dp [ n ] ; else {
int t = ( n - maxn ) / 4 + 1 ; return t + dp [ n - 4 * t ] ; } }
int main ( ) { int n = 12 ;
vector < int > dp = precompute ( ) ; cout << Maximum_Summands ( dp , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE #define N  4
int getSum ( int r1 , int r2 , int c1 , int c2 , int dp [ N + 1 ] [ N + 1 ] ) { return dp [ r2 ] [ c2 ] - dp [ r2 ] [ c1 ] - dp [ r1 ] [ c2 ] + dp [ r1 ] [ c1 ] ; }
bool sumFound ( int K , int S , int grid [ N ] [ N ] ) {
int dp [ N + 1 ] [ N + 1 ] ;
for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] - dp [ i ] [ j ] + grid [ i ] [ j ] ;
for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) { int sum = getSum ( i , i + K , j , j + K , dp ) ; if ( sum == S ) return true ; }
return false ; }
int main ( ) { int grid [ N ] [ N ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int K = 2 ; int S = 14 ;
if ( sumFound ( K , S , grid ) ) cout << " Yes " << endl ; else cout << " No " << endl ; }
int findMinOperations ( string S ) {
reverse ( S . begin ( ) , S . end ( ) ) ; int n = S . length ( ) ;
int dp [ n + 1 ] [ 2 ] ;
if ( S [ 0 ] == '0' ) { dp [ 0 ] [ 0 ] = 0 ; } else {
dp [ 0 ] [ 0 ] = 1 ; }
dp [ 0 ] [ 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ i ] == '0' ) {
dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ;
dp [ i ] [ 1 ] = 1 + min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] ) ; } else {
dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ;
dp [ i ] [ 0 ] = 1 + min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; } } return dp [ n - 1 ] [ 0 ] ; }
int main ( ) { string S = "100" ; cout << findMinOperations ( S ) << endl ; S = "111" ; cout << findMinOperations ( S ) << endl ; return 0 ; }
void solve ( int N , int K ) { vector < long long int > Array ( N + 1 , 0 ) ;
if ( N <= K ) { cout << "1" << endl ; return ; } long long int i = 0 , sum = K ;
for ( i = 1 ; i <= K ; ++ i ) { Array [ i ] = 1 ; }
Array [ i ] = sum ;
for ( int i = K + 2 ; i <= N ; ++ i ) {
Array [ i ] = sum - Array [ i - K - 1 ] + Array [ i - 1 ] ;
sum = Array [ i ] ; } cout << Array [ N ] << endl ; }
int main ( ) { long long int N = 4 , K = 2 ;
solve ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_VAL  10000000
int dp [ 100 ] [ 100 ] ;
int find ( int index , int openbrk , int n , int adj [ ] [ 2 ] ) {
if ( openbrk < 0 ) return MAX_VAL ;
if ( index == n ) {
if ( openbrk == 0 ) { return 0 ; }
return MAX_VAL ; }
if ( dp [ index ] [ openbrk ] != -1 ) return dp [ index ] [ openbrk ] ;
dp [ index ] [ openbrk ] = min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; }
int main ( ) { int n = 4 ; int adj [ n ] [ 2 ] = { { 5000 , 3000 } , { 6000 , 2000 } , { 8000 , 1000 } , { 9000 , 6000 } } ; memset ( dp , -1 , sizeof ( dp ) ) ; cout << find ( 1 , 1 , n , adj ) + adj [ 0 ] [ 1 ] << endl ; return 0 ; }
int find ( int start , string adj , int n , int dp [ ] ) {
if ( start == n ) return 0 ;
if ( dp [ start ] != -1 ) return dp [ start ] ; dp [ start ] = 0 ; int one = 0 , zero = 0 , k ;
for ( k = start ; k < n ; k ++ ) {
if ( adj [ k ] == '1' ) one ++ ; else zero ++ ;
if ( one > zero ) dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ;
else dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; }
return dp [ start ] ; }
int main ( ) { string adj = "100110001010001" ;
int n = adj . size ( ) ; int dp [ n + 1 ] ; memset ( dp , -1 , sizeof ( dp ) ) ;
cout << find ( 0 , adj , n , dp ) << endl ; return 0 ; }
bool isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; return false ; }
int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; int i , j ;
for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( ( X [ i - 1 ] == Y [ j - 1 ] ) && isVowel ( X [ i - 1 ] ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } }
return L [ m ] [ n ] ; }
int main ( ) { char X [ ] = " aieef " ; char Y [ ] = " klaief " ; int m = strlen ( X ) ; int n = strlen ( Y ) ; cout << " Length ▁ of ▁ LCS ▁ = ▁ " << lcs ( X , Y , m , n ) ; return 0 ; }
bool check ( int i , int val ) { if ( i - val < 0 ) return false ; return true ; }
int MinimumPrimes ( int n ) { int dp [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 1e9 ; dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( check ( i , 2 ) ) dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 2 ] ) ; if ( check ( i , 3 ) ) dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 3 ] ) ; if ( check ( i , 5 ) ) dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 5 ] ) ; if ( check ( i , 7 ) ) dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 7 ] ) ; }
if ( dp [ n ] == ( 1e9 ) ) return -1 ; else return dp [ n ] ; }
int main ( ) { int n = 12 ; int minimal = MinimumPrimes ( n ) ; if ( minimal != -1 ) cout << " Minimum ▁ number ▁ of ▁ single " << " ▁ digit ▁ primes ▁ required ▁ : ▁ " << minimal << endl ; else cout << " Not ▁ possible " ; return 0 ; }
int numberOfBST ( int n ) {
int dp [ n + 1 ] ; fill_n ( dp , n + 1 , 0 ) ;
dp [ 0 ] = 1 ; dp [ 1 ] = 1 ;
for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) {
dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) ; } } return dp [ n ] ; }
int main ( ) { int n = 3 ; cout << " Number ▁ of ▁ structurally ▁ Unique ▁ BST ▁ with ▁ " << n << " ▁ keys ▁ are ▁ : ▁ " << numberOfBST ( n ) << " STRNEWLINE " ; return 0 ; }
int summation ( int n ) { return n << ( n - 1 ) ; }
int main ( ) { int n = 2 ; cout << summation ( n ) << endl ; return 0 ; }
int findMaxProduct ( int arr [ ] , int n ) { int i ;
int ans = INT_MIN ;
int maxval = 1 ;
int minval = 1 ;
int prevMax ; for ( i = 0 ; i < n ; i ++ ) {
if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; minval = min ( 1 , minval * arr [ i ] ) ; }
else if ( arr [ i ] == 0 ) { minval = 1 ; maxval = 0 ; }
else if ( arr [ i ] < 0 ) { prevMax = maxval ; maxval = minval * arr [ i ] ; minval = prevMax * arr [ i ] ; }
ans = max ( ans , maxval ) ;
if ( maxval <= 0 ) { maxval = 1 ; } } return ans ; }
int main ( ) { int arr [ ] = { 0 , -4 , 0 , -2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxProduct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INF  1e9 NEW_LINE #define MAX  50 NEW_LINE int minMaxValues ( int arr [ ] , int n , int m ) {
int sum = 0 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ;
arr [ i ] += 50 ; }
bool dp [ MAX + 1 ] [ MAX * MAX + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ 0 ] = 1 ;
for ( int i = 0 ; i < ( n + m ) ; i ++ ) {
for ( int k = min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = 1 ; } } } int max_value = - INF , min_value = INF ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) {
if ( dp [ n ] [ i ] ) {
int temp = i - 50 * n ; max_value = max ( max_value , temp * ( sum - temp ) ) ; min_value = min ( min_value , temp * ( sum - temp ) ) ; } } cout << " Maximum ▁ Value : ▁ " << max_value << " STRNEWLINE " << " Minimum ▁ Value : ▁ " << min_value << endl ; }
int main ( ) { int n = 2 , m = 2 ; int arr [ ] = { 1 , 2 , 3 , 4 } ; minMaxValues ( arr , n , m ) ; return 0 ; }
int findGolomb ( int n ) {
if ( n == 1 ) return 1 ;
return 1 + findGolomb ( n - findGolomb ( findGolomb ( n - 1 ) ) ) ; }
void printGolomb ( int n ) {
for ( int i = 1 ; i <= n ; i ++ ) cout << findGolomb ( i ) << " ▁ " ; }
int main ( ) { int n = 9 ; printGolomb ( n ) ; return 0 ; }
void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ;
for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } }
int res = K [ n ] [ W ] ; cout << res << endl ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) {
if ( res == K [ i - 1 ] [ w ] ) continue ; else {
cout << " ▁ " << wt [ i - 1 ] ;
res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } }
int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; printknapSack ( W , wt , val , n ) ; return 0 ; }
int maximumSegments ( int n , int a , int b , int c ) {
int dp [ n + 1 ] ;
memset ( dp , -1 , sizeof ( dp ) ) ;
dp [ 0 ] = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != -1 ) {
dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) ;
dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) ;
dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; }
int main ( ) { int n = 7 , a = 5 , b = 2 , c = 5 ; cout << maximumSegments ( n , a , b , c ) ; return 0 ; }
void sequence ( int n ) {
int f [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; cout << f [ 1 ] << " ▁ " << f [ 2 ] << " ▁ " ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; cout << f [ i ] << " ▁ " ; } }
int main ( ) { int n = 13 ; sequence ( n ) ; return 0 ; }
int zigzag ( int n , int k ) { int dp [ n + 1 ] [ k + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ;
dp [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; return dp [ n ] [ k ] ; }
int main ( ) { int n = 4 , k = 3 ; cout << zigzag ( n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAXN  109 NEW_LINE using namespace std ;
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ;
for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= min ( i , k ) ; j ++ ) {
if ( j == 0 j == i ) C [ i ] [ j ] = 1 ;
else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int lobb ( int n , int m ) { return ( ( 2 * m + 1 ) * binomialCoeff ( 2 * n , m + n ) ) / ( m + n + 1 ) ; }
int main ( ) { int n = 5 , m = 3 ; cout << lobb ( n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAXN  109 NEW_LINE using namespace std ;
int countarray ( int n , int k , int x ) { int dp [ MAXN ] = { 0 } ;
dp [ 0 ] = 0 ; dp [ 1 ] = 1 ;
for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; }
int main ( ) { int n = 4 , k = 3 , x = 2 ; cout << countarray ( n , k , x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE #define MAX_CHAR  26 NEW_LINE using namespace std ;
void precompute ( string s , int n , int l [ ] [ MAX ] , int r [ ] [ MAX ] ) { l [ s [ 0 ] - ' a ' ] [ 0 ] = 1 ;
for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) l [ j ] [ i ] += l [ j ] [ i - 1 ] ; l [ s [ i ] - ' a ' ] [ i ] ++ ; } r [ s [ n - 1 ] - ' a ' ] [ n - 1 ] = 1 ;
for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) r [ j ] [ i ] += r [ j ] [ i + 1 ] ; r [ s [ i ] - ' a ' ] [ i ] ++ ; } }
int countPalindromes ( int k , int n , int l [ ] [ MAX ] , int r [ ] [ MAX ] ) { int ans = 0 ;
if ( k == 1 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += l [ i ] [ n - 1 ] ; return ans ; }
if ( k == 2 ) {
for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += ( ( l [ i ] [ n - 1 ] * ( l [ i ] [ n - 1 ] - 1 ) ) / 2 ) ; return ans ; }
for ( int i = 1 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < MAX_CHAR ; j ++ ) ans += l [ j ] [ i - 1 ] * r [ j ] [ i + 1 ] ; return ans ; }
int main ( ) { string s = " aabab " ; int k = 2 ; int n = s . length ( ) ; int l [ MAX_CHAR ] [ MAX ] = { 0 } , r [ MAX_CHAR ] [ MAX ] = { 0 } ; precompute ( s , n , l , r ) ; cout << countPalindromes ( k , n , l , r ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  10
int maxSum ( int mat [ SIZE ] [ SIZE ] , int n ) {
if ( n == 1 ) return mat [ 0 ] [ 0 ] ;
int dp [ n ] [ n ] ; int maxSum = INT_MIN , max ;
for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ;
for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = INT_MIN ;
if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ;
dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } }
for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ;
return maxSum ; }
int main ( ) { int mat [ SIZE ] [ SIZE ] = { { 5 , 6 , 1 , 7 } , { -2 , 10 , 8 , -1 } , { 3 , -7 , -9 , 11 } , { 12 , -4 , 2 , 6 } } ; int n = 4 ; cout << " Maximum ▁ Sum ▁ = ▁ " << maxSum ( mat , n ) ; return 0 ; }
string longestRepeatedSubSeq ( string str ) {
int n = str . length ( ) ; int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ;
string res = " " ;
int i = n , j = n ; while ( i > 0 && j > 0 ) {
if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str [ i - 1 ] ; i -- ; j -- ; }
else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; }
reverse ( res . begin ( ) , res . end ( ) ) ; return res ; }
int main ( ) { string str = " AABEBCDD " ; cout << longestRepeatedSubSeq ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
bool ElementsCalculationFunc ( int pre [ ] , int maxx [ ] , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) {
if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; } void MaxNumberOfElements ( int a [ ] , int n , int k ) {
sort ( a , a + n ) ;
for ( int i = 0 ; i <= n ; ++ i ) { pre [ i ] = 0 ; maxx [ i ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) {
pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] ;
maxx [ i ] = max ( maxx [ i - 1 ] , a [ i - 1 ] ) ; }
int l = 1 , r = n , ans ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( ElementsCalculationFunc ( pre , maxx , mid - 1 , k , n ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; }
cout << ans << " STRNEWLINE " ; } int main ( ) { int arr [ ] = { 2 , 4 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; MaxNumberOfElements ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  50 NEW_LINE using namespace std ; int solve ( int dp [ ] [ MAX ] , int a [ ] , int low , int high , int turn ) {
if ( low == high ) return a [ low ] * turn ;
if ( dp [ low ] [ high ] != 0 ) return dp [ low ] [ high ] ;
dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; }
int main ( ) { int arr [ ] = { 1 , 3 , 1 , 5 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int dp [ MAX ] [ MAX ] ; memset ( dp , 0 , sizeof ( dp ) ) ; cout << solve ( dp , arr , 0 , n - 1 , 1 ) << endl ; return 0 ; }
int maxSumBitonicSubArr ( int arr [ ] , int n ) {
int msis [ n ] , msds [ n ] ;
int max_sum = INT_MIN ;
msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ;
msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ;
for ( int i = 0 ; i < n ; i ++ )
if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ;
return max_sum ; }
int main ( ) { int arr [ ] = { 5 , 3 , 9 , 2 , 7 , 6 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ Sum ▁ = ▁ " << maxSumBitonicSubArr ( arr , n ) ; return 0 ; }
int countWays ( int n , int m ) {
int count [ n + 1 ] ; count [ 0 ] = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) {
if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ;
else if ( i < m i == 1 ) count [ i ] = 1 ;
else count [ i ] = 2 ; }
return count [ n ] ; }
int main ( ) { int n = 7 , m = 4 ; cout << " Number ▁ of ▁ ways ▁ = ▁ " << countWays ( n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ;
int largestZigZagSumRec ( int mat [ ] [ MAX ] , int i , int j , int n ) {
if ( i == n - 1 ) return mat [ i ] [ j ] ;
int zzs = 0 ; for ( int k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return zzs + mat [ i ] [ j ] ; }
int largestZigZag ( int mat [ ] [ MAX ] , int n ) {
int res = 0 ; for ( int j = 0 ; j < n ; j ++ ) res = max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; }
int main ( ) { int n = 3 ; int mat [ ] [ MAX ] = { { 4 , 2 , 1 } , { 3 , 9 , 6 } , { 11 , 3 , 15 } } ; cout << " Largest ▁ zigzag ▁ sum : ▁ " << largestZigZag ( mat , n ) ; return 0 ; }
int countStr ( int n , int bCount , int cCount ) {
if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ;
int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; }
int n = 3 ; cout << countStr ( n , 1 , 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4
int MaximumPath ( int Mat [ ] [ N ] ) { int result = 0 ;
int dp [ N ] [ N + 2 ] ;
for ( int i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ;
for ( int i = 0 ; i <= N ; i ++ ) result = max ( result , dp [ N - 1 ] [ i ] ) ;
return result ; }
int main ( ) { int Mat [ 4 ] [ 4 ] = { { 4 , 2 , 3 , 4 } , { 2 , 9 , 1 , 10 } , { 15 , 1 , 3 , 0 } , { 16 , 92 , 41 , 44 } } ; cout << MaximumPath ( Mat ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001
double dp [ MAX ] ; double probability ( int k , int n ) {
double ans = 0 ;
for ( int i = k ; i <= n ; ++ i ) { double res = dp [ n ] - dp [ i ] - dp [ n - i ] - n ; ans += pow ( 2.0 , res ) ; } return ans ; } void precompute ( ) {
for ( int i = 2 ; i < MAX ; ++ i ) dp [ i ] = log2 ( i ) + dp [ i - 1 ] ; }
int main ( ) { precompute ( ) ;
cout << probability ( 2 , 3 ) << " STRNEWLINE " ;
cout << probability ( 3 , 6 ) << " STRNEWLINE " ;
cout << probability ( 500 , 1000 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printMaxSum ( int arr [ ] , int n ) {
int dp [ n ] ; memset ( dp , 0 , sizeof dp ) ;
for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ;
int maxi = 0 ; for ( int j = 1 ; j <= sqrt ( i + 1 ) ; j ++ ) {
if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) {
if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; }
for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 2 , 3 , 1 , 4 , 6 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
printMaxSum ( arr , n ) ; return 0 ; }
int maxAlternateSum ( int arr [ ] , int n ) { if ( n == 1 ) return arr [ 0 ] ;
int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( min > arr [ i ] ) min = arr [ i ] ; } if ( min == arr [ 0 ] ) { return arr [ 0 ] ; }
int dec [ n ] ; memset ( dec , 0 , sizeof ( dec ) ) ;
int inc [ n ] ; memset ( inc , 0 , sizeof ( inc ) ) ;
dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ;
for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) {
if ( arr [ j ] > arr [ i ] ) { dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) ;
flag = 1 ; }
else if ( arr [ j ] < arr [ i ] && flag == 1 )
inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } }
int result = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; }
return result ; }
int main ( ) { int arr [ ] = { 8 , 2 , 3 , 5 , 7 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ sum ▁ = ▁ " << maxAlternateSum ( arr , n ) << endl ; return 0 ; }
int pad ( int n ) {
int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; }
int main ( ) { int n = 12 ; cout << pad ( n ) ; return 0 ; }
int lucas ( int n ) {
int a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ;
for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; }
int main ( ) { int n = 9 ; printf ( " % d " , lucas ( n ) ) ; return 0 ; }
int breakSum ( int n ) { int dp [ n + 1 ] ;
dp [ 0 ] = 0 , dp [ 1 ] = 1 ;
for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; }
int main ( ) { int n = 24 ; cout << breakSum ( n ) ; return 0 ; }
int minTime ( int arr [ ] , int n ) {
if ( n <= 0 ) return 0 ;
int excl = 0 ;
for ( int i = 1 ; i < n ; i ++ ) {
int incl_new = arr [ i ] + min ( excl , incl ) ;
int excl_new = incl ;
incl = incl_new ; excl = excl_new ; }
return min ( incl , excl ) ; }
int main ( ) { int arr1 [ ] = { 10 , 5 , 2 , 7 , 10 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << minTime ( arr1 , n1 ) << endl ; int arr2 [ ] = { 10 , 5 , 7 , 10 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << minTime ( arr2 , n2 ) << endl ; int arr3 [ ] = { 10 , 5 , 2 , 4 , 8 , 6 , 7 , 10 } ; int n3 = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; cout << minTime ( arr3 , n3 ) << endl ; return 0 ; }
void multiply ( int a [ 3 ] [ 3 ] , int b [ 3 ] [ 3 ] ) {
int mul [ 3 ] [ 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { mul [ i ] [ j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; } }
for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ )
a [ i ] [ j ] = mul [ i ] [ j ] ; }
int power ( int F [ 3 ] [ 3 ] , int n ) { int M [ 3 ] [ 3 ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ;
if ( n == 1 ) return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ;
return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; }
int findNthTerm ( int n ) { int F [ 3 ] [ 3 ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ;
if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return 1 ; return power ( F , n - 2 ) ; } int main ( ) { int n = 5 ; cout << " F ( 5 ) ▁ is ▁ " << findNthTerm ( n ) ; return 0 ; }
int count ( int n ) {
int dp [ n + 1 ] ; dp [ 0 ] = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) {
if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else
dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } return dp [ n ] ; }
int main ( ) { int n = 5 ; cout << " Count ▁ of ▁ ways ▁ is ▁ " << count ( n ) ; return 0 ; }
int nCrModp ( int n , int r , int p ) {
if ( r > n - r ) r = n - r ;
int C [ r + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ;
C [ 0 ] = 1 ;
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = min ( i , r ) ; j > 0 ; j -- )
C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }
int main ( ) { int n = 10 , r = 2 , p = 13 ; cout << " Value ▁ of ▁ nCr ▁ % ▁ p ▁ is ▁ " << nCrModp ( n , r , p ) ; return 0 ; }
int bellNumber ( int n ) { int bell [ n + 1 ] [ n + 1 ] ; bell [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) {
bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ;
for ( int j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; }
int main ( ) { for ( int n = 0 ; n <= 5 ; n ++ ) cout << " Bell ▁ Number ▁ " << n << " ▁ is ▁ " << bellNumber ( n ) << endl ; return 0 ; }
int printCountDP ( int dist ) { int count [ dist + 1 ] ;
count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ;
for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; }
int main ( ) { int dist = 4 ; cout << printCountDP ( dist ) ; return 0 ; }
int countSeq ( int n ) { int nCr = 1 , res = 1 ;
for ( int r = 1 ; r <= n ; r ++ ) {
nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; }
int main ( ) { int n = 2 ; cout << " Count ▁ of ▁ sequences ▁ is ▁ " << countSeq ( n ) ; return 0 ; }
int min ( int arr [ ] , int l , int h ) { int mn = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mn > arr [ i ] ) mn = arr [ i ] ; return mn ; }
int max ( int arr [ ] , int l , int h ) { int mx = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mx < arr [ i ] ) mx = arr [ i ] ; return mx ; }
int minRemovalsDP ( int arr [ ] , int n ) {
int table [ n ] [ n ] , gap , i , j , mn , mx ;
for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { mn = min ( arr , i , j ) ; mx = max ( arr , i , j ) ; table [ i ] [ j ] = ( 2 * mn > mx ) ? 0 : min ( table [ i ] [ j - 1 ] + 1 , table [ i + 1 ] [ j ] + 1 ) ; } } return table [ 0 ] [ n - 1 ] ; }
int main ( ) { int arr [ ] = { 20 , 4 , 1 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minRemovalsDP ( arr , n ) ; return 0 ; }
int numberOfPaths ( int m , int n ) {
if ( m == 1 n == 1 ) return 1 ;
return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ;
} int main ( ) { cout << numberOfPaths ( 3 , 3 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int numberOfPaths ( int m , int n ) {
int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; }
int main ( ) { cout << numberOfPaths ( 3 , 3 ) ; return 0 ; }
int lenghtOfLongestAP ( int set [ ] , int n ) { if ( n <= 2 ) return n ;
int L [ n ] [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) L [ i ] [ n - 1 ] = 2 ;
for ( int j = n - 2 ; j >= 1 ; j -- ) {
int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ;
else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 , i -- ; } else {
L [ i ] [ j ] = L [ j ] [ k ] + 1 ;
llap = max ( llap , L [ i ] [ j ] ) ;
i -- ; k ++ ; } }
while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return llap ; }
int main ( ) { int set1 [ ] = { 1 , 7 , 10 , 13 , 14 , 19 } ; int n1 = sizeof ( set1 ) / sizeof ( set1 [ 0 ] ) ; cout << lenghtOfLongestAP ( set1 , n1 ) << endl ; int set2 [ ] = { 1 , 7 , 10 , 15 , 27 , 29 } ; int n2 = sizeof ( set2 ) / sizeof ( set2 [ 0 ] ) ; cout << lenghtOfLongestAP ( set2 , n2 ) << endl ; int set3 [ ] = { 2 , 4 , 6 , 8 , 10 } ; int n3 = sizeof ( set3 ) / sizeof ( set3 [ 0 ] ) ; cout << lenghtOfLongestAP ( set3 , n3 ) << endl ; return 0 ; }
int lbs ( int arr [ ] , int n ) { int i , j ;
int * lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ;
for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ;
int * lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ;
for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ;
int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
int main ( ) { int arr [ ] = { 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Length ▁ of ▁ LBS ▁ is ▁ % d STRNEWLINE " , lbs ( arr , n ) ) ; return 0 ; }
int eggDrop ( int n , int k ) {
int eggFloor [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ;
for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; }
for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ;
for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } }
return eggFloor [ n ] [ k ] ; }
int main ( ) { int n = 2 , k = 36 ; cout << " Minimum number of trials " STRNEWLINE " in worst case with " << n << " ▁ eggs ▁ and ▁ " << k << " ▁ floors ▁ is ▁ " << eggDrop ( n , k ) ; return 0 ; }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {
if ( n == 0 W == 0 ) return 0 ;
if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ;
else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; cout << knapSack ( W , wt , val , n ) ; return 0 ; }
unsigned long int factorial ( unsigned int n ) { unsigned long int res = 1 ;
for ( int i = 1 ; i <= n ; ++ i ) { res *= i ; } return res ; } unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ;
if ( k > n - k ) k = n - k ;
for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
unsigned long int catalan ( unsigned int n ) {
unsigned long int c = binomialCoeff ( 2 * n , n ) ;
return c / ( n + 1 ) ; }
unsigned long int countBST ( unsigned int n ) {
unsigned long int count = catalan ( n ) ;
return count ; }
unsigned long int countBT ( unsigned int n ) {
unsigned long int count = catalan ( n ) ;
return count * factorial ( n ) ; }
int main ( ) { int count1 , count2 , n = 5 ;
count1 = countBST ( n ) ; count2 = countBT ( n ) ;
cout << " Count ▁ of ▁ BST ▁ with ▁ " << n << " ▁ nodes ▁ is ▁ " << count1 << endl ; cout << " Count ▁ of ▁ binary ▁ trees ▁ with ▁ " << n << " ▁ nodes ▁ is ▁ " << count2 ; return 0 ; }
void printPermutation ( int N , int K ) {
vector < int > res ; int l = 1 , r = N , flag = 0 ; for ( int i = 0 ; i < K ; i ++ ) { if ( ! flag ) {
res . push_back ( l ) ; l ++ ; } else {
res . push_back ( r ) ; r -- ; }
flag ^= 1 ; }
if ( ! flag ) { for ( int i = r ; i >= l ; i -- ) res . push_back ( i ) ; }
else { for ( int i = l ; i <= r ; i ++ ) res . push_back ( i ) ; }
for ( auto i : res ) cout << i << " ▁ " ; }
int main ( ) { int N = 10 , K = 4 ; printPermutation ( N , K ) ; return 0 ; }
int fact ( int N ) { int i , product = 1 ; for ( i = 1 ; i <= N ; i ++ ) product = product * i ; return product ; }
int nthTerm ( int N ) { return ( N * N ) * fact ( N ) ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) ; return 0 ; }
#define d  256 
void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ;
int h = 1 ;
for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ;
for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; }
for ( i = 0 ; i <= N - M ; i ++ ) {
if ( p == t ) { bool flag = true ;
for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) { flag = false ; break ; } if ( flag ) cout << i << " ▁ " ; }
if ( j == M ) cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; }
if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ;
if ( t < 0 ) t = ( t + q ) ; } } }
int main ( ) { char txt [ ] = " GEEKS ▁ FOR ▁ GEEKS " ; char pat [ ] = " GEEK " ;
int q = 101 ;
search ( pat , txt , q ) ; return 0 ; }
int number_of_tower ( int house [ ] , int range , int n ) {
sort ( house , house + n ) ;
int numOfTower = 0 ;
int i = 0 ; while ( i < n ) {
numOfTower ++ ;
int loc = house [ i ] + range ;
while ( i < n && house [ i ] <= loc ) i ++ ;
-- i ;
loc = house [ i ] + range ;
while ( i < n && house [ i ] <= loc ) i ++ ; }
return numOfTower ; }
int house [ ] = { 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 } ; int range = 2 ; int n = sizeof ( house ) / sizeof ( house [ 0 ] ) ;
cout << number_of_tower ( house , range , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ;
int freq [ MAX ] ; memset ( freq , 0 , sizeof ( freq ) ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { cout << " Out ▁ of ▁ range " ; return -1 ; } freq [ arr [ i ] ] += 1 ; }
for ( int i = 0 ; i < MAX ; i ++ ) {
if ( freq [ i ] == k ) return i ; } return -1 ; }
int main ( ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = sizeof ( arr ) / ( sizeof ( arr [ 0 ] ) ) ; cout << findDuplicate ( arr , n , k ) ; return 0 ; }
void pendulumArrangement ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int op [ n ] ;
int mid = ( n - 1 ) / 2 ;
int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; }
if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ;
cout << " Pendulum ▁ arrangement : " << endl ; for ( i = 0 ; i < n ; i ++ ) cout << op [ i ] << " ▁ " ; cout << endl ; }
int arr [ ] = { 14 , 6 , 19 , 21 , 12 } ;
int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
pendulumArrangement ( arr , n ) ; return 0 ; }
int MAX = 256 ;
int freq [ 256 ] [ 1000 ] = { 0 } ;
void preCalculate ( string str , int n ) {
freq [ ( int ) str [ 0 ] ] [ 0 ] = 1 ;
for ( int i = 1 ; i < n ; i ++ ) { char ch = str [ i ] ;
for ( int j = 0 ; j < MAX ; j ++ ) {
char charToUpdate = ( char ) j ;
if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } }
int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch ] [ r ] ; else return ( freq [ ( int ) ch ] [ r ] - freq [ ( int ) ch ] [ l - 1 ] ) ; } string getString ( char x ) { string s ( 1 , x ) ; return s ; }
string lastNonRepeating ( string str , int n , int l , int r ) {
for ( int i = r ; i >= l ; i -- ) {
char ch = str [ i ] ;
if ( getFrequency ( ch , l , r ) == 1 ) return getString ( ch ) ; }
return " - 1" ; }
int main ( ) { string str = " GeeksForGeeks " ; int n = str . length ( ) ; int queries [ 3 ] [ 2 ] = { { 2 , 9 } , { 2 , 3 } , { 0 , 12 } } ; int q = 3 ;
preCalculate ( str , n ) ; for ( int i = 0 ; i < q ; i ++ ) { cout << ( lastNonRepeating ( str , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) << endl ; ; } }
int minCost ( string str , int K ) { int n = str . length ( ) ;
int res = 999999999 , count = 0 , a , b ;
int cnt [ 27 ] ;
for ( int i = 0 ; i < n ; i ++ ) cnt [ str [ i ] - ' a ' + 1 ] ++ ;
for ( int i = 1 ; i < ( 26 - K + 1 ) ; i ++ ) {
a = i ;
b = i + K ; count = 0 ; for ( int j = 1 ; j <= 26 ; j ++ ) {
if ( cnt [ j ] > 0 ) {
if ( j >= a && j >= b ) count = count + ( min ( j - b , 25 - j + a + 1 ) ) * cnt [ j ] ;
else if ( j <= a && j <= b ) count = count + ( min ( a - j , 25 + j - b + 1 ) ) * cnt [ j ] ; } }
res = min ( res , count ) ; }
for ( int i = 26 - K + 1 ; i <= 26 ; i ++ ) {
a = i ;
b = ( i + K ) % 26 ; count = 0 ; for ( int j = 1 ; j <= 26 ; j ++ ) {
if ( cnt [ j ] > 0 ) {
if ( j >= b and j <= a ) count = count + ( min ( j - b , a - j ) ) * cnt [ j ] ; } }
res = min ( res , count ) ; } return res ; }
int main ( ) { string str = " abcdefghi " ; int K = 2 ; cout << minCost ( str , K ) ; return 0 ; }
void printLastChar ( string str ) {
str = str + " ▁ " ; for ( int i = 1 ; i < str . length ( ) ; i ++ ) {
if ( str [ i ] == ' ▁ ' )
cout << str [ i - 1 ] << " ▁ " ; } }
int main ( ) { string str = " Geeks ▁ for ▁ Geeks " ; printLastChar ( str ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ;
for ( int i = 0 ; i < s . length ( ) ; i ++ ) {
switch ( s [ i ] ) { case ' ( ' : open1 ++ ; break ; case ' ) ' : close1 ++ ; break ; case ' { ' : open2 ++ ; break ; case ' } ' : close2 ++ ; break ; case ' [ ' : open3 ++ ; break ; case ' ] ' : close3 ++ ; break ; } }
int maxLen = 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) ; return maxLen ; }
int main ( ) { string s = " ) ) [ ] ] ( ( " ; cout << maxBalancedStr ( s ) ; return 0 ; }
string extractSecretMessage ( string str , string sub ) {
size_t pos ; while ( ( pos = str . find ( sub ) ) != string :: npos ) str . replace ( pos , 3 , " ▁ " ) ;
str = trim ( str ) ; return str ; }
int main ( int argc , char const * argv [ ] ) { string str = " LIELIEILIEAMLIECOOL " ; string sub = " LIE " ; cout << extractSecretMessage ( str , sub ) << endl ; return 0 ; }
int binarySearch ( string arr [ ] , string x , int n ) { int l = 0 ; int r = n - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( x == ( arr [ m ] ) ) res = 0 ;
if ( res == 0 ) return m ;
if ( x > ( arr [ m ] ) ) l = m + 1 ;
else r = m - 1 ; } return -1 ; }
int main ( ) { string arr [ ] = { " contribute " , " geeks " , " ide " , " practice " } ; string x = " ide " ; int n = 4 ; int result = binarySearch ( arr , x , n ) ; if ( result == -1 ) cout << ( " Element ▁ not ▁ present " ) ; else cout << ( " Element ▁ found ▁ at ▁ index ▁ " ) << result ; }
void getStudentsList ( string file [ ] , int n ) {
int avgScore ; int maxAvgScore = INT_MIN ;
vector < string > names ;
for ( int i = 0 ; i < n ; i += 4 ) {
avgScore = ( stoi ( file [ i + 1 ] ) + stoi ( file [ i + 2 ] ) + stoi ( file [ i + 3 ] ) ) / 3 ; if ( avgScore > maxAvgScore ) { maxAvgScore = avgScore ;
names . clear ( ) ; names . push_back ( file [ i ] ) ; } else if ( avgScore == maxAvgScore ) names . push_back ( file [ i ] ) ; }
for ( int i = 0 ; i < names . size ( ) ; i ++ ) { cout << names [ i ] + " ▁ " ; } cout << maxAvgScore ; }
int main ( ) { string file [ ] = { " Shrikanth " , "20" , "30" , "10" , " Ram " , "100" , "50" , "10" } ;
int n = sizeof ( file ) / sizeof ( file [ 0 ] ) ; getStudentsList ( file , n ) ; }
int strScore ( string str [ ] , string s , int n ) { int score = 0 , index ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . length ( ) ; j ++ ) score += s [ j ] - ' a ' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; }
int main ( ) { string str [ ] = { " sahil " , " shashanak " , " sanjit " , " abhinav " , " mohit " } ; string s = " abhinav " ; int n = sizeof ( str ) / sizeof ( str [ 0 ] ) ; int score = strScore ( str , s , n ) ; cout << score << endl ; return 0 ; }
int minParentheses ( string p ) {
int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . length ( ) ; ++ i ) { bal += p [ i ] == ' ( ' ? 1 : -1 ;
if ( bal == -1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; }
int main ( ) { string p = " ( ) ) " ;
cout << minParentheses ( p ) ; return 0 ; }
bool isPalindrome ( string r ) { string p = r ;
reverse ( p . begin ( ) , p . end ( ) ) ;
return ( r == p ) ; }
bool CheckStr ( string s ) { int l = s . length ( ) ;
int i ; for ( i = 2 ; i <= l ; i ++ ) {
if ( isPalindrome ( s . substr ( 0 , i ) ) ) break ; }
if ( i == ( l + 1 ) ) return false ;
i = 2 ; for ( i = 2 ; i <= l ; i ++ ) {
if ( isPalindrome ( s . substr ( l - i , i ) ) ) return true ; }
return false ; }
int main ( ) { string s = " abccbarfgdbd " ; if ( CheckStr ( s ) ) cout << " YES STRNEWLINE " ; else cout << " NO STRNEWLINE " ; return 0 ; }
int oddEquivalent ( string s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } return count ; }
int main ( ) { string s = "1011011" ; int n = s . length ( ) ; cout << oddEquivalent ( s , n ) ; return 0 ; }
int findNumberOfTimes ( string str1 , string str2 ) { int freq [ 26 ] = { 0 } ; int freq2 [ 26 ] = { 0 } ; int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ;
for ( int i = 0 ; i < l1 ; i ++ ) freq [ str1 [ i ] - ' a ' ] += 1 ; for ( int i = 0 ; i < l2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] += 1 ; int count = INT_MAX ;
for ( int i = 0 ; i < l2 ; i ++ ) { if ( freq2 [ str2 [ i ] - ' a ' ] != 0 ) count = min ( count , freq [ str2 [ i ] - ' a ' ] / freq2 [ str2 [ i ] - ' a ' ] ) ; } return count ; }
int main ( ) { string str1 = " foreeksgekseg " ; string str2 = " geeks " ; cout << findNumberOfTimes ( str1 , str2 ) << endl ; return 0 ; }
bool solve ( string s1 , string s2 ) { bool flag1 = 0 , flag2 = 0 ;
if ( s1 . length ( ) != s2 . length ( ) ) return false ; int l = s1 . length ( ) ;
for ( int i = 0 ; i < l ; i ++ ) {
if ( s1 [ i ] == '1' ) flag1 = 1 ;
if ( s2 [ i ] == '1' ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; }
return false ; }
int main ( ) { string s1 = "100101" ; string s2 = "100000" ; if ( solve ( s1 , s2 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int subzero ( string str , int k ) { int ans = 0 , curr = 0 ; int len = str . length ( ) ;
for ( int i = 0 ; i < len ; ++ i ) { if ( str [ i ] == '0' ) curr ++ ; else curr = 0 ; ans = max ( ans , curr ) ; }
if ( ans == len ) return len * k ;
else { int pre = 0 , suff = 0 ;
for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) pre ++ ; else break ; }
for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) suff ++ ; else break ; }
if ( k > 1 ) ans = max ( ans , pre + suff ) ; return ans ; } }
int main ( ) { string str = "00100110" ; int k = 5 ; cout << subzero ( str , k ) ; return 0 ; }
string Dragon_Curve_Sequence ( int n ) {
string s = "1" ;
for ( int i = 2 ; i <= n ; i ++ ) { string temp = "1" ; char prev = '1' , zero = '0' , one = '1' ;
for ( int j = 0 ; j < s . length ( ) ; j ++ ) {
temp += s [ j ] ;
if ( prev == '0' ) {
temp += one ;
prev = one ; } else {
temp += zero ;
prev = zero ; } }
s = temp ; } return s ; }
int n = 4 ;
string s = Dragon_Curve_Sequence ( n ) ;
cout << s << " STRNEWLINE " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNonEmptySubstr ( string str ) { int n = str . length ( ) ; return n * ( n + 1 ) / 2 ; }
int main ( ) { string s = " abcde " ; cout << countNonEmptySubstr ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 26 ; bool targetstring ( string str1 , string str2 ) { int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ;
if ( l1 != l2 ) return false ; int map [ MAX ] = { 0 } ;
for ( int i = 0 ; i < l1 ; i ++ ) map [ str1 [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < l2 ; i ++ ) { map [ str2 [ i ] - ' a ' ] -- ;
if ( map [ str2 [ i ] - ' a ' ] < 0 ) return false ; } return true ; }
int main ( ) { string str1 = " geeksforgeeks " ; string str2 = " geegeeksksfor " ; if ( targetstring ( str1 , str2 ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
bool isDigitPresent ( int x , int d ) {
while ( x > 0 ) { if ( x % 10 == d ) break ; x = x / 10 ; }
return ( x > 0 ) ; }
void printNumbers ( int n , int d ) {
for ( int i = 0 ; i <= n ; i ++ )
if ( i == d || isDigitPresent ( i , d ) ) cout << i << " ▁ " ; }
int main ( ) { int n = 47 , d = 7 ; printNumbers ( n , d ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; char findExtraCharcter ( string strA , string strB ) {
int res = 0 , i ;
for ( i = 0 ; i < strA . length ( ) ; i ++ ) {
res ^= strA [ i ] ; }
for ( i = 0 ; i < strB . length ( ) ; i ++ ) {
res ^= strB [ i ] ; }
return ( ( char ) ( res ) ) ; } int main ( ) {
string strA = " abcd " ; string strB = " cbdad " ; cout << findExtraCharcter ( strA , strB ) ; return 0 ; }
int calculateSum ( string arr [ ] , int n ) {
if ( n == 0 ) return 0 ; string s = arr [ 0 ] ;
int value = stoi ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ;
int value = stoi ( s ) ;
char operation = arr [ i - 1 ] [ 0 ] ;
if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; }
int main ( ) { string arr [ ] = { "3" , " + " , "4" , " - " , "7" , " + " , "13" } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << calculateSum ( arr , n ) ; return 0 ; }
void LargestString ( string * na ) { int N = sizeof ( na ) / sizeof ( na [ 0 ] ) ; int c [ N ] ;
int m = 1 ;
for ( int j = 0 ; j < N ; j ++ ) {
bool character [ 26 ] ;
for ( int k = 0 ; k < na [ j ] . size ( ) ; k ++ ) { int x = ( int ) ( na [ j ] [ k ] - ' A ' ) ; if ( na [ j ] [ k ] != ' ▁ ' && character [ x ] == false ) { c [ j ] ++ ; character [ x ] = true ; } }
if ( c [ j ] > c [ m ] ) m = j ; }
cout << na [ m ] << endl ; }
int main ( ) { string na [ ] = { " BOB " , " A ▁ AB ▁ C ▁ JOHNSON " , " ANJALI " , " ASKRIT " , " ARMAN ▁ MALLIK " } ; LargestString ( na ) ; }
string morseEncode ( char x ) {
switch ( x ) { case ' a ' : return " . - " ; case ' b ' : return " - . . . " ; case ' c ' : return " - . - . " ; case ' d ' : return " - . . " ; case ' e ' : return " . " ; case ' f ' : return " . . - . " ; case ' g ' : return " - - . " ; case ' h ' : return " . . . . " ; case ' i ' : return " . . " ; case ' j ' : return " . - - - " ; case ' k ' : return " - . - " ; case ' l ' : return " . - . . " ; case ' m ' : return " - - " ; case ' n ' : return " - . " ; case ' o ' : return " - - - " ; case ' p ' : return " . - - . " ; case ' q ' : return " - - . - " ; case ' r ' : return " . - . " ; case ' s ' : return " . . . " ; case ' t ' : return " - " ; case ' u ' : return " . . - " ; case ' v ' : return " . . . - " ; case ' w ' : return " . - - " ; case ' x ' : return " - . . - " ; case ' y ' : return " - . - - " ;
case ' z ' : return " - - . . " ; case '1' : return " . - - - - " ; case '2' : return " . . - - - " ; case '3' : return " . . . - - " ; case '4' : return " . . . . - " ; case '5' : return " . . . . . " ; case '6' : return " - . . . . " ; case '7' : return " - - . . . " ; case '8' : return " - - - . . " ; case '9' : return " - - - - . " ; case '0' : return " - - - - - " ; default : cerr << " Found ▁ invalid ▁ character : ▁ " << x << ' ▁ ' << std :: endl ; exit ( 0 ) ; } } void morseCode ( string s ) {
for ( int i = 0 ; s [ i ] ; i ++ ) cout << morseEncode ( s [ i ] ) ; cout << endl ; }
int main ( ) { string s = " geeksforgeeks " ; morseCode ( s ) ; return 0 ; }
void polybiusCipher ( string s ) { int row , col ;
for ( int i = 0 ; s [ i ] ; i ++ ) {
row = ceil ( ( s [ i ] - ' a ' ) / 5 ) + 1 ;
col = ( ( s [ i ] - ' a ' ) % 5 ) + 1 ;
if ( s [ i ] == ' k ' ) { row = row - 1 ; col = 5 - col + 1 ; }
else if ( s [ i ] >= ' j ' ) { if ( col == 1 ) { col = 6 ; row = row - 1 ; } col = col - 1 ; } cout << row << col ; } cout << endl ; }
int main ( ) { string s = " geeksforgeeks " ;
polybiusCipher ( s ) ; return 0 ; }
int minRemoval ( string str ) {
int hash [ MAX_CHAR ] ;
for ( int i = 0 ; str [ i ] ; i ++ ) hash [ str [ i ] - ' a ' ] ++ ;
int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( hash [ i ] % 2 ) count ++ ;
return ( count == 0 ) ? 0 : count - 1 ; }
int main ( ) { string str = " geeksforgeeks " ; cout << minRemoval ( str ) << endl ; return 0 ; }
int findLUSlength ( string a , string b ) {
if ( ! a . compare ( b ) ) return 0 ;
return max ( a . length ( ) , b . length ( ) ) ; }
string a = " abcdabcd " , b = " abcabc " ; cout << findLUSlength ( a , b ) ; return 0 ; }
void swapTwoHalves ( string a , string b ) { int la = a . length ( ) ; int lb = b . length ( ) ;
string c = a . substr ( 0 , la / 2 ) + b . substr ( lb / 2 , lb ) ; string d = b . substr ( 0 , lb / 2 ) + a . substr ( la / 2 , la ) ; cout << c << endl << d << endl ; }
int main ( ) { string a = " remuneration " ; string b = " day " ;
swapTwoHalves ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26
int longSubstring ( string str , int k ) {
int freq [ SIZE ] ; memset ( freq , 0 , sizeof ( freq ) ) ;
int start = 0 ;
int maxLen = 0 ; char ch ; int n = str . size ( ) ;
for ( int i = 0 ; i < n ; i ++ ) {
ch = str [ i ] ;
freq [ ch - ' a ' ] ++ ;
if ( freq [ ch - ' a ' ] > k ) {
if ( maxLen < ( i - start ) ) maxLen = i - start ;
while ( freq [ ch - ' a ' ] > k ) {
freq [ str [ start ] - ' a ' ] -- ;
start ++ ; } } }
if ( maxLen < ( n - start ) ) maxLen = n - start ;
return maxLen ; }
int main ( ) { string str = " babcaag " ; int k = 1 ; cout << " Length ▁ = ▁ " << longSubstring ( str , k ) ; return 0 ; }
int solve ( int A [ ] , int n ) { int i , cnt = 0 , j ;
int parent [ n + 1 ] ;
int vis [ n + 1 ] ;
memset ( parent , -1 , sizeof ( parent ) ) ; memset ( vis , 0 , sizeof ( vis ) ) ; for ( i = 0 ; i < n ; i ++ ) { j = i ;
if ( parent [ j ] == -1 ) {
while ( parent [ j ] == -1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; }
if ( parent [ j ] == i ) {
while ( ! vis [ j ] ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; }
int main ( ) { int A [ ] = { 0 , 0 , 0 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << solve ( A , n ) ; return 0 ; }
void TOWUtil ( int * arr , int n , bool * curr_elements , int no_of_selected_elements , bool * soln , int * min_diff , int sum , int curr_sum , int curr_position ) {
if ( curr_position == n ) return ;
if ( ( n / 2 - no_of_selected_elements ) > ( n - curr_position ) ) return ;
TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , min_diff , sum , curr_sum , curr_position + 1 ) ;
no_of_selected_elements ++ ; curr_sum = curr_sum + arr [ curr_position ] ; curr_elements [ curr_position ] = true ;
if ( no_of_selected_elements == n / 2 ) {
if ( abs ( sum / 2 - curr_sum ) < * min_diff ) { * min_diff = abs ( sum / 2 - curr_sum ) ; for ( int i = 0 ; i < n ; i ++ ) soln [ i ] = curr_elements [ i ] ; } } else {
TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , min_diff , sum , curr_sum , curr_position + 1 ) ; }
curr_elements [ curr_position ] = false ; }
void tugOfWar ( int * arr , int n ) {
bool * curr_elements = new bool [ n ] ;
bool * soln = new bool [ n ] ; int min_diff = INT_MAX ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; curr_elements [ i ] = soln [ i ] = false ; }
TOWUtil ( arr , n , curr_elements , 0 , soln , & min_diff , sum , 0 , 0 ) ;
cout << " The ▁ first ▁ subset ▁ is : ▁ " ; for ( int i = 0 ; i < n ; i ++ ) { if ( soln [ i ] == true ) cout << arr [ i ] << " ▁ " ; } cout << " The second subset is : " for ( int i = 0 ; i < n ; i ++ ) { if ( soln [ i ] == false ) cout << arr [ i ] << " ▁ " ; } }
int main ( ) { int arr [ ] = { 23 , 45 , -34 , 12 , 0 , 98 , -99 , 4 , 189 , -1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; tugOfWar ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define NO_OF_CHARS  256
int max_distinct_char ( string str , int n ) {
int count [ NO_OF_CHARS ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] ] ++ ; int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] != 0 ) max_distinct ++ ; return max_distinct ; } int smallesteSubstr_maxDistictChar ( string str ) {
int n = str . size ( ) ;
int max_distinct = max_distinct_char ( str , n ) ;
int minl = n ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { string subs = str . substr ( i , j ) ; int subs_lenght = subs . size ( ) ; int sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ;
if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; }
string str = " AABBBCBB " ; int len = smallesteSubstr_maxDistictChar ( str ) ; cout << " ▁ The ▁ length ▁ of ▁ the ▁ smallest ▁ substring " " ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ " " characters ▁ : ▁ " << len ; return 0 ; }
int evenNumSubstring ( char str [ ] ) { int len = strlen ( str ) ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ;
if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; }
int main ( ) { char str [ ] = "1234" ; cout << evenNumSubstring ( str ) << endl ; return 0 ; }
int findIndex ( int a [ ] , int n ) {
int res ; ll min_diff = INT_MAX ;
ll prod [ n ] ; prod [ 0 ] = a [ 0 ] ;
for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ;
for ( int i = 0 ; i < n - 1 ; i ++ ) { ll curr_diff = abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; }
int main ( ) { int arr [ ] = { 3 , 2 , 5 , 7 , 2 , 9 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findIndex ( arr , N ) ; return 0 ; }
void printNumbers ( int a [ ] , int n , int x ) { bool flag = false ;
for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ;
int g = __gcd ( num , x ) ;
while ( g != 1 ) {
num /= g ;
g = __gcd ( num , x ) ; }
if ( num == 1 ) { flag = true ; cout << a [ i ] << " ▁ " ; } }
if ( ! flag ) cout << " There ▁ are ▁ no ▁ such ▁ numbers " ; }
int main ( ) { int x = 60 ; int a [ ] = { 2 , 5 , 10 , 7 , 17 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printNumbers ( a , n , x ) ; return 0 ; }
void print ( int rStation [ ] , int n ) { for ( int i = 1 ; i <= n ; i ++ ) cout << rStation [ i ] << " ▁ " ; cout << endl ; }
void radiated_Station ( int station [ ] , int n ) {
int rStation [ n + 1 ] ; memset ( rStation , 0 , sizeof ( rStation ) ) ; for ( int i = 1 ; i <= n ; i ++ ) {
int li = i - 1 , ri = i + 1 ;
int lRad = station [ i ] - 1 , rRad = station [ i ] - 1 ;
rStation [ i ] += station [ i ] ;
while ( li >= 1 && lRad >= 1 ) { rStation [ li -- ] += lRad -- ; }
while ( ri <= n && rRad >= 1 ) { rStation [ ri ++ ] += rRad -- ; } }
print ( rStation , n ) ; }
int station [ ] = { 0 , 7 , 9 , 12 , 2 , 5 } ; int n = ( sizeof ( station ) / sizeof ( station [ 0 ] ) ) - 1 ; radiated_Station ( station , n ) ; return 0 ; }
int findMaximumDiff ( int a [ ] , int n ) { int ind1 = 0 ;
for ( int i = n - 1 ; i > 0 ; i -- ) {
if ( a [ 0 ] != a [ i ] ) { ind1 = i ; break ; } } int ind2 = 0 ;
for ( int i = 0 ; i < n - 1 ; i ++ ) {
if ( a [ n - 1 ] != a [ i ] ) { ind2 = ( n - 1 - i ) ; break ; } } return max ( ind1 , ind2 ) ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findMaximumDiff ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sum ( int k , int n ) { int sum = pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ; return sum ; }
int main ( ) { int n = 3 ; int K = 3 ; cout << sum ( K , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool is_prime ( int num ) {
int count = 0 ;
for ( int i = 1 ; i * i <= ( num ) ; i ++ ) { if ( ( num ) % i == 0 ) { if ( i * i != ( num ) ) count += 2 ; else count ++ ; } }
if ( count == 2 ) return true ; else return false ; }
string is_divisible ( int n ) {
if ( n == 1 ) { return " YES " ; }
else {
if ( is_prime ( n + 1 ) ) return " NO " ;
else return " YES " ; } }
n = 3 ; cout << is_divisible ( n ) << endl ;
n = 4 ; cout << is_divisible ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define mod  (int)(1e9 + 7)
ll BitOperations ( string a , int n , string b , int m ) {
reverse ( a . begin ( ) , a . end ( ) ) ; reverse ( b . begin ( ) , b . end ( ) ) ;
int c = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] == '1' ) c ++ ;
ll power [ n ] ; power [ 0 ] = 1 ;
for ( int i = 1 ; i < n ; i ++ ) power [ i ] = ( power [ i - 1 ] * 2 ) % mod ;
ll ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == '1' ) {
ans += c * power [ i ] ; if ( ans >= mod ) ans %= mod ; }
if ( b [ i ] == '1' ) c -- ;
if ( c == 0 ) break ; }
return ans ; }
int main ( ) { string a = "1001" , b = "10101" ; int n = a . length ( ) , m = b . length ( ) ; cout << BitOperations ( a , n , b , m ) ; return 0 ; }
void sieve ( int maxEle , int prime [ ] ) { prime [ 0 ] = prime [ 1 ] = 1 ; for ( int i = 2 ; i * i <= maxEle ; i ++ ) { if ( ! prime [ i ] ) { for ( int j = 2 * i ; j <= maxEle ; j += i ) prime [ j ] = 1 ; } } }
int digitSum ( int n ) { int sum = 0 ; while ( n ) { sum += n % 10 ; n = n / 10 ; } return sum ; }
void printAdditivePrime ( int arr [ ] , int n ) { int maxEle = * max_element ( arr , arr + n ) ; int prime [ maxEle + 1 ] ; memset ( prime , 0 , sizeof ( prime ) ) ; sieve ( maxEle , prime ) ; for ( int i = 0 ; i < n ; i ++ ) {
if ( prime [ arr [ i ] ] == 0 ) { int sum = digitSum ( arr [ i ] ) ;
if ( prime [ sum ] == 0 ) cout << arr [ i ] << " ▁ " ; } } }
int main ( ) { int a [ ] = { 2 , 4 , 6 , 11 , 12 , 18 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printAdditivePrime ( a , n ) ; return 0 ; }
long long int nthTerm ( long long int n ) {
long long int nth ;
if ( n % 2 == 0 ) nth = 2 * ( ( n * n ) - n ) ;
else nth = ( 2 * n * n ) - n ;
return nth ; }
int main ( ) { long long int n ; n = 5 ; printf ( " % lld STRNEWLINE " , nthTerm ( n ) ) ; n = 25 ; printf ( " % lld STRNEWLINE " , nthTerm ( n ) ) ; n = 25000000 ; printf ( " % lld STRNEWLINE " , nthTerm ( n ) ) ; n = 250000007 ; printf ( " % lld STRNEWLINE " , nthTerm ( n ) ) ; return 0 ; }
long nthterm ( int n ) {
int An = ( pow ( 1 , n ) + pow ( 2 , n ) ) * pow ( 3 , n ) ; return An ; }
int main ( ) { int n = 3 ; cout << nthterm ( n ) ; return 0 ; }
int countDivisors ( int n ) {
int x = 0 , ans = 1 ; while ( n % 2 == 0 ) { x ++ ; n = n / 2 ; } ans = ans * ( x + 1 ) ;
for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) {
x = 0 ; while ( n % i == 0 ) { x ++ ; n = n / i ; } ans = ans * ( x + 1 ) ; }
if ( n > 2 ) ans = ans * 2 ; return ans ; } int getTotalCount ( int n , int k ) { int k_count = countDivisors ( k ) ;
int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( k_count == countDivisors ( i ) ) count ++ ;
if ( k < n ) count = count - 1 ; return count ; }
int main ( ) { int n = 500 , k = 6 ; cout << getTotalCount ( n , k ) ; return 0 ; }
long term ( int n ) {
int d = 2 ;
int a1 = 0 ;
int An = a1 + ( n - 1 ) * d ;
An = pow ( An , 3 ) ; return An ; }
int main ( ) { int n = 5 ; cout << term ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_VAL = 200000 ;
int countIntervals ( int arr [ ] [ 2 ] , int V , int N ) {
int min = INT_MAX ; int max = INT_MIN ;
int li , ri ;
int freq [ MAX_VAL ] ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; }
for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; }
int main ( ) { int arr [ 5 ] [ 2 ] = { { 1 , 10 } , { 5 , 10 } , { 15 , 25 } , { 7 , 12 } , { 20 , 25 } } ; int V = 7 ;
int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( countIntervals ( arr , V , N ) ) ; }
void printGroups ( int n ) { int x = 1 ; int y = n * n ;
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = 1 ; j <= n / 2 ; j ++ ) { cout << " { ▁ " << x << " , ▁ " << y << " } ▁ " ; x ++ ; y -- ; } cout << endl ; } }
int main ( ) { int n = 4 ; printGroups ( n ) ; return 0 ; }
int breakEvenPoint ( int exp , int S , int M ) { float earn = S - M ;
int res = ceil ( exp / earn ) ; return res ; }
int main ( ) { int exp = 3550 , S = 90 , M = 65 ; cout << breakEvenPoint ( exp , S , M ) ; return 0 ; }
ll minimum ( ll n ) { ll product = 1 ;
for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; }
int main ( ) { ll n = 20 ; cout << minimum ( n ) << endl ; return 0 ; }
int numbers ( int n , int arr [ ] , int m ) { int isZero = 0 , isFive = 0 ; int result = 0 ;
if ( m < n ) { return -1 ; } for ( int i = 0 ; i < m ; i ++ ) { if ( arr [ i ] == 0 ) isZero = 1 ; if ( arr [ i ] == 5 ) isFive = 1 ; }
if ( isZero && isFive ) { result = 2 ;
for ( int i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else if ( isZero isFive ) { result = 1 ;
for ( int i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else result = -1 ; return result ; }
int main ( ) { int n = 3 , m = 6 ; int arr [ ] = { 2 , 3 , 5 , 6 , 7 , 9 } ; cout << numbers ( n , arr , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int a = 5 , b = 7 , c = 10 ; if ( a <= b && a <= c ) cout << a << " ▁ is ▁ the ▁ smallest " ; else if ( b <= a && b <= c ) cout << b << " ▁ is ▁ the ▁ smallest " ; else cout << c << " ▁ is ▁ the ▁ smallest " ; return 0 ; }
void maxSum ( int a [ ] , int n ) { int maxAnd = 0 ;
for ( int i = 0 ; i < n ; i ++ ) maxAnd = max ( maxAnd , a [ i ] ) ;
int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR = maxOR | a [ i ] ; } cout << maxAnd + maxOR ; }
int main ( ) { int a [ ] = { 3 , 5 , 6 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; maxSum ( a , n ) ; }
int getMin ( int arr [ ] , int n , int k ) { int res = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) res = min ( res , arr [ i ] ) ; } return res ; }
int getMax ( int arr [ ] , int n , int k ) { int res = INT_MIN ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) res = max ( res , arr [ i ] ) ; } return res ; }
int main ( ) { int arr [ ] = { 10 , 1230 , 45 , 67 , 1 } ; int k = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ element ▁ of ▁ array ▁ which ▁ is ▁ divisible ▁ by ▁ k : ▁ " << getMin ( arr , n , k ) << " STRNEWLINE " ; cout << " Maximum ▁ element ▁ of ▁ array ▁ which ▁ is ▁ divisible ▁ by ▁ k : ▁ " << getMax ( arr , n , k ) ; return 0 ; }
void printNumberWithDR ( int k , int d ) {
if ( d == 0 && k != 1 ) cout << " - 1" ; else { cout << d ; k -- ;
while ( k -- ) cout << "0" ; } }
int main ( ) { int k = 4 , d = 4 ; printNumberWithDR ( k , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
int prime [ limit + 1 ] ;
for ( int i = 1 ; i <= limit ; i ++ ) prime [ i ] = i ;
for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) {
for ( int j = i * i ; j <= limit ; j += i ) if ( prime [ j ] == j ) prime [ j ] = i ; } }
for ( int i = 2 ; i <= limit ; i ++ ) {
int p = prime [ i ] ;
int q = prime [ i / prime [ i ] ] ;
if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) {
if ( pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; }
int main ( ) { int n = 1000 ; cout << countNumbers ( n ) ; return 0 ; }
bool isPrime ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
bool isInterprime ( int n ) {
if ( n < 4 ) return false ; int prev_prime = n ; int next_prime = n ;
while ( ! isPrime ( prev_prime ) ) { prev_prime -- ; }
while ( ! isPrime ( next_prime ) ) { next_prime ++ ; }
if ( ( prev_prime + next_prime ) == 2 * n ) return true ; else return false ; }
int main ( ) { int n = 9 ; if ( isInterprime ( n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int get_unit_digit ( long long int N ) {
if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ;
return 3 ; }
int main ( ) { long long int N = 1 ; for ( N = 0 ; N <= 10 ; N ++ ) cout << " For ▁ N ▁ = ▁ " << N << " ▁ : ▁ " << get_unit_digit ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ;
int f [ MAX ] = { 0 } ;
int fib ( int n ) {
if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ;
if ( f [ n ] ) return f [ n ] ; int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ;
f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
int calculateSumOfSquares ( int n ) { return fib ( n ) * fib ( n + 1 ) ; }
int main ( ) { int n = 6 ; cout << " Sum ▁ of ▁ Squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " << calculateSumOfSquares ( n ) << endl ; return 0 ; }
int NumberOfSolutions ( int x , int y , int z , int n ) {
int ans = 0 ;
for ( int i = 0 ; i <= x ; i ++ ) {
for ( int j = 0 ; j <= y ; j ++ ) {
int temp = n - i - j ;
if ( temp >= 0 ) {
temp = min ( temp , z ) ; ans += temp + 1 ; } } }
return ans ; }
int main ( ) { int x = 1 , y = 2 , z = 3 , n = 4 ; cout << NumberOfSolutions ( x , y , z , n ) ; return 0 ; }
int nthTerm ( int n ) { return pow ( n , 2 ) + 4 * n ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
bool isPerfectSquare ( long double x ) { long double sr = sqrt ( x ) ; return ( ( sr - floor ( sr ) ) == 0 ) ; }
bool isProduct ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; }
void findNumbers ( int N ) {
vector < int > vec ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isProduct ( i ) && ! isPerfectSquare ( i ) ) {
vec . push_back ( i ) ; } }
for ( int i = 0 ; i < vec . size ( ) ; i ++ ) { cout << vec [ i ] << " ▁ " ; } }
int main ( ) { int N = 30 ; findNumbers ( N ) ; return 0 ; }
int nthTerm ( int n ) {
return 2 * pow ( n , 3 ) + pow ( n , 2 ) ; }
int main ( ) { int N = 3 ; cout << nthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  1000000009
int NthTerm ( long long n ) { long long x = ( 2 * n * n ) % mod ; return ( x - n + mod ) % mod ; }
long long N = 4 ;
cout << NthTerm ( N ) ; return 0 ; }
int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; }
int N = 3 ;
cout << findSum ( N ) << endl ; return 0 ; }
int nthTerm ( int N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; }
int N = 3 ;
cout << nthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE #define MAX  16 NEW_LINE using namespace std ; ll nCr [ MAX ] [ MAX ] = { 0 } ;
void binomial ( ) {
for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
double findTanNTheta ( double tanTheta , ll n ) {
double ans = 0 , numerator = 0 , denominator = 0 ;
ll toggle = 1 ;
for ( int i = 1 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * pow ( tanTheta , i ) * toggle ; toggle = toggle * -1 ; }
denominator = 1 ; toggle = -1 ; for ( int i = 2 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * pow ( tanTheta , i ) * toggle ; toggle = toggle * -1 ; } ans = numerator / denominator ; return ans ; }
int main ( ) { binomial ( ) ; double tanTheta = 0.3 ; ll n = 10 ; cout << findTanNTheta ( tanTheta , n ) << endl ; return 0 ; }
int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; }
int main ( ) { cout << findMaximumPieces ( 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateSum ( int n ) {
return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; } int main ( ) {
int n = 4 ;
cout << " Sum ▁ = ▁ " << calculateSum ( n ) ; return 0 ; }
void printCombination ( int n ) {
for ( int i = 1 ; i < n ; i ++ ) {
if ( i % 3 != 0 ) {
for ( int j = 1 ; j < n ; j ++ ) {
if ( j % 3 != 0 ) {
for ( int k = 1 ; k < n ; k ++ ) {
if ( k % 3 != 0 && ( i + j + k ) == n ) { cout << i << " ▁ " << j << " ▁ " << k ; return ; } } } } } } }
int main ( ) { int n = 233 ; printCombination ( n ) ; return 0 ; }
int percent ( int a , int b ) { float result = 0 ; result = ( ( b - a ) * 100 ) / a ; return result ; }
int main ( ) { int a = 20 , b = 25 ;
cout << percent ( a , b ) << " % " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculate ( int * array , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( array [ i ] % 2 == 0 && array [ i ] != 0 && array [ i ] != 2 ) count ++ ; return count ; }
int main ( ) { int a [ ] = { 1 , 3 , 4 , 6 } ; int size = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << calculate ( a , size ) ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int main ( ) { int a = 98 , b = 56 ; cout << " GCD ▁ of ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << gcd ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int twoEggDrop ( int k ) { return ceil ( ( -1.0 + sqrt ( 1 + 8 * k ) ) / 2.0 ) ; }
int main ( ) { int k = 100 ; cout << twoEggDrop ( k ) ; return 0 ; }
float findArea ( float a ) { float area ;
area = 5 * sqrt ( 3 ) * a * a ; return area ; }
float findVolume ( float a ) { float volume ;
volume = ( ( float ) 5 / 12 ) * ( 3 + sqrt ( 5 ) ) * a * a * a ; return volume ; }
int main ( ) { float a = 5 ;
cout << " Area : ▁ " << findArea ( a ) << endl ;
cout << " Volume : ▁ " << findVolume ( a ) ; return 0 ; }
int ways ( int n ) {
int first = 2 ;
int second = 3 ; int res = 0 ;
for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; }
int n = 7 ; cout << " Total ▁ ways ▁ are ▁ : ▁ " ; cout << ways ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigits ( int n ) {
double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += log10 ( i ) ;
ans = ans * n ; return 1 + floor ( ans ) ; }
int main ( ) { int n = 4 ; cout << countDigits ( n ) << " STRNEWLINE " ; return 0 ; }
int main ( ) { float cm , meter , kilometer ; cm = 1000 ;
meter = cm / 100.0 ; kilometer = cm / 100000.0 ; cout << " Length ▁ in ▁ meter ▁ = ▁ " << meter << " m " << " STRNEWLINE " ; cout << " Length ▁ in ▁ Kilometer ▁ = ▁ " << kilometer << " km " << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool everMeet ( int x1 , int x2 , int v1 , int v2 ) {
if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ;
if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; }
return ( ( x1 - x2 ) % ( v1 - v2 ) == 0 ) ; }
int main ( ) { int x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) printf ( " Yes " ) ; else printf ( " No " ) ; return 0 ; }
int a = 4 ; int b = 3 ; int val = ( a + b - 1 ) / b ; cout << " The ▁ ceiling ▁ value ▁ of ▁ 4/3 ▁ is ▁ " << val << endl ;
a = 6 ; b = 3 ; val = ( a + b - 1 ) / b ; cout << " The ▁ ceiling ▁ value ▁ of ▁ 6/3 ▁ is ▁ " << val << endl ; return 0 ; }
ll sumTillX ( ll x , ll n ) {
ll odd = ceil ( n / 2.0 ) ; if ( x <= odd ) return x * x ;
ll even = x - odd ; return ( ( odd * odd ) + ( even * even ) + even ) ; } int rangeSum ( int N , int L , int R ) { return sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ; }
int main ( ) { ll N = 10 , L = 1 , R = 6 ; cout << rangeSum ( N , L , R ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwinPrime ( int n ) {
bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } }
for ( int p = 2 ; p <= n - 2 ; p ++ ) if ( prime [ p ] && prime [ p + 2 ] ) cout << " ( " << p << " , ▁ " << p + 2 << " ) " ; }
int main ( ) { int n = 25 ;
printTwinPrime ( n ) ; return 0 ; }
bool isCubeFree ( int n ) { if ( n == 1 ) return false ;
for ( int i = 2 ; i * i * i <= n ; i ++ ) if ( n % ( i * i * i ) == 0 ) return false ; return true ; }
void printCubeFree ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) if ( isCubeFree ( i ) ) cout << i << " ▁ " ; }
int main ( ) { int n = 20 ; printCubeFree ( n ) ; return 0 ; }
int inversegrayCode ( int n ) { int inv = 0 ;
for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; }
int main ( ) { int n = 15 ; cout << inversegrayCode ( n ) << endl ; return 0 ; }
long long int productPrimeFactors ( int n ) { long long int product = 1 ;
if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; }
for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) {
if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } }
if ( n > 2 ) product = product * n ; return product ; }
int main ( ) { int n = 44 ; cout << productPrimeFactors ( n ) ; return 0 ; }
double calculateProbability ( int N ) {
double probability = ( double ) N / ( N + 1 ) ; return probability ; }
N = 1 ; probabilityMax = calculateProbability ( N ) ; cout << " Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ " << N << " ▁ is , ▁ " << setprecision ( 4 ) << fixed << probabilityMax << endl ;
N = 2 ; probabilityMax = calculateProbability ( N ) ; cout << " Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ " << N << " ▁ is , ▁ " << setprecision ( 4 ) << fixed << probabilityMax << endl ;
N = 10 ; probabilityMax = calculateProbability ( N ) ; cout << " Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ " << N << " ▁ is , ▁ " << setprecision ( 4 ) << fixed << probabilityMax << endl ; return 0 ; }
float mean ( float mid [ ] , int freq [ ] , int n ) { float sum = 0 , freqSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; }
float groupedSD ( float lower_limit [ ] , float upper_limit [ ] , int freq [ ] , int n ) { float mid [ n ] , sum = 0 , freqSum = 0 , sd ; for ( int i = 0 ; i < n ; i ++ ) { mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 ; sum = sum + freq [ i ] * mid [ i ] * mid [ i ] ; freqSum = freqSum + freq [ i ] ; }
sd = sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) ; return sd ; }
float lower_limit [ ] = { 50 , 61 , 71 , 86 , 96 } ;
float upper_limit [ ] = { 60 , 70 , 85 , 95 , 100 } ; int freq [ ] = { 9 , 7 , 9 , 12 , 8 } ;
int n = sizeof ( lower_limit ) / sizeof ( lower_limit [ 0 ] ) ; cout << groupedSD ( lower_limit , upper_limit , freq , n ) ; return 0 ; }
int avg_of_even_num ( int n ) {
int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ;
return sum / n ; }
int main ( ) { int n = 9 ; cout << avg_of_even_num ( n ) ; return 0 ; }
int avg_of_even_num ( int n ) { return n + 1 ; }
int main ( ) { int n = 8 ; cout << avg_of_even_num ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int squareSum ( int n ) { return n * ( 4 * n * n - 1 ) / 3 ; }
int main ( ) { cout << squareSum ( 8 ) ; return 0 ; }
bool isPrime ( int n ) {
if ( n % 2 == 0 ) return false ;
for ( int i = 3 ; i * i <= n ; i += 2 ) if ( n % i == 0 ) return false ; return true ; }
int nextPrime ( int start ) {
int next = start + 1 ;
while ( ! isPrime ( next ) ) next ++ ; return next ; }
bool areAdjacentPrimes ( int a , int b , int c ) {
if ( ! isPrime ( a ) || ! isPrime ( b ) || ! isPrime ( c ) ) return false ;
int next = nextPrime ( a ) ;
if ( next != b ) return false ;
if ( nextPrime ( b ) != c ) return false ; return true ; }
int main ( ) { if ( areAdjacentPrimes ( 11 , 13 , 19 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) while ( num % i == 0 ) num /= i , ++ cnt ;
if ( num > 1 ) ++ cnt ;
return cnt == 2 ; }
void semiprime ( int n ) { if ( checkSemiprime ( n ) ) cout << " True STRNEWLINE " ; else cout << " False STRNEWLINE " ; }
int main ( ) { int n = 6 ; semiprime ( n ) ; n = 8 ; semiprime ( n ) ; return 0 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; }
int main ( ) { int n = 10 ;
cout << sumOfSeries ( n ) ; return 0 ; }
int sumOfSeries ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; }
int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
int binomialCoeff ( int n , int k ) { int C [ n + 1 ] [ k + 1 ] ;
for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= min ( i , k ) ; j ++ ) {
if ( j == 0 j == i ) C [ i ] [ j ] = 1 ;
else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; }
int maxcoefficientvalue ( int n ) {
if ( n % 2 == 0 ) return binomialCoeff ( n , n / 2 ) ;
else return binomialCoeff ( n , ( n + 1 ) / 2 ) ; }
int main ( ) { int n = 4 ; cout << maxcoefficientvalue ( n ) << endl ; return 0 ; }
int LCM ( int x , int y , int z ) { int ans = ( ( x * y ) / ( __gcd ( x , y ) ) ) ; return ( ( z * ans ) / ( __gcd ( ans , z ) ) ) ; }
int findDivisible ( int n , int x , int y , int z ) {
int lcm = LCM ( x , y , z ) ;
int ndigitnumber = pow ( 10 , n - 1 ) ;
int reminder = ndigitnumber % lcm ;
if ( reminder == 0 ) return ndigitnumber ;
ndigitnumber += lcm - reminder ;
if ( ndigitnumber < pow ( 10 , n ) ) return ndigitnumber ; else return 0 ; }
int main ( ) { int n = 4 , x = 2 , y = 3 , z = 5 ; int res = findDivisible ( n , x , y , z ) ;
if ( res != 0 ) cout << res ; else cout << " Not ▁ possible " ; return 0 ; }
int squaresum ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
int main ( ) { int n = 4 ; cout << squaresum ( n ) << endl ; return 0 ; }
float distance ( int x1 , int y1 , int x2 , int y2 ) {
return sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) * 1.0 ) ; }
int main ( ) { cout << distance ( 3 , 4 , 4 , 3 ) ; return 0 ; }
bool isDivisible ( string s ) {
int n = s . length ( ) ;
if ( s [ n - 1 ] != '5' and s [ n - 1 ] != '0' ) return false ;
int sum = accumulate ( begin ( s ) , end ( s ) , 0 ) - '0' * n ;
return ( sum % 3 == 0 ) ; }
int main ( ) { string s = "15645746327462384723984023940239" ; isDivisible ( s ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; string s1 = "15645746327462384723984023940235" ; isDivisible ( s1 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
bool checkPerfectSquare ( double n ) {
double d = sqrt ( n ) ;
if ( d * d == n ) return true ; return false ; }
int largestPerfectSquareNumber ( int a [ ] , double n ) {
int maxi = -1 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( checkPerfectSquare ( a [ i ] ) ) maxi = max ( a [ i ] , maxi ) ; } return maxi ; }
int main ( ) { int a [ ] = { 16 , 20 , 25 , 2 , 3 , 10 } ; double n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << largestPerfectSquareNumber ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
int find_LCM ( int x , int y ) { return ( x * y ) / __gcd ( x , y ) ; }
int CountPairs ( int n , int m , int A , int B ) { int cnt = 0 ; int lcm = find_LCM ( A , B ) ; for ( int i = 1 ; i <= n ; i ++ ) cnt += ( m + ( i % lcm ) ) / lcm ; return cnt ; }
int main ( ) { int n = 60 , m = 90 , A = 5 , B = 10 ; cout << CountPairs ( n , m , A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1001 NEW_LINE static int prefix [ MAX ] [ MAX ] ; int ar [ MAX ] ;
void cal_prefix ( int n , int arr [ ] ) { int i , j ;
for ( i = 0 ; i < n ; i ++ ) ar [ i + 1 ] = arr [ i ] ;
for ( i = 1 ; i <= 1000 ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) prefix [ i ] [ j ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) {
prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + ( int ) ( ar [ j ] <= i ? 1 : 0 ) ; } } }
int ksub ( int l , int r , int n , int k ) { int lo , hi , mid ; lo = 1 ; hi = 1000 ;
while ( lo + 1 < hi ) { mid = ( lo + hi ) / 2 ; if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) hi = mid ; else lo = mid + 1 ; } if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) hi = lo ; return hi ; }
int main ( ) { int arr [ ] = { 1 , 4 , 2 , 3 , 5 , 7 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ;
cal_prefix ( n , arr ) ;
int queries [ ] [ 3 ] = { { 1 , n , 1 } , { 2 , n - 2 , 2 } , { 3 , n - 1 , 3 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ;
for ( int i = 0 ; i < q ; i ++ ) cout << ksub ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , n , queries [ i ] [ 2 ] ) << endl ; return 0 ; }
int max_min ( int a [ ] , int n ) {
if ( n <= 1 ) return INT_MAX ;
int f_min = a [ 0 ] , s_min = INT_MAX ;
int f_max = a [ 0 ] , s_max = INT_MIN ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= f_min ) { s_min = f_min ; f_min = a [ i ] ; } else if ( a [ i ] < s_min ) { s_min = a [ i ] ; } if ( a [ i ] >= f_max ) { s_max = f_max ; f_max = a [ i ] ; } else if ( a [ i ] > s_max ) { s_max = a [ i ] ; } } return min ( ( f_max - s_min ) , ( s_max - f_min ) ) ; }
int main ( ) { int a [ ] = { 1 , 3 , 3 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << max_min ( a , n ) ; return 0 ; }
int minimal ( int a [ ] , int n ) { int lo = 0 , hi = n - 1 ;
while ( lo < hi ) {
int mid = ( lo + hi ) >> 1 ;
if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } }
return lo ; }
int main ( ) { int a [ ] = { 8 , 5 , 4 , 3 , 4 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int ind = minimal ( a , n ) ;
cout << a [ ind ] ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findIndices ( int arr [ ] , int n ) { int leftMin = 0 , rightMin = 0 ; int leftMax = 0 , rightMax = 0 ; int min = arr [ 0 ] , max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) {
if ( arr [ i ] < min ) { leftMin = rightMin = i ; min = arr [ i ] ; }
else if ( arr [ i ] == min ) rightMin = i ;
if ( arr [ i ] > max ) { leftMax = rightMax = i ; max = arr [ i ] ; }
else if ( arr [ i ] == max ) rightMax = i ; } cout << " Minimum ▁ left ▁ : ▁ " << leftMin << " STRNEWLINE " ; cout << " Minimum ▁ right ▁ : ▁ " << rightMin << " STRNEWLINE " ; cout << " Maximum ▁ left ▁ : ▁ " << leftMax << " STRNEWLINE " ; cout << " Maximum ▁ right ▁ : ▁ " << rightMax << " STRNEWLINE " ; }
int main ( ) { int arr [ ] = { 2 , 1 , 1 , 2 , 1 , 5 , 6 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findIndices ( arr , n ) ; }
void diagonalsMinMax ( int mat [ 5 ] [ 5 ] ) {
int n = sizeof ( * mat ) / 4 ; if ( n == 0 ) return ;
int principalMin = mat [ 0 ] [ 0 ] , principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] , secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) {
if ( i == j ) {
if ( mat [ i ] [ j ] < principalMin ) { principalMin = mat [ i ] [ j ] ; }
if ( mat [ i ] [ j ] > principalMax ) { principalMax = mat [ i ] [ j ] ; } }
if ( ( i + j ) == ( n - 1 ) ) {
if ( mat [ i ] [ j ] < secondaryMin ) { secondaryMin = mat [ i ] [ j ] ; }
if ( mat [ i ] [ j ] > secondaryMax ) { secondaryMax = mat [ i ] [ j ] ; } } } } cout << ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " ) << principalMin << endl ; cout << ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " ) << principalMax << endl ; cout << ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " ) << secondaryMin << endl ; cout << ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " ) << secondaryMax << endl ; }
int matrix [ 5 ] [ 5 ] = { { 1 , 2 , 3 , 4 , -10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , -5 } } ; diagonalsMinMax ( matrix ) ; }
int countSegments ( int a [ ] , int n , int x ) { bool flag = false ; int count = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] > x ) { flag = true ; } else {
if ( flag ) count += 1 ; flag = false ; } }
if ( flag ) count += 1 ; return count ; }
int main ( ) { int a [ ] = { 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int x = 13 ; cout << countSegments ( a , n , x ) ; return 0 ; }
long gfg :: count_triples ( int n , int k ) { int i = 0 , j = 0 , l = 0 ; int count = 0 ;
for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { for ( l = 1 ; l <= n ; l ++ ) {
if ( ( i + j ) % k == 0 && ( i + l ) % k == 0 && ( j + l ) % k == 0 ) count ++ ; } } } return count ; }
int main ( ) { gfg g ; int n = 3 ; int k = 2 ; long ans = g . count_triples ( n , k ) ; cout << ans ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define maxs  1000001 NEW_LINE int kthSmallestLargest ( int * arr , int n , int k ) { int max_val = * max_element ( arr , arr + n ) ; int hash [ max_val + 1 ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) hash [ arr [ i ] ] ++ ;
int count = 0 ; for ( int i = 0 ; i <= max_val ; i ++ ) { while ( hash [ i ] > 0 ) { count ++ ; if ( count == k ) return i ; hash [ i ] -- ; } } return -1 ; }
int main ( ) { int arr [ ] = { 11 , 6 , 2 , 9 , 4 , 3 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) , k = 3 ; cout << " kth ▁ smallest ▁ number ▁ is : ▁ " << kthSmallestLargest ( arr , n , k ) << endl ; return 0 ; }
int bsearch ( vector < int > A , int key_to_search ) { int n = ( int ) A . size ( ) ;
int lg = log2 ( n - 1 ) + 1 ;
int pos = 0 ; for ( int i = lg ; i >= 0 ; i -- ) { if ( A [ pos ] == key_to_search ) return pos ;
int new_pos = pos | ( 1 << i ) ;
if ( ( new_pos < n ) && ( A [ new_pos ] <= key_to_search ) ) pos = new_pos ; }
return ( ( A [ pos ] == key_to_search ) ? pos : -1 ) ; }
int main ( void ) { vector < int > A = { -2 , 10 , 100 , 250 , 32315 } ; cout << bsearch ( A , 10 ) << endl ; return 0 ; }
float findmedian ( int a [ ] , int n1 , int b [ ] , int n2 ) { int i = 0 ;
int j = 0 ;
int k ; int m1 = -1 , m2 = -1 ; for ( k = 0 ; k <= ( n1 + n2 ) / 2 ; k ++ ) { if ( i < n1 && j < n2 ) { if ( a [ i ] < b [ j ] ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } else { m2 = m1 ; m1 = b [ j ] ; j ++ ; } }
else if ( i == n1 ) { m2 = m1 ; m1 = b [ j ] ; j ++ ; }
else if ( j == n2 ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } }
if ( ( n1 + n2 ) % 2 == 0 ) return ( m1 + m2 ) * 1.0 / 2 ;
return m1 ; }
int main ( ) { int a [ ] = { 1 , 12 , 15 , 26 , 38 } ; int b [ ] = { 2 , 13 , 24 } ; int n1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int n2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; printf ( " % f " , findmedian ( a , n1 , b , n2 ) ) ; return 0 ; }
void printNSE ( int arr [ ] , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = -1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } cout << arr [ i ] << " ▁ - - ▁ " << next << endl ; } }
int main ( ) { int arr [ ] = { 11 , 13 , 21 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNSE ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int longestSubarray ( int input [ ] , int length ) { int prev = -1 ; int current , next ; int prevCount = 0 , currentCount = 1 ;
int longest = 1 ;
current = input [ 0 ] ; for ( int i = 1 ; i < length ; i ++ ) { next = input [ i ] ;
if ( next == current ) { currentCount ++ ; }
else if ( next == prev ) { prevCount += currentCount ; prev = current ; current = next ; currentCount = 1 ; }
else { longest = max ( longest , currentCount + prevCount ) ; prev = current ; prevCount = currentCount ; current = next ; currentCount = 1 ; } } return max ( longest , currentCount + prevCount ) ; }
int main ( ) { int input [ ] = { 5 , 5 , 6 , 7 , 6 } ; int n = sizeof ( input ) / sizeof ( int ) ; cout << longestSubarray ( input , n ) ; return 0 ; }
int binarySearch ( int * searchSpace , int s , int e , int num ) { int ans ; while ( s <= e ) { int mid = ( s + e ) / 2 ; if ( searchSpace [ mid ] >= num ) { ans = mid ; e = mid - 1 ; } else s = mid + 1 ; } return ans ; }
int longestSubArr ( int * arr , int n ) {
int j = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) {
if ( j == 0 or searchSpace [ j - 1 ] < arr [ i ] ) { searchSpace [ j ] = arr [ i ] ; index [ j ] = i ; j ++ ; }
int idx = binarySearch ( searchSpace , 0 , j - 1 , arr [ i ] ) ;
ans = max ( ans , i - index [ idx ] + 1 ) ; } return ans ; }
int main ( int argc , char const * argv [ ] ) { int arr [ ] = { -5 , -1 , 7 , 5 , 1 , -2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestSubArr ( arr , n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; }
int main ( ) { string s1 = " geeks " , s2 = " geeksforgeeks " ;
bool result = isSuffix ( s1 , s2 ) ; if ( result ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool oneSeen = false ;
int i = 0 , n = s . length ( ) ; while ( i < n ) {
if ( s [ i ] == c ) { if ( oneSeen == true ) return false ;
while ( i < n && s [ i ] == c ) i ++ ;
oneSeen = true ; } else i ++ ; } return true ; }
int main ( ) { string s = "110029" ; if ( checkIfAllTogether ( s , '1' ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool search ( int arr [ ] , int n , int x ) {
int front = 0 , back = n - 1 ;
while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; }
int main ( ) { int arr [ ] = { 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 } ; int x = 130 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( search ( arr , n , x ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( max ( X , Y ) / min ( X , Y ) ) ; else return ( max ( 2 * X , Y ) / min ( 2 * X , Y ) ) ; }
int X = 1 , Y = 2 , P = 1 ; cout << findValue ( X , Y , P ) << endl ;
X = 3 , Y = 7 , P = 2 ; cout << findValue ( X , Y , P ) << endl ; }
int sum ( int arr [ ] , int from , int to ) { int total = 0 ; for ( int i = from ; i <= to ; i ++ ) total += arr [ i ] ; return total ; }
int findMax ( int arr [ ] , int n , int k ) {
int dp [ k + 1 ] [ n + 1 ] = { 0 } ;
for ( int i = 1 ; i <= n ; i ++ ) dp [ 1 ] [ i ] = sum ( arr , 0 , i - 1 ) ;
for ( int i = 1 ; i <= k ; i ++ ) dp [ i ] [ 1 ] = arr [ 0 ] ;
for ( int j = 2 ; j <= n ; j ++ ) {
int best = INT_MAX ;
for ( int p = 1 ; p <= j ; p ++ ) best = min ( best , max ( dp [ i - 1 ] [ p ] , sum ( arr , p , j - 1 ) ) ) ; dp [ i ] [ j ] = best ; } }
return dp [ k ] [ n ] ; }
int main ( ) { int arr [ ] = { 10 , 20 , 60 , 50 , 30 , 40 } ;
int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << findMax ( arr , n , k ) << endl ; return 0 ; }
int countCrossLine ( int arr [ ] , int n ) { int count_crossline = 0 ; int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ;
while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ;
count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; }
int main ( ) { int arr [ ] = { 4 , 3 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countCrossLine ( arr , n ) << endl ; return 0 ; }
int findMaxRec ( int A [ ] , int n ) {
if ( n == 1 ) return A [ 0 ] ; return max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; }
int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , -50 , 10 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ;
cout << findMaxRec ( A , n ) ; return 0 ; }
int mod ( int x ) { if ( x >= 0 ) return x ; return - x ; }
void findSquare ( int n ) { int points [ n ] [ 2 ] = { { 1 , 2 } , { -3 , 4 } , { 1 , 78 } , { -3 , -7 } } ; int a [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) { int x , y ; x = points [ i ] [ 0 ] ; y = points [ i ] [ 1 ] ; a [ i ] = max ( mod ( x ) , mod ( y ) ) ; }
sort ( a , a + n ) ;
int index = floor ( n / 2 ) - 1 ; cout << " Minimum ▁ M ▁ required ▁ is : ▁ " << a [ index ] << endl ; }
int main ( ) { int N ; N = 4 ; findSquare ( N ) ; return 0 ; }
void odd_even ( int arr [ ] , int n ) {
vector < int > odd_indexes ; vector < int > even_indexes ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( i % 2 == 0 ) odd_indexes . push_back ( arr [ i ] ) ;
else even_indexes . push_back ( arr [ i ] ) ; }
sort ( odd_indexes . begin ( ) , odd_indexes . end ( ) ) ; sort ( even_indexes . begin ( ) , even_indexes . end ( ) ) ; for ( int i = 0 ; i < odd_indexes . size ( ) ; i ++ ) cout << odd_indexes [ i ] << " ▁ " ; for ( int i = 0 ; i < even_indexes . size ( ) ; i ++ ) cout << even_indexes [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 3 , 2 , 7 , 6 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; odd_even ( arr , n ) ; }
int minimumIncrease ( int a , int b , int c ) {
int arr [ ] = { a , b , c } ;
sort ( arr , arr + 3 ) ;
if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; }
int main ( ) { int a = 3 , b = 5 , c = 10 ; cout << minimumIncrease ( a , b , c ) ; return 0 ; }
int absSumDidd ( int a [ ] , int n ) {
sort ( a , a + n ) ;
int midValue = a [ ( int ) ( n / 2 ) ] ;
int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + abs ( a [ i ] - midValue ) ; } return sum ; }
int main ( ) { int arr [ ] = { 5 , 11 , 14 , 10 , 17 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << absSumDidd ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26
int binomialCoeff ( int n , int k ) { int res = 1 ;
if ( k > n - k ) k = n - k ;
for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int countSubsequences ( string str1 , string str2 ) {
int freq1 [ SIZE ] , freq2 [ SIZE ] ; int n1 = str1 . size ( ) ; int n2 = str2 . size ( ) ;
memset ( freq1 , 0 , sizeof ( freq1 ) ) ; memset ( freq2 , 0 , sizeof ( freq2 ) ) ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ;
int count = 1 ; for ( int i = 0 ; i < SIZE ; i ++ )
if ( freq2 [ i ] != 0 ) {
if ( freq2 [ i ] <= freq1 [ i ] ) count = count * binomialCoeff ( freq1 [ i ] , freq2 [ i ] ) ;
else return 0 ; }
return count ; }
int main ( ) { string str1 = " abacd " ; string str2 = " abc " ; cout << " Count ▁ = ▁ " << countSubsequences ( str1 , str2 ) ; return 0 ; }
int findOccurrences ( string str , string substr ) {
int counter = 0 ;
for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) {
for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) { if ( str [ j ] == substr [ 1 ] ) {
for ( int k = j + 1 ; k < str . length ( ) ; k ++ ) {
if ( str [ k ] == substr [ 2 ] ) counter ++ ; } } } } } return counter ; }
int main ( ) { string str = " GFGFGYSYIOIWIN " ; string substr = " GFG " ; cout << findOccurrences ( str , substr ) ; return 0 ; }
int findOccurrences ( string str , string substr ) {
int n = str . length ( ) ;
int preLeft [ n ] = { 0 } ;
int preRight [ n ] = { 0 } ; if ( str [ 0 ] == substr [ 0 ] ) preLeft [ 0 ] ++ ;
for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) preLeft [ i ] = preLeft [ i - 1 ] + 1 ; else preLeft [ i ] = preLeft [ i - 1 ] ; } if ( str [ n - 1 ] == substr [ 2 ] ) preRight [ n - 1 ] ++ ;
for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == substr [ 2 ] ) preRight [ i ] = preRight [ i + 1 ] + 1 ; else preRight [ i ] = preRight [ i + 1 ] ; }
int counter = 0 ;
for ( int i = 1 ; i < n - 1 ; i ++ ) {
if ( str [ i ] == str [ 1 ] ) {
int total = preLeft [ i - 1 ] * preRight [ i + 1 ] ; counter += total ; } } return counter ; }
int main ( ) { string str = " GFGFGYSYIOIWIN " ; string substr = " GFG " ; cout << findOccurrences ( str , substr ) ; return 0 ; }
void findString ( string str , int n , int k ) {
if ( k == 0 ) { cout << str << endl ; return ; }
string str2 = str ; int p = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( str2 [ i ] != ' a ' ) {
str2 [ i ] = ' a ' ; p ++ ;
if ( p == k ) break ; } }
if ( p < k ) {
for ( int i = n - 1 ; i >= 0 ; i -- ) if ( str [ i ] == ' a ' ) { str2 [ i ] = ' b ' ; p ++ ; if ( p == k ) break ; } } cout << str2 << endl ; }
int main ( ) { string str = " pqrs " ; int n = str . length ( ) ; int k = 2 ; findString ( str , n , k ) ; return 0 ; }
void printSubsequences ( string str ) { int n = str . length ( ) ; unsigned int opsize = pow ( 2 , n - 1 ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << str [ j ] ; if ( counter & ( 1 << j ) ) cout << " ▁ " ; } cout << endl ; } }
int main ( ) { string str = " ABC " ; printSubsequences ( str ) ; return 0 ; }
int countDeletions ( string str ) { int ans = 0 ; for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ )
if ( str [ i ] == str [ i + 1 ] ) ans ++ ; return ans ; }
int main ( ) { string str = " AAABBB " ;
cout << countDeletions ( str ) ; return 0 ; }
string evenlength ( string n ) {
string res = n ;
for ( int j = n . length ( ) - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; }
int main ( ) { string n = "10" ;
cout << evenlength ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool uniqueCharacters ( string str ) {
for ( int i = 0 ; i < str . length ( ) - 1 ; i ++ ) { for ( int j = i + 1 ; j < str . length ( ) ; j ++ ) { if ( str [ i ] == str [ j ] ) { return false ; } } }
return true ; }
int main ( ) { string str = " GeeksforGeeks " ; if ( uniqueCharacters ( str ) ) { cout << " The ▁ String ▁ " << str << " ▁ has ▁ all ▁ unique ▁ characters STRNEWLINE " ; } else { cout << " The ▁ String ▁ " << str << " ▁ has ▁ duplicate ▁ characters STRNEWLINE " ; } return 0 ; }
int findIndex ( string str ) { int len = str . length ( ) ; int open [ len + 1 ] , close [ len + 1 ] ; int index = -1 ; memset ( open , 0 , sizeof ( open ) ) ; memset ( close , 0 , sizeof ( close ) ) ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str [ 0 ] == ' ( ' ) open [ 1 ] = 1 ; if ( str [ len - 1 ] == ' ) ' ) close [ len - 1 ] = 1 ;
for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == ' ( ' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; }
for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ) ' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; }
if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ;
for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; }
int main ( ) { string str = " ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) " ; cout << findIndex ( str ) ; return 0 ; }
string decimalToBinary ( double num , int k_prec ) { string binary = " " ;
int Integral = num ;
double fractional = num - Integral ;
while ( Integral ) { int rem = Integral % 2 ;
binary . push_back ( rem + '0' ) ; Integral /= 2 ; }
reverse ( binary . begin ( ) , binary . end ( ) ) ;
binary . push_back ( ' . ' ) ;
while ( k_prec -- ) {
fractional *= 2 ; int fract_bit = fractional ; if ( fract_bit == 1 ) { fractional -= fract_bit ; binary . push_back ( 1 + '0' ) ; } else binary . push_back ( 0 + '0' ) ; } return binary ; }
int main ( ) { double n = 4.47 ; int k = 3 ; cout << decimalToBinary ( n , k ) << " STRNEWLINE " ; n = 6.986 , k = 5 ; cout << decimalToBinary ( n , k ) ; return 0 ; }
bool isSmaller ( string str1 , string str2 ) {
int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; if ( n1 < n2 ) return true ; if ( n2 < n1 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] < str2 [ i ] ) return true ; else if ( str1 [ i ] > str2 [ i ] ) return false ; } return false ; }
string findDiff ( string str1 , string str2 ) {
if ( isSmaller ( str1 , str2 ) ) swap ( str1 , str2 ) ;
string str = " " ;
int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n1 - n2 ;
int carry = 0 ;
for ( int i = n2 - 1 ; i >= 0 ; i -- ) {
int sub = ( ( str1 [ i + diff ] - '0' ) - ( str2 [ i ] - '0' ) - carry ) ; if ( sub < 0 ) { sub = sub + 10 ; carry = 1 ; } else carry = 0 ; str . push_back ( sub + '0' ) ; }
for ( int i = n1 - n2 - 1 ; i >= 0 ; i -- ) { if ( str1 [ i ] == '0' && carry ) { str . push_back ( '9' ) ; continue ; } int sub = ( ( str1 [ i ] - '0' ) - carry ) ;
str . push_back ( sub + '0' ) ; carry = 0 ; }
reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
int main ( ) { string str1 = "88" ; string str2 = "1079" ;
cout << findDiff ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ;
bool areKAnagrams ( string str1 , string str2 , int k ) {
int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int hash_str1 [ MAX_CHAR ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 [ i ] - ' a ' ] ++ ;
int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 [ i ] - ' a ' ] > 0 ) hash_str1 [ str2 [ i ] - ' a ' ] -- ; else count ++ ; if ( count > k ) return false ; }
return true ; }
int main ( ) { string str1 = " fodr " ; string str2 = " gork " ; int k = 2 ; if ( areKAnagrams ( str1 , str2 , k ) == true ) cout << " Yes " ; else cout << " No " ; return 0 ; }
char getDigit ( int N , int d ) { string str ; stringstream ss ; ss << N ; ss >> str ; return str [ d - 1 ] ; }
char getNthChar ( int N ) {
int sum = 0 , nine = 9 ;
int dist = 0 , len ;
for ( len = 1 ; ; len ++ ) {
sum += nine * len ; dist += nine ; if ( sum >= N ) {
sum -= nine * len ; dist -= nine ; N -= sum ; break ; } nine *= 10 ; }
int diff = ceil ( ( double ) N / len ) ;
int d = N % len ; if ( d == 0 ) d = len ;
return getDigit ( dist + diff , d ) ; }
int main ( ) { int N = 251 ; cout << getNthChar ( N ) << endl ; return 0 ; }
for ( int i = 0 ; i < str . size ( ) ; i ++ )
if ( i == ( str [ i ] - ' a ' ) || i == ( str [ i ] - ' A ' ) ) result ++ ; return result ; }
int main ( ) { string str = " AbgdeF " ; cout << findCount ( str ) ; return 0 ; }
void print ( string str , int index ) { if ( index == str . size ( ) ) { cout << str << endl ; return ; } if ( str [ index ] == ' ? ' ) {
str [ index ] = '0' ; print ( str , index + 1 ) ;
str [ index ] = '1' ; print ( str , index + 1 ) ;
} else print ( str , index + 1 ) ; }
int main ( ) { string str = "1 ? ? 0?101" ; print ( str , 0 ) ; return 0 ; }
int countOccurrences ( long int x , int d ) {
while ( x ) {
if ( x % 10 == d ) count ++ ; x = x / 10 ; } return count ; }
int maxOccurring ( long int x ) {
if ( x < 0 ) x = - x ;
for ( int d = 0 ; d <= 9 ; d ++ ) {
int count = countOccurrences ( x , d ) ;
if ( count >= max_count ) { max_count = count ; result = d ; } } return result ; }
int main ( ) { long int x = 1223355 ; cout << " Max ▁ occurring ▁ digit ▁ is ▁ " << maxOccurring ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSubarrayXOR ( int arr [ ] , int n ) {
int ans = INT_MIN ;
for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = max ( ans , curr_xor ) ; } } return ans ; }
int main ( ) { int arr [ ] = { 8 , 1 , 2 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Max ▁ subarray ▁ XOR ▁ is ▁ " << maxSubarrayXOR ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define NO_OF_CHARS  256
int * getCharCountArray ( char * str ) { int * count = ( int * ) calloc ( sizeof ( int ) , NO_OF_CHARS ) ; int i ; for ( i = 0 ; * ( str + i ) ; i ++ ) count [ * ( str + i ) ] ++ ; return count ; }
int firstNonRepeating ( char * str ) { int * count = getCharCountArray ( str ) ; int index = -1 , i ; for ( i = 0 ; * ( str + i ) ; i ++ ) { if ( count [ * ( str + i ) ] == 1 ) { index = i ; break ; } }
int main ( ) { char str [ ] = " geeksforgeeks " ; int index = firstNonRepeating ( str ) ; if ( index == -1 ) cout << " Either ▁ all ▁ characters ▁ are ▁ repeating ▁ or ▁ " " string ▁ is ▁ empty " ; else cout << " First ▁ non - repeating ▁ character ▁ is ▁ " << str [ index ] ; getchar ( ) ; return 0 ; }
public : void divideString ( char str [ ] , int n ) { int str_size = strlen ( str ) ; int i ; int part_size ;
if ( str_size % n != 0 ) { cout << " Invalid ▁ Input : ▁ String ▁ size " ; cout << " ▁ is ▁ not ▁ divisible ▁ by ▁ n " ; return ; }
part_size = str_size / n ; for ( i = 0 ; i < str_size ; i ++ ) { if ( i % part_size == 0 ) cout << endl ; cout << str [ i ] ; } } } ;
char str [ ] = " a _ simple _ divide _ string _ quest " ;
g . divideString ( str , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000009 NEW_LINE #define ll  long long int NEW_LINE ll power ( ll n ) { if ( n <= 1 ) return 1 ;
n -- ;
ll res [ 2 ] [ 2 ] = { 1 , 0 , 0 , 1 } ;
ll tMat [ 2 ] [ 2 ] = { 2 , 3 , 1 , 0 } ;
while ( n ) { if ( n & 1 ) { ll tmp [ 2 ] [ 2 ] ; tmp [ 0 ] [ 0 ] = ( res [ 0 ] [ 0 ] * tMat [ 0 ] [ 0 ] + res [ 0 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 0 ] [ 1 ] = ( res [ 0 ] [ 0 ] * tMat [ 0 ] [ 1 ] + res [ 0 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; tmp [ 1 ] [ 0 ] = ( res [ 1 ] [ 0 ] * tMat [ 0 ] [ 0 ] + res [ 1 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 1 ] [ 1 ] = ( res [ 1 ] [ 0 ] * tMat [ 0 ] [ 1 ] + res [ 1 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; res [ 0 ] [ 0 ] = tmp [ 0 ] [ 0 ] ; res [ 0 ] [ 1 ] = tmp [ 0 ] [ 1 ] ; res [ 1 ] [ 0 ] = tmp [ 1 ] [ 0 ] ; res [ 1 ] [ 1 ] = tmp [ 1 ] [ 1 ] ; } n = n / 2 ; ll tmp [ 2 ] [ 2 ] ; tmp [ 0 ] [ 0 ] = ( tMat [ 0 ] [ 0 ] * tMat [ 0 ] [ 0 ] + tMat [ 0 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 0 ] [ 1 ] = ( tMat [ 0 ] [ 0 ] * tMat [ 0 ] [ 1 ] + tMat [ 0 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; tmp [ 1 ] [ 0 ] = ( tMat [ 1 ] [ 0 ] * tMat [ 0 ] [ 0 ] + tMat [ 1 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 1 ] [ 1 ] = ( tMat [ 1 ] [ 0 ] * tMat [ 0 ] [ 1 ] + tMat [ 1 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; tMat [ 0 ] [ 0 ] = tmp [ 0 ] [ 0 ] ; tMat [ 0 ] [ 1 ] = tmp [ 0 ] [ 1 ] ; tMat [ 1 ] [ 0 ] = tmp [ 1 ] [ 0 ] ; tMat [ 1 ] [ 1 ] = tmp [ 1 ] [ 1 ] ; }
return ( res [ 0 ] [ 0 ] * 1 + res [ 0 ] [ 1 ] * 1 ) % MOD ; }
int main ( ) { ll n = 3 ; cout << power ( n ) ; return 0 ; }
bool isFeasible ( int mid , int arr [ ] , int n , int k ) {
int pos = arr [ 0 ] ;
int elements = 1 ;
for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - pos >= mid ) {
pos = arr [ i ] ; elements ++ ;
if ( elements == k ) return true ; } } return 0 ; }
int largestMinDist ( int arr [ ] , int n , int k ) {
sort ( arr , arr + n ) ;
int res = -1 ;
int left = 1 , right = arr [ n - 1 ] ;
while ( left < right ) { int mid = ( left + right ) / 2 ;
if ( isFeasible ( mid , arr , n , k ) ) {
res = max ( res , mid ) ; left = mid + 1 ; }
else right = mid ; } return res ; }
int main ( ) { int arr [ ] = { 1 , 2 , 8 , 4 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << largestMinDist ( arr , n , k ) ; return 0 ; }
int countOdd ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i & 1 ) {
m = ( n - i ) / 2 ;
j = ( i * ( i + 1 ) ) / 2 ;
coun += j * m ; } else {
m = ( ( n - 1 ) - i ) / 2 ;
j = ( i * ( i + 1 ) ) / 2 ;
coun += j * m ; } } return coun ; }
int countEven ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i & 1 ) { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; }
int main ( ) { int n = 5 ;
if ( n & 1 ) cout << countOdd ( n ) ; else cout << countEven ( n ) ; return 0 ; }
float ellipse ( float l , float b ) {
if ( l < 0 b < 0 ) return -1 ;
float x = ( 3.14 * l * b ) / 4 ; return x ; }
int main ( ) { float l = 5 , b = 3 ; cout << ellipse ( l , b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = abs ( x2 - x1 ) ; int dy = abs ( y2 - y1 ) ; int ans = dx + dy - __gcd ( dx , dy ) ; cout << ans ; }
int main ( ) { int x1 = 1 , y1 = 1 , x2 = 4 , y2 = 3 ; noOfSquares ( x1 , y1 , x2 , y2 ) ; return 0 ; }
ll binomialCoeff ( int n , int k ) { ll res = 1 ;
if ( k > n - k ) k = n - k ;
for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
ll countPaths ( int x1 , int y1 , int x2 , int y2 ) {
int m = abs ( x1 - x2 ) ;
int n = abs ( y1 - y2 ) ; return ( binomialCoeff ( m + n , n ) ) ; }
int main ( ) { int x1 = 2 , y1 = 3 , x2 = 4 , y2 = 5 ; cout << countPaths ( x1 , y1 , x2 , y2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define pi  3.1415926
double areaCircle ( double b ) { double area = pi * b * b ; return area ; }
int main ( ) { double a = 10 , b = 8 ; cout << areaCircle ( b ) ; return 0 ; }
void section ( double x1 , double x2 , double y1 , double y2 , double z1 , double z2 , double m , double n ) {
double x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; double y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; double z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ;
cout << " ( " << x << " , ▁ " ; cout << y << " , ▁ " ; cout << z << " ) " << endl ; }
int main ( ) { double x1 = 2 , x2 = 4 , y1 = -1 , y2 = 3 , z1 = 4 , z2 = 2 , m = 2 , n = 3 ; section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) ; return 0 ; }
float findRadiusOfcircumcircle ( float n , float a ) {
if ( n < 0 a < 0 ) return -1 ;
float radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) ;
return radius ; }
int main ( ) { float n = 5 , a = 6 ;
cout << findRadiusOfcircumcircle ( n , a ) << endl ; return 0 ; }
float findRadiusOfIncircle ( float a , float b , float c ) {
if ( a < 0 b < 0 c < 0 ) return -1 ;
float p = ( a + b + c ) / 2 ;
float area = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ;
float radius = area / p ;
return radius ; }
float a = 2 , b = 2 , c = 3 ;
cout << findRadiusOfIncircle ( a , b , c ) << endl ; return 0 ; }
float area ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { float area = sqrt ( pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; area = area / 2 ; return area ; }
int main ( ) { intx1 = -2 ; int y1 = 0 ; int z1 = -5 ; int x2 = 1 ; int y2 = -2 ; int z2 = -1 ; float a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) ; cout << " Area ▁ = ▁ " << a << endl ; return 0 ; }
float trapezoidarea ( float r ) {
if ( r < 0 ) return -1 ;
float a = ( 3 * sqrt ( 3 ) * pow ( r , 2 ) ) / 4 ; return a ; }
int main ( ) { float r = 5 ; cout << trapezoidarea ( r ) << endl ; return 0 ; }
float rectanglearea ( float r ) {
if ( r < 0 ) return -1 ;
float a = r * r ; return a ; }
int main ( ) { float r = 5 ; cout << rectanglearea ( r ) << endl ; return 0 ; }
int maxLines ( int n , int x1 [ ] , int y1 [ ] , int x2 [ ] , int y2 [ ] ) { unordered_set < double > s ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = INT_MAX ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . insert ( slope ) ; } return s . size ( ) ; }
int main ( ) { int n = 2 , x1 [ ] = { 1 , 2 } , y1 [ ] = { 1 , 2 } , x2 [ ] = { 2 , 4 } , y2 [ ] = { 2 , 10 } ; cout << maxLines ( n , x1 , y1 , x2 , y2 ) ; return 0 ; }
float area ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float area = sqrt ( pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; return area ; }
int main ( ) { float x1 = 3 ; float y1 = 1 ; float z1 = -2 ; float x2 = 1 ; float y2 = -3 ; float z2 = 4 ; float a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) ; cout << " Area ▁ = ▁ " << a ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_intersection ( int * center , int length , int k ) { sort ( center , center + 3 ) ;
if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) { return 0 ; }
else if ( center [ 2 ] - center [ 0 ] >= 2 * k ) { return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; }
else return length ; }
int main ( ) { int center [ 3 ] = { 1 , 2 , 3 } ; int L = 1 ; int K = 1 ; cout << max_intersection ( center , L , K ) ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE using namespace std ; static double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) {
double dLat = ( lat2 - lat1 ) * M_PI / 180.0 ; double dLon = ( lon2 - lon1 ) * M_PI / 180.0 ;
lat1 = ( lat1 ) * M_PI / 180.0 ; lat2 = ( lat2 ) * M_PI / 180.0 ;
double a = pow ( sin ( dLat / 2 ) , 2 ) + pow ( sin ( dLon / 2 ) , 2 ) * cos ( lat1 ) * cos ( lat2 ) ; double rad = 6371 ; double c = 2 * asin ( sqrt ( a ) ) ; return rad * c ; }
int main ( ) { double lat1 = 51.5007 ; double lon1 = 0.1246 ; double lat2 = 40.6892 ; double lon2 = 74.0445 ; cout << haversine ( lat1 , lon1 , lat2 , lon2 ) << " ▁ K . M . " ; return 0 ; }
int pentatopeNum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) ) / 24 ; }
int n = 5 ; cout << pentatopeNum ( n ) << endl ;
n = 11 ; cout << pentatopeNum ( n ) << endl ; return 0 ; }
int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; }
int main ( ) { int n = 2 ; cout << heptagonalNumber ( n ) << endl ; n = 15 ; cout << heptagonalNumber ( n ) << endl ; return 0 ; }
int icosidigonal_num ( long int n ) {
return ( 20 * n * n - 18 * n ) / 2 ; }
int main ( ) { long int n = 4 ; cout << n << " th ▁ Icosidigonal ▁ number ▁ : " << icosidigonal_num ( n ) ; cout << endl ; n = 8 ; cout << n << " th ▁ Icosidigonal ▁ number : " << icosidigonal_num ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ;
int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; }
int main ( ) { int n = 4 ; cout << power ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findPoint ( int x1 , int y1 , int x2 , int y2 ) { cout << " ( " << 2 * x2 - x1 << " , ▁ " << 2 * y2 - y1 << " ) " ; }
int main ( ) { int x1 = 0 , y1 = 0 , x2 = 1 , y2 = 1 ; findPoint ( x1 , y1 , x2 , y2 ) ; return 0 ; }
void parallel ( int n , int a [ ] [ 2 ] ) { bool x = true , y = true ;
for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; }
if ( x ) cout << " parallel ▁ to ▁ Y ▁ Axis " << endl ; else if ( y ) cout << " parallel ▁ to ▁ X ▁ Axis " << endl ; else cout << " Not ▁ parallel ▁ to ▁ X " << " ▁ and ▁ Y ▁ Axis " << endl ; }
int main ( ) { int a [ ] [ 2 ] = { { 1 , 2 } , { 1 , 4 } , { 1 , 6 } , { 1 , 0 } } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; parallel ( n , a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; }
int main ( ) { cout << numberOfSticks ( 7 ) ; return 0 ; }
int find_Area ( int r ) { return ( 2 * r * r ) ; }
int r = 3 ;
cout << " ▁ Area ▁ of ▁ square ▁ = ▁ " << find_Area ( r ) ; return 0 ; }
bool checkValidity ( int a , int b , int c ) {
if ( a + b <= c a + c <= b b + c <= a ) return false ; else return true ; }
int main ( ) { int a = 7 , b = 10 , c = 5 ;
if ( checkValidity ( a , b , c ) ) cout << " Valid " ; else cout << " Invalid " ; }
const int M = 3 ; const int N = 3 ;
int contribution_height ( int current , int previous ) { return abs ( current - previous ) ; }
int surfaceArea ( int A [ N ] [ M ] ) { int ans = 0 ;
for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) {
int up = 0 ;
int left = 0 ;
if ( i > 0 ) up = A [ i - 1 ] [ j ] ;
if ( j > 0 ) left = A [ i ] [ j - 1 ] ;
ans += contribution_height ( A [ i ] [ j ] , up ) + contribution_height ( A [ i ] [ j ] , left ) ;
if ( i == N - 1 ) ans += A [ i ] [ j ] ;
if ( j == M - 1 ) ans += A [ i ] [ j ] ; } }
ans += N * M * 2 ; return ans ; }
int main ( ) { int A [ N ] [ M ] = { { 1 , 3 , 4 } , { 2 , 2 , 3 } , { 1 , 2 , 4 } } ; cout << surfaceArea ( A ) << endl ; return 0 ; }
double area_of_tetrahedron ( int side ) { return ( sqrt ( 3 ) * ( side * side ) ) ; }
int main ( ) { int side = 3 ; cout << " Area ▁ of ▁ Tetrahedron ▁ = " << area_of_tetrahedron ( side ) ; }
double vol_tetra ( int side ) { double volume = ( pow ( side , 3 ) / ( 6 * sqrt ( 2 ) ) ) ; return volume ; }
int main ( ) { int side = 3 ; double vol = vol_tetra ( side ) ; vol = ( double ) round ( vol * 100 ) / 100 ; cout << vol ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int numberOfWays ( int x ) { int dp [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; }
int main ( ) { int x = 3 ; cout << numberOfWays ( x ) << endl ; return 0 ; }
float area_equi_triangle ( float side ) { return sqrt ( 3 ) / 4 * side * side ; }
float peri_equi_triangle ( float side ) { return 3 * side ; }
int main ( ) { float side = 4 ; cout << " Area ▁ of ▁ Equilateral ▁ Triangle : ▁ " << area_equi_triangle ( side ) << endl ; cout << " Perimeter ▁ of ▁ Equilateral ▁ Triangle : ▁ " << peri_equi_triangle ( side ) ; return 0 ; }
double areaCuboid ( double l , double h , double w ) { return ( l * h * w ) ; } double surfaceAreaCuboid ( double l , double h , double w ) { return ( 2 * l * w + 2 * w * h + 2 * l * h ) ; }
int main ( ) { double l = 1 ; double h = 5 ; double w = 7 ; cout << " Area ▁ = ▁ " << areaCuboid ( l , h , w ) << endl ; cout << " Total ▁ Surface ▁ Area ▁ = ▁ " << surfaceAreaCuboid ( l , h , w ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define PI  3.1415
double circumference ( double r ) { double cir = 2 * PI * r ; return cir ; }
int main ( ) { double r = 5 ; cout << " Circumference ▁ = ▁ " << circumference ( r ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; }
int main ( ) { int n = 5 , m = 4 ; cout << rectCount ( n , m ) ; return 0 ; }
int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; }
int main ( ) { int n = 5 ; printf ( " % d " , countRect ( n ) ) ; return 0 ; }
int main ( ) {
int ax = 5 , ay = 0 ;
int bx = 1 , by = 1 ;
int cx = 2 , cy = 5 ; cout << ax + cx - bx << " , ▁ " << ay + cy - by ; return 0 ; }
void bestApproximate ( int x [ ] , int y [ ] , int n ) { float m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; cout << " m ▁ = " << m ; cout << " c = " }
int main ( ) { int x [ ] = { 1 , 2 , 3 , 4 , 5 } ; int y [ ] = { 14 , 27 , 40 , 55 , 68 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; bestApproximate ( x , y , n ) ; return 0 ; }
#define size  4
bool checkStar ( int mat [ ] [ size ] ) {
int vertexD1 = 0 , vertexDn_1 = 0 ;
if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ;
if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ;
for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; }
int main ( ) { int mat [ size ] [ size ] = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } } ; checkStar ( mat ) ? cout << " Star ▁ Graph " : cout << " Not ▁ a ▁ Star ▁ Graph " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getMinSteps ( int n ) { int table [ n + 1 ] ; table [ 1 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ! ( i % 2 ) && ( i % 3 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , table [ i / 2 ] ) ; else if ( ! ( i % 3 ) && ( i % 2 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , table [ i / 3 ] ) ; else if ( ! ( i % 2 ) && ! ( i % 3 ) ) table [ i ] = 1 + min ( table [ i - 1 ] , min ( table [ i / 2 ] , table [ i / 3 ] ) ) ; else table [ i ] = 1 + table [ i - 1 ] ; } return table [ n ] ; }
int main ( ) { int n = 14 ; cout << getMinSteps ( n ) ; return 0 ; }
bool isVowel ( char c ) { string vowel = " aeiou " ; for ( int i = 0 ; i < vowel . length ( ) ; ++ i ) if ( vowel [ i ] == c ) return true ; return false ; }
bool printRLE ( string str , string typed ) { int n = str . length ( ) , m = typed . length ( ) ;
int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( str [ i ] != typed [ j ] ) return false ;
if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; }
int count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; }
int count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) return false ; } return true ; }
int main ( ) { string name = " alex " , typed = " aaalaeex " ; if ( printRLE ( name , typed ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool check ( int degree [ ] , int n ) {
int deg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) deg_sum += degree [ i ] ;
return ( 2 * ( n - 1 ) == deg_sum ) ; }
int main ( ) { int n = 5 ; int degree [ ] = { 2 , 3 , 1 , 1 , 1 } ; if ( check ( degree , n ) ) cout << " Tree " ; else cout << " Graph " ; return 0 ; }
bool isInorder ( int arr [ ] , int n ) {
if ( n == 0 n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ )
if ( arr [ i - 1 ] > arr [ i ] ) return false ;
return true ; }
int main ( ) { int arr [ ] = { 19 , 23 , 25 , 30 , 45 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isInorder ( arr , n ) ) cout << " Yesn " ; else cout << " Non " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSorted ( int arr [ ] , int start , int end ) { if ( start > end ) return ;
printSorted ( arr , start * 2 + 1 , end ) ;
cout << arr [ start ] << " ▁ " ;
printSorted ( arr , start * 2 + 2 , end ) ; }
int main ( ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 } ; int arr_size = sizeof ( arr ) / sizeof ( int ) ; printSorted ( arr , 0 , arr_size - 1 ) ; getchar ( ) ; return 0 ; }
bool isLeaf ( int pre [ ] , int & i , int n , int min , int max ) { if ( i >= n ) return false ; if ( pre [ i ] > min && pre [ i ] < max ) { i ++ ; bool left = isLeaf ( pre , i , n , min , pre [ i - 1 ] ) ; bool right = isLeaf ( pre , i , n , pre [ i - 1 ] , max ) ; if ( ! left && ! right ) cout << pre [ i - 1 ] << " ▁ " ; return true ; } return false ; } void printLeaves ( int preorder [ ] , int n ) { int i = 0 ; isLeaf ( preorder , i , n , INT_MIN , INT_MAX ) ; }
int main ( ) { int preorder [ ] = { 890 , 325 , 290 , 530 , 965 } ; int n = sizeof ( preorder ) / sizeof ( preorder [ 0 ] ) ; printLeaves ( preorder , n ) ; return 0 ; }
void pairs ( int arr [ ] , int n , int k ) {
int smallest = INT_MAX ; int count = 0 ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) {
if ( abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; }
else if ( abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; }
cout << " Minimal ▁ Value ▁ = ▁ " << smallest << " STRNEWLINE " ; cout << " Total ▁ Pairs ▁ = ▁ " << count << " STRNEWLINE " ; }
int main ( ) { int arr [ ] = { 3 , 5 , 7 , 5 , 1 , 9 , 9 } ; int k = 12 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pairs ( arr , n , k ) ; return 0 ; }
int main ( ) { int a [ ] = { 5 , 1 , 14 , 4 , 15 , 9 , 7 , 20 , 11 } ; int key = 20 ; int arraySize = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int count = 0 ; for ( int i = 0 ; i < arraySize ; i ++ ) { if ( a [ i ] <= key ) { count += 1 ; } } cout << " Rank ▁ of ▁ " << key << " ▁ in ▁ stream ▁ is : ▁ " << count - 1 << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; void middlesum ( int mat [ ] [ MAX ] , int n ) { int row_sum = 0 , col_sum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 ] [ i ] ; cout << " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " << row_sum << endl ;
for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ n / 2 ] ; cout << " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " << col_sum ; }
int main ( ) { int mat [ ] [ MAX ] = { { 2 , 5 , 7 } , { 3 , 7 , 2 } , { 5 , 6 , 9 } } ; middlesum ( mat , 3 ) ; return 0 ; }
#define M  3 NEW_LINE #define N  3 NEW_LINE using namespace std ;
void rotateMatrix ( int matrix [ ] [ M ] , int k ) {
int temp [ M ] ;
k = k % M ; for ( int i = 0 ; i < N ; i ++ ) {
for ( int t = 0 ; t < M - k ; t ++ ) temp [ t ] = matrix [ i ] [ t ] ;
for ( int j = M - k ; j < M ; j ++ ) matrix [ i ] [ j - M + k ] = matrix [ i ] [ j ] ;
for ( int j = k ; j < M ; j ++ ) matrix [ i ] [ j ] = temp [ j - k ] ; } }
void displayMatrix ( int matrix [ ] [ M ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) cout << matrix [ i ] [ j ] << " ▁ " ; cout << endl ; } }
int main ( ) { int matrix [ N ] [ M ] = { { 12 , 23 , 34 } , { 45 , 56 , 67 } , { 78 , 89 , 91 } } ; int k = 2 ;
rotateMatrix ( matrix , k ) ;
displayMatrix ( matrix ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ;
void multiply ( int mat [ ] [ N ] , int res [ ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { res [ i ] [ j ] = 0 ; for ( int k = 0 ; k < N ; k ++ ) res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] ; } } }
bool InvolutoryMatrix ( int mat [ N ] [ N ] ) { int res [ N ] [ N ] ;
multiply ( mat , res ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j && res [ i ] [ j ] != 1 ) return false ; if ( i != j && res [ i ] [ j ] != 0 ) return false ; } } return true ; }
int main ( ) { int mat [ N ] [ N ] = { { 1 , 0 , 0 } , { 0 , -1 , 0 } , { 0 , 0 , -1 } } ;
if ( InvolutoryMatrix ( mat ) ) cout << " Involutory ▁ Matrix " ; else cout << " Not ▁ Involutory ▁ Matrix " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define n  4 NEW_LINE void interchangeFirstLast ( int m [ ] [ n ] ) { int rows = n ;
for ( int i = 0 ; i < n ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } }
int m [ n ] [ n ] = { { 8 , 9 , 7 , 6 } , { 4 , 7 , 6 , 5 } , { 3 , 2 , 1 , 8 } , { 9 , 9 , 7 , 7 } } ; interchangeFirstLast ( m ) ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << m [ i ] [ j ] << " ▁ " ; cout << endl ; } }
#include <iostream> NEW_LINE using namespace std ; #define n  3 NEW_LINE bool checkMarkov ( double m [ ] [ n ] ) {
for ( int i = 0 ; i < n ; i ++ ) {
double sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; }
double m [ 3 ] [ 3 ] = { { 0 , 0 , 1 } , { 0.5 , 0 , 0.5 } , { 1 , 0 , 0 } } ;
if ( checkMarkov ( m ) ) cout << " ▁ yes ▁ " ; else cout << " ▁ no ▁ " ; }
#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ;
bool isDiagonalMatrix ( int mat [ N ] [ N ] ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ )
if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; }
int main ( ) { int mat [ N ] [ N ] = { { 4 , 0 , 0 , 0 } , { 0 , 7 , 0 , 0 } , { 0 , 0 , 5 , 0 } , { 0 , 0 , 0 , 1 } } ; if ( isDiagonalMatrix ( mat ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ;
bool isScalarMatrix ( int mat [ N ] [ N ] ) {
for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ;
for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; }
int main ( ) { int mat [ N ] [ N ] = { { 2 , 0 , 0 , 0 } , { 0 , 2 , 0 , 0 } , { 0 , 0 , 2 , 0 } , { 0 , 0 , 0 , 2 } } ;
if ( isScalarMatrix ( mat ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
bool isMagicSquare ( int mat [ ] [ N ] ) {
int sum = 0 , sum2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum = sum + mat [ i ] [ i ] ;
for ( int i = 0 ; i < N ; i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ; if ( sum != sum2 ) return false ;
for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) rowSum += mat [ i ] [ j ] ;
if ( rowSum != sum ) return false ; }
for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) colSum += mat [ j ] [ i ] ;
if ( sum != colSum ) return false ; } return true ; }
int main ( ) { int mat [ ] [ N ] = { { 2 , 7 , 6 } , { 9 , 5 , 1 } , { 4 , 3 , 8 } } ; if ( isMagicSquare ( mat ) ) cout << " Magic ▁ Square " ; else cout << " Not ▁ a ▁ magic ▁ Square " ; return 0 ; }
int subCount ( int arr [ ] , int n , int k ) {
int mod [ k ] ; memset ( mod , 0 , sizeof ( mod ) ) ;
int cumSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumSum += arr [ i ] ;
mod [ ( ( cumSum % k ) + k ) % k ] ++ ; }
int result = 0 ;
for ( int i = 0 ; i < k ; i ++ )
if ( mod [ i ] > 1 ) result += ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ;
result += mod [ 0 ] ; return result ; }
int countSubmatrix ( int mat [ SIZE ] [ SIZE ] , int n , int k ) {
int tot_count = 0 ; int left , right , i ; int temp [ n ] ;
for ( left = 0 ; left < n ; left ++ ) {
memset ( temp , 0 , sizeof ( temp ) ) ;
for ( right = left ; right < n ; right ++ ) {
for ( i = 0 ; i < n ; ++ i ) temp [ i ] += mat [ i ] [ right ] ;
tot_count += subCount ( temp , n , k ) ; } }
return tot_count ; }
int main ( ) { int mat [ ] [ SIZE ] = { { 5 , -1 , 6 } , { -2 , 3 , 8 } , { 7 , 4 , -9 } } ; int n = 3 , k = 4 ; cout << " Count ▁ = ▁ " << countSubmatrix ( mat , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; }
int main ( ) { int n = 4 , k = 7 ; int freq = find ( n , k ) ; if ( freq < 0 ) cout << " ▁ element ▁ not ▁ exist ▁ STRNEWLINE ▁ " ; else cout << " ▁ Frequency ▁ of ▁ " << k << " ▁ is ▁ " << freq << " STRNEWLINE " ; return 0 ; }
void ZigZag ( int rows , int columns , int numbers [ ] ) { int k = 0 ;
int arr [ rows ] [ columns ] ; for ( int i = 0 ; i < rows ; i ++ ) {
if ( i % 2 == 0 ) {
for ( int j = 0 ; j < columns and numbers [ k ] > 0 ; j ++ ) {
arr [ i ] [ j ] = k + 1 ;
numbers [ k ] -- ;
if ( numbers [ k ] == 0 ) k ++ ; } }
else {
for ( int j = columns - 1 ; j >= 0 and numbers [ k ] > 0 ; j -- ) {
arr [ i ] [ j ] = k + 1 ;
numbers [ k ] -- ;
if ( numbers [ k ] == 0 ) k ++ ; } } }
for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) cout << arr [ i ] [ j ] << " ▁ " ; cout << endl ; } }
int main ( ) { int rows = 4 ; int columns = 5 ; int Numbers [ ] = { 3 , 4 , 2 , 2 , 3 , 1 , 5 } ; ZigZag ( rows , columns , Numbers ) ; return 0 ; }
int numberofPosition ( int n , int k , int x , int y , int obstPosx [ ] , int obstPosy [ ] ) {
int d11 , d12 , d21 , d22 , r1 , r2 , c1 , c2 ;
d11 = min ( x - 1 , y - 1 ) ; d12 = min ( n - x , n - y ) ; d21 = min ( n - x , y - 1 ) ; d22 = min ( x - 1 , n - y ) ; r1 = y - 1 ; r2 = n - y ; c1 = x - 1 ; c2 = n - x ;
for ( int i = 0 ; i < k ; i ++ ) { if ( x > obstPosx [ i ] && y > obstPosy [ i ] && x - obstPosx [ i ] == y - obstPosy [ i ] ) d11 = min ( d11 , x - obstPosx [ i ] - 1 ) ; if ( obstPosx [ i ] > x && obstPosy [ i ] > y && obstPosx [ i ] - x == obstPosy [ i ] - y ) d12 = min ( d12 , obstPosx [ i ] - x - 1 ) ; if ( obstPosx [ i ] > x && y > obstPosy [ i ] && obstPosx [ i ] - x == y - obstPosy [ i ] ) d21 = min ( d21 , obstPosx [ i ] - x - 1 ) ; if ( x > obstPosx [ i ] && obstPosy [ i ] > y && x - obstPosx [ i ] == obstPosy [ i ] - y ) d22 = min ( d22 , x - obstPosx [ i ] - 1 ) ; if ( x == obstPosx [ i ] && obstPosy [ i ] < y ) r1 = min ( r1 , y - obstPosy [ i ] - 1 ) ; if ( x == obstPosx [ i ] && obstPosy [ i ] > y ) r2 = min ( r2 , obstPosy [ i ] - y - 1 ) ; if ( y == obstPosy [ i ] && obstPosx [ i ] < x ) c1 = min ( c1 , x - obstPosx [ i ] - 1 ) ; if ( y == obstPosy [ i ] && obstPosx [ i ] > x ) c2 = min ( c2 , obstPosx [ i ] - x - 1 ) ; } return d11 + d12 + d21 + d22 + r1 + r2 + c1 + c2 ; }
int n = 8 ;
int k = 1 ;
int Qposx = 4 ;
int Qposy = 4 ;
int obstPosx [ ] = { 3 } ;
int obstPosy [ ] = { 5 } ; cout << numberofPosition ( n , k , Qposx , Qposy , obstPosx , obstPosy ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int n = 5 ;
int FindMaxProduct ( int arr [ ] [ n ] , int n ) { int max = 0 , result ;
for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = 0 ; j < n ; j ++ ) {
if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; }
if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; }
if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; }
if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ; if ( max < result ) max = result ; } } } return max ; }
int main ( ) { int arr [ ] [ 5 ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 1 } , { 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 1 , 0 } , { 9 , 6 , 4 , 2 , 3 } } ; cout << FindMaxProduct ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ;
int minimumflip ( int mat [ ] [ N ] , int n ) { int transpose [ n ] [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ;
int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; }
int main ( ) { int n = 3 ; int mat [ N ] [ N ] = { { 0 , 0 , 1 } , { 1 , 1 , 1 } , { 1 , 0 , 0 } } ; cout << minimumflip ( mat , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ;
int minimumflip ( int mat [ ] [ N ] , int n ) {
int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; }
int main ( ) { int n = 3 ; int mat [ N ] [ N ] = { { 0 , 0 , 1 } , { 1 , 1 , 1 } , { 1 , 0 , 0 } } ; cout << minimumflip ( mat , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100
void freq ( int ar [ ] [ MAX ] , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) {
if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } }
printf ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = ▁ % d ▁ STRNEWLINE " , odd ) ; printf ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ % d ▁ STRNEWLINE " , even ) ; }
int main ( ) { int m = 3 , n = 3 ; int array [ ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; freq ( array , m , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ;
bool HalfDiagonalSums ( int mat [ ] [ MAX ] , int n ) {
int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 ] [ n / 2 ] ) ; }
int main ( ) { int a [ ] [ MAX ] = { { 2 , 9 , 1 , 4 , -2 } , { 6 , 7 , 2 , 11 , 4 } , { 4 , 2 , 9 , 2 , 4 } , { 1 , 9 , 2 , 4 , 4 } , { 0 , 2 , 4 , 2 , 5 } } ; cout << ( HalfDiagonalSums ( a , 5 ) ? " Yes " : " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) {
if ( row == col ) cout << 1 << " ▁ " ; else cout << 0 << " ▁ " ; } cout << endl ; } return 0 ; }
int main ( ) { int size = 5 ; Identity ( size ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; bool isIdentity ( int mat [ ] [ MAX ] , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; }
int main ( ) { int N = 4 ; int mat [ ] [ MAX ] = { { 1 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 1 } } ; if ( isIdentity ( mat , N ) ) cout << " Yes ▁ " ; else cout << " No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define mod  100000007
long long modPower ( long long a , long long t ) { long long now = a , ret = 1 ;
while ( t ) { if ( t & 1 ) ret = now * ( ret % mod ) ; now = now * ( now % mod ) ; t >>= 1 ; } return ret ; }
long countWays ( int n , int m , int k ) {
if ( k == -1 && ( n + m ) % 2 == 1 ) return 0 ;
if ( n == 1 m == 1 ) return 1 ;
return ( modPower ( modPower ( ( long long ) 2 , n - 1 ) , m - 1 ) % mod ) ; }
int main ( ) { int n = 2 , m = 7 , k = 1 ; cout << countWays ( n , m , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void imageSwap ( int mat [ ] [ MAX ] , int n ) {
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j <= i ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] + mat [ j ] [ i ] - ( mat [ j ] [ i ] = mat [ i ] [ j ] ) ; }
void printMatrix ( int mat [ ] [ MAX ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << mat [ i ] [ j ] << " ▁ " ; cout << endl ; } }
int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int n = 4 ; imageSwap ( mat , n ) ; printMatrix ( mat , n ) ; return 0 ; }
int search ( int mat [ 4 ] [ 4 ] , int n , int x ) { if ( n == 0 ) return -1 ; int smallest = mat [ 0 ] [ 0 ] , largest = mat [ n - 1 ] [ n - 1 ] ; if ( x < smallest x > largest ) return -1 ;
int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { cout << " n ▁ Found ▁ at ▁ " << i << " , ▁ " << j ; return 1 ; } if ( mat [ i ] [ j ] > x ) j -- ;
else i ++ ; } cout << " n ▁ Element ▁ not ▁ found " ;
return 0 ; }
int main ( ) { int mat [ 4 ] [ 4 ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; search ( mat , 4 , 29 ) ; return 0 ; }
int calculateEnergy ( int mat [ SIZE ] [ SIZE ] , int n ) { int i_des , j_des , q ; int tot_energy = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
q = mat [ i ] [ j ] / n ;
i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ;
tot_energy += abs ( i_des - i ) + abs ( j_des - j ) ; } }
return tot_energy ; }
int main ( ) { int mat [ SIZE ] [ SIZE ] = { { 4 , 7 , 0 , 3 } , { 8 , 5 , 6 , 1 } , { 9 , 11 , 10 , 2 } , { 15 , 13 , 14 , 12 } } ; int n = 4 ; cout << " Total ▁ energy ▁ required ▁ = ▁ " << calculateEnergy ( mat , n ) << " ▁ units " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ;
bool isUnique ( int mat [ ] [ MAX ] , int i , int j , int n , int m ) {
int sumrow = 0 ; for ( int k = 0 ; k < m ; k ++ ) { sumrow += mat [ i ] [ k ] ; if ( sumrow > 1 ) return false ; }
int sumcol = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sumcol += mat [ k ] [ j ] ; if ( sumcol > 1 ) return false ; } return true ; } int countUnique ( int mat [ ] [ MAX ] , int n , int m ) { int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] && isUnique ( mat , i , j , n , m ) ) uniquecount ++ ; return uniquecount ; }
int main ( ) { int mat [ ] [ MAX ] = { { 0 , 1 , 0 , 0 } , { 0 , 0 , 1 , 0 } , { 1 , 0 , 0 , 1 } } ; cout << countUnique ( mat , 3 , 4 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; bool isSparse ( int array [ ] [ MAX ] , int m , int n ) { int counter = 0 ;
for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ; return ( counter > ( ( m * n ) / 2 ) ) ; }
int main ( ) { int array [ ] [ MAX ] = { { 1 , 0 , 3 } , { 0 , 0 , 4 } , { 6 , 0 , 0 } } ; int m = 3 , n = 3 ; if ( isSparse ( array , m , n ) ) cout << " Yes " ; else cout << " No " ; }
#include <iostream> NEW_LINE #define MAX  100 NEW_LINE using namespace std ;
int countCommon ( int mat [ ] [ MAX ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; }
int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; cout << countCommon ( mat , 3 ) ; return 0 ; }
bool areSumSame ( int a [ ] [ MAX ] , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 , sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; }
int n = 4 ;
int m = 4 ; int M [ n ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 9 , 5 , 3 , 1 } , { 0 , 3 , 5 , 6 } , { 0 , 4 , 5 , 6 } } ; cout << areSumSame ( M , n , m ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  4 NEW_LINE using namespace std ;
void findMax ( int arr [ ] [ N ] ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) {
while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } cout << " Row ▁ number ▁ = ▁ " << row + 1 ; cout << " , ▁ MaxCount ▁ = ▁ " << N - 1 - j ; }
int main ( ) { int arr [ N ] [ N ] = { 0 , 0 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 1 , 1 , 1 } ; findMax ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define n  4 NEW_LINE #define m  4 NEW_LINE using namespace std ;
int findPossibleMoves ( int mat [ n ] [ m ] , int p , int q ) {
int X [ 8 ] = { 2 , 1 , -1 , -2 , -2 , -1 , 1 , 2 } ; int Y [ 8 ] = { 1 , 2 , 2 , 1 , -1 , -2 , -2 , -1 } ; int count = 0 ;
for ( int i = 0 ; i < 8 ; i ++ ) {
int x = p + X [ i ] ; int y = q + Y [ i ] ;
if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; }
return count ; }
int main ( ) { int mat [ n ] [ m ] = { { 1 , 0 , 1 , 0 } , { 0 , 1 , 1 , 1 } , { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 1 } } ; int p = 2 , q = 2 ; cout << findPossibleMoves ( mat , p , q ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void printDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
if ( i == j ) principal += mat [ i ] [ j ] ;
if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } cout << " Principal ▁ Diagonal : " << principal << endl ; cout << " Secondary ▁ Diagonal : " << secondary << endl ; }
int main ( ) { int a [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printDiagonalSums ( a , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void printDiagonalSums ( int mat [ ] [ MAX ] , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } cout << " Principal ▁ Diagonal : " << principal << endl ; cout << " Secondary ▁ Diagonal : " << secondary << endl ; }
int main ( ) { int a [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printDiagonalSums ( a , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void printBoundary ( int a [ ] [ MAX ] , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 j == 0 i == n - 1 j == n - 1 ) cout << a [ i ] [ j ] << " ▁ " ; else cout << " ▁ " << " ▁ " ; } cout << " STRNEWLINE " ; } }
int main ( ) { int a [ 4 ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printBoundary ( a , 4 , 4 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; int getBoundarySum ( int a [ ] [ MAX ] , int m , int n ) { long long int sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; }
int main ( ) { int a [ ] [ MAX ] = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; long long int sum = getBoundarySum ( a , 4 , 4 ) ; cout << " Sum ▁ of ▁ boundary ▁ elements ▁ is ▁ " << sum ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 100 ; void printSpiral ( int mat [ ] [ MAX ] , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) cout << mat [ low_row ] [ i ] << " ▁ " ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) cout << mat [ i ] [ high_column ] << " ▁ " ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) cout << mat [ high_row ] [ i ] << " ▁ " ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) cout << mat [ i ] [ low_column ] << " ▁ " ; low_column -= 1 ; } cout << endl ; }
int main ( ) { int mat [ ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int r = 3 , c = 3 ;
printSpiral ( mat , r , c ) ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int difference ( int arr [ ] [ MAX ] , int n ) {
int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
if ( i == j ) d1 += arr [ i ] [ j ] ;
if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } }
return abs ( d1 - d2 ) ; }
int main ( ) { int n = 3 ; int arr [ ] [ MAX ] = { { 11 , 2 , 4 } , { 4 , 5 , 6 } , { 10 , 8 , -12 } } ; cout << difference ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ; int difference ( int arr [ ] [ MAX ] , int n ) {
int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; }
return abs ( d1 - d2 ) ; }
int main ( ) { int n = 3 ; int arr [ ] [ MAX ] = { { 11 , 2 , 4 } , { 4 , 5 , 6 } , { 10 , 8 , -12 } } ; cout << difference ( arr , n ) ; return 0 ; }
void spiralFill ( int m , int n , int a [ ] [ MAX ] ) {
int val = 1 ;
int k = 0 , l = 0 ; while ( k < m && l < n ) {
for ( int i = l ; i < n ; ++ i ) a [ k ] [ i ] = val ++ ; k ++ ;
for ( int i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = val ++ ; n -- ;
if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = val ++ ; m -- ; }
if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = val ++ ; l ++ ; } } }
int main ( ) { int m = 4 , n = 4 ; int a [ MAX ] [ MAX ] ; spiralFill ( m , n , a ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) cout << a [ i ] [ j ] << " ▁ " ; cout << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100
void maxMin ( int arr [ ] [ MAX ] , int n ) { int min = INT_MAX ; int max = INT_MIN ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) {
if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } cout << " Maximum ▁ = ▁ " << max << " , ▁ Minimum ▁ = ▁ " << min ; }
int main ( ) { int arr [ MAX ] [ MAX ] = { 5 , 9 , 11 , 25 , 0 , 14 , 21 , 6 , 4 } ; maxMin ( arr , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  5 NEW_LINE #define M  5 NEW_LINE using namespace std ;
int minOperation ( bool arr [ N ] [ M ] ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) {
if ( arr [ i ] [ j ] == 0 ) {
ans ++ ;
for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) {
if ( arr [ k ] [ h ] == 1 ) arr [ k ] [ h ] = 0 ; else arr [ k ] [ h ] = 1 ; } } } } } return ans ; }
int main ( ) { bool mat [ N ] [ M ] = { 0 , 0 , 1 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 } ; cout << minOperation ( mat ) << endl ; return 0 ; }
int findSum ( int n ) { int ans = 0 , temp = 0 , num ;
for ( int i = 1 ; i <= n && temp < n ; i ++ ) {
temp = i - 1 ;
num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; }
int main ( ) { int N = 2 ; cout << findSum ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ; int countOps ( int A [ ] [ MAX ] , int B [ ] [ MAX ] , int m , int n ) {
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) A [ i ] [ j ] -= B [ i ] [ j ] ;
for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j < m ; j ++ ) if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) return -1 ;
int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += abs ( A [ i ] [ 0 ] ) ; for ( int j = 0 ; j < m ; j ++ ) result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; return ( result ) ; }
int main ( ) { int A [ MAX ] [ MAX ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int B [ MAX ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; cout << countOps ( A , B , 3 , 3 ) ; return 0 ; }
void printCoils ( int n ) {
int m = 8 * n * n ;
int coil1 [ m ] ;
coil1 [ 0 ] = 8 * n * n + 2 * n ; int curr = coil1 [ 0 ] ; int nflg = 1 , step = 2 ;
int index = 1 ; while ( index < m ) {
for ( int i = 0 ; i < step ; i ++ ) {
curr = coil1 [ index ++ ] = ( curr - 4 * n * nflg ) ; if ( index >= m ) break ; } if ( index >= m ) break ;
for ( int i = 0 ; i < step ; i ++ ) { curr = coil1 [ index ++ ] = curr + nflg ; if ( index >= m ) break ; } nflg = nflg * ( -1 ) ; step += 2 ; }
int coil2 [ m ] ; for ( int i = 0 ; i < 8 * n * n ; i ++ ) coil2 [ i ] = 16 * n * n + 1 - coil1 [ i ] ;
cout << " Coil ▁ 1 ▁ : ▁ " ; for ( int i = 0 ; i < 8 * n * n ; i ++ ) cout << coil1 [ i ] << " ▁ " ; cout << " Coil 2 : " for ( int i = 0 ; i < 8 * n * n ; i ++ ) cout << coil2 [ i ] << " ▁ " ; }
int main ( ) { int n = 1 ; printCoils ( n ) ; return 0 ; }
int findSum ( int n ) {
int arr [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = abs ( i - j ) ;
int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; }
int main ( ) { int n = 3 ; cout << findSum ( n ) << endl ; return 0 ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; }
int main ( ) { int n = 3 ; cout << findSum ( n ) << endl ; return 0 ; }
int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; }
int main ( ) { int n = 3 ; cout << findSum ( n ) << endl ; return 0 ; }
int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ;
return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; }
int main ( ) { int n = 7 ; cout << spiralDiaSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  5
int numofneighbour ( int mat [ ] [ C ] , int i , int j ) { int count = 0 ;
if ( i > 0 && mat [ i - 1 ] [ j ] ) count ++ ;
if ( j > 0 && mat [ i ] [ j - 1 ] ) count ++ ;
if ( i < R - 1 && mat [ i + 1 ] [ j ] ) count ++ ;
if ( j < C - 1 && mat [ i ] [ j + 1 ] ) count ++ ; return count ; }
int findperimeter ( int mat [ R ] [ C ] ) { int perimeter = 0 ;
for ( int i = 0 ; i < R ; i ++ ) for ( int j = 0 ; j < C ; j ++ ) if ( mat [ i ] [ j ] ) perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; return perimeter ; }
int main ( ) { int mat [ R ] [ C ] = { 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , } ; cout << findperimeter ( mat ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void printMatrixDiagonal ( int mat [ MAX ] [ MAX ] , int n ) {
int i = 0 , j = 0 ;
bool isUp = true ;
for ( int k = 0 ; k < n * n ; ) {
if ( isUp ) { for ( ; i >= 0 && j < n ; j ++ , i -- ) { cout << mat [ i ] [ j ] << " ▁ " ; k ++ ; }
if ( i < 0 && j <= n - 1 ) i = 0 ; if ( j == n ) i = i + 2 , j -- ; }
else { for ( ; j >= 0 && i < n ; i ++ , j -- ) { cout << mat [ i ] [ j ] << " ▁ " ; k ++ ; }
if ( j < 0 && i <= n - 1 ) j = 0 ; if ( i == n ) j = j + 2 , i -- ; }
isUp = ! isUp ; } }
int main ( ) { int mat [ MAX ] [ MAX ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int n = 3 ; printMatrixDiagonal ( mat , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ;
int maxRowDiff ( int mat [ ] [ MAX ] , int m , int n ) {
int rowSum [ m ] ;
for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; }
int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) {
if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ;
if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; }
int main ( ) { int m = 5 , n = 4 ; int mat [ ] [ MAX ] = { { -1 , 2 , 3 , 4 } , { 5 , 3 , -2 , 1 } , { 6 , 7 , 2 , -3 } , { 2 , 9 , 1 , 4 } , { 2 , 1 , -2 , 0 } } ; cout << maxRowDiff ( mat , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ;
int sortedCount ( int mat [ ] [ MAX ] , int r , int c ) {
int result = 0 ;
for ( int i = 0 ; i < r ; i ++ ) {
int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ;
if ( j == c - 1 ) result ++ ; }
for ( int i = 0 ; i < r ; i ++ ) {
int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ;
if ( c > 1 && j == 0 ) result ++ ; } return result ; }
int main ( ) { int m = 4 , n = 5 ; int mat [ ] [ MAX ] = { { 1 , 2 , 3 , 4 , 5 } , { 4 , 3 , 1 , 2 , 6 } , { 8 , 7 , 6 , 5 , 4 } , { 5 , 7 , 8 , 9 , 10 } } ; cout << sortedCount ( mat , m , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 1000 ;
int maxXOR ( int mat [ ] [ MAX ] , int N ) {
int r_xor , c_xor ; int max_xor = 0 ;
for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) {
r_xor = r_xor ^ mat [ i ] [ j ] ;
c_xor = c_xor ^ mat [ j ] [ i ] ; }
if ( max_xor < max ( r_xor , c_xor ) ) max_xor = max ( r_xor , c_xor ) ; }
return max_xor ; }
int main ( ) { int N = 3 ; int mat [ ] [ MAX ] = { { 1 , 5 , 4 } , { 3 , 7 , 2 } , { 5 , 9 , 10 } } ; cout << " maximum ▁ XOR ▁ value ▁ : ▁ " << maxXOR ( mat , N ) ; return 0 ; }
void direction ( ll R , ll C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { cout << " Left " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { cout << " Up " << endl ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { cout << " Right " << endl ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { cout << " Left " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { cout << " Right " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { cout << " Down " << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { cout << " Left " << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { cout << " Up " << endl ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { cout << " Down " << endl ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { cout << " Right " << endl ; return ; } }
int main ( ) { ll R = 3 , C = 1 ; direction ( R , C ) ; return 0 ; }
bool checkDiagonal ( int mat [ N ] [ M ] , int i , int j ) { int res = mat [ i ] [ j ] ; while ( ++ i < N && ++ j < M ) {
if ( mat [ i ] [ j ] != res ) return false ; }
return true ; }
bool isToepliz ( int mat [ N ] [ M ] ) {
for ( int i = 0 ; i < M ; i ++ ) {
if ( ! checkDiagonal ( mat , 0 , i ) ) return false ; }
for ( int i = 1 ; i < N ; i ++ ) {
if ( ! checkDiagonal ( mat , i , 0 ) ) return false ; }
return true ; }
int main ( ) { int mat [ N ] [ M ] = { { 6 , 7 , 8 , 9 } , { 4 , 6 , 7 , 8 } , { 1 , 4 , 6 , 7 } , { 0 , 1 , 4 , 6 } , { 2 , 0 , 1 , 4 } } ;
if ( isToepliz ( mat ) ) cout << " Matrix ▁ is ▁ a ▁ Toepliz ▁ " ; else cout << " Matrix ▁ is ▁ not ▁ a ▁ Toepliz ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define N  5
int countZeroes ( int mat [ N ] [ N ] ) {
int row = N - 1 , col = 0 ;
int count = 0 ; while ( col < N ) {
while ( mat [ row ] [ col ] )
if ( -- row < 0 ) return count ;
count += ( row + 1 ) ;
col ++ ; } return count ; }
int main ( ) { int mat [ N ] [ N ] = { { 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 1 , 1 } , { 0 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } } ; cout << countZeroes ( mat ) ; return 0 ; }
#define N  10
int findLargestPlus ( int mat [ N ] [ N ] ) {
int left [ N ] [ N ] , right [ N ] [ N ] , top [ N ] [ N ] , bottom [ N ] [ N ] ;
for ( int i = 0 ; i < N ; i ++ ) {
top [ 0 ] [ i ] = mat [ 0 ] [ i ] ;
bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ;
left [ i ] [ 0 ] = mat [ i ] [ 0 ] ;
right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; }
for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) {
if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ;
if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ;
j = N - 1 - j ;
if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ;
if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ;
j = N - 1 - j ; } }
int n = 0 ;
for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) {
int len = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ;
if ( len > n ) n = len ; } }
if ( n ) return 4 * ( n - 1 ) + 1 ;
return 0 ; }
int main ( ) { int mat [ N ] [ N ] = { { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 } , { 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 } , { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 } } ; cout << findLargestPlus ( mat ) ; return 0 ; }
string findLeft ( string str ) { int n = str . length ( ) ;
while ( n -- ) {
if ( str [ n ] == ' d ' ) { str [ n ] = ' c ' ; break ; } if ( str [ n ] == ' b ' ) { str [ n ] = ' a ' ; break ; }
if ( str [ n ] == ' a ' ) str [ n ] = ' b ' ; else if ( str [ n ] == ' c ' ) str [ n ] = ' d ' ; } return str ; }
int main ( ) { string str = " aacbddc " ; cout << " Left ▁ of ▁ " << str << " ▁ is ▁ " << findLeft ( str ) ; return 0 ; }
void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
int x ;
x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) ;
if ( i <= j ) printf ( " % d TABSYMBOL ▁ " , ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) ) ;
else printf ( " % d TABSYMBOL ▁ " , ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) ; } printf ( " STRNEWLINE " ) ; } }
int main ( ) { int n = 5 ;
printSpiral ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  4 NEW_LINE void modifyMatrix ( bool mat [ R ] [ C ] ) { bool row [ R ] ; bool col [ C ] ; int i , j ;
for ( i = 0 ; i < R ; i ++ ) { row [ i ] = 0 ; }
for ( i = 0 ; i < C ; i ++ ) { col [ i ] = 0 ; }
for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { row [ i ] = 1 ; col [ j ] = 1 ; } } }
for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( row [ i ] == 1 col [ j ] == 1 ) { mat [ i ] [ j ] = 1 ; } } } }
void printMatrix ( bool mat [ R ] [ C ] ) { int i , j ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { cout << mat [ i ] [ j ] ; } cout << endl ; } }
int main ( ) { bool mat [ R ] [ C ] = { { 1 , 0 , 0 , 1 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } } ; cout << " Input ▁ Matrix ▁ STRNEWLINE " ; printMatrix ( mat ) ; modifyMatrix ( mat ) ; printf ( " Matrix ▁ after ▁ modification ▁ STRNEWLINE " ) ; printMatrix ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  4 NEW_LINE void modifyMatrix ( int mat [ R ] [ C ] ) {
bool row_flag = false ; bool col_flag = false ;
for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( i == 0 && mat [ i ] [ j ] == 1 ) row_flag = true ; if ( j == 0 && mat [ i ] [ j ] == 1 ) col_flag = true ; if ( mat [ i ] [ j ] == 1 ) { mat [ 0 ] [ j ] = 1 ; mat [ i ] [ 0 ] = 1 ; } } }
for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( mat [ 0 ] [ j ] == 1 mat [ i ] [ 0 ] == 1 ) { mat [ i ] [ j ] = 1 ; } } }
if ( row_flag == true ) { for ( int i = 0 ; i < C ; i ++ ) { mat [ 0 ] [ i ] = 1 ; } }
if ( col_flag == true ) { for ( int i = 0 ; i < R ; i ++ ) { mat [ i ] [ 0 ] = 1 ; } } }
void printMatrix ( int mat [ R ] [ C ] ) { for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { cout << mat [ i ] [ j ] ; } cout << " STRNEWLINE " ; } }
int main ( ) { int mat [ R ] [ C ] = { { 1 , 0 , 0 , 1 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } } ; cout << " Input ▁ Matrix ▁ : STRNEWLINE " ; printMatrix ( mat ) ; modifyMatrix ( mat ) ; cout << " Matrix ▁ After ▁ Modification ▁ : STRNEWLINE " ; printMatrix ( mat ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define n  5 NEW_LINE int find ( bool arr [ n ] [ n ] ) {
int i = 0 , j = n - 1 ;
int res = -1 ;
while ( i < n && j >= 0 ) {
if ( arr [ i ] [ j ] == 0 ) {
while ( j >= 0 && ( arr [ i ] [ j ] == 0 i == j ) ) j -- ;
if ( j == -1 ) { res = i ; break ; }
else i ++ ; }
else {
while ( i < n && ( arr [ i ] [ j ] == 1 i == j ) ) i ++ ;
if ( i == n ) { res = j ; break ; }
else j -- ; } }
if ( res == -1 ) return res ;
for ( int i = 0 ; i < n ; i ++ ) if ( res != i && arr [ i ] [ res ] != 1 ) return -1 ; for ( int j = 0 ; j < n ; j ++ ) if ( res != j && arr [ res ] [ j ] != 0 ) return -1 ; return res ; }
int main ( ) { bool mat [ n ] [ n ] = { { 0 , 0 , 1 , 1 , 0 } , { 0 , 0 , 0 , 1 , 0 } , { 1 , 1 , 1 , 1 , 0 } , { 0 , 0 , 0 , 0 , 0 } , { 1 , 1 , 1 , 1 , 1 } } ; cout << find ( mat ) ; return 0 ; }
int preProcess ( int mat [ M ] [ N ] , int aux [ M ] [ N ] ) {
for ( int i = 0 ; i < N ; i ++ ) aux [ 0 ] [ i ] = mat [ 0 ] [ i ] ;
for ( int i = 1 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] ;
for ( int i = 0 ; i < M ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) aux [ i ] [ j ] += aux [ i ] [ j - 1 ] ; }
int sumQuery ( int aux [ M ] [ N ] , int tli , int tlj , int rbi , int rbj ) {
int res = aux [ rbi ] [ rbj ] ;
if ( tli > 0 ) res = res - aux [ tli - 1 ] [ rbj ] ;
if ( tlj > 0 ) res = res - aux [ rbi ] [ tlj - 1 ] ;
if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 ] [ tlj - 1 ] ; return res ; }
int main ( ) { int mat [ M ] [ N ] = { { 1 , 2 , 3 , 4 , 6 } , { 5 , 3 , 8 , 1 , 2 } , { 4 , 6 , 7 , 5 , 5 } , { 2 , 4 , 8 , 9 , 4 } } ; int aux [ M ] [ N ] ; preProcess ( mat , aux ) ; int tli = 2 , tlj = 2 , rbi = 3 , rbj = 4 ; cout << " Query1 : " tli = 0 , tlj = 0 , rbi = 1 , rbj = 1 ; cout << " Query2 : " tli = 1 , tlj = 2 , rbi = 3 , rbj = 3 ; cout << " Query3 : " return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  3
void swap ( int mat [ R ] [ C ] , int row1 , int row2 , int col ) { for ( int i = 0 ; i < col ; i ++ ) { int temp = mat [ row1 ] [ i ] ; mat [ row1 ] [ i ] = mat [ row2 ] [ i ] ; mat [ row2 ] [ i ] = temp ; } }
int rankOfMatrix ( int mat [ R ] [ C ] ) { int rank = C ; for ( int row = 0 ; row < rank ; row ++ ) {
if ( mat [ row ] [ row ] ) { for ( int col = 0 ; col < R ; col ++ ) { if ( col != row ) {
double mult = ( double ) mat [ col ] [ row ] / mat [ row ] [ row ] ; for ( int i = 0 ; i < rank ; i ++ ) mat [ col ] [ i ] -= mult * mat [ row ] [ i ] ; } } }
else { bool reduce = true ;
for ( int i = row + 1 ; i < R ; i ++ ) {
if ( mat [ i ] [ row ] ) { swap ( mat , row , i , rank ) ; reduce = false ; break ; } }
if ( reduce ) {
rank -- ;
for ( int i = 0 ; i < R ; i ++ ) mat [ i ] [ row ] = mat [ i ] [ rank ] ; }
row -- ; }
} return rank ; }
void display ( int mat [ R ] [ C ] , int row , int col ) { for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) printf ( " ▁ % d " , mat [ i ] [ j ] ) ; printf ( " STRNEWLINE " ) ; } }
int main ( ) { int mat [ ] [ 3 ] = { { 10 , 20 , 10 } , { -20 , -30 , 10 } , { 30 , 50 , 0 } } ; printf ( " Rank ▁ of ▁ the ▁ matrix ▁ is ▁ : ▁ % d " , rankOfMatrix ( mat ) ) ; return 0 ; }
int countIslands ( int mat [ ] [ N ] ) {
int count = 0 ;
for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) {
if ( mat [ i ] [ j ] == ' X ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' O ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; }
int main ( ) { int mat [ M ] [ N ] = { { ' O ' , ' O ' , ' O ' } , { ' X ' , ' X ' , ' O ' } , { ' X ' , ' X ' , ' O ' } , { ' O ' , ' O ' , ' X ' } , { ' O ' , ' O ' , ' X ' } , { ' X ' , ' X ' , ' O ' } } ; cout << " Number ▁ of ▁ rectangular ▁ islands ▁ is ▁ " << countIslands ( mat ) ; return 0 ; }
#define M  6 NEW_LINE #define N  6
void floodFillUtil ( char mat [ ] [ N ] , int x , int y , char prevV , char newV ) {
if ( x < 0 x > = M y < 0 y > = N ) return ; if ( mat [ x ] [ y ] != prevV ) return ;
mat [ x ] [ y ] = newV ;
floodFillUtil ( mat , x + 1 , y , prevV , newV ) ; floodFillUtil ( mat , x - 1 , y , prevV , newV ) ; floodFillUtil ( mat , x , y + 1 , prevV , newV ) ; floodFillUtil ( mat , x , y - 1 , prevV , newV ) ; }
int replaceSurrounded ( char mat [ ] [ N ] ) {
for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == ' O ' ) mat [ i ] [ j ] = ' - ' ;
for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ 0 ] == ' - ' ) floodFillUtil ( mat , i , 0 , ' - ' , ' O ' ) ;
for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ N - 1 ] == ' - ' ) floodFillUtil ( mat , i , N - 1 , ' - ' , ' O ' ) ;
for ( int i = 0 ; i < N ; i ++ ) if ( mat [ 0 ] [ i ] == ' - ' ) floodFillUtil ( mat , 0 , i , ' - ' , ' O ' ) ;
for ( int i = 0 ; i < N ; i ++ ) if ( mat [ M - 1 ] [ i ] == ' - ' ) floodFillUtil ( mat , M - 1 , i , ' - ' , ' O ' ) ;
for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == ' - ' ) mat [ i ] [ j ] = ' X ' ; }
int main ( ) { char mat [ ] [ N ] = { { ' X ' , ' O ' , ' X ' , ' O ' , ' X ' , ' X ' } , { ' X ' , ' O ' , ' X ' , ' X ' , ' O ' , ' X ' } , { ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' X ' } , { ' O ' , ' X ' , ' X ' , ' X ' , ' X ' , ' X ' } , { ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' O ' } , { ' O ' , ' O ' , ' X ' , ' O ' , ' O ' , ' O ' } , } ; replaceSurrounded ( mat ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) cout << mat [ i ] [ j ] << " ▁ " ; cout << endl ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ;
int x [ ] = { 0 , 1 , 1 , -1 , 1 , 0 , -1 , -1 } ; int y [ ] = { 1 , 0 , 1 , 1 , -1 , -1 , 0 , -1 } ;
int dp [ R ] [ C ] ;
bool isvalid ( int i , int j ) { if ( i < 0 j < 0 i > = R j > = C ) return false ; return true ; }
bool isadjacent ( char prev , char curr ) { return ( ( curr - prev ) == 1 ) ; }
int getLenUtil ( char mat [ R ] [ C ] , int i , int j , char prev ) {
if ( ! isvalid ( i , j ) || ! isadjacent ( prev , mat [ i ] [ j ] ) ) return 0 ;
if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ;
int ans = 0 ;
for ( int k = 0 ; k < 8 ; k ++ ) ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) ;
return dp [ i ] [ j ] = ans ; }
int getLen ( char mat [ R ] [ C ] , char s ) { memset ( dp , -1 , sizeof dp ) ; int ans = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) {
if ( mat [ i ] [ j ] == s ) {
for ( int k = 0 ; k < 8 ; k ++ ) ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; }
int main ( ) { char mat [ R ] [ C ] = { { ' a ' , ' c ' , ' d ' } , { ' h ' , ' b ' , ' a ' } , { ' i ' , ' g ' , ' f ' } } ; cout << getLen ( mat , ' a ' ) << endl ; cout << getLen ( mat , ' e ' ) << endl ; cout << getLen ( mat , ' b ' ) << endl ; cout << getLen ( mat , ' f ' ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; int minInitialPoints ( int points [ ] [ C ] ) {
int dp [ R ] [ C ] ; int m = R , n = C ;
dp [ m - 1 ] [ n - 1 ] = points [ m - 1 ] [ n - 1 ] > 0 ? 1 : abs ( points [ m - 1 ] [ n - 1 ] ) + 1 ;
for ( int i = m - 2 ; i >= 0 ; i -- ) dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) dp [ m - 1 ] [ j ] = max ( dp [ m - 1 ] [ j + 1 ] - points [ m - 1 ] [ j ] , 1 ) ;
for ( int i = m - 2 ; i >= 0 ; i -- ) { for ( int j = n - 2 ; j >= 0 ; j -- ) { int min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) ; dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) ; } } return dp [ 0 ] [ 0 ] ; }
int main ( ) { int points [ R ] [ C ] = { { -2 , -3 , 3 } , { -5 , -10 , 1 } , { 10 , 30 , -5 } } ; cout << " Minimum ▁ Initial ▁ Points ▁ Required : ▁ " << minInitialPoints ( points ) ; return 0 ; }
int findPeakUtil ( int arr [ ] , int low , int high , int n ) {
int mid = low + ( high - low ) / 2 ;
if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ;
else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ;
else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; }
int findPeak ( int arr [ ] , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; }
int main ( ) { int arr [ ] = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Index ▁ of ▁ a ▁ peak ▁ point ▁ is ▁ " << findPeak ( arr , n ) ; return 0 ; }
void printRepeating ( int arr [ ] , int size ) { int i , j ; printf ( " ▁ Repeating ▁ elements ▁ are ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) for ( j = i + 1 ; j < size ; j ++ ) if ( arr [ i ] == arr [ j ] ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; }
void printRepeating ( int arr [ ] , int size ) { int * count = new int [ sizeof ( int ) * ( size - 2 ) ] ; int i ; cout << " ▁ Repeating ▁ elements ▁ are ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) cout << arr [ i ] << " ▁ " ; else count [ arr [ i ] ] ++ ; } }
int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; return 0 ; }
int fact ( int n ) ; void printRepeating ( int arr [ ] , int size ) {
int S = 0 ;
int P = 1 ;
int x , y ;
int D ; int n = size - 2 , i ;
for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; }
S = S - n * ( n + 1 ) / 2 ;
P = P / fact ( n ) ;
D = sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; cout << " The ▁ two ▁ Repeating ▁ elements ▁ are ▁ " << x << " ▁ & ▁ " << y ; }
int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; }
int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printRepeating ( int arr [ ] , int size ) {
int Xor = arr [ 0 ] ;
int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ;
for ( i = 1 ; i < size ; i ++ ) Xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) Xor ^= i ;
set_bit_no = Xor & ~ ( Xor - 1 ) ;
for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ;
else y = y ^ arr [ i ] ;
} for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ;
else y = y ^ i ;
} cout << " The ▁ two ▁ repeating ▁ elements ▁ are ▁ " << y << " ▁ " << x ; }
int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; return 0 ; }
void printRepeating ( int arr [ ] , int size ) { int i ; cout << " The ▁ repeating ▁ elements ▁ are " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) ] > 0 ) arr [ abs ( arr [ i ] ) ] = - arr [ abs ( arr [ i ] ) ] ; else cout << " ▁ " << abs ( arr [ i ] ) << " ▁ " ; } }
int main ( ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeating ( arr , arr_size ) ; return 0 ; }
int subArraySum ( int arr [ ] , int n , int sum ) { int curr_sum , i , j ;
for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ;
for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << i << " ▁ and ▁ " << j - 1 ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } cout << " No ▁ subarray ▁ found " ; return 0 ; }
int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }
int subArraySum ( int arr [ ] , int n , int sum ) {
int curr_sum = arr [ 0 ] , start = 0 , i ;
for ( i = 1 ; i <= n ; i ++ ) {
while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; }
if ( curr_sum == sum ) { cout << " Sum ▁ found ▁ between ▁ indexes ▁ " << start << " ▁ and ▁ " << i - 1 ; return 1 ; }
if ( i < n ) curr_sum = curr_sum + arr [ i ] ; }
cout << " No ▁ subarray ▁ found " ; return 0 ; }
int main ( ) { int arr [ ] = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 23 ; subArraySum ( arr , n , sum ) ; return 0 ; }
int maximum ( int a , int b , int c ) { return max ( max ( a , b ) , c ) ; }
int minimum ( int a , int b , int c ) { return min ( min ( a , b ) , c ) ; }
void smallestDifferenceTriplet ( int arr1 [ ] , int arr2 [ ] , int arr3 [ ] , int n ) {
sort ( arr1 , arr1 + n ) ; sort ( arr2 , arr2 + n ) ; sort ( arr3 , arr3 + n ) ;
int res_min , res_max , res_mid ;
int i = 0 , j = 0 , k = 0 ;
int diff = INT_MAX ; while ( i < n && j < n && k < n ) { int sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ;
int max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ;
int min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; if ( min == arr1 [ i ] ) i ++ ; else if ( min == arr2 [ j ] ) j ++ ; else k ++ ;
if ( diff > ( max - min ) ) { diff = max - min ; res_max = max ; res_mid = sum - ( max + min ) ; res_min = min ; } }
cout << res_max << " , ▁ " << res_mid << " , ▁ " << res_min ; }
int main ( ) { int arr1 [ ] = { 5 , 2 , 8 } ; int arr2 [ ] = { 10 , 7 , 12 } ; int arr3 [ ] = { 9 , 14 , 6 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) ; return 0 ; }
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ;
for ( int i = 0 ; i < arr_size - 2 ; i ++ ) {
for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) {
for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { cout << " Triplet ▁ is ▁ " << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] ; return true ; } } } }
return false ; }
int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find3Numbers ( A , arr_size , sum ) ; return 0 ; }
bool find3Numbers ( int A [ ] , int arr_size , int sum ) { int l , r ;
sort ( A , A + arr_size ) ;
for ( int i = 0 ; i < arr_size - 2 ; i ++ ) {
l = i + 1 ;
r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { printf ( " Triplet ▁ is ▁ % d , ▁ % d , ▁ % d " , A [ i ] , A [ l ] , A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ;
else r -- ; } }
return false ; }
int main ( ) { int A [ ] = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = sizeof ( A ) / sizeof ( A [ 0 ] ) ; find3Numbers ( A , arr_size , sum ) ; return 0 ; }
void subArray ( int arr [ ] , int n ) {
for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = i ; j < n ; j ++ ) {
for ( int k = i ; k <= j ; k ++ ) cout << arr [ k ] << " ▁ " ; cout << endl ; } } }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " All ▁ Non - empty ▁ Subarrays STRNEWLINE " ; subArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printSubsequences ( int arr [ ] , int n ) {
unsigned int opsize = pow ( 2 , n ) ;
for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
if ( counter & ( 1 << j ) ) cout << arr [ j ] << " ▁ " ; } cout << endl ; } }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " All ▁ Non - empty ▁ Subsequences STRNEWLINE " ; printSubsequences ( arr , n ) ; return 0 ; }
void productArray ( int arr [ ] , int n ) {
if ( n == 1 ) { cout << 0 ; return ; } int i , temp = 1 ;
int * prod = new int [ ( sizeof ( int ) * n ) ] ;
memset ( prod , 1 , n ) ;
for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; }
temp = 1 ;
for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; }
for ( i = 0 ; i < n ; i ++ ) cout << prod [ i ] << " ▁ " ; return ; }
int main ( ) { int arr [ ] = { 10 , 3 , 5 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ product ▁ array ▁ is : ▁ STRNEWLINE " ; productArray ( arr , n ) ; }
bool areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ;
int min = getMin ( arr , n ) ;
int max = getMax ( arr , n ) ;
if ( max - min + 1 == n ) {
bool * visited = ( bool * ) calloc ( n , sizeof ( bool ) ) ; int i ; for ( i = 0 ; i < n ; i ++ ) {
if ( visited [ arr [ i ] - min ] != false ) return false ;
visited [ arr [ i ] - min ] = true ; }
return true ; }
return false ; }
int getMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] < min ) min = arr [ i ] ; return min ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; }
int main ( ) { int arr [ ] = { 5 , 4 , 2 , 3 , 1 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areConsecutive ( arr , n ) == true ) printf ( " ▁ Array ▁ elements ▁ are ▁ consecutive ▁ " ) ; else printf ( " ▁ Array ▁ elements ▁ are ▁ not ▁ consecutive ▁ " ) ; getchar ( ) ; return 0 ; }
bool areConsecutive ( int arr [ ] , int n ) { if ( n < 1 ) return false ;
int min = getMin ( arr , n ) ;
int max = getMax ( arr , n ) ;
if ( max - min + 1 == n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { int j ; if ( arr [ i ] < 0 ) j = - arr [ i ] - min ; else j = arr [ i ] - min ;
if ( arr [ j ] > 0 ) arr [ j ] = - arr [ j ] ; else return false ; }
return true ; }
return false ; }
int getMin ( int arr [ ] , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] < min ) min = arr [ i ] ; return min ; } int getMax ( int arr [ ] , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; }
int main ( ) { int arr [ ] = { 1 , 4 , 5 , 3 , 2 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( areConsecutive ( arr , n ) == true ) printf ( " ▁ Array ▁ elements ▁ are ▁ consecutive ▁ " ) ; else printf ( " ▁ Array ▁ elements ▁ are ▁ not ▁ consecutive ▁ " ) ; getchar ( ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void relativeComplement ( int arr1 [ ] , int arr2 [ ] , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) {
if ( arr1 [ i ] < arr2 [ j ] ) { cout << arr1 [ i ] << " ▁ " ; i ++ ;
} else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ;
} else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } }
while ( i < n ) cout << arr1 [ i ] << " ▁ " ; }
int main ( ) { int arr1 [ ] = { 3 , 6 , 10 , 12 , 15 } ; int arr2 [ ] = { 1 , 3 , 5 , 10 , 16 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; relativeComplement ( arr1 , arr2 , n , m ) ; return 0 ; }
int minOps ( int arr [ ] , int n , int k ) {
int max = * max_element ( arr , arr + n ) ; int res = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( ( max - arr [ i ] ) % k != 0 ) return -1 ;
else res += ( max - arr [ i ] ) / k ; }
return res ; }
int main ( ) { int arr [ ] = { 21 , 33 , 9 , 45 , 63 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 6 ; cout << minOps ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int solve ( int A [ ] , int B [ ] , int C [ ] , int i , int j , int k ) { int min_diff , current_diff , max_term ;
min_diff = Integer . MAX_VALUE ; while ( i != -1 && j != -1 && k != -1 ) { current_diff = abs ( max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) - min ( A [ i ] , min ( B [ j ] , C [ k ] ) ) ) ;
if ( current_diff < min_diff ) min_diff = current_diff ;
max_term = max ( A [ i ] , max ( B [ j ] , C [ k ] ) ) ;
if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; }
int main ( ) { int D [ ] = { 5 , 8 , 10 , 15 } ; int E [ ] = { 6 , 9 , 15 , 78 , 89 } ; int F [ ] = { 2 , 3 , 6 , 6 , 8 , 8 , 10 } ; int nD = sizeof ( D ) / sizeof ( D [ 0 ] ) ; int nE = sizeof ( E ) / sizeof ( E [ 0 ] ) ; int nF = sizeof ( F ) / sizeof ( F [ 0 ] ) ; cout << solve ( D , E , F , nD - 1 , nE - 1 , nF - 1 ) ; return 0 ; }
int search ( int arr [ ] , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) return i ; } return -1 ; }
int main ( ) { int arr [ ] = { 1 , 10 , 30 , 15 } ; int x = 30 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << x << " ▁ is ▁ present ▁ at ▁ index ▁ " << search ( arr , n , x ) ; getchar ( ) ; return 0 ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ;
if ( arr [ mid ] == x ) return mid ;
if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ;
return binarySearch ( arr , mid + 1 , r , x ) ; }
return -1 ; }
int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? cout << " Element ▁ is ▁ not ▁ present ▁ in ▁ array " : cout << " Element ▁ is ▁ present ▁ at ▁ index ▁ " << result ; return 0 ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { while ( l <= r ) { int m = l + ( r - l ) / 2 ;
if ( arr [ m ] == x ) return m ;
if ( arr [ m ] < x ) l = m + 1 ;
else r = m - 1 ; }
return -1 ; }
int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int x = 10 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? cout << " Element ▁ is ▁ not ▁ present ▁ in ▁ array " : cout << " Element ▁ is ▁ present ▁ at ▁ index ▁ " << result ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int jumpSearch ( int arr [ ] , int x , int n ) {
int step = sqrt ( n ) ;
int prev = 0 ; while ( arr [ min ( step , n ) - 1 ] < x ) { prev = step ; step += sqrt ( n ) ; if ( prev >= n ) return -1 ; }
while ( arr [ prev ] < x ) { prev ++ ;
if ( prev == min ( step , n ) ) return -1 ; }
if ( arr [ prev ] == x ) return prev ; return -1 ; }
int main ( ) { int arr [ ] = { 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 } ; int x = 55 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
int index = jumpSearch ( arr , x , n ) ;
cout << " Number " ▁ < < ▁ x ▁ < < ▁ " is at index " return 0 ; }
int exponentialSearch ( int arr [ ] , int n , int x ) {
if ( arr [ 0 ] == x ) return 0 ;
int i = 1 ; while ( i < n && arr [ i ] <= x ) i = i * 2 ;
return binarySearch ( arr , i / 2 , min ( i , n - 1 ) , x ) ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ;
if ( arr [ mid ] == x ) return mid ;
if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ;
return binarySearch ( arr , mid + 1 , r , x ) ; }
return -1 ; }
int main ( void ) { int arr [ ] = { 2 , 3 , 4 , 10 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 10 ; int result = exponentialSearch ( arr , n , x ) ; ( result == -1 ) ? printf ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) : printf ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " , result ) ; return 0 ; }
void countSort ( int arr [ ] , int n , int exp ) {
int output [ n ] ; int i , count [ 10 ] = { 0 } ;
for ( i = 0 ; i < n ; i ++ ) count [ ( arr [ i ] / exp ) % 10 ] ++ ;
for ( i = 1 ; i < 10 ; i ++ ) count [ i ] += count [ i - 1 ] ;
for ( i = n - 1 ; i >= 0 ; i -- ) { output [ count [ ( arr [ i ] / exp ) % 10 ] - 1 ] = arr [ i ] ; count [ ( arr [ i ] / exp ) % 10 ] -- ; }
for ( i = 0 ; i < n ; i ++ ) arr [ i ] = output [ i ] ; }
void radixsort ( int arr [ ] , int n ) {
int m = getMax ( arr , n ) ;
for ( int exp = 1 ; m / exp > 0 ; exp *= 10 ) countSort ( arr , n , exp ) ; }
void print ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 170 , 45 , 75 , 90 , 802 , 24 , 2 , 66 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
radixsort ( arr , n ) ; print ( arr , n ) ; return 0 ; }
void swap ( int * a , int * b ) { int temp = * a ; * a = * b ; * b = temp ; }
int partition ( int arr [ ] , int l , int h ) { int x = arr [ h ] ; int i = ( l - 1 ) ; for ( int j = l ; j <= h - 1 ; j ++ ) { if ( arr [ j ] <= x ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ h ] ) ; return ( i + 1 ) ; }
void quickSort ( int A [ ] , int l , int h ) { if ( l < h ) {
int p = partition ( A , l , h ) ; quickSort ( A , l , p - 1 ) ; quickSort ( A , p + 1 , h ) ; } }
int main ( ) { int n = 5 ; int arr [ n ] = { 4 , 2 , 6 , 9 , 2 } ; quickSort ( arr , 0 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } return 0 ; }
void swap ( int * a , int * b ) { int t = * a ; * a = * b ; * b = t ; }
int partition ( int arr [ ] , int l , int h ) { int x = arr [ h ] ; int i = ( l - 1 ) ; for ( int j = l ; j <= h - 1 ; j ++ ) { if ( arr [ j ] <= x ) { i ++ ; swap ( & arr [ i ] , & arr [ j ] ) ; } } swap ( & arr [ i + 1 ] , & arr [ h ] ) ; return ( i + 1 ) ; }
void quickSortIterative ( int arr [ ] , int l , int h ) {
int stack [ h - l + 1 ] ;
int top = -1 ;
stack [ ++ top ] = l ; stack [ ++ top ] = h ;
while ( top >= 0 ) {
h = stack [ top -- ] ; l = stack [ top -- ] ;
int p = partition ( arr , l , h ) ;
if ( p - 1 > l ) { stack [ ++ top ] = l ; stack [ ++ top ] = p - 1 ; }
if ( p + 1 < h ) { stack [ ++ top ] = p + 1 ; stack [ ++ top ] = h ; } } }
void printArr ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( * arr ) ;
quickSortIterative ( arr , 0 , n - 1 ) ; printArr ( arr , n ) ; return 0 ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ;
if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ;
if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ;
return binarySearch ( arr , mid + 2 , r , x ) ; }
return -1 ; }
int main ( void ) { int arr [ ] = { 3 , 2 , 10 , 4 , 40 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 4 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == -1 ) ? printf ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) : printf ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " , result ) ; return 0 ; }
void printClosest ( int ar1 [ ] , int ar2 [ ] , int m , int n , int x ) {
int diff = INT_MAX ;
int res_l , res_r ;
int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) {
if ( abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) ; }
if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ;
else l ++ ; }
cout << " The ▁ closest ▁ pair ▁ is ▁ [ " << ar1 [ res_l ] << " , ▁ " << ar2 [ res_r ] << " ] ▁ STRNEWLINE " ; }
int main ( ) { int ar1 [ ] = { 1 , 4 , 5 , 7 } ; int ar2 [ ] = { 10 , 20 , 30 , 40 } ; int m = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; int x = 38 ; printClosest ( ar1 , ar2 , m , n , x ) ; return 0 ; }
void printClosest ( int arr [ ] , int n , int x ) {
int res_l , res_r ;
int l = 0 , r = n - 1 , diff = INT_MAX ;
while ( r > l ) {
if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; }
if ( arr [ l ] + arr [ r ] > x ) r -- ;
else l ++ ; } cout << " ▁ The ▁ closest ▁ pair ▁ is ▁ " << arr [ res_l ] << " ▁ and ▁ " << arr [ res_r ] ; }
int main ( ) { int arr [ ] = { 10 , 22 , 28 , 29 , 30 , 40 } , x = 54 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printClosest ( arr , n , x ) ; return 0 ; }
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) {
int mid = low + ( high - low ) / 2 ;
if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ;
if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ;
return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int main ( ) { bool arr [ ] = { 1 , 1 , 1 , 1 , 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is ▁ " << countOnes ( arr , 0 , n - 1 ) ; return 0 ; }
void solve ( int a [ ] , int n ) { int maxx = -1 , minn = a [ 0 ] , l = 0 , r = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] > maxx ) { maxx = a [ i ] ; l = i ; }
if ( a [ i ] <= minn ) { minn = a [ i ] ; r = i ; } } if ( r < l ) cout << l + ( n - r - 2 ) ; else cout << l + ( n - r - 1 ) ; }
int main ( ) { int a [ ] = { 5 , 6 , 1 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; solve ( a , n ) ; return 0 ; }
void printMaxActivities ( int s [ ] , int f [ ] , int n ) { int i , j ; cout << " Following ▁ activities ▁ are ▁ selected ▁ " << endl ;
i = 0 ; cout << " ▁ " << i ;
for ( j = 1 ; j < n ; j ++ ) {
if ( s [ j ] >= f [ i ] ) { cout << " ▁ " << j ; i = j ; } } }
int main ( ) { int s [ ] = { 1 , 3 , 0 , 5 , 8 , 5 } ; int f [ ] = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = sizeof ( s ) / sizeof ( s [ 0 ] ) ; printMaxActivities ( s , f , n ) ; return 0 ; }
int lcs ( char * X , char * Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
int main ( ) { char X [ ] = " AGGTAB " ; char Y [ ] = " GXTXAYB " ; int m = strlen ( X ) ; int n = strlen ( Y ) ; cout << " Length ▁ of ▁ LCS ▁ is ▁ " << lcs ( X , Y , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max ( int a , int b ) ;
int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ; int i , j ;
for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } }
return L [ m ] [ n ] ; }
int main ( ) { char X [ ] = " AGGTAB " ; char Y [ ] = " GXTXAYB " ; int m = strlen ( X ) ; int n = strlen ( Y ) ; cout << " Length ▁ of ▁ LCS ▁ is ▁ " << lcs ( X , Y , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  3 NEW_LINE #define C  3 NEW_LINE int min ( int x , int y , int z ) ;
int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; }
int minCost ( int cost [ R ] [ C ] , int m , int n ) { if ( n < 0 m < 0 ) return INT_MAX ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; }
int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; cout << minCost ( cost , 2 , 2 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <limits.h> NEW_LINE #define R  3 NEW_LINE #define C  3 NEW_LINE using namespace std ; int min ( int x , int y , int z ) ; int minCost ( int cost [ R ] [ C ] , int m , int n ) { int i , j ;
int tc [ R ] [ C ] ; tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ;
for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ;
for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ;
for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; }
int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; }
int main ( ) { int cost [ R ] [ C ] = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; cout << " ▁ " << minCost ( cost , 2 , 2 ) ; return 0 ; }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) {
if ( n == 0 W == 0 ) return 0 ;
if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ;
else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; }
int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; cout << knapSack ( W , wt , val , n ) ; return 0 ; }
int knapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ n + 1 ] [ W + 1 ] ;
for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; }
int main ( ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = sizeof ( val ) / sizeof ( val [ 0 ] ) ; cout << knapSack ( W , wt , val , n ) ; return 0 ; }
int eggDrop ( int n , int k ) {
int eggFloor [ n + 1 ] [ k + 1 ] ; int res ; int i , j , x ;
for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; }
for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ;
for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = INT_MAX ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } }
return eggFloor [ n ] [ k ] ; }
int main ( ) { int n = 2 , k = 36 ; printf ( " Minimum number of trials " STRNEWLINE " in worst case with % d eggs and " STRNEWLINE " % d floors is % d " , n , k , eggDrop ( n , k ) ) ; return 0 ; }
int lps ( char * seq , int i , int j ) {
if ( i == j ) return 1 ;
if ( seq [ i ] == seq [ j ] && i + 1 == j ) return 2 ;
if ( seq [ i ] == seq [ j ] ) return lps ( seq , i + 1 , j - 1 ) + 2 ;
return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; }
int main ( ) { char seq [ ] = " GEEKSFORGEEKS " ; int n = strlen ( seq ) ; cout << " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " << lps ( seq , 0 , n - 1 ) ; return 0 ; }
int max ( int x , int y ) { return ( x > y ) ? x : y ; }
int lps ( char * str ) { int n = strlen ( str ) ; int i , j , cl ;
int L [ n ] [ n ] ;
for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ;
for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; }
int main ( ) { char seq [ ] = " GEEKS ▁ FOR ▁ GEEKS " ; int n = strlen ( seq ) ; printf ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ % d " , lps ( seq ) ) ; getchar ( ) ; return 0 ; }
int lbs ( int arr [ ] , int n ) { int i , j ;
int * lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ;
for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ;
int * lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ;
for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ;
int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; }
int main ( ) { int arr [ ] = { 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Length ▁ of ▁ LBS ▁ is ▁ % d STRNEWLINE " , lbs ( arr , n ) ) ; return 0 ; }
int maxDivide ( int a , int b ) { while ( a % b == 0 ) a = a / b ; return a ; }
int isUgly ( int no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ? 1 : 0 ; }
int getNthUglyNo ( int n ) { int i = 1 ;
int count = 1 ;
while ( n > count ) { i ++ ; if ( isUgly ( i ) ) count ++ ; } return i ; }
int main ( ) { unsigned no = getNthUglyNo ( 150 ) ; printf ( "150th ▁ ugly ▁ no . ▁ is ▁ % d ▁ " , no ) ; getchar ( ) ; return 0 ; }
unsigned long long int countRec ( int n , int sum ) {
if ( n == 0 ) return sum == 0 ; if ( sum == 0 ) return 1 ;
unsigned long long int ans = 0 ;
for ( int i = 0 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
unsigned long long int finalCount ( int n , int sum ) {
unsigned long long int ans = 0 ;
for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
int main ( ) { int n = 2 , sum = 5 ; cout << finalCount ( n , sum ) ; return 0 ; }
unsigned long long int lookup [ 101 ] [ 501 ] ;
unsigned long long int countRec ( int n , int sum ) {
if ( n == 0 ) return sum == 0 ;
if ( lookup [ n ] [ sum ] != -1 ) return lookup [ n ] [ sum ] ;
unsigned long long int ans = 0 ;
for ( int i = 0 ; i < 10 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return lookup [ n ] [ sum ] = ans ; }
unsigned long long int finalCount ( int n , int sum ) {
unsigned long long int ans = 0 ;
for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; }
int main ( ) { int n = 3 , sum = 5 ; cout << finalCount ( n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void findCount ( int n , int sum ) {
int start = pow ( 10 , n - 1 ) ; int end = pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i <= end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } cout << count ; }
int main ( ) { int n = 3 ; int sum = 5 ; findCount ( n , sum ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countNonDecreasing ( int n ) {
long long int dp [ 10 ] [ n + 1 ] ; memset ( dp , 0 , sizeof dp ) ;
for ( int i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ;
for ( int digit = 0 ; digit <= 9 ; digit ++ ) {
for ( int len = 2 ; len <= n ; len ++ ) {
for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } long long int count = 0 ;
for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; }
int main ( ) { int n = 3 ; cout << countNonDecreasing ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; long long int countNonDecreasing ( int n ) { int N = 10 ;
long long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; }
int main ( ) { int n = 3 ; cout << countNonDecreasing ( n ) ; return 0 ; }
int getMinSquares ( unsigned int n ) {
if ( sqrt ( n ) - floor ( sqrt ( n ) ) == 0 ) return 1 ; if ( n <= 3 ) return n ;
int res = n ;
for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; }
int main ( ) { cout << getMinSquares ( 6 ) ; return 0 ; }
int getMinSquares ( int n ) {
int * dp = new int [ n + 1 ] ;
dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ;
for ( int i = 4 ; i <= n ; i ++ ) {
dp [ i ] = i ;
for ( int x = 1 ; x <= ceil ( sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } }
int res = dp [ n ] ; delete [ ] dp ; return res ; }
int main ( ) { cout << getMinSquares ( 6 ) ; return 0 ; }
int minCoins ( int coins [ ] , int m , int V ) {
if ( V == 0 ) return 0 ;
int res = INT_MAX ;
for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ;
if ( sub_res != INT_MAX && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; }
int main ( ) { int coins [ ] = { 9 , 6 , 5 , 1 } ; int m = sizeof ( coins ) / sizeof ( coins [ 0 ] ) ; int V = 11 ; cout << " Minimum ▁ coins ▁ required ▁ is ▁ " << minCoins ( coins , m , V ) ; return 0 ; }
int minCoins ( int coins [ ] , int m , int V ) {
int table [ V + 1 ] ;
table [ 0 ] = 0 ;
for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = INT_MAX ;
for ( int i = 1 ; i <= V ; i ++ ) {
for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != INT_MAX && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == INT_MAX ) return -1 ; return table [ V ] ; }
int main ( ) { int coins [ ] = { 9 , 6 , 5 , 1 } ; int m = sizeof ( coins ) / sizeof ( coins [ 0 ] ) ; int V = 11 ; cout << " Minimum ▁ coins ▁ required ▁ is ▁ " << minCoins ( coins , m , V ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int superSeq ( char * X , char * Y , int m , int n ) { if ( ! m ) return n ; if ( ! n ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; }
int main ( ) { char X [ ] = " AGGTAB " ; char Y [ ] = " GXTXAYB " ; cout << " Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is ▁ " << superSeq ( X , Y , strlen ( X ) , strlen ( Y ) ) ; return 0 ; }
int superSeq ( char * X , char * Y , int m , int n ) { int dp [ m + 1 ] [ n + 1 ] ;
for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) {
if ( ! i ) dp [ i ] [ j ] = j ; else if ( ! j ) dp [ i ] [ j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; }
int main ( ) { char X [ ] = " AGGTAB " ; char Y [ ] = " GXTXAYB " ; cout << " Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is ▁ " << superSeq ( X , Y , strlen ( X ) , strlen ( Y ) ) ; return 0 ; }
int sumOfDigitsFrom1ToN ( int n ) {
int result = 0 ;
for ( int x = 1 ; x <= n ; x ++ ) result += sumOfDigits ( x ) ; return result ; }
int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; }
int main ( ) { int n = 328 ; cout << " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ is ▁ " << sumOfDigitsFrom1ToN ( n ) ; return 0 ; }
int sumOfDigitsFrom1ToN ( int n ) {
if ( n < 10 ) return n * ( n + 1 ) / 2 ;
int d = log10 ( n ) ;
int * a = new int [ d + 1 ] ; a [ 0 ] = 0 , a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ceil ( pow ( 10 , i - 1 ) ) ;
int p = ceil ( pow ( 10 , d ) ) ;
int msd = n / p ;
return msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ; }
int main ( ) { int n = 328 ; cout << " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ is ▁ " << sumOfDigitsFrom1ToN ( n ) ; return 0 ; }
int countWays ( int N ) {
if ( N == 1 )
return 4 ;
int countB = 1 , countS = 1 , prev_countB , prev_countS ;
for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; }
int result = countS + countB ;
return ( result * result ) ; }
int main ( ) { int N = 3 ; cout << " Count ▁ of ▁ ways ▁ for ▁ " << N << " ▁ sections ▁ is ▁ " << countWays ( N ) ; return 0 ; }
int count ( int n ) {
int table [ n + 1 ] , i ;
table [ 0 ] = 1 ;
for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; }
int main ( void ) { int n = 20 ; cout << " Count ▁ for ▁ " << n << " ▁ is ▁ " << count ( n ) << endl ; n = 13 ; cout << " Count ▁ for ▁ " << n << " ▁ is ▁ " << count ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void search ( char * pat , char * txt ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ;
for ( int i = 0 ; i <= N - M ; i ++ ) { int j ;
for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ;
if ( j == M ) cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; } }
int main ( ) { char txt [ ] = " AABAACAADAABAAABAA " ; char pat [ ] = " AABA " ; search ( pat , txt ) ; return 0 ; }
#define d  256
void search ( char pat [ ] , char txt [ ] , int q ) { int M = strlen ( pat ) ; int N = strlen ( txt ) ; int i , j ;
int p = 0 ;
int t = 0 ; int h = 1 ;
for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ;
for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; }
for ( i = 0 ; i <= N - M ; i ++ ) {
if ( p == t ) {
for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; }
if ( j == M ) cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; }
if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ;
if ( t < 0 ) t = ( t + q ) ; } } }
int main ( ) { char txt [ ] = " GEEKS ▁ FOR ▁ GEEKS " ; char pat [ ] = " GEEK " ;
int q = 101 ;
search ( pat , txt , q ) ; return 0 ; }
void search ( string pat , string txt ) { int M = pat . size ( ) ; int N = txt . size ( ) ; int i = 0 ; while ( i <= N - M ) { int j ;
for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ;
if ( j == M ) { cout << " Pattern ▁ found ▁ at ▁ index ▁ " << i << endl ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else
i = i + j ; } }
int main ( ) { string txt = " ABCEABCDABCEABCD " ; string pat = " ABCD " ; search ( pat , txt ) ; return 0 ; }
void printPatternUtil ( const char str [ ] , char buff [ ] , int i , int j , int n ) { if ( i == n ) { buff [ j ] = ' \0' ; cout << buff << endl ; return ; }
buff [ j ] = str [ i ] ; printPatternUtil ( str , buff , i + 1 , j + 1 , n ) ;
buff [ j ] = ' ▁ ' ; buff [ j + 1 ] = str [ i ] ; printPatternUtil ( str , buff , i + 1 , j + 2 , n ) ; }
void printPattern ( const char * str ) { int n = strlen ( str ) ;
char buf [ 2 * n ] ;
buf [ 0 ] = str [ 0 ] ; printPatternUtil ( str , buf , 1 , 1 , n ) ; }
int main ( ) { const char * str = " ABCD " ; printPattern ( str ) ; return 0 ; }
int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = -1 , m2 = -1 ;
for ( count = 0 ; count <= n ; count ++ ) {
if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; }
else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; }
if ( ar1 [ i ] <= ar2 [ j ] ) {
m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else {
m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; }
int main ( ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n2 = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ; if ( n1 == n2 ) cout << " Median ▁ is ▁ " << getMedian ( ar1 , ar2 , n1 ) ; else cout << " Doesn ' t ▁ work ▁ for ▁ arrays " << " ▁ of ▁ unequal ▁ size " ; getchar ( ) ; return 0 ; }
float area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; }
bool isInside ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x , int y ) {
float A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ;
float A1 = area ( x , y , x2 , y2 , x3 , y3 ) ;
float A2 = area ( x1 , y1 , x , y , x3 , y3 ) ;
float A3 = area ( x1 , y1 , x2 , y2 , x , y ) ;
return ( A == A1 + A2 + A3 ) ; }
if ( isInside ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) printf ( " Inside " ) ; else printf ( " Not ▁ Inside " ) ; return 0 ; }
bool isLucky ( int n ) { static int counter = 2 ;
int next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ;
next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; }
int main ( ) { int x = 5 ; if ( isLucky ( x ) ) cout << x << " ▁ is ▁ a ▁ lucky ▁ no . " ; else cout << x << " ▁ is ▁ not ▁ a ▁ lucky ▁ no . " ; }
int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; }
int main ( ) { cout << pow ( 5 , 3 ) ; return 0 ; }
int multiply ( int x , int y ) { if ( y ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; }
int pow ( int a , int b ) { if ( b ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; }
int main ( ) { cout << pow ( 5 , 3 ) ; getchar ( ) ; return 0 ; }
int count ( int n ) {
if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ;
int po = 1 ; while ( n / po > 9 ) po = po * 10 ;
int msd = n / po ; if ( msd != 3 )
return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else
return count ( msd * po - 1 ) ; }
int main ( ) { cout << count ( 578 ) << " ▁ " ; return 0 ; }
int maximumNumberDistinctPrimeRange ( int m , int n ) {
long long factorCount [ n + 1 ] ;
bool prime [ n + 1 ] ;
for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ;
prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) {
if ( prime [ i ] == true ) {
factorCount [ i ] = 1 ;
for ( int j = i * 2 ; j <= n ; j += i ) {
factorCount [ j ] ++ ;
prime [ j ] = false ; } } }
int max = factorCount [ m ] ; int num = m ;
for ( int i = m ; i <= n ; i ++ ) {
if ( factorCount [ i ] > max ) { max = factorCount [ i ] ; num = i ; } } return num ; }
int main ( ) { int m = 4 , n = 6 ;
cout << maximumNumberDistinctPrimeRange ( m , n ) ; return 0 ; }
int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; }
int findSmallerInRight ( char * str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; }
int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; int i ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ;
countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; }
int main ( ) { char str [ ] = " string " ; cout << findRank ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_CHAR  256
int count [ MAX_CHAR ] = { 0 } ;
int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; }
void populateAndIncreaseCount ( int * count , char * str ) { int i ; for ( i = 0 ; str [ i ] ; ++ i ) ++ count [ str [ i ] ] ; for ( i = 1 ; i < MAX_CHAR ; ++ i ) count [ i ] += count [ i - 1 ] ; }
void updatecount ( int * count , char ch ) { int i ; for ( i = ch ; i < MAX_CHAR ; ++ i ) -- count [ i ] ; }
int findRank ( char * str ) { int len = strlen ( str ) ; int mul = fact ( len ) ; int rank = 1 , i ;
populateAndIncreaseCount ( count , str ) ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ;
rank += count [ str [ i ] - 1 ] * mul ;
updatecount ( count , str [ i ] ) ; } return rank ; }
int main ( ) { char str [ ] = " string " ; cout << findRank ( str ) ; return 0 ; }
float exponential ( int n , float x ) {
float sum = 1.0f ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; }
int main ( ) { int n = 10 ; float x = 1.0f ; cout << " e ^ x ▁ = ▁ " << fixed << setprecision ( 5 ) << exponential ( n , x ) ; return 0 ; }
bool isPerfectSquare ( int x ) { int s = sqrt ( x ) ; return ( s * s == x ) ; }
bool isFibonacci ( int n ) {
return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; }
int main ( ) { for ( int i = 1 ; i <= 10 ; i ++ ) isFibonacci ( i ) ? cout << i << " ▁ is ▁ a ▁ Fibonacci ▁ Number ▁ STRNEWLINE " : cout << i << " ▁ is ▁ a ▁ not ▁ Fibonacci ▁ Number ▁ STRNEWLINE " ; return 0 ; }
int findTrailingZeros ( int n ) {
int count = 0 ;
for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; }
int main ( ) { int n = 100 ; cout << " Count ▁ of ▁ trailing ▁ 0s ▁ in ▁ " << 100 << " ! ▁ is ▁ " << findTrailingZeros ( n ) ; return 0 ; }
unsigned long int catalan ( unsigned int n ) {
if ( n <= 1 ) return 1 ;
unsigned long int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ; return res ; }
int main ( ) { for ( int i = 0 ; i < 10 ; i ++ ) cout << catalan ( i ) << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; unsigned long int catalanDP ( unsigned int n ) {
unsigned long int catalan [ n + 1 ] ;
catalan [ 0 ] = catalan [ 1 ] = 1 ;
for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; }
return catalan [ n ] ; }
int main ( ) { for ( int i = 0 ; i < 10 ; i ++ ) cout << catalanDP ( i ) << " ▁ " ; return 0 ; }
unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ;
if ( k > n - k ) k = n - k ;
for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
unsigned long int catalan ( unsigned int n ) {
unsigned long int c = binomialCoeff ( 2 * n , n ) ;
return c / ( n + 1 ) ; }
int main ( ) { for ( int i = 0 ; i < 10 ; i ++ ) cout << catalan ( i ) << " ▁ " ; return 0 ; }
int min ( int x , int y ) { return ( x < y ) ? x : y ; }
int calcAngle ( double h , double m ) {
if ( h < 0 m < 0 h > 12 m > 60 ) printf ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; }
float hour_angle = 0.5 * ( h * 60 + m ) ; float minute_angle = 6 * m ;
float angle = abs ( hour_angle - minute_angle ) ;
angle = min ( 360 - angle , angle ) ; return angle ; }
int main ( ) { cout << calcAngle ( 9 , 60 ) << endl ; cout << calcAngle ( 3 , 30 ) << endl ; return 0 ; }
int getInvCount ( int arr [ ] ) { int inv_count = 0 ; for ( int i = 0 ; i < 9 - 1 ; i ++ ) for ( int j = i + 1 ; j < 9 ; j ++ )
if ( arr [ j ] && arr [ i ] && arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; }
bool isSolvable ( int puzzle [ 3 ] [ 3 ] ) {
int invCount = getInvCount ( ( int * ) puzzle ) ;
return ( invCount % 2 == 0 ) ; }
int main ( int argv , char * * args ) { int puzzle [ 3 ] [ 3 ] = { { 1 , 8 , 2 } , { 0 , 4 , 3 } , { 7 , 6 , 5 } } ; isSolvable ( puzzle ) ? cout << " Solvable " : cout << " Not ▁ Solvable " ; return 0 ; }
int find ( double p ) { return ceil ( sqrt ( 2 * 365 * log ( 1 / ( 1 - p ) ) ) ) ; }
int main ( ) { cout << find ( 0.70 ) ; }
int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; }
int main ( ) { cout << " Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " << countSolutions ( 6 ) << endl ; return 0 ; }
int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ;
for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ;
while ( yCount != 0 ) {
res += yCount ;
x ++ ;
while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; }
int main ( ) { cout << " Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " << countSolutions ( 6 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define EPSILON  0.001 NEW_LINE using namespace std ;
double func ( double x ) { return x * x * x - x * x + 2 ; }
double derivFunc ( double x ) { return 3 * x * x - 2 * x ; }
void newtonRaphson ( double x ) { double h = func ( x ) / derivFunc ( x ) ; while ( abs ( h ) >= EPSILON ) { h = func ( x ) / derivFunc ( x ) ;
x = x - h ; } cout << " The ▁ value ▁ of ▁ the ▁ root ▁ is ▁ : ▁ " << x ; }
double x0 = -20 ; newtonRaphson ( x0 ) ; return 0 ; }
int getSingle ( int arr [ ] , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) {
twos = twos | ( ones & arr [ i ] ) ;
ones = ones ^ arr [ i ] ;
common_bit_mask = ~ ( ones & twos ) ;
ones &= common_bit_mask ;
twos &= common_bit_mask ; } return ones ; }
int main ( ) { int arr [ ] = { 3 , 3 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " << getSingle ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define INT_SIZE  32 NEW_LINE int getSingle ( int arr [ ] , int n ) {
int result = 0 ; int x , sum ;
for ( int i = 0 ; i < INT_SIZE ; i ++ ) {
sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; }
if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; }
int main ( ) { int arr [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " << getSingle ( arr , n ) ; return 0 ; }
bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; }
int main ( ) { int x = 100 , y = -100 ; if ( oppositeSigns ( x , y ) == true ) printf ( " Signs ▁ are ▁ opposite " ) ; else printf ( " Signs ▁ are ▁ not ▁ opposite " ) ; return 0 ; }
unsigned int countSetBits ( unsigned int n ) {
int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; }
unsigned int countSetBitsUtil ( unsigned int x ) { if ( x <= 0 ) return 0 ; return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ; }
int main ( ) { int n = 4 ; printf ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ % d " , countSetBits ( n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSetBits ( int n ) { int i = 0 ;
int ans = 0 ;
while ( ( 1 << i ) <= n ) {
bool k = 0 ;
int change = 1 << i ;
for ( int j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) {
k = ! k ;
change = 1 << i ; } else { change -- ; } }
i ++ ; } return ans ; }
int main ( ) { int n = 17 ; cout << countSetBits ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int swapBits ( unsigned int x , unsigned int p1 , unsigned int p2 , unsigned int n ) {
unsigned int set1 = ( x >> p1 ) & ( ( 1U << n ) - 1 ) ;
unsigned int set2 = ( x >> p2 ) & ( ( 1U << n ) - 1 ) ;
unsigned int Xor = ( set1 ^ set2 ) ;
Xor = ( Xor << p1 ) | ( Xor << p2 ) ;
unsigned int result = x ^ Xor ; return result ; }
int main ( ) { int res = swapBits ( 28 , 0 , 3 , 2 ) ; cout << " Result ▁ = ▁ " << res ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int smallest ( int x , int y , int z ) { int c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; }
int main ( ) { int x = 12 , y = 15 , z = 5 ; cout << " Minimum ▁ of ▁ 3 ▁ numbers ▁ is ▁ " << smallest ( x , y , z ) ; return 0 ; }
uint_t snoob ( uint_t x ) { uint_t rightOne ; uint_t nextHigherOneBit ; uint_t rightOnesPattern ; uint_t next = 0 ; if ( x ) {
rightOne = x & - ( signed ) x ;
nextHigherOneBit = x + rightOne ;
rightOnesPattern = x ^ nextHigherOneBit ;
rightOnesPattern = ( rightOnesPattern ) / rightOne ;
rightOnesPattern >>= 2 ;
next = nextHigherOneBit | rightOnesPattern ; } return next ; }
int main ( ) { int x = 156 ; cout << " Next ▁ higher ▁ number ▁ with ▁ same ▁ number ▁ of ▁ set ▁ bits ▁ is ▁ " << snoob ( x ) ; getchar ( ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int addOne ( int x ) { int m = 1 ;
while ( x & m ) { x = x ^ m ; m <<= 1 ; }
x = x ^ m ; return x ; }
int main ( ) { cout << addOne ( 13 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int addOne ( int x ) { return ( - ( ~ x ) ) ; }
int main ( ) { cout << addOne ( 13 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; }
int main ( ) { int x = 4 ; printf ( " % d " , multiplyWith3Point5 ( x ) ) ; getchar ( ) ; return 0 ; }
int fun ( unsigned int n ) { return n & ( n - 1 ) ; }
int main ( ) { int n = 7 ; cout << " The ▁ number ▁ after ▁ unsetting ▁ the " ; cout << " ▁ rightmost ▁ set ▁ bit ▁ " << fun ( n ) ; return 0 ; }
public : bool isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } } ;
int main ( ) { GFG g ; int test_no = 64 ; if ( g . isPowerOfFour ( test_no ) ) cout << test_no << " ▁ is ▁ a ▁ power ▁ of ▁ 4" ; else cout << test_no << " is ▁ not ▁ a ▁ power ▁ of ▁ 4" ; getchar ( ) ; }
bool isPowerOfFour ( unsigned int n ) { int count = 0 ;
if ( n && ! ( n & ( n - 1 ) ) ) {
while ( n > 1 ) { n >>= 1 ; count += 1 ; }
return ( count % 2 == 0 ) ? 1 : 0 ; }
return 0 ; }
int main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) ) cout << test_no << " ▁ is ▁ a ▁ power ▁ of ▁ 4" ; else cout << test_no << " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4" ; }
public : int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x < y ) ) ; }
int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x < y ) ) ; } } ;
int main ( ) { gfg g ; int x = 15 ; int y = 6 ; cout << " Minimum ▁ of ▁ " << x << " ▁ and ▁ " << y << " ▁ is ▁ " ; cout << g . min ( x , y ) ; cout << " Maximum of " ▁ < < ▁ x ▁ < < STRNEWLINE " and " ▁ < < ▁ y ▁ < < ▁ " is " cout << g . max ( x , y ) ; getchar ( ) ; }
int getOddOccurrence ( int arr [ ] , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return -1 ; }
int main ( ) { int arr [ ] = { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << getOddOccurrence ( arr , n ) ; return 0 ; }
int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; }
int FlippedCount ( int a , int b ) {
return countSetBits ( a ^ b ) ; }
int main ( ) { int a = 10 ; int b = 20 ; cout << FlippedCount ( a , b ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; class gfg { public : unsigned int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; } } ;
int main ( ) { gfg g ; int n = 12 ; cout << g . getFirstSetBitPos ( n ) ; return 0 ; }
int PositionRightmostSetbit ( int n ) {
int position = 1 ; int m = 1 ; while ( ! ( n & m ) ) {
m = m << 1 ; position ++ ; } return position ; }
int main ( ) { int n = 16 ;
cout << PositionRightmostSetbit ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define INT_SIZE  32 NEW_LINE int Right_most_setbit ( int num ) {
for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ! ( num & ( 1 << i ) ) ) pos ++ ; else break ; } return pos ; } }
int main ( ) { int num = 0 ; int pos = Right_most_setbit ( num ) ; cout << pos << endl ; return 0 ; }
void bin ( unsigned n ) { if ( n > 1 ) bin ( n >> 1 ) ; printf ( " % d " , n & 1 ) ; }
int main ( void ) { bin ( 131 ) ; printf ( " STRNEWLINE " ) ; bin ( 3 ) ; return 0 ; }
unsigned int swapBits ( unsigned int x ) {
unsigned int even_bits = x & 0xAAAAAAAA ;
unsigned int odd_bits = x & 0x55555555 ;
even_bits >>= 1 ;
odd_bits <<= 1 ;
return ( even_bits odd_bits ) ; }
unsigned int x = 23 ;
cout << swapBits ( x ) ; return 0 ; }
int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; }
int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned i = 1 , pos = 1 ;
while ( ! ( i & n ) ) {
i = i << 1 ;
++ pos ; } return pos ; }
int main ( void ) { int n = 16 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number " << endl : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number " << endl : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number " << endl : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; return 0 ; }
int isPowerOfTwo ( unsigned n ) { return n && ( ! ( n & ( n - 1 ) ) ) ; }
int findPosition ( unsigned n ) { if ( ! isPowerOfTwo ( n ) ) return -1 ; unsigned count = 0 ;
while ( n ) { n = n >> 1 ;
++ count ; } return count ; }
int main ( void ) { int n = 0 ; int pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number STRNEWLINE " : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 12 ; pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number STRNEWLINE " : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; n = 128 ; pos = findPosition ( n ) ; ( pos == -1 ) ? cout << " n ▁ = ▁ " << n << " , ▁ Invalid ▁ number STRNEWLINE " : cout << " n ▁ = ▁ " << n << " , ▁ Position ▁ " << pos << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int x = 10 , y = 5 ;
x = x * y ;
y = x / y ;
x = x / y ; cout << " After ▁ Swapping : ▁ x ▁ = " << x << " , ▁ y = " << y ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int main ( ) { int x = 10 , y = 5 ;
x = x ^ y ;
y = x ^ y ;
x = x ^ y ; cout << " After ▁ Swapping : ▁ x ▁ = " << x << " , ▁ y = " << y ; return 0 ; }
void swap ( int * xp , int * yp ) { * xp = * xp ^ * yp ; * yp = * xp ^ * yp ; * xp = * xp ^ * yp ; }
int main ( ) { int x = 10 ; swap ( & x , & x ) ; cout << " After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ " << x ; return 0 ; }
int maxOnesIndex ( bool arr [ ] , int n ) {
int max_count = 0 ;
int max_index ;
int prev_zero = -1 ;
int prev_prev_zero = -1 ;
for ( int curr = 0 ; curr < n ; ++ curr ) {
if ( arr [ curr ] == 0 ) {
if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; }
prev_prev_zero = prev_zero ; prev_zero = curr ; } }
if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; }
int main ( ) { bool arr [ ] = { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ " << maxOnesIndex ( arr , n ) ; return 0 ; }
int min ( int x , int y ) { return ( x < y ) ? x : y ; } int max ( int x , int y ) { return ( x > y ) ? x : y ; }
int findLength ( int arr [ ] , int n ) {
int max_len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {
int mn = arr [ i ] , mx = arr [ i ] ;
for ( int j = i + 1 ; j < n ; j ++ ) {
mn = min ( mn , arr [ j ] ) ; mx = max ( mx , arr [ j ] ) ;
if ( ( mx - mn ) == j - i ) max_len = max ( max_len , mx - mn + 1 ) ; } }
return max_len ; }
int main ( ) { int arr [ ] = { 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is ▁ " << findLength ( arr , n ) ; return 0 ; }
void printArr ( int arr [ ] , int k ) { for ( int i = 0 ; i < k ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; }
void printSeqUtil ( int n , int k , int & len , int arr [ ] ) {
if ( len == k ) { printArr ( arr , k ) ; return ; }
int i = ( len == 0 ) ? 1 : arr [ len - 1 ] + 1 ;
len ++ ;
while ( i <= n ) { arr [ len - 1 ] = i ; printSeqUtil ( n , k , len , arr ) ; i ++ ; }
len -- ; }
void printSeq ( int n , int k ) {
int arr [ k ] ;
int len = 0 ; printSeqUtil ( n , k , len , arr ) ; }
int main ( ) { int k = 3 , n = 7 ; printSeq ( n , k ) ; return 0 ; }
bool isSubSequence ( char str1 [ ] , char str2 [ ] , int m , int n ) {
if ( m == 0 ) return true ; if ( n == 0 ) return false ;
if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ;
return isSubSequence ( str1 , str2 , m , n - 1 ) ; }
int main ( ) { char str1 [ ] = " gksrek " ; char str2 [ ] = " geeksforgeeks " ; int m = strlen ( str1 ) ; int n = strlen ( str2 ) ; isSubSequence ( str1 , str2 , m , n ) ? cout << " Yes ▁ " : cout << " No " ; return 0 ; }
void nextGreatest ( int arr [ ] , int size ) {
int max_from_right = arr [ size - 1 ] ;
arr [ size - 1 ] = -1 ;
for ( int i = size - 2 ; i >= 0 ; i -- ) {
int temp = arr [ i ] ;
arr [ i ] = max_from_right ;
if ( max_from_right < temp ) max_from_right = temp ; } }
void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; }
int main ( ) { int arr [ ] = { 16 , 17 , 4 , 3 , 5 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; nextGreatest ( arr , size ) ; cout << " The ▁ modified ▁ array ▁ is : ▁ STRNEWLINE " ; printArray ( arr , size ) ; return ( 0 ) ; }
int GetCeilIndex ( int arr [ ] , vector < int > & T , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; } int LongestIncreasingSubsequence ( int arr [ ] , int n ) {
vector < int > tailIndices ( n , 0 ) ;
vector < int > prevIndices ( n , -1 ) ;
int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) {
tailIndices [ 0 ] = i ; } else if ( arr [ i ] > arr [ tailIndices [ len - 1 ] ] ) {
prevIndices [ i ] = tailIndices [ len - 1 ] ; tailIndices [ len ++ ] = i ; } else {
int pos = GetCeilIndex ( arr , tailIndices , -1 , len - 1 , arr [ i ] ) ; prevIndices [ i ] = tailIndices [ pos - 1 ] ; tailIndices [ pos ] = i ; } } cout << " LIS ▁ of ▁ given ▁ input " << endl ; for ( int i = tailIndices [ len - 1 ] ; i >= 0 ; i = prevIndices [ i ] ) cout << arr [ i ] << " ▁ " ; cout << endl ; return len ; }
int main ( ) { int arr [ ] = { 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " LIS ▁ size ▁ % d STRNEWLINE " , LongestIncreasingSubsequence ( arr , n ) ) ; return 0 ; }
void generateUtil ( int A [ ] , int B [ ] , int C [ ] , int i , int j , int m , int n , int len , bool flag ) {
if ( flag ) {
if ( len ) printArr ( C , len + 1 ) ;
for ( int k = i ; k < m ; k ++ ) { if ( ! len ) {
C [ len ] = A [ k ] ;
generateUtil ( A , B , C , k + 1 , j , m , n , len , ! flag ) ; } else
{ if ( A [ k ] > C [ len ] ) { C [ len + 1 ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , ! flag ) ; } } } } else
{ for ( int l = j ; l < n ; l ++ ) { if ( B [ l ] > C [ len ] ) { C [ len + 1 ] = B [ l ] ; generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , ! flag ) ; } } } }
void generate ( int A [ ] , int B [ ] , int m , int n ) { int C [ m + n ] ;
generateUtil ( A , B , C , 0 , 0 , m , n , 0 , true ) ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; }
int main ( ) { int A [ ] = { 10 , 15 , 25 } ; int B [ ] = { 5 , 20 , 30 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int m = sizeof ( B ) / sizeof ( B [ 0 ] ) ; generate ( A , B , n , m ) ; return 0 ; }
void replace_elements ( int arr [ ] , int n ) {
int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } }
for ( int i = 0 ; i < pos ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 6 , 4 , 3 , 4 , 3 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; replace_elements ( arr , n ) ; return 0 ; }
void arrangeString ( string str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . length ( ) ;
for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count_0 ++ ; else count_1 ++ ; }
while ( count_0 > 0 count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { cout << "0" ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { cout << "1" ; count_1 -- ; } } } }
int main ( ) { string str = "01101101101101101000000" ; int x = 1 ; int y = 2 ; arrangeString ( str , x , y ) ; return 0 ; }
void rearrange ( int arr [ ] , int n ) {
if ( arr == NULL n % 2 == 1 ) return ;
int currIdx = ( n - 1 ) / 2 ;
while ( currIdx > 0 ) { int count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } }
int main ( ) { int arr [ ] = { 1 , 3 , 5 , 2 , 4 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; rearrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << " ▁ " << arr [ i ] ; }
int maxDiff ( int arr [ ] , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 0 ; i < arr_size ; i ++ ) { for ( int j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; }
int main ( ) { int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << " Maximum ▁ difference ▁ is ▁ " << maxDiff ( arr , n ) ; return 0 ; }
int maxDiff ( int arr [ ] , int n ) {
int maxDiff = -1 ;
int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; }
int main ( ) { int arr [ ] = { 1 , 2 , 90 , 10 , 110 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << " Maximum ▁ difference ▁ is ▁ " << maxDiff ( arr , n ) ; return 0 ; }
int maxDiff ( int arr [ ] , int n ) {
int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) {
diff = arr [ i + 1 ] - arr [ i ] ;
if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ;
if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; }
int main ( ) { int arr [ ] = { 80 , 2 , 6 , 3 , 100 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << " Maximum ▁ difference ▁ is ▁ " << maxDiff ( arr , n ) ; return 0 ; }
int findMaximum ( int arr [ ] , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; }
int main ( ) { int arr [ ] = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ maximum ▁ element ▁ is ▁ " << findMaximum ( arr , 0 , n - 1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findMaximum ( int arr [ ] , int low , int high ) {
if ( low == high ) return arr [ low ] ;
if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ;
if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ;
if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ;
if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ;
else return findMaximum ( arr , mid + 1 , high ) ; }
int main ( ) { int arr [ ] = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ maximum ▁ element ▁ is ▁ " << findMaximum ( arr , 0 , n - 1 ) ; return 0 ; }
int maxPathSum ( int ar1 [ ] , int ar2 [ ] , int m , int n ) {
int i = 0 , j = 0 ;
int result = 0 , sum1 = 0 , sum2 = 0 ;
while ( i < m && j < n ) {
if ( ar1 [ i ] < ar2 [ j ] ) sum1 += ar1 [ i ++ ] ;
else if ( ar1 [ i ] > ar2 [ j ] ) sum2 += ar2 [ j ++ ] ;
else {
result += max ( sum1 , sum2 ) + ar1 [ i ] ;
sum1 = 0 ; sum2 = 0 ;
i ++ ; j ++ ; } }
while ( i < m ) sum1 += ar1 [ i ++ ] ;
while ( j < n ) sum2 += ar2 [ j ++ ] ;
result += max ( sum1 , sum2 ) ; return result ; }
int main ( ) { int ar1 [ ] = { 2 , 3 , 7 , 10 , 12 , 15 , 30 , 34 } ; int ar2 [ ] = { 1 , 5 , 7 , 8 , 10 , 15 , 16 , 19 } ; int m = sizeof ( ar1 ) / sizeof ( ar1 [ 0 ] ) ; int n = sizeof ( ar2 ) / sizeof ( ar2 [ 0 ] ) ;
cout << " Maximum ▁ sum ▁ path ▁ is ▁ " << maxPathSum ( ar1 , ar2 , m , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void smallestGreater ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) {
int diff = INT_MAX , closest = -1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } }
( closest == -1 ) ? cout << " _ ▁ " : cout << arr [ closest ] << " ▁ " ; } }
int main ( ) { int ar [ ] = { 6 , 3 , 9 , 8 , 10 , 2 , 1 , 15 , 7 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; smallestGreater ( ar , n ) ; return 0 ; }
void findZeroes ( int arr [ ] , int n , int m ) {
int wL = 0 , wR = 0 ;
int bestL = 0 , bestWindow = 0 ;
int zeroCount = 0 ;
while ( wR < n ) {
if ( zeroCount <= m ) { if ( arr [ wR ] == 0 ) zeroCount ++ ; wR ++ ; }
if ( zeroCount > m ) { if ( arr [ wL ] == 0 ) zeroCount -- ; wL ++ ; }
if ( ( wR - wL > bestWindow ) && ( zeroCount <= m ) ) { bestWindow = wR - wL ; bestL = wL ; } }
for ( int i = 0 ; i < bestWindow ; i ++ ) { if ( arr [ bestL + i ] == 0 ) cout << bestL + i << " ▁ " ; } }
int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 } ; int m = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Indexes ▁ of ▁ zeroes ▁ to ▁ be ▁ flipped ▁ are ▁ " ; findZeroes ( arr , n , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIncreasing ( int arr [ ] , int n ) {
int cnt = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ;
else break ; } } return cnt ; }
int main ( ) { int arr [ ] = { 1 , 2 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is ▁ " << countIncreasing ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countIncreasing ( int arr [ ] , int n ) {
int cnt = 0 ;
int len = 1 ;
for ( int i = 0 ; i < n - 1 ; ++ i ) {
if ( arr [ i + 1 ] > arr [ i ] ) len ++ ;
else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } }
if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; }
int main ( ) { int arr [ ] = { 1 , 2 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is ▁ " << countIncreasing ( arr , n ) ; return 0 ; }
long long int arraySum ( int arr [ ] , int n ) { long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; }
long long int maxDiff ( int arr [ ] , int n , int k ) {
sort ( arr , arr + n ) ;
long long int arraysum = arraySum ( arr , n ) ;
long long int diff1 = abs ( arraysum - 2 * arraySum ( arr , k ) ) ;
reverse ( arr , arr + n ) ;
long long int diff2 = abs ( arraysum - 2 * arraySum ( arr , k ) ) ;
return ( max ( diff1 , diff2 ) ) ; }
int main ( ) { int arr [ ] = { 1 , 7 , 4 , 8 , -1 , 5 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << " Maximum ▁ Difference ▁ = ▁ " << maxDiff ( arr , n , k ) ; return 0 ; }
int minNumber ( int a [ ] , int n , int x ) {
sort ( a , a + n ) ; int k ; for ( k = 0 ; a [ ( n - 1 ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; sort ( a , a + n ) ; } return k ; }
int main ( ) { int x = 10 ; int a [ 6 ] = { 10 , 20 , 30 } ; int n = 3 ; cout << minNumber ( a , n , x ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minNumber ( int a [ ] , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] == x ) e ++ ;
else if ( a [ i ] > x ) h ++ ;
else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ;
return ans + 1 - e ; }
int main ( ) { int x = 10 ; int a [ ] = { 10 , 20 , 30 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minNumber ( a , n , x ) << endl ; return 0 ; }
void checkEVENodd ( int arr [ ] , int n , int l , int r ) {
if ( arr [ r ] == 1 ) cout << " odd " << endl ;
else cout < < " even " << endl ; }
int main ( ) { int arr [ ] = { 1 , 1 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkEVENodd ( arr , n , 1 , 3 ) ; return 0 ; }
int findMean ( int arr [ ] , int l , int r ) {
int sum = 0 , count = 0 ;
for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; }
int mean = floor ( sum / count ) ;
return mean ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; cout << findMean ( arr , 0 , 2 ) << endl ; cout << findMean ( arr , 1 , 3 ) << endl ; cout << findMean ( arr , 0 , 4 ) << endl ; return 0 ; }
int calculateProduct ( int A [ ] , int L , int R , int P ) {
L = L - 1 ; R = R - 1 ; int ans = 1 ; for ( int i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; }
int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int P = 229 ; int L = 2 , R = 5 ; cout << calculateProduct ( A , L , R , P ) << endl ; L = 1 , R = 3 ; cout << calculateProduct ( A , L , R , P ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ;
int prefix [ MAX + 1 ] ; void buildPrefix ( ) {
bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } }
prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] ++ ; } }
int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; }
int main ( ) { buildPrefix ( ) ; int L = 5 , R = 10 ; cout << query ( L , R ) << endl ; L = 1 , R = 10 ; cout << query ( L , R ) << endl ; return 0 ; }
void command ( bool arr [ ] , int a , int b ) { arr [ a ] ^= 1 ; arr [ b + 1 ] ^= 1 ; }
void process ( bool arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) arr [ k ] ^= arr [ k - 1 ] ; }
void result ( bool arr [ ] , int n ) { for ( int k = 1 ; k <= n ; k ++ ) cout << arr [ k ] << " ▁ " ; }
int main ( ) { int n = 5 , m = 3 ; bool arr [ n + 2 ] = { 0 } ;
command ( arr , 1 , 5 ) ; command ( arr , 2 , 5 ) ; command ( arr , 3 , 5 ) ;
process ( arr , n ) ;
result ( arr , n ) ; return 0 ; }
double probability ( int a [ ] , int b [ ] , int size1 , int size2 ) {
int max1 = INT_MIN , count1 = 0 ; for ( int i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max1 ) { max1 = a [ i ] ; count1 = 1 ; } else if ( a [ i ] == max1 ) { count1 ++ ; } }
int max2 = INT_MIN , count2 = 0 ; for ( int i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max2 ) { max2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max2 ) { count2 ++ ; } }
return ( double ) ( count1 * count2 ) / ( size1 * size2 ) ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int b [ ] = { 1 , 3 , 3 } ; int size1 = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int size2 = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << probability ( a , b , size1 , size2 ) ; return 0 ; }
int countDe ( int arr [ ] , int n ) {
vector < int > v ( arr , arr + n ) ;
sort ( arr , arr + n ) ;
int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ;
reverse ( arr , arr + n ) ;
int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ;
return ( min ( count1 , count2 ) ) ; }
int main ( ) { int arr [ ] = { 5 , 9 , 21 , 17 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ Dearrangement ▁ = ▁ " << countDe ( arr , n ) ; return 0 ; }
int maxOfSegmentMins ( int a [ ] , int n , int k ) {
if ( k == 1 ) return * min_element ( a , a + n ) ; if ( k == 2 ) return max ( a [ 0 ] , a [ n - 1 ] ) ;
return * max_element ( a , a + n ) ; }
int main ( ) { int a [ ] = { -10 , -9 , -8 , 2 , 7 , -6 , -5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 2 ; cout << maxOfSegmentMins ( a , n , k ) ; }
int printMinimumProduct ( int arr [ ] , int n ) {
int first_min = min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = max ( arr [ 0 ] , arr [ 1 ] ) ;
for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; }
int main ( ) { int a [ ] = { 11 , 8 , 5 , 7 , 5 , 100 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << printMinimumProduct ( a , n ) ; return 0 ; }
long long noOfTriples ( long long arr [ ] , int n ) {
sort ( arr , arr + n ) ;
long long count = 0 ; for ( long long i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ;
if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ;
else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ;
return count ; }
int main ( ) { long long arr [ ] = { 1 , 3 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << noOfTriples ( arr , n ) ; return 0 ; }
bool checkReverse ( int arr [ ] , int n ) {
int temp [ n ] ; for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = arr [ i ] ;
sort ( temp , temp + n ) ;
int front ; for ( front = 0 ; front < n ; front ++ ) if ( temp [ front ] != arr [ front ] ) break ;
int back ; for ( back = n - 1 ; back >= 0 ; back -- ) if ( temp [ back ] != arr [ back ] ) break ;
if ( front >= back ) return true ;
do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) return false ; } while ( front != back ) ; return true ; }
int main ( ) { int arr [ ] = { 1 , 2 , 5 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkReverse ( arr , n ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; return 0 ; }
bool checkReverse ( int arr [ ] , int n ) { if ( n == 1 ) return true ;
int i ; for ( i = 1 ; i < n && arr [ i - 1 ] < arr [ i ] ; i ++ ) ; if ( i == n ) return true ;
int j = i ; while ( j < n && arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ; j ++ ; } if ( j == n ) return true ;
int k = j ;
if ( arr [ k ] < arr [ i - 1 ] ) return false ; while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) return false ; k ++ ; } return true ; }
int main ( ) { int arr [ ] = { 1 , 3 , 4 , 10 , 9 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; checkReverse ( arr , n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOperation ( int a [ ] , int b [ ] , int n ) {
sort ( a , a + n ) ; sort ( b , b + n ) ;
int result = 0 ;
for ( int i = 0 ; i < n ; ++ i ) { result = result + abs ( a [ i ] - b [ i ] ) ; } return result ; }
int main ( ) { int a [ ] = { 3 , 1 , 1 } ; int b [ ] = { 1 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MinOperation ( a , b , n ) ; return 0 ; }
void sortExceptUandL ( int a [ ] , int l , int u , int n ) {
int b [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ;
sort ( b , b + n - ( u - l + 1 ) ) ;
for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; }
int main ( ) { int a [ ] = { 5 , 4 , 3 , 12 , 14 , 9 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int l = 2 , u = 4 ; sortExceptUandL ( a , l , u , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sortExceptK ( int arr [ ] , int k , int n ) {
swap ( arr [ k ] , arr [ n - 1 ] ) ;
sort ( arr , arr + n - 1 ) ;
int last = arr [ n - 1 ] ;
for ( int i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ;
arr [ k ] = last ; }
int main ( ) { int a [ ] = { 10 , 4 , 11 , 7 , 6 , 20 } ; int k = 2 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; sortExceptK ( a , k , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << a [ i ] << " ▁ " ; }
int maxPartitions ( int arr [ ] , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) {
max_so_far = max ( max_so_far , arr [ i ] ) ;
if ( max_so_far == i ) ans ++ ; } return ans ; }
int main ( ) { int arr [ ] = { 1 , 0 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxPartitions ( arr , n ) ; return 0 ; }
void cuttringRopes ( int Ropes [ ] , int n ) {
sort ( Ropes , Ropes + n ) ; int singleOperation = 0 ;
int cuttingLenght = Ropes [ 0 ] ;
for ( int i = 1 ; i < n ; i ++ ) {
if ( Ropes [ i ] - cuttingLenght > 0 ) { cout << ( n - i ) << " ▁ " ;
cuttingLenght = Ropes [ i ] ; singleOperation ++ ; } }
if ( singleOperation == 0 ) cout << "0 ▁ " ; }
int main ( ) { int Ropes [ ] = { 5 , 1 , 1 , 2 , 3 , 5 } ; int n = sizeof ( Ropes ) / sizeof ( Ropes [ 0 ] ) ; cuttringRopes ( Ropes , n ) ; return 0 ; }
void rankify ( int * A , int n ) {
float R [ n ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) { int r = 1 , s = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i && A [ j ] < A [ i ] ) r += 1 ; if ( j != i && A [ j ] == A [ i ] ) s += 1 ; }
R [ i ] = r + ( float ) ( s - 1 ) / ( float ) 2 ; } for ( int i = 0 ; i < n ; i ++ ) cout << R [ i ] << ' ▁ ' ; }
int main ( ) { int A [ ] = { 1 , 2 , 5 , 2 , 1 , 25 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) cout << A [ i ] << ' ▁ ' ; cout << ' ' ; rankify ( A , n ) ; return 0 ; }
int min_noOf_operation ( int arr [ ] , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) {
noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ;
if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ;
arr [ i ] = arr [ i ] - k * noOfSubtraction ; }
res = res + noOfSubtraction ; } return res ; }
int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << min_noOf_operation ( arr , N , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; }
int main ( ) { int arr [ ] = { 3 , 5 , 6 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) << endl ; return 0 ; }
int countPairs ( int a [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; }
int main ( ) { int a [ ] = { 1 , 10 , 4 , 2 } ; int k = 3 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countPairs ( int a [ ] , int n , int k ) {
sort ( a , a + n ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; }
int main ( ) { int a [ ] = { 1 , 10 , 4 , 2 } ; int k = 3 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n , k ) << endl ; return 0 ; }
int sumOfMinAbsDifferences ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int sum = 0 ;
sum += abs ( arr [ 0 ] - arr [ 1 ] ) ;
sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ;
for ( int i = 1 ; i < n - 1 ; i ++ ) sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) ;
return sum ; }
int main ( ) { int arr [ ] = { 5 , 10 , 1 , 4 , 8 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ = ▁ " << sumOfMinAbsDifferences ( arr , n ) ; }
int findSmallestDifference ( int A [ ] , int B [ ] , int m , int n ) {
sort ( A , A + m ) ; sort ( B , B + n ) ; int a = 0 , b = 0 ;
int result = INT_MAX ;
while ( a < m && b < n ) { if ( abs ( A [ a ] - B [ b ] ) < result ) result = abs ( A [ a ] - B [ b ] ) ;
if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; }
return result ; }
int main ( ) {
int A [ ] = { 1 , 2 , 11 , 5 } ;
int B [ ] = { 4 , 12 , 19 , 23 , 127 , 235 } ;
int m = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int n = sizeof ( B ) / sizeof ( B [ 0 ] ) ;
cout << findSmallestDifference ( A , B , m , n ) ; return 0 ; }
void findLarger ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
for ( int i = n - 1 ; i >= n / 2 ; i -- ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 1 , 3 , 6 , 1 , 0 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findLarger ( arr , n ) ; return 0 ; }
int getMissingNo ( int a [ ] , int n ) { int total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; }
int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int miss = getMissingNo ( arr , n ) ; cout << miss ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; }
int main ( ) { int arr [ ] = { 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 2 ; cout << countOccurrences ( arr , n , x ) ; return 0 ; }
int binarySearch ( int arr [ ] , int l , int r , int x ) { if ( r < l ) return -1 ; int mid = l + ( r - l ) / 2 ;
if ( arr [ mid ] == x ) return mid ;
if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ;
return binarySearch ( arr , mid + 1 , r , x ) ; }
int countOccurrences ( int arr [ ] , int n , int x ) { int ind = binarySearch ( arr , 0 , n - 1 , x ) ;
if ( ind == -1 ) return 0 ;
int count = 1 ; int left = ind - 1 ; while ( left >= 0 && arr [ left ] == x ) count ++ , left -- ;
int right = ind + 1 ; while ( right < n && arr [ right ] == x ) count ++ , right ++ ; return count ; }
int main ( ) { int arr [ ] = { 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 2 ; cout << countOccurrences ( arr , n , x ) ; return 0 ; }
void printClosest ( int arr [ ] , int n , int x ) {
int res_l , res_r ;
int l = 0 , r = n - 1 , diff = INT_MAX ;
while ( r > l ) {
if ( abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = abs ( arr [ l ] + arr [ r ] - x ) ; }
if ( arr [ l ] + arr [ r ] > x ) r -- ;
else l ++ ; } cout << " ▁ The ▁ closest ▁ pair ▁ is ▁ " << arr [ res_l ] << " ▁ and ▁ " << arr [ res_r ] ; }
int main ( ) { int arr [ ] = { 10 , 22 , 28 , 29 , 30 , 40 } , x = 54 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printClosest ( arr , n , x ) ; return 0 ; }
int countOnes ( bool arr [ ] , int low , int high ) { if ( high >= low ) {
int mid = low + ( high - low ) / 2 ;
if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ;
if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ;
return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; }
int main ( ) { bool arr [ ] = { 1 , 1 , 1 , 1 , 0 , 0 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is ▁ " << countOnes ( arr , 0 , n - 1 ) ; return 0 ; }
int findMissingUtil ( int arr1 [ ] , int arr2 [ ] , int N ) {
if ( N == 1 ) return arr1 [ 0 ] ;
if ( arr1 [ 0 ] != arr2 [ 0 ] ) return arr1 [ 0 ] ;
int lo = 0 , hi = N - 1 ;
while ( lo < hi ) { int mid = ( lo + hi ) / 2 ;
if ( arr1 [ mid ] == arr2 [ mid ] ) lo = mid ; else hi = mid ;
if ( lo == hi - 1 ) break ; }
return arr1 [ hi ] ; }
void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( N == M - 1 ) cout << " Missing ▁ Element ▁ is ▁ " << findMissingUtil ( arr1 , arr2 , M ) << endl ; else if ( M == N - 1 ) cout << " Missing ▁ Element ▁ is ▁ " << findMissingUtil ( arr2 , arr1 , N ) << endl ; else cout << " Invalid ▁ Input " ; }
int main ( ) { int arr1 [ ] = { 1 , 4 , 5 , 7 , 9 } ; int arr2 [ ] = { 4 , 5 , 7 , 9 } ; int M = sizeof ( arr1 ) / sizeof ( int ) ; int N = sizeof ( arr2 ) / sizeof ( int ) ; findMissing ( arr1 , arr2 , M , N ) ; return 0 ; }
void findMissing ( int arr1 [ ] , int arr2 [ ] , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { cout << " Invalid ▁ Input " ; return ; }
int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; cout << " Missing ▁ element ▁ is ▁ " << res ; }
int main ( ) { int arr1 [ ] = { 4 , 1 , 5 , 9 , 7 } ; int arr2 [ ] = { 7 , 5 , 9 , 4 } ; int M = sizeof ( arr1 ) / sizeof ( int ) ; int N = sizeof ( arr2 ) / sizeof ( int ) ; findMissing ( arr1 , arr2 , M , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwoElements ( int arr [ ] , int size ) { int i ; cout << " ▁ The ▁ repeating ▁ element ▁ is ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ abs ( arr [ i ] ) - 1 ] > 0 ) arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] ; else cout << abs ( arr [ i ] ) << " STRNEWLINE " ; } cout << " and ▁ the ▁ missing ▁ element ▁ is ▁ " ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) cout << ( i + 1 ) ; } }
int main ( ) { int arr [ ] = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printTwoElements ( arr , n ) ; }
void getTwoElements ( int arr [ ] , int n , int * x , int * y ) {
int xor1 ;
int set_bit_no ; int i ; * x = 0 ; * y = 0 ; xor1 = arr [ 0 ] ;
for ( i = 1 ; i < n ; i ++ ) xor1 = xor1 ^ arr [ i ] ;
for ( i = 1 ; i <= n ; i ++ ) xor1 = xor1 ^ i ;
set_bit_no = xor1 & ~ ( xor1 - 1 ) ;
for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit_no )
* x = * x ^ arr [ i ] ; else
* y = * y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no )
* x = * x ^ i ; else
* y = * y ^ i ; }
}
int main ( ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 , 6 , 2 } ; int * x = ( int * ) malloc ( sizeof ( int ) ) ; int * y = ( int * ) malloc ( sizeof ( int ) ) ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; getTwoElements ( arr , n , x , y ) ; cout << " ▁ The ▁ missing ▁ element ▁ is ▁ " << * x << " ▁ and ▁ the ▁ repeating " << " ▁ number ▁ is ▁ " << * y ; getchar ( ) ; }
void findFourElements ( int A [ ] , int n , int X ) {
for ( int i = 0 ; i < n - 3 ; i ++ ) {
for ( int j = i + 1 ; j < n - 2 ; j ++ ) {
for ( int k = j + 1 ; k < n - 1 ; k ++ ) {
for ( int l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) cout << A [ i ] << " , ▁ " << A [ j ] << " , ▁ " << A [ k ] << " , ▁ " << A [ l ] ; } } } }
int main ( ) { int A [ ] = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int X = 91 ; findFourElements ( A , n , X ) ; return 0 ; }
int search ( int arr [ ] , int n , int x ) {
int i = 0 ; while ( i < n ) {
if ( arr [ i ] == x ) return i ;
i = i + abs ( arr [ i ] - x ) ; } cout << " number ▁ is ▁ not ▁ present ! " ; return -1 ; }
int main ( ) { int arr [ ] = { 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 3 ; cout << " Element ▁ " << x << " ▁ is ▁ present ▁ at ▁ index ▁ " << search ( arr , n , 3 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void thirdLargest ( int arr [ ] , int arr_size ) {
if ( arr_size < 3 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; }
int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ;
int second = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ;
int third = INT_MIN ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; printf ( " The ▁ third ▁ Largest ▁ element ▁ is ▁ % d STRNEWLINE " , third ) ; }
int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; thirdLargest ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void thirdLargest ( int arr [ ] , int arr_size ) {
if ( arr_size < 3 ) { printf ( " ▁ Invalid ▁ Input ▁ " ) ; return ; }
int first = arr [ 0 ] , second = INT_MIN , third = INT_MIN ;
for ( int i = 1 ; i < arr_size ; i ++ ) {
if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; }
else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; }
else if ( arr [ i ] > third ) third = arr [ i ] ; } printf ( " The ▁ third ▁ Largest ▁ element ▁ is ▁ % d STRNEWLINE " , third ) ; }
int main ( ) { int arr [ ] = { 12 , 13 , 1 , 10 , 34 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; thirdLargest ( arr , n ) ; return 0 ; }
bool checkPair ( int arr [ ] , int n ) {
int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;
if ( sum % 2 != 0 ) return false ; sum = sum / 2 ;
unordered_set < int > s ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ;
if ( s . find ( val ) != s . end ( ) ) { printf ( " Pair ▁ elements ▁ are ▁ % d ▁ and ▁ % d STRNEWLINE " , arr [ i ] , val ) ; return true ; } s . insert ( arr [ i ] ) ; } return false ; }
int main ( ) { int arr [ ] = { 2 , 11 , 5 , 1 , 4 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkPair ( arr , n ) == false ) printf ( " No ▁ pair ▁ found " ) ; return 0 ; }
string search ( int arr [ ] , int n , int x ) {
if ( arr [ n - 1 ] == x ) return " Found " ; int backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ;
for ( int i = 0 ; ; i ++ ) {
if ( arr [ i ] == x ) {
arr [ n - 1 ] = backup ;
if ( i < n - 1 ) return " Found " ;
return " Not ▁ Found " ; } } }
int main ( ) { int arr [ ] = { 4 , 6 , 1 , 5 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 1 ; cout << search ( arr , n , x ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findMajority ( int arr [ ] , int n ) { return arr [ n / 2 ] ; }
int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMajority ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minAdjDifference ( int arr [ ] , int n ) { if ( n < 2 ) return ;
int res = abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) ;
res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; cout << " Min ▁ Difference ▁ = ▁ " << res ; }
int main ( ) { int a [ ] = { 10 , 12 , 13 , 15 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; minAdjDifference ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100000 NEW_LINE using namespace std ; int Print3Smallest ( int array [ ] , int n ) { int firstmin = MAX , secmin = MAX , thirdmin = MAX ; for ( int i = 0 ; i < n ; i ++ ) {
if ( array [ i ] < firstmin ) { thirdmin = secmin ; secmin = firstmin ; firstmin = array [ i ] ; }
else if ( array [ i ] < secmin ) { thirdmin = secmin ; secmin = array [ i ] ; }
else if ( array [ i ] < thirdmin ) thirdmin = array [ i ] ; } cout << " First ▁ min ▁ = ▁ " << firstmin << " STRNEWLINE " ; cout << " Second ▁ min ▁ = ▁ " << secmin << " STRNEWLINE " ; cout << " Third ▁ min ▁ = ▁ " << thirdmin << " STRNEWLINE " ; }
int main ( ) { int array [ ] = { 4 , 9 , 1 , 32 , 12 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; Print3Smallest ( array , n ) ; return 0 ; }
int getMin ( int arr [ ] , int n ) { return * min_element ( arr , arr + n ) ; } int getMax ( int arr [ ] , int n ) { return * max_element ( arr , arr + n ) ; }
int main ( ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ element ▁ of ▁ array : ▁ " << getMin ( arr , n ) << " STRNEWLINE " ; cout << " Maximum ▁ element ▁ of ▁ array : ▁ " << getMax ( arr , n ) ; return 0 ; }
void printfrequency ( int arr [ ] , int n ) {
for ( int j = 0 ; j < n ; j ++ ) arr [ j ] = arr [ j ] - 1 ;
for ( int i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % n ] = arr [ arr [ i ] % n ] + n ;
for ( int i = 0 ; i < n ; i ++ ) cout << i + 1 << " ▁ - > ▁ " << arr [ i ] / n << endl ; }
int main ( ) { int arr [ ] = { 2 , 3 , 3 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printfrequency ( arr , n ) ; return 0 ; }
int getInvCount ( int arr [ ] , int n ) {
int invcount = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) {
int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ;
int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ;
invcount += great * small ; } return invcount ; }
int main ( ) { int arr [ ] = { 8 , 4 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Inversion ▁ Count ▁ : ▁ " << getInvCount ( arr , n ) ; return 0 ; }
int findWater ( int arr [ ] , int n ) {
int water = 0 ;
left [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) left [ i ] = max ( left [ i - 1 ] , arr [ i ] ) ;
right [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) right [ i ] = max ( right [ i + 1 ] , arr [ i ] ) ;
for ( int i = 0 ; i < n ; i ++ ) water += min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; }
int main ( ) { int arr [ ] = { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ water ▁ that ▁ can ▁ be ▁ accumulated ▁ is ▁ " << findWater ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findWater ( int arr [ ] , int n ) {
int result = 0 ;
int left_max = 0 , right_max = 0 ;
int lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max )
left_max = arr [ lo ] ; else
result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max )
right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; }
int main ( ) { int arr [ ] = { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ water ▁ that ▁ can ▁ be ▁ accumulated ▁ is ▁ " << findWater ( arr , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printUncommon ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) {
if ( arr1 [ i ] < arr2 [ j ] ) { cout << arr1 [ i ] << " ▁ " ; i ++ ; k ++ ; } else if ( arr2 [ j ] < arr1 [ i ] ) { cout << arr2 [ j ] << " ▁ " ; k ++ ; j ++ ; }
else { i ++ ; j ++ ; } }
while ( i < n1 ) { cout << arr1 [ i ] << " ▁ " ; i ++ ; k ++ ; } while ( j < n2 ) { cout << arr2 [ j ] << " ▁ " ; j ++ ; k ++ ; } }
int main ( ) { int arr1 [ ] = { 10 , 20 , 30 } ; int arr2 [ ] = { 20 , 25 , 30 , 40 , 50 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printUncommon ( arr1 , arr2 , n1 , n2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int leastFrequent ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int min_count = n + 1 , res = -1 , curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } }
if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ n - 1 ] ; } return res ; }
int main ( ) { int arr [ ] = { 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << leastFrequent ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define M  4 NEW_LINE using namespace std ;
int maximumSum ( int a [ ] [ M ] , int n ) {
for ( int i = 0 ; i < n ; i ++ ) sort ( a [ i ] , a [ i ] + M ) ;
int sum = a [ n - 1 ] [ M - 1 ] ; int prev = a [ n - 1 ] [ M - 1 ] ; int i , j ;
for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev ) { prev = a [ i ] [ j ] ; sum += prev ; break ; } }
if ( j == -1 ) return 0 ; } return sum ; }
int main ( ) { int arr [ ] [ M ] = { { 1 , 7 , 3 , 4 } , { 4 , 2 , 5 , 1 } , { 9 , 5 , 1 , 8 } } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumSum ( arr , n ) ; return 0 ; }
int countPairs ( int A [ ] , int n , int k ) { int ans = 0 ;
sort ( A , A + n ) ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) {
int x = 0 ;
while ( ( A [ i ] * pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; }
int main ( ) { int A [ ] = { 3 , 8 , 9 , 12 , 18 , 4 , 24 , 2 , 6 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int k = 3 ; cout << countPairs ( A , n , k ) ; return 0 ; }
int findValue ( int a [ ] , int n , int k ) {
for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == k ) k *= 2 ; } return k ; }
int main ( ) { int arr [ ] = { 2 , 3 , 4 , 10 , 8 , 1 } , k = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findValue ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void dupLastIndex ( int arr [ ] , int n ) {
if ( arr == NULL n <= 0 ) return ;
for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { printf ( " Last ▁ index : ▁ % d STRNEWLINE Last ▁ " " duplicate ▁ item : ▁ % d STRNEWLINE " , i , arr [ i ] ) ; return ; } }
printf ( " no ▁ duplicate ▁ found " ) ; }
int main ( ) { int arr [ ] = { 1 , 5 , 5 , 6 , 6 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( int ) ; dupLastIndex ( arr , n ) ; return 0 ; }
int findSmallest ( int a [ ] , int n ) {
for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] ) break ;
if ( j == n ) return a [ i ] ; } return -1 ; }
int main ( ) { int a [ ] = { 25 , 20 , 5 , 10 , 100 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << findSmallest ( a , n ) ; return 0 ; }
int findSmallest ( int a [ ] , int n ) {
int smallest = * min_element ( a , a + n ) ;
for ( int i = 1 ; i < n ; i ++ ) if ( a [ i ] % smallest ) return -1 ; return smallest ; }
int main ( ) { int a [ ] = { 25 , 20 , 5 , 10 , 100 } ; int n = sizeof ( a ) / sizeof ( int ) ; cout << findSmallest ( a , n ) ; return 0 ; }
int findIndex ( int arr [ ] , int len ) {
int maxIndex = 0 ; for ( int i = 0 ; i < len ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ;
for ( int i = 0 ; i < len ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return -1 ; return maxIndex ; }
int main ( ) { int arr [ ] = { 3 , 6 , 1 , 0 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( findIndex ( arr , len ) ) ; }
int find_consecutive_steps ( int arr [ ] , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) {
if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = max ( maximum , count ) ; count = 0 ; } } return max ( maximum , count ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int len = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << find_consecutive_steps ( arr , len ) ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll CalculateMax ( ll arr [ ] , int n ) {
sort ( arr , arr + n ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return abs ( max_sum - min_sum ) ; }
int main ( ) { ll arr [ ] = { 6 , 7 , 1 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CalculateMax ( arr , n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE using namespace std ; ll calculate ( ll a [ ] , ll n ) {
sort ( a , a + n ) ;
vector < ll > s ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push_back ( a [ i ] + a [ j ] ) ; ll mini = * min_element ( s . begin ( ) , s . end ( ) ) ; ll maxi = * max_element ( s . begin ( ) , s . end ( ) ) ; return abs ( maxi - mini ) ; }
int main ( ) { ll a [ ] = { 2 , 6 , 4 , 3 } ; int n = sizeof ( a ) / ( sizeof ( a [ 0 ] ) ) ; cout << calculate ( a , n ) << endl ; return 0 ; }
void printMinDiffPairs ( int arr [ ] , int n ) { if ( n <= 1 ) return ;
sort ( arr , arr + n ) ;
int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ;
for ( int i = 1 ; i < n ; i ++ ) if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) cout << " ( " << arr [ i - 1 ] << " , ▁ " << arr [ i ] << " ) , ▁ " ; }
int main ( ) { int arr [ ] = { 5 , 3 , 2 , 4 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMinDiffPairs ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int calculateDiff ( int i , int j , int arr [ ] ) {
return abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ; }
int maxDistance ( int arr [ ] , int n ) {
int result = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) {
if ( calculateDiff ( i , j , arr ) > result ) result = calculateDiff ( i , j , arr ) ; } } return result ; }
int main ( ) { int arr [ ] = { -70 , -64 , -6 , -56 , 64 , 61 , -57 , 16 , 48 , -98 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxDistance ( arr , n ) << endl ; return 0 ; }
int maxDistance ( int arr [ ] , int n ) {
int max1 = INT_MIN , min1 = INT_MAX ; int max2 = INT_MIN , min2 = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) {
max1 = max ( max1 , arr [ i ] + i ) ; min1 = min ( min1 , arr [ i ] + i ) ; max2 = max ( max2 , arr [ i ] - i ) ; min2 = min ( min2 , arr [ i ] - i ) ; }
return max ( max1 - min1 , max2 - min2 ) ; }
int main ( ) { int arr [ ] = { -70 , -64 , -6 , -56 , 64 , 61 , -57 , 16 , 48 , -98 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxDistance ( arr , n ) << endl ; return 0 ; }
int extrema ( int a [ ] , int n ) { int count = 0 ;
for ( int i = 1 ; i < n - 1 ; i ++ ) {
count += ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) ;
count += ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) ; } return count ; }
int main ( ) { int a [ ] = { 1 , 0 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << extrema ( a , n ) ; return 0 ; }
int findClosest ( int arr [ ] , int n , int target ) {
if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ;
int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ;
if ( target < arr [ mid ] ) {
if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ;
j = mid ; }
else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ;
i = mid + 1 ; } }
return arr [ mid ] ; }
int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; }
int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int target = 11 ; cout << ( findClosest ( arr , n , target ) ) ; }
int sum ( int a [ ] , int n ) {
int maxSum = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) maxSum = max ( maxSum , a [ i ] + a [ j ] ) ;
int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; }
int main ( ) { int array [ ] = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << sum ( array , n ) ; return 0 ; }
int sum ( int a [ ] , int n ) {
int maxVal = a [ 0 ] , maxCount = 1 ; int secondMax = INT_MIN , secondMaxCount ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == maxVal ) maxCount ++ ; else if ( a [ i ] > maxVal ) { secondMax = maxVal ; secondMaxCount = maxCount ; maxVal = a [ i ] ; maxCount = 1 ; } else if ( a [ i ] == secondMax ) { secondMax = a [ i ] ; secondMaxCount ++ ; } else if ( a [ i ] > secondMax ) { secondMax = a [ i ] ; secondMaxCount = 1 ; } }
if ( maxCount > 1 ) return maxCount * ( maxCount - 1 ) / 2 ;
return secondMaxCount ; }
int main ( ) { int array [ ] = { 1 , 1 , 1 , 2 , 2 , 2 , 3 } ; int n = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << sum ( array , n ) ; return 0 ; }
void printKMissing ( int arr [ ] , int n , int k ) { sort ( arr , arr + n ) ;
int i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ;
int count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { cout << curr << " ▁ " ; count ++ ; } else i ++ ; curr ++ ; }
while ( count < k ) { cout << curr << " ▁ " ; curr ++ ; count ++ ; } }
int main ( ) { int arr [ ] = { 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; printKMissing ( arr , n , k ) ; return 0 ; }
int nobleInteger ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ;
if ( count == arr [ i ] ) return arr [ i ] ; } return -1 ; }
int main ( ) { int arr [ ] = { 10 , 3 , 20 , 40 , 2 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int res = nobleInteger ( arr , size ) ; if ( res != -1 ) cout << " The ▁ noble ▁ integer ▁ is ▁ " << res ; else cout << " No ▁ Noble ▁ Integer ▁ Found " ; }
int nobleInteger ( int arr [ ] , int n ) { sort ( arr , arr + n ) ;
for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ;
if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return -1 ; }
int main ( ) { int arr [ ] = { 10 , 3 , 20 , 40 , 2 } ; int res = nobleInteger ( arr , 5 ) ; if ( res != -1 ) cout << " The ▁ noble ▁ integer ▁ is ▁ " << res ; else cout << " No ▁ Noble ▁ Integer ▁ Found " ; return 0 ; }
long long int findMinSum ( long long int a [ ] , long long int b [ ] , int n ) {
sort ( a , a + n ) ; sort ( b , b + n ) ;
long long int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + abs ( a [ i ] - b [ i ] ) ; return sum ; }
long long int a [ ] = { 4 , 1 , 8 , 7 } ; long long int b [ ] = { 2 , 3 , 6 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printf ( " % lld STRNEWLINE " , findMinSum ( a , b , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ;
int max_neg = INT_MIN ; int min_pos = INT_MAX ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] == 0 ) { count_zero ++ ; continue ; }
if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = max ( max_neg , a [ i ] ) ; }
if ( a [ i ] > 0 ) min_pos = min ( min_pos , a [ i ] ) ; prod = prod * a [ i ] ; }
if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ;
if ( count_neg == 0 ) return min_pos ;
if ( ! ( count_neg & 1 ) && count_neg != 0 ) {
prod = prod / max_neg ; } return prod ; }
int main ( ) { int a [ ] = { -1 , -1 , -2 , 4 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minProductSubset ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findElement ( int a [ ] , int n , int b ) {
sort ( a , a + n ) ;
int max = a [ n - 1 ] ; while ( b < max ) {
if ( binary_search ( a , a + n , b ) ) b *= 2 ; else return b ; } return b ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int b = 1 ; cout << findElement ( a , n , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define Mod  1000000007 NEW_LINE using namespace std ;
long long int findSum ( int arr [ ] , int n ) { long long int sum = 0 ;
sort ( arr , arr + n ) ;
int i = 0 ; while ( i < n && arr [ i ] < 0 ) { if ( i != n - 1 && arr [ i + 1 ] <= 0 ) { sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod ; i += 2 ; } else break ; }
int j = n - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { if ( j != 0 && arr [ j - 1 ] > 0 ) { sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod ; j -= 2 ; } else break ; }
if ( j > i ) sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod ;
else if ( i == j ) sum = ( sum + arr [ i ] ) % Mod ; return sum ; }
int main ( ) { int arr [ ] = { -1 , 9 , 4 , 5 , -4 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findSum ( arr , n ) ; return 0 ; }
void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; cout << " Odd ▁ = ▁ " << odd_count << endl ; cout << " Even ▁ = ▁ " << even_count << endl ; }
int main ( ) { int n = 1234 ; countOddRotations ( n ) ; }
int numberOfDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; }
void cal ( int num ) { int digits = numberOfDigits ( num ) ; int powTen = pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int firstDigit = num / powTen ;
int left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; cout << left << " ▁ " ;
num = left ; } }
int main ( ) { int num = 1445 ; cal ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void CheckKCycles ( int n , string s ) { bool ff = true ; int x = 0 ; for ( int i = 1 ; i < n ; i ++ ) {
x = ( s . substr ( i ) + s . substr ( 0 , i ) ) . length ( ) ;
if ( x >= s . length ( ) ) { continue ; } ff = false ; break ; } if ( ff ) { cout << ( " Yes " ) ; } else { cout << ( " No " ) ; } }
int main ( ) { int n = 3 ; string s = "123" ; CheckKCycles ( n , s ) ; return 0 ; }
bool rightRotationDivisor ( int N ) { int lastDigit = N % 10 ; int rightRotation = ( lastDigit * pow ( 10 , int ( log10 ( N ) ) ) ) + floor ( N / 10 ) ; return ( rightRotation % N == 0 ) ; }
void generateNumbers ( int m ) { for ( int i = pow ( 10 , ( m - 1 ) ) ; i < pow ( 10 , m ) ; i ++ ) if ( rightRotationDivisor ( i ) ) cout << i << endl ; }
int main ( ) { int m = 3 ; generateNumbers ( m ) ; }
void checkIfSortRotated ( int arr [ ] , int n ) { int minEle = INT_MAX ; int maxEle = INT_MIN ; int minIndex = -1 ;
for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } int flag1 = 1 ;
for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = 0 ; break ; } } int flag2 = 1 ;
for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = 0 ; break ; } }
if ( flag1 && flag2 && ( arr [ n - 1 ] < arr [ 0 ] ) ) cout << " YES " ; else cout << " NO " ; }
int main ( ) { int arr [ ] = { 3 , 4 , 5 , 1 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
checkIfSortRotated ( arr , n ) ; return 0 ; }
void occurredOnce ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
if ( arr [ 0 ] != arr [ 1 ] ) cout << arr [ 0 ] << " ▁ " ;
for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) cout << arr [ i ] << " ▁ " ;
if ( arr [ n - 2 ] != arr [ n - 1 ] ) cout << arr [ n - 1 ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; occurredOnce ( arr , n ) ; return 0 ; }
void occurredOnce ( int arr [ ] , int n ) { int i = 1 , len = n ;
if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; }
for ( ; i < n ; i ++ )
if ( arr [ i ] == arr [ i - 1 ] ) i ++ ;
else cout < < arr [ i - 1 ] << " ▁ " ;
if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) cout << arr [ n - 1 ] ; }
int main ( ) { int arr [ ] = { 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; occurredOnce ( arr , n ) ; return 0 ; }
void rvereseArray ( int arr [ ] , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } }
void printArray ( int arr [ ] , int size ) { for ( int i = 0 ; i < size ; i ++ ) cout << arr [ i ] << " ▁ " ; }
void splitArr ( int arr [ ] , int k , int n ) { rvereseArray ( arr , 0 , n - 1 ) ; rvereseArray ( arr , 0 , n - k - 1 ) ; rvereseArray ( arr , n - k , n - 1 ) ; }
int main ( ) { int arr [ ] = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ;
splitArr ( arr , k , n ) ; printArray ( arr , n ) ; return 0 ; }
int countRotationsDivBy8 ( string n ) { int len = n . length ( ) ; int count = 0 ;
if ( len == 1 ) { int oneDigit = n [ 0 ] - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; }
if ( len == 2 ) {
int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ;
int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; }
int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0' ) * 10 + ( n [ i + 2 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; }
threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ;
threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ;
return count ; }
int main ( ) { string n = "43262488612" ; cout << " Rotations : ▁ " << countRotationsDivBy8 ( n ) ; return 0 ; }
bool isRotation ( unsigned int x , unsigned int y ) {
unsigned long long int x64 = x | ( ( unsigned long long int ) x << 32 ) ; while ( x64 >= y ) {
if ( unsigned ( x64 ) == y ) return true ;
x64 >>= 1 ; } return false ; }
int main ( ) { unsigned int x = 122 ; unsigned int y = 2147483678 ; if ( isRotation ( x , y ) ) cout << " yes " << endl ; else cout << " no " << endl ; return 0 ; }
int countRotations ( string n ) { int len = n . length ( ) ;
if ( len == 1 ) { int oneDigit = n . at ( 0 ) - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; }
int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n . at ( i ) - '0' ) * 10 + ( n . at ( i + 1 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; }
twoDigit = ( n . at ( len - 1 ) - '0' ) * 10 + ( n . at ( 0 ) - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; }
int main ( ) { string n = "4834" ; cout << " Rotations : ▁ " << countRotations ( n ) << endl ; return 0 ; }
int maxLength ( int a [ ] , int n ) { int sum = 0 , len = 0 ;
for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ;
return n ;
for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) len = max ( len , max ( n - i - 1 , i ) ) ; } return len ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxLength ( a , n ) << " STRNEWLINE " ; return 0 ; }
void solve ( long long n ) { long long initial_array [ n - 1 ] [ n - 1 ] , final_array [ n ] [ n ] ; for ( long long i = 0 ; i < n - 1 ; ++ i ) initial_array [ 0 ] [ i ] = i + 1 ;
for ( long long i = 1 ; i < n - 1 ; ++ i ) for ( long long j = 0 ; j < n - 1 ; ++ j ) initial_array [ i ] [ j ] = initial_array [ i - 1 ] [ ( j + 1 ) % ( n - 1 ) ] ;
for ( long long i = 0 ; i < n - 1 ; ++ i ) for ( long long j = 0 ; j < n - 1 ; ++ j ) final_array [ i ] [ j ] = initial_array [ i ] [ j ] ;
for ( long long i = 0 ; i < n ; ++ i ) final_array [ i ] [ n - 1 ] = final_array [ n - 1 ] [ i ] = 0 ; for ( long long i = 0 ; i < n ; ++ i ) { long long t0 = final_array [ i ] [ i ] ; long long t1 = final_array [ i ] [ n - 1 ] ;
swap ( final_array [ i ] [ i ] , final_array [ i ] [ n - 1 ] ) ;
final_array [ n - 1 ] [ i ] = t0 ; }
for ( long long i = 0 ; i < n ; ++ i ) { for ( long long j = 0 ; j < n ; ++ j ) cout << final_array [ i ] [ j ] << " ▁ " ; cout << endl ; } }
int main ( ) { long long n = 5 ; solve ( n ) ; return 0 ; }
int getMinVal ( int p , int q ) {
if ( q % p == 0 ) return p ;
return -1 ; }
int main ( ) { int p = 24 , q = 48 ; cout << getMinVal ( p , q ) ; return 0 ; }
bool isPalindrome ( string str , int i , int j ) { while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; }
int countPrimePalindrome ( string str , int len ) { bool prime [ len + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ;
prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= len ; p ++ ) {
if ( prime [ p ] ) {
for ( int i = p * p ; i <= len ; i += p ) prime [ i ] = false ; } }
int count = 0 ;
for ( int j = 2 ; j <= len ; j ++ ) {
if ( prime [ j ] ) {
for ( int i = 0 ; i + j - 1 < len ; i ++ ) {
if ( isPalindrome ( str , i , i + j - 1 ) ) count ++ ; } } } return count ; }
int main ( ) { string s = " geeksforgeeks " ; int len = s . length ( ) ; cout << countPrimePalindrome ( s , len ) ; return 0 ; }
int minOperations ( int N ) { double x = log2 ( N ) ; int ans = ceil ( x ) ; return ans ; }
int main ( ) { int N = 10 ; cout << minOperations ( N ) ; return 0 ; }
int find_greatest_divisor ( int l , int r ) { if ( l == r ) return l ; return 1 ; }
int main ( ) { int l = 2 , r = 12 ; cout << find_greatest_divisor ( l , r ) ; }
double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ;
double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; }
p = 80 ; q = 40 ; cout << fixed << setprecision ( 15 ) << getProbability ( p , q ) << endl ; return 0 ; }
bool check ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) {
if ( arr [ i ] & 1 ) return true ; }
return false ; }
int main ( ) { int arr [ ] = { 3 , 9 , 12 , 13 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( check ( arr , n ) ) cout << " Odd ▁ Bit - wise ▁ OR " ; else cout << " Even ▁ Bit - wise ▁ OR " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int _log ( double x , double base ) { return ( int ) ( log ( x ) / log ( base ) ) ; } double recursiveLogStar ( double n , double b ) { if ( n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) ; else return 0 ; }
int main ( ) { int n = 100 , base = 5 ; cout << " Log * ( " << n << " ) ▁ = ▁ " << recursiveLogStar ( n , base ) << " STRNEWLINE " ; return 0 ; }
bool isPossible ( int box [ ] , int truck [ ] , int n , int m , int min_time ) { int temp = 0 ; int count = 0 ; while ( count < m ) { for ( int j = 0 ; j < min_time && temp < n && truck [ count ] >= box [ temp ] ; j += 2 ) temp ++ ; count ++ ; }
if ( temp == n ) return true ;
return false ; }
int minTime ( int box [ ] , int truck [ ] , int n , int m ) {
sort ( box , box + n ) ; sort ( truck , truck + m ) ; int l = 0 ; int h = 2 * n ;
int min_time = 0 ;
while ( l <= h ) { int mid = ( l + h ) / 2 ;
if ( isPossible ( box , truck , n , m , mid ) ) { min_time = mid ; h = mid - 1 ; } else l = mid + 1 ; } return min_time ; }
int main ( ) { int box [ ] = { 10 , 2 , 16 , 19 } ; int truck [ ] = { 29 , 25 } ; int n = sizeof ( box ) / sizeof ( int ) ; int m = sizeof ( truck ) / sizeof ( int ) ; printf ( " % d " , minTime ( box , truck , n , m ) ) ; return 0 ; }
bool isPossible ( int arr [ ] , int n , int dist , int k ) {
int req = 0 ; int curr = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) curr ++ ; req ++ ; if ( curr == n ) break ; prev = curr - 1 ; } if ( curr != n ) return false ;
if ( req <= k ) return true ; return false ; }
int minDistance ( int arr [ ] , int n , int k ) { int l = 0 ; int h = arr [ n - 1 ] ;
int ans = 0 ;
while ( l <= h ) { int m = ( l + h ) / 2 ; if ( isPossible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else l = m + 1 ; } return ans ; }
int main ( ) { int arr [ ] = { 2 , 15 , 36 , 43 } ; int n = sizeof ( arr ) / sizeof ( int ) ; int k = 2 ; cout << minDistance ( arr , n , k ) ; return 0 ; }
int getKthElement ( int n , int k , int L [ ] , int R [ ] ) { int l = 1 ; int h = n ;
int total [ n + 1 ] ; total [ 0 ] = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 ; }
int index = -1 ;
while ( l <= h ) { int m = ( l + h ) / 2 ; if ( total [ m ] > k ) { index = m ; h = m - 1 ; } else if ( total [ m ] < k ) l = m + 1 ; else { index = m ; break ; } } l = L [ index - 1 ] ; h = R [ index - 1 ] ;
int x = k - total [ index - 1 ] ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( m - L [ index - 1 ] ) + 1 == x ) { return m ; } else if ( ( m - L [ index - 1 ] ) + 1 > x ) h = m - 1 ; else l = m + 1 ; } }
int main ( ) { int L [ ] = { 1 , 8 , 21 } ; int R [ ] = { 4 , 10 , 23 } ; int n = sizeof ( L ) / sizeof ( int ) ; int k = 6 ; cout << getKthElement ( n , k , L , R ) ; return 0 ; }
int MinimumX ( int a , int b , int c , int k ) { int x = INT_MAX ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ;
while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; }
return x ; }
int main ( ) { int a = 3 , b = 2 , c = 4 , k = 15 ; cout << MinimumX ( a , b , c , k ) ; return 0 ; }
void IfExists ( int arr [ ] , int n ) {
int sum [ n ] ;
sort ( arr , arr + n ) ; sum [ 0 ] = arr [ 0 ] ;
for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ;
int max = arr [ n - 1 ] ;
bool flag = false ; for ( int i = 1 ; i <= max ; i ++ ) {
int findex = 0 ;
int lindex = 0 ; int l = 0 ; int r = n - 1 ;
while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < i ) { findex = m ; l = m + 1 ; } else r = m - 1 ; } l = 1 ; r = n ; flag = false ;
while ( l <= r ) { int m = ( r + l ) / 2 ; if ( arr [ m ] > i ) { lindex = m ; r = m - 1 ; } else l = m + 1 ; }
if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) { flag = true ; break ; } }
if ( flag ) cout << " Yes " ; else cout << " No " ; }
int main ( ) { int arr [ ] = { 1 , 2 , 2 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; IfExists ( arr , n ) ; return 0 ; }
int findMissing ( int arr [ ] , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ;
if ( arr [ mid ] - mid == arr [ 0 ] ) {
if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else {
l = mid + 1 ; } } else {
if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else {
h = mid - 1 ; } } }
return -1 ; }
int main ( ) { int arr [ ] = { -9 , -8 , -7 , -5 , -4 , -3 , -2 , -1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( findMissing ( arr , n ) ) ; }
int maxSum ( int arr [ ] , int n , int K ) {
int maximum = INT_MIN ;
for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ;
for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ;
maximum = max ( maximum , sumk ) ; } return maximum ; }
int main ( ) { int arr [ ] = { 3 , 6 , 4 , 7 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << maxSum ( arr , n , K ) ; return ( 0 ) ; }
int countGreater ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n - 1 ;
int leftGreater = n ;
while ( l <= r ) { int m = l + ( r - l ) / 2 ;
if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; }
else l = m + 1 ; }
return ( n - leftGreater ) ; }
int main ( ) { int arr [ ] = { 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 7 ; cout << countGreater ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int operations ( int op [ ] , int n , int k ) { int i , count = 0 ;
int nVal = 0 ;
int minimum = INT_MAX ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; minimum = min ( minimum , nVal ) ;
if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; }
if ( nVal >= 0 ) return -1 ;
int times = ( k - abs ( minimum ) ) / abs ( nVal ) ;
k = ( k - ( times * abs ( nVal ) ) ) ; count = ( times * n ) ;
while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; }
int main ( ) { int op [ ] = { -60 , 65 , -1 , 14 , -25 } ; int n = sizeof ( op ) / sizeof ( op [ 0 ] ) ; int k = 100000 ; cout << operations ( op , n , k ) << endl ; }
int countFactor ( int P , int X ) { if ( X < P ) return 0 ; return ( X / P + countFactor ( P , X / P ) ) ; }
int findSmallestX ( int Y ) { int low = 0 , high = 5 * Y ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( countFactor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; }
int main ( ) { int Y = 10 ; cout << findSmallestX ( Y ) ; return 0 ; }
int squareSum ( int N ) { int sum = ( int ) ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ; return sum ; }
int findMaxN ( int X ) { int low = 1 , high = 100000 ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( squareSum ( mid ) <= X ) { N = mid ; low = mid + 1 ; } else high = mid - 1 ; } return N ; }
int main ( ) { int X = 25 ; cout << findMaxN ( X ) ; return 0 ; }
#include <iostream> NEW_LINE #define n  4 NEW_LINE using namespace std ;
int findRing ( int arr [ ] [ n ] , int x ) {
if ( arr [ 0 ] [ 0 ] > x ) return -1 ;
int l = 0 , r = ( n + 1 ) / 2 - 1 ;
if ( n % 2 == 1 && arr [ r ] [ r ] < x ) return -1 ; if ( n % 2 == 0 && arr [ r + 1 ] [ r ] < x ) return -1 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid ] [ mid ] <= x ) if ( mid == ( n + 1 ) / 2 - 1 arr [ mid + 1 ] [ mid + 1 ] > x ) return mid ; else l = mid + 1 ; else r = mid - 1 ; } return r ; }
int binarySearchRowInc ( int arr [ ] [ n ] , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return -1 ; }
int binarySearchColumnInc ( int arr [ ] [ n ] , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) t = mid + 1 ; else b = mid - 1 ; } return -1 ; }
int binarySearchRowDec ( int arr [ ] [ n ] , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) r = mid - 1 ; else l = mid + 1 ; } return -1 ; }
int binarySearchColumnDec ( int arr [ ] [ n ] , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) b = mid - 1 ; else t = mid + 1 ; } return -1 ; }
void spiralBinary ( int arr [ ] [ n ] , int x ) {
int f1 = findRing ( arr , x ) ;
int r , c ; if ( f1 == -1 ) { cout << " - 1" ; return ; }
if ( n % 2 == 1 && f1 == ( n + 1 ) / 2 - 1 ) { cout << f1 << " ▁ " << f1 << endl ; return ; }
if ( x < arr [ f1 ] [ n - f1 - 1 ] ) { c = binarySearchRowInc ( arr , f1 , f1 , n - f1 - 2 , x ) ; r = f1 ; } else if ( x < arr [ n - f1 - 1 ] [ n - f1 - 1 ] ) { c = n - f1 - 1 ; r = binarySearchColumnInc ( arr , n - f1 - 1 , f1 , n - f1 - 2 , x ) ; } else if ( x < arr [ n - f1 - 1 ] [ f1 ] ) { c = binarySearchRowDec ( arr , n - f1 - 1 , f1 + 1 , n - f1 - 1 , x ) ; r = n - f1 - 1 ; } else { r = binarySearchColumnDec ( arr , f1 , f1 + 1 , n - f1 - 1 , x ) ; c = f1 ; }
if ( c == -1 r == -1 ) cout << " - 1" ; else cout << r << " ▁ " << c ; return ; }
int main ( ) { int arr [ ] [ n ] = { { 1 , 2 , 3 , 4 } , { 12 , 13 , 14 , 5 } , { 11 , 16 , 15 , 6 } , { 10 , 9 , 8 , 7 } } ; spiralBinary ( arr , 7 ) ; return 0 ; }
int countSubArrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ;
for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; }
int main ( ) { int arr [ ] = { 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 6 ; cout << countSubArrays ( arr , n , k ) ; return 0 ; }
int countPattern ( int n , string pat ) {
int pattern_int = 0 ; int power_two = 1 ;
int all_ones = 0 ;
for ( int i = pat . length ( ) - 1 ; i >= 0 ; i -- ) { int current_bit = pat [ i ] - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n && n >= pattern_int ) {
if ( ( n & all_ones ) == pattern_int ) { count ++ ; }
n = n >> 1 ; } return count ; }
int main ( ) { int n = 500 ; string pat = "10" ; cout << countPattern ( n , pat ) ; }
int max_min ( int a [ ] , int n ) { sort ( a , a + n ) ; return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; }
int main ( ) { int a [ ] = { 1 , 3 , 3 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << max_min ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000001 ;
int primeUpto [ MAX ] ;
void SieveOfEratosthenes ( ) { bool isPrime [ MAX ] ; memset ( isPrime , 1 , sizeof ( isPrime ) ) ;
isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( int i = 2 ; i * i < MAX ; i ++ ) {
if ( isPrime [ i ] ) {
for ( int j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } }
for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] ) primeUpto [ i ] ++ ; } }
int countOfNumbers ( int N , int K ) {
SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ;
if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; }
return ( ans ? N - ans + 1 : 0 ) ; }
int main ( ) { int N = 10 , K = 3 ; cout << countOfNumbers ( N , K ) ; }
int minIndex ( int arr [ ] , int n ) {
int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return -1 ; }
int main ( ) { int arr [ ] = { 1 , 3 , -5 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minIndex ( arr , n ) << endl ; return 0 ; }
void printIntersection ( int A [ ] [ N ] , int B [ ] [ N ] ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) {
if ( A [ i ] [ j ] == B [ i ] [ j ] ) cout << A [ i ] [ j ] << " ▁ " ; else cout << " * ▁ " ; } cout << " STRNEWLINE " ; } }
int main ( ) { int A [ M ] [ N ] = { { 2 , 4 , 6 , 8 } , { 1 , 3 , 5 , 7 } , { 8 , 6 , 4 , 2 } , { 7 , 5 , 3 , 1 } } ; int B [ M ] [ N ] = { { 2 , 3 , 6 , 8 } , { 1 , 3 , 5 , 2 } , { 8 , 1 , 4 , 2 } , { 3 , 5 , 4 , 1 } } ; printIntersection ( A , B ) ; return 0 ; }
int countWays ( int arr [ ] , int n ) {
int max_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) max_val = max ( max_val , arr [ i ] ) ; int freq [ max_val + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ;
ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ;
for ( int i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ;
for ( int i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ;
for ( int i = 1 ; i <= max_val ; i ++ ) { for ( int j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << ( countWays ( arr , n ) ) ; return 0 ; }
int LongestSubarray ( int arr [ ] , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ;
for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ;
if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return max ( max_length , count ) ; }
int main ( ) { int arr [ ] = { 4 , 9 , 7 , 18 , 29 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 11 ; cout << LongestSubarray ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  3 NEW_LINE #define N  4
bool binarySearch1D ( int arr [ ] , int K ) { int low = 0 ; int high = N - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ;
if ( arr [ mid ] == K ) return true ;
if ( arr [ mid ] < K ) low = mid + 1 ; else high = mid - 1 ; }
return false ; }
bool searchMatrix ( int matrix [ M ] [ N ] , int K ) { int low = 0 ; int high = M - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ;
if ( K >= matrix [ mid ] [ 0 ] && K <= matrix [ mid ] [ N - 1 ] ) return binarySearch1D ( matrix [ mid ] , K ) ;
if ( K < matrix [ mid ] [ 0 ] ) high = mid - 1 ; else low = mid + 1 ; }
return false ; }
int main ( ) { int matrix [ M ] [ N ] = { { 1 , 3 , 5 , 7 } , { 10 , 11 , 16 , 20 } , { 23 , 30 , 34 , 50 } } ; int K = 3 ; if ( searchMatrix ( matrix , K ) ) cout << " Found " << endl ; else cout << " Not ▁ found " << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfElements ( int height [ ] , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; }
int main ( ) { int n = 6 ; int height [ ] = { 4 , 8 , 2 , 0 , 0 , 5 } ; cout << numberOfElements ( height , n ) ; return 0 ; }
void solve ( int arr [ ] , int n , int k ) {
sort ( arr , arr + n ) ;
if ( k == 1 && arr [ n - 2 ] != arr [ n - 1 ] ) { cout << arr [ n - 1 ] << endl ; return ; }
int count = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) {
if ( arr [ i ] == arr [ i + 1 ] ) count ++ ;
else count = 1 ;
if ( count == k && ( i == 0 || ( arr [ i - 1 ] != arr [ i ] ) ) ) { cout << arr [ i ] << endl ; return ; } }
cout << " No ▁ such ▁ element " << endl ; }
int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 } ; int k = 2 ; int n = sizeof ( arr ) / sizeof ( int ) ;
solve ( arr , n , k ) ; return 0 ; }
int getMin ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = min ( res , arr [ i ] ) ; return res ; }
int getMax ( int arr [ ] , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = max ( res , arr [ i ] ) ; return res ; }
int findSum ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min + max ; }
int findProduct ( int arr [ ] , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min * max ; }
int main ( ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << " Sum ▁ = ▁ " << findSum ( arr , n ) << endl ;
cout << " Product ▁ = ▁ " << findProduct ( arr , n ) ; return 0 ; }
int countChar ( string str ) { int n = str . length ( ) ;
if ( n <= 2 ) return n ; int count = 2 ;
for ( int i = 1 ; i < n - 1 ; i ++ )
if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ;
return count ; }
int main ( ) { string str = " egeeksk " ; cout << countChar ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int next ( int arr [ ] , int target , int end ) {
if ( end == 0 ) return -1 ;
if ( target > arr [ end - 1 ] ) return end - 1 ; int start = 0 ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ;
if ( arr [ mid ] >= target ) { end = mid - 1 ; }
else { ans = mid ; start = mid + 1 ; } } return ans ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( next ( arr , 5 , n ) ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int next ( int arr [ ] , int target , int end ) { int start = 0 ; int ans = -1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ;
if ( arr [ mid ] <= target ) start = mid + 1 ;
else { ans = mid ; end = mid - 1 ; } } return ans ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 , 8 , 12 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << next ( arr , 8 , n ) ; return 0 ; }
bool search ( int arr [ ] , int n , int x ) {
int res = -1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ;
if ( res == -1 ) return false ;
int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; }
int main ( ) { int arr [ ] = { 12 , 25 , 36 , 85 , 98 , 75 , 89 , 15 , 63 , 66 , 64 , 74 , 27 , 83 , 97 } ; int q [ ] = { 63 , 63 , 86 , 63 , 78 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = sizeof ( q ) / sizeof ( q [ 0 ] ) ; for ( int i = 0 ; i < m ; i ++ ) search ( arr , n , q [ i ] ) ? cout << " Yes ▁ " : cout << " No ▁ " ; return 0 ; }
float kPresentProbability ( int a [ ] , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ;
return count / n ; }
int main ( ) { int A [ ] = { 4 , 7 , 2 , 0 , 8 , 7 , 5 } ; int K = 3 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << kPresentProbability ( A , N , K ) ; return 0 ; }
int slopeOfNum ( string num , int n ) {
int slope = 0 ;
for ( int i = 1 ; i < n - 1 ; i ++ ) {
if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ;
else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; }
return slope ; }
int main ( ) { string num = "1213321" ; int n = num . size ( ) ; cout << " Slope ▁ = ▁ " << slopeOfNum ( num , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void prevGreater ( int arr [ ] , int n ) {
cout << " - 1 , ▁ " ;
for ( int i = 1 ; i < n ; i ++ ) {
int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { cout << arr [ j ] << " , ▁ " ; break ; } }
if ( j == -1 ) cout << " - 1 , ▁ " ; } }
int main ( ) { int arr [ ] = { 10 , 4 , 2 , 20 , 40 , 12 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; prevGreater ( arr , n ) ; return 0 ; }
void printDuplicates ( int arr [ ] , int n ) { int i ;
int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) {
if ( arr [ arr [ i ] % n ] >= n ) {
if ( arr [ arr [ i ] % n ] < 2 * n ) { cout << arr [ i ] % n << " ▁ " ; fl = 1 ; } }
arr [ arr [ i ] % n ] += n ; }
if ( ! fl ) cout << " - 1" ; }
int main ( ) { int arr [ ] = { 1 , 6 , 3 , 1 , 3 , 6 , 6 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printDuplicates ( arr , arr_size ) ; return 0 ; }
int findMissingNo ( int arr [ ] , int n ) {
int val ;
int nextval ; for ( int i = 0 ; i < n ; i ++ ) {
if ( arr [ i ] <= 0 arr [ i ] > n ) continue ; val = arr [ i ] ;
while ( arr [ val - 1 ] != val ) { nextval = arr [ val - 1 ] ; arr [ val - 1 ] = val ; val = nextval ; if ( val <= 0 val > n ) break ; } }
for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } }
return n + 1 ; }
int main ( ) { int arr [ ] = { 2 , 3 , 7 , 6 , 8 , -1 , -10 , 15 } ; int arr_size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int missing = findMissingNo ( arr , arr_size ) ; cout << " The ▁ smallest ▁ positive ▁ missing ▁ number ▁ is ▁ " << missing ; return 0 ; }
void findTriplets ( int arr [ ] , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { cout << arr [ i ] << " ▁ " << arr [ j ] << " ▁ " << arr [ k ] << endl ; } } } } }
int main ( ) { int arr [ ] = { 0 , -1 , 2 , -3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTriplets ( arr , n , -2 ) ; return 0 ; }
int maxProduct ( int arr [ ] , int n ) {
if ( n < 4 ) return -1 ;
int max_product = INT_MIN ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; }
int main ( ) { int arr [ ] = { 10 , 3 , 5 , 6 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Quadruple ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
int maxProduct ( int arr [ ] , int n ) {
if ( n < 4 ) return -1 ;
sort ( arr , arr + n ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ;
return max ( x , max ( y , z ) ) ; }
int main ( ) { int arr [ ] = { -10 , -3 , 5 , 6 , -20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Quadruple ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int n ) { if ( n < 2 ) return -1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; }
int main ( ) { int arr [ ] = { 1 , 12 , 2 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ;
int getGreatestSum ( int a [ ] [ N ] ) {
int prev_max = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ;
int sum = prev_max ; for ( int i = N - 2 ; i >= 0 ; i -- ) {
int curr_max = INT_MIN ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ;
if ( curr_max == INT_MIN ) return -1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; }
int main ( ) { int a [ 3 ] [ 3 ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; cout << getGreatestSum ( a ) << endl ; int b [ 3 ] [ 3 ] = { { 4 , 5 , 6 } , { 4 , 5 , 6 } , { 4 , 5 , 6 } } ; cout << getGreatestSum ( b ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findElement ( int n , int k ) {
int left = 1 ;
int right = pow ( 2 , n ) - 1 ; while ( 1 ) { int mid = ( left + right ) / 2 ; if ( k == mid ) { cout << ans << endl ; break ; }
ans -- ;
if ( k < mid ) right = mid - 1 ;
else left = mid + 1 ; } }
int main ( ) { int n = 4 , k = 8 ; findElement ( n , k ) ; return 0 ; }
int checkBit ( int pattern , int arr [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; }
int maxAND ( int arr [ ] , int n ) { int res = 0 , count ;
for ( int bit = 31 ; bit >= 0 ; bit -- ) {
count = checkBit ( res | ( 1 << bit ) , arr , n ) ;
if ( count >= 2 ) res |= ( 1 << bit ) ; }
if ( res == 0 ) cout << " Not ▁ Possible STRNEWLINE " ; else {
cout << " Pair ▁ = ▁ " ; count = 0 ; for ( int i = 0 ; i < n && count < 2 ; i ++ ) {
if ( ( arr [ i ] & res ) == res ) { count ++ ; cout << arr [ i ] << " ▁ " ; } } }
return res ; }
int main ( ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum AND Value = " << maxAND ( arr , n ) ; return 0 ; }
int countMaxSumPairs ( int a [ ] , int n ) { int first = INT_MIN , second = INT_MIN ; for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] > first ) { second = first ; first = a [ i ] ; }
else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } int cnt1 = 0 , cnt2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == first )
if ( a [ i ] == second )
} if ( cnt1 == 1 ) return cnt2 ; if ( cnt1 > 1 ) return cnt1 * ( cnt1 - 1 ) / 2 ; }
float findMaxSumProbability ( int a [ ] , int n ) { int total = n * ( n - 1 ) / 2 ; int max_sum_pairs = countMaxSumPairs ( a , n ) ; return ( float ) max_sum_pairs / ( float ) total ; }
int main ( ) { int a [ ] = { 1 , 2 , 2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findMaxSumProbability ( a , n ) ; return 0 ; }
int findS ( int s ) { int sum = 0 ;
for ( int n = 1 ; sum < s ; n ++ ) { sum += n ;
if ( sum == s ) return n ; } return -1 ; }
int main ( ) { int s = 15 ; int n = findS ( s ) ; n == -1 ? cout << " - 1" : cout << n ; return 0 ; }
int calcSafe ( int pos ) {
int j = pos % 10 ; int i = pos / 10 ;
int dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) ; int dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) ; int dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) ; int dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) ;
int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ;
return ( 64 - sum ) ; }
int main ( ) { int pos = 34 ; cout << " Safe ▁ Positions ▁ = ▁ " << calcSafe ( pos ) ; return 0 ; }
int getCount ( int arr [ ] , int n , int num1 , int num2 ) {
int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ;
if ( i >= n - 1 ) return 0 ;
int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ;
if ( j == i ) return 0 ;
return ( j - i - 1 ) ; }
int main ( ) { int arr [ ] = { 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int num1 = 5 , num2 = 4 ; cout << getCount ( arr , n , num1 , num2 ) ; return 0 ; }
int sumOfDigit ( int K ) {
int sod = 0 ; while ( K ) { sod += K % 10 ; K /= 10 ; } return sod ; }
int totalNumbersWithSpecificDifference ( int N , int diff ) { int low = 1 , high = N ;
while ( low <= high ) { int mid = ( low + high ) / 2 ;
if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ;
else high = mid - 1 ; }
return ( N - high ) ; }
int main ( ) { int N = 13 ; int diff = 2 ; cout << totalNumbersWithSpecificDifference ( N , diff ) ; return 0 ; }
int countBuildings ( int arr [ ] , int n ) {
int count = 1 ;
int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) {
if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; }
int main ( ) { int arr [ ] = { 7 , 4 , 8 , 2 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countBuildings ( arr , n ) ; return 0 ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; }
int main ( ) { int arr1 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 13 } ; int arr2 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 } ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ;
cout << findExtra ( arr1 , arr2 , n ) ; return 0 ; }
int findExtra ( int arr1 [ ] , int arr2 [ ] , int n ) {
int index = n ;
int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ;
if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ;
else { index = mid ; right = mid - 1 ; } }
return index ; }
int main ( ) { int arr1 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 , 13 } ; int arr2 [ ] = { 2 , 4 , 6 , 8 , 10 , 12 } ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ;
cout << findExtra ( arr1 , arr2 , n ) ; return 0 ; }
int computeCost ( int arr [ ] , int N , int X ) { int cost = 0 ; for ( int i = 0 ; i < N ; i ++ ) cost += abs ( arr [ i ] - X ) ; return cost ; }
int minCostToMakeElementEqual ( int arr [ ] , int N ) { int low , high ; low = high = arr [ 0 ] ;
for ( int i = 0 ; i < N ; i ++ ) { if ( low > arr [ i ] ) low = arr [ i ] ; if ( high < arr [ i ] ) high = arr [ i ] ; }
while ( ( high - low ) > 2 ) {
int mid1 = low + ( high - low ) / 3 ; int mid2 = high - ( high - low ) / 3 ; int cost1 = computeCost ( arr , N , mid1 ) ; int cost2 = computeCost ( arr , N , mid2 ) ;
if ( cost1 < cost2 ) high = mid2 ;
else low = mid1 ; }
return computeCost ( arr , N , ( low + high ) / 2 ) ; }
int main ( ) { int arr [ ] = { 1 , 100 , 101 } ; int N = sizeof ( arr ) / sizeof ( int ) ; cout << minCostToMakeElementEqual ( arr , N ) ; return 0 ; }
int Next_greater ( int a [ ] , int n , int x ) {
sort ( a , a + n ) ; int low = 0 , high = n - 1 , ans = x + 1 ;
while ( low <= high ) {
int mid = ( low + high ) / 2 ;
if ( a [ mid ] <= ans ) {
if ( a [ mid ] == ans ) {
ans ++ ;
high = n - 1 ; }
low = mid + 1 ; }
else high = mid - 1 ; }
return ans ; }
int main ( ) { int a [ ] = { 1 , 5 , 10 , 4 , 7 } , x = 4 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Next_greater ( a , n , x ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; long long mod = 1000000007 ;
int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; }
long long powmod ( long long a , long long n ) { if ( ! n ) return 1 ; long long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 ) return ( pt * a ) % mod ; else return pt ; }
long long CountSubset ( int * arr , int n ) {
long long ans = powmod ( 2 , n - 1 ) ;
sort ( arr , arr + n ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ;
while ( j < n && arr [ j ] == arr [ i ] ) {
int r = n - 1 - j ;
int l = i ;
ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; }
int main ( ) { int arr [ ] = { 2 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << CountSubset ( arr , n ) << endl ; return 0 ; }
void reArrange ( string words [ ] , int n ) {
map < string , int > mp ; for ( int i = 0 ; i < n ; i ++ ) mp [ words [ i ] ] = i + 1 ;
sort ( words , words + n ) ;
for ( int i = 0 ; i < n ; i ++ ) cout << mp [ words [ i ] ] << " ▁ " ; }
int main ( ) { string words [ ] = { " live " , " place " , " travel " , " word " , " sky " } ; int n = sizeof ( words ) / sizeof ( words [ 0 ] ) ; reArrange ( words , n ) ; }
#include <iostream> NEW_LINE using namespace std ; #define MAX  100000
int findSumofEle ( int arr1 [ ] , int m , int arr2 [ ] , int n ) {
int hash [ MAX ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) hash [ arr2 [ i ] ] ++ ;
for ( int i = 1 ; i < MAX ; i ++ ) hash [ i ] = hash [ i ] + hash [ i - 1 ] ;
int maximumFreq = 0 ; for ( int i = 0 ; i < m ; i ++ ) maximumFreq = max ( maximumFreq , hash [ arr1 [ i ] ] ) ;
int sumOfElements = 0 ; for ( int i = 0 ; i < m ; i ++ ) sumOfElements += ( maximumFreq == hash [ arr1 [ i ] ] ) ? arr1 [ i ] : 0 ;
return sumOfElements ; }
int main ( ) { int arr1 [ ] = { 2 , 5 , 6 , 8 } ; int arr2 [ ] = { 4 , 10 } ; int m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << findSumofEle ( arr1 , m , arr2 , n ) ; return 0 ; }
void printNumbers ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int A = arr [ n - 1 ] , B = -1 ;
for ( int i = n - 2 ; i >= 0 ; i -- ) {
if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; }
if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } }
cout << " A ▁ = ▁ " << A << " , ▁ B ▁ = ▁ " << B ; }
int main ( ) { int arr [ ] = { 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printNumbers ( arr , n ) ; return 0 ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
void removeMin ( int arr [ ] , int n ) { int i , minVal = arr [ 0 ] ;
for ( i = 1 ; i < n ; i ++ ) minVal = min ( minVal , arr [ i ] ) ;
for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; }
void removeFromMax ( int arr [ ] , int n ) { int i , maxVal = arr [ 0 ] ;
for ( i = 1 ; i < n ; i ++ ) maxVal = max ( maxVal , arr [ i ] ) ;
for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; }
void modifyArray ( int arr [ ] , int n , int k ) {
if ( k % 2 == 0 ) removeMin ( arr , n ) ;
else removeFromMax ( arr , n ) ;
printArray ( arr , n ) ; }
int main ( ) { int arr [ ] = { 4 , 8 , 12 , 16 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; modifyArray ( arr , n , k ) ; return 0 ; }
unsigned long long findAnswer ( int n , vector < int > & arr ) {
sort ( arr . begin ( ) , arr . end ( ) ) ;
unsigned long long sum = 0 ;
for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; }
int main ( ) { std :: vector < int > arr = { 53 , 28 , 143 , 5 } ; int n = arr . size ( ) ; cout << findAnswer ( n , arr ) ; }
#include <iostream> NEW_LINE #define n  4 NEW_LINE using namespace std ;
void merge ( int l , int r , int * output ) {
int l_in = l * n , r_in = ( ( l + r ) / 2 + 1 ) * n ;
int l_c = ( ( l + r ) / 2 - l + 1 ) * n ; int r_c = ( r - ( l + r ) / 2 ) * n ;
int l_arr [ l_c ] , r_arr [ r_c ] ;
for ( int i = 0 ; i < l_c ; i ++ ) l_arr [ i ] = output [ l_in + i ] ;
for ( int i = 0 ; i < r_c ; i ++ ) r_arr [ i ] = output [ r_in + i ] ;
int l_curr = 0 , r_curr = 0 ;
int in = l_in ;
while ( l_curr + r_curr < l_c + r_c ) { if ( r_curr == r_c || ( l_curr != l_c && l_arr [ l_curr ] < r_arr [ r_curr ] ) ) output [ in ] = l_arr [ l_curr ] , l_curr ++ , in ++ ; else output [ in ] = r_arr [ r_curr ] , r_curr ++ , in ++ ; } }
void divide ( int l , int r , int * output , int arr [ ] [ n ] ) { if ( l == r ) {
for ( int i = 0 ; i < n ; i ++ ) output [ l * n + i ] = arr [ l ] [ i ] ; return ; }
divide ( l , ( l + r ) / 2 , output , arr ) ;
divide ( ( l + r ) / 2 + 1 , r , output , arr ) ;
merge ( l , r , output ) ; }
int arr [ ] [ n ] = { { 5 , 7 , 15 , 18 } , { 1 , 8 , 9 , 17 } , { 1 , 4 , 7 , 7 } } ;
int k = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
int * output = new int [ n * k ] ; divide ( 0 , k - 1 , output , arr ) ;
for ( int i = 0 ; i < n * k ; i ++ ) cout << output [ i ] << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countDistinct ( int arr [ ] , int n ) { int res = 1 ;
for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ;
if ( i == j ) res ++ ; } return res ; }
int main ( ) { int arr [ ] = { 12 , 10 , 9 , 45 , 2 , 10 , 10 , 45 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDistinct ( arr , n ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int countDistinct ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) i ++ ; res ++ ; } return res ; }
int main ( ) { int arr [ ] = { 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countDistinct ( arr , n ) ; return 0 ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
void printMaxMean ( int arr [ ] , int n ) { int newArr [ n ] ;
sort ( arr , arr + 2 * n ) ;
for ( int i = 0 ; i < n ; i ++ ) newArr [ i ] = arr [ i + n ] ;
printArray ( newArr , n ) ; }
int main ( ) { int arr [ ] = { 4 , 8 , 3 , 1 , 3 , 7 , 0 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMaxMean ( arr , n / 2 ) ; return 0 ; }
double average ( int arr [ ] , int n , int k ) { double total = 0 ;
if ( 2 * k >= n ) return 0 ;
sort ( arr , arr + n ) ; int start = k , end = n - k - 1 ;
for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ;
return ( total / ( n - 2 * k ) ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 4 , 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << average ( arr , n , k ) << endl ; return 0 ; }
int min_sum ( int n , int k , int a [ ] ) { sort ( a , a + n ) ; if ( a [ 0 ] < 0 ) return -1 ;
if ( k == 0 ) {
if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return -1 ; } else { int f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int p = a [ i ] - a [ 0 ] ;
if ( p % k == 0 ) continue ; else { f = 1 ; break ; } }
if ( f ) return -1 ; else {
if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } }
int main ( ) { int arr [ ] = { 2 , 3 , 4 , 5 } ; int K = 1 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min_sum ( N , K , arr ) ; return 0 ; }
int minCost ( int A [ ] , int n ) {
int cost = 0 ;
sort ( A , A + n ) ;
int K = A [ n / 2 ] ;
for ( int i = 0 ; i < n ; ++ i ) cost += abs ( A [ i ] - K ) ;
if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ;
for ( int i = 0 ; i < n ; ++ i ) tempCost += abs ( A [ i ] - K ) ;
cost = min ( cost , tempCost ) ; }
return cost ; }
int main ( ) { int A [ ] = { 1 , 6 , 7 , 10 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minCost ( A , n ) ; return 0 ; }
void printArray ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ; int l = 0 , r = n - 1 , flag = 0 , i ;
int k = 2 ;
while ( l <= r ) {
if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) cout << arr [ i ] << " ▁ " ; flag = 1 ; l = i ; }
{ for ( i = r ; i > r - k && i >= l ; i -- ) cout << arr [ i ] << " ▁ " ; flag = 0 ; r = i ; }
k ++ ; } }
int main ( ) { int n = 6 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; printArray ( arr , n ) ; return 0 ; }
bool isAlphabaticOrder ( string s ) { int n = s . length ( ) ; for ( int i = 1 ; i < n ; i ++ ) {
if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; }
int main ( ) { string s = " aabbbcc " ;
if ( isAlphabaticOrder ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int rotateRec ( int n , int L [ ] , int B [ ] ) {
int m = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) {
if ( max ( L [ i ] , B [ i ] ) <= m ) m = max ( L [ i ] , B [ i ] ) ;
else if ( min ( L [ i ] , B [ i ] ) <= m ) m = min ( L [ i ] , B [ i ] ) ;
else { return 0 ; } } return 1 ; }
int n = 3 ;
int L [ ] = { 5 , 5 , 6 } ; int B [ ] = { 6 , 7 , 8 } ; rotateRec ( n , L , B ) == 1 ? cout << " YES " : cout << " NO " ; return 0 ; }
void minDistance ( int n , int k , vector < vector < int > > & point ) {
for ( int i = 0 ; i < k ; ++ i ) sort ( point [ i ] . begin ( ) , point [ i ] . end ( ) ) ;
for ( int i = 0 ; i < k ; ++ i ) cout << point [ i ] [ ( ceil ( ( double ) n / 2 ) - 1 ) ] << " ▁ " ; }
int main ( ) { int n = 4 , k = 4 ; vector < vector < int > > point = { { 1 , 5 , 2 , 4 } , { 6 , 2 , 0 , 6 } , { 9 , 5 , 1 , 3 } , { 6 , 7 , 5 , 9 } } ;
minDistance ( n , k , point ) ; return 0 ; }
void printOrder ( int arr [ ] , int n , int k ) { int len1 = k , len2 = n - k ; int arr1 [ k ] , arr2 [ n - k ] ;
for ( int i = 0 ; i < k ; i ++ ) arr1 [ i ] = arr [ i ] ;
for ( int i = k ; i < n ; i ++ ) arr2 [ i - k ] = arr [ i ] ;
sort ( arr1 , arr1 + len1 ) ;
sort ( arr2 , arr2 + len2 ) ;
for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) arr [ i ] = arr1 [ i ] ; else { arr [ i ] = arr2 [ len2 - 1 ] ; len2 -- ; } }
for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , -1 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printOrder ( arr , n , k ) ; return 0 ; }
void findMaxNum ( int arr [ ] , int n ) {
int hash [ 10 ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; }
for ( int i = 9 ; i >= 0 ; i -- ) {
for ( int j = 0 ; j < hash [ i ] ; j ++ ) cout << i ; } }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findMaxNum ( arr , n ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int distribution ( int arr [ ] , int n ) { sort ( arr , arr + n ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return min ( count , n / 2 ) ; }
int main ( ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << distribution ( arr , n ) << endl ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int main ( ) { int a [ ] = { 10 , 12 , 5 } ; sort ( a , a + 3 ) ; for ( int i = 0 ; i < 3 ; i ++ ) cout << a [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printTriplets ( int arr [ ] , int n , int sum ) {
for ( int i = 0 ; i < n - 2 ; i ++ ) {
for ( int j = i + 1 ; j < n - 1 ; j ++ ) {
for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) cout << arr [ i ] << " , ▁ " << arr [ j ] << " , ▁ " << arr [ k ] << endl ; } } }
int main ( ) { int arr [ ] = { 5 , 1 , 3 , 4 , 7 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int sum = 12 ; printTriplets ( arr , n , sum ) ; return 0 ; }
int countTriplets ( int arr [ ] , int n , int a , int b ) {
int ans = 0 ;
for ( int i = 0 ; i < n - 2 ; i ++ ) {
for ( int j = i + 1 ; j < n - 1 ; j ++ ) {
for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) ans ++ ; } } return ans ; }
int main ( ) { int arr [ ] = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int a = 8 , b = 16 ; cout << countTriplets ( arr , n , a , b ) << endl ; return 0 ; }
int countTripletsLessThan ( int arr [ ] , int n , int val ) {
sort ( arr , arr + n ) ;
int ans = 0 ; int j , k ;
int sum ;
for ( int i = 0 ; i < n - 2 ; i ++ ) {
j = i + 1 ; k = n - 1 ;
while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ;
if ( sum > val ) k -- ;
else { ans += ( k - j ) ; j ++ ; } } } return ans ; }
int countTriplets ( int arr [ ] , int n , int a , int b ) {
int res ;
res = countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ; return res ; }
int main ( ) { int arr [ ] = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int a = 8 , b = 16 ; cout << countTriplets ( arr , n , a , b ) << endl ; return 0 ; }
int MaxTotalRectangleArea ( int a [ ] , int n ) {
sort ( a , a + n , greater < int > ( ) ) ;
int sum = 0 ; bool flag = false ;
int len ; for ( int i = 0 ; i < n ; i ++ ) {
if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) {
flag = true ;
len = a [ i + 1 ] ;
i ++ ; }
else if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) {
sum = sum + a [ i + 1 ] * len ;
flag = false ;
i ++ ; } } return sum ; }
int main ( ) { int a [ ] = { 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << MaxTotalRectangleArea ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; void print ( vector < int > a , int n ) { for ( int i = 0 ; i <= n ; i ++ ) cout << a [ i ] << " ▁ " ; cout << endl ; }
void sort ( vector < int > a , int n ) { for ( int i = n ; i >= 0 ; i -- ) for ( int j = n ; j > n - i ; j -- ) if ( a [ j ] > a [ j - 1 ] ) swap ( a [ j ] , a [ j - 1 ] ) ; print ( a , n ) ; }
int main ( ) { int n = 7 ; vector < int > a ; a . push_back ( 2 ) ; a . push_back ( 4 ) ; a . push_back ( 3 ) ; a . push_back ( 2 ) ; a . push_back ( 4 ) ; a . push_back ( 5 ) ; a . push_back ( 3 ) ; sort ( a , n - 1 ) ; return 0 ; }
int distancesum ( int x [ ] , int y [ ] , int n ) { int sum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) ; return sum ; }
int main ( ) { int x [ ] = { -1 , 1 , 3 , 2 } ; int y [ ] = { 5 , 6 , 5 , 3 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; cout << distancesum ( x , y , n ) << endl ; return 0 ; }
int distancesum ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int res = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += ( arr [ i ] * i - sum ) ; sum += arr [ i ] ; } return res ; } int totaldistancesum ( int x [ ] , int y [ ] , int n ) { return distancesum ( x , n ) + distancesum ( y , n ) ; }
int main ( ) { int x [ ] = { -1 , 1 , 3 , 2 } ; int y [ ] = { 5 , 6 , 5 , 3 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; cout << totaldistancesum ( x , y , n ) << endl ; return 0 ; }
void printMedian ( int arr [ ] , int n , int K ) {
sort ( arr , arr + n ) ;
cout << arr [ ( n + K ) / 2 ] ; }
int main ( ) { int arr [ ] = { 5 , 3 , 2 , 8 } ; int k = 3 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printMedian ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void arrange ( int arr [ ] , int n , int x ) {
for ( int i = 1 ; i < n ; i ++ ) { int diff = abs ( arr [ i ] - x ) ;
int j = i - 1 ; if ( abs ( arr [ j ] - x ) > diff ) { int temp = arr [ i ] ; while ( abs ( arr [ j ] - x ) > diff && j >= 0 ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } } }
void print ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 10 , 5 , 3 , 9 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 7 ; arrange ( arr , n , x ) ; print ( arr , n ) ; return 0 ; }
void printOrder ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
for ( int i = 0 ; i < n / 2 ; i ++ ) cout << arr [ i ] << " ▁ " ;
for ( int j = n - 1 ; j >= n / 2 ; j -- ) cout << arr [ j ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , -1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printOrder ( arr , n ) ; return 0 ; }
int findMinimum ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
res += arr [ i ] ;
n = n - k ; } return res ; }
int findMaximum ( int arr [ ] , int n , int k ) { int res = 0 , index = 0 ; for ( int i = n - 1 ; i >= index ; i -- ) {
res += arr [ i ] ;
index += k ; } return res ; }
int main ( ) { int arr [ ] = { 3 , 2 , 1 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; sort ( arr , arr + n ) ;
cout << findMinimum ( arr , n , k ) << " ▁ " << findMaximum ( arr , n , k ) << endl ; return 0 ; }
int maxLevel ( int boxes [ ] , int n ) {
sort ( boxes , boxes + n ) ;
int prev_width = boxes [ 0 ] ; int prev_count = 1 ;
int curr_count = 0 ;
int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) {
curr_width += boxes [ i ] ; curr_count += 1 ;
if ( curr_width > prev_width && curr_count > prev_count ) {
prev_width = curr_width ; prev_count = curr_count ;
curr_count = 0 ; curr_width = 0 ;
ans ++ ; } } return ans ; }
int main ( ) { int boxes [ ] = { 10 , 20 , 30 , 50 , 60 , 70 } ; int n = sizeof ( boxes ) / sizeof ( boxes [ 0 ] ) ; cout << maxLevel ( boxes , n ) << endl ; return 0 ; }
void twoWaySort ( int arr [ ] , int n ) {
for ( int i = 0 ; i < n ; i ++ )
arr [ i ] *= -1 ;
sort ( arr , arr + n ) ;
for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= -1 ; }
int main ( ) { int arr [ ] = { 1 , 3 , 2 , 7 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( int ) ; twoWaySort ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; return 0 ; }
bool isPossibleTriangle ( int arr [ ] , int N ) {
if ( N < 3 ) return false ;
sort ( arr , arr + N ) ;
for ( int i = 0 ; i < N - 2 ; i ++ )
if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; }
int main ( ) { int arr [ ] = { 5 , 4 , 3 , 1 , 2 } ; int N = sizeof ( arr ) / sizeof ( int ) ; isPossibleTriangle ( arr , N ) ? cout << " Yes " : cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  1000000 NEW_LINE using namespace std ;
int ksmallest ( int arr [ ] , int n , int k ) {
int b [ MAX ] ; memset ( b , 0 , sizeof b ) ;
for ( int i = 0 ; i < n ; i ++ ) b [ arr [ i ] ] = 1 ; for ( int j = 1 ; j < MAX ; j ++ ) {
if ( b [ j ] != 1 ) k -- ;
if ( ! k ) return j ; } }
int main ( ) { int k = 1 ; int arr [ ] = { 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ksmallest ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void mergeTwoHalf ( int A [ ] , int n ) {
sort ( A , A + n ) ; }
int main ( ) { int A [ ] = { 2 , 3 , 8 , -1 , 7 , 10 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; mergeTwoHalf ( A , n ) ;
for ( int i = 0 ; i < n ; i ++ ) cout << A [ i ] << " ▁ " ; return 0 ; }
int minDiff ( int arr [ ] , int n , int k ) { int result = INT_MAX ;
sort ( arr , arr + n ) ;
for ( int i = 0 ; i <= n - k ; i ++ ) result = min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; }
int main ( ) { int arr [ ] = { 10 , 100 , 300 , 200 , 1000 , 20 , 30 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 3 ; cout << minDiff ( arr , n , k ) << endl ; return 0 ; }
int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_count = 0 ; int i = left ;
int j = mid ;
int k = left ;
while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ;
inv_count = inv_count + ( mid - i ) ; } }
while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ;
while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ;
for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; }
int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) {
mid = ( right + left ) / 2 ;
inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ;
inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; }
int countSwaps ( int arr [ ] , int n ) { int temp [ n ] ; return _mergeSort ( arr , temp , 0 , n - 1 ) ; }
int main ( int argv , char * * args ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Number ▁ of ▁ swaps ▁ is ▁ % d ▁ STRNEWLINE " , countSwaps ( arr , n ) ) ; return 0 ; }
bool isEven ( int n ) { return ( n % 2 == 0 ) ; }
int main ( ) { int n = 101 ; isEven ( n ) ? cout << " Even " : cout << " Odd " ; return 0 ; }
void findSurpasser ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) {
int count = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; cout << count << " ▁ " ; } }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , arr [ i ] ) ; printf ( " STRNEWLINE " ) ; }
int main ( ) { int arr [ ] = { 2 , 7 , 5 , 3 , 0 , 8 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Given ▁ array ▁ is ▁ STRNEWLINE " ) ; printArray ( arr , n ) ; printf ( " Surpasser ▁ Count ▁ of ▁ array ▁ is ▁ STRNEWLINE " ) ; findSurpasser ( arr , n ) ; return 0 ; }
int solve ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( i & 1 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; }
return a + b ; }
int main ( ) { int arr [ ] = { 6 , 8 , 4 , 5 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ is ▁ " << solve ( arr , n ) ; return 0 ; }
int maxProduct ( int arr [ ] , int n ) {
if ( n < 3 ) return -1 ;
int max_product = INT_MIN ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; }
int main ( ) { int arr [ ] = { 10 , 3 , 5 , 6 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Triplet ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
int maxProduct ( int arr [ ] , int n ) {
if ( n < 3 ) return -1 ;
vector < int > leftMin ( n , -1 ) ; vector < int > rightMin ( n , -1 ) ; vector < int > leftMax ( n , -1 ) ; vector < int > rightMax ( n , -1 ) ;
int max_product = INT_MIN ;
int max_sum = arr [ 0 ] ;
int min_sum = arr [ 0 ] ;
for ( int i = 1 ; i < n ; i ++ ) { leftMax [ i ] = max_sum ; if ( arr [ i ] > max_sum ) max_sum = arr [ i ] ; leftMin [ i ] = min_sum ; if ( arr [ i ] < min_sum ) min_sum = arr [ i ] ; }
max_sum = arr [ n - 1 ] ;
min_sum = arr [ n - 1 ] ;
for ( int j = n - 2 ; j >= 0 ; j -- ) { rightMax [ j ] = max_sum ; if ( arr [ j ] > max_sum ) max_sum = arr [ j ] ; rightMin [ j ] = min_sum ; if ( arr [ j ] < min_sum ) min_sum = arr [ j ] ; }
for ( int i = 1 ; i < n - 1 ; i ++ ) { int max1 = max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) ; int max2 = max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) ; max_product = max ( max_product , max ( max1 , max2 ) ) ; } return max_product ; }
int main ( ) { int arr [ ] = { 1 , 4 , 3 , -6 , -7 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Triplet ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
int maxProduct ( int arr [ ] , int n ) {
if ( n < 3 ) return -1 ;
sort ( arr , arr + n ) ;
return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; }
int main ( ) { int arr [ ] = { -10 , -3 , 5 , 6 , -20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Triplet ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
int Substring ( string s ) { int ans = 1 , temp = 1 ;
for ( int i = 1 ; i < s . size ( ) ; i ++ ) {
if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = max ( ans , temp ) ; temp = 1 ; } } ans = max ( ans , temp ) ;
return ans ; }
int main ( ) { string s = " abcdddddeff " ;
cout << Substring ( s ) ; return 0 ; }
void solve ( int n , int k ) { int mini = 0 ; int x1 = 1 ; int a [ k ] ; for ( int i = 1 ; i <= k ; i ++ ) { mini += x1 ; a [ i - 1 ] = x1 ; x1 += 1 ; }
if ( n < mini ) { cout << " - 1" ; return ; } int rem = n - mini ; int cnt = rem / k ; rem = rem % k ;
for ( int i = 0 ; i < k ; i ++ ) a [ i ] += cnt ;
for ( int i = k - 1 ; i > 0 && rem > 0 ; i -- ) {
int xx = a [ i - 1 ] * 2 ; int left = xx - a [ i ] ;
if ( rem >= left ) { a [ i ] = xx ; rem -= left ; }
else { a [ i ] += rem ; rem = 0 ; } }
int sum = a [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) {
if ( a [ i ] > 2 * a [ i - 1 ] ) { cout << " - 1" ; return ; }
sum += a [ i ] ; }
if ( sum != n ) { cout << " - 1" ; return ; }
for ( int i = 0 ; i < k ; i ++ ) cout << a [ i ] << " ▁ " ; }
int main ( ) { int n = 26 , k = 6 ; solve ( n , k ) ; return 0 ; }
int maxCoins ( int X , int Y ) {
if ( X < Y ) swap ( X , Y ) ;
int coins = X ;
X -- ;
coins += max ( X , Y ) ; return coins ; }
int main ( ) { int X = 7 , Y = 5 ; cout << maxCoins ( X , Y ) ; return 0 ; }
int findElementsCrossed ( int arr [ ] , int a , int b , int n ) {
int aa = a ; int ans = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( a == 0 && b == 0 ) break ;
else if ( a == 0 ) {
if ( arr [ i ] == 1 ) { b -= 1 ; a = min ( aa , a + 1 ) ; }
else b -= 1 ; }
else if ( b == 0 ) a -- ;
else if ( arr [ i ] == 1 && a < aa ) { b -= 1 ; a = min ( aa , a + 1 ) ; }
else a -- ; ans ++ ; } return ans ; }
int main ( ) { int arr [ ] = { 1 , 0 , 0 , 1 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int a = 1 ; int b = 2 ; cout << findElementsCrossed ( arr , a , b , n ) ; return 0 ; }
bool isVowel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; default : return false ; } }
int vowelPairs ( string s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {
if ( isVowel ( s [ i ] ) && isVowel ( s [ i + 1 ] ) ) cnt ++ ; } return cnt ; }
int main ( ) { string s = " abaebio " ; int n = s . length ( ) ; cout << vowelPairs ( s , n ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int solve ( int * health , int n ) {
int currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ;
for ( int i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; }
int main ( ) { int health [ ] = { 4 , 6 , 8 , 12 } ; int n = sizeof ( health ) / sizeof ( health [ 0 ] ) ; cout << solve ( health , n ) ; return 0 ; }
void Find_Sequence ( int arr [ ] , int n ) {
vector < int > inc_arr , dec_arr ;
int flag = 0 ; long inc = -1 , dec = 1e7 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( inc < arr [ i ] && arr [ i ] < dec ) {
if ( arr [ i ] < arr [ i + 1 ] ) { inc = arr [ i ] ; inc_arr . emplace_back ( arr [ i ] ) ; }
else { dec = arr [ i ] ; dec_arr . emplace_back ( arr [ i ] ) ; } }
else if ( inc < arr [ i ] ) { inc = arr [ i ] ; inc_arr . emplace_back ( arr [ i ] ) ; }
else if ( dec > arr [ i ] ) { dec = arr [ i ] ; dec_arr . emplace_back ( arr [ i ] ) ; }
else { cout << -1 << endl ; flag = 1 ; break ; } }
if ( ! flag ) { for ( auto i = inc_arr . begin ( ) ; i != inc_arr . end ( ) ; i ++ ) cout << * i << " ▁ " ; cout << endl ; for ( auto i = dec_arr . begin ( ) ; i != dec_arr . end ( ) ; i ++ ) cout << * i << " ▁ " ; cout << endl ; } }
int main ( ) { int arr [ ] = { 5 , 1 , 3 , 6 , 8 , 2 , 9 , 0 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; Find_Sequence ( arr , n ) ; }
int reverse ( int n ) { int rev = 0 ; while ( n != 0 ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; }
void getSum ( int n ) { n = reverse ( n ) ; int sumOdd = 0 , sumEven = 0 , c = 1 ; while ( n != 0 ) {
if ( c % 2 == 0 ) sumEven += n % 10 ; else sumOdd += n % 10 ; n /= 10 ; c ++ ; } cout << " Sum ▁ odd ▁ = ▁ " << sumOdd << " STRNEWLINE " ; cout << " Sum ▁ even ▁ = ▁ " << sumEven ; }
int main ( ) { int n = 457892 ; getSum ( n ) ; return 0 ; }
int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ;
if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return -1 ; }
int main ( ) { int A = 1 , B = 2 , S = 7 , N = 5 ; cout << bankNotes ( A , B , S , N ) << endl ; }
void twoParts ( string str ) { int flag = 0 ; string a = " " ;
for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == '4' ) { str [ i ] = '3' ; a += '1' ; flag = 1 ; }
else if ( flag ) a += '0' ; }
cout << str << " ▁ " << a ; }
int main ( ) { string str = "9441" ; twoParts ( str ) ; return 0 ; }
int longestSubstring ( string s ) { int cnt = 1 ; int maxi = 1 ;
int n = s . length ( ) ;
for ( int i = 1 ; i < n ; i ++ ) {
if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; else {
maxi = max ( cnt , maxi ) ;
cnt = 1 ; } }
maxi = max ( cnt , maxi ) ; return maxi ; }
int main ( ) { string s = " ccccdeededff " ; cout << longestSubstring ( s ) ; return 0 ; }
int Minimum_Operations ( int a [ ] , int n ) {
int np [ n + 1 ] ; np [ n ] = 0 ;
for ( int i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ;
if ( a [ i ] <= 0 ) np [ i ] ++ ; }
int pos = 0 ; int ans = n ;
for ( int i = 0 ; i < n - 1 ; i ++ ) {
if ( a [ i ] >= 0 ) pos ++ ;
ans = min ( ans , pos + np [ i + 1 ] ) ; }
return ans ; }
int main ( ) { int a [ ] = { -1 , 0 , 1 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << Minimum_Operations ( a , n ) ; return 0 ; }
int findSumofEle ( int arr1 [ ] , int m , int arr2 [ ] , int n , int k ) { float arraySum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ;
int sumOfElements = 0 ; float difference ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( -1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } }
return sumOfElements ; }
int main ( ) { int arr1 [ ] = { 1 , 2 , 3 , 4 , 7 , 9 } ; int arr2 [ ] = { 0 , 1 , 2 , 1 , 1 , 4 } ; int k = 2 ; int m , n ; m = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << findSumofEle ( arr1 , m , arr2 , n , k ) ; return 0 ; }
void findIntegers ( int n , int x , int y ) {
vector < int > ans ;
for ( int i = 0 ; i < n - 1 ; i ++ ) ans . push_back ( 1 ) ;
if ( y - ( n - 1 ) <= 0 ) { cout << " - 1" ; return ; }
ans . push_back ( y - ( n - 1 ) ) ;
int store = 0 ; for ( int i = 0 ; i < n ; i ++ ) store += ans [ i ] * ans [ i ] ;
if ( store < x ) { cout << " - 1" ; return ; }
for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " ▁ " ; }
int main ( ) { int n = 3 , x = 254 , y = 18 ; findIntegers ( n , x , y ) ; return 0 ; }
int Minsteps ( int n , int m ) { int ans = 0 ;
while ( m > n ) {
if ( m & 1 ) {
m ++ ; ans ++ ; }
m /= 2 ; ans ++ ; }
return ans + n - m ; }
int main ( ) { int n = 4 , m = 6 ; cout << Minsteps ( n , m ) ; return 0 ; }
int getsum ( int x ) { return ( x * ( x + 1 ) ) / 2 ; }
int countJumps ( int n ) {
n = abs ( n ) ;
int ans = 0 ;
while ( getsum ( ans ) < n or ( getsum ( ans ) - n ) & 1 ) ans ++ ;
return ans ; }
int main ( ) { int n = 9 ; cout << countJumps ( n ) ; return 0 ; }
int maxCandies ( int arr [ ] , int n ) {
int prevBought = arr [ n - 1 ] ; int candies = prevBought ;
for ( int i = n - 2 ; i >= 0 ; i -- ) {
int x = min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) {
candies += x ;
prevBought = x ; } } return candies ; }
int main ( ) { int arr [ ] = { 1 , 2 , 1 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxCandies ( arr , n ) ; return 0 ; }
int minChanges ( string str , int n ) {
int count = 0 , zeros = 0 , ones = 0 ;
if ( str [ 0 ] != '1' ) { count ++ ; ones ++ ; } for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeros ++ ; else ones ++ ;
if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } }
return count ; }
int main ( ) { string str = "0000" ; int n = str . length ( ) ; cout << minChanges ( str , n ) ; return 0 ; }
int steps ( int cur , int x , int n ) {
if ( x == 0 ) return INT_MAX ;
if ( x > 0 ) return abs ( ( n - cur ) / x ) ;
else return abs ( ( cur - 1 ) / x ) ; }
int countSteps ( int curx , int cury , int n , int m , vector < pair < int , int > > moves ) { int count = 0 ; int k = moves . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int x = moves [ i ] . first ; int y = moves [ i ] . second ;
int stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ;
count += stepct ; curx += stepct * x ; cury += stepct * y ; } return count ; }
main ( ) { int n = 4 , m = 5 , x = 1 , y = 1 ; vector < pair < int , int > > moves = { { 1 , 1 } , { 1 , 1 } , { 0 , -2 } } ; int k = moves . size ( ) ; cout << countSteps ( x , y , n , m , moves ) ; return 0 ; }
int min_elimination ( int n , int arr [ ] ) { int count = 0 ;
int prev_val = arr [ 0 ] ;
for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ;
if ( curr_val % 2 == prev_val % 2 ) count ++ ;
prev_val = curr_val ; }
return count ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 7 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << min_elimination ( n , arr ) ; return 0 ; }
string getCount ( int N ) {
if ( N % 2 == 1 ) return 0 ; string result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; }
int main ( ) { int N = 4 ; cout << getCount ( N ) ; return 0 ; }
bool canFormTeam ( int n , int m ) {
if ( n >= 1 && m >= 2 ) return true ;
if ( m >= 1 && n >= 2 ) return true ;
return false ; }
int maxTeams ( int n , int m ) {
int count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) {
n -= 2 ;
m -= 1 ; } else {
m -= 2 ;
n -= 1 ; }
count ++ ; } return count ; }
int main ( ) { int n = 4 , m = 5 ; cout << maxTeams ( n , m ) ; return 0 ; }
long long int max ( long long a , long long b ) { if ( a > b ) return a ; else return b ; }
long long int smallestSide ( long long int a [ ] ) {
sort ( a , a + 4 ) ; long long side1 , side2 , side3 , side4 , side11 , side12 , sideOfSquare ;
side1 = a [ 0 ] + a [ 3 ] ; side2 = a [ 1 ] + a [ 2 ] ; side3 = a [ 0 ] + a [ 1 ] ; side4 = a [ 2 ] + a [ 3 ] ;
side11 = max ( side1 , side2 ) ; side12 = max ( side3 , side4 ) ;
sideOfSquare = max ( side11 , side12 ) ;
return sideOfSquare ; }
int main ( ) { long long int side [ 4 ] ; cout << " Test ▁ Case ▁ 1 STRNEWLINE " ;
side [ 0 ] = 2 ; side [ 1 ] = 2 ; side [ 2 ] = 2 ; side [ 3 ] = 2 ;
cout << smallestSide ( side ) << endl ; cout << " Test Case 2 "
side [ 0 ] = 100000000000000 ; side [ 1 ] = 123450000000000 ; side [ 2 ] = 987650000000000 ; side [ 3 ] = 987654321000000 ;
cout << smallestSide ( side ) << endl ; return 0 ; }
void find_rectangle ( int area ) { int l , b ; int M = sqrt ( area ) , ans ; for ( int i = M ; i >= 1 ; i -- ) {
if ( area % i == 0 ) {
l = ( area / i ) ;
b = i ; break ; } }
cout << " l ▁ = ▁ " << l << " , ▁ b ▁ = ▁ " << b << endl ; }
int main ( ) { int area = 99 ; find_rectangle ( area ) ; return 0 ; }
int sizeSubSet ( int a [ ] , int k , int n ) {
sort ( a , a + n ) ;
unordered_set < int > s ;
for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . count ( a [ i ] / k ) == 0 ) s . insert ( a [ i ] ) ; }
return s . size ( ) ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 2 ; cout << sizeSubSet ( a , k , n ) ; return 0 ; }
int minimumSets ( string s , int y ) {
int cnt = 0 ; int num = 0 ; int l = s . length ( ) ; int f = 0 ;
for ( int i = 0 ; i < l ; i ++ ) {
num = num * 10 + ( s [ i ] - '0' ) ;
if ( num <= y ) f = 1 ;
{
if ( f ) cnt += 1 ;
num = s [ i ] - '0' ; f = 0 ;
if ( num <= y ) f = 1 ; else num = 0 ; } }
if ( f ) cnt += 1 ; return cnt ; }
int main ( ) { string s = "1234" ; int y = 30 ; cout << minimumSets ( s , y ) ; return 0 ; }
void printArr ( int b [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << b [ i ] << " ▁ " ; }
void ModifiedArray ( int a [ ] , int n ) {
int l = 0 , r = INT_MAX ;
int b [ n ] = { 0 } ;
for ( int i = 0 ; i < n / 2 ; i ++ ) { b [ i ] = max ( l , a [ i ] - r ) ; b [ n - i - 1 ] = a [ i ] - b [ i ] ; l = b [ i ] ; r = b [ n - i - 1 ] ; }
printArr ( b , n ) ; }
int main ( ) { int a [ ] = { 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; ModifiedArray ( a , 2 * n ) ; return 0 ; }
int maxSubArraySum ( int a [ ] , int size ) { int max_so_far = INT_MIN , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int maxSum ( int a [ ] , int n ) {
int S = 0 ;
int S1 = maxSubArraySum ( a , n ) ;
for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; }
int main ( ) { int a [ ] = { -35 , 32 , -24 , 0 , 27 , -10 , 0 , -19 } ;
int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxSum ( a , n ) ; return 0 ; }
int minimizeDiff ( int * arr , int n , int k ) {
int max = * ( max_element ( arr , arr + n ) ) ; int min = * ( min_element ( arr , arr + n ) ) ;
if ( ( max - min ) <= k ) { return ( max - min ) ; }
int avg = ( max + min ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( arr [ i ] > avg ) arr [ i ] -= k ;
else arr [ i ] += k ; }
max = * ( max_element ( arr , arr + n ) ) ; min = * ( min_element ( arr , arr + n ) ) ;
return ( max - min ) ; }
int main ( ) { int arr [ ] = { 3 , 16 , 12 , 9 , 20 } ; int n = 5 ; int k = 3 ; cout << " Max ▁ height ▁ difference ▁ = ▁ " << minimizeDiff ( arr , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxLitres ( int budget , int plastic , int glass , int refund ) {
if ( glass - refund < plastic ) {
int ans = max ( ( budget - refund ) / ( glass - refund ) , 0 ) ;
budget -= ans * ( glass - refund ) ;
ans += budget / plastic ; cout << ans << endl ; }
else cout < < ( budget / plastic ) << endl ; }
int main ( ) { int budget = 10 , plastic = 11 , glass = 9 , refund = 8 ; maxLitres ( budget , plastic , glass , refund ) ; }
int leastValue ( int P , int A , int N , int a [ ] ) {
int ans = -1 ;
float tmp = ( float ) INFINITY ; for ( int i = 0 ; i < N ; i ++ ) {
float t = P - a [ i ] * 0.006 ;
if ( abs ( t - A ) < tmp ) { tmp = abs ( t - A ) ; ans = i ; } } return a [ ans ] ; }
int main ( ) { int N = 2 , P = 12 , A = 2005 ; int a [ ] = { 1000 , 2000 } ; cout << leastValue ( P , A , N , a ) << endl ; }
int findPermutation ( int n ) {
int len = ceil ( log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) {
if ( n % 2 != 0 ) {
return n ; } else {
n = ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) ; continue ; } }
return -1 ; }
int main ( ) { int n = 132 ; cout << findPermutation ( n ) ; return 0 ; }
bool isSellingPossible ( int n , int a [ ] ) { int i , c25 = 0 , c50 = 0 ; for ( i = 0 ; i < n ; i ++ ) {
if ( a [ i ] == 25 ) c25 ++ ; else if ( a [ i ] == 50 ) { c50 ++ ;
if ( c25 == 0 ) break ; c25 -- ; } else {
if ( c50 > 0 && c25 > 0 ) { c50 -- ; c25 -- ; }
else if ( c25 >= 3 ) c25 -= 3 ; else break ; } }
if ( i == n ) return true ; else return false ; }
int main ( ) { int a [ ] = { 25 , 25 , 50 , 100 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isSellingPossible ( n , a ) ) { cout << " YES " ; } else { cout << " NO " ; } }
bool checkIfOverlap ( string str ) { int len = str . length ( ) ;
int visited [ len + 1 ] = { 0 } ;
for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' . ' ) continue ;
for ( int j = max ( 0 , i - str [ i ] ) ; j <= min ( len , i + str [ i ] ) ; j ++ ) visited [ j ] ++ ; } for ( int i = 0 ; i < len ; i ++ ) {
if ( visited [ i ] > 1 ) { return true ; } } return false ; }
int main ( ) { string str = " . 2 . . 2 . " ; if ( checkIfOverlap ( str ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
bool isCorrectOrder ( int n ) { bool flag = true ;
int prev = -1 ;
int type = -1 ; while ( n != 0 ) { if ( type == -1 ) { if ( prev == -1 ) { prev = n % 10 ; n = n / 10 ; continue ; }
if ( prev == n % 10 ) { flag = false ; break ; }
if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else {
if ( prev == n % 10 ) { flag = false ; break ; }
if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; }
int main ( ) { int n = 123454321 ; if ( isCorrectOrder ( n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
void printCoins ( int arr [ ] , int n ) {
int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ;
int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ;
int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr1 [ ] = { 8 , 15 , 3 , 7 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; printCoins ( arr1 , n ) ; cout << endl ; int arr2 [ ] = { 2 , 2 , 2 , 2 } ; n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printCoins ( arr2 , n ) ; cout << endl ; int arr3 [ ] = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; printCoins ( arr3 , n ) ; return 0 ; }
void finalPos ( char command [ ] , int n , int x , int y ) {
int cup , cdown , cleft , cright ;
int final_x , final_y ; cup = cdown = cleft = cright = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { if ( command [ i ] == ' U ' ) cup ++ ; else if ( command [ i ] == ' D ' ) cdown ++ ; else if ( command [ i ] == ' L ' ) cleft ++ ; else if ( command [ i ] == ' R ' ) cright ++ ; }
final_x = x + ( cright - cleft ) ; final_y = y + ( cdown - cup ) ; cout << " Final ▁ Position : ▁ " << " ( " << final_x << " , ▁ " << final_y << " ) " ; }
int main ( ) { char command [ ] = " DDLRULL " ; int n = ( sizeof ( command ) / sizeof ( char ) ) - 1 ; int x = 3 , y = 4 ; finalPos ( command , n , x , y ) ; return 0 ; }
int smallestSumSubarr ( int arr [ ] , int n ) {
for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ;
int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = max ( max_sum , sum_here ) ; }
return ( -1 ) * max_sum ; }
int main ( ) { int arr [ ] = { 3 , -4 , 2 , -3 , -1 , 7 , -5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Smallest ▁ sum : ▁ " << smallestSumSubarr ( arr , n ) ; return 0 ; }
void printLargest ( int a [ ] , int n ) {
int max = -1 ; int ind = -1 ;
for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ;
while ( num ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) {
if ( max < r ) { max = r ; ind = i ; } } } }
for ( int i = ind ; i < n ; i ++ ) cout << a [ i ] ;
for ( int i = 0 ; i < ind ; i ++ ) cout << a [ i ] ; }
int main ( ) { int a [ ] = { 54 , 546 , 548 , 60 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printLargest ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int MinOperation ( int a [ ] , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) {
if ( a [ i ] != 1 && a [ i ] > k ) { result = result + min ( a [ i ] % k , k - a [ i ] % k ) ; } else {
result = result + k - a [ i ] ; } } return result ; }
int main ( ) { int arr [ ] = { 4 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 5 ; cout << MinOperation ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxProductSubset ( int a [ ] , int n ) { if ( n == 1 ) return a [ 0 ] ;
int max_neg = INT_MIN ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] == 0 ) { count_zero ++ ; continue ; }
if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; }
if ( count_zero == n ) return 0 ;
if ( count_neg & 1 ) {
if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0 ;
prod = prod / max_neg ; } return prod ; }
int main ( ) { int a [ ] = { -1 , -1 , -2 , 4 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maxProductSubset ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void digitsNum ( int N ) {
if ( N == 0 ) cout << "0 STRNEWLINE " ;
if ( N % 9 != 0 ) cout << ( N % 9 ) ;
for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) cout << "9" ;
for ( int i = 1 ; i <= N ; ++ i ) cout << "0" ; cout << " STRNEWLINE " ; }
int main ( ) { int N = 5 ; cout << " The ▁ number ▁ is ▁ : ▁ " ; digitsNum ( N ) ; return 0 ; }
void printVector ( vector < int > v ) {
cout << v . size ( ) << endl ;
for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << " ▁ " ; cout << endl ; }
void findTwoGroup ( int n ) {
int sum = n * ( n + 1 ) / 2 ;
int group1Sum = sum / 2 ; vector < int > group1 , group2 ; for ( int i = n ; i > 0 ; i -- ) {
if ( group1Sum - i >= 0 ) { group1 . push_back ( i ) ;
group1Sum -= i ; } else { group2 . push_back ( i ) ; } }
printVector ( group1 ) ; printVector ( group2 ) ; }
int main ( ) { int n = 5 ; findTwoGroup ( n ) ; return 0 ; }
int maxDifference ( int arr [ ] , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ;
for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ;
sort ( arr , arr + N , greater < int > ( ) ) ; M = max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ;
max_difference = S1 - ( S - S1 ) ; return max_difference ; }
int main ( ) { int arr [ ] = { 8 , 4 , 5 , 2 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << maxDifference ( arr , N , k ) << endl ; return 0 ; }
int minproduct ( int a [ ] , int b [ ] , int n , int k ) { int diff = 0 , res = 0 ; int temp ; for ( int i = 0 ; i < n ; i ++ ) {
int pro = a [ i ] * b [ i ] ; res = res + pro ;
if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ;
else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ;
else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ;
int d = abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; }
int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 4 } ; int b [ ] = { 3 , 4 , 2 , 3 , 2 } ; int n = 5 , k = 3 ; cout << minproduct ( a , b , n , k ) << endl ; return 0 ; }
int count ( int n ) {
if ( n < 4 ) return -1 ;
int rem = n % 4 ;
if ( rem == 0 ) return n / 4 ;
if ( rem == 1 ) {
if ( n < 9 ) return -1 ;
return ( n - 9 ) / 4 + 1 ; }
if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ;
if ( rem == 3 ) { if ( n < 15 ) return -1 ;
return ( n - 15 ) / 4 + 2 ; } }
int main ( ) { int n = 90 ; cout << count ( n ) << endl ; n = 143 ; cout << count ( n ) << endl ; return 0 ; }
int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ;
while ( input unlock_code ) {
input_digit = input % 10 ; code_digit = unlock_code % 10 ;
rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ;
input /= 10 ; unlock_code /= 10 ; } return rotation ; }
int main ( ) { int input = 28756 ; int unlock_code = 98234 ; cout << " Minimum ▁ Rotation ▁ = ▁ " << minRotation ( input , unlock_code ) ; return 0 ; }
void preprocess ( int coin [ ] , int n ) {
sort ( coin , coin + n ) ;
for ( int i = 1 ; i <= n - 1 ; i ++ ) coin [ i ] += coin [ i - 1 ] ; }
int minCost ( int coin [ ] , int n , int k ) {
int coins_needed = ceil ( 1.0 * n / ( k + 1 ) ) ;
return coin [ coins_needed - 1 ] ; }
int main ( ) { int coin [ ] = { 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 } ; int n = sizeof ( coin ) / sizeof ( coin [ 0 ] ) ; preprocess ( coin , n ) ; int k = 3 ; cout << minCost ( coin , n , k ) << endl ; k = 7 ; cout << minCost ( coin , n , k ) << endl ; return 0 ; }
int maximumSum ( int arr [ ] , int n , int k ) {
for ( int i = 1 ; i <= k ; i ++ ) { int min = INT_MAX ; int index = -1 ;
for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } }
if ( min == 0 ) break ;
arr [ index ] = - arr [ index ] ; }
int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int main ( ) { int arr [ ] = { -2 , 0 , 5 , -1 , 2 } ; int k = 4 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maximumSum ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define maxLen  10 NEW_LINE using namespace std ;
int dp [ maxLen ] ;
bool v [ maxLen ] ;
int maxSum ( int arr [ ] , int i , int n ) {
if ( i >= n ) return 0 ;
if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ;
dp [ i ] = max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ;
return dp [ i ] ; }
int main ( ) { int arr [ ] = { 12 , 9 , 7 , 33 } ; int n = sizeof ( arr ) / sizeof ( int ) ; cout << maxSum ( arr , 0 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5
int func ( int idx , int cur , int a [ ] , int dp [ N ] [ 3 ] , int n , int x ) {
if ( idx == n ) return 0 ;
if ( dp [ idx ] [ cur ] != -1 ) return dp [ idx ] [ cur ] ; int ans = 0 ;
if ( cur == 0 ) {
ans = max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) ;
ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) ; } else if ( cur == 1 ) {
ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) ;
ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) ; } else
ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) ;
return dp [ idx ] [ cur ] = ans ; }
int getMaximumSum ( int a [ ] , int n , int x ) {
int dp [ n ] [ 3 ] ; memset ( dp , -1 , sizeof dp ) ;
int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) maxi = max ( maxi , func ( i , 0 , a , dp , n , x ) ) ; return maxi ; }
int main ( ) { int a [ ] = { -3 , 8 , -2 , 1 , -6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int x = -1 ; cout << getMaximumSum ( a , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100
void pre_process ( bool dp [ N ] [ N ] , string s ) {
int n = s . size ( ) ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = false ; }
for ( int j = 1 ; j <= n ; j ++ ) {
for ( int i = 0 ; i <= n - j ; i ++ ) {
if ( j <= 2 ) {
if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = true ; }
else if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } }
int countPairs ( string s ) {
bool dp [ N ] [ N ] ; pre_process ( dp , s ) ; int n = s . length ( ) ;
int left [ n ] ; memset ( left , 0 , sizeof left ) ;
int right [ n ] ; memset ( right , 0 , sizeof right ) ;
left [ 0 ] = 1 ;
for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( dp [ j ] [ i ] == 1 ) left [ i ] ++ ; } }
right [ n - 1 ] = 1 ;
for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] ; for ( int j = n - 1 ; j >= i ; j -- ) { if ( dp [ i ] [ j ] == 1 ) right [ i ] ++ ; } } int ans = 0 ;
for ( int i = 0 ; i < n - 1 ; i ++ ) ans += left [ i ] * right [ i + 1 ] ; return ans ; }
int main ( ) { string s = " abacaba " ; cout << countPairs ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100
void pre_process ( bool dp [ N ] [ N ] , string s ) {
int n = s . size ( ) ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = false ; }
for ( int j = 1 ; j <= n ; j ++ ) {
for ( int i = 0 ; i <= n - j ; i ++ ) {
if ( j <= 2 ) {
if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = true ; }
else if ( s [ i ] == s [ i + j - 1 ] ) dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } }
void answerQuery ( int l , int r , bool dp [ N ] [ N ] ) { if ( dp [ l ] [ r ] ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; }
int main ( ) { string s = " abaaab " ; bool dp [ N ] [ N ] ; pre_process ( dp , s ) ; int queries [ ] [ 2 ] = { { 0 , 1 } , { 1 , 5 } } ; int q = sizeof ( queries ) / sizeof ( queries [ 0 ] ) ; for ( int i = 0 ; i < q ; i ++ ) answerQuery ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , dp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005
int LIS ( int a [ ] , int n ) {
int dp [ N ] , d [ N ] ;
int ans = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
dp [ a [ i ] ] = 1 ;
for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) {
dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ;
d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } }
ans = max ( ans , dp [ a [ i ] ] ) ;
d [ a [ i ] ] = a [ i ] ; }
return ans ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << LIS ( a , n ) ; return 0 ; }
int findSum ( int n ) {
int dp [ n + 1 ] ;
dp [ 1 ] = 1 ; dp [ 0 ] = 0 ;
for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( 4 * ( i * i ) ) - 6 * ( i - 1 ) + dp [ i - 2 ] ; } return dp [ n ] ; }
int main ( ) { int n = 4 ; cout << findSum ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; #define n  3 NEW_LINE #define MAX  30
int dp [ n ] [ n ] [ MAX ] ;
bool v [ n ] [ n ] [ MAX ] ;
int findCount ( int mat [ ] [ n ] , int i , int j , int m ) {
if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; }
if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ;
if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ;
v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; }
int main ( ) { int mat [ n ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int m = 5 ; cout << findCount ( mat , n - 1 , n - 1 , m ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int N = 10 ;
int findMinimumDeletion ( int l , int r , int dp [ N ] [ N ] , string s ) { if ( l > r ) return 0 ; if ( l == r ) return 1 ; if ( dp [ l ] [ r ] != -1 ) return dp [ l ] [ r ] ;
int res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) ;
for ( int i = l + 1 ; i <= r ; ++ i ) {
if ( s [ l ] == s [ i ] ) res = min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) ; }
return dp [ l ] [ r ] = res ; }
int main ( ) { string s = " abcddcba " ; int n = s . length ( ) ; int dp [ N ] [ N ] ; memset ( dp , -1 , sizeof dp ) ; cout << findMinimumDeletion ( 0 , n - 1 , dp , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  5005
int n , k ; vector < int > gr [ N ] ;
int d [ N ] [ 505 ] ;
int ans = 0 ;
void Add_edge ( int x , int y ) { gr [ x ] . push_back ( y ) ; gr [ y ] . push_back ( x ) ; }
void dfs ( int v , int par ) {
d [ v ] [ 0 ] = 1 ; for ( auto i : gr [ v ] ) { if ( i != par ) { dfs ( i , v ) ;
for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] ;
for ( int j = 1 ; j <= k ; j ++ ) d [ v ] [ j ] += d [ i ] [ j - 1 ] ; } } }
int main ( ) { n = 5 , k = 2 ;
Add_edge ( 1 , 2 ) ; Add_edge ( 2 , 3 ) ; Add_edge ( 3 , 4 ) ; Add_edge ( 2 , 5 ) ;
dfs ( 1 , 0 ) ;
cout << ans ; return 0 ; }
int findXorSum ( int arr [ ] , int n ) {
int sum = 0 ;
int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) {
int c_odd = 0 ;
bool odd = 0 ;
for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) odd = ( ! odd ) ; if ( odd ) c_odd ++ ; }
for ( int j = 0 ; j < n ; j ++ ) { sum += ( mul * c_odd ) ; if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) c_odd = ( n - j - c_odd ) ; }
mul *= 2 ; }
return sum ; }
int main ( ) { int arr [ ] = { 3 , 8 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findXorSum ( arr , n ) ; return 0 ; }
bool checkCombinations ( int a [ ] , int n ) {
int pow_set_size = pow ( 2 , n ) ; int counter , j ;
for ( counter = 0 ; counter < pow_set_size ; counter ++ ) {
int sum = 0 ; for ( j = 0 ; j < n ; j ++ ) {
if ( counter & ( 1 << j ) )
else
}
if ( sum % ( 24 * 60 ) == 0 ) return true ; } return false ; }
int main ( ) { int a [ ] = { 60 , 60 , 120 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( checkCombinations ( a , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
float calcProbability ( int M [ ] [ m ] , int k ) {
float dp [ m ] [ n ] , sum [ n ] ;
for ( int j = 0 ; j < n ; j ++ ) { dp [ 0 ] [ j ] = M [ 0 ] [ j ] ; sum [ 0 ] += dp [ 0 ] [ j ] ; }
for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] / sum [ i - 1 ] + M [ i ] [ j ] ; sum [ i ] += dp [ i ] [ j ] ; } }
return dp [ n - 1 ] [ k - 1 ] / sum [ n - 1 ] ; }
int main ( ) { int M [ m ] [ n ] = { { 1 , 1 , 0 , 3 } , { 2 , 3 , 2 , 3 } , { 9 , 3 , 0 , 2 } , { 2 , 3 , 2 , 2 } } ; int k = 3 ; cout << calcProbability ( M , k ) ; return 0 ; }
int MaximumNumbers ( string s ) {
int n = s . length ( ) ;
vector < int > remIndex ( 3 , -1 ) ;
remIndex [ 0 ] = 0 ;
vector < int > res ( n + 1 ) ; int r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) {
r = ( r + s [ i - 1 ] - '0' ) % 3 ;
res [ i ] = res [ i - 1 ] ; if ( remIndex [ r ] != -1 ) res [ i ] = max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) ; remIndex [ r ] = i + 1 ; } return res [ n ] ; }
int main ( ) { string s = "12345" ; cout << MaximumNumbers ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define max  4 NEW_LINE #define c  2
int countPaths ( int sum , int get , int m , int n , int dp [ ] ) {
if ( sum < 0 ) return 0 ;
if ( sum == 0 ) return get ;
if ( dp [ sum ] [ get ] != -1 ) return dp [ sum ] [ get ] ;
int res = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) {
if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ;
res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; }
int main ( ) { int n = 3 , m = 2 , x = 3 ; int dp [ max + 1 ] ;
for ( int i = 0 ; i <= max ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = -1 ;
cout << countPaths ( x , 0 , m , n , dp ) ; }
const int MAX_K = 15 ; long long unsigned int fac [ MAX_K ] ;
void factorial ( int k ) { fac [ 0 ] = 1 ; for ( int i = 1 ; i <= k + 1 ; i ++ ) { fac [ i ] = ( i * fac [ i - 1 ] ) ; } }
long long unsigned int bin ( int a , int b ) {
long long unsigned int ans = ( ( fac [ a ] ) / ( fac [ a - b ] * fac [ b ] ) ) ; return ans ; }
long int sumofn ( int n , int k ) { int p = 0 ; long long unsigned int num1 , temp , arr [ 1000 ] ; for ( int j = 1 ; j <= k ; j ++ ) {
if ( j == 1 ) { num1 = ( n * ( n + 1 ) ) / 2 ;
arr [ p ++ ] = num1 ;
temp = num1 ; } else { temp = ( pow ( n + 1 , j + 1 ) - 1 - n ) ;
for ( int s = 1 ; s < j ; s ++ ) {
temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) ; } temp = temp / ( j + 1 ) ;
arr [ p ++ ] = temp ; } } temp = arr [ p - 1 ] ; return temp ; }
int main ( ) { int n = 5 , k = 2 ; factorial ( k ) ; cout << sumofn ( n , k ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define max  4
int countWays ( int index , int cnt , int dp [ ] [ max ] , int n , int m , int k ) {
if ( index == n ) {
if ( cnt == k ) return 1 ; else return 0 ; }
if ( dp [ index ] [ cnt ] != -1 ) return dp [ index ] [ cnt ] ; int ans = 0 ;
ans += countWays ( index + 1 , cnt , dp , n , m , k ) ;
ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; }
int main ( ) { int n = 3 , m = 3 , k = 2 ; int dp [ n + 1 ] [ max ] ; memset ( dp , -1 , sizeof dp ) ; cout << m * countWays ( 1 , 0 , dp , n , m , k ) ; }
int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ 2 * n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ;
int sum = 0 ;
for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ;
if ( i % 2 == 0 ) sum += fibo [ i ] ; }
return sum ; }
int n = 8 ;
cout << " Even ▁ indexed ▁ Fibonacci ▁ Sum ▁ upto ▁ " << n << " ▁ terms : ▁ " << calculateEvenSum ( n ) << endl ; return 0 ; }
#define MAX  32768
int arr [ 2 * MAX ] ;
int gouldSequence ( ) {
arr [ 0 ] = 1 ;
int i = 1 ;
int p = 1 ;
while ( i <= MAX ) {
int j = 0 ; while ( j < i ) {
arr [ i + j ] = 2 * arr [ j ] ; j ++ ; }
i = ( 1 << p ) ;
p ++ ; } }
void printSequence ( int n ) {
for ( int i = 0 ; i < n ; i ++ ) { cout << arr [ i ] << " ▁ " ; } }
int main ( ) { gouldSequence ( ) ;
int n = 16 ;
printSequence ( n ) ; return 0 ; }
int MatrixChainOrder ( int p [ ] , int n ) {
int dp [ n ] [ n ] ;
for ( int i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ;
for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; }
int main ( ) { int arr [ ] = { 10 , 20 , 30 , 40 , 30 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ % d ▁ " , MatrixChainOrder ( arr , size ) ) ; return 0 ; }
int CommomSubsequencesCount ( string s , string t ) { int n1 = s . length ( ) ; int n2 = t . length ( ) ; int dp [ n1 + 1 ] [ n2 + 1 ] ; for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } }
for ( int i = 1 ; i <= n1 ; i ++ ) {
for ( int j = 1 ; j <= n2 ; j ++ ) {
if ( s [ i - 1 ] == t [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] ; } } return dp [ n1 ] [ n2 ] ; }
int main ( ) { string s = " ajblqcpdz " ; string t = " aefcnbtdi " ; cout << CommomSubsequencesCount ( s , t ) << endl ; return 0 ; }
int fib [ 43 ] = { 0 } ;
void fibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i < 43 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; }
int rec ( int x , int y , int last ) {
if ( y == 0 ) { if ( x == 0 ) return 1 ; return 0 ; } int sum = 0 ;
for ( int i = last ; i >= 0 and fib [ i ] * y >= x ; i -- ) { if ( fib [ i ] > x ) continue ; sum += rec ( x - fib [ i ] , y - 1 , i ) ; } return sum ; }
int main ( ) { fibonacci ( ) ; int n = 13 , k = 3 ; cout << " Possible ▁ ways ▁ are : ▁ " << rec ( n , k , 42 ) ; return 0 ; }
int minimumCost ( int cost [ ] , int n ) {
if ( n == 1 ) return cost [ 0 ] ;
dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ;
for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; }
return min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; }
int main ( ) { int a [ ] = { 16 , 19 , 10 , 12 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minimumCost ( a , n ) ; return 0 ; }
int minimumCost ( int cost [ ] , int n ) { int dp1 = 0 , dp2 = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + min ( dp1 , dp2 ) ;
dp2 = dp1 ; dp1 = dp0 ; } return min ( dp1 , dp2 ) ; }
int main ( ) { int a [ ] = { 2 , 5 , 3 , 1 , 7 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << minimumCost ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int editDistanceWith2Ops ( string & X , string & Y ) {
int m = X . length ( ) , n = Y . length ( ) ; int L [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } int lcs = L [ m ] [ n ] ;
return ( m - lcs ) + ( n - lcs ) ; }
int main ( ) { string X = " abc " , Y = " acd " ; cout << editDistanceWith2Ops ( X , Y ) ; return 0 ; }
int lcs ( string X , string Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; }
int main ( ) { string X = " AGGTAB " ; string Y = " GXTXAYB " ;
int m = X . length ( ) ; int n = Y . length ( ) ; cout << " Length ▁ of ▁ LCS : ▁ " << lcs ( X , Y , m , n ) ; return 0 ; }
int countPaths ( int n ) {
int zB = 1 ;
int zADC = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) {
int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ;
zB = nzB ; zADC = nzADC ; }
return zB ; }
int main ( ) { int n = 3 ; cout << countPaths ( n ) ; return 0 ; }
void getMinimumPenalty ( string x , string y , int pxy , int pgap ) {
int dp [ m + 1 ] [ n + 1 ] = { 0 } ;
for ( i = 0 ; i <= ( n + m ) ; i ++ ) { dp [ i ] [ 0 ] = i * pgap ; dp [ 0 ] [ i ] = i * pgap ; }
for ( i = 1 ; i <= m ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = min ( { dp [ i - 1 ] [ j - 1 ] + pxy , dp [ i - 1 ] [ j ] + pgap , dp [ i ] [ j - 1 ] + pgap } ) ; } } }
i = m ; j = n ; int xpos = l ; int ypos = l ;
int xans [ l + 1 ] , yans [ l + 1 ] ; while ( ! ( i == 0 j == 0 ) ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { xans [ xpos -- ] = ( int ) x [ i - 1 ] ; yans [ ypos -- ] = ( int ) y [ j - 1 ] ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j - 1 ] + pxy == dp [ i ] [ j ] ) { xans [ xpos -- ] = ( int ) x [ i - 1 ] ; yans [ ypos -- ] = ( int ) y [ j - 1 ] ; i -- ; j -- ; } else if ( dp [ i - 1 ] [ j ] + pgap == dp [ i ] [ j ] ) { xans [ xpos -- ] = ( int ) x [ i - 1 ] ; yans [ ypos -- ] = ( int ) ' _ ' ; i -- ; } else if ( dp [ i ] [ j - 1 ] + pgap == dp [ i ] [ j ] ) { xans [ xpos -- ] = ( int ) ' _ ' ; yans [ ypos -- ] = ( int ) y [ j - 1 ] ; j -- ; } } while ( xpos > 0 ) { if ( i > 0 ) xans [ xpos -- ] = ( int ) x [ -- i ] ; else xans [ xpos -- ] = ( int ) ' _ ' ; } while ( ypos > 0 ) { if ( j > 0 ) yans [ ypos -- ] = ( int ) y [ -- j ] ; else yans [ ypos -- ] = ( int ) ' _ ' ; }
int id = 1 ; for ( i = l ; i >= 1 ; i -- ) { if ( ( char ) yans [ i ] == ' _ ' && ( char ) xans [ i ] == ' _ ' ) { id = i + 1 ; break ; } }
cout << " Minimum ▁ Penalty ▁ in ▁ aligning ▁ the ▁ genes ▁ = ▁ " ; cout << dp [ m ] [ n ] << " STRNEWLINE " ; cout << " The ▁ aligned ▁ genes ▁ are ▁ : STRNEWLINE " ; for ( i = id ; i <= l ; i ++ ) { cout << ( char ) xans [ i ] ; } cout << " STRNEWLINE " ; for ( i = id ; i <= l ; i ++ ) { cout << ( char ) yans [ i ] ; } return ; }
string gene1 = " AGGGCT " ; string gene2 = " AGGCA " ;
int misMatchPenalty = 3 ; int gapPenalty = 2 ;
getMinimumPenalty ( gene1 , gene2 , misMatchPenalty , gapPenalty ) ; return 0 ; }
int lds ( int arr [ ] , int n ) { int lds [ n ] ; int i , j , max = 0 ;
for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ;
for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ;
for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ;
return max ; }
int main ( ) { int arr [ ] = { 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Length ▁ of ▁ LDS ▁ is ▁ " << lds ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100
void binomialCoeff ( int C [ ] , int n ) {
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } }
int sumOfproduct ( int n ) { int sum = 0 ; int C [ MAX ] = { 0 } ; binomialCoeff ( C , n ) ;
for ( int i = 0 ; i <= n ; i ++ ) sum += C [ i ] * C [ i + 1 ] ; return sum ; }
int main ( ) { int n = 3 ; cout << sumOfproduct ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100
void binomialCoeff ( int n , int C [ ] ) {
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } }
int summation ( int n ) { int C [ MAX ] ; memset ( C , 0 , sizeof ( C ) ) ;
binomialCoeff ( n , C ) ;
int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( i * C [ i ] ) ; return sum ; }
int main ( ) { int n = 2 ; cout << summation ( n ) << endl ; return 0 ; }
int binomialCoeff ( int n , int k ) { int C [ k + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ;
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; }
int countArray ( int N , int K ) { return binomialCoeff ( K - 1 , N - 1 ) ; }
int main ( ) { int N = 2 , K = 3 ; cout << countArray ( N , K ) << endl ; return 0 ; }
int findMaxVal ( int arr [ ] , int n , int num , int maxLimit ) {
int ind ;
int val ;
int dp [ n ] [ maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) {
if ( ind == 0 ) { if ( num - arr [ ind ] == val num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else {
if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) {
dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] || dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } }
for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] ) { return val ; } }
return -1 ; }
int main ( ) { int num = 1 ; int arr [ ] = { 3 , 10 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxLimit = 15 ; cout << findMaxVal ( arr , n , num , maxLimit ) ; return 0 ; }
int gen ( int n ) {
if ( n == 0 ) return 0 ;
else if ( n == 1 ) return 1 ;
else if ( n % 2 == 0 ) return 4 * gen ( n / 2 ) ;
else if ( n % 2 == 1 ) return 4 * gen ( n / 2 ) + 1 ; }
void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << gen ( i ) << " ▁ " ; cout << " STRNEWLINE " ; }
int main ( ) { int n = 15 ; cout << " First ▁ " << n << " ▁ terms ▁ of ▁ " << " Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ STRNEWLINE " ; moserDeBruijn ( n ) ; return 0 ; }
int minSumPath ( vector < vector < int > > & A ) {
int memo [ A . size ( ) ] ; int n = A . size ( ) - 1 ;
for ( int i = 0 ; i < A [ n ] . size ( ) ; i ++ ) memo [ i ] = A [ n ] [ i ] ;
for ( int i = A . size ( ) - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i ] . size ( ) ; j ++ ) memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ;
return memo [ 0 ] ; }
int main ( ) { vector < vector < int > > A { { 2 } , { 3 , 9 } , { 1 , 6 , 7 } } ; cout << minSumPath ( A ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100 NEW_LINE int dp [ MAX ] [ MAX ] ;
int countRemovals ( int a [ ] , int i , int j , int k ) {
if ( i >= j ) return 0 ;
else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ;
else if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ;
else if ( ( a [ j ] - a [ i ] ) > k ) {
dp [ i ] [ j ] = 1 + min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) ; } return dp [ i ] [ j ] ; }
int removals ( int a [ ] , int n , int k ) {
sort ( a , a + n ) ;
memset ( dp , -1 , sizeof ( dp ) ) ; if ( n == 1 ) return 0 ; else return countRemovals ( a , 0 , n - 1 , k ) ; }
int main ( ) { int a [ ] = { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 4 ; cout << removals ( a , n , k ) ; return 0 ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 )
count += 2 ; } return count ; }
int main ( ) { int a [ ] = { 3 , 4 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; return 0 ; }
long long dp [ 1000 ] [ 1000 ] ;
long long sum ( int a [ ] , int i , int j ) { long long ans = 0 ; for ( int m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; } long long solve ( int a [ ] , int i , int j ) {
if ( i == j ) return 0 ;
if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ;
dp [ i ] [ j ] = INT_MAX ;
for ( int k = i ; k < j ; k ++ ) {
dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; }
return dp [ i ] [ j ] ; } void initialize ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = -1 ; }
int main ( ) { int a [ ] = { 40 , 60 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; initialize ( n ) ; cout << solve ( a , 0 , n - 1 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void reverseFibonacci ( int n ) { int a [ n ] ;
a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) {
a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) {
cout << a [ i ] << " ▁ " ; } }
int main ( ) { int n = 5 ; reverseFibonacci ( n ) ; return 0 ; }
float find_prob ( int N , float P ) { double dp [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return dp [ N ] ; }
int main ( ) { int n = 5 ; float p = 0.2 ; cout << find_prob ( n , p ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  5 NEW_LINE using namespace std ;
void printHosoya ( int n ) { int dp [ N ] [ N ] ; memset ( dp , 0 , sizeof ( dp ) ) ;
dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 ;
for ( int i = 2 ; i < n ; i ++ ) {
for ( int j = 0 ; j < n ; j ++ ) {
if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } }
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) cout << dp [ i ] [ j ] << " ▁ " ; cout << endl ; } }
int main ( ) { int n = 5 ; printHosoya ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ;
int numberofways ( int n , int m ) { int dp [ n + 2 ] [ n + 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ; dp [ 0 ] [ n + 1 ] = 1 ;
for ( int k = n ; k >= m ; k -- ) {
for ( int i = 0 ; i <= n ; i ++ ) {
dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ;
if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; }
int main ( ) { int n = 3 , m = 1 ; cout << numberofways ( n , m ) << endl ; return 0 ; }
int zigzag ( int n , int k ) {
if ( n == 0 && k == 0 ) return 1 ;
if ( k == 0 ) return 0 ;
return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; }
int main ( ) { int n = 4 , k = 3 ; cout << zigzag ( n , k ) << endl ; return 0 ; }
int eulerian ( int n , int m ) { int dp [ n + 1 ] [ m + 1 ] ; memset ( dp , 0 , sizeof ( dp ) ) ;
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = 0 ; j <= m ; j ++ ) {
if ( i > j ) {
if ( j == 0 ) dp [ i ] [ j ] = 1 ;
else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; }
int main ( ) { int n = 3 , m = 1 ; cout << eulerian ( n , m ) << endl ; return 0 ; }
int dealnnoy ( int n , int m ) {
if ( m == 0 n == 0 ) return 1 ;
return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; }
int main ( ) { int n = 3 , m = 4 ; cout << dealnnoy ( n , m ) << endl ; return 0 ; }
int dealnnoy ( int n , int m ) { int dp [ m + 1 ] [ n + 1 ] ;
for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( int i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; }
int main ( ) { int n = 3 , m = 4 ; cout << dealnnoy ( n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void longestAlternating ( int arr [ ] , int n ) { int count [ n ] ;
count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; }
for ( int i = 0 ; i < n ; i ++ ) cout << count [ i ] << " ▁ " ; }
int main ( ) { int a [ ] = { -5 , -1 , -1 , 2 , -2 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; longestAlternating ( a , n ) ; return 0 ; }
int maxDP ( int n ) { int res [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ;
for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; }
int main ( ) { int n = 60 ; cout << " MaxSum ▁ = " << maxDP ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; # define R  4 NEW_LINE # define C  3 NEW_LINE bool isSafe ( int x , int y ) { return ( x < R && y < C ) ; }
int minJump ( int height [ R ] [ C ] , int x , int y ) {
if ( x == R - 1 && y == C - 1 ) return 0 ;
int diag = INT_MAX ; if ( isSafe ( x + 1 , y + 1 ) ) diag = minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ;
int down = INT_MAX ; if ( isSafe ( x + 1 , y ) ) down = minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ;
int right = INT_MAX ; if ( isSafe ( x , y + 1 ) ) right = minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ;
return min ( { down , right , diag } ) ; }
int main ( ) { int height [ ] [ C ] = { { 5 , 4 , 2 } , { 9 , 2 , 1 } , { 2 , 5 , 9 } , { 1 , 3 , 11 } } ; cout << minJump ( height , 0 , 0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxSum ( int arr [ ] , int N , int k ) {
MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; }
int main ( ) { int N = 10 , k = 2 ; int arr [ ] = { 50 , 70 , 40 , 50 , 90 , 70 , 60 , 40 , 70 , 50 } ; cout << maxSum ( arr , N , k ) ; return 0 ; }
void alternateSubarray ( bool arr [ ] , int n ) { int len [ n ] ;
len [ n - 1 ] = 1 ;
for ( int i = n - 2 ; i >= 0 ; -- i ) {
if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ;
else len [ i ] = 1 ; }
for ( int i = 0 ; i < n ; ++ i ) cout << len [ i ] << " ▁ " ; }
int main ( ) { bool arr [ ] = { 1 , 0 , 1 , 0 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; alternateSubarray ( arr , n ) ; return 0 ; }
void alternateSubarray ( bool arr [ ] , int n ) {
int count = 1 ;
int prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) {
if ( ( arr [ i ] ^ prev ) == 0 ) {
while ( count ) cout << count -- << " ▁ " ; }
++ count ;
prev = arr [ i ] ; }
while ( count ) cout << count -- << " ▁ " ; }
int main ( ) { bool arr [ ] = { 1 , 0 , 1 , 0 , 0 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; alternateSubarray ( arr , n ) ; return 0 ; }
long countWays ( int n ) { long dp [ 2 ] [ n + 1 ] ;
dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) {
dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ;
dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; }
return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; }
int main ( ) { int n = 5 ; cout << " Total ▁ no ▁ of ▁ ways ▁ with ▁ n ▁ = ▁ " << n << " ▁ are : ▁ " << countWays ( n ) << endl ; }
int maxLenSub ( int arr [ ] , int n ) { int mls [ n ] , max = 0 ;
for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ;
for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ;
for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ;
return max ; }
int main ( ) { int arr [ ] = { 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ length ▁ subsequence ▁ = ▁ " << maxLenSub ( arr , n ) ; return 0 ; }
bool findWinner ( int x , int y , int n ) {
int dp [ n + 1 ] ;
dp [ 0 ] = false ; dp [ 1 ] = true ;
for ( int i = 2 ; i <= n ; i ++ ) {
if ( i - 1 >= 0 and ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 and ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 and ! dp [ i - y ] ) dp [ i ] = true ;
else dp [ i ] = false ; }
return dp [ n ] ; }
int main ( ) { int x = 3 , y = 4 , n = 5 ; if ( findWinner ( x , y , n ) ) cout << ' A ' ; else cout << ' B ' ; return 0 ; }
int maxGameByWinner ( int N ) { int dp [ N ] ;
dp [ 0 ] = 1 ; dp [ 1 ] = 2 ;
int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ;
return ( i - 2 ) ; }
int main ( ) { int N = 10 ; cout << maxGameByWinner ( N ) << endl ; return 0 ; }
int minRemove ( int arr [ ] , int n ) { int LIS [ n ] , len = 0 ;
for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ;
for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) { LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) ; } } len = max ( len , LIS [ i ] ) ; }
return n - len ; }
int main ( ) { int arr [ ] = { 1 , 2 , 6 , 5 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minRemove ( arr , n ) ; return 0 ; }
int maxSum ( int grid [ 2 ] [ MAX ] , int n ) {
int incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ;
int excl = 0 , excl_new ;
for ( int i = 1 ; i < n ; i ++ ) {
excl_new = max ( excl , incl ) ;
incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ;
excl = excl_new ; }
return max ( excl , incl ) ; }
int main ( ) { int grid [ 2 ] [ MAX ] = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 10 } } ; int n = 5 ; cout << maxSum ( grid , n ) ; return 0 ; }
int minInsertionStepToSortArray ( int arr [ ] , int N ) {
int lis [ N ] ;
for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ;
for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ;
int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ;
return ( N - max ) ; }
int main ( ) { int arr [ ] = { 2 , 3 , 5 , 1 , 4 , 7 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minInsertionStepToSortArray ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1005
int shortestSeq ( char * S , char * T ) { int m = strlen ( S ) , n = strlen ( T ) ;
int dp [ m + 1 ] [ n + 1 ] ;
for ( int i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ;
for ( int i = 0 ; i <= n ; i ++ ) dp [ 0 ] [ i ] = MAX ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = S [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) if ( T [ k ] == ch ) break ;
if ( k == -1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) ; } } int ans = dp [ m ] [ n ] ; if ( ans >= MAX ) ans = -1 ; return ans ; }
int main ( ) { char S [ ] = " babab " ; char T [ ] = " babba " ; int m = strlen ( S ) , n = strlen ( T ) ; cout << " Length ▁ of ▁ shortest ▁ subsequence ▁ is ▁ : ▁ " << shortestSeq ( S , T ) << endl ; }
void countWaysToJump ( int arr [ ] , int n ) {
int count_jump [ n ] ; memset ( count_jump , 0 , sizeof ( count_jump ) ) ;
for ( int i = n - 2 ; i >= 0 ; i -- ) {
if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ;
for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ )
if ( count_jump [ j ] != -1 ) count_jump [ i ] += count_jump [ j ] ;
if ( count_jump [ i ] == 0 ) count_jump [ i ] = -1 ; }
for ( int i = 0 ; i < n ; i ++ ) cout << count_jump [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; countWaysToJump ( arr , n ) ; return 0 ; }
int minStepToDeleteString ( string str ) { int N = str . length ( ) ;
int dp [ N + 1 ] [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ;
for ( int len = 1 ; len <= N ; len ++ ) {
for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) {
if ( len == 1 ) dp [ i ] [ j ] = 1 ; else {
dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ;
if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ;
for ( int K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } }
return dp [ 0 ] [ N - 1 ] ; }
int main ( ) { string str = "2553432" ; cout << minStepToDeleteString ( str ) << endl ; return 0 ; }
const int inf = 1000000000 ; int ans = inf ;
void solve ( int i , int par , int a [ ] , int n , int k , int current_ans ) {
if ( par > k ) return ;
if ( par == k && i == n - 1 ) { ans = min ( ans , current_ans ) ; return ; }
for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; }
int main ( ) { int k = 2 ; int a [ ] = { 1 , 5 , 8 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; solve ( -1 , 0 , a , n , k , 0 ) ; cout << ans << endl ; return 0 ; }
int getMinSteps ( int n , int * memo ) {
if ( n == 1 ) return 0 ; if ( memo [ n ] != -1 ) return memo [ n ] ;
int res = getMinSteps ( n - 1 , memo ) ; if ( n % 2 == 0 ) res = min ( res , getMinSteps ( n / 2 , memo ) ) ; if ( n % 3 == 0 ) res = min ( res , getMinSteps ( n / 3 , memo ) ) ;
memo [ n ] = 1 + res ; return memo [ n ] ; }
int getMinSteps ( int n ) { int memo [ n + 1 ] ;
for ( int i = 0 ; i <= n ; i ++ ) memo [ i ] = -1 ; return getMinSteps ( n , memo ) ; }
int main ( ) { int n = 10 ; cout << getMinSteps ( n ) ; return 0 ; }
int stringReduction ( string str ) { int n = str . length ( ) ;
int count [ 3 ] = { 0 } ; for ( int i = 0 ; i < n ; ++ i ) count [ str [ i ] - ' a ' ] ++ ;
if ( count [ 0 ] == n count [ 1 ] == n count [ 2 ] == n ) return n ;
if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) return 2 ;
return 1 ; }
int main ( ) { string str = " abcbbaacb " ; cout << stringReduction ( str ) ; return 0 ; }
int countSubsequences ( string s ) {
int aCount = 0 ;
int bCount = 0 ;
int cCount = 0 ;
for ( unsigned int i = 0 ; i < s . size ( ) ; i ++ ) {
if ( s [ i ] == ' a ' ) aCount = ( 1 + 2 * aCount ) ;
else if ( s [ i ] == ' b ' ) bCount = ( aCount + 2 * bCount ) ;
else if ( s [ i ] == ' c ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; }
int main ( ) { string s = " abbc " ; cout << countSubsequences ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int maxRevenue ( int m , int x [ ] , int revenue [ ] , int n , int t ) {
int maxRev [ m + 1 ] ; memset ( maxRev , 0 , sizeof ( maxRev ) ) ;
int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) {
if ( nxtbb < n ) {
if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ;
else {
if ( i <= t ) maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ;
else maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; }
int main ( ) { int m = 20 ; int x [ ] = { 6 , 7 , 12 , 13 , 14 } ; int revenue [ ] = { 5 , 6 , 5 , 3 , 1 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; int t = 5 ; cout << maxRevenue ( m , x , revenue , n , t ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define Row  6 NEW_LINE #define Col  6 NEW_LINE using namespace std ;
int largestKSubmatrix ( int a [ ] [ Col ] ) { int dp [ Row ] [ Col ] ; memset ( dp , sizeof ( dp ) , 0 ) ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) {
if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else {
if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 ;
else dp [ i ] [ j ] = 1 ; }
result = max ( result , dp [ i ] [ j ] ) ; } } return result ; }
int main ( ) { int a [ Row ] [ Col ] = { 2 , 2 , 3 , 3 , 4 , 4 , 5 , 5 , 7 , 7 , 7 , 4 , 1 , 2 , 7 , 7 , 7 , 4 , 4 , 4 , 7 , 7 , 7 , 4 , 5 , 5 , 5 , 1 , 2 , 7 , 8 , 7 , 9 , 4 , 4 , 4 } ; cout << largestKSubmatrix ( a ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  21 NEW_LINE double fact [ MAX ] ;
double probability ( int k , int n ) { double ans = 0 ; for ( int i = k ; i <= n ; ++ i )
ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) ;
ans = ans / ( 1LL << n ) ; return ans ; } void precompute ( ) {
fact [ 0 ] = fact [ 1 ] = 1 ; for ( int i = 2 ; i < 20 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; }
int main ( ) { precompute ( ) ;
cout << probability ( 2 , 3 ) << " STRNEWLINE " ;
cout << probability ( 3 , 6 ) << " STRNEWLINE " ;
cout << probability ( 12 , 18 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countStrings ( int n , int k ) {
int dp [ n + 1 ] [ k + 1 ] [ 2 ] ; memset ( dp , 0 , sizeof ( dp ) ) ;
dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) {
for ( int j = 0 ; j <= k ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; }
int main ( ) { int n = 5 , k = 2 ; cout << countStrings ( n , k ) ; return 0 ; }
int countFriendsPairings ( int n ) { if ( dp [ n ] != -1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; }
int main ( ) { memset ( dp , -1 , sizeof ( dp ) ) ; int n = 4 ; cout << countFriendsPairings ( n ) << endl ; }
int maxPathSum ( int tri [ ] [ N ] , int m , int n ) {
for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) {
if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } }
return tri [ 0 ] [ 0 ] ; }
int main ( ) { int tri [ N ] [ N ] = { { 1 , 0 , 0 } , { 4 , 8 , 0 } , { 1 , 5 , 3 } } ; cout << maxPathSum ( tri , 2 , 2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string X = " AGGT12" ; string Y = "12TXAYB " ; string Z = "12XBA " ; int dp [ 100 ] [ 100 ] [ 100 ] ;
int lcsOf3 ( int i , int j , int k ) { if ( i == -1 j == -1 k == -1 ) return 0 ; if ( dp [ i ] [ j ] [ k ] != -1 ) return dp [ i ] [ j ] [ k ] ; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; else return dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; }
int main ( ) { memset ( dp , -1 , sizeof ( dp ) ) ; int m = X . length ( ) ; int n = Y . length ( ) ; int o = Z . length ( ) ; cout << " Length ▁ of ▁ LCS ▁ is ▁ " << lcsOf3 ( m - 1 , n - 1 , o - 1 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  4 NEW_LINE #define C  4
int countPaths ( int maze [ ] [ C ] ) {
if ( maze [ 0 ] [ 0 ] == -1 ) return 0 ;
for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ;
else break ; }
for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ;
else break ; }
for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) {
if ( maze [ i ] [ j ] == -1 ) continue ;
if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ;
if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } }
return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; }
int main ( ) { int maze [ R ] [ C ] = { { 0 , 0 , 0 , 0 } , { 0 , -1 , 0 , 0 } , { -1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; cout << countPaths ( maze ) ; return 0 ; }
long long int maxDecimalValue ( int mat [ ] [ N ] , int i , int j , int p ) {
if ( i >= N j >= N ) return 0 ; int result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ;
if ( mat [ i ] [ j ] == 1 ) return pow ( 2 , p ) + result ; else return result ; }
int main ( ) { int mat [ ] [ 4 ] = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; cout << maxDecimalValue ( mat , 0 , 0 , 0 ) << endl ; return 0 ; }
int CountPS ( char str [ ] , int n ) {
int dp [ n ] [ n ] ; memset ( dp , 0 , sizeof ( dp ) ) ;
bool P [ n ] [ n ] ; memset ( P , false , sizeof ( P ) ) ;
for ( int i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ;
for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } }
for ( int gap = 2 ; gap < n ; gap ++ ) {
for ( int i = 0 ; i < n - gap ; i ++ ) {
int j = gap + i ;
if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ;
if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } }
return dp [ 0 ] [ n - 1 ] ; }
int main ( ) { char str [ ] = " abaab " ; int n = strlen ( str ) ; cout << CountPS ( str , n ) << endl ; return 0 ; }
int maxSumWO3Consec ( int arr [ ] , int n ) {
int sum [ n ] ;
if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ;
for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; }
int main ( ) { int arr [ ] = { 100 , 1000 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxSumWO3Consec ( arr , n ) ; return 0 ; }
int maxSumPairWithDifferenceLessThanK ( int arr [ ] , int N , int K ) {
sort ( arr , arr + N ) ;
int dp [ N ] ;
dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) {
dp [ i ] = dp [ i - 1 ] ;
if ( arr [ i ] - arr [ i - 1 ] < K ) {
if ( i >= 2 ) dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } }
return dp [ N - 1 ] ; }
int main ( ) { int arr [ ] = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = sizeof ( arr ) / sizeof ( int ) ; int K = 4 ; cout << maxSumPairWithDifferenceLessThanK ( arr , N , K ) ; return 0 ; }
int lucas ( int n ) {
if ( n == 0 ) return 2 ; if ( n == 1 ) return 1 ;
return lucas ( n - 1 ) + lucas ( n - 2 ) ; }
int main ( ) { int n = 9 ; printf ( " % d " , lucas ( n ) ) ; return 0 ; }
int breakSum ( int n ) {
if ( n == 0 n == 1 ) return n ;
return max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; }
int main ( ) { int n = 12 ; cout << breakSum ( n ) ; return 0 ; }
int countPS ( string str ) { int N = str . length ( ) ;
int cps [ N + 1 ] [ N + 1 ] ; memset ( cps , 0 , sizeof ( cps ) ) ;
for ( int i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ;
for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( str [ i ] == str [ k ] ) cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; else cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } }
return cps [ 0 ] [ N - 1 ] ; }
int main ( ) { string str = " abcb " ; cout << " Total ▁ palindromic ▁ subsequence ▁ are ▁ : ▁ " << countPS ( str ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int n , dp [ 1000 ] [ 1000 ] ; string str = " abcb " ;
int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != -1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; }
int main ( ) { memset ( dp , -1 , sizeof ( dp ) ) ; n = str . size ( ) ; cout << " Total ▁ palindromic ▁ subsequence ▁ are ▁ : ▁ " << countPS ( 0 , n - 1 ) << endl ; return 0 ; }
int minimum ( int a , int b , int c ) { return min ( min ( a , b ) , c ) ; }
int findMinSum ( int arr [ ] , int n ) {
int sum [ n ] ;
sum [ 0 ] = arr [ 0 ] ; sum [ 1 ] = arr [ 1 ] ; sum [ 2 ] = arr [ 2 ] ;
for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ; return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 20 , 2 , 10 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Min ▁ Sum ▁ is ▁ " << findMinSum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define INF  1000000 NEW_LINE using namespace std ;
int MinimumCost ( int cost [ ] , int n , int W ) {
vector < int > val , wt ;
int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != -1 ) { val . push_back ( cost [ i ] ) ; wt . push_back ( i + 1 ) ; size ++ ; } } n = size ; int min_cost [ n + 1 ] [ W + 1 ] ;
for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = INF ;
for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) {
if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ;
else min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } }
return ( min_cost [ n ] [ W ] == INF ) ? -1 : min_cost [ n ] [ W ] ; }
int main ( ) { int cost [ ] = { 1 , 2 , 3 , 4 , 5 } , W = 5 ; int n = sizeof ( cost ) / sizeof ( cost [ 0 ] ) ; cout << MinimumCost ( cost , n , W ) ; return 0 ; }
int count ( string a , string b , int m , int n ) {
if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ;
if ( m == 0 ) return 0 ;
if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else
return count ( a , b , m - 1 , n ) ; }
int main ( ) { string a = " GeeksforGeeks " ; string b = " Gks " ; cout << count ( a , b , a . size ( ) , b . size ( ) ) << endl ; return 0 ; }
int lcs ( char * X , char * Y , int m , int n ) { int L [ m + 1 ] [ n + 1 ] ;
for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } }
return L [ m ] [ n ] ; }
int findMinCost ( char X [ ] , char Y [ ] , int costX , int costY ) {
int m = strlen ( X ) , n = strlen ( Y ) ; int len_LCS = lcs ( X , Y , m , n ) ;
return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ; }
int main ( ) { char X [ ] = " ef " ; char Y [ ] = " gh " ; cout << " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ " << " ▁ identical ▁ is ▁ = ▁ " << findMinCost ( X , Y , 10 , 20 ) ; return 0 ; }
int countIntegralSolutions ( int n ) {
int result = 0 ;
for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; }
int main ( ) { int n = 3 ; cout << countIntegralSolutions ( n ) ; return 0 ; }
int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; }
int main ( ) { int n = 3 ; cout << countIntegralSolutions ( n ) ; return 0 ; }
int maxLeftSubArraySum ( int a [ ] , int size , int sum [ ] ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; sum [ 0 ] = max_so_far ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; sum [ i ] = max_so_far ; } return max_so_far ; }
int maxRightSubArraySum ( int a [ ] , int n , int sum [ ] ) { int max_so_far = a [ n ] ; int curr_max = a [ n ] ; sum [ n ] = max_so_far ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_max = max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = max ( max_so_far , curr_max ) ; sum [ i ] = max_so_far ; } return max_so_far ; }
int findMaxAbsDiff ( int arr [ ] , int n ) {
int leftMax [ n ] ; maxLeftSubArraySum ( arr , n , leftMax ) ;
int rightMax [ n ] ; maxRightSubArraySum ( arr , n - 1 , rightMax ) ;
int invertArr [ n ] ; for ( int i = 0 ; i < n ; i ++ ) invertArr [ i ] = - arr [ i ] ;
int leftMin [ n ] ; maxLeftSubArraySum ( invertArr , n , leftMin ) ; for ( int i = 0 ; i < n ; i ++ ) leftMin [ i ] = - leftMin [ i ] ;
int rightMin [ n ] ; maxRightSubArraySum ( invertArr , n - 1 , rightMin ) ; for ( int i = 0 ; i < n ; i ++ ) rightMin [ i ] = - rightMin [ i ] ; int result = INT_MIN ; for ( int i = 0 ; i < n - 1 ; i ++ ) {
int absValue = max ( abs ( leftMax [ i ] - rightMin [ i + 1 ] ) , abs ( leftMin [ i ] - rightMax [ i + 1 ] ) ) ; if ( absValue > result ) result = absValue ; } return result ; }
int main ( ) { int a [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findMaxAbsDiff ( a , n ) ; return 0 ; }
int countWays ( int p , int q , int r , int last ) {
if ( p < 0 q < 0 r < 0 ) return 0 ;
if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ;
if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ;
if ( last == 0 ) return countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ;
if ( last == 1 ) return countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; if ( last == 2 ) return countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; }
int countUtil ( int p , int q , int r ) {
}
int main ( ) { int p = 1 , q = 1 , r = 1 ; printf ( " % d " , countUtil ( p , q , r ) ) ; return 0 ; }
int countP ( int n , int k ) {
if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ;
return k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ; }
int main ( ) { cout << countP ( 3 , 2 ) ; return 0 ; }
int countP ( int n , int k ) {
int dp [ n + 1 ] [ k + 1 ] ;
for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; }
int main ( ) { cout << countP ( 5 , 2 ) ; return 0 ; }
int printCountRec ( int dist ) {
if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ;
return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; }
int main ( ) { int dist = 4 ; cout << printCountRec ( dist ) ; return 0 ; }
int countNumbersWith4 ( int n ) {
for ( int x = 1 ; x <= n ; x ++ ) result += has4 ( x ) ? 1 : 0 ; return result ; }
bool has4 ( int x ) { while ( x != 0 ) { if ( x % 10 == 4 ) return true ; x = x / 10 ; } return false ; }
int main ( ) { int n = 328 ; cout << " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ a ▁ digit ▁ is ▁ " << countNumbersWith4 ( n ) << endl ; return 0 ; }
int countNumbersWith4 ( int n ) {
if ( n < 4 ) return 0 ;
int d = log10 ( n ) ;
int * a = new int [ d + 1 ] ; a [ 0 ] = 0 , a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ceil ( pow ( 10 , i - 1 ) ) ;
int p = ceil ( pow ( 10 , d ) ) ;
int msd = n / p ;
if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ;
if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ;
return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; }
int main ( ) { int n = 328 ; cout << " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " << n << " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ a ▁ digit ▁ is ▁ " << countNumbersWith4 ( n ) << endl ; return 0 ; }
int minRemovalsDP ( int arr [ ] , int n ) {
int longest_start = -1 , longest_end = 0 ;
for ( int start = 0 ; start < n ; start ++ ) {
int min = INT_MAX , max = INT_MIN ;
for ( int end = start ; end < n ; end ++ ) {
int val = arr [ end ] ; if ( val < min ) min = val ; if ( val > max ) max = val ;
if ( 2 * min <= max ) break ;
if ( end - start > longest_end - longest_start longest_start == -1 ) { longest_start = start ; longest_end = end ; } } }
if ( longest_start == -1 ) return n ;
return ( n - ( longest_end - longest_start + 1 ) ) ; }
int main ( ) { int arr [ ] = { 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minRemovalsDP ( arr , n ) ; return 0 ; }
int optimalStrategyOfGame ( int * arr , int n ) {
int table [ n ] [ n ] ;
for ( int gap = 0 ; gap < n ; ++ gap ) { for ( int i = 0 , j = gap ; j < n ; ++ i , ++ j ) {
int x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; int y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; int z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; }
int main ( ) { int arr1 [ ] = { 8 , 15 , 3 , 7 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; printf ( " % d STRNEWLINE " , optimalStrategyOfGame ( arr1 , n ) ) ; int arr2 [ ] = { 2 , 2 , 2 , 2 } ; n = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; printf ( " % d STRNEWLINE " , optimalStrategyOfGame ( arr2 , n ) ) ; int arr3 [ ] = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = sizeof ( arr3 ) / sizeof ( arr3 [ 0 ] ) ; printf ( " % d STRNEWLINE " , optimalStrategyOfGame ( arr3 , n ) ) ; return 0 ; }
int maxSumIS ( int arr [ ] , int n ) { int i , j , max = 0 ; int msis [ n ] ;
for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ;
for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ;
for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; }
int main ( ) { int arr [ ] = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ " " subsequence ▁ is ▁ " << maxSumIS ( arr , n ) << endl ; return 0 ; }
bool endsWith ( string str , string pat ) { int patLen = pat . length ( ) ; int strLen = str . length ( ) ;
if ( patLen > strLen ) return false ;
patLen -- ; strLen -- ; while ( patLen >= 0 ) {
if ( pat [ patLen ] != str [ strLen ] ) return false ; patLen -- ; strLen -- ; }
return true ; }
int countOfStrings ( string pat , int n , string sArr [ ] ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ )
if ( endsWith ( sArr [ i ] , pat ) ) count ++ ; return count ; }
int main ( ) { string pat = " ks " ; int n = 4 ; string sArr [ ] = { " geeks " , " geeksforgeeks " , " games " , " unit " } ; cout << countOfStrings ( pat , n , sArr ) ; return 0 ; }
int getEndingIndex ( string str , int n , int i ) { i ++ ; while ( i < n ) { char curr = str [ i ] ; char prev = str [ i - 1 ] ;
if ( ( curr == ' a ' && prev == ' z ' ) || ( curr - prev == 1 ) ) i ++ ; else break ; } return i - 1 ; }
int largestSubStr ( string str , int n ) { int len = 0 ; int i = 0 ; while ( i < n ) {
int end = getEndingIndex ( str , n , i ) ;
len = max ( end - i + 1 , len ) ; i = end + 1 ; } return len ; }
int main ( ) { string str = " abcabcdefabc " ; int n = str . length ( ) ; cout << ( largestSubStr ( str , n ) ) ; }
ll getSum ( ll n , int d ) { if ( n < d ) return 0 ;
while ( n % 10 != d ) n -- ; ll k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; }
int main ( ) { ll n = 30 ; int d = 3 ; cout << getSum ( n , d ) ; return 0 ; }
int replace ( string A , string B ) { int n = A . length ( ) , m = B . length ( ) ; int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) {
if ( A [ i + j ] != B [ j ] ) break ; }
if ( j == m ) { count ++ ;
i += m - 1 ; } } return count ; }
int main ( ) { string str1 = " aaaaaaaa " ; string str2 = " aaa " ; cout << replace ( str1 , str2 ) ; return 0 ; }
int isSubstring ( string s1 , string s2 ) { int M = s1 . length ( ) ; int N = s2 . length ( ) ;
for ( int i = 0 ; i <= N - M ; i ++ ) { int j ;
for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return -1 ; }
int main ( ) { string s1 = " for " ; string s2 = " geeksforgeeks " ; int res = isSubstring ( s1 , s2 ) ; if ( res == -1 ) cout << " Not ▁ present " ; else cout << " Present ▁ at ▁ index ▁ " << res ; return 0 ; }
int patternCount ( string str ) {
char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . size ( ) ) {
if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ;
if ( str [ i ] == '1' ) counter ++ ; }
last = str [ i ] ; i ++ ; } return counter ; }
int main ( ) { string str = "1001ab010abc01001" ; cout << patternCount ( str ) << endl ; return 0 ; }
int maxPrefix ( char s [ ] , char t [ ] ) { int count = 0 ;
for ( int i = 0 ; i < strlen ( t ) ; i ++ ) {
if ( count == strlen ( s ) ) break ;
if ( t [ i ] == s [ count ] ) count ++ ; } return count ; }
int main ( ) { char S [ ] = " digger " ; char T [ ] = " biggerdiagram " ; cout << maxPrefix ( S , T ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE void translate ( char * str ) { if ( str [ 0 ] == ' ' ) return ;
for ( int i = 1 ; str [ i ] != ' ' ; i ++ ) {
if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) {
str [ i - 1 ] = ' C ' ; for ( int j = i ; str [ j ] != ' ' ; j ++ ) str [ j ] = str [ j + 1 ] ; } } return ; }
int main ( ) { char str [ ] = " helloABworldABGfG " ; translate ( str ) ; printf ( " The ▁ modified ▁ string ▁ is ▁ : STRNEWLINE " ) ; printf ( " % s " , str ) ; }
void positions ( string str , int n ) { for ( int i = 0 ; i < n ; i ++ ) {
cout << ( str [ i ] & NUM ) << " ▁ " ; } }
int main ( ) { string str = " Geeks " ; int n = str . length ( ) ; positions ( str , n ) ; return 0 ; }
int lenoflongestnonpalindrome ( string s ) {
int max1 = 1 , len = 0 ; for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) {
if ( s [ i ] == s [ i + 1 ] ) len = 0 ;
else if ( s [ i + 1 ] == s [ i - 1 ] && i > 0 ) len = 1 ;
len ++ ;
}
if ( max1 == 1 ) return 0 ; else return max1 ; }
int main ( ) { string s = " synapse " ; cout << lenoflongestnonpalindrome ( s ) << " STRNEWLINE " ; return 0 ; }
string makePalindrome ( string str ) { int i = 0 , j = str . length ( ) - 1 ; while ( i <= j ) {
if ( str [ i ] == ' * ' && str [ j ] == ' * ' ) { str [ i ] = ' a ' ; str [ j ] = ' a ' ; }
else if ( str [ j ] == ' * ' ) str [ j ] = str [ i ] ;
else if ( str [ i ] == ' * ' ) str [ i ] = str [ j ] ;
else if ( str [ i ] != str [ j ] ) return " - 1" ; i ++ ; j -- ; }
return str ; }
int main ( ) { string str = " na * an " ; cout << makePalindrome ( str ) ; return 0 ; }
int calcScore ( string str ) { int score = 0 ; int len = str . length ( ) ;
for ( int i = 0 ; i < len ; ) {
int chunkSize = 1 ;
char currentChar = str [ i ++ ] ;
while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; }
if ( currentChar == '1' ) score += pow ( chunkSize , 2 ) ; else score -= pow ( chunkSize , 2 ) ; }
return score ; }
int main ( ) { string str = "11011" ; cout << calcScore ( str ) ; return 0 ; }
int countSubString ( string s , char c , int k ) {
int leftCount = 0 , rightCount = 0 ;
int left = 0 , right = 0 ;
int freq = 0 ;
int result = 0 , len = s . length ( ) ;
while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; }
right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; }
while ( left < len && ( right - 1 ) < len ) {
while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; }
while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; }
result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ;
freq = k - 1 ;
leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; }
int main ( ) { string s = " abada " ; char c = ' a ' ; int k = 2 ; cout << countSubString ( s , c , k ) << " STRNEWLINE " ; return 0 ; }
bool isValid ( string str , int n ) {
if ( ! ( ( str [ 0 ] >= ' a ' && str [ 0 ] <= ' z ' ) || ( str [ 0 ] >= ' A ' && str [ 0 ] <= ' Z ' ) str [ 0 ] == ' _ ' ) ) return false ;
for ( int i = 1 ; i < str . length ( ) ; i ++ ) { if ( ! ( ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) || ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= '0' && str [ i ] <= '9' ) str [ i ] == ' _ ' ) ) return false ; }
return true ; }
int main ( ) { string str = " _ geeks123" ; int n = str . length ( ) ; if ( isValid ( str , n ) ) cout << " Valid " ; else cout << " Invalid " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string FirstAndLast ( string str ) {
string ch = str ; for ( int i = 0 ; i < ch . length ( ) ; i ++ ) {
int k = i ; while ( i < ch . length ( ) && ch [ i ] != ' ▁ ' ) i ++ ;
ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return ch ; }
int main ( ) { string str = " Geeks ▁ for ▁ Geeks " ; cout << str << " STRNEWLINE " ; cout << FirstAndLast ( str ) ; }
int findM ( string s , int x ) {
int cnt = 0 ;
for ( int i = 0 ; i < s . size ( ) ; i ++ ) {
if ( s [ i ] - '0' != x ) cnt ++ ; } return cnt ; }
int main ( ) { string s = "3662123" ; int x = 6 ; cout << findM ( s , x ) ; return 0 ; }
vector < int > compute_lps ( string s ) { int n = s . size ( ) ;
vector < int > lps ( n ) ;
int len = 0 ;
lps [ 0 ] = 0 ; int i = 1 ;
while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; }
else { if ( len != 0 ) len = lps [ len - 1 ] ;
else { lps [ i ] = 0 ; i ++ ; } } } return lps ; }
void Longestsubstring ( string s ) {
vector < int > lps = compute_lps ( s ) ; int n = s . size ( ) ;
if ( lps [ n - 1 ] == 0 ) { cout << -1 ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) {
if ( lps [ i ] == lps [ n - 1 ] ) { cout << s . substr ( 0 , lps [ i ] ) ; return ; } }
if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) cout << -1 ; else cout << s . substr ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ; }
int main ( ) { string s = " fixprefixsuffix " ;
Longestsubstring ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  64
int getBitmask ( string s ) { int temp = 0 ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) { if ( s [ j ] == ' s ' ) { temp = temp | ( 1 ) ; } else if ( s [ j ] == ' t ' ) { temp = temp | ( 2 ) ; } else if ( s [ j ] == ' r ' ) { temp = temp | ( 4 ) ; } else if ( s [ j ] == ' i ' ) { temp = temp | ( 8 ) ; } else if ( s [ j ] == ' n ' ) { temp = temp | ( 16 ) ; } else if ( s [ j ] == ' g ' ) { temp = temp | ( 32 ) ; } } return temp ; }
int countPairs ( string arr [ ] , int n ) {
int bitMask [ MAX ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) bitMask [ getBitmask ( arr [ i ] ) ] ++ ;
int cnt = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i ; j < MAX ; j ++ ) {
if ( ( i j ) == ( MAX - 1 ) ) {
if ( i == j ) cnt += ( ( bitMask [ i ] * bitMask [ i ] - 1 ) / 2 ) ; else cnt += ( bitMask [ i ] * bitMask [ j ] ) ; } } } return cnt ; }
int main ( ) { string arr [ ] = { " strrr " , " string " , " gstrin " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) ; return 0 ; }
int countOcc ( string s ) {
int cnt = 0 ;
for ( int i = 0 ; i < s . length ( ) - 3 ; i ++ ) {
int c = 0 , l = 0 , a = 0 , p = 0 ;
for ( int j = i ; j < i + 4 ; j ++ ) { switch ( s [ j ] ) { case ' c ' : c ++ ; break ; case ' l ' : l ++ ; break ; case ' a ' : a ++ ; break ; case ' p ' : p ++ ; break ; } }
if ( c == 1 && l == 1 && a == 1 && p == 1 ) cnt ++ ; } return cnt ; }
int main ( ) { string s = " clapc " ; transform ( s . begin ( ) , s . end ( ) , s . begin ( ) , :: tolower ) ; cout << ( countOcc ( s ) ) ; }
int calculateWays ( string s , int n , int l , int r ) {
int freq [ 26 ] ; memset ( freq , 0 , sizeof freq ) ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( i < l i > r ) freq [ s [ i ] - ' a ' ] ++ ; }
int ways = 1 ;
for ( int i = l ; i <= r ; i ++ ) {
if ( freq [ s [ i ] - ' a ' ] ) { ways = ways * freq [ s [ i ] - ' a ' ] ; freq [ s [ i ] - ' a ' ] -- ; }
else { ways = 0 ; break ; } }
return ways ; }
int main ( ) { string s = " cabcaab " ; int n = s . length ( ) ; int l = 1 , r = 3 ; cout << calculateWays ( s , n , l , r ) ; return 0 ; }
void asciiToSentence ( string str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) {
num = num * 10 + ( str [ i ] - '0' ) ;
if ( num >= 32 && num <= 122 ) {
char ch = ( char ) num ; cout << ch ;
num = 0 ; } } }
int main ( ) { string str = "7110110110711510211111471101101107115" ; int len = str . length ( ) ; asciiToSentence ( str , len ) ; return 0 ; }
const int arr [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 } ;
int countKeyPressed ( string str , int len ) { int count = 0 ;
for ( int i = 0 ; i < len ; i ++ ) count = count + arr [ str [ i ] - ' a ' ] ;
return count ; }
int main ( ) { string str = " abcdef " ; int len = str . length ( ) ; cout << countKeyPressed ( str , len ) ; return 0 ; }
bool isReverseEqual ( string s1 , string s2 ) {
if ( s1 . length ( ) != s2 . length ( ) ) return false ; int len = s1 . length ( ) ; for ( int i = 0 ; i < len ; i ++ )
if ( s1 [ i ] != s2 [ len - i - 1 ] ) return false ; return true ; }
string getWord ( string str [ ] , int n ) {
for ( int i = 0 ; i < n - 1 ; i ++ )
for ( int j = i + 1 ; j < n ; j ++ )
if ( isReverseEqual ( str [ i ] , str [ j ] ) ) return str [ i ] ;
return " - 1" ; }
int main ( ) { string str [ ] = { " geeks " , " for " , " skeeg " } ; cout << ( getWord ( str , 3 ) ) ; }
bool isPrefix ( string str , int len , int i , int k ) {
if ( i + k > len ) return false ; for ( int j = 0 ; j < k ; j ++ ) {
if ( str [ i ] != str [ j ] ) return false ; i ++ ; } return true ; }
bool isKPeriodic ( string str , int len , int k ) {
for ( int i = k ; i < len ; i += k ) if ( ! isPrefix ( str , len , i , k ) ) return false ; return true ; }
int main ( ) { string str = " geeksgeeks " ; int len = str . length ( ) ; int k = 5 ; if ( isKPeriodic ( str , len , k ) ) cout << ( " Yes " ) ; else cout << ( " No " ) ; }
int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; }
int main ( ) { int n = 52 ; cout << minLettersNeeded ( n ) ; return 0 ; }
int minReplacement ( string s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) {
if ( i % 2 == 0 && s [ i ] == '1' ) ans ++ ;
if ( i % 2 == 1 && s [ i ] == '0' ) ans ++ ; } return min ( ans , len - ans ) ; }
int main ( ) { string s = "1100" ; int len = s . size ( ) ; cout << minReplacement ( s , len ) ; return 0 ; }
string groupCharacters ( string s , int len ) {
string temp = " " ;
for ( int i = 0 ; i < len ; i ++ ) if ( s [ i ] != ' ▁ ' ) temp = temp + s [ i ] ; len = temp . length ( ) ;
string ans = " " ; int i = 0 ;
while ( i < len ) {
if ( int ( temp [ i ] ) >= int ( ' A ' ) && int ( temp [ i ] ) <= int ( ' Z ' ) ) { while ( i < len && int ( temp [ i ] ) >= int ( ' A ' ) && int ( temp [ i ] ) <= int ( ' Z ' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " ▁ " ; }
else if ( int ( temp [ i ] ) >= int ( '0' ) && int ( temp [ i ] ) <= int ( '9' ) ) { while ( i < len && int ( temp [ i ] ) >= int ( '0' ) && int ( temp [ i ] ) <= int ( '9' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " ▁ " ; }
else { while ( i < len && int ( temp [ i ] ) >= int ( ' * ' ) && int ( temp [ i ] ) <= int ( ' / ' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " ▁ " ; } }
return ans ; }
int main ( ) { string s = "34FTG234 + ▁ + - ▁ * " ; int len = s . length ( ) ; cout << groupCharacters ( s , len ) ; return 0 ; }
int Preprocess ( string A , string B ) {
int n = A . size ( ) ;
int ans = 0 ;
for ( int i = 0 ; i < n / 2 ; i ++ ) {
map < char , int > mp ; mp [ A [ i ] ] ++ ; mp [ A [ n - i - 1 ] ] ++ ; mp [ B [ i ] ] ++ ; mp [ B [ n - i - 1 ] ] ++ ; int sz = mp . size ( ) ;
if ( sz == 4 ) ans += 2 ;
else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ) ;
else if ( sz == 2 ) ans += mp [ A [ i ] ] != 2 ; }
if ( n % 2 == 1 && A [ n / 2 ] != B [ n / 2 ] ) ans ++ ; return ans ; }
int main ( ) { string A = " abacaba " , B = " bacabaa " ; cout << Preprocess ( A , B ) ; return 0 ; }
string leastLexiString ( string s ) {
if ( s . size ( ) & 1 ) return s ;
string x = leastLexiString ( s . substr ( 0 , s . size ( ) / 2 ) ) ; string y = leastLexiString ( s . substr ( s . size ( ) / 2 ) ) ;
return min ( x + y , y + x ) ; } bool areEquivalent ( string a , string b ) { return ( leastLexiString ( a ) == leastLexiString ( b ) ) ; }
int main ( ) { string a = " aaba " ; string b = " abaa " ; if ( areEquivalent ( a , b ) ) cout << " YES " << endl ; else cout << " NO " << endl ; a = " aabb " ; b = " abab " ; if ( areEquivalent ( a , b ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
void generateString ( int A , int B ) { string rt ; while ( 0 < A 0 < B ) {
if ( A < B ) { if ( 0 < B -- ) rt . push_back ( ' b ' ) ; if ( 0 < B -- ) rt . push_back ( ' b ' ) ; if ( 0 < A -- ) rt . push_back ( ' a ' ) ; }
else if ( B < A ) { if ( 0 < A -- ) rt . push_back ( ' a ' ) ; if ( 0 < A -- ) rt . push_back ( ' a ' ) ; if ( 0 < B -- ) rt . push_back ( ' b ' ) ; }
else { if ( 0 < A -- ) rt . push_back ( ' a ' ) ; if ( 0 < B -- ) rt . push_back ( ' b ' ) ; } } cout << rt ; }
int main ( ) { int A = 2 , B = 6 ; generateString ( A , B ) ; return 0 ; }
string getSubSeq ( string s , int n ) { string res = " " ; int cr = 0 ; while ( cr < n ) {
char mx = s [ cr ] ; for ( int i = cr + 1 ; i < n ; i ++ ) mx = max ( mx , s [ i ] ) ; int lst = cr ;
for ( int i = cr ; i < n ; i ++ ) if ( s [ i ] == mx ) { res += s [ i ] ; lst = i ; }
cr = lst + 1 ; } return res ; }
int main ( ) { string s = " geeksforgeeks " ; int n = s . length ( ) ; cout << getSubSeq ( s , n ) ; }
int countSubStr ( string str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ;
for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] - '0' ) ;
if ( n % k == 0 ) count ++ ; } }
return count ; }
int main ( ) { string str = "33445" ; int len = str . length ( ) ; int k = 11 ; cout << countSubStr ( str , len , k ) ; return 0 ; }
char Colour_Combination ( string s ) { char temp = s [ 0 ] ; for ( int i = 1 ; i < s . length ( ) ; i ++ ) { if ( temp != s [ i ] ) {
if ( ( temp == ' B ' temp == ' G ' ) && ( s [ i ] == ' G ' s [ i ] == ' B ' ) ) temp = ' Y ' ;
else if ( ( temp == ' B ' temp == ' Y ' ) && ( s [ i ] == ' Y ' s [ i ] == ' B ' ) ) temp = ' G ' ;
else temp = ' B ' ; } } return temp ; }
int main ( int argc , char * * argv ) { string s = " GBYGB " ; cout << Colour_Combination ( s ) ; }
void reverse ( string str , int x ) {
int n = ( str . length ( ) - x ) / 2 ;
for ( int i = 0 ; i < n ; i ++ ) cout << str [ i ] ;
for ( int i = n + x - 1 ; i >= n ; i -- ) cout << str [ i ] ;
for ( int i = n + x ; i < str . length ( ) ; i ++ ) cout << str [ i ] ; }
int main ( ) { string str = " geeksforgeeks " ; int x = 3 ; reverse ( str , x ) ; return 0 ; }
string lexoSmallest ( string s , int n ) {
int ca = 0 , cb = 0 , cc = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' ) ca ++ ; else if ( s [ i ] == ' b ' ) cb ++ ; else cc ++ ; }
if ( ca == cb && cb == cc ) { return s ; } int cnt = n / 3 ;
if ( cnt * 3 != n ) { return " - 1" ; } int i = 0 ;
while ( ca < cnt && i < n ) {
if ( s [ i ] == ' b ' && cb > cnt ) { cb -- ; s [ i ] = ' a ' ; ca ++ ; }
else if ( s [ i ] == ' c ' && cc > cnt ) { cc -- ; s [ i ] = ' a ' ; ca ++ ; } i ++ ; } i = 0 ;
while ( cb < cnt && i < n ) {
if ( s [ i ] == ' c ' && cc > cnt ) { cc -- ; s [ i ] = '1' ; cb ++ ; } i ++ ; } i = n - 1 ;
while ( cc < cnt && i >= 0 ) {
if ( s [ i ] == ' a ' && ca > cnt ) { ca -- ; s [ i ] = ' c ' ; cc ++ ; } i -- ; } i = n - 1 ;
while ( cb < cnt && i >= 0 ) {
if ( s [ i ] == ' a ' && ca > cnt ) { ca -- ; s [ i ] = ' b ' ; cb ++ ; } i -- ; } i = n - 1 ;
while ( cc < cnt && i >= 0 ) {
if ( s [ i ] == ' b ' && cb > cnt ) { cb -- ; s [ i ] = ' c ' ; cc ++ ; } i -- ; } return s ; }
int main ( ) { string s = " aaaaaa " ; int n = s . size ( ) ; cout << lexoSmallest ( s , n ) ; return 0 ; }
int getSteps ( string str , int i , int j , int n ) {
int k = i + 1 ;
int steps = 0 ;
char ch = str [ i ] ; while ( k <= j ) {
if ( str [ k ] != ch ) {
steps ++ ;
ch = str [ k ] ; } k ++ ; }
return steps ; }
int getMinSteps ( string str , int i , int j , int n ) {
if ( j < i ) { int temp = i ; i = j ; j = temp ; }
int stepsToRight = getSteps ( str , i , j , n ) ;
int stepsToLeft = getSteps ( str , 0 , i , n ) + getSteps ( str , j , n - 1 , n ) ;
if ( str [ 0 ] != str [ n - 1 ] ) stepsToLeft ++ ;
return min ( stepsToLeft , stepsToRight ) ; }
int main ( ) { string str = " SSNSS " ; int n = str . length ( ) ; int i = 0 , j = 3 ; cout << getMinSteps ( str , i , j , n ) ; return 0 ; }
string removeChars ( string s ) { string modifiedStr = " " ; modifiedStr += s [ 0 ] ;
for ( int i = 1 ; i < s . length ( ) ; i ++ ) {
if ( isupper ( s [ i ] ) && islower ( s [ i - 1 ] ) || islower ( s [ i ] ) && isupper ( s [ i - 1 ] ) ) modifiedStr += s [ i ] ; } return modifiedStr ; }
int main ( ) { string s = " GeeksForGeeks " ; cout << removeChars ( s ) ; return 0 ; }
int pangramCost ( int arr [ ] , string str ) { int cost = 0 ; bool occurred [ 26 ] = { false } ;
for ( int i = 0 ; i < str . size ( ) ; i ++ ) occurred [ str [ i ] - ' a ' ] = true ;
for ( int i = 0 ; i < 26 ; i ++ ) { if ( ! occurred [ i ] ) cost += arr [ i ] ; } return cost ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 } ; string str = " abcdefghijklmopqrstuvwz " ; cout << pangramCost ( arr , str ) ; return 0 ; }
void pairStar ( string & input , string & output , int i = 0 ) {
output = output + input [ i ] ;
if ( i == input . length ( ) - 1 ) return ;
if ( input [ i ] == input [ i + 1 ] ) output = output + ' * ' ; pairStar ( input , output , i + 1 ) ; }
int main ( ) { string input = " geeks " , output = " " ; pairStar ( input , output ) ; cout << output << endl ; return 0 ; }
int maxOperations ( string str ) { int i , g , gk , gks ; i = g = gk = gks = 0 ; for ( i = 0 ; i < str . length ( ) ; i ++ ) { if ( str [ i ] == ' g ' ) {
g ++ ; } else if ( str [ i ] == ' k ' ) {
if ( g > 0 ) { g -- ; gk ++ ; } } else if ( str [ i ] == ' s ' ) {
if ( gk > 0 ) { gk -- ; gks ++ ; } } }
return gks ; }
int main ( ) { string a = " ggkssk " ; cout << maxOperations ( a ) ; return 0 ; }
string printFinalString ( string s ) { int i , n ; n = s . length ( ) ; int x = 0 , y = 0 ; for ( i = 0 ; i < n ; i ++ ) {
if ( s [ i ] == ' x ' ) x ++ ;
else y ++ ; } string finalString = " " ;
if ( x > y ) for ( i = 0 ; i < x - y ; i ++ ) finalString += " x " ; else for ( i = 0 ; i < y - x ; i ++ ) finalString += " y " ; return finalString ; }
int main ( ) { string s = " xxyyxyy " ; cout << printFinalString ( s ) ; }
string K_String ( string s , int k ) {
int n = s . size ( ) ;
int fre [ 26 ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - ' a ' ] ++ ;
string str = " " ; for ( int i = 0 ; i < 26 ; i ++ ) {
if ( fre [ i ] % k == 0 ) { int x = fre [ i ] / k ;
while ( x -- ) { str += ( char ) ( i + ' a ' ) ; } }
else { return " - 1" ; } } return str ; }
int main ( ) { string s = " aabb " ; int k = 2 ;
cout << K_String ( s , k ) ; return 0 ; }
int CountCharacters ( string str , int l , int r ) {
int cnt = 0 ;
unordered_map < char , int > m ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) {
if ( ! ( l <= str [ i ] and str [ i ] <= r ) ) { cnt ++ ; if ( m [ str [ i ] ] != 1 ) { cout << str [ i ] << " ▁ " ; m [ str [ i ] ] ++ ; } } }
return cnt ; }
int main ( ) { string str = " geeksforgeeks " ; int l = 102 , r = 111 ; cout << " Characters ▁ with ▁ ASCII ▁ values " " ▁ not ▁ in ▁ the ▁ range ▁ [ l , ▁ r ] ▁ STRNEWLINE in ▁ the ▁ given ▁ string ▁ are : ▁ " ; cout << " and their count is " << CountCharacters ( str , l , r ) ; return 0 ; }
void CountWords ( string str , int k ) {
int sum = 0 ; int NumberOfWords = 0 ;
int counter = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) {
if ( str [ i ] == ' ▁ ' ) { if ( sum < k ) counter ++ ; sum = 0 ; NumberOfWords ++ ; } else
sum += str [ i ] ; }
NumberOfWords ++ ; if ( sum < k ) counter ++ ; cout << " Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ ASCII " " ▁ values ▁ less ▁ than ▁ k ▁ = ▁ " << counter << endl ; cout << " Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ ASCII ▁ values " " ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ k ▁ = ▁ " << NumberOfWords - counter ; }
int main ( ) { string str = " Learn ▁ how ▁ to ▁ code " ; int k = 400 ; CountWords ( str , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ;
int countPalindrome ( string str ) { int n = str . size ( ) ; int sum = 0 ;
int hashTable [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hashTable [ str [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < 26 ; i ++ ) { if ( hashTable [ i ] ) sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) / 2 ) ; }
return sum ; }
int main ( ) { string str = " ananananddd " ; cout << countPalindrome ( str ) ; return 0 ; }
int countConsecutive ( string s ) {
int count = 0 ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) {
if ( s [ i ] == s [ i + 1 ] ) i ++ ; else count ++ ; } return count ; }
int main ( ) { string str = "44522255" ; cout << countConsecutive ( str ) ; return 0 ; }
int check_digits ( int n ) {
while ( n ) {
return 0 ; n /= 10 ; }
return 1 ; }
int smallest_number ( int n ) {
for ( int i = n ; ; i ++ ) if ( check_digits ( i ) ) return i ; }
int main ( ) { int N = 2397 ; cout << smallest_number ( N ) ; return 0 ; }
int CountCharacters ( string str , int l , int r ) {
int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) {
if ( l <= str [ i ] and str [ i ] <= r ) { cnt ++ ; cout << str [ i ] << " ▁ " ; } }
return cnt ; }
int main ( ) { string str = " geeksforgeeks " ; int l = 102 , r = 111 ; cout << " Characters ▁ with ▁ ASCII ▁ values " " ▁ in ▁ the ▁ range ▁ [ l , ▁ r ] ▁ are ▁ STRNEWLINE " ; cout << " and their count is " << CountCharacters ( str , l , r ) ; return 0 ; }
int minSteps ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) - 2 ; i ++ ) { if ( str [ i ] == '0' ) { if ( str [ i + 1 ] == '1' ) { if ( str [ i + 2 ] == '0' ) {
count ++ ; i += 2 ; } } } } return count ; }
string str = "0101010" ;
cout << minSteps ( str ) ; return 0 ; }
int CountCharacters ( string str , int k ) {
int cnt = 0 ; int len = str . length ( ) ; for ( int i = 0 ; i < len ; i ++ ) {
if ( str [ i ] < k ) cnt ++ ; }
return cnt ; }
int main ( ) { string str = " GeeksForGeeks " ; int k = 90 ; int count = CountCharacters ( str , k ) ; cout << " Characters ▁ with ▁ ASCII ▁ values " " ▁ less ▁ than ▁ K ▁ are ▁ " << count ; cout << " Characters with ASCII values " STRNEWLINE " greater than or equal to K are " << str . length ( ) - count ; return 0 ; }
int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { f = f * i ; } return f ; }
int npr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; }
int countPermutations ( string str ) {
int even = floor ( str . length ( ) / 2 ) ;
int odd = str . length ( ) - even ; int ways = 0 ;
int freq [ 26 ] = { 0 } ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { ++ freq [ str [ i ] - ' a ' ] ; }
int nvowels = freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ;
int nconsonants = str . length ( ) - nvowels ;
ways = npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ; return ways ; }
int main ( ) { string str = " geeks " ; cout << countPermutations ( str ) ; return 0 ; }
bool isVowel ( char ch ) { if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' ) return false ; return true ; }
string replaceConsonants ( string s ) {
for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! isVowel ( s [ i ] ) ) {
if ( s [ i ] == ' z ' ) s [ i ] = ' b ' ;
else {
s [ i ] = ( char ) ( s [ i ] + 1 ) ;
if ( isVowel ( s [ i ] ) ) s [ i ] = ( char ) ( s [ i ] + 1 ) ; } } } return s ; }
int main ( ) { string s = " geeksforgeeks " ; cout << replaceConsonants ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOnOff ( string n ) {
int Led [ ] = { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 } ; int len = n . length ( ) ;
int sum = Led [ n [ 0 ] - '0' ] ; for ( int i = 1 ; i < len ; i ++ ) { sum = sum + abs ( Led [ n [ i ] - '0' ] - Led [ n [ i - 1 ] - '0' ] ) ; } return sum ; }
int main ( ) { string n = "082" ; cout << countOnOff ( n ) ; return 0 ; }
int max_length_substring ( string st , int n , int k ) {
int max_len = 0 ; int len = 0 ; for ( int i = 0 ; i < n ; ++ i ) {
if ( st [ i ] == '0' ) len ++ ; else len = 0 ;
max_len = max ( max_len , len ) ; }
if ( max_len == n ) return n * k ; int pref = 0 , suff = 0 ;
for ( int i = 0 ; st [ i ] == '0' ; ++ i , ++ pref ) ;
for ( int i = n - 1 ; st [ i ] == '0' ; -- i , ++ suff ) ;
if ( k > 1 ) max_len = max ( max_len , pref + suff ) ; return max_len ; }
int main ( ) { int n = 6 ; int k = 3 ; string st = "110010" ; int ans = max_length_substring ( st , n , k ) ; cout << ans ; }
int count ( string S , int X ) { int count = 0 ; const int N = S . length ( ) ; for ( int i = 0 ; i < N ; ++ i ) {
if ( S [ i ] != '0' ) { for ( int len = 1 ; ( i + len ) <= N ; ++ len ) {
if ( stoi ( S . substr ( i , len ) ) > X ) count ++ ; } } } return count ; }
int main ( ) { string S = "2222" ; int X = 97 ; cout << count ( S , X ) ; return 0 ; }
bool isBinary ( int n ) { while ( n != 0 ) { int temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = n / 10 ; } return true ; }
void formBinaryStr ( int n , int a [ ] ) { bool flag = true ;
string s = " " ; for ( int i = 0 ; i < n ; i ++ ) {
if ( isBinary ( a [ i ] ) )
s += to_string ( a [ i ] ) ; else {
flag = false ; break ; } }
if ( flag ) cout << s << " STRNEWLINE " ;
else cout < < " - 1 STRNEWLINE " ; }
int main ( ) { int a [ ] = { 10 , 1 , 0 , 11 , 10 } ; int N = sizeof ( a ) / sizeof ( a [ 0 ] ) ; formBinaryStr ( N , a ) ; return 0 ; }
bool checkPalindrome ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s [ i ] != s [ s . length ( ) - i - 1 ] ) return false ; } return true ; }
bool CheckOdd ( string s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) {
string x = " " ; for ( int j = i ; j < n ; j ++ ) { x += s [ j ] ;
if ( x . length ( ) % 2 == 0 && checkPalindrome ( x ) == true ) return false ; } } return true ; }
int main ( ) { string s = " geeksforgeeks " ; if ( CheckOdd ( s ) ) cout << ( " YES " ) ; else cout << ( " NO " ) ; }
long long int fact ( int n ) { long long result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result *= i ; return result ; }
int getResult ( string str , char ch ) {
int has [ 26 ] = { 0 } ;
for ( int i = 0 ; i < str . length ( ) ; i ++ ) has [ str [ i ] - ' A ' ] ++ ;
int particular = has [ ch - ' A ' ] ;
if ( particular == 0 ) return 0 ;
has [ ch - ' A ' ] = 0 ;
int total = str . length ( ) ;
total = total - particular + 1 ;
long long int result = fact ( total ) ;
for ( int i = 0 ; i < 26 ; i ++ ) { if ( has [ i ] > 1 ) { result = result / fact ( has [ i ] ) ; } }
return result ; }
int main ( ) { string str = " MISSISSIPPI " ;
cout << getResult ( str , ' S ' ) << endl ; return 0 ; }
ll factorial ( ll n ) { ll res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) res = res * i ; return res ; }
ll count ( string word ) {
ll freq [ 27 ] = { 0 } ; ll vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < word . length ( ) ; i ++ ) { freq [ word [ i ] - ' A ' ] ++ ;
if ( word [ i ] == ' A ' word [ i ] == ' E ' word [ i ] == ' I ' word [ i ] == ' O ' word [ i ] == ' U ' ) { vowel ++ ; }
else consonant ++ ; }
ll vowelArrange ; vowelArrange = factorial ( vowel ) ; vowelArrange /= factorial ( freq [ 0 ] ) ; vowelArrange /= factorial ( freq [ 4 ] ) ; vowelArrange /= factorial ( freq [ 8 ] ) ; vowelArrange /= factorial ( freq [ 14 ] ) ; vowelArrange /= factorial ( freq [ 20 ] ) ; ll consonantArrange ; consonantArrange = factorial ( consonant ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 ) consonantArrange /= factorial ( freq [ i ] ) ; }
ll total = vowelArrange * consonantArrange ; return total ; }
string word = " COMPUTER " ;
ll ans = count ( word ) ; cout << ans << endl ; return 0 ; }
long long productAscii ( string str ) { long long prod = 1 ;
for ( int i = 0 ; i < str . length ( ) ; i ++ ) { prod *= ( int ) str [ i ] ; }
return prod ; }
int main ( ) { string str = " GfG " ; cout << productAscii ( str ) ; return 0 ; }
void balancedString ( string str ) { int count = 0 , i ; int n = str . length ( ) ;
for ( i = 0 ; i < n ; i ++ ) {
if ( str [ i ] == ' ( ' ) {
cout << str [ i ] ; count ++ ; }
else if ( str [ i ] == ' ) ' && count != 0 ) { cout << str [ i ] ;
count -- ; }
else if ( str [ i ] != ' ) ' ) cout << str [ i ] ; }
if ( count != 0 )
for ( i = 0 ; i < count ; i ++ ) cout << " ) " ; }
int main ( ) { string str = " gau ) ra ) v ( ku ( mar ( rajput ) ) " ; balancedString ( str ) ; return 0 ; }
int countStrings ( string s ) {
long sum = 1 ;
for ( int i = 0 ; i < s . size ( ) ; i ++ ) {
if ( i % 2 == 0 && s [ i ] == ' $ ' )
sum *= 21 ;
else if ( s [ i ] == ' $ ' )
sum *= 5 ; } return sum ; }
string str = " s $ $ e $ " ;
cout << countStrings ( str ) << endl ; return 0 ; }
string removeDuplicatesFromString ( string str ) {
int counter = 0 ; int i = 0 ; int size = str . size ( ) ;
int x ;
int length = 0 ; while ( i < size ) { x = str [ i ] - 97 ;
if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = ' a ' + x ;
counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return str . substr ( 0 , length ) ; }
int main ( ) { string str = " geeksforgeeks " ; cout << removeDuplicatesFromString ( str ) ; return 0 ; }
int firstPos ( string str , int start , int end ) { int firstChar = -1 ;
for ( int i = start ; i <= end ; i ++ ) { if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { firstChar = i ; break ; } } return firstChar ; }
int lastPos ( string str , int start , int end ) { int lastChar = -1 ;
for ( int i = start ; i >= end ; i -- ) { if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { lastChar = i ; break ; } } return lastChar ; }
bool isPalindrome ( string str ) { int firstChar = 0 , lastChar = str . length ( ) - 1 ; bool ch = true ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { firstChar = firstPos ( str , firstChar , lastChar ) ; lastChar = lastPos ( str , lastChar , firstChar ) ;
if ( lastChar < 0 firstChar < 0 ) break ; if ( str [ firstChar ] == str [ lastChar ] ) { firstChar ++ ; lastChar -- ; continue ; }
ch = false ; break ; } return ( ch ) ; }
int main ( ) { string str = " ma ▁ 343 ▁ la ▁ y ▁ a ▁ l ▁ am " ; if ( isPalindrome ( str ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int powerOfJump ( string s ) {
int count = 1 ; int max_so_far = INT_MIN ;
char ch = s [ s . length ( ) - 1 ] ;
for ( int i = 0 ; i < s . length ( ) ; i ++ ) {
if ( s [ i ] == ch ) {
if ( count > max_so_far ) { max_so_far = count ; }
count = 1 ; }
else count ++ ; }
return max_so_far ; }
int main ( ) { string st = "1010101" ; cout << powerOfJump ( st ) ; }
int averageValue ( string s ) { int sum_char = 0 ;
for ( int i = 0 ; i < s . length ( ) ; i ++ ) { sum_char += ( int ) s [ i ] ; }
return sum_char / s . length ( ) ; }
int main ( ) { string s = " GeeksforGeeks " ; cout << averageValue ( s ) ; return 0 ; }
string commonPrefixUtil ( string str1 , string str2 ) { string result ; int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;
for ( int i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 [ i ] != str2 [ j ] ) break ; result . push_back ( str1 [ i ] ) ; } return ( result ) ; }
void commonPrefix ( string arr [ ] , int n ) {
sort ( arr , arr + n ) ;
cout << commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ; }
int main ( ) { string arr [ ] = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; commonPrefix ( arr , n ) ; return 0 ; }
string addBinaryUtil ( string a , string b ) {
string result = " " ;
int s = 0 ;
int i = a . size ( ) - 1 , j = b . size ( ) - 1 ; while ( i >= 0 j >= 0 s == 1 ) {
s += ( ( i >= 0 ) ? a [ i ] - '0' : 0 ) ; s += ( ( j >= 0 ) ? b [ j ] - '0' : 0 ) ;
result = char ( s % 2 + '0' ) + result ;
s /= 2 ;
i -- ; j -- ; } return result ; }
string addBinary ( string arr [ ] , int n ) { string result = " " ; for ( int i = 0 ; i < n ; i ++ ) result = addBinaryUtil ( result , arr [ i ] ) ; return result ; }
int main ( ) { string arr [ ] = { "1" , "10" , "11" } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << addBinary ( arr , n ) << endl ; return 0 ; }
int prefix ( string k , int n ) { int a = 0 , b = 0 , count = 0 ; int i = 0 ; int len = k . size ( ) ;
for ( i = 0 ; i < len ; i ++ ) { if ( k [ i ] == ' a ' ) a ++ ; if ( k [ i ] == ' b ' ) b ++ ; if ( a > b ) { count ++ ; } }
if ( count == 0 n == 1 ) { cout << count << endl ; return 0 ; }
if ( count == len a - b == 0 ) { cout << count * n << endl ; return 0 ; } int n2 = n - 1 , count2 = 0 ;
while ( n2 != 0 ) { for ( i = 0 ; i < len ; i ++ ) { if ( k [ i ] == ' a ' ) a ++ ; if ( k [ i ] == ' b ' ) b ++ ; if ( a > b ) { count2 ++ ; } } count += count2 ; n2 -- ; if ( count2 == 0 ) break ; if ( count2 == len ) { count += ( n2 * count2 ) ; break ; } count2 = 0 ; } return count ; }
int main ( ) { string S = " aba " ; int N = 2 ; cout << prefix ( S , N ) << endl ; S = " baa " ; N = 3 ; cout << prefix ( S , N ) << endl ; return 0 ; }
bool isCommonBase ( string base , string s1 , string s2 ) {
for ( int j = 0 ; j < s1 . length ( ) ; ++ j ) if ( base [ j % base . length ( ) ] != s1 [ j ] ) return false ;
for ( int j = 0 ; j < s2 . length ( ) ; ++ j ) if ( base [ j % base . length ( ) ] != s2 [ j ] ) return false ; return true ; } int countCommonBases ( string s1 , string s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; int count = 0 ; for ( int i = 1 ; i <= min ( n1 , n2 ) ; i ++ ) { string base = s1 . substr ( 0 , i ) ; if ( isCommonBase ( base , s1 , s2 ) ) count ++ ; } return count ; }
int main ( ) { string s1 = " pqrspqrs " ; string s2 = " pqrspqrspqrspqrs " ; cout << countCommonBases ( s1 , s2 ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPerfectSquareString ( string str ) { int sum = 0 ;
int len = str . length ( ) ;
for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] ;
long double squareRoot = sqrt ( sum ) ;
return ( ( squareRoot - floor ( squareRoot ) ) == 0 ) ; }
int main ( ) { string str = " d " ; if ( isPerfectSquareString ( str ) ) cout << " Yes " ; else cout << " No " ; }
bool is_vow ( char c ) {
return ( c == ' a ' ) || ( c == ' e ' ) || ( c == ' i ' ) || ( c == ' o ' ) || ( c == ' u ' ) ; }
void removeVowels ( string str ) {
printf ( " % c " , str [ 0 ] ) ;
for ( int i = 1 ; str [ i ] ; i ++ )
if ( ( ! is_vow ( str [ i - 1 ] ) ) || ( ! is_vow ( str [ i ] ) ) ) printf ( " % c " , str [ i ] ) ; }
int main ( ) { char str [ ] = " ▁ geeks ▁ for ▁ geeks " ; removeVowels ( str ) ; }
bool transformString ( string & s ) {
char ch = ' a ' ;
if ( s . size ( ) < 26 ) return false ; for ( int i = 0 ; i < s . size ( ) ; i ++ ) {
if ( int ( ch ) > int ( ' z ' ) ) break ;
if ( s [ i ] <= ch ) { s [ i ] = ch ; ch = char ( int ( ch ) + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; }
int main ( ) { string str = " aaaaaaaaaaaaaaaaaaaaaaaaaa " ; if ( transformString ( str ) ) cout << str << endl ; else cout << " Not ▁ Possible " << endl ; return 0 ; }
bool isPanDigital ( string s ) { bool digits [ 10 ] = { false } ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) digits [ s [ i ] - '0' ] = true ;
for ( int i = 0 ; i <= 9 ; i ++ ) if ( digits [ i ] == false ) return false ; return true ; }
int countPandigitalPairs ( vector < string > & v ) {
int pairs = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) for ( int j = i + 1 ; j < v . size ( ) ; j ++ ) if ( isPanDigital ( v [ i ] + v [ j ] ) ) pairs ++ ; return pairs ; }
int main ( ) { vector < string > v = { "123567" , "098234" , "14765" , "19804" } ; cout << countPandigitalPairs ( v ) << endl ; return 0 ; }
int minChanges ( string & str ) { int n = str . length ( ) ;
if ( n > MAX_CHAR ) return -1 ;
int dist_count = 0 ;
int count [ MAX_CHAR ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ str [ i ] - ' a ' ] == 0 ) dist_count ++ ; count [ ( str [ i ] - ' a ' ) ] ++ ; }
return ( n - dist_count ) ; }
int main ( ) { string str = " aebaecedabbee " ; cout << minChanges ( str ) ; return 0 ; }
int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) ; }
int main ( ) { int n = 2 , m = 3 ; cout << numofstring ( n , m ) << endl ; return 0 ; }
int CountSpecialPalindrome ( string str ) { int n = str . length ( ) ;
int result = 0 ;
int sameChar [ n ] = { 0 } ; int i = 0 ;
while ( i < n ) {
int sameCharCount = 1 ; int j = i + 1 ;
while ( str [ i ] == str [ j ] && j < n ) sameCharCount ++ , j ++ ;
result += ( sameCharCount * ( sameCharCount + 1 ) / 2 ) ;
sameChar [ i ] = sameCharCount ;
i = j ; }
for ( int j = 1 ; j < n ; j ++ ) {
if ( str [ j ] == str [ j - 1 ] ) sameChar [ j ] = sameChar [ j - 1 ] ;
if ( j > 0 && j < ( n - 1 ) && ( str [ j - 1 ] == str [ j + 1 ] && str [ j ] != str [ j - 1 ] ) ) result += min ( sameChar [ j - 1 ] , sameChar [ j + 1 ] ) ; }
return result - n ; }
int main ( ) { string str = " abccba " ; cout << CountSpecialPalindrome ( str ) << endl ; return 0 ; }
void printBracketNumber ( string exp , int n ) {
int left_bnum = 1 ;
stack < int > right_bnum ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( exp [ i ] == ' ( ' ) {
cout << left_bnum << " ▁ " ;
right_bnum . push ( left_bnum ) ;
left_bnum ++ ; }
else if ( exp [ i ] == ' ) ' ) {
cout << right_bnum . top ( ) << " ▁ " ;
right_bnum . pop ( ) ; } } }
int main ( ) { string exp = " ( a + ( b * c ) ) + ( d / e ) " ; int n = exp . size ( ) ; printBracketNumber ( exp , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isCornerPresent ( string str , string corner ) { int n = str . length ( ) ; int cl = corner . length ( ) ;
if ( n < cl ) return false ;
return ( str . substr ( 0 , cl ) . compare ( corner ) == 0 && str . substr ( n - cl , cl ) . compare ( corner ) == 0 ) ; }
int main ( ) { string str = " geeksforgeeks " ; string corner = " geeks " ; if ( isCornerPresent ( str , corner ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool isConvertible ( string str1 , string str2 , int k ) {
if ( ( str1 . length ( ) + str2 . length ( ) ) < k ) return true ;
int commonLength = 0 ; for ( int i = 0 ; i < min ( str1 . length ( ) , str2 . length ( ) ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; }
if ( ( k - str1 . length ( ) - str2 . length ( ) + 2 * commonLength ) % 2 == 0 ) return true ;
return false ; }
int main ( ) { string str1 = " geek " , str2 = " geek " ; int k = 7 ; if ( isConvertible ( str1 , str2 , k ) ) cout << " Yes " ; else cout << " No " ; str1 = " geeks " , str2 = " geek " ; k = 5 ; cout << endl ; if ( isConvertible ( str1 , str2 , k ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_CHAR  26
int maxLower ( string str ) { int n = str . length ( ) ;
int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { i ++ ; break ; } }
int maxCount = 0 ; int count [ MAX_CHAR ] = { 0 } ; for ( ; i < n ; i ++ ) {
if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) {
int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) if ( count [ j ] > 0 ) currCount ++ ;
maxCount = max ( maxCount , currCount ) ;
memset ( count , 0 , sizeof ( count ) ) ; }
if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) count [ str [ i ] - ' a ' ] ++ ; } return maxCount ; }
int main ( ) { string str = " zACaAbbaazzC " ; cout << maxLower ( str ) ; return 0 ; }
char first ( string str ) { for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( isupper ( str [ i ] ) ) return str [ i ] ; return 0 ; }
int main ( ) { string str = " geeksforGeeKS " ; char res = first ( str ) ; if ( res == 0 ) cout << " No ▁ uppercase ▁ letter " ; else cout << res << " STRNEWLINE " ; return 0 ; }
int evenDecimalValue ( string str , int n ) {
int result = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ;
for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - '0' ) * powerOf2 ) ;
powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; }
int main ( ) { string str = "10010" ; int n = 5 ; cout << evenDecimalValue ( str , n ) << endl ; return 0 ; }
void solve ( string s ) { int l = s . length ( ) ; int x = l / 2 ; int y = l ;
string p = " " ; while ( x > 0 && y > l / 2 ) {
p += s [ x - 1 ] ; x -- ;
p += s [ y - 1 ] ; y -- ; } if ( y > l / 2 ) { p += s [ y - 1 ] ; y -- ; } cout << p ; }
int main ( ) { string s = " sunshine " ;
solve ( s ) ; return 0 ; }
int recLen ( char * str ) {
if ( * str == ' \0' ) return 0 ; else return 1 + recLen ( str + 1 ) ; }
int main ( ) { char str [ ] = " GeeksforGeeks " ; cout << recLen ( str ) ; return 0 ; }
bool isConsonant ( char ch ) {
ch = toupper ( ch ) ; return ! ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) && ch >= 65 && ch <= 90 ; } int totalConsonants ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ )
if ( isConsonant ( str [ i ] ) ) ++ count ; return count ; }
int main ( ) { string str = " abc ▁ de " ; cout << totalConsonants ( str ) ; return 0 ; }
unsigned int reverseBits ( unsigned int n ) { unsigned int rev = 0 ;
while ( n > 0 ) {
rev <<= 1 ;
if ( n & 1 == 1 ) rev ^= 1 ;
n >>= 1 ; }
return rev ; }
bool isPalindrome ( unsigned int n ) {
unsigned int rev = reverseBits ( n ) ; return ( n == rev ) ; }
int main ( ) { unsigned int n = 9 ; if ( isPalindrome ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
void solve ( int n , int t , string s ) {
for ( int i = 0 ; i < t ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ )
if ( s [ j ] == ' B ' && s [ j + 1 ] == ' G ' ) { char temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j ++ ; } cout << s ; }
int main ( ) { int n = 6 , t = 2 ; string s = " BBGBBG " ; solve ( n , t , s ) ; return 0 ; }
int calSumUtil ( int a [ ] , int b [ ] , int n , int m ) {
int sum [ n ] ; int i = n - 1 , j = m - 1 , k = n - 1 ; int carry = 0 , s = 0 ;
while ( j >= 0 ) {
s = a [ i ] + b [ j ] + carry ; sum [ k ] = ( s % 10 ) ;
carry = s / 10 ; k -- ; i -- ; j -- ; }
while ( i >= 0 ) {
s = a [ i ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; i -- ; k -- ; } int ans = 0 ;
if ( carry ) ans = 10 ;
for ( int i = 0 ; i <= n - 1 ; i ++ ) { ans += sum [ i ] ; ans *= 10 ; } return ans / 10 ; }
int calSum ( int a [ ] , int b [ ] , int n , int m ) {
if ( n >= m ) return calSumUtil ( a , b , n , m ) ; else return calSumUtil ( b , a , m , n ) ; }
int main ( ) { int a [ ] = { 9 , 3 , 9 } ; int b [ ] = { 6 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << calSum ( a , b , n , m ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define SIZE  26
int longCommomAnagramSubseq ( char str1 [ ] , char str2 [ ] , int n1 , int n2 ) {
int freq1 [ SIZE ] , freq2 [ SIZE ] ; memset ( freq1 , 0 , sizeof ( freq1 ) ) ; memset ( freq2 , 0 , sizeof ( freq2 ) ) ; int len = 0 ;
for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < SIZE ; i ++ ) len += min ( freq1 [ i ] , freq2 [ i ] ) ;
return len ; }
int main ( ) { char str1 [ ] = " abdacp " ; char str2 [ ] = " ckamb " ; int n1 = strlen ( str1 ) ; int n2 = strlen ( str2 ) ; cout << " Length ▁ = ▁ " << longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) ; return 0 ; }
bool isPanalphabeticWindow ( char s [ ] , int n ) { char ch = ' a ' ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( s [ i ] == ch ) ch ++ ;
if ( ch == ' z ' + 1 ) return true ; } return false ; }
int main ( ) { char s [ ] = " abujm ▁ zvcd ▁ acefc ▁ deghf ▁ gijkle " " ▁ m ▁ n ▁ o ▁ p ▁ pafqrstuvwxyzfap " ; int n = strlen ( s ) ; ( isPanalphabeticWindow ( s , n ) ) ? ( cout << " YES " ) : ( cout << " NO " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) {
if ( n <= 1 ) return false ;
for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; }
void prime_index ( string input ) { int n = input . length ( ) ;
for ( int i = 2 ; i <= n ; i ++ ) if ( isPrime ( i ) ) cout << input [ i - 1 ] ; }
int main ( ) { string input = " GeeksforGeeks " ; prime_index ( input ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isHeterogram ( char s [ ] , int n ) { int hash [ 26 ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( s [ i ] != ' ▁ ' ) {
if ( hash [ s [ i ] - ' a ' ] == 0 ) hash [ s [ i ] - ' a ' ] = 1 ;
else return false ; } } return true ; }
int main ( ) { char s [ ] = " the ▁ big ▁ dwarf ▁ only ▁ jumps " ; int n = strlen ( s ) ; ( isHeterogram ( s , n ) ) ? ( cout << " YES " ) : ( cout << " NO " ) ; return 0 ; }
void ASCIISentence ( std :: string str ) { int l = str . length ( ) ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str [ i ] - NULL ; cout << convert ; } }
int main ( ) { string str = " GeeksforGeeks " ; cout << " ASCII ▁ Sentence : " << std :: endl ; ASCIISentence ( str ) ; return 0 ; }
void convert ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) {
if ( str . at ( i ) == ' ▁ ' ) str . at ( i ) = ' _ ' ; else
str . at ( i ) = tolower ( str . at ( i ) ) ; } cout << str ; }
int main ( ) { string str = " I ▁ got ▁ intern ▁ at ▁ geeksforgeeks " ;
convert ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string replace ( string s , char c1 , char c2 ) { int l = s . length ( ) ;
for ( int i = 0 ; i < l ; i ++ ) {
if ( s [ i ] == c1 ) s [ i ] = c2 ;
else if ( s [ i ] == c2 ) s [ i ] = c1 ; } return s ; }
int main ( ) { string s = " grrksfoegrrks " ; char c1 = ' e ' , c2 = ' r ' ; cout << replace ( s , c1 , c2 ) ; return 0 ; }
string constructPalin ( string str , int len ) { int i = 0 , j = len - 1 ;
for ( ; i < j ; i ++ , j -- ) {
if ( str [ i ] == str [ j ] && str [ i ] != ' * ' ) continue ;
else if ( str [ i ] == str [ j ] && str [ i ] == ' * ' ) { str [ i ] = ' a ' ; str [ j ] = ' a ' ; continue ; }
else if ( str [ i ] == ' * ' ) { str [ i ] = str [ j ] ; continue ; }
else if ( str [ j ] == ' * ' ) { str [ j ] = str [ i ] ; continue ; }
cout << " Not ▁ Possible " ; return " " ; } return str ; }
int main ( ) { string str = " bca * xc * * b " ; int len = str . size ( ) ; cout << constructPalin ( str , len ) ; return 0 ; }
void carveCross ( string str ) { int n = str . length ( ) ; if ( n % 2 == 0 ) {
cout << " Not ▁ possible . ▁ Please ▁ enter ▁ " << " odd ▁ length ▁ string . STRNEWLINE " ; } else {
char arr [ max ] [ max ] ; int m = n / 2 ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = ' X ' ; } }
for ( int i = 0 ; i < n ; i ++ ) {
arr [ i ] [ m ] = str [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) {
arr [ m ] [ i ] = str [ i ] ; }
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { cout << arr [ i ] [ j ] << " ▁ " ; } cout << " STRNEWLINE " ; } } }
int main ( ) { string str = " PICTURE " ; carveCross ( str ) ; return 0 ; }
int remainder ( string str ) {
int len = str . length ( ) ; int num , rem = 0 ;
for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; }
int main ( ) { string str = "3435346456547566345436457867978" ; cout << remainder ( str ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE using namespace std ; void findPermutations ( char str [ ] , int index , int n ) { if ( index >= n || ( index + 1 ) >= n ) { cout << str << endl ; return ; }
findPermutations ( str , index + 1 , n ) ;
swap ( str [ index ] , str [ index + 1 ] ) ; findPermutations ( str , index + 2 , n ) ; swap ( str [ index ] , str [ index + 1 ] ) ; }
int main ( ) { char str [ ] = { "12345" } ; int n = strlen ( str ) ; findPermutations ( str , 0 , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isUnique ( int a [ ] , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ;
return ( sum == k ) ; }
int main ( ) { int a [ ] = { 3 , 3 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 12 ; if ( isUnique ( a , n , k ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool isPalindrome ( string & s , int i , int j ) { int p = j ; for ( int k = i ; k <= p ; k ++ ) { if ( s [ k ] != s [ p ] ) return false ; p -- ; } return true ; } int countWays ( string & s ) {
int n = s . length ( ) ; int count = 0 ;
if ( isPalindrome ( s , 0 , n - 1 ) ) {
for ( int i = n / 2 ; i < n ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) count ++ ; else break ; }
{ count ++ ;
} else
} else { for ( int i = 0 ; i < n / 2 ; i ++ ) {
if ( s [ i ] != s [ n - 1 - i ] ) { int j = n - 1 - i ;
if ( isPalindrome ( s , i , n - 2 - i ) ) { for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( s [ k ] != s [ j ] ) break ; count ++ ; } count ++ ; }
if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) { for ( int k = n - i ; k < n ; k ++ ) { if ( s [ k ] != s [ i ] ) break ; count ++ ; } count ++ ; } break ; } } } return count ; }
int main ( ) { string s = " abca " ; cout << countWays ( s ) << endl ; return 0 ; }
int countOfSubstringWithKOnes ( string s , int K ) { int N = s . length ( ) ; int res = 0 ; int countOfOne = 0 ; int freq [ N + 1 ] = { 0 } ;
freq [ 0 ] = 1 ;
for ( int i = 0 ; i < N ; i ++ ) {
countOfOne += ( s [ i ] - '0' ) ;
if ( countOfOne >= K ) {
res += freq [ countOfOne - K ] ; }
freq [ countOfOne ] ++ ; } return res ; }
int main ( ) { string s = "10010" ; int K = 1 ; cout << countOfSubstringWithKOnes ( s , K ) << endl ; return 0 ; }
void reverse ( char num [ ] , int i , int j ) { while ( i < j ) { swap ( num [ i ] , num [ j ] ) ; i ++ ; j -- ; } }
void nextPalin ( char num [ ] , int n ) {
if ( n <= 3 ) { cout << " Not ▁ Possible " ; return ; }
int mid = n / 2 - 1 ; int i , j ;
for ( i = mid - 1 ; i >= 0 ; i -- ) if ( num [ i ] < num [ i + 1 ] ) break ;
if ( i < 0 ) { cout << " Not ▁ Possible " ; return ; }
int smallest = i + 1 ; for ( j = i + 2 ; j <= mid ; j ++ ) if ( num [ j ] > num [ i ] && num [ j ] <= num [ smallest ] ) smallest = j ;
swap ( num [ i ] , num [ smallest ] ) ;
swap ( num [ n - i - 1 ] , num [ n - smallest - 1 ] ) ;
reverse ( num , i + 1 , mid ) ;
if ( n % 2 == 0 ) reverse ( num , mid + 1 , n - i - 2 ) ;
else reverse ( num , mid + 2 , n - i - 2 ) ;
cout << " Next ▁ Palindrome : ▁ " << num ; }
int main ( ) { char num [ ] = "4697557964" ; int n = strlen ( num ) ; nextPalin ( num , n ) ; return 0 ; }
void printRec ( string number , int extraOnes , int remainingPlaces ) {
if ( 0 == remainingPlaces ) { cout << number << " ▁ " ; return ; }
printRec ( number + "1" , extraOnes + 1 , remainingPlaces - 1 ) ;
if ( 0 < extraOnes ) printRec ( number + "0" , extraOnes - 1 , remainingPlaces - 1 ) ; } void printNums ( int n ) { string str = " " ; printRec ( str , 0 , n ) ; }
int main ( ) { int n = 4 ;
printNums ( n ) ; return 0 ; }
string findstem ( vector < string > arr ) {
int n = arr . size ( ) ;
string s = arr [ 0 ] ; int len = s . length ( ) ; string res = " " ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j <= len ; j ++ ) {
string stem = s . substr ( i , j ) ; int k = 1 ; for ( k = 1 ; k < n ; k ++ ) {
if ( arr [ k ] . find ( stem ) == std :: string :: npos ) break ; }
if ( k == n && res . length ( ) < stem . length ( ) ) res = stem ; } } return res ; }
int main ( ) { vector < string > arr { " grace " , " graceful " , " disgraceful " , " gracefully " } ;
string stems = findstem ( arr ) ; cout << stems << endl ; }
string nxtHighUsingAtMostOneSwap ( string num ) { int l = num . size ( ) ;
int posRMax = l - 1 ;
int index = -1 ;
for ( int i = l - 2 ; i >= 0 ; i -- ) { if ( num [ i ] >= num [ posRMax ] ) posRMax = i ;
else { index = i ; break ; } }
if ( index == -1 ) return " Not ▁ Possible " ;
int greatSmallDgt = -1 ;
for ( int i = l - 1 ; i > index ; i -- ) { if ( num [ i ] > num [ index ] ) { if ( greatSmallDgt == -1 ) greatSmallDgt = i ; else if ( num [ i ] <= num [ greatSmallDgt ] ) greatSmallDgt = i ; } }
char temp = num [ index ] ; num [ index ] = num [ greatSmallDgt ] ; num [ greatSmallDgt ] = temp ;
return num ; }
int main ( ) { string num = "218765" ; cout << " Original ▁ number : ▁ " << num << endl ; cout << " Next ▁ higher ▁ number : ▁ " << nxtHighUsingAtMostOneSwap ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } int longestVowel ( string s ) { int count = 0 , res = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) {
if ( isVowel ( s [ i ] ) ) count ++ ; else {
res = max ( res , count ) ; count = 0 ; } } return max ( res , count ) ; }
int main ( ) { string s = " theeare " ; cout << longestVowel ( s ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ;
bool check ( int freq [ ] , int k ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] && freq [ i ] != k ) return false ; return true ; }
int substrings ( string s , int k ) {
for ( int i = 0 ; s [ i ] ; i ++ ) {
int freq [ MAX_CHAR ] = { 0 } ;
for ( int j = i ; s [ j ] ; j ++ ) {
int index = s [ j ] - ' a ' ; freq [ index ] ++ ;
if ( freq [ index ] > k ) break ;
else if ( freq [ index ] == k && check ( freq , k ) == true ) res ++ ; } } return res ; }
int main ( ) { string s = " aabbcc " ; int k = 2 ; cout << substrings ( s , k ) << endl ; s = " aabbc " ; k = 2 ; cout << substrings ( s , k ) << endl ; }
int countSubstrs ( string str , int i , int j , int n ) {
if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; }
int main ( ) { string str = " abcab " ; int n = str . length ( ) ; cout << countSubstrs ( str , 0 , n - 1 , n ) ; }
int countManipulations ( string s1 , string s2 ) { int count = 0 ;
int char_count [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { char_count [ i ] = 0 ; }
for ( int i = 0 ; i < s1 . length ( ) ; i ++ ) char_count [ s1 [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < s2 . length ( ) ; i ++ ) { char_count [ s2 [ i ] - ' a ' ] -- ; } for ( int i = 0 ; i < 26 ; ++ i ) { if ( char_count [ i ] != 0 ) { count += abs ( char_count [ i ] ) ; } } return count / 2 ; }
int main ( ) { string s1 = " ddcf " ; string s2 = " cedk " ; cout << countManipulations ( s1 , s2 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ;
char stringPalindrome ( string A , string B ) {
int countA [ MAX_CHAR ] = { 0 } ; int countB [ MAX_CHAR ] = { 0 } ; int l1 = A . length ( ) , l2 = B . length ( ) ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B [ i ] - ' a ' ] ++ ;
for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' A ' ; return ' B ' ; }
int main ( ) { string a = " abcdea " ; string b = " bcdesg " ; cout << stringPalindrome ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 256 ;
int countBalance ( char * str ) {
int leftVisited [ MAX_CHAR ] = { 0 } ; int rightVisited [ MAX_CHAR ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) rightVisited [ str [ i ] ] ++ ;
int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
leftVisited [ str [ i ] ] ++ ; rightVisited [ str [ i ] ] -- ;
int j ; for ( j = 0 ; j < MAX_CHAR ; j ++ ) {
if ( ( leftVisited [ j ] == 0 && rightVisited [ j ] != 0 ) || ( leftVisited [ j ] != 0 && rightVisited [ j ] == 0 ) ) break ; }
if ( j == MAX_CHAR ) res ++ ; } return res ; }
int main ( ) { char str [ ] = " abaababa " ; cout << countBalance ( str ) ; return 0 ; }
int findFlips ( char str [ ] , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( last != str [ i ] ) res ++ ; last = str [ i ] ; }
return res / 2 ; }
int main ( ) { char str [ ] = "00011110001110" ; int n = strlen ( str ) ; cout << findFlips ( str , n ) ; return 0 ; }
int findLen ( string & A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ;
while ( r < n ) {
if ( A [ r ] != ch ) ++ cnt ;
while ( cnt > k ) { if ( A [ l ] != ch ) -- cnt ; ++ l ; }
maxlen = max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; }
int answer ( string & A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = max ( maxlen , findLen ( A , n , k , i + ' A ' ) ) ; maxlen = max ( maxlen , findLen ( A , n , k , i + ' a ' ) ) ; } return maxlen ; }
int main ( ) { int n = 5 , k = 2 ; string A = " ABABA " ; cout << " Maximum ▁ length ▁ = ▁ " << answer ( A , n , k ) << endl ; n = 6 , k = 4 ; string B = " HHHHHH " ; cout << " Maximum ▁ length ▁ = ▁ " << answer ( B , n , k ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ;
bool checkCorrectOrNot ( string s ) {
int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ;
int n = s . length ( ) ; if ( n == 1 ) return true ;
for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) {
count1 [ s [ i ] - ' a ' ] ++ ;
count2 [ s [ j ] - ' a ' ] ++ ; }
for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; }
string s = " abab " ; if ( checkCorrectOrNot ( s ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
string maximumNum ( string curr_num , string res ) { int len1 = curr_num . length ( ) ; int len2 = res . length ( ) ;
if ( len1 == len2 ) {
int i = 0 ; while ( curr_num [ i ] == res [ i ] ) i ++ ;
if ( curr_num [ i ] < res [ i ] ) return res ; else return curr_num ; }
return len1 < len2 ? res : curr_num ; }
string extractMaximum ( string str ) { int n = str . length ( ) ; string curr_num = " " ; string res ;
for ( int i = 0 ; i < n ; i ++ ) {
while ( i < n && str [ i ] == '0' ) i ++ ;
while ( i < n && str [ i ] >= '0' && str [ i ] <= '9' ) { curr_num = curr_num + str [ i ] ; i ++ ; } if ( i == n ) break ; if ( curr_num . size ( ) > 0 ) i -- ;
res = maximumNum ( curr_num , res ) ; curr_num = " " ; }
if ( curr_num . size ( ) == 0 && res . size ( ) == 0 ) res = res + '0' ;
return maximumNum ( curr_num , res ) ; }
int main ( ) { string str = "100klh564abc365bg " ; cout << extractMaximum ( str ) << endl ; return 0 ; }
bool isDivisible999 ( string num ) { int n = num . length ( ) ; if ( n == 0 && num [ 0 ] == '0' ) return true ;
if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ;
int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
int group = 0 ; group += ( num [ i ++ ] - '0' ) * 100 ; group += ( num [ i ++ ] - '0' ) * 10 ; group += num [ i ] - '0' ; gSum += group ; }
if ( gSum > 1000 ) { num = to_string ( gSum ) ; n = num . length ( ) ; gSum = isDivisible999 ( num ) ; } return ( gSum == 999 ) ; }
int main ( ) { string num = "1998" ; int n = num . length ( ) ; if ( isDivisible999 ( num ) ) cout << " Divisible " ; else cout << " Not ▁ divisible " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ;
string arrangeString ( string str ) { int char_count [ MAX_CHAR ] = { 0 } ; int sum = 0 ;
for ( int i = 0 ; i < str . length ( ) ; i ++ ) {
if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) char_count [ str [ i ] - ' A ' ] ++ ;
else sum = sum + ( str [ i ] - '0' ) ; } string res = " " ;
for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( ' A ' + i ) ;
while ( char_count [ i ] -- ) res = res + ch ; }
if ( sum > 0 ) res = res + to_string ( sum ) ;
return res ; }
int main ( ) { string str = " ACCBA10D2EW30" ; cout << arrangeString ( str ) ; return 0 ; }
void subString ( char str [ ] , int n ) {
for ( int len = 1 ; len <= n ; len ++ ) {
for ( int i = 0 ; i <= n - len ; i ++ ) {
int j = i + len - 1 ; for ( int k = i ; k <= j ; k ++ ) cout << str [ k ] ; cout << endl ; } } }
int main ( ) { char str [ ] = " abc " ; subString ( str , strlen ( str ) ) ; return 0 ; }
bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; }
int countVowels ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ )
++ count ; return count ; }
string str = " abc ▁ de " ;
cout << countVowels ( str ) << endl ; return 0 ; }
void printRotatedString ( char str [ ] ) { int len = strlen ( str ) ;
char temp [ len ] ; for ( int i = 0 ; i < len ; i ++ ) {
int j = i ;
int k = 0 ;
while ( str [ j ] != ' \0' ) { temp [ k ] = str [ j ] ; k ++ ; j ++ ; }
j = 0 ; while ( j < i ) { temp [ k ] = str [ j ] ; j ++ ; k ++ ; } printf ( " % s STRNEWLINE " , temp ) ; } }
int main ( ) { char str [ ] = " geeks " ; printRotatedString ( str ) ; return 0 ; }
bool isPalindrome ( string str ) {
int n = str . size ( ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) if ( str . at ( i ) != str . at ( n - i - 1 ) ) return false ;
return true ; }
int maxLengthNonPalinSubstring ( string str ) { int n = str . size ( ) ; char ch = str . at ( 0 ) ;
int i = 1 ; for ( i = 1 ; i < n ; i ++ ) if ( str . at ( i ) != ch ) break ;
if ( i == n ) return 0 ;
if ( isPalindrome ( str ) ) return n - 1 ;
return n ; }
int main ( ) { string str = " abba " ; cout << " Maximum ▁ length ▁ = ▁ " << maxLengthNonPalinSubstring ( str ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void isKthBitSet ( int n , int k ) { if ( ( n >> ( k - 1 ) ) & 1 ) cout << " SET " ; else cout << " NOT ▁ SET " ; }
int main ( ) { int n = 5 , k = 1 ; isKthBitSet ( n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const char MAX_CHAR = 26 ;
void countFreq ( string str , int freq [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) freq [ str . at ( i ) - ' a ' ] ++ ; }
bool canMakePalindrome ( int freq [ ] , int len ) {
int count_odd = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] % 2 != 0 ) count_odd ++ ;
if ( len % 2 == 0 ) { if ( count_odd > 0 ) return false ; else return true ; }
if ( count_odd != 1 ) return false ; return true ; }
string findOddAndRemoveItsFreq ( int freq [ ] ) { string odd_str = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { freq [ i ] -- ; odd_str = odd_str + ( char ) ( i + ' a ' ) ; return odd_str ; } } return odd_str ; }
string findPalindromicString ( string str ) { int len = str . length ( ) ; int freq [ MAX_CHAR ] = { 0 } ; countFreq ( str , freq , len ) ; if ( ! canMakePalindrome ( freq , len ) ) return " No ▁ Palindromic ▁ String " ;
string odd_str = findOddAndRemoveItsFreq ( freq ) ; string front_str = " " , rear_str = " ▁ " ;
for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { string temp = " " ; if ( freq [ i ] != 0 ) { char ch = ( char ) ( i + ' a ' ) ;
for ( int j = 1 ; j <= freq [ i ] / 2 ; j ++ ) temp = temp + ch ;
front_str = front_str + temp ;
rear_str = temp + rear_str ; } }
return ( front_str + odd_str + rear_str ) ; }
int main ( ) { string str = " malayalam " ; cout << findPalindromicString ( str ) ; return 0 ; }
int checkEquality ( string s ) { return ( s [ 0 ] == s [ s . size ( ) - 1 ] ) ; } int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ;
for ( int i = 0 ; i < n ; i ++ )
for ( int len = 1 ; len <= n - i ; len ++ )
if ( checkEquality ( s . substr ( i , len ) ) ) result ++ ; return result ; }
int main ( ) { string s ( " abcab " ) ; cout << countSubstringWithEqualEnds ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . length ( ) ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s [ i ] == s [ j ] ) result ++ ; return result ; }
int main ( ) { string s ( " abcab " ) ; cout << countSubstringWithEqualEnds ( s ) ; return 0 ; }
char maxRepeating ( string str ) { int len = str . length ( ) ; int count = 0 ;
char res = str [ 0 ] ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] != str [ j ] ) break ; cur_count ++ ; }
if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } } return res ; }
int main ( ) { string str = " aaaabbaaccde " ; cout << maxRepeating ( str ) ; return 0 ; }
string findSum ( string str1 , string str2 ) {
if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 , str2 ) ;
string str = " " ;
int n1 = str1 . length ( ) , n2 = str2 . length ( ) ;
reverse ( str1 . begin ( ) , str1 . end ( ) ) ; reverse ( str2 . begin ( ) , str2 . end ( ) ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) {
int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ;
carry = sum / 10 ; }
for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; }
if ( carry ) str . push_back ( carry + '0' ) ;
reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
int main ( ) { string str1 = "12" ; string str2 = "198111" ; cout << findSum ( str1 , str2 ) ; return 0 ; }
string findSum ( string str1 , string str2 ) {
if ( str1 . length ( ) > str2 . length ( ) ) swap ( str1 , str2 ) ;
string str = " " ;
int n1 = str1 . length ( ) , n2 = str2 . length ( ) ; int diff = n2 - n1 ;
int carry = 0 ;
for ( int i = n1 - 1 ; i >= 0 ; i -- ) {
int sum = ( ( str1 [ i ] - '0' ) + ( str2 [ i + diff ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; }
for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( str2 [ i ] - '0' ) + carry ) ; str . push_back ( sum % 10 + '0' ) ; carry = sum / 10 ; }
if ( carry ) str . push_back ( carry + '0' ) ;
reverse ( str . begin ( ) , str . end ( ) ) ; return str ; }
int main ( ) { string str1 = "12" ; string str2 = "198111" ; cout << findSum ( str1 , str2 ) ; return 0 ; }
bool areChractersUnique ( string str ) {
int checker = 0 ; for ( int i = 0 ; i < str . length ( ) ; ++ i ) { int val = ( str [ i ] - ' a ' ) ;
if ( ( checker & ( 1 << val ) ) > 0 ) return false ;
checker |= ( 1 << val ) ; } return true ; }
int main ( ) { string s = " aaabbccdaa " ; if ( areChractersUnique ( s ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int countWords ( char str [ ] , int len ) { int count = 1 ;
if ( len == 1 ) return count ;
if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ;
for ( int j = 1 ; j < len - 1 ; j ++ ) {
if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ;
else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ;
else count *= 3 ; }
if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; }
int main ( ) { char str [ ] = " abc " ; int len = strlen ( str ) ; cout << countWords ( str , len ) << endl ; return 0 ; }
int replaceDig ( int x , int from , int to ) { int result = 0 ; int multiply = 1 ; while ( x > 0 ) { int reminder = x % 10 ;
if ( reminder == from ) result = result + to * multiply ; else result = result + reminder * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; }
void calculateMinMaxSum ( int x1 , int x2 ) {
int minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) ;
int maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) ; cout << " Minimum ▁ sum ▁ = ▁ " << minSum ; cout << " nMaximum ▁ sum ▁ = ▁ " << maxSum ; }
int main ( ) { int x1 = 5466 , x2 = 4555 ; calculateMinMaxSum ( x1 , x2 ) ; return 0 ; }
void qType1 ( int l , int x , char str [ ] ) { str [ l - 1 ] = x ; }
void qType2 ( int l , int r , char str [ ] ) { int freq [ 27 ] = { 0 } ;
for ( int i = l - 1 ; i <= r - 1 ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ;
int count = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) if ( freq [ j ] % 2 ) count ++ ; ( count <= 1 ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; }
int main ( ) { char str [ ] = " geeksforgeeks " ; int n = strlen ( str ) ; qType1 ( 4 , ' g ' , str ) ; qType2 ( 1 , 4 , str ) ; qType2 ( 2 , 3 , str ) ; qType1 ( 10 , ' t ' , str ) ; qType2 ( 10 , 11 , str ) ; return 0 ; }
string findTwoscomplement ( string str ) { int n = str . length ( ) ;
int i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str [ i ] == '1' ) break ;
if ( i == -1 ) return '1' + str ;
for ( int k = i - 1 ; k >= 0 ; k -- ) {
if ( str [ k ] == '1' ) str [ k ] = '0' ; else str [ k ] = '1' ; }
return str ; ; }
int main ( ) { string str = "00000101" ; cout << findTwoscomplement ( str ) ; return 0 ; }
bool isequal ( string str ) { int n = str . length ( ) ;
int num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( '0' <= str [ i ] && str [ i ] <= '9' ) { num = ( str [ i ] - '0' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; }
return num == i + 1 ; }
int main ( ) { string str = " geeksforgeeks13" ; isequal ( str ) ? cout << " Yes " : cout << " No " ; return 0 ; }
void countToMake0lternate ( const string & s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ )
if ( s [ i ] == s [ i + 1 ] )
return result ; }
int main ( ) { cout << countToMake0lternate ( "000111" ) << endl ; cout << countToMake0lternate ( "11111" ) << endl ; cout << countToMake0lternate ( "01010101" ) << endl ; return 0 ; }
bool isPossiblePalindrome ( string str ) { int n = str . length ( ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) {
if ( str [ i ] != ' . ' && str [ n - i - 1 ] != ' . ' && str [ i ] != str [ n - i - 1 ] ) return false ; } return true ; }
string smallestPalindrome ( string str ) { if ( ! isPossiblePalindrome ( str ) ) return " Not ▁ Possible " ; int n = str . length ( ) ;
for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' . ' ) {
if ( str [ n - i - 1 ] != ' . ' ) str [ i ] = str [ n - i - 1 ] ;
else str [ i ] = str [ n - i - 1 ] = ' a ' ; } }
return str ; }
int main ( ) { string str = " ab . . e . c . a " ; cout << smallestPalindrome ( str ) << endl ; return 0 ; }
char flip ( char ch ) { return ( ch == '0' ) ? '1' : '0' ; }
int getFlipWithStartingCharcter ( string str , char expected ) { int flipCount = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) {
if ( str [ i ] != expected ) flipCount ++ ;
expected = flip ( expected ) ; } return flipCount ; }
int minFlipToMakeStringAlternate ( string str ) {
return min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) ) ; }
int main ( ) { string str = "0001010111" ; cout << minFlipToMakeStringAlternate ( str ) ; return 0 ; }
int remainderWith7 ( string num ) {
int series [ ] = { 1 , 3 , 2 , -1 , -3 , -2 } ;
int series_index = 0 ;
for ( int i = num . size ( ) - 1 ; i >= 0 ; i -- ) {
int digit = num [ i ] - '0' ;
result += digit * series [ series_index ] ;
series_index = ( series_index + 1 ) % 6 ;
result %= 7 ; }
if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; }
int main ( ) { string str = "12345" ; cout << " Remainder ▁ with ▁ 7 ▁ is ▁ " << remainderWith7 ( str ) ; return 0 ; }
string intToRoman ( int num ) {
string m [ ] = { " " , " M " , " MM " , " MMM " } ; string c [ ] = { " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM " } ; string x [ ] = { " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " } ; string i [ ] = { " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " } ;
string thousands = m [ num / 1000 ] ; string hundereds = c [ ( num % 1000 ) / 100 ] ; string tens = x [ ( num % 100 ) / 10 ] ; string ones = i [ num % 10 ] ; string ans = thousands + hundereds + tens + ones ; return ans ; }
int main ( ) { int number = 3549 ; cout << intToRoman ( number ) ; return 0 ; }
void pattern ( string str , int len ) {
for ( int i = 0 ; i < len ; i ++ ) { int j = len - 1 - i ; for ( int k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) cout << str [ k ] ; else cout << " ▁ " ; } cout << endl ; } }
int main ( ) { string str = " geeksforgeeks " ; int len = str . size ( ) ; pattern ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int no_of_chars = 256 ;
string findSubString ( string str , string pat ) { int len1 = str . length ( ) ; int len2 = pat . length ( ) ;
if ( len1 < len2 ) { cout << " No ▁ such ▁ window ▁ exists " ; return " " ; } int hash_pat [ no_of_chars ] = { 0 } ; int hash_str [ no_of_chars ] = { 0 } ;
for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat [ i ] ] ++ ; int start = 0 , start_index = -1 , min_len = INT_MAX ;
int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) {
hash_str [ str [ j ] ] ++ ;
if ( hash_str [ str [ j ] ] <= hash_pat [ str [ j ] ] ) count ++ ;
if ( count == len2 ) {
while ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] hash_pat [ str [ start ] ] == 0 ) { if ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] ) hash_str [ str [ start ] ] -- ; start ++ ; }
int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } }
if ( start_index == -1 ) { cout << " No ▁ such ▁ window ▁ exists " ; return " " ; }
return str . substr ( start_index , min_len ) ; }
int main ( ) { string str = " this ▁ is ▁ a ▁ test ▁ string " ; string pat = " tist " ; cout << " Smallest ▁ window ▁ is ▁ : ▁ STRNEWLINE " << findSubString ( str , pat ) ; return 0 ; }
vector < int > set ; vector < int > prime ;
bool isPrime ( int x ) {
int sqroot = sqrt ( x ) ; bool flag = true ;
if ( x == 1 ) return false ;
for ( int i = 2 ; i <= sqroot ; i ++ ) if ( x % i == 0 ) return false ;
return true ; }
void display ( ) { int length = set . size ( ) ; for ( int i = 0 ; i < length ; i ++ ) cout << set [ i ] << " ▁ " ; cout << " STRNEWLINE " ; }
void primeSum ( int total , int N , int S , int index ) {
if ( total == S && set . size ( ) == N ) {
display ( ) ; return ; }
if ( total > S || index == prime . size ( ) ) return ;
set . push_back ( prime [ index ] ) ;
primeSum ( total + prime [ index ] , N , S , index + 1 ) ;
set . pop_back ( ) ;
primeSum ( total , N , S , index + 1 ) ; }
void allPrime ( int N , int S , int P ) {
for ( int i = P + 1 ; i <= S ; i ++ ) {
if ( isPrime ( i ) ) prime . push_back ( i ) ; }
if ( prime . size ( ) < N ) return ; primeSum ( 0 , N , S , 0 ) ; }
int main ( ) { int S = 54 , N = 2 , P = 3 ; allPrime ( N , S , P ) ; return 0 ; }
ll F ( ll A , ll B ) {
if ( A == 1 ) return ( 4 % B ) ; else { ll temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } }
int main ( ) { ll A = 25 , B = 50 ;
cout << F ( A , B ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007
int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = max ( l , a ) ; int R = min ( r , b ) ;
if ( L <= R ) {
int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; }
int main ( ) { int l = 98 , r = 102 ; cout << rangeSum ( l , r ) ; return 0 ; }
vector < int > permutation ;
void printPermutation ( ) { for ( auto i : permutation ) cout << i << " ▁ " ; }
int give_random_number ( int l , int r ) { int x = rand ( ) % ( r - l + 1 ) + l ; return x ; }
void generate_random_permutation ( int l , int r ) {
if ( l > r ) return ;
int n = give_random_number ( l , r ) ;
permutation . push_back ( n ) ;
generate_random_permutation ( l , n - 1 ) ;
generate_random_permutation ( n + 1 , r ) ; }
int main ( ) { int l = 5 ; int r = 15 ;
generate_random_permutation ( l , r ) ;
printPermutation ( ) ; return 0 ; }
int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; }
int findMinimum ( int x ) { int low = 0 , high = 100000 ; int ans = high ;
while ( low <= high ) {
int mid = ( low + high ) >> 1 ;
if ( getSetBitsFromOneToN ( mid ) >= x ) { ans = min ( ans , mid ) ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; }
int main ( ) { int x = 20 ; cout << findMinimum ( x ) ; return 0 ; }
int trailingZeroes ( int n ) { int cnt = 0 ; while ( n > 0 ) { n /= 5 ; cnt += n ; } return cnt ; } void binarySearch ( int n ) { int low = 0 ;
while ( low < high ) { int mid = ( low + high ) / 2 ; int count = trailingZeroes ( mid ) ; if ( count < n ) low = mid + 1 ; else high = mid ; }
vector < int > result ; while ( trailingZeroes ( low ) == n ) { result . push_back ( low ) ; low ++ ; }
for ( int i = 0 ; i < result . size ( ) ; i ++ ) cout << result [ i ] << " ▁ " ; }
int main ( ) { int n = 2 ; binarySearch ( n ) ; return 0 ; }
int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( std :: sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return std :: ceil ( eq_root ) + l ; }
int main ( ) { cout << minDaysToEmpty ( 5 , 2 ) << endl ; cout << minDaysToEmpty ( 6514683 , 4965 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int kth ( int arr1 [ ] , int arr2 [ ] , int m , int n , int k ) { int sorted1 [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; }
int main ( ) { int arr1 [ 5 ] = { 2 , 3 , 6 , 7 , 9 } ; int arr2 [ 4 ] = { 1 , 4 , 8 , 10 } ; int k = 5 ; cout << kth ( arr1 , arr2 , 5 , 4 , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define R  2 NEW_LINE #define C  2
int bsearch ( int low , int high , int n , int arr [ ] ) { int mid = ( low + high ) / 2 ; if ( low <= high ) { if ( arr [ mid ] < n ) return bsearch ( mid + 1 , high , n , arr ) ; return bsearch ( low , mid - 1 , n , arr ) ; } return low ; }
int mindiff ( int arr [ R ] [ C ] , int n , int m ) {
for ( int i = 0 ; i < n ; i ++ ) sort ( arr [ i ] , arr [ i ] + m ) ; int ans = INT_MAX ;
for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) {
int p = bsearch ( 0 , m - 1 , arr [ i ] [ j ] , arr [ i + 1 ] ) ; ans = min ( ans , abs ( arr [ i + 1 ] [ p ] - arr [ i ] [ j ] ) ) ;
if ( p - 1 >= 0 ) ans = min ( ans , abs ( arr [ i + 1 ] [ p - 1 ] - arr [ i ] [ j ] ) ) ; } } return ans ; }
int main ( ) { int m [ R ] [ C ] = { 8 , 5 , 6 , 8 , } ; cout << mindiff ( m , R , C ) << endl ; return 0 ; }
int binarySearch ( int arr [ ] , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ;
if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ;
if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return -1 ; }
int main ( ) { int arr [ ] = { 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int index = binarySearch ( arr , 1 , n - 2 ) ; if ( index != -1 ) cout << arr [ index ] ; return 0 ; }
int findRepeatingElement ( int arr [ ] , int low , int high ) {
if ( low > high ) return -1 ; int mid = low + ( high - low ) / 2 ;
if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ;
return findRepeatingElement ( arr , low , mid - 1 ) ; }
return findRepeatingElement ( arr , mid + 1 , high ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int index = findRepeatingElement ( arr , 0 , n - 1 ) ; if ( index != -1 ) cout << arr [ index ] ; return 0 ; }
double diff ( double n , double mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; }
double cubicRoot ( double n ) {
double start = 0 , end = n ;
double e = 0.0000001 ; while ( true ) { double mid = ( start + end ) / 2 ; double error = diff ( n , mid ) ;
if ( error <= e ) return mid ;
if ( ( mid * mid * mid ) > n ) end = mid ;
else start = mid ; } }
int main ( ) { double n = 3 ; printf ( " Cubic ▁ root ▁ of ▁ % lf ▁ is ▁ % lf STRNEWLINE " , n , cubicRoot ( n ) ) ; return 0 ; }
int floorSqrt ( int x ) {
if ( x == 0 x == 1 ) return x ;
int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; }
int main ( ) { int x = 11 ; cout << floorSqrt ( x ) << endl ; return 0 ; }
int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; }
int main ( ) { int n = 5 ; cout << sumOfInternalAngles ( n ) ; return 0 ; }
float diagonal_length ( float a ) { float L ;
L = a * sqrt ( 3 ) ; return L ; }
int main ( ) { float a = 5 ;
cout << diagonal_length ( a ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const double PI = 3.14 ;
double find_area ( int r , int d ) {
double R = d / PI ; R += pow ( r , 2 ) ; R = sqrt ( R ) ;
double area = PI * pow ( R , 2 ) ; return area ; }
int main ( ) { int r = 4 , d = 5 ; cout << find_area ( r , d ) ; return 0 ; }
bool Valid ( int a , int b , int c , int d ) {
if ( a + b + c + d == 360 ) return true ; return false ; }
int main ( ) { int a = 80 , b = 70 , c = 100 , d = 110 ; if ( Valid ( a , b , c , d ) ) cout << " Valid ▁ quadrilateral " ; else cout << " Invalid ▁ quadrilateral " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; }
int main ( ) { int x1 = -10 , y1 = 8 ; int x2 = 14 , y2 = -24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) cout << " There ▁ are ▁ 3 ▁ common ▁ tangents " << " ▁ between ▁ the ▁ circles . " ; else if ( t < 0 ) cout << " There ▁ are ▁ 4 ▁ common ▁ tangents " << " ▁ between ▁ the ▁ circles . " ; else cout << " There ▁ are ▁ 2 ▁ common ▁ tangents " << " ▁ between ▁ the ▁ circles . " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; }
void ratiotang ( int r1 , int r2 ) { cout << " The ▁ ratio ▁ is ▁ " << r1 / GCD ( r1 , r2 ) << " : " << r2 / GCD ( r1 , r2 ) << endl ; }
int main ( ) { int r1 = 4 , r2 = 8 ; ratiotang ( r1 , r2 ) ; return 0 ; }
int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; }
int main ( ) { int V = 5 , E = 7 ; cout << Regions ( V , E ) ; return 0 ; }
int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; }
void ratiotang ( int r1 , int r2 ) { cout << " The ▁ ratio ▁ is ▁ " << r1 / GCD ( r1 , r2 ) << " ▁ : ▁ " << r2 / GCD ( r1 , r2 ) << endl ; }
int main ( ) { int r1 = 4 , r2 = 6 ; ratiotang ( r1 , r2 ) ; return 0 ; }
void lengthOfTangent ( double r1 , double r2 , double d ) { cout << " The ▁ length ▁ of ▁ the ▁ transverse " << " ▁ common ▁ tangent ▁ is ▁ " << sqrt ( pow ( d , 2 ) - pow ( ( r1 + r2 ) , 2 ) ) << endl ; }
int main ( ) { double r1 = 4 , r2 = 6 , d = 12 ; lengthOfTangent ( r1 , r2 , d ) ; return 0 ; }
int remainingArea ( int N , int M , int K ) {
while ( K -- && N && M ) {
if ( N > M ) N = N - M ;
else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; }
int main ( ) { int N = 5 , M = 3 , K = 2 ; cout << remainingArea ( N , M , K ) ; return 0 ; }
void lengtang ( double r1 , double r2 ) { cout << " The ▁ length ▁ of ▁ the ▁ " << " direct ▁ common ▁ tangent ▁ is ▁ " << 2 * sqrt ( r1 * r2 ) << endl ; }
int main ( ) { double r1 = 5 , r2 = 9 ; lengtang ( r1 , r2 ) ; return 0 ; }
void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { cout << " The ▁ shortest ▁ distance ▁ " << " between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " << sqrt ( ( pow ( ( x2 - x1 ) , 2 ) ) + ( pow ( ( y2 - y1 ) , 2 ) ) ) - r << endl ; }
int main ( ) { double x1 = 4 , y1 = 6 , x2 = 35 , y2 = 42 , r = 5 ; dist ( x1 , y1 , x2 , y2 , r ) ; return 0 ; }
double dist ( double m , double b1 , double b2 ) { double d = fabs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; return d ; }
int main ( ) { double m = 2 , b1 = 4 , b2 = 3 ; cout << dist ( m , b1 , b2 ) ; return 0 ; }
float normal ( float m , float n ) {
float N = ( fabsf ( m ) * fabsf ( n ) ) / sqrt ( ( fabsf ( m ) * fabsf ( m ) ) + ( fabsf ( n ) * fabsf ( n ) ) ) ; return N ; }
int main ( ) { float m = -5 , n = 3 ; cout << normal ( m , n ) ; return 0 ; }
bool isPossible ( int a [ ] , int n ) {
int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = max ( a [ i ] , maxS ) ; }
if ( ( sum - maxS ) > maxS ) return true ; return false ; }
int main ( ) { int a [ ] = { 2 , 3 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; if ( isPossible ( a , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
float findAreaShaded ( float a ) {
float sqArea = a * a ;
float semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ;
float ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; }
int main ( ) { float a = 10 ; cout << findAreaShaded ( a ) ; return 0 ; }
int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } }
int main ( ) { int x = 4 , y = 3 ; cout << countSteps ( x , y ) ; return 0 ; }
bool isSlopeGood ( double slope , int arr [ ] , int n ) { set < double > setOfLines ; for ( int i = 0 ; i < n ; i ++ ) setOfLines . insert ( arr [ i ] - slope * ( i ) ) ;
return setOfLines . size ( ) == 2 ; }
bool checkForParallel ( int arr [ ] , int n ) {
bool slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) ; bool slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) ; bool slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) / 2 , arr , n ) ; return ( slope1 slope2 slope3 ) ; }
int main ( ) { int arr [ ] = { 1 , 6 , 3 , 8 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( int ) checkForParallel ( arr , n ) ; return 0 ; }
bool pointIsOnLine ( int m , int c , int x , int y ) {
if ( y == ( ( m * x ) + c ) ) return true ; return false ; }
int main ( ) { int m = 3 , c = 2 ; int x = 1 , y = 5 ; if ( pointIsOnLine ( m , c , x , y ) ) cout << " Yes " ; else cout << " No " ; }
float Area ( float a , float b ) {
if ( a < 0 && b < 0 ) return -1 ;
float h = sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) ;
float A = 0.70477 * pow ( h , 2 ) ; return A ; }
int main ( ) { float a = 5 , b = 4 ; cout << Area ( a , b ) << endl ; return 0 ; }
int maxRectangles ( int L , int B , int l , int b ) { int horizontal = 0 , vertical = 0 ;
if ( l <= L && b <= B ) {
int columns = B / b ; int rows = L / l ;
horizontal = rows * columns ; }
if ( l <= B && b <= L ) { int columns = L / b ; int rows = B / l ; vertical = rows * columns ; }
return max ( horizontal , vertical ) ; }
int main ( ) { int L = 10 , B = 7 , l = 4 , b = 3 ; cout << ( maxRectangles ( L , B , l , b ) ) << endl ; }
float cone ( float a ) {
if ( a < 0 ) return -1 ;
float r = ( a * sqrt ( 2 ) ) / 3 ;
float h = ( 2 * a ) / 3 ;
float V = 3.14 * pow ( r , 2 ) * h ; return V ; }
int main ( ) { float a = 5 ; cout << cone ( a ) << endl ; return 0 ; }
float Area ( float a ) {
if ( a < 0 ) return -1 ;
float h = 1.268 * a ;
float A = 0.70477 * pow ( h , 2 ) ; return A ; }
int main ( ) { float a = 5 ; cout << Area ( a ) << endl ; return 0 ; }
float Area ( float r ) {
if ( r < 0 ) return -1 ;
float x = ( 2 * r ) / sqrt ( 5 ) ;
float A = 0.70477 * pow ( x , 2 ) ; return A ; }
int main ( ) { float r = 5 ; cout << Area ( r ) << endl ; return 0 ; }
float Area ( float a ) {
if ( a < 0 ) return -1 ;
float x = 0.464 * a ;
float A = 0.70477 * pow ( x , 2 ) ; return A ; }
int main ( ) { float a = 5 ; cout << Area ( a ) << endl ; return 0 ; }
double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / pow ( 2 , fold ) ; }
int main ( ) { double side = 4 , fold = 2 ; cout << areaSquare ( side , fold ) ; return 0 ; }
float ReuleauxArea ( float r ) {
if ( r < 0 ) return -1 ;
float A = 0.70477 * 2 * pow ( r , 2 ) ; return A ; }
int main ( ) { float r = 6 ; cout << ReuleauxArea ( r ) << endl ; return 0 ; }
float cyl ( float a ) {
if ( a < 0 ) return -1 ;
float r = ( 2 * a * sqrt ( 2 ) ) / 3 ;
float h = ( 2 * a ) / 3 ;
float V = 3.14 * pow ( r , 2 ) * h ; return V ; }
int main ( ) { float a = 5 ; cout << cyl ( a ) << endl ; return 0 ; }
float Area ( float l , float b , float h ) {
if ( l < 0 b < 0 h < 0 ) return -1 ;
float x = ( l * b ) / ( l + b ) ;
float A = 0.70477 * pow ( x , 2 ) ; return A ; }
int main ( ) { float l = 5 , b = 12 , h = 13 ; cout << Area ( l , b , h ) << endl ; return 0 ; }
float squareSide ( float a ) {
if ( a < 0 ) return -1 ;
float x = 0.423 * a ; return x ; }
int main ( ) { float a = 8 ; cout << squareSide ( a ) << endl ; return 0 ; }
bool isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( ceil ( a ) == 1 && floor ( a ) == 1 ) return true ; return false ; }
int main ( ) { float l = 0.70710678 , m = 0.5 , n = 0.5 ; if ( isPossible ( l , m , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
float polydiagonal ( float n , float a ) {
if ( a < 0 && n < 0 ) return -1 ;
return 2 * a * sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ; }
int main ( ) { float a = 9 , n = 10 ; cout << polydiagonal ( n , a ) << endl ; return 0 ; }
float decdiagonal ( float a ) {
if ( a < 0 ) return -1 ;
float d = 1.902 * a ; return d ; }
int main ( ) { float a = 9 ; cout << decdiagonal ( a ) << endl ; return 0 ; }
float heptdiagonal ( float a ) {
if ( a < 0 ) return -1 ;
float d = 1.802 * a ; return d ; }
int main ( ) { float a = 6 ; cout << heptdiagonal ( a ) << endl ; return 0 ; }
float hexDiagonal ( float a ) {
if ( a < 0 ) return -1 ;
float d = 1.73 * a ; return d ; }
int main ( ) { float a = 9 ; cout << hexDiagonal ( a ) << endl ; return 0 ; }
float ReuleauxArea ( float a ) {
if ( a < 0 ) return -1 ;
float A = 0.70477 * pow ( a , 2 ) ; return A ; }
int main ( ) { float a = 6 ; cout << ReuleauxArea ( a ) << endl ; return 0 ; }
float squareArea ( float a ) {
if ( a < 0 ) return -1 ;
float area = pow ( 1.268 , 2 ) * pow ( a , 2 ) ; return area ; }
int main ( ) { float a = 6 ; cout << squareArea ( a ) << endl ; return 0 ; }
float CubeVolume ( float d ) { float Volume ;
Volume = ( sqrt ( 3 ) * pow ( d , 3 ) ) / 9 ; return Volume ; }
float d = 5 ; cout << " Volume ▁ of ▁ Cube : ▁ " << CubeVolume ( d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define PI  3.14159265
float length_rope ( float r ) { return ( ( 2 * PI * r ) + 6 * r ) ; }
int main ( ) { float r = 7 ; cout << ceil ( length_rope ( r ) ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define PI  3.14159265 NEW_LINE using namespace std ;
float area_circumscribed ( float c ) { return ( c * c * ( PI / 4 ) ) ; }
int main ( ) { float c = 8 ; cout << area_circumscribed ( c ) ; return 0 ; }
float cyl ( float r , float h ) {
if ( r < 0 && h < 0 ) return -1 ;
float R = ( 2 * r ) / 3 ;
float H = ( 2 * h ) / 3 ;
float V = 3.14 * pow ( R , 2 ) * H ; return V ; }
int main ( ) { float r = 4 , h = 8 ; cout << cyl ( r , h ) << endl ; return 0 ; }
float cube ( float h , float r ) {
if ( h < 0 && r < 0 ) return -1 ;
float a = pow ( h , 3 ) ; return a ; }
int main ( ) { float h = 5 , r = 4 ; cout << cube ( h , r ) << endl ; return 0 ; }
float sph ( float r , float h ) {
if ( r < 0 && h < 0 ) return -1 ;
float R = r ; return R ; }
int main ( ) { float r = 4 , h = 8 ; cout << sph ( r , h ) << endl ; return 0 ; }
float cyl ( float R ) {
if ( R < 0 ) return -1 ;
float V = ( 2 * 3.14 * pow ( R , 3 ) ) / ( 3 * sqrt ( 3 ) ) ; return V ; }
int main ( ) { float R = 4 ; cout << cyl ( R ) << endl ; return 0 ; }
float rod ( float h , float r ) {
if ( h < 0 && r < 0 ) return -1 ;
float l = sqrt ( pow ( h , 2 ) + 4 * pow ( r , 2 ) ) ; return l ; }
int main ( ) { float h = 4 , r = 1.5 ; cout << rod ( h , r ) << endl ; return 0 ; }
float cubeSide ( float h , float r ) {
if ( h < 0 && r < 0 ) return -1 ;
float a = ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) ; return a ; }
int main ( ) { float h = 5 , r = 6 ; cout << cubeSide ( h , r ) << endl ; return 0 ; }
float coner ( float R ) {
if ( R < 0 ) return -1 ;
float r = ( 2 * sqrt ( 2 ) * R ) / 3 ; return r ; }
float coneh ( float R ) {
if ( R < 0 ) return -1 ;
float h = ( 4 * R ) / 3 ; return h ; }
int main ( ) { float R = 10 ; cout << " r ▁ = ▁ " << coner ( R ) << " , ▁ " << " h ▁ = ▁ " << coneh ( R ) << endl ; return 0 ; }
float coneRadius ( float a ) {
if ( a < 0 ) return -1 ;
float r = a / sqrt ( 2 ) ; return r ; }
float coneHeight ( float a ) {
if ( a < 0 ) return -1 ;
float h = a ; return h ; }
int main ( ) { float a = 6 ; cout << " r ▁ = ▁ " << coneRadius ( a ) << " , ▁ " << " h ▁ = ▁ " << coneHeight ( a ) << endl ; return 0 ; }
float largestCube ( float r ) {
if ( r < 0 ) return -1 ;
float a = ( 2 * r ) / sqrt ( 3 ) ; return a ; }
int main ( ) { float r = 5 ; cout << largestCube ( r ) << endl ; return 0 ; }
float sphere ( float a ) {
if ( a < 0 ) return -1 ;
float r = a / 2 ; return r ; }
int main ( ) { float a = 5 ; cout << sphere ( a ) << endl ; return 0 ; }
int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; }
int main ( ) { int M = 4 , N = 4 ;
int Cuts = numberOfCuts ( M , N ) ; cout << " Maximum ▁ cuts ▁ = ▁ " << Cuts ; return 0 ; }
float maxVol ( float P , float A ) {
float l = ( P - sqrt ( P * P - 24 * A ) ) / 12 ;
float V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ;
return V ; }
int main ( ) { float P = 20 , A = 16 ;
cout << maxVol ( P , A ) ; return 0 ; }
int rhombusAreaPeri ( int d1 , int d2 ) { long long int area , perimeter ; area = ( d1 * d2 ) / 2 ; perimeter = 2 * sqrt ( pow ( d1 , 2 ) + pow ( d2 , 2 ) ) ; cout << " The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " << d1 << " ▁ and ▁ " << d2 << " ▁ is ▁ " << area << " . " << endl ; cout << " The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals ▁ " << d1 << " ▁ and ▁ " << d2 << " ▁ is ▁ " << perimeter << " . " << endl ; }
int main ( ) { int d1 = 2 , d2 = 4 ; rhombusAreaPeri ( d1 , d2 ) ; return 0 ; }
float area ( float r ) {
if ( r < 0 ) return -1 ;
float area = ( 5 * pow ( r , 2 ) * ( 3 - sqrt ( 5 ) ) * ( sqrt ( 5 ) + ( 2 * sqrt ( 5 ) ) ) ) / 4 ; return area ; }
int main ( ) { float r = 8 ; cout << area ( r ) << endl ; return 0 ; }
int maxArea ( float perimeter ) { int length = ( int ) ceil ( perimeter / 4 ) ; int breadth = ( int ) floor ( perimeter / 4 ) ;
return length * breadth ; }
int main ( ) { float n = 38 ; cout << " Maximum ▁ Area ▁ = ▁ " << maxArea ( n ) ; return 0 ; }
void foot ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 1 ) ; cout << " ▁ x2 ▁ = ▁ " << x2 ; cout << " ▁ y2 ▁ = ▁ " << y2 ; cout << " ▁ z2 ▁ = ▁ " << z2 ; }
int main ( ) { float a = 1 ; float b = -2 ; float c = 0 ; float d = 0 ; float x1 = -1 ; float y1 = 3 ; float z1 = 4 ;
foot ( a , b , c , d , x1 , y1 , z1 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countRectangles ( int l , int w ) {
int squareSide = __gcd ( l , w ) ;
return ( l * w ) / ( squareSide * squareSide ) ; }
int main ( ) { int l = 4 , w = 6 ; cout << countRectangles ( l , w ) << endl ; return 0 ; }
void circle_equation ( double x1 , double y1 , double r ) { double a = -2 * x1 ; double b = -2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ;
cout << " x ^ 2 ▁ + ▁ ( " << a << " ▁ x ) ▁ + ▁ " ; cout << " y ^ 2 ▁ + ▁ ( " << b << " ▁ y ) ▁ = ▁ " ; cout << c << " . " << endl ; }
int main ( ) { double x1 = 2 , y1 = -3 , r = 8 ; circle_equation ( x1 , y1 , r ) ; return 0 ; }
float area ( float r ) {
return ( 0.5 ) * ( 3.14 ) * ( r * r ) ; }
float perimeter ( float r ) {
return ( 3.14 ) * ( r ) ; }
int r = 10 ;
cout << " The ▁ Area ▁ of ▁ Semicircle : ▁ " << area ( r ) << endl ;
cout << " The ▁ Perimeter ▁ of ▁ Semicircle : ▁ " << perimeter ( r ) << endl ; return 0 ; }
bool checkEquilibrium ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) {
int resx = x1 + x2 + x3 ;
int resy = y1 + y2 + y3 ;
int resz = z1 + z2 + z3 ;
if ( resx == 0 and resy == 0 and resz == 0 ) return true ; else return false ; }
int main ( ) { int x1 = -2 , y1 = -7 , z1 = -9 , x2 = 5 , y2 = -14 , z2 = 14 , x3 = -3 , y3 = 21 , z3 = -5 ;
if ( checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ) cout << " The ▁ vectors ▁ are ▁ at ▁ equilibrium . " ; else cout << " The ▁ vectors ▁ are ▁ not ▁ at ▁ equilibrium . " ; return 0 ; }
void findTangent ( int A , int x , int y ) {
int dif = A - x * 2 ;
if ( y == ( 2 * x - x * x ) ) {
if ( dif < 0 ) cout << " y ▁ = ▁ " << dif << " x " << ( x * dif ) + ( y ) ; else if ( dif > 0 )
cout << " y ▁ = ▁ " << dif << " x + " << - x * dif + y ;
else cout < < " Not ▁ possible " ; } }
int A = 2 , x = 2 , y = 0 ;
findTangent ( A , x , y ) ; return 0 ; }
float hexadiagonal ( float a ) {
if ( a < 0 ) return -1 ;
return 2 * a ; }
int main ( ) { float a = 4 ; cout << hexadiagonal ( a ) << endl ; return 0 ; }
float octaside ( float a ) {
if ( a < 0 ) return -1 ;
float s = a / ( sqrt ( 2 ) + 1 ) ; return s ; }
float a = 4 ;
cout << octaside ( a ) << endl ; return 0 ; }
bool Arrive ( int a , int b , int n ) { if ( n >= abs ( a ) + abs ( b ) and ( n - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 ) return true ; return false ; }
int main ( ) { int a = 5 , b = 5 , n = 11 ; if ( Arrive ( a , b , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; }
int main ( ) { int a = 3 , x = 2 , b = 7 ;
if ( Move ( a , x , b ) ) cout << " Yes " ; else cout << " No " ; }
float area ( float a , float b ) {
if ( a < 0 b < 0 ) return -1 ;
float A = a * b ; return A ; }
int main ( ) { float a = 5 , b = 2 ; cout << area ( a , b ) << endl ; return 0 ; }
float findRadiusOfcircumcircle ( float l , float b ) {
if ( l < 0 b < 0 ) return -1 ;
float radius = sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ;
return radius ; }
float l = 4 , b = 3 ;
cout << findRadiusOfcircumcircle ( l , b ) << endl ; return 0 ; }
float circlearea ( float a , float b , float c ) {
if ( a < 0 b < 0 c < 0 ) return -1 ;
float p = ( a + b + c ) / 2 ;
float At = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ;
float A = 3.14 * pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) ; return A ; }
float a = 4 , b = 5 , c = 3 ;
cout << circlearea ( a , b , c ) << endl ; return 0 ; }
float altitude ( float a , float b ) {
return sqrt ( pow ( a , 2 ) - ( pow ( b , 2 ) / 4 ) ) ; }
float area ( float b , float h ) {
return ( 1 * b * h ) / 2 ; }
int main ( ) { float a = 2 , b = 3 ; float h = altitude ( a , b ) ; cout << setprecision ( 3 ) ; cout << " Altitude = ▁ " << h << " , ▁ " ; cout << " Area = ▁ " << area ( b , h ) ; return 0 ; }
int surfaceArea ( int b , int s ) { return 2 * b * s + pow ( b , 2 ) ; }
int main ( ) { int b = 3 , s = 4 ;
cout << surfaceArea ( b , s ) << endl ; return 0 ; }
float trianglearea ( float l , float b ) {
if ( l < 0 b < 0 ) return -1 ;
float area = ( l * b ) / 2 ; return area ; }
int main ( ) { float l = 5 , b = 4 ; cout << trianglearea ( l , b ) << endl ; return 0 ; }
void halfsquare ( int n , int x , int y ) { int half = n / 2 ;
if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) cout << " NO " << endl ;
else cout < < " YES " << endl ; }
int n = 100 ;
int x = 51 , y = 100 ; halfsquare ( n , x , y ) ; return 0 ; }
ll check ( ll a , ll b , ll p , ll q ) { ll d = p * p + q * q ;
if ( d == 0 ) return a == 0 && b == 0 ; else return ( a * p + b * q ) % d == 0 && ( b * p - a * q ) % d == 0 ; } bool check ( int a , int b , int x , int y , int p , int q ) {
if ( check ( a - x , b - y , p , q ) || check ( a + x , b + y , p , q ) || check ( a - y , b + x , p , q ) || check ( a + y , b - x , p , q ) ) return true ; else return false ; }
int a = -4 , b = -2 ; int x = 0 , y = 0 ; int p = -2 , q = -1 ; if ( check ( a , b , x , y , p , q ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
float trianglearea ( float a , float b ) {
if ( a < 0 b < 0 ) return -1 ;
float area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / ( 4 * b ) ; return area ; }
int main ( ) { float a = 4 , b = 2 ; cout << trianglearea ( a , b ) << endl ; return 0 ; }
float squarearea ( float a , float b ) {
if ( a < 0 b < 0 ) return -1 ;
float area = 4 * ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ; return area ; }
int main ( ) { float a = 4 , b = 2 ; cout << squarearea ( a , b ) << endl ; return 0 ; }
float trianglearea ( float r ) {
if ( r < 0 ) return -1 ;
return r * r ; }
int main ( ) { float r = 5 ; cout << trianglearea ( r ) << endl ; return 0 ; }
float squarearea ( float r ) {
if ( r < 0 ) return -1 ;
float a = 4 * ( pow ( r , 2 ) / 5 ) ; return a ; }
int main ( ) { float r = 5 ; cout << squarearea ( r ) << endl ; return 0 ; }
float rectanglearea ( float a , float b ) {
if ( a < 0 b < 0 ) return -1 ;
return 2 * a * b ; }
int main ( ) { float a = 10 , b = 8 ; cout << rectanglearea ( a , b ) << endl ; return 0 ; }
float squareArea ( float l , float b , float h ) {
if ( l < 0 b < 0 h < 0 ) return -1 ;
float a = ( l * b ) / ( l + b ) ;
return a * a ; }
int main ( ) { float l = 5 , b = 12 , h = 13 ; cout << squareArea ( l , b , h ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  50
void solveQuery ( int n , int q , int qi [ ] , int qj [ ] ) { int arr [ MAX ] ; for ( int i = 0 ; i <= n ; i ++ ) arr [ i ] = 0 ; for ( int k = 0 ; k < q ; k ++ ) {
int flag = 0 ;
if ( qj [ k ] < qi [ k ] ) { int temp = qi [ k ] ; qi [ k ] = qj [ k ] ; qj [ k ] = temp ; }
if ( arr [ qi [ k ] ] != 0 arr [ qj [ k ] ] != 0 ) flag = 1 ;
else if ( qi [ k ] == qj [ k ] ) flag = 1 ; else {
for ( int i = 1 ; i < qi [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] < qj [ k ] && qi [ k ] < arr [ i ] ) { flag = 1 ; break ; } }
if ( flag == 0 ) { for ( int i = qi [ k ] + 1 ; i < qj [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] > qj [ k ] ) { flag = 1 ; break ; } } } }
if ( flag == 0 ) { cout << " YES STRNEWLINE " ; arr [ qi [ k ] ] = qj [ k ] ; arr [ qj [ k ] ] = qi [ k ] ; } else cout << " NO STRNEWLINE " ; } }
int main ( ) { int n = 10 ; int q = 7 ; int qi [ ] = { 1 , 2 , 2 , 2 , 9 , 10 , 8 } ; int qj [ ] = { 5 , 7 , 3 , 4 , 9 , 9 , 6 } ; solveQuery ( n , q , qi , qj ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int squares ( int l , int b , int a ) {
return ceil ( l / ( double ) a ) * ceil ( b / ( double ) a ) ; }
int main ( ) { int l = 11 , b = 23 , a = 14 ; cout << squares ( l , b , a ) << endl ; return 0 ; }
int gcd ( int a , int b ) {
if ( a == 0 b == 0 ) return 0 ;
if ( a == b ) return a ;
if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; }
int squarearea ( int l , int b ) {
if ( l < 0 b < 0 ) return -1 ;
int n = ( l * b ) / gcd ( l , b ) ;
return n * n ; }
int main ( ) { int l = 6 , b = 4 ; cout << squarearea ( l , b ) << endl ; return 0 ; }
float angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; float den = sqrt ( pow ( ( x2 - x1 ) , 2 ) + pow ( ( y2 - y1 ) , 2 ) + pow ( ( z2 - z1 ) , 2 ) ) * sqrt ( pow ( ( x3 - x1 ) , 2 ) + pow ( ( y3 - y1 ) , 2 ) + pow ( ( z3 - z1 ) , 2 ) ) ; float angle = acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; }
int main ( ) { int x1 = -1 ; int y1 = 3 ; int z1 = 2 ; int x2 = 2 ; int y2 = 3 ; int z2 = 5 ; int x3 = 3 ; int y3 = 5 ; int z3 = -2 ; float angle_A = angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) ; float angle_B = angle_triangle ( x2 , x3 , x1 , y2 , y3 , y1 , z2 , z3 , z1 ) ; float angle_C = angle_triangle ( x3 , x2 , x1 , y3 , y2 , y1 , z3 , z2 , z1 ) ; cout << " Angles ▁ are ▁ : " << endl ; cout << setprecision ( 3 ) ; cout << " angle ▁ A ▁ = ▁ " << angle_A << " ▁ degree " << endl ; cout << " angle ▁ B ▁ = ▁ " << angle_B << " ▁ degree " << endl ; cout << " angle ▁ C ▁ = ▁ " << angle_C << " ▁ degree " << endl ; }
int solve ( int M , int N , int s ) {
if ( N % s == 0 ) {
N = N / s ; } else {
N = ( N / s ) + 1 ; }
if ( M % s == 0 ) {
M = M / s ; } else {
M = ( M / s ) + 1 ; } return M * N ; }
int N = 12 , M = 13 , s = 4 ; cout << solve ( M , N , s ) ; return 0 ; }
int solve ( double M , double N , double s ) {
int ans = ( ( int ) ( ceil ( M / s ) ) * ( int ) ( ceil ( N / s ) ) ) ; return ans ; }
double N = 12 , M = 13 , s = 4 ; cout << solve ( M , N , s ) ; return 0 ; }
void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " equation ▁ of ▁ plane ▁ is ▁ " << a << " ▁ x ▁ + ▁ " << b << " ▁ y ▁ + ▁ " << c << " ▁ z ▁ + ▁ " << d << " ▁ = ▁ 0 . " ; }
int main ( ) { float x1 = -1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = -3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = -4 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; return 0 ; }
void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 1st ▁ octant STRNEWLINE " ; else if ( x < 0 && y >= 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 2nd ▁ octant STRNEWLINE " ; else if ( x < 0 && y < 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 3rd ▁ octant STRNEWLINE " ; else if ( x >= 0 && y < 0 && z >= 0 ) cout << " Point ▁ lies ▁ in ▁ 4th ▁ octant STRNEWLINE " ; else if ( x >= 0 && y >= 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 5th ▁ octant STRNEWLINE " ; else if ( x < 0 && y >= 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 6th ▁ octant STRNEWLINE " ; else if ( x < 0 && y < 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 7th ▁ octant STRNEWLINE " ; else if ( x >= 0 && y < 0 && z < 0 ) cout << " Point ▁ lies ▁ in ▁ 8th ▁ octant STRNEWLINE " ; }
int main ( ) { float x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = -4 , y = 2 , z = -8 ; octant ( x , y , z ) ; x = -6 , y = -2 , z = 8 ; octant ( x , y , z ) ; return 0 ; }
int countNumberOfTriangles ( int n ) {
return n * ( n - 1 ) * ( n - 2 ) / 6 ; }
int main ( ) { int n = 4 ; cout << countNumberOfTriangles ( n ) ; return 0 ; }
int centeredTridecagonalNum ( long int n ) {
return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; }
int main ( ) { long int n = 3 ; cout << centeredTridecagonalNum ( n ) ; cout << endl ; n = 10 ; cout << centeredTridecagonalNum ( n ) ; return 0 ; }
int pentagon_pyramidal ( int n ) { int sum = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) {
int p = ( 3 * i * i - i ) / 2 ;
sum = sum + p ; } return sum ; }
int main ( ) { int n = 4 ; cout << pentagon_pyramidal ( n ) << endl ; return 0 ; }
int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; }
int main ( ) { int n = 4 ; cout << pentagon_pyramidal ( n ) << endl ; return 0 ; }
bool checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; }
int main ( ) { int a1 = 2 , b1 = -3 , c1 = 5 ; int a2 = 3 , b2 = 4 , c2 = -7 ; int a3 = 9 , b3 = -5 , c3 = 8 ; ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ? ( cout << " Yes " ) : ( cout << " No " ) ) ; return 0 ; }
int center_octadecagon_num ( long int n ) {
return 9 * n * n - 9 * n + 1 ; }
int main ( ) { long int n = 3 ; cout << n << " th ▁ centered ▁ octadecagonal ▁ number ▁ : ▁ " << center_octadecagon_num ( n ) ; cout << endl ; n = 13 ; cout << n << " th ▁ centered ▁ octadecagonal ▁ number ▁ : ▁ " << center_octadecagon_num ( n ) ; return 0 ; }
int centereddecagonalnum ( int n ) {
return ( 5 * n * n + 5 * n + 1 ) ; }
int main ( ) { int n = 5 ; cout << n << " th ▁ centered ▁ decagonal " << " number : ▁ " ; cout << centereddecagonalnum ( n ) ; cout << endl ; n = 9 ; cout << n << " th ▁ centered ▁ decagonal " << " number : ▁ " ; cout << centereddecagonalnum ( n ) ; return 0 ; }
int factorial ( int a , int b ) { int res = 1 ;
for ( int i = 1 ; i <= ( a + b ) ; i ++ ) res = res * i ;
for ( int i = 1 ; i <= a ; i ++ ) res = res / i ;
for ( int i = 1 ; i <= b ; i ++ ) res = res / i ; return res ; }
void Ksmallest ( int x , int y , int k ) {
if ( x == 0 && y == 0 ) return ;
else if ( x == 0 ) {
y -- ;
cout << " V " ;
Ksmallest ( x , y , k ) ; }
else if ( y == 0 ) {
x -- ;
cout << " H " ;
Ksmallest ( x , y , k ) ; } else {
if ( factorial ( x - 1 , y ) > k ) {
cout << " H " ;
Ksmallest ( x - 1 , y , k ) ; } else {
cout << " V " ;
Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) ; } } }
int main ( ) { int x = 2 , y = 2 , k = 2 ; Ksmallest ( x , y , k ) ; return 0 ; }
int centered_pentagonal_Num ( int n ) {
return ( 5 * n * n - 5 * n + 2 ) / 2 ; }
int main ( ) { int n = 7 ; cout << n << " th ▁ Centered ▁ pentagonal ▁ number : ▁ " ; cout << centered_pentagonal_Num ( n ) ; return 0 ; }
int pivotDis ( int x0 , int y0 , int x1 , int y1 ) { return sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) ; }
int minDis ( int D , int r1 , int r2 ) { return max ( ( D - r1 - r2 ) , 0 ) ; }
int maxDis ( int D , int r1 , int r2 ) { return D + r1 + r2 ; }
int main ( ) { int x0 = 0 , y0 = 0 , x1 = 8 , y1 = 0 , r1 = 4 , r2 = 5 ; int D = pivotDis ( x0 , y0 , x1 , y1 ) ; cout << " Distance ▁ while ▁ repulsion ▁ = ▁ " << maxDis ( D , r1 , r2 ) ; cout << " Distance while attraction = " return 0 ; }
double maximumValueOfF ( int R ) {
return 4 * R * R + 0.25 ; }
int main ( ) { int R = 3 ; printf ( " % .2f " , maximumValueOfF ( R ) ) ; return 0 ; }
void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) {
float x2 = ( float ) ( 2 * m1 - x1 ) ;
float y2 = ( float ) ( 2 * m2 - y1 ) ; cout << " x2 ▁ = ▁ " << x2 << " , ▁ " << " y2 ▁ = ▁ " << y2 ; }
int main ( ) { int x1 = -4 , y1 = -1 , m1 = 3 , m2 = 5 ; otherEndPoint ( x1 , y1 , m1 , m2 ) ; return 0 ; }
void printRect ( int X [ ] , int Y [ ] , int n ) {
int Xmax = * max_element ( X , X + n ) ; int Xmin = * min_element ( X , X + n ) ;
int Ymax = * max_element ( Y , Y + n ) ; int Ymin = * min_element ( Y , Y + n ) ;
cout << " { " << Xmin << " , ▁ " << Ymin << " } " << endl ; cout << " { " << Xmin << " , ▁ " << Ymax << " } " << endl ; cout << " { " << Xmax << " , ▁ " << Ymax << " } " << endl ; cout << " { " << Xmax << " , ▁ " << Ymin << " } " << endl ; }
int main ( ) { int X [ ] = { 4 , 3 , 6 , 1 , -1 , 12 } ; int Y [ ] = { 4 , 1 , 10 , 3 , 7 , -1 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; printRect ( X , Y , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; }
int main ( ) { if ( checkOrigin ( 1 , 28 , 2 , 56 ) == true ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool isBetween ( int a , int b , int c ) { return min ( a , b ) <= c && c <= max ( a , b ) ; }
bool canJoin ( int x [ ] , int y [ ] , int i , int j , int k ) {
return ( x [ k ] == x [ i ] x [ k ] == x [ j ] ) && isBetween ( y [ i ] , y [ j ] , y [ k ] ) || ( y [ k ] == y [ i ] y [ k ] == y [ j ] ) && isBetween ( x [ i ] , x [ j ] , x [ k ] ) ; } int countLineSegments ( int x [ ] , int y [ ] ) {
if ( ( x [ 0 ] == x [ 1 ] && x [ 1 ] == x [ 2 ] ) || ( y [ 0 ] == y [ 1 ] && y [ 1 ] == y [ 2 ] ) ) return 1 ;
else if ( canJoin ( x , y , 0 , 1 , 2 ) || canJoin ( x , y , 0 , 2 , 1 ) || canJoin ( x , y , 1 , 2 , 0 ) ) return 2 ;
else return 3 ; }
int main ( ) { int x [ 3 ] , y [ 3 ] ; x [ 0 ] = -1 ; y [ 0 ] = -1 ; x [ 1 ] = -1 ; y [ 1 ] = 3 ; x [ 2 ] = 4 ; y [ 2 ] = 3 ; cout << countLineSegments ( x , y ) ; return 0 ; }
bool pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; }
int main ( ) { int a = 1 , b = 2 , c = 2 , d = 3 ; if ( pythagorean_quadruple ( a , b , c , d ) ) cout << " Yes " << endl ; else cout << " No " << endl ; }
float volume ( float r , float R , float h ) { return ( float ( 1 ) / float ( 3 ) ) * pi * h * ( r * r + R * R + r * R ) ; }
float curved_surface_area ( float r , float R , float l ) { return pi * l * ( R + r ) ; }
float total_surface_area ( float r , float R , float l , float h ) { return pi * l * ( R + r ) + pi * ( r * r + R * R ) ; }
int main ( ) { float small_radius = 3 ; float big_radius = 8 ; float slant_height = 13 ; float height = 12 ;
cout << " Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " << volume ( small_radius , big_radius , height ) << endl ; cout << " Curved ▁ Surface ▁ Area ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " << curved_surface_area ( small_radius , big_radius , slant_height ) << endl ; cout << " Total ▁ Surface ▁ Area ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " << total_surface_area ( small_radius , big_radius , slant_height , height ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Circumference ( int a ) { return 4 * a ; }
int main ( ) { int a = 5 ; cout << " Circumference ▁ of " << " ▁ a ▁ square ▁ is ▁ " << Circumference ( a ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; double maxArea ( double a , double b , double c , double d ) {
double semiperimeter = ( a + b + c + d ) / 2 ;
return sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; }
int main ( ) { double a = 1 , b = 2 , c = 1 , d = 2 ; cout << maxArea ( a , b , c , d ) ; return 0 ; }
int minRadius ( int k , int x [ ] , int y [ ] , int n ) { int dis [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ;
sort ( dis , dis + n ) ; return dis [ k - 1 ] ; }
int main ( ) { int k = 3 ; int x [ ] = { 1 , -1 , 1 } ; int y [ ] = { 1 , -1 , -1 } ; int n = sizeof ( x ) / sizeof ( x [ 0 ] ) ; cout << minRadius ( k , x , y , n ) << endl ; return 0 ; }
int areaRectangle ( int a , int b ) { int area = a * b ; return area ; } int perimeterRectangle ( int a , int b ) { int perimeter = 2 * ( a + b ) ; return perimeter ; }
int main ( ) { int a = 5 ; int b = 6 ; cout << " Area ▁ = ▁ " << areaRectangle ( a , b ) << endl ; cout << " Perimeter ▁ = ▁ " << perimeterRectangle ( a , b ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int areaSquare ( int side ) { int area = side * side ; return area ; }
int main ( ) { int side = 4 ; cout << areaSquare ( side ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minPerimeter ( int n ) { int l = sqrt ( n ) ; int sq = l * l ;
if ( sq == n ) return l * 4 ; else {
long long int row = n / l ;
long long int perimeter = 2 * ( l + row ) ;
if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } }
int main ( ) { int n = 10 ; cout << minPerimeter ( n ) ; return 0 ; }
void possibleOrNot ( long long a1 , long long a2 , long long b1 , long long b2 , long long c1 , long long c2 ) {
long long dis1 = pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ; long long dis2 = pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ;
if ( dis1 != dis2 ) cout << " No " ;
else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) cout << " No " ; else cout < < " Yes " ; }
long long a1 = 1 , a2 = 0 , b1 = 2 , b2 = 0 , c1 = 3 , c2 = 0 ; possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return -1 ; else return 0 ; }
int main ( ) { int x1 = -10 , y1 = 8 ; int x2 = 14 , y2 = -24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) cout << " Circle ▁ touch ▁ to " << " ▁ each ▁ other . " ; else if ( t < 0 ) cout << " Circle ▁ not ▁ touch " << " ▁ to ▁ each ▁ other . " ; else cout << " Circle ▁ intersect " << " ▁ to ▁ each ▁ other . " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countObtuseAngles ( int a , int b , int k ) {
int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ;
if ( c1 == c2 ) return 0 ;
return min ( c1 , c2 ) ; }
int main ( ) { int k = 6 , a = 1 , b = 3 ; cout << countObtuseAngles ( a , b , k ) ; return 0 ; }
void findTriangle ( int a [ ] , int n ) { int b [ n + 2 ] ;
for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ;
sort ( a , a + n ) ; sort ( b , b + n ) ;
int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) {
while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = max ( q , p ) ;
while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ;
if ( b [ i ] + b [ j ] == b [ p ] ) {
x += max ( p - j - 1 , 0 ) ;
y ++ ;
z += q - p ; }
else {
x += max ( p - j , 0 ) ;
z += q - p ; } } } cout << " Acute ▁ Triangle : ▁ " << x << endl ; cout << " Right ▁ Triangle : ▁ " << y << endl ; cout << " Obtuse ▁ Triangle : ▁ " << z << endl ; }
int main ( ) { int arr [ ] = { 2 , 3 , 9 , 10 , 12 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findTriangle ( arr , n ) ; return 0 ; }
double polygonArea ( double X [ ] , double Y [ ] , int n ) {
double area = 0.0 ;
int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ;
}
return abs ( area / 2.0 ) ; }
int main ( ) { double X [ ] = { 0 , 2 , 4 } ; double Y [ ] = { 1 , 3 , 7 } ; int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << polygonArea ( X , Y , n ) ; }
void last_digit ( int X , int Y ) { cout << X % Y ; }
int main ( ) { int X = 55 , Y = 3 ; last_digit ( X , Y ) ; return 0 ; }
void printRoots ( long a , long b , long c ) { cout << 1 << " , ▁ " << c / ( a * 1.0 ) ; }
int main ( ) { long a = 2 ; long b = 3 ; long c = -5 ; printRoots ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 130 ;
bool validQuadruple ( int arr [ ] , int n ) {
if ( n >= MAX ) return true ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; }
int main ( ) { int arr [ ] = { 1 , 0 , 2 , 3 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( validQuadruple ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool solve ( int n , int k ) {
if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; }
int main ( ) { int n = 12 , k = 4 ; if ( solve ( n , k ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int closetAND ( int arr [ ] , int n , int k ) { int ans = INT_MAX ;
for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ;
ans = min ( ans , abs ( k - X ) ) ; } } return ans ; }
int main ( ) { int arr [ ] = { 4 , 7 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << closetAND ( arr , n , k ) ; return 0 ; }
float Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / float ( N1 ) ; return rate ; }
int main ( ) { int N1 = 100 , N2 = 120 ; cout << Rate ( N1 , N2 ) << " ▁ % " ; return 0 ; }
int getPrime ( int arr [ ] , int n ) {
int max_val = * max_element ( arr , arr + n ) ;
vector < bool > prime ( max_val + 1 , true ) ;
prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } }
int maximum = -1 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( prime [ arr [ i ] ] ) maximum = max ( maximum , arr [ i ] ) ; }
return maximum ; }
int main ( ) { int arr [ ] = { 2 , 10 , 15 , 7 , 6 , 8 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getPrime ( arr , n ) ; return 0 ; }
long getMinNum ( int N ) {
int lcm = 1 ; for ( int i = 2 ; i <= N ; i ++ ) lcm = ( ( i * lcm ) / ( __gcd ( i , lcm ) ) ) ;
return ( lcm + 1 ) ; }
int main ( ) { int N = 5 ; cout << getMinNum ( N ) ; return 0 ; }
int maxEdges ( int N ) { int edges = 0 ; edges = floor ( ( N * N ) / 4 ) ; return edges ; }
int main ( ) { int N = 5 ; cout << maxEdges ( N ) ; return 0 ; }
void Permutation ( int n , int k ) { int p [ n + 1 ] ;
for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ;
for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ;
p [ 1 ] = n - k ;
for ( int i = 1 ; i <= n ; i ++ ) cout << p [ i ] << " ▁ " ; }
int main ( ) { int n = 5 , k = 2 ; Permutation ( n , k ) ; return 0 ; }
int validPosition ( int arr [ ] , int N , int K ) { int count = 0 , sum = 0 ;
for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; }
for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; }
int main ( ) { int arr [ ] = { 2 , 1 , 6 , 7 } , K = 4 ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << validPosition ( arr , N , K ) ; return 0 ; }
int maxBitElement ( int arr [ ] , int n ) {
int num = 0 , max = -1 ; for ( int i = 0 ; i < n ; i ++ ) {
int cnt = __builtin_popcount ( arr [ i ] ) ;
if ( cnt > max ) { max = cnt ; num = arr [ i ] ; } } return num ; }
int main ( ) { int arr [ ] = { 3 , 2 , 4 , 7 , 1 , 10 , 5 , 8 , 9 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxBitElement ( arr , n ) << endl ; return 0 ; }
int smallestSum ( int n ) { if ( n == 1 ) return 0 ; return ( 2 * pow ( 10 , n - 1 ) ) ; }
int largestSum ( int n ) { return ( 2 * ( pow ( 10 , n ) - 1 ) ) ; }
int main ( ) { int n = 4 ; cout << " Largest ▁ = ▁ " << largestSum ( n ) << endl ; cout << " Smallest ▁ = ▁ " << smallestSum ( n ) ; return 0 ; }
int count_pairs ( int a [ ] , int b [ ] , int n , int m ) {
int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 ) odd1 ++ ; else even1 ++ ; }
for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 ) odd2 ++ ; else even2 ++ ; }
int pairs = min ( odd1 , even2 ) + min ( odd2 , even1 ) ;
return pairs ; }
int main ( ) { int a [ ] = { 9 , 14 , 6 , 2 , 11 } ; int b [ ] = { 8 , 4 , 7 , 20 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = sizeof ( b ) / sizeof ( b [ 0 ] ) ; cout << count_pairs ( a , b , n , m ) ; return 0 ; }
int find_leftmost_unsetbit ( int n ) { int ind = -1 ; int i = 1 ; while ( n ) { if ( ! ( n & 1 ) ) ind = i ; i ++ ; n >>= 1 ; } return ind ; }
void perform_steps ( int n ) {
int left = find_leftmost_unsetbit ( n ) ;
if ( left == -1 ) { cout << " No ▁ steps ▁ required " ; return ; }
int step = 1 ;
while ( find_leftmost_unsetbit ( n ) != -1 ) {
if ( step % 2 == 0 ) { n += 1 ; cout << " Step " << step << " : ▁ Increase ▁ by ▁ 1 STRNEWLINE " ; }
else {
int m = find_leftmost_unsetbit ( n ) ;
int num = pow ( 2 , m ) - 1 ;
n = n ^ num ; cout << " Step " << step << " : ▁ Xor ▁ with ▁ " << num << endl ; }
step += 1 ; } }
int main ( ) { int n = 39 ; perform_steps ( n ) ; return 0 ; }
int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = INT_MAX ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) {
if ( i == A i == B ) continue ;
else { int x = abs ( i - A ) ; int y = abs ( i - B ) ;
sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; }
int main ( ) { int N = 3 , A = 1 , B = 2 ;
cout << " Vertex ▁ = ▁ " << vertices ( N , A , B ) ; return 0 ; }
int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; }
int sumFactorial ( int * arr , int n ) {
int s = 0 , i ; for ( i = 0 ; i < n ; i ++ ) {
s += factorial ( arr [ i ] ) ; } return s ; }
int main ( ) { int arr [ ] = { 7 , 3 , 5 , 4 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumFactorial ( arr , n ) ; return 0 ; }
int highestPower ( string str , int len ) {
int ans = 0 ;
for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) ans ++ ; else break ; } return ans ; }
int main ( ) { string str = "100100" ; int len = str . length ( ) ; cout << highestPower ( str , len ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE #define mod  (ll)(1e9 + 7)
ll factorial ( ll n , ll p ) {
for ( int i = 2 ; i <= n ; i ++ ) res = ( res * i ) % p ; return res ; }
ll power ( ll x , ll y , ll p ) {
while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
ll modInverse ( ll n , ll p ) { return power ( n , p - 2 , p ) ; }
ll nCrModP ( ll n , ll r , ll p ) {
if ( r == 0 ) return 1 ;
ll fac [ n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p ; }
ll countArrangements ( ll n , ll k , ll p ) { return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p ; }
int main ( ) { ll N = 5 , K = 8 ;
cout << countArrangements ( N , K , mod ) ; return 0 ; }
int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; }
int main ( ) { int N = 390 ; cout << maxProd ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  2 NEW_LINE #define M  3
bool check ( int mat [ N ] [ M ] ) { int xorr = 0 ;
for ( int i = 0 ; i < N ; i ++ ) { xorr ^= mat [ i ] [ 0 ] ; }
if ( xorr != 0 ) return true ;
for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) {
if ( mat [ i ] [ j ] != mat [ i ] [ 0 ] ) return true ; } } return false ; }
int main ( ) { int mat [ N ] [ M ] = { { 7 , 7 , 7 } , { 10 , 10 , 7 } } ; if ( check ( mat ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int sumodd ( int n ) { return ( n * n ) ; }
int sumeven ( int n ) { return ( n * ( n + 1 ) ) ; }
int findSum ( int num ) {
int sumo = 0 ;
int sume = 0 ;
int x = 1 ;
int cur = 0 ;
int ans = 0 ; while ( num > 0 ) {
int inc = min ( x , num ) ;
num -= inc ;
if ( cur == 0 ) {
ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) ;
sumo += inc ; }
else {
ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) ;
sume += inc ; }
x *= 2 ;
cur ^= 1 ; } return ans ; }
int main ( ) { int n = 4 ; cout << findSum ( n ) ; return 0 ; }
int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; }
int main ( ) { int N = 3 ; cout << oddTriangularNumber ( N ) ; return 0 ; }
void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) cout << " The ▁ given ▁ straight " << " ▁ lines ▁ are ▁ identical " << endl ; else cout << " The ▁ given ▁ straight " << " ▁ lines ▁ are ▁ not ▁ identical " << endl ; }
int main ( ) { double a1 = -2 , b1 = 4 , c1 = 3 , a2 = -6 , b2 = 12 , c2 = 9 ; idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) ; return 0 ; }
void line ( double x0 , double y0 ) { double c = 2 * y0 * x0 ; cout << y0 << " x " << " ▁ + ▁ " << x0 << " y ▁ = ▁ " << c ; }
int main ( ) { double x0 = 4 , y0 = 3 ; line ( x0 , y0 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3 NEW_LINE #define M  7
void printOriginalMatrix ( int a [ ] , int b [ ] , int mat [ N ] [ M ] ) {
for ( int i = 0 ; i < N ; i ++ ) {
for ( int j = 0 ; j < M ; j ++ ) {
if ( mat [ i ] [ j ] == 1 ) cout << min ( a [ i ] , b [ j ] ) << " ▁ " ; else cout << 0 << " ▁ " ; } cout << endl ; } }
int main ( ) { int a [ ] = { 2 , 1 , 3 } ; int b [ ] = { 2 , 3 , 0 , 0 , 2 , 0 , 1 } ; int mat [ N ] [ M ] = { { 1 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { 1 , 1 , 0 , 0 , 0 , 0 , 0 } } ; printOriginalMatrix ( a , b , mat ) ; return 0 ; }
float percent ( int n , int x ) { float p = n * x ; p /= 100 ; return p ; }
float getLoss ( int price [ ] , int quantity [ ] , int X [ ] , int n ) {
float loss = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
float originalPrice = price [ i ] ;
float sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ;
float afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ;
loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; } return loss ; }
int main ( ) { int price [ ] = { 20 , 48 , 200 , 100 } ; int quantity [ ] = { 20 , 48 , 1 , 1 } ; int X [ ] = { 0 , 48 , 200 , 5 } ;
int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; cout << getLoss ( price , quantity , X , n ) ; return 0 ; }
int maxAbsDiff ( int arr [ ] , int n ) {
int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = min ( minEle , arr [ i ] ) ; maxEle = max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; }
int main ( ) { int arr [ ] = { 2 , 1 , 5 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxAbsDiff ( arr , n ) ; return 0 ; }
int maxSubArraySum ( int a [ ] , int size ) {
int max_so_far = INT_MIN , max_ending_here = 0 ;
for ( int i = 0 ; i < size ; i ++ ) {
max_ending_here = max_ending_here + a [ i ] ;
if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ;
if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; }
int maximizeSum ( int a [ ] , int n ) { int cnt = 0 ; int mini = INT_MAX ; int minSubarray = INT_MAX ;
int sum = maxSubArraySum ( a , n ) ; int max_so_far = INT_MIN , max_ending_here = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
max_ending_here = max_ending_here + a [ i ] ; cnt ++ ; minSubarray = min ( a [ i ] , minSubarray ) ;
if ( sum == max_ending_here ) {
if ( cnt == 1 ) mini = min ( mini , 0 ) ;
else mini = min ( mini , minSubarray ) ; }
if ( max_ending_here < 0 ) {
max_ending_here = 0 ; cnt = 0 ; minSubarray = INT_MAX ; } } return sum - mini ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 , -2 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << maximizeSum ( a , n ) ; return 0 ; }
bool isOsiris ( int n ) {
int a = n % 10 ;
int b = ( n / 10 ) % 10 ;
int c = n / 100 ; int digit_sum = a + b + c ;
if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; }
int main ( ) { int n = 132 ; if ( isOsiris ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool isDudeney ( int n ) { int cube_rt = int ( round ( ( pow ( n , 1.0 / 3.0 ) ) ) ) ;
if ( cube_rt * cube_rt * cube_rt != n ) return false ; int dig_sum = 0 ; int temp = n ; while ( temp > 0 ) {
int rem = temp % 10 ;
dig_sum += rem ;
temp /= 10 ; }
if ( cube_rt != dig_sum ) return false ; return true ; }
int main ( ) { int n = 17576 ; if ( isDudeney ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int countTriangles ( int a [ ] , int n ) {
int cnt = 0 ;
int pairs = 0 ;
for ( int i = n - 1 ; i >= 0 ; i -- ) {
pairs += a [ i ] / 2 ;
if ( a [ i ] % 2 == 1 && pairs > 0 ) {
cnt += 1 ;
pairs -= 1 ; } }
cnt += ( 2 * pairs ) / 3 ; return cnt ; }
int main ( ) { int a [ ] = { 1 , 2 , 2 , 2 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countTriangles ( a , n ) ; return 0 ; }
int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return pow ( 10 , n - 1 ) ; }
int main ( ) { int n = 4 ; cout << smallestMultiple ( n ) ; return 0 ; }
int getHCF ( int x , int y ) {
int minimum = min ( x , y ) ;
if ( x % minimum == 0 && y % minimum == 0 ) return minimum ;
for ( int i = minimum / 2 ; i >= 2 ; i -- ) {
if ( x % i == 0 && y % i == 0 ) return i ; }
return 1 ; }
int main ( ) { int x = 16 , y = 32 ; cout << getHCF ( x , y ) ; return 0 ; }
bool isPrime ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isDivisible ( int n ) { if ( isPrime ( n + 1 ) ) return false ; return true ; }
int main ( ) { int n = 6 ; if ( isDivisible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int R = 5 ; const int C = 5 ;
int findMaxCock ( int ar [ R ] [ C ] ) {
if ( R < 3 C < 3 ) return -1 ;
int max_sum = INT_MIN ;
for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) {
int sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ;
max_sum = max ( max_sum , sum ) ; } } return max_sum ; }
int main ( ) { int ar [ ] [ C ] = { { 0 , 3 , 0 , 6 , 0 } , { 0 , 1 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 0 } , { 0 , 0 , 2 , 0 , 1 } , { 0 , 2 , 0 , 1 , 3 } } ; cout << findMaxCock ( ar ) ; return 0 ; }
int segments ( int n , int p [ ] , int m ) { map < int , int > c ; c [ 0 ] = 1 ; bool has = false ; int sum = 0 ; long long ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) {
if ( p [ r ] < m ) sum -- ;
else if ( p [ r ] > m ) sum ++ ;
if ( p [ r ] == m ) has = true ;
if ( has ) ans += c [ sum ] + c [ sum - 1 ] ;
else c [ sum ] ++ ; } return ans ; }
int main ( ) { int a [ ] = { 2 , 4 , 5 , 3 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = 4 ; cout << segments ( n , a , m ) ; return 0 ; }
int oddDays ( int N ) {
int hund1 = N / 100 ; int hund4 = N / 400 ;
int leap = N >> 2 ; int ord = N - leap ;
if ( hund1 ) { ord += hund1 ; leap -= hund1 ; }
if ( hund4 ) { ord -= hund4 ; leap += hund4 ; }
int days = ord + leap * 2 ;
int odd = days % 7 ; return odd ; }
int N = 100 ; cout << oddDays ( N ) ; return 0 ; }
float ellipsearea ( float r ) {
if ( r < 0 ) return -1 ;
float a = ( 3.14 * r * r ) / 4 ; return a ; }
int main ( ) { float r = 5 ; cout << ellipsearea ( r ) << endl ; return 0 ; }
int CntDivbyX ( int arr [ ] , int n , int x ) {
int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
number = number * 2 + arr [ i ] ;
if ( ( number % x == 0 ) ) count += 1 ; } return count ; }
int main ( ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 2 ; cout << CntDivbyX ( arr , n , x ) ; return 0 ; }
int countCon ( int ar [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {
if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; }
int main ( ) { int ar [ ] = { 1 , 2 , 2 , 3 , 4 , 4 , 5 , 5 , 5 , 5 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << countCon ( ar , n ) ; return 0 ; }
void reduceFraction ( int x , int y ) { int d ; d = __gcd ( x , y ) ; x = x / d ; y = y / d ; cout << " x ▁ = ▁ " << x << " , ▁ y ▁ = ▁ " << y << endl ; }
int main ( ) { int x = 16 ; int y = 10 ; reduceFraction ( x , y ) ; return 0 ; }
float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; }
int main ( ) { int T1 = 3 , N1 = 5 , T2 = 6 ; cout << noOfYears ( T1 , N1 , T2 ) ; return 0 ; }
bool isPossible ( int n ) {
int fac [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ;
int sum = 0 ;
int x = n ;
while ( x ) { sum += fac [ x % 10 ] ; x /= 10 ; }
if ( sum % n == 0 ) return true ; return false ; }
int main ( ) { int n = 19 ; if ( isPossible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
void findSubsequence ( int * arr , int n , int k ) {
map < int , int > M ;
for ( int i = 0 ; i < n ; ++ i ) ++ M [ arr [ i ] ] ;
int * numCount = new int [ k + 1 ] ; for ( int i = 0 ; i <= k ; ++ i ) numCount [ i ] = 0 ;
for ( auto p : M ) { if ( p . first <= k ) {
for ( int i = 1 ; ; ++ i ) { if ( p . first * i > k ) break ;
numCount [ p . first * i ] += p . second ; } } else break ; } int lcm = 0 , length = 0 ;
for ( int i = 1 ; i <= k ; ++ i ) { if ( numCount [ i ] > length ) { length = numCount [ i ] ; lcm = i ; } }
if ( lcm == 0 ) cout << -1 << endl ; else {
cout << " LCM ▁ = ▁ " << lcm << " , ▁ Length ▁ = ▁ " << length << endl ; cout << " Indexes ▁ = ▁ " ; for ( int i = 0 ; i < n ; ++ i ) if ( lcm % arr [ i ] == 0 ) cout << i << " ▁ " ; } }
int main ( ) { int k = 14 ; int arr [ ] = { 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; findSubsequence ( arr , n , k ) ; return 0 ; }
ll power ( ll x , ll y , ll p ) {
while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
ll findCount ( ll N ) { int count = power ( 2 , N , mod ) ; return count ; }
int main ( ) { ll N = 25 ; cout << findCount ( N ) ; return 0 ; }
int msb ( int x ) { int ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; }
int xorRange ( int l , int r ) {
int max_bit = msb ( r ) ;
int mul = 2 ;
int ans = 0 ;
for ( int i = 1 ; i <= max_bit ; i ++ ) {
if ( ( l / mul ) * mul == ( r / mul ) * mul ) { if ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ans += mul ; mul *= 2 ; continue ; }
bool odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ;
if ( odd_c ) ans += mul ;
mul *= 2 ; }
int zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) / 2 ; if ( l % 2 == 1 && r % 2 == 1 ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans ++ ; return ans ; }
int main ( ) { int l = 1 , r = 4 ;
cout << xorRange ( l , r ) ; return 0 ; }
long computeXOR ( const int n ) {
switch ( n & 3 ) {
case 0 : return n ;
case 1 : return 1 ;
case 2 : return n + 1 ;
case 3 : return 0 ; } }
int main ( ) { int l = 1 , r = 4 ; cout << ( computeXOR ( r ) ^ computeXOR ( l - 1 ) ) ; return 0 ; }
int countNumbers ( int x , int n ) {
if ( x > n ) return 0 ;
return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; }
int main ( ) { int n = 120 ; cout << countNumbers ( 1 , n ) ; return 0 ; }
bool checkfact ( int N , int countprime , int prime ) { int countfact = 0 ; if ( prime == 2 prime == 3 ) countfact ++ ; int divide = prime ;
while ( N / divide != 0 ) { countfact += N / divide ; divide = divide * divide ; } if ( countfact >= countprime ) return true ; else return false ; }
bool check ( int N ) {
int sumsquares = ( N + 1 ) * ( 2 * N + 1 ) ; int countprime = 0 ;
for ( int i = 2 ; i <= sqrt ( sumsquares ) ; i ++ ) { int flag = 0 ; while ( sumsquares % i == 0 ) { flag = 1 ; countprime ++ ; sumsquares /= i ; } if ( flag ) { if ( ! checkfact ( N - 1 , countprime , i ) ) return false ; countprime = 0 ; } }
if ( sumsquares != 1 ) if ( ! checkfact ( N - 1 , 1 , sumsquares ) ) return false ; return true ; }
int main ( ) { int N = 5 ; if ( check ( N ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countNonIncreasing ( int arr [ ] , int n ) {
int cnt = 0 ;
int len = 1 ;
for ( int i = 0 ; i < n - 1 ; ++ i ) {
if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ;
else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } }
if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; }
int main ( ) { int arr [ ] = { 5 , 2 , 3 , 7 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countNonIncreasing ( arr , n ) ; return 0 ; }
int printPermutation ( int n ) {
if ( n % 2 != 0 ) cout << -1 ;
else for ( int i = 1 ; i <= n / 2 ; i ++ ) cout << 2 * i << " ▁ " << 2 * i - 1 << " ▁ " ; }
int main ( ) { int n = 4 ; printPermutation ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  10000000
int minimumSteps ( int n , int m , int a , int b ) {
if ( n > m ) return MAXN ;
if ( n == m ) return 0 ;
return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; }
int main ( ) { int n = 120 , m = 51840 ; int a = 2 , b = 3 ; cout << minimumSteps ( n , m , a , b ) ; return 0 ; }
int minOperations ( int n , int m ) { if ( m % n != 0 ) return -1 ; int minOperations = 0 ; int q = m / n ;
while ( q % 2 == 0 ) { q = q / 2 ; minOperations ++ ; }
while ( q % 3 == 0 ) { q = q / 3 ; minOperations ++ ; }
if ( q == 1 ) return minOperations ; return -1 ; }
int main ( ) { int n = 120 , m = 51840 ; cout << minOperations ( n , m ) ; return 0 ; }
int fib ( int n ) { double phi = ( 1 + sqrt ( 5 ) ) / 2 ; return round ( pow ( phi , n ) / sqrt ( 5 ) ) ; }
ll calculateSum ( int l , int r ) {
ll sum = 0 ;
for ( int i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; }
int main ( ) { int l = 4 , r = 8 ; cout << calculateSum ( l , r ) ; return 0 ; }
float sphereSide ( float h , float r ) {
if ( h < 0 && r < 0 ) return -1 ;
float R = ( ( h * r * sqrt ( 2 ) ) / ( h + sqrt ( 2 ) * r ) ) / 2 ; return R ; }
int main ( ) { float h = 5 , r = 6 ; cout << sphereSide ( h , r ) << endl ; return 0 ; }
int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; }
int main ( ) { int n = 20 ; cout << possibleways ( n ) ; return 0 ; }
int countSubarrays ( const int * arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) {
ll product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ;
if ( product % K == 0 ) count ++ ; } } return count ; }
int main ( ) { int arr [ ] = { 6 , 2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 4 ; cout << countSubarrays ( arr , n , K ) ; return 0 ; }
void printMaxValPair ( vector < long long > & v , int n ) { sort ( v . begin ( ) , v . end ( ) ) ;
long long N = v [ n - 1 ] ;
if ( N % 2 == 1 ) { long long first_maxima = N / 2 ; long long second_maxima = first_maxima + 1 ; long long ans1 = 3e18 , ans2 = 3e18 ; long long from_left = -1 , from_right = -1 ; long long from = -1 ; for ( long long i = 0 ; i < n ; ++ i ) { if ( v [ i ] > first_maxima ) { from = i ; break ; } else { long long diff = first_maxima - v [ i ] ; if ( diff < ans1 ) { ans1 = diff ; from_left = v [ i ] ; } } } from_right = v [ from ] ; long long diff1 = first_maxima - from_left ; long long diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) cout << N << " ▁ " << from_left ; else cout << N << " ▁ " << from_right ; }
else { long long maxima = N / 2 ; long long ans1 = 3e18 ; long long R = -1 ; for ( long long i = 0 ; i < n - 1 ; ++ i ) { long long diff = abs ( v [ i ] - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v [ i ] ; } } cout << N << " ▁ " << R ; } }
int main ( ) { vector < long long > v = { 1 , 1 , 2 , 3 , 6 , 1 } ; int n = v . size ( ) ; printMaxValPair ( v , n ) ; return 0 ; }
int Permutations ( int n , int k ) {
int ans = 1 ;
if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ;
if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ;
if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; }
int main ( ) { int n = 5 , k = 2 ; cout << Permutations ( n , k ) ; return 0 ; }
ll power ( ll a , ll n ) { if ( n == 0 ) return 1 ; ll p = power ( a , n / 2 ) ; p = p * p ; if ( n & 1 ) p = p * a ; return p ; }
int countIntegers ( ll l , ll r ) { ll ans = 0 , i = 1 ; ll v = power ( 2 , i ) ; while ( v <= r ) { while ( v <= r ) { if ( v >= l ) ans ++ ; v = v * 3 ; } i ++ ; v = power ( 2 , i ) ; } if ( l == 1 ) ans ++ ; return ans ; }
int main ( ) { ll l = 12 , r = 21 ; cout << countIntegers ( l , r ) ; return 0 ; }
int findPairCount ( int N , int K ) { int count = 0 ;
int rem [ K ] ; rem [ 0 ] = N / K ;
for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ;
if ( K % 2 == 0 ) {
count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ;
for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ;
count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else {
count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ;
for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; }
int main ( ) { int N = 10 , K = 4 ;
cout << findPairCount ( N , K ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005
bool prime [ N ] ;
void sieve ( ) { memset ( prime , true , sizeof prime ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) if ( prime [ i ] ) for ( int j = i * 2 ; j < N ; j += i ) prime [ j ] = false ; }
int sumTruncatablePrimes ( int n ) {
int sum = 0 ;
for ( int i = 2 ; i < n ; i ++ ) { int num = i ; bool flag = true ;
while ( num ) {
if ( ! prime [ num ] ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ;
while ( num / power ) {
if ( ! prime [ num % power ] ) { flag = false ; break ; } power *= 10 ; }
if ( flag ) sum += i ; }
return sum ; }
int main ( ) { int n = 25 ; sieve ( ) ; cout << sumTruncatablePrimes ( n ) ; return 0 ; }
void nDigitPerfectSquares ( int n ) {
cout << pow ( ceil ( sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) << " ▁ " ;
cout << pow ( ceil ( sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ; }
int main ( ) { int n = 4 ; nDigitPerfectSquares ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  3
int MaxTraceSub ( int mat [ ] [ N ] ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ;
while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ;
max_trace = max ( trace , max_trace ) ; } } }
return max_trace ; }
int main ( ) { int mat [ N ] [ N ] = { { 10 , 2 , 5 } , { 6 , 10 , 4 } , { 2 , 7 , -10 } } ; cout << MaxTraceSub ( mat ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define n  3 NEW_LINE #define m  3
bool check ( int a [ n ] [ m ] , int b [ n ] [ m ] ) {
for ( int i = 0 ; i < n ; i ++ ) { vector < int > v1 , v2 ; int r = i ; int col = 0 ;
while ( r >= 0 && col < m ) {
v1 . push_back ( a [ r ] [ col ] ) ; v2 . push_back ( b [ r ] [ col ] ) ;
r -- ; col ++ ; }
sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ;
for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) { if ( v1 [ i ] != v2 [ i ] ) return false ; } }
for ( int j = 1 ; j < m ; j ++ ) { vector < int > v1 , v2 ; int r = n - 1 ; int col = j ;
while ( r >= 0 && col < m ) {
v1 . push_back ( a [ r ] [ col ] ) ; v2 . push_back ( b [ r ] [ col ] ) ; r -- ; col ++ ; }
sort ( v1 . begin ( ) , v1 . end ( ) ) ; sort ( v2 . begin ( ) , v2 . end ( ) ) ;
for ( int i = 0 ; i < v1 . size ( ) ; i ++ ) { if ( v1 [ i ] != v2 [ i ] ) return false ; } }
return true ; }
int main ( ) { int a [ n ] [ m ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int b [ n ] [ m ] = { { 1 , 4 , 7 } , { 2 , 5 , 6 } , { 3 , 8 , 9 } } ; if ( check ( a , b ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
void lastDigit ( string a , string b ) { int lastDig = ( a [ a . length ( ) - 1 ] - '0' ) * ( b [ b . length ( ) - 1 ] - '0' ) ; cout << lastDig % 10 ; }
int main ( ) { string a = "1234567891233" , b = "1234567891233156" ; lastDigit ( a , b ) ; return 0 ; }
void printPalindrome ( int n ) { if ( n == 1 ) { cout << " Smallest ▁ Palindrome : ▁ 0" << endl ; cout << " Largest ▁ Palindrome : ▁ 9" ; } else { cout << " Smallest ▁ Palindrome : ▁ " << pow ( 10 , n - 1 ) + 1 ; cout << " Largest Palindrome : " } }
int main ( ) { int n = 4 ; printPalindrome ( n ) ; return 0 ; }
int printSum ( int a , int b ) { int res = 0 ; int temp1 = 0 , temp2 = 0 ;
while ( a ) { temp1 = temp1 * 10 + ( a % 10 ) ; a /= 10 ; } a = temp1 ;
while ( b ) { temp2 = temp2 * 10 + ( b % 10 ) ; b /= 10 ; } b = temp2 ;
while ( a ) {
int sum = ( a % 10 + b % 10 ) ;
if ( sum / 10 == 0 ) res = res * 10 + sum ; else {
temp1 = 0 ; while ( sum ) { temp1 = temp1 * 10 + ( sum % 10 ) ; sum /= 10 ; } sum = temp1 ;
while ( sum ) { res = res * 10 + ( sum % 10 ) ; sum /= 10 ; } } a /= 10 ; b /= 10 ; } return res ; }
int main ( ) { int a = 7752 , b = 8834 ; cout << printSum ( a , b ) ; return 0 ; }
int countDigits ( int a , int b ) { int count = 0 ;
int p = abs ( a / b ) ;
if ( p == 0 ) return 1 ;
while ( p > 0 ) { count ++ ; p = p / 10 ; }
return count ; }
int main ( ) { int a = 100 ; int b = 10 ; cout << countDigits ( a , b ) ; return 0 ; }
int countDigits ( int a , int b ) {
return floor ( log10 ( abs ( a ) ) - log10 ( abs ( b ) ) ) + 1 ; }
int main ( ) { int a = 100 ; int b = 10 ; cout << countDigits ( a , b ) ; return 0 ; }
int smallestOdd ( int n ) { if ( n == 1 ) return 1 ; return pow ( 10 , n - 1 ) + 1 ; }
int main ( ) { int n = 4 ; cout << smallestOdd ( n ) ; return 0 ; }
void findNumbers ( int n ) { int odd = pow ( 10 , n ) - 1 ; int even = odd - 1 ; cout << " Even ▁ = ▁ " << even << endl ; cout << " Odd ▁ = ▁ " << odd ; }
int main ( ) { int n = 4 ; findNumbers ( n ) ; return 0 ; }
int longestSubArray ( int arr [ ] , int n ) { bool isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 0 , 1 , 2 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << longestSubArray ( arr , n ) ; return 0 ; }
int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return pow ( 10 , n - 1 ) ; }
int main ( ) { int n = 4 ; cout << smallestEven ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
int maxProfit ( int n , int a , int b , int x , int y ) { int res = x * ( n / a ) ; res += y * ( n / b ) ;
res -= min ( x , y ) * ( n / ( ( a * b ) / __gcd ( a , b ) ) ) ; return res ; }
int main ( ) { int n = 6 , a = 6 , b = 2 , x = 8 , y = 2 ; cout << maxProfit ( n , a , b , x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE #define MOD  1000000007
int sumOfSeries ( int n ) { ll ans = ( ll ) pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; }
int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
int kthOdd ( int arr [ ] , int n , int k ) {
for ( int i = 0 ; i <= n ; i ++ ) {
if ( ( arr [ i ] % 2 ) == 1 ) k -- ;
if ( k == 0 ) return arr [ i ] ; }
return -1 ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; cout << ( kthOdd ( arr , n , k ) ) ; return 0 ; }
int lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } printf ( " % 05d " , ans ) ; }
int main ( ) { int n = 12345 ; lastFiveDigits ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE using namespace std ; const int mod = 1000000007 ;
ll power ( ll a , ll n ) { if ( n == 0 ) return 1 ; ll p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n & 1 ) { p = ( p * a ) % mod ; } return p ; }
ll computeSum ( int * arr , int n ) {
sort ( arr , arr + n ) ; ll sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
ll maxs = ( power ( 2 , i ) - 1 + mod ) % mod ; maxs = ( maxs * arr [ i ] ) % mod ;
ll mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod ; mins = ( mins * arr [ i ] ) % mod ; ll V = ( maxs - mins + mod ) % mod ; sum = ( sum + V ) % mod ; } return sum ; }
int main ( ) { int arr [ ] = { 4 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << computeSum ( arr , n ) ; return 0 ; }
int countNumbers ( int n ) {
if ( n % 2 == 1 ) return 0 ; return ( 9 * pow ( 10 , n / 2 - 1 ) ) ; }
int main ( ) { int n = 2 ; cout << countNumbers ( n ) ; return 0 ; }
int count ( int n ) {
int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ;
p *= 2 ; } return cnt ; }
int main ( ) { int n = 7 ; cout << count ( n ) ; return 0 ; }
int KthMinValAfterMconcatenate ( int A [ ] , int N , int M , int K ) {
sort ( A , A + N ) ;
return ( A [ ( ( K - 1 ) / M ) ] ) ; }
int main ( ) { int A [ ] = { 3 , 1 , 2 } ; int M = 3 , K = 4 ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << KthMinValAfterMconcatenate ( A , N , M , K ) ; return 0 ; }
int sumN ( int n ) {
n = ( n + 1 ) / 2 ;
return ( n * n ) ; }
int main ( ) { int n = 3 ; cout << sumN ( n ) ; return 0 ; }
int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; }
int main ( ) { int n = 20 ; cout << countNumbers ( n ) ; return 0 ; }
int maxPrimes ( int n ) {
return n / 2 ; }
int main ( ) { int n = 17 ; cout << maxPrimes ( n ) ; return 0 ; }
int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; }
int main ( ) { int n = 2 ; cout << sum ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
int findMinimum ( int n , int m ) { int mini = m ;
for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int sec = n / i ;
if ( __gcd ( m , i ) > 1 ) { return i ; }
else if ( __gcd ( sec , m ) > 1 ) { mini = min ( sec , mini ) ; } } }
if ( mini == m ) return -1 ; else return mini ; }
int main ( ) { int n = 8 , m = 10 ; cout << findMinimum ( n , m ) ; return 0 ; }
int nthTerm ( int N ) { int nth = 0 , i ;
for ( i = N ; i > 0 ; i -- ) { nth += pow ( i , i ) ; } return nth ; }
int main ( ) { int N = 3 ; cout << nthTerm ( N ) << endl ; return 0 ; }
int kthSmallest ( int n , int k ) { return ( 2 * k ) ; }
int main ( ) { int n = 8 , k = 4 ; cout << kthSmallest ( n , k ) ; return 0 ; }
bool isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; }
int main ( ) { int n = 10 ; if ( isSumOfPowersOfTwo ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int findMinRemoval ( int arr [ ] , int n ) {
int temp , value = 0 ;
int maximum = 0 ;
if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( i != 0 && i != n - 1 ) { value = value + abs ( arr [ i ] - arr [ i + 1 ] ) ;
temp = abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = max ( maximum , temp ) ; }
return ( value - maximum ) ; }
int main ( ) { int arr [ ] = { 1 , 5 , 3 , 2 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinRemoval ( arr , n ) << " STRNEWLINE " ; return 0 ; }
double getTime ( int u , int v , int x ) { double speed = u + v ;
double time = x / speed ; return time ; }
int main ( ) { double u = 3 , v = 3 , x = 3 ; cout << getTime ( u , v , x ) ; return 0 ; }
int number_of_teams ( int M ) {
sqr = sqrt ( 1 + ( 8 * M ) ) ;
N1 = ( 1 + sqr ) / 2 ;
N2 = ( 1 - sqr ) / 2 ;
if ( N1 > 0 ) return N1 ; return N2 ; }
int main ( ) { int M = 45 ; cout << number_of_teams ( M ) ; return 0 ; }
int LucasSum ( int N ) {
int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; int c = a + b ; a = b ; b = c ; } return sum ; }
int main ( ) { int N = 20 ; cout << LucasSum ( N ) ; return 0 ; }
int countNumbers ( int l , int r ) {
return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; }
int main ( ) { int l = 1000 , r = 6000 ; cout << countNumbers ( l , r ) ; return 0 ; }
int findMinSum ( int arr [ ] , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * pow ( 2 , occ ) ; occ -- ; } return sum ; }
int main ( ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinSum ( arr , n ) ; return 0 ; }
int countNumbers ( int X , int Y , int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) {
if ( ( i % X == 0 ) && ( i % Y != 0 ) ) count ++ ; } return count ; }
int main ( ) { int X = 2 , Y = 3 , N = 10 ; cout << countNumbers ( X , Y , N ) ; return 0 ; }
int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; }
int main ( ) { int n = 8 , m = 5 ; cout << getPosition ( n , m ) ; return 0 ; }
int parity ( int a ) { return a % 3 ; }
int solve ( int array [ ] , int size ) { int operations = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) {
if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) {
int pari1 = parity ( array [ i ] ) ;
int pari2 = parity ( array [ i + 2 ] ) ;
if ( pari1 == pari2 ) { if ( pari1 == 0 ) array [ i + 1 ] = 1 ; else if ( pari1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( pari1 == 0 && pari2 == 1 ) || ( pari1 == 1 && pari2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( pari1 == 1 && pari2 == 2 ) || ( pari1 == 2 && pari2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( pari1 == 2 && pari2 == 0 ) || ( pari1 == 0 && pari2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; }
int main ( ) { int array [ ] = { 2 , 1 , 3 , 0 } ; int size = sizeof ( array ) / sizeof ( array [ 0 ] ) ; cout << solve ( array , size ) << endl ; return 0 ; }
int submatrixXor ( int arr [ ] [ n ] ) { int ans = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
int top_left = ( i + 1 ) * ( j + 1 ) ;
int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; }
int main ( ) { int arr [ ] [ n ] = { { 6 , 7 , 13 } , { 8 , 3 , 4 } , { 9 , 7 , 6 } } ; cout << submatrixXor ( arr ) ; return 0 ; }
int findDigitalRoot ( int num ) { int sum = INT_MAX , tempNum = num ; while ( sum >= 10 ) { sum = 0 ; while ( tempNum > 0 ) { sum += tempNum % 10 ; tempNum /= 10 ; } tempNum = sum ; } return sum ; }
void findAnswer ( int X , int N ) {
int counter = 0 ; for ( int i = 1 ; counter < N ; ++ i ) {
int digitalRoot = findDigitalRoot ( i ) ;
if ( digitalRoot == X ) { ++ counter ; }
if ( counter == N ) { cout << i ; break ; } } }
int main ( ) { int X = 1 , N = 3 ; findAnswer ( X , N ) ; return 0 ; }
int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; }
int main ( ) { int X = 7 , N = 43 ; cout << findAnswer ( X , N ) ; return 0 ; }
long long int count ( int N , int K , int R ) { long long int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) {
if ( i % K == R )
sum += i ; }
return sum ; }
int main ( ) { int N = 20 , K = 4 , R = 3 ; cout << count ( N , K , R ) ; return 0 ; }
int getCount ( int a , int b , int c ) { int count = 0 ;
for ( int i = 1 ; i <= 81 ; i ++ ) {
int cr = b * pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ;
while ( tmp ) { sm += tmp % 10 ; tmp /= 10 ; }
if ( sm == i && cr < 1e9 ) count ++ ; }
return count ; }
int main ( ) { int a = 3 , b = 2 , c = 8 ; cout << getCount ( a , b , c ) ; return 0 ; }
bool isSpiltPossible ( int n , int a [ ] ) { int sum = 0 , c1 = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } }
if ( sum % 2 ) return false ;
if ( ( sum / 2 ) % 2 == 0 ) return true ;
if ( c1 > 0 ) return true ; else return false ; }
int main ( ) { int n = 3 ; int a [ ] = { 1 , 1 , 2 } ; if ( isSpiltPossible ( n , a ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int matrixSum ( int arr [ ] [ n ] ) {
int sum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) {
int top_left = ( i + 1 ) * ( j + 1 ) ;
int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; }
int main ( ) { int arr [ ] [ n ] = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; cout << matrixSum ( arr ) ; return 0 ; }
int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ )
maximum = max ( maximum , ( i & j ) ) ; return maximum ; }
int main ( ) { int L = 1 , R = 632 ; cout << maxAND ( L , R ) ; return 0 ; }
bool checkArray ( int arr [ ] , int n ) {
return ( arr [ 0 ] % 2 ) && ( arr [ n - 1 ] % 2 ) && ( n % 2 ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( int ) checkArray ( arr , n ) ; return 0 ; }
int findCount ( int arr [ ] , int n ) {
int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ;
if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 5 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findCount ( arr , n ) ; return 0 ; }
bool isPerfectSquare ( long double x ) {
long double sr = sqrt ( x ) ;
return ( ( sr - floor ( sr ) ) == 0 ) ; }
bool isSunnyNum ( int n ) {
if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; }
int main ( ) { int n = 3 ; if ( isSunnyNum ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005
bool isprime [ N ] ;
bool can [ N ] ;
vector < int > SieveOfEratosthenes ( ) { memset ( isprime , true , sizeof ( isprime ) ) ; for ( int p = 2 ; p * p < N ; p ++ ) {
if ( isprime [ p ] == true ) {
for ( int i = p * p ; i < N ; i += p ) isprime [ i ] = false ; } } vector < int > primes ; for ( int i = 2 ; i < N ; i ++ ) if ( isprime [ i ] ) primes . push_back ( i ) ; return primes ; }
int Prime_Numbers ( int n ) { vector < int > primes = SieveOfEratosthenes ( ) ;
for ( int i = 0 ; i < ( int ) ( primes . size ( ) ) - 1 ; i ++ ) if ( primes [ i ] + primes [ i + 1 ] + 1 < N ) can [ primes [ i ] + primes [ i + 1 ] + 1 ] = true ; int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( can [ i ] and isprime [ i ] ) { ans ++ ; } } return ans ; }
int main ( ) { int n = 50 ; cout << Prime_Numbers ( n ) ; return 0 ; }
int findAndSum ( int arr [ ] , int n ) {
int sum = 0 ;
int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) {
bool count_on = 0 ;
int l = 0 ;
for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) if ( count_on ) l ++ ; else { count_on = 1 ; l ++ ; } else if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = 0 ; l = 0 ; } } if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = 0 ; l = 0 ; }
mul *= 2 ; }
return sum ; }
int main ( ) { int arr [ ] = { 7 , 1 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findAndSum ( arr , n ) ; return 0 ; }
bool isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; }
int main ( ) { int Sx = 0 , Sy = 0 , Dx = 0 , Dy = 0 ; int x = 3 , y = 4 ; if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int getPairs ( int a [ ] , int n ) {
int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) {
if ( a [ i ] < a [ j ] ) count ++ ; } }
return count ; }
int main ( ) { int a [ ] = { 2 , 4 , 3 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getPairs ( a , n ) ; return 0 ; }
bool isComposite ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return false ;
if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; }
bool isDigitSumOne ( int nm ) {
while ( nm > 9 ) {
int sum_digit = 0 ;
while ( nm > 0 ) { int digit = nm % 10 ; sum_digit = sum_digit + digit ; nm = nm / 10 ; } nm = sum_digit ; }
if ( nm == 1 ) return true ; else return false ; }
void printValidNums ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) {
if ( isComposite ( i ) && isDigitSumOne ( i ) ) cout << i << " ▁ " ; } }
int main ( void ) { int l = 10 , r = 100 ; printValidNums ( l , r ) ; return 0 ; }
int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; }
int main ( ) { int N = 5 , I = 2 ; cout << " Leaf ▁ nodes ▁ = ▁ " << calcNodes ( N , I ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE ll mod = 1000000007 ; ll arr [ 1000001 ] = { 0 } ;
void cal_factorial ( ) { arr [ 0 ] = 1 ;
for ( int i = 1 ; i <= 1000000 ; i ++ ) {
arr [ i ] = ( arr [ i - 1 ] * i ) % mod ; } }
ll mod_exponent ( ll num , ll p ) { if ( p == 0 ) return 1 ;
if ( p & 1 ) { return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ) % mod ; }
else if ( ! ( p & 1 ) ) return ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ; }
ll getCount ( ll x , ll y ) { ll ans = arr [ x + y - 1 ] ;
ans *= mod_exponent ( arr [ x ] , mod - 2 ) ; ans %= mod ;
ans *= mod_exponent ( arr [ y ] , mod - 2 ) ; ans %= mod ; ans *= ( x - y ) ; ans %= mod ; return ans ; }
cal_factorial ( ) ; ll x = 3 , y = 1 ; cout << getCount ( x , y ) ; return 0 ; }
void findValues ( int a , int b ) {
if ( ( a - b ) % 2 == 1 ) { cout << " - 1" ; return ; }
cout << ( a - b ) / 2 << " ▁ " << ( a + b ) / 2 ; }
int main ( ) { int a = 12 , b = 8 ; findValues ( a , b ) ; return 0 ; }
int countTriplets ( int n , vector < pair < int , int > > points ) { set < pair < int , int > > pts ; int ct = 0 ;
for ( int i = 0 ; i < n ; i ++ ) pts . insert ( points [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points [ i ] . first + points [ j ] . first ; int y = points [ i ] . second + points [ j ] . second ;
if ( x % 2 == 0 && y % 2 == 0 ) if ( pts . find ( make_pair ( x / 2 , y / 2 ) ) != pts . end ( ) ) ct ++ ; }
return ct ; }
int main ( ) { vector < pair < int , int > > points = { { 1 , 1 } , { 2 , 2 } , { 3 , 3 } } ; int n = points . size ( ) ; cout << countTriplets ( n , points ) ; }
double mixtureConcentration ( int n , int p [ ] ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; }
int main ( ) { int arr [ ] = { 0 , 20 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << mixtureConcentration ( n , arr ) ; }
int countOddSquares ( int n , int m ) { return ( int ) pow ( m , 0.5 ) - ( int ) pow ( n - 1 , 0.5 ) ; }
int main ( ) { int n = 5 , m = 100 ; cout << " Count ▁ is ▁ " << ( m - n + 1 ) - countOddSquares ( n , m ) ; return 0 ; }
int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ;
a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ;
if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ;
total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; }
int main ( ) { int R = 4 , C = 5 , M = 2 ; cout << Square ( R , C , M ) ; return 0 ; }
int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; }
int main ( ) { int n = 2 , m = 5 ; cout << findNumber ( n , m ) ; return 0 ; }
bool checkTriangularSumRepresentation ( int n ) { unordered_set < int > tri ; int i = 1 ;
while ( 1 ) { int x = i * ( i + 1 ) / 2 ; if ( x >= n ) break ; tri . insert ( x ) ; i ++ ; }
for ( auto tm : tri ) if ( tri . find ( n - tm ) != tri . end ( ) ) return true ; return false ; }
int main ( ) { int n = 24 ; checkTriangularSumRepresentation ( n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
long long digitsCount ( long long n ) { int len = 0 ; while ( n > 0 ) { len ++ ; n /= 10 ; } return len ; }
long long absoluteFirstLast ( long long n , int x ) {
int i = 0 , mod = 1 ; while ( i < x ) { mod *= 10 ; i ++ ; } int last = n % mod ;
long long len = digitsCount ( n ) ;
while ( len != x ) { n /= 10 ; len -- ; }
int first = n ;
return abs ( first - last ) ; }
int main ( ) { long long n = 21546 , x = 2 ; cout << absoluteFirstLast ( n , x ) ; return 0 ; }
void make_sequence ( int N ) {
int arr [ N + 1 ] , sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; }
if ( sum % 2 == 1 ) arr [ 2 ] = 3 ;
for ( int i = 1 ; i <= N ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int N = 9 ; make_sequence ( N ) ; return 0 ; }
int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ;
if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; }
int main ( ) { int L = 3 , R = 7 ; int odds = countOdd ( L , R ) ; int evens = ( R - L + 1 ) - odds ; cout << " Count ▁ of ▁ odd ▁ numbers ▁ is ▁ " << odds << endl ; cout << " Count ▁ of ▁ even ▁ numbers ▁ is ▁ " << evens << endl ; return 0 ; }
int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; }
int main ( ) { int n = 4 , m = 5 ; cout << getMinCost ( n , m ) ; return 0 ; }
void minOperation ( int n , int k , int a [ ] ) {
for ( int i = k ; i < n ; i ++ ) { if ( a [ i ] != a [ k - 1 ] ) cout << ( -1 ) << endl ; }
for ( int i = k - 2 ; i > -1 ; i -- ) { if ( a [ i ] != a [ k - 1 ] ) cout << ( i + 1 ) << endl ; } }
int main ( ) { int n = 5 ; int k = 3 ; int a [ ] = { 2 , 1 , 1 , 1 , 1 } ; minOperation ( n , k , a ) ; }
int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ;
if ( k > n - k ) k = n - k ;
for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int main ( ) { int N = 5 , M = 1 ; int P = ( N * ( N - 1 ) ) / 2 ; cout << binomialCoeff ( P , M ) ; return 0 ; }
void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) cout << i * g << " ▁ " ; }
int main ( ) { int n = 6 , g = 5 ; generateSequence ( n , g ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ;
int f [ MAX ] = { 0 } ;
int fib ( int n ) {
if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ;
if ( f [ n ] ) return f [ n ] ; int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ;
f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findLCMFibonacci ( int a , int b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; }
int main ( ) { int a = 3 , b = 12 ; cout << findLCMFibonacci ( a , b ) ; return 0 ; }
string isEvenOrOdd ( int L , int R ) {
int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ;
if ( oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; }
int main ( ) { int L = 5 , R = 15 ; cout << isEvenOrOdd ( L , R ) ; return 0 ; }
int trailing_zeros ( int N ) {
int count_of_two = 0 , count_of_five = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int val = i ; while ( val % 2 == 0 && val > 0 ) { val /= 2 ;
count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val /= 5 ;
count_of_five += i ; } }
int ans = min ( count_of_two , count_of_five ) ; return ans ; }
int main ( ) { int N = 12 ; cout << trailing_zeros ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void midptellipse ( int rx , int ry , int xc , int yc ) { float dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ;
d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ;
while ( dx < dy ) {
cout << x + xc << " ▁ , ▁ " << y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << y + yc << endl ; cout << x + xc << " ▁ , ▁ " << - y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << - y + yc << endl ;
if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } }
d2 = ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ;
while ( y >= 0 ) {
cout << x + xc << " ▁ , ▁ " << y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << y + yc << endl ; cout << x + xc << " ▁ , ▁ " << - y + yc << endl ; cout << - x + xc << " ▁ , ▁ " << - y + yc << endl ;
if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } }
midptellipse ( 10 , 15 , 50 , 50 ) ; return 0 ; }
string isDivisible ( long long int n ) { long long int temp = n ;
int sum = 0 ; while ( n ) { int k = n % 10 ; sum += k ; n /= 10 ; }
if ( temp % sum == 0 ) return " YES " ; return " NO " ; }
int main ( ) { long long int n = 123 ; cout << isDivisible ( n ) ; return 0 ; }
void alter ( long long int x , long long int y ) {
while ( true ) {
if ( x == 0 y == 0 ) break ;
if ( x >= 2 * y ) x = x % ( 2 * y ) ;
else if ( y >= 2 * x ) y = y % ( 2 * x ) ;
else break ; } cout << " X = " << x << " , ▁ " << " Y = " << y ; }
long long int x = 12 , y = 5 ;
alter ( x , y ) ; return 0 ; }
int digitProduct ( int n ) { int prod = 1 ; while ( n ) { prod = prod * ( n % 10 ) ; n = n / 10 ; } return prod ; }
void printMultiplicativePrimes ( int n ) {
bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) {
if ( prime [ i ] && prime [ digitProduct ( i ) ] ) cout << i << " ▁ " ; } }
int main ( ) { int n = 10 ; printMultiplicativePrimes ( n ) ; }
ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
bool coPrime ( ll n1 , ll n2 ) {
if ( gcd ( n1 , n2 ) == 1 ) return true ; else return false ; }
ll largestCoprime ( ll N ) { ll half = floor ( N / 2 ) ;
while ( coPrime ( N , half ) == false ) half -- ; return half ; }
int main ( ) { ll n = 50 ; cout << largestCoprime ( n ) ; return 0 ; }
long long largestCoprime ( long long N ) {
if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; }
int main ( ) { long long int n = 50 ; cout << largestCoprime ( n ) << endl ; return 0 ; }
void printSafePrimes ( int n ) { int prime [ n + 1 ] ;
for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = 1 ;
prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == 1 ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = 0 ; } } for ( int i = 2 ; i <= n ; i ++ ) {
if ( prime [ i ] != 0 ) {
int temp = ( 2 * i ) + 1 ;
if ( temp <= n && prime [ temp ] != 0 ) prime [ temp ] = 2 ; } } for ( int i = 5 ; i <= n ; i ++ )
if ( prime [ i ] == 2 ) cout << i << " ▁ " ; }
int main ( ) { int n = 20 ; printSafePrimes ( n ) ; return 0 ; }
vector < int > Divisors ( int x ) {
int c = 0 ;
vector < int > v ;
while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . push_back ( c ) ; c = 0 ;
while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . push_back ( c ) ; c = 0 ;
while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . push_back ( c ) ;
v . push_back ( x ) ; return v ; }
int MinOperations ( int a , int b ) {
vector < int > va = Divisors ( a ) ;
vector < int > vb = Divisors ( b ) ;
if ( va [ 3 ] != vb [ 3 ] ) return -1 ;
int minOperations = abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) ; return minOperations ; }
int main ( ) { int a = 14 , b = 28 ; cout << MinOperations ( a , b ) ; return 0 ; }
int largestOddDigit ( int n ) {
int maxOdd = -1 ; while ( n > 0 ) {
int digit = n % 10 ;
if ( digit % 2 == 1 && digit > maxOdd ) maxOdd = digit ;
n = n / 10 ; }
return maxOdd ; }
int getProduct ( int n ) { int maxOdd = largestOddDigit ( n ) ;
if ( maxOdd == -1 ) return -1 ;
return ( n * maxOdd ) ; }
int main ( ) { int n = 12345 ; cout << getProduct ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define n  1000002 NEW_LINE #define ll  long long int NEW_LINE ll phi [ n + 2 ] , ans [ n + 2 ] ;
void ETF ( ) { for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { phi [ i ] = i - 1 ; for ( int j = 2 * i ; j <= n ; j += i ) { phi [ j ] = ( phi [ j ] * ( i - 1 ) ) / i ; } } } }
ll LcmSum ( int m ) { ETF ( ) ; for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = i ; j <= n ; j += i ) { ans [ j ] += ( i * phi [ i ] ) ; } } ll answer = ans [ m ] ; answer = ( answer + 1 ) * m ; answer = answer / 2 ; return answer ; }
int main ( ) { int m = 5 ; cout << LcmSum ( m ) ; return 0 ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int countWays ( string str ) { int freq [ 26 ] = { 0 } ; int nvowels = 0 , nconsonants = 0 ; int vplaces , cways , vways ;
for ( int i = 0 ; i < str . length ( ) ; i ++ ) ++ freq [ str [ i ] - ' a ' ] ;
for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) nvowels += freq [ i ] ; else nconsonants += freq [ i ] ; }
vplaces = nconsonants + 1 ;
cways = factorial ( nconsonants ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { cways = cways / factorial ( freq [ i ] ) ; } }
vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { vways = vways / factorial ( freq [ i ] ) ; } } return cways * vways ; }
int main ( ) { string str = " permutation " ; cout << countWays ( str ) << endl ; return 0 ; }
int setBits ( int n ) { int count = 0 ; while ( n ) { n = n & ( n - 1 ) ; count ++ ; } return count ; }
int countPairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) {
int setbits_x = setBits ( a [ i ] ) ; for ( int j = i + 1 ; j < n ; j ++ ) {
int setbits_y = setBits ( a [ j ] ) ;
int setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) ;
if ( setbits_x + setbits_y == setbits_xor_xy )
count ++ ; } }
return count ; }
int main ( ) { int a [ ] = { 2 , 3 , 4 , 5 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << countPairs ( a , n ) ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int findPossibleDerivables ( int arr [ ] , int n , int D , int A , int B ) {
int gcdAB = gcd ( A , B ) ;
int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( ( abs ( arr [ i ] - D ) % gcdAB ) == 0 ) { counter ++ ; } } return counter ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 7 , 13 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int D = 5 , A = 4 , B = 2 ; cout << findPossibleDerivables ( arr , n , D , A , B ) << " STRNEWLINE " ; int a [ ] = { 1 , 2 , 3 } ; n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; D = 6 , A = 3 , B = 2 ; cout << findPossibleDerivables ( a , n , D , A , B ) << " STRNEWLINE " ; return 0 ; }
int calSum ( int n ) {
return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; }
int main ( ) { int n = 3 ; cout << calSum ( n ) ; return 0 ; }
void getElements ( int a , int arr [ ] , int n ) {
elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) {
elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; }
for ( int i = 0 ; i < n + 1 ; i ++ ) cout << elements [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 13 , 2 , 6 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int a = 5 ; getElements ( a , arr , n ) ; return 0 ; }
int distinctDigitSum ( int n ) { bool used [ 10 ] ; int sum = 0 ; while ( n > 0 ) {
int digit = n % 10 ;
if ( ! used [ digit ] ) {
used [ digit ] = true ; sum += digit ; }
n = ( int ) n / 10 ; } return sum ; }
string checkSum ( int m , int n ) { int sumM = distinctDigitSum ( m ) ; int sumN = distinctDigitSum ( n ) ; if ( sumM != sumN ) return " YES " ; return " NO " ; }
int main ( ) { int m = 2452 , n = 9222 ; cout << ( checkSum ( m , n ) ) ; return 0 ; }
int doubleFactorial ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { fact = fact * i ; } return fact ; }
int hermiteNumber ( int n ) {
if ( n % 2 == 1 ) return 0 ;
else {
int number = ( pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ;
if ( ( n / 2 ) % 2 == 1 ) number = number * -1 ;
return number ; } }
int main ( ) { int n = 6 ;
cout << hermiteNumber ( n ) ; return 0 ; }
ll getSum ( int n , int d ) { ll sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) {
if ( i % 10 == d ) sum += i ; } return sum ; }
int main ( ) { int n = 30 , d = 3 ; cout << getSum ( n , d ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printThreeParts ( int N ) {
if ( N % 3 == 0 ) cout << " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " << N - 2 << endl ;
else cout < < " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " << N - 3 << endl ; }
int main ( ) { int N = 10 ; printThreeParts ( N ) ; return 0 ; }
bool isPrime ( int N ) { for ( int i = 2 ; i <= sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; }
int getDifference ( int N ) { if ( N == 0 ) return 2 ; else if ( N == 1 ) return 1 ; else if ( isPrime ( N ) ) return 0 ;
int aboveN = -1 , belowN = -1 ; int n1 ;
n1 = N + 1 ; while ( true ) { if ( isPrime ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; }
n1 = N - 1 ; while ( true ) { if ( isPrime ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; }
int diff1 = aboveN - N ; int diff2 = N - belowN ; return min ( diff1 , diff2 ) ; }
int main ( ) { int N = 25 ; cout << getDifference ( N ) << endl ; return 0 ; }
bool check ( int arr [ ] , int x , int n ) { long long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double x = sqrt ( arr [ i ] ) ;
if ( floor ( x ) == ceil ( x ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; }
int main ( ) { int arr [ ] = { 2 , 3 , 4 , 9 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int x = 13 ; if ( check ( arr , x , n ) ) { cout << " Yes " ; } else { cout << " No " ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void MinimumMaximumPairs ( int n , int m ) { int max_pairs = ( ( n - m + 1 ) * ( n - m ) ) / 2 ; int min_pairs = m * ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 + ceil ( ( n - m ) / double ( m ) ) * ( ( n - m ) % m ) ; cout << " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " << min_pairs << " STRNEWLINE " ; cout << " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " << max_pairs << " STRNEWLINE " ; }
int main ( ) { int n = 5 , m = 2 ; MinimumMaximumPairs ( n , m ) ; return 0 ; }
void findGreater ( int a , int b ) { long double x = ( long double ) a * ( long double ) ( log ( ( long double ) ( b ) ) ) ; long double y = ( long double ) b * ( long double ) ( log ( ( long double ) ( a ) ) ) ; if ( y > x ) { cout << " a ^ b ▁ is ▁ greater " << endl ; } else if ( y < x ) { cout << " b ^ a ▁ is ▁ greater " << endl ; } else { cout << " Both ▁ are ▁ equal " << endl ; } }
int main ( ) { int a = 3 , b = 5 , c = 2 , d = 4 ; findGreater ( a , b ) ; findGreater ( c , d ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
ll modexp ( ll x , ll n ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) ; } }
ll getFractionModulo ( ll a , ll b ) { ll c = gcd ( a , b ) ; a = a / c ; b = b / c ;
ll d = modexp ( b , m - 2 ) ;
ll ans = ( ( a % m ) * ( d % m ) ) % m ; return ans ; }
int main ( ) { ll a = 2 , b = 6 ; cout << getFractionModulo ( a , b ) << endl ; return 0 ; }
int maxPrimeFactors ( int n ) { int num = n ;
int maxPrime = -1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n /= 2 ; }
for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } }
if ( n > 2 ) maxPrime = n ;
int sum = maxPrime + num ; return sum ; }
int main ( ) { int n = 19 ; cout << maxPrimeFactors ( n ) ; return 0 ; }
int sumOfDigits ( int n ) { int res = 0 ;
while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; }
int findNumber ( int n ) {
int i = n - 1 ;
while ( i > 0 ) {
if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) return i ; i -- ; }
return -1 ; }
int main ( ) { int n = 824 ; cout << findNumber ( n ) ; return 0 ; }
int findNth ( int N ) {
int b = 14 ; int i ;
for ( i = 2 ; i <= N ; i ++ ) {
if ( i % 2 == 0 ) b = b * 2 ;
else b = b - 8 ; } return b ; }
int main ( ) { int N = 6 ; cout << findNth ( N ) ; return 0 ; }
#define N  4 NEW_LINE void predictMatrix ( int arr [ N ] [ N ] , int range1a , int range1b , int range0a , int range0b , int K , int b [ N ] [ N ] ) {
int c = 0 ; while ( K -- ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { c = 0 ;
if ( i > 0 && arr [ i - 1 ] [ j ] == 1 ) c ++ ; if ( j > 0 && arr [ i ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j > 0 && arr [ i - 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i < N - 1 && arr [ i + 1 ] [ j ] == 1 ) c ++ ; if ( j < N - 1 && arr [ i ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j < N - 1 && arr [ i + 1 ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j > 0 && arr [ i + 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j < N - 1 && arr [ i - 1 ] [ j + 1 ] == 1 ) c ++ ;
if ( arr [ i ] [ j ] == 1 ) { if ( c >= range1a && c <= range1b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } if ( arr [ i ] [ j ] == 0 ) { if ( c >= range0a && c <= range0b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } } }
for ( int k = 0 ; k < N ; k ++ ) for ( int m = 0 ; m < N ; m ++ ) arr [ k ] [ m ] = b [ k ] [ m ] ; } }
int main ( ) { int arr [ N ] [ N ] = { 0 , 0 , 0 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 } ; int range1a = 2 , range1b = 2 ; int range0a = 2 , range0b = 3 ; int K = 3 , b [ N ] [ N ] = { 0 } ;
predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) ;
for ( int i = 0 ; i < N ; i ++ ) { cout << endl ; for ( int j = 0 ; j < N ; j ++ ) cout << b [ i ] [ j ] << " ▁ " ; } return 0 ; }
int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ;
ct += n ; return ct ; }
int main ( ) { int n = 3 ; cout << countMoves ( n ) ; return 0 ; }
int countNumbers ( int N ) { return ( pow ( 10 , N ) - 1 ) - ( pow ( 10 , N ) - pow ( 8 , N ) ) / 2 ; }
int main ( ) { int n = 2 ; cout << countNumbers ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define N  3 NEW_LINE using namespace std ;
int calcDeterminant ( int arr [ ] ) { int determinant = 0 ; for ( int i = 0 ; i < N ; i ++ ) { determinant += pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; }
int main ( ) { int arr [ ] = { 4 , 5 , 3 } ; cout << calcDeterminant ( arr ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int minimumMoves ( int k , int l , int r ) {
int count = r - l + 1 ;
if ( count % k == 0 ) return 0 ;
return ( k - ( count % k ) ) ; }
int main ( ) { int k = 3 , l = 10 , r = 10 ; cout << minimumMoves ( k , l , r ) ; return 0 ; }
int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) ; return sum ; }
int sumEven ( int l , int r ) { return sumNatural ( r / 2 ) - sumNatural ( ( l - 1 ) / 2 ) ; }
int main ( ) { int l = 2 , r = 5 ; cout << " Sum ▁ of ▁ Natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " << sumEven ( l , r ) ; return 0 ; }
bool isDivisibleRec ( int x , int a , int b , int n ) {
if ( x > n ) return false ; if ( n % x == 0 ) return true ;
return ( isDivisibleRec ( x * 10 + a , a , b , n ) || isDivisibleRec ( x * 10 + b , a , b , n ) ) ; } bool isDivisible ( int a , int b , int n ) {
return isDivisibleRec ( a , a , b , n ) || isDivisibleRec ( b , a , b , n ) ; }
int main ( ) { int a = 3 , b = 5 , n = 53 ; if ( isDivisible ( a , b , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
void MinSteps ( int SourceX , int SourceY , int DestX , int DestY ) {
cout << max ( abs ( SourceX - DestX ) , abs ( SourceY - DestY ) ) << endl ;
while ( ( SourceX != DestX ) || ( SourceY != DestY ) ) {
if ( SourceX < DestX ) { cout << ' U ' ; SourceX ++ ; }
if ( SourceX > DestX ) { cout << ' D ' ; SourceX -- ; }
if ( SourceY > DestY ) { cout << ' L ' ; SourceY -- ; }
if ( SourceY < DestY ) { cout << ' R ' ; SourceY ++ ; } cout << endl ; } }
int main ( ) { int sourceX = 4 , sourceY = 4 ; int destinationX = 7 , destinationY = 0 ; MinSteps ( sourceX , sourceY , destinationX , destinationY ) ; return 0 ; }
vector < int > getPerfectSquares ( int n ) { vector < int > perfectSquares ; int current = 1 , i = 1 ;
while ( current <= n ) { perfectSquares . push_back ( current ) ; current = static_cast < int > ( pow ( ++ i , 2 ) ) ; } return perfectSquares ; }
int maxPairSum ( vector < int > & arr ) { int n = arr . size ( ) ; int max , secondMax ; if ( arr [ 0 ] > arr [ 1 ] ) { max = arr [ 0 ] ; secondMax = arr [ 1 ] ; } else { max = arr [ 1 ] ; secondMax = arr [ 0 ] ; } for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return ( max + secondMax ) ; }
int countPairsWith ( int n , vector < int > & perfectSquares , unordered_set < int > & nums ) { int count = 0 ; for ( int i = 0 ; i < perfectSquares . size ( ) ; i ++ ) { int temp = perfectSquares [ i ] - n ;
if ( temp > n && find ( nums . begin ( ) , nums . end ( ) , temp ) != nums . end ( ) ) { count ++ ; } } return count ; }
int countPairs ( vector < int > & arr ) { int i , n = arr . size ( ) ;
int max = maxPairSum ( arr ) ;
vector < int > perfectSquares = getPerfectSquares ( max ) ;
unordered_set < int > nums ; for ( i = 0 ; i < n ; i ++ ) { nums . insert ( arr [ i ] ) ; } int count = 0 ; for ( i = 0 ; i < n ; i ++ ) {
count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; } return count ; }
int main ( ) { vector < int > arr = { 2 , 3 , 6 , 9 , 10 , 20 } ; cout << countPairs ( arr ) << endl ; return 0 ; }
int findEle ( int arr [ ] , int n ) {
ll sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;
for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return -1 ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findEle ( arr , n ) ; return 0 ; }
int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; }
int suminRange ( int l , int r ) { return sumNatural ( r ) - sumNatural ( l - 1 ) ; }
int main ( ) { int l = 2 , r = 5 ; cout << " Sum ▁ of ▁ Natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " << suminRange ( l , r ) ; return 0 ; }
bool divisibleBy3 ( string number ) {
int sumOfDigit = 0 ;
for ( int i = 0 ; i < number . length ( ) ; i ++ )
sumOfDigit += number [ i ] - '0' ;
if ( sumOfDigit % 3 == 0 ) return true ; return false ; }
bool divisibleBy25 ( string number ) {
if ( number . length ( ) < 2 ) return false ;
int length = number . length ( ) ;
int lastTwo = ( number [ length - 2 ] - '0' ) * 10 + ( number [ length - 1 ] - '0' ) ;
if ( lastTwo % 25 == 0 ) return true ; return false ; }
bool divisibleBy75 ( string number ) {
if ( divisibleBy3 ( number ) && divisibleBy25 ( number ) ) return true ; return false ; }
int main ( ) { string number = "754586672150" ;
bool divisible = divisibleBy75 ( number ) ;
if ( divisible ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; }
int main ( ) { int A = 8 , Lcm = 8 , Hcf = 1 ;
int result = otherNumber ( A , Lcm , Hcf ) ; cout << " B ▁ = ▁ " << result ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; float successiveChange ( int arr [ ] , int N ) { float var1 , var2 , result = 0 ; var1 = arr [ 0 ] ; var2 = arr [ 1 ] ;
result = var1 + var2 + ( float ( var1 * var2 ) / 100 ) ;
for ( int i = 2 ; i < N ; i ++ ) result = result + arr [ i ] + ( float ( result * arr [ i ] ) / 100 ) ; return result ; }
int main ( ) { int arr [ ] = { 10 , 20 , 30 , 10 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
float result = successiveChange ( arr , N ) ; cout << " Percentage ▁ change ▁ is ▁ = ▁ " << result << " ▁ % " ; return 0 ; }
int minimumNumbers ( int n , int s ) { if ( s % n ) return s / n + 1 ; else return s / n ; }
int main ( ) { int n = 5 ; int s = 11 ; cout << minimumNumbers ( n , s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int
ll sumAP ( ll n , ll d ) {
n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
ll sumMultiples ( ll A , ll B , ll n ) {
n -- ;
ll common = ( A * B ) / __gcd ( A , B ) ; return sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ; }
int main ( ) { ll n = 100 , A = 5 , B = 10 ; cout << " Sum ▁ = ▁ " << sumMultiples ( A , B , n ) ; return 0 ; }
bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; }
bool isPossible ( int N ) {
if ( isPrime ( N ) && isPrime ( N - 2 ) ) return true ; else return false ; }
int main ( ) { int n = 13 ; if ( isPossible ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int contiguousPerfectSquare ( int arr [ ] , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = sqrt ( arr [ i ] ) ; a = b ;
if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = max ( max_length , current_length ) ; } return max_length ; }
int main ( ) { int arr [ ] = { 9 , 75 , 4 , 64 , 121 , 25 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << contiguousPerfectSquare ( arr , n ) ; return 0 ; }
int countPairs ( int n ) {
int count = 0 ;
for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; }
int main ( ) { int n = 15 ; cout << countPairs ( n ) ; return 0 ; }
int getIndex ( int a [ ] , int n ) {
if ( n == 1 ) return 0 ;
int ptrL = 0 , ptrR = n - 1 , sumL = a [ 0 ] , sumR = a [ n - 1 ] ; while ( ptrR - ptrL > 1 ) { if ( sumL < sumR ) { ptrL ++ ; sumL += a [ ptrL ] ; } else if ( sumL > sumR ) { ptrR -- ; sumR += a [ ptrR ] ; } else { break ; } } return ptrL ; }
int main ( ) { int a [ ] = { 2 , 7 , 9 , 8 , 7 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << getIndex ( a , n ) ; return 0 ; }
int getPosition ( int a [ ] , int n , int m ) {
for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m != 0 ) ) ; } int ans = -1 , max = -1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } }
return ans + 1 ; }
int main ( ) { int a [ ] = { 2 , 5 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int m = 2 ; cout << getPosition ( a , n , m ) ; return 0 ; }
int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = max ( r , n - r ) ;
for ( int i = mx + 1 ; i <= n ; i ++ ) {
int denominator = ( int ) pow ( i , i ) ; int numerator = ( int ) pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; }
return finalDenominator ; }
int main ( ) { int n = 6 , r = 2 ; cout << "1 / " << calcFunction ( n , r ) << endl ; return 0 ; }
int findNum ( int div [ ] , int rem [ ] , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; }
int main ( ) { int div [ ] = { 8 , 3 } ; int rem [ ] = { 2 , 2 } ; int N = sizeof ( div ) / sizeof ( div [ 0 ] ) ; cout << findNum ( div , rem , N ) ; return 0 ; }
void profitLoss ( int N , int M ) { if ( N == M ) cout << " No ▁ Profit ▁ nor ▁ Loss " ; else { float result = 0.0 ; result = float ( abs ( N - M ) ) / M ; if ( N - M < 0 ) cout << " Loss ▁ = ▁ - " << result * 100 << " % " ; else cout << " Profit ▁ = ▁ " << result * 100 << " % " ; } }
int main ( ) { int N = 8 , M = 9 ; profitLoss ( N , M ) ; return 0 ; }
int countPieces ( int N ) { return 2 * N ; }
int main ( ) { int N = 100 ; cout << countPieces ( N ) ; return 0 ; }
long long sumAP ( long long n , long long d ) {
n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; }
long long sumMultiples ( long long n ) {
n -- ; return sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ; }
int main ( ) { long long n = 24 ; cout << sumMultiples ( n ) ; return 0 ; }
bool productSumDivisible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) {
if ( size % 2 == 0 ) { product *= n % 10 ; }
else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) return true ; return false ; }
int main ( ) { int n = 1234 ; int len = 4 ; if ( productSumDivisible ( n , len ) ) cout << " TRUE " ; else cout << " FALSE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long int ll ; ll gcd ( ll a , ll b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
ll powGCD ( ll a , ll n , ll b ) { for ( int i = 0 ; i < n ; i ++ ) a = a * a ; return gcd ( a , b ) ; }
int main ( ) { ll a = 10 , b = 5 , n = 2 ; cout << powGCD ( a , n , b ) ; return 0 ; }
int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; }
int main ( ) { int n = 3 , a = 5 , b = 2 ; cout << lastCoordinate ( n , a , b ) ; return 0 ; }
int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; }
int main ( ) { int N = 45 , K = 6 ; cout << " Smallest ▁ number ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ " << N << " that is divisible by " ▁ < < ▁ K ▁ < < ▁ " is " return 0 ; }
void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) {
int d = temp % 10 ; temp /= 10 ;
if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } cout << " Sum ▁ = ▁ " << sum ; cout << " Product = " }
int main ( ) { int n = 1012 ; countDigit ( n ) ; return 0 ; }
int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; }
int main ( ) { int N = 45 , K = 6 ; cout << " Largest ▁ number ▁ smaller ▁ than ▁ or ▁ equal ▁ to ▁ " << N << " that is divisible by " < < ▁ K ▁ < < ▁ " is " return 0 ; }
bool isDivisiblePalindrome ( int n ) {
int hash [ 10 ] = { 0 } ; int digitSum = 0 ;
while ( n ) {
digitSum += n % 10 ; hash [ n % 10 ] ++ ; n /= 10 ; }
if ( digitSum % 3 != 0 ) return false ; int oddCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; }
if ( oddCount > 1 ) return false ; else return true ; }
int main ( ) { int n = 34734 ; isDivisiblePalindrome ( n ) ? cout << " True " : cout << " False " ; return 0 ; }
bool productDivisible ( int n , int k ) { int product = 1 , position = 1 ; while ( n > 0 ) {
if ( position % 2 == 0 ) product *= n % 10 ; n = n / 10 ; position ++ ; } if ( product % k == 0 ) return true ; return false ; }
int main ( ) { int n = 321922 ; int k = 3 ; if ( productDivisible ( n , k ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int npr ( int n , int r ) { int pnr = factorial ( n ) / factorial ( n - r ) ; return pnr ; }
int countPermutations ( int n , int r , int k ) { return factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ; }
int main ( ) { int n = 8 ; int r = 5 ; int k = 2 ; cout << countPermutations ( n , r , k ) ; return 0 ; }
int GIF ( float n ) {
return floor ( n ) ; }
int main ( ) { int n = 2.3 ; cout << GIF ( n ) ; return 0 ; }
int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; }
int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int main ( ) { int m = 3 , n = 4 , k = 5 ; int totalTriangles = ncr ( m + n + k , 3 ) - ncr ( m , 3 ) - ncr ( n , 3 ) - ncr ( k , 3 ) ; cout << totalTriangles << endl ; }
bool SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) {
if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; }
int main ( ) { int n = 592452 ; int k = 3 ; if ( SumDivisible ( n , k ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string isTriangleExists ( int a , int b , int c ) {
if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 )
if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " YES " ; else return " NO " ; else return " NO " ; }
int main ( ) { int a = 50 , b = 60 , c = 70 ; cout << isTriangleExists ( a , b , c ) << endl ; return 0 ; }
public : int findX ( int n , int k ) { int r = n , v , u ;
int m = sqrt ( k ) + 1 ;
for ( int i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; }
for ( u = v = 0 ; k % i == 0 ; v ++ ) { k /= i ; } if ( v > 0 ) { int t = n ; while ( t > 0 ) { t /= i ; u += t ; }
r = min ( r , u / v ) ; } } return r ; } } ;
int main ( ) { GfG g ; int n = 5 ; int k = 2 ; cout << g . findX ( n , k ) ; }
int fact ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact *= i ; return fact ; }
int ncr ( int n , int r ) { int ncr = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; return ncr ; }
int ways ( int m , int w , int n , int k ) { int ans = 0 ; while ( m >= k ) { ans += ncr ( m , k ) * ncr ( w , n - k ) ; k += 1 ; } return ans ; }
int main ( ) { int m , w , n , k ; m = 7 ; w = 6 ; n = 5 ; k = 3 ; cout << ways ( m , w , n , k ) ; }
int square ( int n ) { return n * n ; }
int sum ( int n ) { if ( n == 0 ) return 0 ;
return square ( ( n + 1 ) / 2 ) + sum ( n / 2 ) ; }
return square ( n / 2 ) + sum ( n / 2 ) ; } }
int oddDivSum ( int a , int b ) { return sum ( b ) - sum ( a - 1 ) ; }
int main ( ) { int a = 3 , b = 9 ; cout << oddDivSum ( a , b ) << endl ; return 0 ; }
int countBits ( int n ) { int count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; }
int main ( ) { int n = 32 ; cout << " Minimum ▁ value ▁ of ▁ K ▁ is ▁ = ▁ " << countBits ( n ) << endl ; return 0 ; }
bool isPowerful ( int n ) {
while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; }
if ( power == 1 ) return false ; }
for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) {
int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; }
if ( power == 1 ) return false ; }
return ( n == 1 ) ; }
bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = log ( a ) / log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; }
bool isAchillesNumber ( int n ) { if ( isPowerful ( n ) && ! isPower ( n ) ) return true ; else return false ; }
int main ( ) { int n = 72 ; if ( isAchillesNumber ( n ) ) cout << " YES " << endl ; else cout << " NO " << endl ; n = 36 ; if ( isAchillesNumber ( n ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
int OddDivCount ( int a , int b ) {
int res = 0 ;
for ( int i = a ; i <= b ; ++ i ) {
int divCount = 0 ; for ( int j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } }
if ( divCount % 2 ) { ++ res ; } } return res ; }
int main ( ) { int a = 1 , b = 10 ; cout << OddDivCount ( a , b ) << endl ; return 0 ; }
int largestSquareFactor ( int num ) {
int answer = 1 ;
for ( int i = 2 ; i < sqrt ( num ) ; ++ i ) {
int cnt = 0 ; int j = i ; while ( num % j == 0 ) { cnt ++ ; j *= i ; }
if ( cnt & 1 ) { cnt -- ; answer *= pow ( i , cnt ) ; }
else { answer *= pow ( i , cnt ) ; } } return answer ; }
int main ( ) { int N = 420 ; cout << largestSquareFactor ( N ) ; return 0 ; }
int Nth_Term ( int n ) { return ( 3 * pow ( n , 2 ) - n + 2 ) / ( 2 ) ; }
int main ( ) { int N = 5 ; cout << Nth_Term ( N ) << endl ; }
void countPermutations ( int N , int B ) {
int x = pow ( B , N ) ;
int y = pow ( B , N - 1 ) ;
cout << x - y << " STRNEWLINE " ; }
int main ( ) { int N = 6 ; int B = 4 ; countPermutations ( N , B ) ; return 0 ; }
int calculateDifference ( int arr [ ] , int n ) {
int max_val = * max_element ( arr , arr + n ) ;
vector < bool > prime ( max_val + 1 , true ) ;
prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } }
int P1 = 1 , P2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) {
P1 *= arr [ i ] ; } else if ( arr [ i ] != 1 ) {
P2 *= arr [ i ] ; } }
return abs ( P2 - P1 ) ; }
int main ( ) { int arr [ ] = { 1 , 3 , 5 , 10 , 15 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << calculateDifference ( arr , n ) ; return 0 ; }
int EqualNumbers ( int a [ ] , int n ) {
int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ;
if ( sum % n ) return n - 1 ; return n ; }
int main ( ) { int a [ ] = { 1 , 4 , 1 } ;
int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << EqualNumbers ( a , n ) ; return 0 ; }
int count_odd_pair ( int n , int a [ ] ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( a [ i ] % 2 == 0 ) even ++ ;
else odd ++ ; }
int ans = odd * even * 2 ; return ans ; }
int count_even_pair ( int odd_sum_pairs , int n ) { int total_pairs = ( n * ( n - 1 ) ) ; int ans = total_pairs - odd_sum_pairs ; return ans ; }
int main ( ) { int n = 6 ; int a [ ] = { 2 , 4 , 5 , 9 , 1 , 8 } ; int odd_sum_pairs = count_odd_pair ( n , a ) ; int even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) ; cout << " Even ▁ Sum ▁ Pairs ▁ = ▁ " << even_sum_pairs << endl ; cout << " Odd ▁ Sum ▁ Pairs = ▁ " << odd_sum_pairs << endl ; return 0 ; }
int findSteps ( int n , int m , int a [ ] ) {
int cur = 1 ;
int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) {
if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ;
cur = a [ i ] ; } return steps ; }
int main ( ) { int n = 3 , m = 3 ; int a [ ] = { 2 , 1 , 2 } ; cout << findSteps ( n , m , a ) ; }
void HexToBin ( string hexdec ) { long int i = 0 ; while ( hexdec [ i ] ) { switch ( hexdec [ i ] ) { case '0' : cout << "0000" ; break ; case '1' : cout << "0001" ; break ; case '2' : cout << "0010" ; break ; case '3' : cout << "0011" ; break ; case '4' : cout << "0100" ; break ; case '5' : cout << "0101" ; break ; case '6' : cout << "0110" ; break ; case '7' : cout << "0111" ; break ; case '8' : cout << "1000" ; break ; case '9' : cout << "1001" ; break ; case ' A ' : case ' a ' : cout << "1010" ; break ; case ' B ' : case ' b ' : cout << "1011" ; break ; case ' C ' : case ' c ' : cout << "1100" ; break ; case ' D ' : case ' d ' : cout << "1101" ; break ; case ' E ' : case ' e ' : cout << "1110" ; break ; case ' F ' : case ' f ' : cout << "1111" ; break ; default : cout << " Invalid hexadecimal digit " << hexdec [ i ] ; } i ++ ; } }
char hexdec [ 100 ] = "1AC5" ;
cout << " Equivalent Binary value is : " HexToBin ( hexdec ) ; return 0 ; }
bool isPowerOfTwo ( int x ) {
return x && ( ! ( x & ( x - 1 ) ) ) ; }
void Count_pairs ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( isPowerOfTwo ( a [ i ] ) ) count ++ ; }
int ans = ( count * ( count - 1 ) ) / 2 ; cout << ans << " STRNEWLINE " ; }
int main ( ) { int a [ ] = { 2 , 5 , 8 , 16 , 128 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; Count_pairs ( a , n ) ; return 0 ; }
int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = result * i ; return result ; }
int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; }
int calculate_result ( int n ) { int result = 2 * nCr ( ( n - 2 ) , ( n / 2 - 1 ) ) ; return result ; }
int main ( void ) { int a = 2 , b = 4 ; cout << calculate_result ( 2 * a ) << endl ; cout << calculate_result ( 2 * b ) << endl ; return 0 ; }
void PossibleValues ( int b , int x , int n ) {
int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ;
while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { cout << leastdivisible - b << " ▁ " ;
leastdivisible += x ;
flag = 0 ; } else break ; } if ( flag ) cout << -1 ; }
int main ( ) { int b = 10 , x = 6 , n = 40 ;
PossibleValues ( b , x , n ) ; return 0 ; }
int digitProduct ( int digits [ ] , int start , int end ) { int pro = 1 ; for ( int i = start ; i <= end ; i ++ ) { pro *= digits [ i ] ; } return pro ; }
bool isDistinct ( int N ) { string s = to_string ( N ) ;
int len = s . length ( ) ;
int digits [ len ] ;
unordered_set < int > products ; for ( int i = 0 ; i < len ; i ++ ) { digits [ i ] = s [ i ] - '0' ; }
for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i ; j < len ; j ++ ) { int val = digitProduct ( digits , i , j ) ; if ( products . find ( val ) != products . end ( ) ) return false ; else products . insert ( val ) ; } } return true ; }
int main ( ) { int N = 324 ; if ( isDistinct ( N ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
long nthHilbertNumber ( int n ) { return 4 * ( n - 1 ) + 1 ; }
int main ( ) { int n = 5 ; cout << nthHilbertNumber ( n ) ; return 0 ; }
long nthKyneaNumber ( int n ) {
n = ( 1 << n ) + 1 ;
n = n * n ;
n = n - 2 ;
return n ; }
int main ( ) { int n = 8 ;
cout << nthKyneaNumber ( n ) ; return 0 ; }
long nthKyneaNumber ( int n ) {
return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; }
int main ( ) { int n = 2 ;
cout << nthKyneaNumber ( n ) ; return 0 ; }
bool isPowerOfTwo ( int n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; }
bool isProthNumber ( int n ) { int k = 1 ; while ( k < ( n / k ) ) {
if ( n % k == 0 ) {
if ( isPowerOfTwo ( n / k ) ) return true ; }
k = k + 2 ; }
return false ; }
int n = 25 ;
if ( isProthNumber ( n - 1 ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int get_last_two_digit ( long long int N ) {
if ( N <= 10 ) { ll ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; }
return 13 ; }
int main ( ) { long long int N = 1 ; for ( N = 1 ; N <= 10 ; N ++ ) cout << " For ▁ N ▁ = ▁ " << N << " ▁ : ▁ " << get_last_two_digit ( N ) << endl ; return 0 ; }
bool isProductEven ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ )
if ( ( arr [ i ] & 1 ) == 0 ) return true ;
return false ; }
int main ( ) { int arr [ ] = { 2 , 4 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isProductEven ( arr , n ) ) cout << " Even " ; else cout << " Odd " ; return 0 ; }
int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ;
int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ;
for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; }
int main ( ) { int n = 6 ; cout << " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " << calculateSquareSum ( n ) << endl ; return 0 ; }
int fnMod ( int n ) {
int rem = n % 4 ;
if ( rem == 0 rem == 3 ) return 0 ;
else if ( rem == 1 rem == 2 ) return 1 ; }
int main ( ) { int n = 6 ; cout << fnMod ( n ) ; return 0 ; }
int MinimumMoves ( int a [ ] , int n , int x ) {
int ans = 0 ;
for ( int i = 1 ; i < n ; i ++ ) {
if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ;
ans += p ;
a [ i ] += p * x ; } }
return ans ; }
int main ( ) { int arr [ ] = { 1 , 3 , 3 , 2 } ; int x = 2 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << MinimumMoves ( arr , n , x ) ; return 0 ; }
int SumOfDigits ( string str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( str [ i ] - '0' ) ; return sum ; }
bool Divisible ( string str , int n ) { if ( SumOfDigits ( str , n ) % 3 == 0 and str [ n - 1 ] == '0' ) return true ; return false ; }
int main ( ) { string str = "263730746028908374890" ; int n = str . size ( ) ; if ( Divisible ( str , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
bool isPrime ( int k ) {
if ( k <= 1 ) return false ;
for ( int i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; }
int check ( int num , int k ) { int flag = 1 ;
for ( int i = 2 ; i < k ; i ++ ) { if ( num % i == 0 ) flag = 0 ; } if ( flag == 1 ) {
if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; }
int findCount ( int a , int b , int k ) { int count = 0 ;
if ( ! isPrime ( k ) ) return 0 ; else { int ans ; for ( int i = a ; i <= b ; i ++ ) {
ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; }
int main ( ) { int a = 2020 , b = 6300 , k = 29 ; cout << findCount ( a , b , k ) ; return 0 ; }
int NumberOfSolutions ( int a , int b , int c , int d ) {
int ans = 0 ;
for ( int i = a ; i <= b ; i ++ ) if ( d >= max ( c , i + 1 ) ) ans += d - max ( c , i + 1 ) + 1 ;
return ans ; }
int main ( ) { int a = 2 , b = 3 , c = 3 , d = 4 ;
cout << NumberOfSolutions ( a , b , c , d ) ; return 0 ; }
ll findF_N ( ll n ) { ll ans = 0 ; for ( ll i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; }
int main ( ) { ll n = 3 ; cout << findF_N ( n ) ; return 0 ; }
string findNumber ( int n , int d ) {
string ans = " " ; if ( d != 10 ) { ans += to_string ( d ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += " Impossible " ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; }
int main ( ) { int n = 12 , d = 3 ; cout << findNumber ( n , d ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000
int sieve_Prime [ MAX + 4 ] = { 0 } , sieve_count [ MAX + 4 ] = { 0 } ;
void form_sieve ( ) {
sieve_Prime [ 1 ] = 1 ;
for ( int i = 2 ; i <= MAX ; i ++ ) {
if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) {
if ( sieve_Prime [ j ] == 0 ) {
sieve_Prime [ j ] = 1 ;
sieve_count [ i ] ++ ; } } } } }
form_sieve ( ) ; int n = 2 ;
cout << " Count ▁ = ▁ " << ( sieve_count [ n ] + 1 ) << endl ; n = 3 ;
cout << " Count ▁ = ▁ " << ( sieve_count [ n ] + 1 ) << endl ; return 0 ; }
vector < int > PrimeFactors ( int n ) {
vector < int > v ; int x = n ;
for ( int i = 2 ; i * i <= n ; i ++ ) { if ( x % i == 0 ) {
v . push_back ( i ) ; while ( x % i == 0 ) x /= i ; } }
if ( x > 1 ) v . push_back ( x ) ; return v ; }
int GoodNumber ( int n ) {
vector < int > v = PrimeFactors ( n ) ;
int ans = 1 ;
for ( int i = 0 ; i < v . size ( ) ; i ++ ) ans *= v [ i ] ; return ans ; }
int main ( ) { int n = 12 ;
cout << GoodNumber ( n ) ; return 0 ; }
bool checkSpecialPrime ( bool * sieve , int num ) {
while ( num ) {
if ( ! sieve [ num ] ) { return false ; }
num /= 10 ; }
return true ; }
void findSpecialPrime ( int N ) { bool sieve [ N + 10 ] ;
memset ( sieve , true , sizeof ( sieve ) ) ; sieve [ 0 ] = sieve [ 1 ] = false ; for ( long long i = 2 ; i <= N ; i ++ ) { if ( sieve [ i ] ) { for ( long long j = i * i ; j <= N ; j += i ) { sieve [ j ] = false ; } } }
while ( true ) {
if ( checkSpecialPrime ( sieve , N ) ) {
cout << N << ' ' ; break ; }
else N -- ; } }
int main ( ) { findSpecialPrime ( 379 ) ; findSpecialPrime ( 100 ) ; return 0 ; }
bool isPrime ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; }
int main ( ) { int n = 13 ;
if ( isPrime ( n ) && ( n % 4 == 1 ) ) { cout << " YES " ; } else { cout << " NO " ; } return 0 ; }
float heightCalculate ( int H , int n , int m ) {
float N = n * 1.0 ; float M = m * 1.0 ;
float h = H * sqrt ( N / ( N + M ) ) ; return h ; }
int main ( ) { int H = 10 , n = 3 , m = 4 ; cout << heightCalculate ( H , n , m ) ; return 0 ; }
bool isprime ( int x ) {
for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; }
bool isNSqMinusnMSqPrime ( int m , int n ) { if ( n - m == 1 and isprime ( m + n ) ) return true ; else return false ; }
int main ( ) { int m = 13 , n = 16 ; if ( isNSqMinusnMSqPrime ( m , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
void findsolution ( ll n , ll x , ll y ) {
if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x y < n ) { cout << " No ▁ solution " ; return ; }
cout << y - n + 1 ;
while ( n -- > 1 ) cout << endl << 1 ; }
ll n , x , y ; n = 5 , x = 15 , y = 15 ; findsolution ( n , x , y ) ; return 0 ; }
int findPosition ( int n , int f , int b ) { return n - max ( f + 1 , n - b ) + 1 ; }
int main ( ) { int n = 5 , f = 2 , b = 3 ; cout << findPosition ( n , f , b ) ; return 0 ; }
int nthOdd ( int n ) { return ( 2 * n - 1 ) ; }
int main ( ) { int n = 10 ; cout << nthOdd ( n ) ; return 0 ; }
int nthEven ( int n ) { return ( 2 * n ) ; }
int main ( ) { int n = 10 ; cout << nthEven ( n ) ; return 0 ; }
double nthHarmonic ( int N ) {
float harmonic = 1.00 ;
for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; }
int main ( ) { int N = 8 ; cout << nthHarmonic ( N ) ; return 0 ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + n - 3 ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
int nthTerm ( int n ) { return 5 * pow ( n , 2 ) - 5 * n ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) + n - 2 ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 4 * n - 2 ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
int nthTerm ( int n ) { return 3 * pow ( n , 2 ) + 2 * n - 5 ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) + 3 * n - 5 ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 3 * n + 2 ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #include <cmath> NEW_LINE using namespace std ; #define PI  3.1415926535
double findAnglesA ( double a , double b , double c ) {
double A = acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) ;
return A * 180 / PI ; }
double findAnglesB ( double a , double b , double c ) {
double B = acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) ;
return B * 180 / PI ; }
void printAngles ( int a , int b , int c ) { double x = ( double ) a ; double y = ( double ) b ; double z = ( double ) c ;
double A = findAnglesA ( x , y , z ) ;
double B = findAnglesB ( x , y , z ) ; cout << " Angles ▁ are ▁ A ▁ = ▁ " << A << " , ▁ B ▁ = ▁ " << B << " , ▁ C ▁ = ▁ " << 90 << endl ; }
void printOtherSides ( int n ) { int b , c ;
if ( n & 1 ) {
if ( n == 1 ) cout << -1 << endl ; else { b = ( n * n - 1 ) / 2 ; c = ( n * n + 1 ) / 2 ; cout << " Side ▁ b ▁ = ▁ " << b << " , ▁ Side ▁ c ▁ = ▁ " << c << endl ; } } else {
if ( n == 2 ) cout << -1 << endl ; else { b = n * n / 4 - 1 ; c = n * n / 4 + 1 ; cout << " Side ▁ b ▁ = ▁ " << b << " , ▁ Side ▁ c ▁ = ▁ " << c << endl ; } }
printAngles ( n , b , c ) ; }
int main ( ) { int a = 12 ; printOtherSides ( a ) ; return 0 ; }
int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; }
int n = 3 ;
cout << " Sum ▁ = ▁ " << calculateSum ( n ) ; return 0 ; }
int nthTerm ( int n ) { return 2 * pow ( n , 2 ) - n - 1 ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) ; return 0 ; }
int nthTerm ( int n ) { return 4 * pow ( n , 2 ) - 7 * n + 3 ; }
int main ( ) { int N = 4 ; cout << nthTerm ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void checkIfPowerIsolated ( int num ) { int input = num ; int count = 0 ; int factor [ num + 1 ] = { 0 } ;
if ( num % 2 == 0 ) { while ( num % 2 == 0 ) { ++ count ; num /= 2 ; } factor [ 2 ] = count ; }
for ( int i = 3 ; i * i <= num ; i += 2 ) { count = 0 ; while ( num % i == 0 ) { ++ count ; num /= i ; } if ( count > 0 ) factor [ i ] = count ; } if ( num > 1 ) factor [ num ] = 1 ;
int product = 1 ; for ( int i = 0 ; i < num + 1 ; i ++ ) { if ( factor [ i ] > 0 ) product = product * factor [ i ] * i ; }
if ( product == input ) cout << " Power - isolated ▁ Integer STRNEWLINE " ; else cout << " Not ▁ a ▁ Power - isolated ▁ Integer STRNEWLINE " ; }
int main ( ) { checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ; return 0 ; }
long long int getNthTerm ( long long int N ) {
return ( pow ( N , 2 ) + N + 1 ) ; }
long long int N = 11 ;
cout << getNthTerm ( N ) ; return 0 ; }
ll findSum ( int n ) { ll sum2 , sum5 , sum10 ;
sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ;
sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ;
sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; }
int main ( ) { int n = 5 ; cout << findSum ( n ) << endl ; return 0 ; }
float CalculateRatio ( float m , float n ) {
return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; }
int main ( ) { float m = 6 , n = 2 ; cout << CalculateRatio ( m , n ) ; return 0 ; }
int calculateSum ( int n ) {
return pow ( n * ( n + 1 ) / 2 , 2 ) ; }
int main ( ) { int n = 4 ; cout << calculateSum ( n ) ; return 0 ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int powerDigitSum ( int a , int n ) { int res = 1 ; while ( n ) { if ( n % 2 == 1 ) { res = res * digSum ( a ) ; res = digSum ( res ) ; } a = digSum ( digSum ( a ) * digSum ( a ) ) ; n /= 2 ; } return res ; }
int main ( ) { int a = 9 , n = 4 ; cout << powerDigitSum ( a , n ) ; return 0 ; }
int totEdge ( int n ) { int result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; }
int main ( ) { int n = 6 ; cout << totEdge ( n ) ; return 0 ; }
int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ;
one = X * 1 ; fifty = ( ( Y * 1 ) / 2.0 ) ; twentyfive = ( ( Z * 1 ) / 4.0 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return result ; }
int main ( ) { int totalRupees = 1800 ; int X = 1 , Y = 2 , Z = 4 ; int Rupees = coin ( totalRupees , X , Y , Z ) ; cout << "1 ▁ rupess ▁ coins ▁ = ▁ " << Rupees * 1 << endl ; cout << "50 ▁ paisa ▁ coins ▁ = ▁ " << Rupees * 2 << endl ; cout << "25 ▁ paisa ▁ coins ▁ = ▁ " << Rupees * 4 << endl ; return 0 ; }
float sumOfSeries ( int x , int k ) { return ( float ( x ) / 81 ) * ( 9 * k - 1 + pow ( 10 , ( -1 ) * k ) ) ; }
int main ( ) { int x = 9 ; int k = 20 ; cout << sumOfSeries ( x , k ) ; return 0 ; }
int modExp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b & 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; }
int check ( int num ) {
if ( num & 1 num < 3 ) return -1 ;
else if ( num % 4 == 0 ) return modExp ( num / 4 , 4 ) ;
else if ( num % 6 == 0 ) return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) ;
else if ( num % 10 == 0 ) return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ;
else return -1 ; }
int main ( ) { int num = 10 ; cout << check ( num ) ; return 0 ; }
bool isDivisible ( long long int n ) { while ( n / 100 ) {
int d = n % 10 ;
n /= 10 ;
n -= d * 5 ; }
return ( n % 17 == 0 ) ; }
int main ( ) { long long int n = 19877658 ; if ( isDivisible ( n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int nextPowerOf2 ( unsigned int n ) { unsigned count = 0 ;
if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; }
int removeElement ( unsigned int n ) { if ( n == 1 n == 2 ) return 0 ; unsigned int a = nextPowerOf2 ( n ) ; if ( n == a n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; }
int main ( ) { unsigned int n = 5 ;
cout << removeElement ( n ) ; return 0 ; }
int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; }
int trainLength = 120 ; int Speed = 30 ; int Time = 18 ; cout << " Length ▁ of ▁ bridge ▁ = ▁ " << bridge_length ( trainLength , Speed , Time ) << " ▁ meters " ; return 0 ; }
long long modInv ( long long x ) { long long n = MOD - 2 ; long long result = 1 ; while ( n ) { if ( n & 1 ) result = result * x % MOD ; x = x * x % MOD ; n = n / 2 ; } return result ; }
long long getSum ( long long n , long long k ) { long long ans = 1 ; for ( long long i = n + 1 ; i > n - k ; i -- ) ans = ans * i % MOD ; ans = ans * modInv ( k + 1 ) % MOD ; return ans ; }
int main ( ) { long long n = 3 , k = 2 ; cout << getSum ( n , k ) ; return 0 ; }
void printCombination ( int n ) { cout << 1 << " ▁ " ;
if ( ( n - 2 ) % 3 == 0 ) cout << 2 << " ▁ " << n - 3 ; else cout << 1 << " ▁ " << n - 2 ; }
int main ( ) { int n = 233 ; printCombination ( n ) ; return 0 ; }
bool checkPairs ( int l , int r ) {
if ( ( l - r ) % 2 == 0 ) return false ;
return true ; }
int main ( ) { int l = 1 , r = 8 ; if ( checkPairs ( l , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool isPalindrome ( int n ) {
if ( n % 11 == 0 ) { return true ; }
return false ; }
int main ( ) { isPalindrome ( 123321 ) ? cout << " Palindrome " : cout << " Not ▁ Palindrome " ; return 0 ; }
int target = 93 ; int arr [ ] = { 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 } ; int length = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
int totalCount = 0 ;
for ( int i = 0 ; i < length - 2 ; i ++ ) {
if ( target % arr [ i ] == 0 ) { for ( int j = i + 1 ; j < length - 1 ; j ++ ) {
if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) {
int toFind = target / ( arr [ i ] * arr [ j ] ) ; for ( int k = j + 1 ; k < length ; k ++ ) {
if ( arr [ k ] == toFind ) { totalCount ++ ; } } } } } } cout << " Total ▁ number ▁ of ▁ triplets ▁ found ▁ : ▁ " << totalCount ; return 0 ; }
unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ;
if ( k > n - k ) k = n - k ;
for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
unsigned long int catalan ( unsigned int n ) {
unsigned long int c = binomialCoeff ( 2 * n , n ) ;
return c / ( n + 1 ) ; }
int main ( ) { int n = 3 ; cout << catalan ( n ) << endl ; return 0 ; }
bool isFascinating ( int num ) {
int freq [ 10 ] = { 0 } ;
string val = " " + to_string ( num ) + to_string ( num * 2 ) + to_string ( num * 3 ) ;
for ( int i = 0 ; i < val . length ( ) ; i ++ ) {
int digit = val [ i ] - '0' ;
if ( freq [ digit ] and digit != 0 > 0 ) return false ; else freq [ digit ] ++ ; }
for ( int i = 1 ; i < 10 ; i ++ ) { if ( freq [ i ] == 0 ) return false ; } return true ; }
int num = 192 ;
if ( num < 100 ) cout << " No " << endl ; else {
bool ans = isFascinating ( num ) ; if ( ans ) cout << " Yes " ; else cout << " No " ; } }
int binomial_coefficient ( int n , int m ) { int res = 1 ; if ( m > n - m ) m = n - m ; for ( int i = 0 ; i < m ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
int calculate_ways ( int m , int n ) {
if ( m < n ) return 0 ;
int ways = binomial_coefficient ( n + m - 1 , n - 1 ) ; return ways ; }
int m = 7 , n = 5 ; int result = calculate_ways ( m , n ) ; printf ( " % d STRNEWLINE " , result ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005
int phi [ N ] ;
int S [ N ] ;
void computeTotient ( ) {
for ( int i = 1 ; i < N ; i ++ ) phi [ i ] = i ;
for ( int p = 2 ; p < N ; p ++ ) {
if ( phi [ p ] == p ) {
phi [ p ] = p - 1 ;
for ( int i = 2 * p ; i < N ; i += p ) {
phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } }
void CoPrimes ( ) {
computeTotient ( ) ;
for ( int i = 1 ; i < N ; i ++ ) S [ i ] = S [ i - 1 ] + phi [ i ] ; }
CoPrimes ( ) ; int q [ ] = { 3 , 4 } ; int n = sizeof ( q ) / sizeof ( q [ 0 ] ) ; for ( int i = 0 ; i < n ; i ++ ) cout << " Number ▁ of ▁ unordered ▁ coprime STRNEWLINE " << " pairs ▁ of ▁ integers ▁ from ▁ 1 ▁ to ▁ " << q [ i ] << " ▁ are ▁ " << S [ q [ i ] ] << endl ; return 0 ; }
int binaryToDecimal ( string n ) { string num = n ; int dec_value = 0 ;
int base = 1 ; int len = num . length ( ) ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_value += base ; base = base * 2 ; } return dec_value ; }
int numberSequence ( int n ) {
if ( n == 1 ) return 1 ;
string s = " " ;
for ( int i = 1 ; i < n ; i ++ ) s += '1' ;
s += '0' ;
for ( int i = 1 ; i <= n ; i ++ ) s += '1' ; int num = binaryToDecimal ( s ) ; return num ; }
int main ( ) { int n = 4 ; cout << numberSequence ( n ) ; return 0 ; }
int numberSequence ( int n ) {
int num = pow ( 4 , n ) - pow ( 2 , n ) - 1 ; return num ; }
int main ( ) { int n = 4 ; cout << numberSequence ( n ) ; return 0 ; }
int prime ( int num ) { int i , flag = 0 ; for ( i = 2 ; i <= num / 2 ; i ++ ) { if ( num % i == 0 ) { flag = 1 ; break ; } }
if ( flag == 0 ) return 1 ; else return 0 ; }
void print_alternate_prime ( int n ) {
int counter = 0 ;
for ( int num = 2 ; num < n ; num ++ ) {
if ( prime ( num ) == 1 ) {
if ( counter % 2 == 0 ) cout << num << " ▁ " ; counter ++ ; } } }
int main ( ) { int n = 15 ; cout << " Following ▁ are ▁ the ▁ alternate ▁ prime " << " ▁ number ▁ smaller ▁ than ▁ or ▁ equal ▁ to ▁ " << n << endl ;
print_alternate_prime ( n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void SieveOfEratosthenes ( int n ) {
bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } }
bool flag = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { if ( flag ) { cout << p << " ▁ " ; flag = false ; } else {
flag = true ; } } } }
int main ( ) { int n = 15 ; cout << " Following ▁ are ▁ the ▁ alternate " << " ▁ prime ▁ numbers ▁ smaller ▁ " << " ▁ than ▁ or ▁ equal ▁ to ▁ " << n << endl ; SieveOfEratosthenes ( n ) ; return 0 ; }
bool findGreater ( int x , int y ) {
if ( x > y ) { return false ; }
else { return true ; } }
int main ( ) { int x = 4 ; int y = 9 ; findGreater ( x , y ) ? cout << "1 STRNEWLINE " : cout << "2 STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int max_profit ( int a [ ] , int b [ ] , int n , int fee ) { int i , j , profit ; int l , r , diff_day = 1 , sum = 0 ;
b [ 0 ] = 0 ;
b [ 1 ] = diff_day ; for ( i = 1 ; i < n ; i ++ ) { l = 0 ; r = diff_day ; sum = 0 ; for ( j = n - 1 ; j >= i ; j -- ) {
profit = ( a [ r ] - a [ l ] ) - fee ;
if ( profit > 0 ) { sum = sum + profit ; } l ++ ; r ++ ; }
if ( b [ 0 ] < sum ) { b [ 0 ] = sum ; b [ 1 ] = diff_day ; } diff_day ++ ; } return 0 ; }
int main ( ) { int arr [ ] = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int b [ 2 ] ; int tranFee = 2 ; max_profit ( arr , b , n , tranFee ) ; cout << b [ 0 ] << " , ▁ " << b [ 1 ] << endl ; return 0 ; }
int binomialCoeff ( int x , int n , int k ) { int sum = 0 , term = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; if ( sum > k ) return sum ; } return sum ; }
int minTrials ( int n , int k ) {
int low = 1 , high = k ;
while ( low < high ) { int mid = ( low + high ) / 2 ; if ( binomialCoeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; }
int main ( ) { cout << minTrials ( 2 , 10 ) ; return 0 ; }
#include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; bool isPrime ( int num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( int i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; } int primePalindrome ( int N ) {
if ( 8 <= N && N <= 11 ) return 11 ;
for ( int x = 1 ; x < 100000 ; ++ x ) { string s = to_string ( x ) , r ( s . rbegin ( ) , s . rend ( ) ) ; int y = stoi ( s + r . substr ( 1 ) ) ;
if ( y >= N && isPrime ( y ) ) return y ; } return -1 ; }
int main ( ) { cout << primePalindrome ( 112 ) ; return 0 ; }
int getsum ( int a ) { int r = 0 , sum = 0 ; while ( a > 0 ) { r = a % 10 ; sum = sum + r ; a = a / 10 ; } return sum ; }
void value ( int a , int b , int c ) { int co = 0 , p = 0 ; int no , r = 0 , x = 0 , q = 0 , w = 0 ; vector < int > v ; for ( int i = 1 ; i < 82 ; i ++ ) {
no = pow ( ( double ) i , double ( a ) ) ;
no = b * no + c ; if ( no > 0 && no < 1000000000 ) { x = getsum ( no ) ;
if ( x == i ) {
q ++ ;
v . push_back ( no ) ; w ++ ; } } }
for ( int i = 0 ; i < v . size ( ) ; i ++ ) { cout << v [ i ] << " ▁ " ; } }
int main ( ) { int a = 2 , b = 2 , c = -1 ;
value ( a , b , c ) ; return 0 ; }
void print ( int p0 ) { int p1 , i = 0 , x , flag , k ;
while ( 1 ) { flag = 1 ; x = ( int ) ( pow ( 2 , i ) ) ; p1 = x * p0 - ( x - 1 ) ;
for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; printf ( " % d ▁ " , p1 ) ; i ++ ; } }
int main ( ) { int p0 = 19 ; print ( p0 ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findOddPair ( int A [ ] , int N ) {
int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ;
return count * ( count - 1 ) / 2 ; }
int main ( ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
cout << findOddPair ( a , n ) << endl ; return 0 ; }
bool isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) {
int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; }
int main ( ) { int n = 15 ; if ( isSurd ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int LastTwoDigit ( long long int num ) {
int one = num % 10 ;
num /= 10 ;
int tens = num % 10 ;
tens *= 10 ;
num = tens + one ;
return num ; }
int main ( ) { int n = 10 ; long long int num = 1 ;
num = pow ( 2 , n ) ; cout << " Last ▁ " << 2 ; cout << " ▁ digits ▁ of ▁ " << 2 ; cout << " ^ " << n << " ▁ = ▁ " ; cout << LastTwoDigit ( num ) << endl ; return 0 ; }
int power ( long long int x , long long int y , long long int p ) {
while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
int numberOfDigits ( int x ) { int i = 0 ; while ( x ) { x /= 10 ; i ++ ; } return i ; }
void LastTwoDigit ( int n ) { cout << " Last ▁ " << 2 ; cout << " ▁ digits ▁ of ▁ " << 2 ; cout << " ^ " << n << " ▁ = ▁ " ;
int temp = 1 ; for ( int i = 1 ; i <= 2 ; i ++ ) temp *= 10 ;
temp = power ( 2 , n , temp ) ;
for ( int i = 0 ; i < 2 - numberOfDigits ( temp ) ; i ++ ) cout << 0 ;
if ( temp ) cout << temp ; }
int main ( ) { int n = 72 ; LastTwoDigit ( n ) ; return 0 ; }
ll modPower ( ll x , ll y , ll p ) {
while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
ll gcdPow ( ll a , ll n , ll c ) {
if ( a % c == 0 ) return c ;
ll modexpo = modPower ( a , n , c ) ;
return gcd ( modexpo , c ) ; }
int main ( ) { ll a = 10248585 , n = 1000000 , c = 12564 ; cout << gcdPow ( a , n , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOddSum ( int ar [ ] , int n ) { int result = 0 ;
for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; }
int main ( ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << " The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ odd " " ▁ sum ▁ is ▁ " << countOddSum ( ar , n ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOddSum ( int ar [ ] , int n ) {
int temp [ 2 ] = { 1 , 0 } ;
int result = 0 , val = 0 ;
for ( int i = 0 ; i <= n - 1 ; i ++ ) {
val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ;
temp [ val ] ++ ; }
result = ( temp [ 0 ] * temp [ 1 ] ) ; return ( result ) ; }
int main ( ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << " The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ odd " " ▁ sum ▁ is ▁ " << countOddSum ( ar , n ) ; return ( 0 ) ; }
#include <iostream> NEW_LINE using namespace std ; void printPFsInPairs ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) cout << i << " * " << n / i << endl ; }
int main ( ) { int n = 24 ; printPFsInPairs ( n ) ; return 0 ; }
int rangesum ( int n , int l , int r ) {
int arr [ n ] ;
int c = 1 , i = 0 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; }
c = 2 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } int sum = 0 ;
for ( i = l - 1 ; i < r ; i ++ ) { sum += arr [ i ] ; } return sum ; }
int main ( ) { int n = 12 ; int l = 1 , r = 11 ; cout << ( rangesum ( n , l , r ) ) ; }
void findAngle ( int n ) { int interiorAngle , exteriorAngle ;
interiorAngle = ( n - 2 ) * 180 / n ;
exteriorAngle = 360 / n ;
cout << " Interior ▁ angle : ▁ " << interiorAngle << endl ; cout << " Exterior ▁ angle : ▁ " << exteriorAngle ; }
int main ( ) { int n = 10 ;
findAngle ( n ) ; return 0 ; }
void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float d = sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) + pow ( z2 - z1 , 2 ) * 1.0 ) ; std :: cout << std :: fixed ; std :: cout << std :: setprecision ( 2 ) ; cout << " ▁ Distance ▁ is ▁ " << d ; return ; }
int main ( ) { float x1 = 2 ; float y1 = -5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ;
distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; return 0 ; }
bool DivisibleBy41 ( int first , int second , int c , int n ) {
int digit [ n ] ;
digit [ 0 ] = first ; digit [ 1 ] = second ;
for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ;
int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ;
if ( ans % 41 == 0 ) return true ; else return false ; }
int main ( ) { int first = 1 , second = 2 , c = 1 , n = 3 ; if ( DivisibleBy41 ( first , second , c , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int findTetrahedralNumber ( int n ) { return ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ; }
void printSeries ( int n ) {
int prev = 0 ; int curr ;
for ( int i = 1 ; i <= n ; i ++ ) {
curr = findTetrahedralNumber ( i ) ;
curr = curr + prev ; cout << curr << " ▁ " ;
prev = curr ; } }
int main ( ) { int n = 10 ;
printSeries ( n ) ; return 0 ; }
void printSeries ( int n ) {
for ( int i = 1 ; i <= n ; i ++ ) {
int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; cout << num << " ▁ " ; } }
int main ( ) { int n = 10 ;
printSeries ( n ) ; return 0 ; }
long findTriangularNumber ( int n ) { return ( n * ( n + 1 ) ) / 2 ; }
void printSeries ( int n ) {
int prev = 0 ; int curr ;
for ( int i = 1 ; i <= n ; i ++ ) {
curr = findTriangularNumber ( i ) ;
curr = curr + prev ; cout << curr << " ▁ " ;
prev = curr ; } }
int main ( ) { int n = 10 ;
printSeries ( n ) ; return 0 ; }
void printSeries ( int n ) {
for ( int i = 1 ; i <= n ; i ++ ) {
int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; cout << num << " ▁ " ; } }
int main ( ) { int n = 10 ;
printSeries ( n ) ; return 0 ; }
void count_even_odd ( int min , int max , int steps [ ] [ 2 ] ) { int a , b , even , odd ;
bool beven = true , aeven = false ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { a = steps [ i ] [ 0 ] , b = steps [ i ] [ 1 ] ;
if ( ! ( aeven a & 1 ) ) aeven = true ;
if ( beven ) { if ( b & 1 ) beven = false ; } else if ( ! ( a & 1 ) ) { if ( ! ( b & 1 ) ) beven = true ; } else { if ( b & 1 ) beven = true ; } }
if ( beven ) { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } else { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; }
if ( ! ( beven ^ aeven ) ) even += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; else odd += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ;
cout << " even ▁ = ▁ " << even << " , ▁ odd ▁ = ▁ " << odd << endl ; }
int main ( ) { int min = 1 , max = 4 ; int steps [ ] [ 2 ] = { { 1 , 2 } , { 3 , 4 } } ; count_even_odd ( min , max , steps ) ; return 0 ; }
int getMaxOnes ( int n , int x ) {
int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ;
int total = n * n ;
int ans = total - zeroes ; return ans ; }
int n = 5 ; int x = 2 ; cout << getMaxOnes ( n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void check ( int n , int m ) {
if ( n == 2 m == 2 n % m == 0 ) { cout << " Yes " << endl ; }
else { cout << " No " << endl ; } }
int main ( ) { int m = 3 , n = 9 ; check ( n , m ) ; return 0 ; }
void findSurfaceArea ( float a , float h ) { float Area ;
Area = 6 * a * h + 3 * sqrt ( 3 ) * a * a ;
cout << " Surface ▁ Area : ▁ " << Area ; cout << " STRNEWLINE " ; }
void findVolume ( float a , float h ) { float Volume ;
Volume = 3 * sqrt ( 3 ) * a * a * h / 2 ;
cout << " Volume : ▁ " << Volume ; }
int main ( ) { float a = 5 , h = 10 ;
findSurfaceArea ( a , h ) ;
findVolume ( a , h ) ; return 0 ; }
long long int MinimumMail ( int n , int k , int x ) {
ll m = ( n - 1 ) + ( ll ) ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + ( ll ) ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; }
int N = 4 ;
int K = 9 ;
int X = 2 ;
cout << MinimumMail ( N , K , X ) << endl ; return 0 ; }
void findArea ( float a , float b ) { float Area ;
Area = 3.142 * a * b ;
cout << " Area : ▁ " << Area ; }
int main ( ) { float a = 5 , b = 4 ; findArea ( a , b ) ; return 0 ; }
int calculate ( int x , int k , int m ) { int result = x ; k -- ;
while ( k -- ) { result = pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; }
int main ( ) { int x = 5 , k = 2 , m = 3 ;
cout << calculate ( x , k , m ) ; return 0 ; }
int rev ( int n , int temp ) {
if ( n == 0 ) return temp ;
temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; }
int main ( ) { int n = 121 ; int temp = rev ( n , 0 ) ; if ( temp == n ) cout << " yes " << endl ; else cout << " no " << endl ; return 0 ; }
void findGreater ( int a , int b , int n ) {
if ( ! ( n & 1 ) ) { a = abs ( a ) ; b = abs ( b ) ; } if ( a == b ) cout << " a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n " ; else if ( a > b ) cout << " a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n " ; else cout << " b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n " ; }
int main ( ) { int a = 12 , b = 24 , n = 5 ; findGreater ( a , b , n ) ; return 0 ; }
void fibonacci ( int n ) { long long int fib ; for ( long long int i = 0 ; i < n ; i ++ ) {
fib = ( pow ( ( 1 + sqrt ( 5 ) ) , i ) - pow ( ( 1 - sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * sqrt ( 5 ) ) ; cout << fib << " ▁ " ; } }
int main ( ) { long long int n = 8 ; fibonacci ( n ) ; return 0 ; }
int center_hexadecagonal_num ( long int n ) {
return 8 * n * n - 8 * n + 1 ; }
int main ( ) { long int n = 2 ; cout << n << " th ▁ centered ▁ hexadecagonal ▁ number ▁ : ▁ " << center_hexadecagonal_num ( n ) ; cout << endl ; n = 12 ; cout << n << " th ▁ centered ▁ hexadecagonal ▁ numbe ▁ : ▁ " << center_hexadecagonal_num ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100
bool findNature ( int a , int b , int n ) { int seq [ MAX ] = { 0 } ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ;
return ( seq [ n ] & 1 ) ; }
int main ( ) { int a = 2 , b = 4 ; int n = 3 ; ( findNature ( a , b , n ) ? ( cout << " Odd " << " ▁ " ) : ( cout << " Even " << " ▁ " ) ) ; return 0 ; }
void check ( unsigned long long m , unsigned long long int n ) {
double RHS = m * ( double ) log ( n ) ;
double LHS = n * ( double ) log ( m ) ; if ( LHS > RHS ) cout << " m ^ n ▁ > ▁ n ^ m " ; else if ( LHS < RHS ) cout << " m ^ n ▁ < ▁ n ^ m " ; else cout << " m ^ n ▁ = ▁ n ^ m " ; }
int main ( ) { unsigned long long m = 987654321 , n = 123456987 ;
check ( m , n ) ; return 0 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int maxDivisorRange ( int a , int b , int l , int h ) { int g = gcd ( a , b ) ; int res = -1 ;
for ( int i = l ; i * i <= g && i <= h ; i ++ )
if ( g % i == 0 ) res = max ( { res , i , g / i } ) ; return res ; }
int main ( ) { int a = 3 , b = 27 , l = 1 , h = 5 ; cout << maxDivisorRange ( a , b , l , h ) << endl ; return 0 ; }
void checksum ( int n ) {
if ( n == 0 ) { cout << " - 2 ▁ - 1 ▁ 0 ▁ 1 ▁ 2" << endl ; return ; } int inc ;
if ( n > 0 ) inc = 1 ;
else inc = -1 ;
for ( int i = 0 ; i <= n - 4 ; i += inc ) {
if ( i + i + 1 + i + 2 + i + 3 + i + 4 == n ) { cout << i << " ▁ " << i + 1 << " ▁ " << i + 2 << " ▁ " << i + 3 << " ▁ " << i + 4 ; return ; } } cout << " - 1" ; }
int main ( ) { int n = 15 ; checksum ( n ) ; return 0 ; }
void checksum ( int n ) {
if ( n % 5 == 0 ) cout << n / 5 - 2 << " ▁ " << n / 5 - 1 << " ▁ " << n / 5 << " ▁ " << n / 5 + 1 << " ▁ " << n / 5 + 2 ;
else cout < < " - 1" ; }
int main ( ) { int n = 15 ; checksum ( n ) ; return 0 ; }
int sumOfSeries ( int n ) {
int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; }
int main ( ) { int n = 4 ; cout << sumOfSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; }
int main ( ) { int N = 4 ; cout << " Number ▁ of ▁ unmarked ▁ elements : ▁ " << countUnmarked ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int calculateSeries ( int n ) { return factorial ( n + 1 ) - 1 ; }
int main ( ) { int n = 3 ; cout << calculateSeries ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; }
int calculateSeries ( int n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; }
int main ( ) { int n = 3 ; cout << calculateSeries ( n ) ; return 0 ; }
int minimumLength ( int x , int y , int z ) { return 1 + abs ( x - y ) + abs ( y - z ) ; }
int main ( ) { int x = 3 , y = 1 , z = 2 ; cout << minimumLength ( x , y , z ) ; return 0 ; }
void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) {
cout << " x2 ▁ = ▁ " << ( float ) ( 2 * c1 - x1 ) << " ▁ " ;
cout << " y2 ▁ = ▁ " << ( float ) ( 2 * c2 - y1 ) ; }
int main ( ) { int x1 = -4 , y1 = -1 ; int c1 = 3 , c2 = 5 ; endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) ; return 0 ; }
float proterm ( int i , float value , float x [ ] ) { float pro = 1 ; for ( int j = 0 ; j < i ; j ++ ) { pro = pro * ( value - x [ j ] ) ; } return pro ; }
void dividedDiffTable ( float x [ ] , float y [ ] [ 10 ] , int n ) { for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) { y [ j ] [ i ] = ( y [ j ] [ i - 1 ] - y [ j + 1 ] [ i - 1 ] ) / ( x [ j ] - x [ i + j ] ) ; } } }
float applyFormula ( float value , float x [ ] , float y [ ] [ 10 ] , int n ) { float sum = y [ 0 ] [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum = sum + ( proterm ( i , value , x ) * y [ 0 ] [ i ] ) ; } return sum ; }
void printDiffTable ( float y [ ] [ 10 ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) { cout << setprecision ( 4 ) << y [ i ] [ j ] << " TABSYMBOL ▁ " ; } cout << " STRNEWLINE " ; } }
int n = 4 ; float value , sum , y [ 10 ] [ 10 ] ; float x [ ] = { 5 , 6 , 9 , 11 } ;
y [ 0 ] [ 0 ] = 12 ; y [ 1 ] [ 0 ] = 13 ; y [ 2 ] [ 0 ] = 14 ; y [ 3 ] [ 0 ] = 16 ;
dividedDiffTable ( x , y , n ) ;
printDiffTable ( y , n ) ;
value = 7 ;
cout << " Value at " ▁ < < ▁ value ▁ < < ▁ " is " << applyFormula ( value , x , y , n ) << endl ; return 0 ; }
int centered_heptagonal_num ( long int n ) {
return ( 7 * n * n - 7 * n + 2 ) / 2 ; }
int main ( ) { long int n = 5 ; cout << n << " th ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ " ; cout << centered_heptagonal_num ( n ) ; return 0 ; }
int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; }
int main ( ) { int n = 3 ; cout << findSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  4
bool checkHankelMatrix ( int n , int m [ N ] [ N ] ) {
for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = 0 ; j < n ; j ++ ) {
if ( i + j < n ) {
if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else {
if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; }
int main ( ) { int n = 4 ; int m [ N ] [ N ] = { { 1 , 2 , 3 , 5 } , { 2 , 3 , 5 , 8 } , { 3 , 5 , 8 , 0 } , { 5 , 8 , 0 , 9 } } ; checkHankelMatrix ( n , m ) ? ( cout << " Yes " ) : ( cout << " No " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPower ( unsigned int n ) {
for ( int x = 2 ; x <= sqrt ( n ) ; x ++ ) { float f = log ( n ) / log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; }
int main ( ) { for ( int i = 2 ; i < 100 ; i ++ ) if ( isPower ( i ) ) cout << i << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000005
void sumOddDigit ( int digitSum [ ] ) {
for ( int i = 1 ; i < N ; i ++ ) {
digitSum [ i ] = digitSum [ i / 10 ] + ( i & 1 ) * ( i % 10 ) ; } }
void sumFactor ( int digitSum [ ] , int factorDigitSum [ ] ) {
for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j += i ) {
factorDigitSum [ j ] += digitSum [ i ] ; } } }
void wrapper ( int q , int n [ ] ) { int digitSum [ N ] ; int factorDigitSum [ N ] ; sumOddDigit ( digitSum ) ; sumFactor ( digitSum , factorDigitSum ) ; for ( int i = 0 ; i < q ; i ++ ) cout << factorDigitSum [ n [ i ] ] << " ▁ " ; }
int main ( ) { int q = 2 ; int n [ ] = { 10 , 36 } ; wrapper ( q , n ) ; return 0 ; }
int number_of_digits ( int n ) { int i , res , sum = 0 ;
for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; }
int main ( ) { int n = 21 ; cout << number_of_digits ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void Reverseorder ( int n ) {
bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } }
for ( int p = n ; p >= 2 ; p -- ) if ( prime [ p ] ) cout << p << " ▁ " ; }
int N = 25 ;
cout << " Prime ▁ number ▁ in ▁ reverse ▁ order " << endl ; if ( N == 1 ) cout << " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ; else
return 0 ; }
int magicOfSequence ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; }
int main ( ) { int N = 4 ; cout << magicOfSequence ( N ) << endl ; return 0 ; }
int countOddFactors ( long long n ) { int odd_factors = 0 ; for ( int i = 1 ; 1ll * i * i <= n ; i ++ ) { if ( n % i == 0 ) {
if ( 1ll * i * i == n ) { if ( i & 1 ) odd_factors ++ ; }
else { if ( i & 1 ) odd_factors ++ ; int factor = n / i ; if ( factor & 1 ) odd_factors ++ ; } } } return odd_factors - 1 ; }
long long int N = 15 ; cout << countOddFactors ( N ) << endl ; N = 10 ; cout << countOddFactors ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPossibleToZero ( int a [ ] , int n ) {
int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( i & 1 ) odd += a [ i ] ;
else even += a [ i ] ; } return ( odd == even ) ; }
int main ( ) { int arr [ ] = { 0 , 1 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( isPossibleToZero ( arr , n ) ) cout << " YES " ; else cout << " NO " ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const double PI = 3.142 ; double cosXSertiesSum ( double x , int n ) {
x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * -1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; }
int main ( ) { float x = 50 ; int n = 5 ; cout << cosXSertiesSum ( x , 5 ) ; return 0 ; }
int solve ( int n , int base ) {
int result = 0 ;
while ( n > 0 ) { int remainder = n % base ; result = result + remainder ; n = n / base ; }
return result ; } void printSumsOfDigits ( int n ) {
for ( int base = 2 ; base < n ; ++ base ) cout << solve ( n , base ) << " ▁ " ; }
int main ( ) { int n = 8 ; printSumsOfDigits ( n ) ; return 0 ; }
bool check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; }
int main ( ) { int N = 5 ; int M = 7 ; if ( check ( N , M ) ) cout << " yes " ; else cout << " no " ; return 0 ; }
int perfectSquare ( string s ) {
int n = s . size ( ) ;
int ans = -1 ;
string num ;
for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { string str = " " ; for ( int j = 0 ; j < n ; j ++ ) {
if ( ( i >> j ) & 1 ) { str += s [ j ] ; } }
if ( str [ 0 ] != '0' ) {
int temp = 0 ; for ( int j = 0 ; j < str . size ( ) ; j ++ ) temp = temp * 10 + ( int ) ( str [ j ] - '0' ) ; int k = sqrt ( temp ) ;
if ( k * k == temp ) {
if ( ans < ( int ) str . size ( ) ) { ans = ( int ) str . size ( ) ; num = str ; } } } } if ( ans == -1 ) return ans ; else {
cout << num << " ▁ " ; return n - ans ; } }
int main ( ) { cout << perfectSquare ( "8314" ) << endl ; cout << perfectSquare ( "753" ) << endl ; return 0 ; }
void printFourSquares ( int a ) {
for ( int i = 0 ; i * i <= a ; i ++ ) { for ( int j = i ; j * j <= a ; j ++ ) { for ( int k = j ; k * k <= a ; k ++ ) { for ( int l = k ; l * l <= a ; l ++ ) {
if ( i * i + j * j + k * k + l * l == a ) {
cout << a << " ▁ = ▁ " << i << " * " << i << " ▁ + ▁ " << j << " * " << j << " ▁ + ▁ " ; cout << k << " * " << k << " ▁ + ▁ " << l << " * " << l << " STRNEWLINE " ; } } } } } }
int main ( ) { int a = 74 ;
printFourSquares ( a ) ; return 0 ; }
int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; }
for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } }
if ( n > 2 ) count ++ ; return count ; }
int main ( ) { int n = 51242183 ; cout << " The ▁ number ▁ of ▁ distinct ▁ prime ▁ factors ▁ is / are ▁ " << exactPrimeFactorCount ( n ) << endl ; cout << " The ▁ value ▁ of ▁ log ( log ( n ) ) ▁ is ▁ " << log ( log ( n ) ) << endl ; return 0 ; }
int no_of_digit ( int a , int b ) { return ( ( int ) ( b * log10 ( a ) ) + 1 ) ; }
int main ( ) { int a = 2 , b = 100 ; cout << " no . ▁ of ▁ digits ▁ = ▁ " << no_of_digit ( a , b ) ; }
int checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ;
++ cnt ; } }
if ( num > 1 ) ++ cnt ;
return cnt == 2 ; }
bool isEmirpimes ( int n ) {
if ( checkSemiprime ( n ) == false ) return false ;
int r = 0 ; for ( int t = n ; t != 0 ; t = t / n ) r = r * 10 + t % 10 ;
if ( r == n ) return false ;
return ( checkSemiprime ( r ) ) ; }
int main ( ) { int n = 15 ; if ( isEmirpimes ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
unsigned long long int factorial ( unsigned int n ) { unsigned long long int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
void printNComposite ( int n ) { unsigned long long int fact = factorial ( n + 1 ) ; for ( int i = 2 ; i <= n + 1 ; ++ i ) cout << fact + i << " ▁ " ; }
int main ( ) { int n = 4 ; printNComposite ( n ) ; return 0 ; }
vector < long long int > primes ( long long int n ) { bool prime [ n + 1 ] ;
memset ( prime , true , sizeof ( prime ) ) ; for ( int i = 2 ; i * i <= n ; i ++ ) {
if ( prime [ i ] == true ) {
for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } }
vector < long long int > arr ; for ( int i = 2 ; i < n ; i ++ ) if ( prime [ i ] ) arr . push_back ( i ) ; return arr ; }
int countDigits ( long long int n ) { long long int temp = n ; int c = 0 ; while ( temp != 0 ) { temp = temp / 10 ; c ++ ; } return c ; }
bool frugal ( long long int n ) { vector < long long int > r = primes ( n ) ; long long int t = n ;
long long int s = 0 ; for ( int i = 0 ; i < r . size ( ) ; i ++ ) { if ( t % r [ i ] == 0 ) {
long long int k = 0 ;
while ( t % r [ i ] == 0 ) { t = t / r [ i ] ; k ++ ; }
if ( k == 1 ) s = s + countDigits ( r [ i ] ) ; else if ( k != 1 ) s = s + countDigits ( r [ i ] ) + countDigits ( k ) ; } }
return ( countDigits ( n ) > s && s != 0 ) ; }
int main ( ) { long long int n = 343 ; if ( frugal ( n ) ) cout << " A ▁ Frugal ▁ number STRNEWLINE " ; else cout << " Not ▁ a ▁ frugal ▁ number STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nthSquareCube ( int n ) { return n * n * n * n * n * n ; }
int main ( ) { int n = 5 ; cout << nthSquareCube ( n ) ; return 0 ; }
int findS ( int s ) { int sum = 0 ;
for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ;
if ( sum == s ) return n ; } return -1 ; }
int main ( ) { int s = 9 ; int n = findS ( s ) ; n == -1 ? cout << " - 1" : cout << n ; return 0 ; }
long long int findKthGoodNo ( long long int n ) {
int lastDig = n % 10 ;
if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ;
else return ( n << 1 ) + 1 ; }
int main ( ) { long long int n = 10 ; cout << findKthGoodNo ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void NicomachuTheorum_sum ( int n ) {
int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ;
int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) cout << " Yes " ; else cout << " No " ; }
int main ( ) { int n = 5 ; NicomachuTheorum_sum ( n ) ; return 0 ; }
int checkDigits ( int n ) {
while ( n ) {
return 0 ; n /= 10 ; }
return 1 ; }
int largestNumber ( int n ) {
for ( int i = n ; ; i -- ) if ( checkDigits ( i ) ) return i ; }
int main ( ) { int N = 23 ; cout << largestNumber ( N ) ; return 0 ; }
int largestNumber ( int n ) { string s = " " ; int duplicate = n ;
while ( n ) { s = char ( n % 10 + 48 ) + s ; n /= 10 ; } int index = -1 ;
for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ( s [ i ] - '0' ) % 2 & 1 ) { index = i ; break ; } }
if ( index == -1 ) return duplicate ; int num = 0 ;
for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ;
num = num * 10 + ( s [ index ] - '0' - 1 ) ;
for ( int i = index + 1 ; i < s . length ( ) ; i ++ ) num = num * 10 + 8 ; return num ; }
int main ( ) { int N = 24578 ; cout << largestNumber ( N ) ; return 0 ; }
int countDigits ( int n ) { return ( n * log10 ( 2 ) + 1 ) ; }
int main ( ) { int n = 5 ; cout << countDigits ( n ) << endl ; return 0 ; }
int check_digits ( int n ) {
while ( n ) {
return 0 ; n /= 10 ; }
return 1 ; }
int smallest_number ( int n ) {
for ( int i = n ; ; i ++ ) if ( check_digits ( i ) ) return i ; }
int main ( ) { int N = 2397 ; cout << smallest_number ( N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findBucketNo ( int p ) { return ceil ( ( sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; }
int main ( ) { int p = 10 ; cout << findBucketNo ( p ) ; return 0 ; }
unsigned int factorial ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } int LCMOfNeighbourFact ( int n ) {
return factorial ( n + 1 ) ; }
int main ( ) { int N = 5 ; cout << LCMOfNeighbourFact ( N ) << " STRNEWLINE " ; return 0 ; }
int sumofFactors ( int n ) {
int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ;
n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; }
if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
bool checkFriendly ( int n , int m ) {
int sumFactors_n = sumofFactors ( n ) ; int sumFactors_m = sumofFactors ( m ) ;
int gcd_n = gcd ( n , sumFactors_n ) ;
int gcd_m = gcd ( m , sumFactors_m ) ;
if ( n / gcd_n == m / gcd_m && sumFactors_n / gcd_n == sumFactors_m / gcd_m ) return true ; else return false ; }
int main ( ) { int n = 6 , m = 28 ; checkFriendly ( n , m ) ? ( cout << " Yes STRNEWLINE " ) : ( cout << " No STRNEWLINE " ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPrime ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
long long int primorial ( long long int n ) { long long int p = 2 ; n -- ; for ( int i = 3 ; n != 0 ; i ++ ) { if ( isPrime ( i ) ) { p = p * i ; n -- ; } i ++ ; } return p ; }
long long int findNextPrime ( long long int n ) {
long long int nextPrime = n + 2 ;
while ( true ) {
if ( isPrime ( nextPrime ) ) break ; nextPrime ++ ; } return nextPrime ; }
long long int fortunateNumber ( int n ) { long long int p = primorial ( n ) ; return findNextPrime ( p ) - p ; }
int main ( ) { long long int n = 5 ; cout << fortunateNumber ( n ) << " STRNEWLINE " ; return 0 ; }
double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << procal ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) {
int pow_sum = pow ( a , n ) + pow ( b , n ) ; double c = pow ( pow_sum , 1.0 / n ) ; int c_pow = pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { cout << " Count ▁ example ▁ found " ; return ; } } cout << " No ▁ counter ▁ example ▁ within ▁ given " " ▁ range ▁ and ▁ data " ; }
int main ( ) { testSomeNumbers ( 10 , 3 ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void productReduce ( int n , int num [ ] , int den [ ] ) { int new_num = 1 , new_den = 1 ;
for ( int i = 0 ; i < n ; i ++ ) { new_num *= num [ i ] ; new_den *= den [ i ] ; }
int GCD = gcd ( new_num , new_den ) ;
new_num /= GCD ; new_den /= GCD ; cout << new_num << " / " << new_den << endl ; }
int main ( ) { int n = 3 ; int num [ ] = { 1 , 2 , 5 } ; int den [ ] = { 2 , 1 , 6 } ; productReduce ( n , num , den ) ; return 0 ; }
int fnMod ( int n ) {
if ( n % 5 == 1 ) return 4 ;
else return 0 ; }
int main ( ) { int n = 10 ; cout << fnMod ( n ) << endl ; n = 11 ; cout << fnMod ( n ) << endl ; return 0 ; }
int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; }
int repeatedNumberSum ( int n , int x ) { int sum = x * digSum ( n ) ; return digSum ( sum ) ; }
int main ( ) { int n = 24 , x = 3 ; cout << repeatedNumberSum ( n , x ) << endl ; return 0 ; }
int totalSumDivisibleByNum ( int n , int number ) {
int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ;
int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; }
int main ( ) { int n = 3 , num = 7 ; cout << totalSumDivisibleByNum ( n , num ) << " STRNEWLINE " ; return 0 ; }
int numberofterm ( int n , int number ) {
int firstnum = pow ( 10 , n - 1 ) ; int lastnum = pow ( 10 , n ) ;
int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; }
int main ( ) { int n = 3 , num = 7 ; cout << numberofterm ( n , num ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void georgeCantor ( int n ) {
int i = 1 ;
int j = 1 ;
int k = 1 ;
while ( k < n ) { j ++ , k ++ ;
if ( k == n ) break ;
while ( j > 1 && k < n ) { i ++ , j -- , k ++ ; } if ( k == n ) break ; i ++ , k ++ ; if ( k == n ) break ;
while ( i > 1 && k < n ) { i -- , j ++ , k ++ ; } } cout << " N - th ▁ term ▁ : ▁ " << i << " ▁ / ▁ " << j ; }
int main ( ) { int n = 15 ; georgeCantor ( n ) ; return 0 ; }
bool isDivisible ( long long int n ) {
while ( n / 100 ) { int last_digit = n % 10 ; n /= 10 ; n += last_digit * 3 ; }
return ( n % 29 == 0 ) ; }
int main ( ) { long long int n = 348 ; if ( isDivisible ( n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
string solveEquation ( string equation ) { int n = equation . size ( ) , sign = 1 , coeff = 0 ; int total = 0 , i = 0 ;
for ( int j = 0 ; j < n ; j ++ ) { if ( equation [ j ] == ' + ' equation [ j ] == ' - ' ) { if ( j > i ) total += sign * stoi ( equation . substr ( i , j - i ) ) ; i = j ; }
else if ( equation [ j ] == ' x ' ) { if ( ( i == j ) equation [ j - 1 ] == ' + ' ) coeff += sign ; else if ( equation [ j - 1 ] == ' - ' ) coeff -= sign ; else coeff += sign * stoi ( equation . substr ( i , j - i ) ) ; i = j + 1 ; }
else if ( equation [ j ] == ' = ' ) { if ( j > i ) total += sign * stoi ( equation . substr ( i , j - i ) ) ; sign = -1 ; i = j + 1 ; } }
if ( i < n ) total += sign * stoi ( equation . substr ( i ) ) ;
if ( coeff == 0 && total == 0 ) return " Infinite ▁ solutions " ;
if ( coeff == 0 && total ) return " No ▁ solution " ;
int ans = - total / coeff ; return " x = " + to_string ( ans ) ; }
int main ( ) { string equation = " x + 5-3 + x = 6 + x - 2" ; cout << solveEquation ( equation ) ; return 0 ; }
bool pronic_check ( int n ) { int x = ( int ) ( sqrt ( n ) ) ;
if ( x * ( x + 1 ) == n ) return true ; else return false ; }
int main ( void ) { int n = 56 ; pronic_check ( n ) == true ? cout << " YES " : cout << " NO " ; return 0 ; }
int multiply ( int x , int res [ ] , int res_size ) {
int carry = 0 ;
for ( int i = 0 ; i < res_size ; i ++ ) { int prod = res [ i ] * x + carry ;
res [ i ] = prod % 10 ;
carry = prod / 10 ; }
while ( carry ) { res [ res_size ] = carry % 10 ; carry = carry / 10 ; res_size ++ ; } return res_size ; }
void power ( int x , int n ) {
if ( n == 0 ) { cout << "1" ; return ; } int res [ MAX ] ; int res_size = 0 ; int temp = x ;
while ( temp != 0 ) { res [ res_size ++ ] = temp % 10 ; temp = temp / 10 ; }
for ( int i = 2 ; i <= n ; i ++ ) res_size = multiply ( x , res , res_size ) ; cout << x << " ^ " << n << " ▁ = ▁ " ; for ( int i = res_size - 1 ; i >= 0 ; i -- ) cout << res [ i ] ; }
int main ( ) { int exponent = 100 ; int base = 20 ; power ( base , exponent ) ; return 0 ; }
bool check ( int n , int p ) { int maximum = -1 ;
while ( ! ( n % 2 ) ) {
maximum = max ( maximum , 2 ) ; n = n / 2 ; }
for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) {
while ( n % i == 0 ) {
maximum = max ( maximum , i ) ; n = n / i ; } }
if ( n > 2 ) maximum = max ( maximum , n ) ; return ( maximum <= p ) ; }
int main ( ) { int n = 24 , p = 7 ; if ( check ( n , p ) ) cout << " yes " ; else cout << " no " ; return 0 ; }
void find_time ( int h1 ) {
int theta = 30 * h1 ; cout << " ( " << ( theta * 2 ) << " / " << "11" << " ) " << " ▁ minutes " ; }
int main ( ) { int h1 = 3 ; find_time ( h1 ) ; return 0 ; }
int sum_series ( int n ) { int nSquare = n * n ;
return nSquare * ( nSquare - 1 ) / 4 ; }
int main ( ) { int n = 2 ; cout << sum_series ( n ) << endl ; return 0 ; }
bool isPrime ( int n ) {
if ( n == 0 n == 1 ) return false ;
int root = sqrt ( n ) ;
for ( int i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; } bool isSandwitched ( int n ) { return ( isPrime ( n - 1 ) && isPrime ( n + 1 ) ) ; }
int main ( ) { int n = 642 ; cout << n << " ▁ : ▁ " ; if ( isSandwitched ( n ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; n = 9 ; cout << n << " ▁ : ▁ " ; if ( isSandwitched ( n ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
int day_of_the_week ( int y , int m , int d ) {
int t [ ] = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ;
if ( m < 3 ) y -= 1 ; return ( ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ) ; }
int main ( void ) { int day = 13 , month = 7 , year = 2017 ; cout << ( day_of_the_week ( year , month , day ) ) ; return 0 ; }
bool isPrime ( int n , int i = 2 ) {
if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ;
return isPrime ( n , i + 1 ) ; }
int main ( ) { int n = 15 ; if ( isPrime ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ;
if ( n % 2 == 0 ) return false ;
for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) {
if ( n % i == 0 ) { n = n / i ;
if ( n % i == 0 ) return false ; } } return true ; }
int main ( ) { int n = 10 ; if ( isSquareFree ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
double findArea ( double d ) { return ( d * d ) / 2.0 ; }
int main ( ) { double d = 10 ; cout << ( findArea ( d ) ) ; return 0 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; }
int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
int sumOfSeries ( int n ) {
return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; }
int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
float mean ( float arr [ ] , int n ) {
float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; }
float SSD ( float arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; return sqrt ( sum / ( n - 1 ) ) ; }
float sampleError ( float arr [ ] , int n ) {
return SSD ( arr , n ) / sqrt ( n ) ; }
int main ( ) { float arr [ ] = { 78.53 , 79.62 , 80.25 , 81.05 , 83.21 , 83.46 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sampleError ( arr , n ) ; return 0 ; }
int StepstoReachTarget ( int target ) {
target = abs ( target ) ;
int n = ceil ( ( -1.0 + sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ;
if ( ( d & 1 ) == 0 ) return n ;
else return n + ( ( n & 1 ) ? 2 : 1 ) ; }
int main ( ) { int target = 5 ;
cout << StepstoReachTarget ( target ) ; return 0 ; }
double seriesSum ( int n ) {
int i = 1 ;
double res = 0.0 ; bool sign = true ;
while ( n > 0 ) { n -- ;
if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; }
int main ( ) { int n = 5 ; cout << seriesSum ( n ) ; return 0 ; }
unsigned int countSymmetric ( unsigned int n ) {
if ( n == 0 ) return 1 ;
return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; }
int main ( ) { unsigned int n = 3 ; printf ( " % u " , countSymmetric ( n ) ) ; return 0 ; }
int centeredNonagonal ( int n ) {
return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; }
int main ( ) { int n = 10 ; cout << centeredNonagonal ( n ) ; return 0 ; }
float Mean ( float arr [ ] , int n ) {
float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; }
float meanAbsoluteDeviation ( float arr [ ] , int n ) {
float absSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) absSum = absSum + abs ( arr [ i ] - Mean ( arr , n ) ) ;
return absSum / n ; }
int main ( ) { float arr [ ] = { 10 , 15 , 15 , 17 , 18 , 21 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << meanAbsoluteDeviation ( arr , n ) ; return 0 ; }
bool isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) {
int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; }
int main ( ) { int lowCost = 14 , upCost = 30 , lowQuant = 5 , upQuant = 12 , r = 9 ; if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
void findNumbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) cout << "1" << " ▁ " ; cout << "2" << " ▁ " ; cout << n + d << endl ; }
int main ( ) { int N = 3 , D = 5 ; findNumbers ( N , D ) ; return 0 ; }
long long int oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; }
int main ( ) { int n = 4 ; cout << oddNumSum ( n ) << endl ; return 0 ; }
int trailingZero ( int x ) {
int i = 5 , count = 0 ; while ( x > i ) { count = count + x / i ; i = i * 5 ; } return count ; }
int countProductTrailing ( int M , int N ) { return trailingZero ( N ) + trailingZero ( M ) ; }
int main ( ) { int N = 67 , M = 98 ; cout << countProductTrailing ( N , M ) ; return 0 ; }
bool isTrimorphic ( int N ) {
int cube = N * N * N ;
while ( N > 0 ) {
if ( N % 10 != cube % 10 ) return false ;
N /= 10 ; cube /= 10 ; } return true ; }
int main ( ) { int N = 24 ; isTrimorphic ( N ) ? cout << " trimorphic " : cout << " not ▁ trimporphic " ; return 0 ; }
bool checkTrimorphic ( int num ) { int cube = num * num * num ;
while ( num > 0 ) {
if ( num % 10 != cube % 10 ) return false ;
num /= 10 ; cube /= 10 ; } return true ; } int nthTrimorphic ( int n ) { int count = 0 ;
for ( int i = 0 ; i < INT_MAX ; i ++ ) {
if ( checkTrimorphic ( i ) ) count ++ ;
if ( count == n ) return i ; } }
int main ( ) { int n = 9 ; cout << nthTrimorphic ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int reachTarget ( int target ) {
target = abs ( target ) ;
int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; }
int main ( ) { int target = 5 ; cout << reachTarget ( target ) ; return 0 ; }
long long int fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; }
int main ( ) { int n = 5 ; cout << fifthPowerSum ( n ) << endl ; return 0 ; }
int unitDigitXRaisedY ( int x , int y ) {
int res = 1 ;
for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; }
int main ( ) { cout << unitDigitXRaisedY ( 4 , 2 ) ; return 0 ; }
int findDivisor ( int x , int y ) {
if ( x == y ) return y ;
return 2 ; }
int main ( ) { int x = 3 , y = 16 ; cout << findDivisor ( x , y ) ; return 0 ; }
float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; }
int main ( ) { int n = 2 ; cout << AvgofSquareN ( n ) ; return 0 ; }
int sumofFactors ( int n ) {
if ( n % 2 != 0 ) return 0 ;
int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) {
int count = 0 , curr_sum = 1 , curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ;
if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; }
if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int main ( ) { int n = 18 ; cout << sumofFactors ( n ) ; return 0 ; }
float focal_length_concave ( float R ) { return R / 2 ; }
float focal_length_convex ( float R ) { return - ( R / 2 ) ; }
int main ( ) { float R = 30 ; cout << " Focal ▁ length ▁ of ▁ spherical " << " concave ▁ mirror ▁ is ▁ : ▁ " << focal_length_concave ( R ) << " ▁ units STRNEWLINE " ; cout << " Focal ▁ length ▁ of ▁ spherical " << " convex ▁ mirror ▁ is ▁ : ▁ " << focal_length_convex ( R ) << " ▁ units " ; return 0 ; }
int sumofoddFactors ( int n ) {
int res = 1 ;
while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i ++ ) {
int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; }
if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
int main ( ) { int n = 30 ; cout << sumofoddFactors ( n ) ; return 0 ; }
int countSolutions ( int n , int val ) {
int total = 0 ;
if ( n == 1 && val >= 0 ) return 1 ;
for ( int i = 0 ; i <= val ; i ++ ) {
total += countSolutions ( n - 1 , val - i ) ; }
return total ; }
int main ( ) { int n = 5 ; int val = 20 ; cout << countSolutions ( n , val ) ; }
#include <bits/stdc++.h> NEW_LINE #define N  6 NEW_LINE using namespace std ;
void fib ( int f [ ] , int n ) { int i ;
f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( i = 2 ; i <= n ; i ++ )
f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; }
void fibcoef ( int fc [ ] [ N + 1 ] , int f [ ] , int n ) { for ( int i = 0 ; i <= n ; i ++ ) fc [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int k = j ; while ( k -- ) fc [ i ] [ j ] *= f [ k ] ; k = 1 ; while ( ( j + 1 ) != k ) fc [ i ] [ j ] /= f [ k ++ ] ; } } }
void printFibonomialTriangle ( int n ) { int f [ N + 1 ] = { 0 } ;
fib ( f , n ) ;
int dp [ N + 1 ] [ N + 1 ] = { 0 } ;
for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ i ] = 1 ;
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = 1 ; j < i ; j ++ )
dp [ i ] [ j ] = f [ i - j + 1 ] * dp [ i - 1 ] [ j - 1 ] + f [ j - 1 ] * dp [ i - 1 ] [ j ] ; }
for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) cout << dp [ i ] [ j ] << " ▁ " ; cout << endl ; } }
int main ( ) { int n = 6 ; printFibonomialTriangle ( n ) ; return 0 ; }
int sumofNterm ( int a , int d , int b , int r , int n ) {
int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * pow ( r , i - 1 ) ) ) ; return sum ; }
int main ( ) { int a = 1 , d = 1 , b = 2 , r = 2 , n = 3 ; cout << sumofNterm ( a , d , b , r , n ) << endl ; return 0 ; }
int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) {
int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ;
k += 2 ; } }
return sum ; }
int main ( ) { int n = 5 ; cout << " Sum ▁ = ▁ " << sumOfTheSeries ( n ) ; return 0 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; }
int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
double Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 , p = 1 , multi = 1 ;
for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( -1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; }
int main ( ) { double x = 9 ; int n = 10 ; printf ( " % .4f " , Series ( x , n ) ) ; return 0 ; }
int two_factor ( int n ) {
int twocount = 0 ; while ( n % 2 == 0 ) { twocount ++ ; n = n / 2 ; } return twocount ; }
int five_factor ( int n ) { int fivecount = 0 ; while ( n % 5 == 0 ) { fivecount ++ ; n = n / 5 ; } return fivecount ; }
int find_con_zero ( int arr [ ] , int n ) { int twocount = 0 ; int fivecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
twocount += two_factor ( arr [ i ] ) ;
fivecount += five_factor ( arr [ i ] ) ; }
if ( twocount < fivecount ) return twocount ; else return fivecount ; }
int main ( ) { int arr [ ] = { 100 , 10 , 5 , 25 , 35 , 14 } ; int n = 6 ; cout << find_con_zero ( arr , n ) ; }
int first ( int a , int b , int c ) {
a %= b ;
for ( int i = 1 ; i <= b ; i ++ ) {
a = a * 10 ;
if ( a / b == c ) return i ;
a %= b ; } return -1 ; }
int main ( ) { int a = 1 , b = 4 , c = 5 ; cout << first ( a , b , c ) ; return 0 ; }
void subsetDifference ( int n ) {
int s = n * ( n + 1 ) / 2 ;
if ( n % 4 == 0 ) { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " Second subset sum = " << s / 2 ; cout << " Difference = " } else {
if ( n % 4 == 1 n % 4 == 2 ) { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " Second subset sum = " << s / 2 + 1 ; cout << " Difference = " }
else { cout << " First ▁ subset ▁ sum ▁ = ▁ " << s / 2 ; cout << " Second subset sum = " << s / 2 ; cout << " Difference = " } } }
int main ( ) { int n = 6 ; subsetDifference ( n ) ; return 0 ; }
void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; cout << time ; }
int main ( void ) { double s = 25 , v = 56 ; timeToMeet ( s , v ) ; return 0 ; }
void checksum ( int n ) {
if ( n == 0 ) { cout << " - 1 ▁ 0 ▁ 1" << endl ; return ; } int inc ;
if ( n > 0 ) inc = 1 ;
else inc = -1 ;
for ( int i = 0 ; i <= n - 2 ; i += inc ) {
if ( i + i + 1 + i + 2 == n ) { cout << i << " ▁ " << i + 1 << " ▁ " << i + 2 ; return ; } } cout << " - 1" ; }
int main ( ) { int n = 6 ; checksum ( n ) ; return 0 ; }
int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) {
for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; }
int main ( ) { int n = 4 ; cout << " ▁ " << divisorSum ( n ) << endl ; n = 5 ; cout << " ▁ " << divisorSum ( n ) ; return 0 ; }
int printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { printf ( " % 2d " , m ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) {
if ( m != 0 && x != 0 )
binom = binom * ( m - x + 1 ) / x ; printf ( " % 4d " , binom ) ; } printf ( " STRNEWLINE " ) ; } }
int main ( ) { int max = 10 ; printbinomial ( max ) ; return 0 ; }
long long maxPrimeFactors ( long long n ) {
long long maxPrime = -1 ;
while ( n % 2 == 0 ) { maxPrime = 2 ;
}
while ( n % 3 == 0 ) { maxPrime = 3 ; n = n / 3 ; }
for ( int i = 5 ; i <= sqrt ( n ) ; i += 6 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } while ( n % ( i + 2 ) == 0 ) { maxPrime = i + 2 ; n = n / ( i + 2 ) ; } }
if ( n > 4 ) maxPrime = n ; return maxPrime ; }
int main ( ) { long long n = 15 ; cout << maxPrimeFactors ( n ) << endl ; n = 25698751364526 ; cout << maxPrimeFactors ( n ) ; }
unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
unsigned int countUnsetBitsInGivenRange ( unsigned int n , unsigned int l , unsigned int r ) {
int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ;
return ( r - l + 1 ) - countSetBits ( n & num ) ; }
int main ( ) { unsigned int n = 80 ; unsigned int l = 1 , r = 4 ; cout << countUnsetBitsInGivenRange ( n , l , r ) ; return 0 ; }
long long int evenPowerSum ( int n ) { long long int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) {
int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; }
int main ( ) { int n = 5 ; cout << evenPowerSum ( n ) << endl ; return 0 ; }
long long int evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; }
int main ( ) { int n = 4 ; cout << evenPowerSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  501 NEW_LINE using namespace std ;
int balancedprime ( int n ) {
bool prime [ MAX + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } }
vector < int > v ; for ( int p = 3 ; p <= MAX ; p += 2 ) if ( prime [ p ] ) v . push_back ( p ) ; int count = 0 ;
for ( int i = 1 ; i < v . size ( ) ; i ++ ) { if ( v [ i ] == ( v [ i + 1 ] + v [ i - 1 ] ) / 2 ) count ++ ; if ( count == n ) return v [ i ] ; } }
int main ( ) { int n = 4 ; cout << balancedprime ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000001 ;
int factor [ MAX ] = { 0 } ;
void generatePrimeFactors ( ) { factor [ 1 ] = 1 ;
for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ;
for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ;
for ( int i = 3 ; i * i < MAX ; i ++ ) {
if ( factor [ i ] == i ) {
for ( int j = i * i ; j < MAX ; j += i ) {
if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ;
int dup = factor [ n ] ;
int c = 1 ;
int j = n / factor [ n ] ;
while ( j != 1 ) {
if ( factor [ j ] == dup ) c += 1 ;
else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; }
j = j / factor [ j ] ; }
ans = ans * ( c + 1 ) ; return ans ; }
int smallest ( int n ) { for ( int i = 1 ; ; i ++ )
if ( calculateNoOFactors ( i ) >= n ) return i ; }
generatePrimeFactors ( ) ; int n = 4 ; cout << smallest ( n ) ; return 0 ; }
int squaresum ( int n ) {
int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
int main ( ) { int n = 4 ; cout << squaresum ( n ) << endl ; return 0 ; }
bool isPrime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; } int minimumSum ( int n ) { if ( isPrime ( n ) ) return 1 ;
if ( n % 2 == 0 ) return 2 ;
if ( isPrime ( n - 2 ) ) return 2 ;
return 3 ; }
int main ( ) { int n = 27 ; cout << minimumSum ( n ) ; return 0 ; }
int firstDigit ( int n ) {
while ( n >= 10 ) n /= 10 ;
return n ; }
int lastDigit ( int n ) {
return ( n % 10 ) ; }
int main ( ) { int n = 98562 ; cout << firstDigit ( n ) << " ▁ " << lastDigit ( n ) << endl ; return 0 ; }
int firstDigit ( int n ) {
int digits = ( int ) log10 ( n ) ;
n = ( int ) ( n / pow ( 10 , digits ) ) ;
return n ; }
int lastDigit ( int n ) {
return ( n % 10 ) ; }
int main ( ) { int n = 98562 ; cout << firstDigit ( n ) << " ▁ " << lastDigit ( n ) << endl ; return 0 ; }
bool isPrime ( int x ) { if ( x == 0 x == 1 ) return false ; for ( int i = 2 ; i * i <= x ; ++ i ) if ( x % i == 0 ) return false ; return true ; }
void findPrimes ( int n ) {
cout << n << endl ;
cout << 2 << " ▁ " << n - 2 << endl ;
{ cout << 3 << " ▁ " ; n = n - 3 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i ) && isPrime ( n - i ) ) { cout << i << " ▁ " << ( n - i ) ; break ; } } } }
int main ( ) { int n = 27 ; findPrimes ( n ) ; return 0 ; }
long long c [ 100 ] ;
void coef ( int n ) { c [ 0 ] = 1 ; for ( int i = 0 ; i < n ; c [ 0 ] = - c [ 0 ] , i ++ ) { c [ 1 + i ] = 1 ; for ( int j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; } }
bool isPrime ( int n ) {
coef ( n ) ;
int i = n ; while ( i -- && c [ i ] % n == 0 ) ;
return i < 0 ; }
int main ( ) { int n = 37 ; if ( isPrime ( n ) ) cout << " Prime " << endl ; else cout << " Not ▁ Prime " << endl ; return 0 ; }
int motzkin ( int n ) {
if ( n == 0 n == 1 ) return 1 ;
return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; }
int main ( ) { int n = 8 ; cout << motzkin ( n ) << endl ; return 0 ; }
float sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ; }
int main ( ) { int n = 2 ; cout << sumOfSeries ( n ) ; }
int countDigit ( int n ) { if ( n == 0 ) return 0 ; return 1 + countDigit ( n / 10 ) ; }
bool check ( int n ) {
int l = countDigit ( n ) ; int dup = n ; int sum = 0 ;
while ( dup ) { sum += pow ( dup % 10 , l ) ; dup /= 10 ; } return ( n == sum ) ; }
int main ( ) { int n = 1634 ; if ( check ( n ) ) cout << " yes " ; else cout << " no " ; return 0 ; }
int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; }
int main ( ) { int n = 2 ; cout << summation ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100 NEW_LINE using namespace std ;
void leyland ( int n ) { vector < int > ans ;
for ( int x = 2 ; x <= n ; x ++ ) {
for ( int y = 2 ; y <= x ; y ++ ) {
int temp = pow ( x , y ) + pow ( y , x ) ; ans . push_back ( temp ) ; } }
sort ( ans . begin ( ) , ans . end ( ) ) ;
for ( int i = 0 ; i < n ; i ++ ) cout << ans [ i ] << " ▁ " ; }
int main ( ) { int n = 6 ; leyland ( n ) ; return 0 ; }
int kthgroupsum ( int k ) {
int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ;
while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; }
int main ( ) { int k = 3 ; cout << kthgroupsum ( k ) << endl ; return 0 ; }
int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; }
int main ( ) { int n = 4 ; cout << nthTerm ( n ) ; return 0 ; }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int main ( ) { int n = 4 ; cout << seriesSum ( n ) ; return 0 ; }
double cal_speed ( double dist , double time ) { cout << " Distance ( km ) : " cout << " Time ( hr ) : " return dist / time ; }
double cal_dis ( double speed , double time ) { cout << " Time ( hr ) : " cout << " Speed ( km / hr ) : " return speed * time ; }
double cal_time ( double dist , double speed ) { cout << " Distance ( km ) : " cout << " Speed ( km / hr ) : " return speed * dist ; }
cout << " The calculated Speed ( km / hr ) is : " << cal_speed ( 45.9 , 2.0 ) << endl ;
cout << " The calculated Distance ( km ) : " << cal_dis ( 62.9 , 2.5 ) << endl ;
cout << " The calculated Time ( hr ) : " << cal_time ( 48.0 , 4.5 ) << endl ; return 0 ; }
#include <boost/multiprecision/cpp_int.hpp> NEW_LINE #include <iostream> NEW_LINE #include <vector> NEW_LINE using namespace std ; using boost :: multiprecision :: cpp_int ; vector < cpp_int > find_factorial ( int num1 , int num2 ) {
vector < cpp_int > vec ;
cpp_int fac = 1 ;
int temp = num1 ;
while ( 1 ) { if ( temp == 1 ) break ; fac *= temp ; temp -- ; }
vec . push_back ( fac ) ;
num1 ++ ;
while ( num1 <= num2 ) { fac *= num1 ;
vec . push_back ( fac ) ;
num1 ++ ; }
return ( vec ) ; }
void print_format ( vector < cpp_int > & result ) {
int digits = result . back ( ) . str ( ) . size ( ) ; for ( int i = 0 ; i < result . size ( ) ; i ++ ) { cout << setw ( digits + 1 ) << right << result [ i ] << endl ; } }
int m = 10 , n = 20 ;
vector < cpp_int > result_fac ;
result_fac = find_factorial ( m , n ) ;
print_format ( result_fac ) ; return 0 ; }
int term ( int n ) {
int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; }
int main ( ) { int n = 4 ; cout << term ( n ) ; return 0 ; }
float avgOfFirstN ( int n ) { return ( float ) ( 1 + n ) / 2 ; }
int main ( ) { int n = 20 ; cout << avgOfFirstN ( n ) << endl ; return 0 ; }
int summation ( int n ) { int sum ; sum = ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; }
int main ( ) { int n = 5 ; printf ( " % d " , summation ( n ) ) ; return 0 ; }
double sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; }
int main ( ) { int x = 2 ; int n = 5 ; cout << fixed << setprecision ( 2 ) << sum ( x , n ) ; return 0 ; }
int term ( int n ) {
int x = ( ( ( 1 ) + ( double ) sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; }
int main ( ) { int n = 5 ; cout << term ( n ) ; return 0 ; }
int countDigits ( int n ) { int c = 0 ; do { c ++ ; n = n / 10 ; } while ( n != 0 ) ; return c ; }
bool isDeserium ( int x ) { int temp = x ; int p = countDigits ( x ) ;
int sum = 0 ; while ( x != 0 ) { int digit = x % 10 ; sum += pow ( digit , p ) ; p -- ; x = x / 10 ; }
return ( sum == temp ) ; }
int main ( ) { int x = 135 ; if ( isDeserium ( x ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int sameRemainder ( int a , int b , int c ) {
int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ;
return gcd ( a1 , gcd ( b1 , c1 ) ) ; }
int main ( ) { int a = 62 , b = 132 , c = 237 ; cout << sameRemainder ( a , b , c ) << endl ; return 0 ; }
float mean ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; float mean = ( float ) sum / n ; return mean ; }
float sd ( int arr [ ] , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; float sdd = sum / n ; return sdd ; }
float combinedVariance ( int arr1 [ ] , int arr2 [ ] , int n , int m ) {
float mean1 = mean ( arr1 , n ) ; float mean2 = mean ( arr2 , m ) ; cout << " Mean1 : ▁ " << mean1 << " ▁ mean2 : ▁ " << mean2 << endl ;
float sd1 = sd ( arr1 , n ) ; float sd2 = sd ( arr2 , m ) ; cout << " StandardDeviation1 : ▁ " << sd1 << " ▁ StandardDeviation2 : ▁ " << sd2 << endl ;
float combinedMean = ( float ) ( n * mean1 + m * mean2 ) / ( n + m ) ; cout << " Combined ▁ Mean : ▁ " << combinedMean << endl ;
float d1_square = ( mean1 - combinedMean ) * ( mean1 - combinedMean ) ; float d2_square = ( mean2 - combinedMean ) * ( mean2 - combinedMean ) ; cout << " d1 ▁ square : ▁ " << d1_square << " ▁ d2 _ square : ▁ " << d2_square << endl ;
float combinedVar = ( n * ( sd1 + d1_square ) + m * ( sd2 + d2_square ) ) / ( n + m ) ; return combinedVar ; }
int main ( ) { int arr1 [ ] = { 23 , 45 , 34 , 78 , 12 , 76 , 34 } ; int arr2 [ ] = { 65 , 67 , 34 , 23 , 45 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int m = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ;
cout << " Combined ▁ Variance : ▁ " << combinedVariance ( arr1 , arr2 , n , m ) ; return 0 ; }
bool checkDivisibility ( string num ) { int length = num . size ( ) ; if ( length == 1 && num [ 0 ] == '0' ) return true ;
if ( length % 3 == 1 ) {
num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) {
num += "0" ; length += 1 ; }
int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) {
int group = 0 ; group += num [ i -- ] - '0' ; group += ( num [ i -- ] - '0' ) * 10 ; group += ( num [ i ] - '0' ) * 100 ; sum = sum + group * p ;
p *= ( -1 ) ; } sum = abs ( sum ) ; return ( sum % 13 == 0 ) ; }
int main ( ) { string number = "83959092724" ; if ( checkDivisibility ( number ) ) cout << number << " ▁ is ▁ divisible ▁ by ▁ 13 . " ; else cout << number << " ▁ is ▁ not ▁ divisible ▁ by ▁ 13 . " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void modularEquation ( int a , int b ) {
if ( a < b ) { cout << " No ▁ solution ▁ possible ▁ " << endl ; return ; }
if ( a == b ) { cout << " Infinite ▁ Solution ▁ possible ▁ " << endl ; return ; }
int count = 0 ; int n = a - b ; int y = sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) {
if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } }
if ( y * y == n && y > b ) count -- ; cout << count << endl ; }
int main ( ) { int a = 21 , b = 5 ; modularEquation ( a , b ) ; return 0 ; }
int countWays ( int num ) {
int dp [ num + 1 ] ; const int MOD = 1e9 + 7 ;
dp [ 1 ] = 2 ; for ( int i = 2 ; i <= num ; ++ i ) {
dp [ i ] = 0 ; for ( int j = 1 ; j <= 3 ; ++ j ) {
if ( i - j == 0 ) dp [ i ] += 1 ;
else if ( j == 1 ) dp [ i ] += dp [ i - j ] * 2 ;
else if ( i - j > 0 ) dp [ i ] += dp [ i - j ] ;
if ( dp [ i ] >= MOD ) dp [ i ] %= MOD ; } }
return dp [ num ] ; }
int main ( ) { int n = 3 ; cout << countWays ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) {
while ( n % i == 0 ) { count ++ ; n /= i ; }
if ( i % 4 == 3 && count % 2 != 0 ) return false ; } }
return n % 4 != 3 ; }
int main ( ) { int n = 17 ; if ( judgeSquareSum ( n ) ) cout << " Yes " ; else cout << " No " ; }
int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + min ( max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; }
int main ( ) { int n = 13 ; cout << countDigitOne ( n ) << endl ; n = 113 ; cout << countDigitOne ( n ) << endl ; n = 205 ; cout << countDigitOne ( n ) << endl ; }
bool isPrime ( char c ) { return ( c == '2' c == '3' c == '5' c == '7' ) ; }
void decrease ( string & s , int i ) {
if ( s [ i ] <= '2' ) { s . erase ( i , 1 ) ; s [ i ] = '7' ; } else if ( s [ i ] == '3' ) s [ i ] = '2' ; else if ( s [ i ] <= '5' ) s [ i ] = '3' ; else if ( s [ i ] <= '7' ) s [ i ] = '5' ; else s [ i ] = '7' ; return ; } string primeDigits ( string s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) {
if ( ! isPrime ( s [ i ] ) ) {
while ( s [ i ] <= '2' && i >= 0 ) i -- ;
if ( i < 0 ) { i = 0 ; decrease ( s , i ) ; }
else decrease ( s , i ) ;
for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) s [ j ] = '7' ; break ; } } return s ; }
int main ( ) { string s = "45" ; cout << primeDigits ( s ) << endl ; s = "1000" ; cout << primeDigits ( s ) << endl ; s = "7721" ; cout << primeDigits ( s ) << endl ; s = "7221" ; cout << primeDigits ( s ) << endl ; s = "74545678912345689748593275897894708927680" ; cout << primeDigits ( s ) << endl ; return 0 ; }
void greatest ( string s ) { int n = s . length ( ) ; int a [ n ] ;
int sum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s [ i ] - '0' ; sum += a [ i ] ; }
{
if ( a [ n - 2 ] % 2 != 0 or ( sum - a [ n - 1 ] ) % 3 != 0 ) { cout << " - 1" << endl ; }
else {
cout << n << endl ; } } else { int re = sum % 3 ; int del = -1 ;
int flag = 0 ;
for ( int i = 0 ; i < n - 1 ; i ++ ) {
if ( ( a [ i ] ) % 3 == re ) {
if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ;
break ; } else {
del = i ; } } }
if ( flag == 0 ) {
if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) del = n - 1 ; }
if ( del == -1 ) cout << -1 << endl ; else { cout << del + 1 << endl ; } } }
int main ( ) { string s = "7510222" ; greatest ( s ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool asPowerSum ( int w , int m ) { while ( m ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else
}
return ( m == 0 ) ; }
int main ( ) { int w = 3 , m = 7 ; if ( asPowerSum ( w , m ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
int divisible ( string num ) { int n = num . length ( ) ;
int sum = accumulate ( begin ( num ) , end ( num ) , 0 ) - '0' * 1 ;
if ( sum % 3 == 0 ) return 0 ;
if ( n == 1 ) return -1 ;
for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ;
if ( n == 2 ) return -1 ;
return 2 ; }
int main ( ) { string num = "1234" ; cout << divisible ( num ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define n  3 NEW_LINE using namespace std ;
int dotProduct ( int vect_A [ ] , int vect_B [ ] ) { int product = 0 ;
for ( int i = 0 ; i < n ; i ++ ) product = product + vect_A [ i ] * vect_B [ i ] ; return product ; }
void crossProduct ( int vect_A [ ] , int vect_B [ ] , int cross_P [ ] ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; }
int main ( ) { int vect_A [ ] = { 3 , -5 , 4 } ; int vect_B [ ] = { 2 , 6 , 5 } ; int cross_P [ n ] ;
cout << " Dot ▁ product : " ; cout << dotProduct ( vect_A , vect_B ) << endl ;
cout << " Cross ▁ product : " ; crossProduct ( vect_A , vect_B , cross_P ) ;
for ( int i = 0 ; i < n ; i ++ ) cout << cross_P [ i ] << " ▁ " ; return 0 ; }
const int MOD = 1e9 + 7 ;
int power ( int x , unsigned int y , int p ) {
while ( y > 0 ) {
if ( y & 1 ) res = ( 1LL * res * x ) % p ;
x = ( 1LL * x * x ) % p ; } return res ; }
int countEvenWays ( int n ) { return power ( 2 , n / 2 - 1 , MOD ) ; }
int main ( ) { int n = 6 ; cout << countEvenWays ( n ) << " STRNEWLINE " ; n = 8 ; cout << countEvenWays ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX = 1000001 ;
int factor [ MAX ] = { 0 } ;
void cal_factor ( ) { factor [ 1 ] = 1 ;
for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ;
for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ;
for ( int i = 3 ; i * i < MAX ; i ++ ) {
if ( factor [ i ] == i ) {
for ( int j = i * i ; j < MAX ; j += i ) {
if ( factor [ j ] == j ) factor [ j ] = i ; } } } }
int no_of_representations ( int a [ ] , int n ) {
int count = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { int temp = a [ i ] ; int flag = 0 ;
while ( factor [ temp ] != 1 ) { flag = -1 ; count ++ ; temp = temp / factor [ temp ] ; }
count += flag ; } return count ; }
cal_factor ( ) ; int a [ ] = { 4 , 4 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << no_of_representations ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int coutSubSeq ( int A [ ] , int N , int M ) { int sum = 0 ; int ans = 0 ;
for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ;
if ( sum % M == 0 ) ans ++ ; } } } return ans ; }
int main ( ) { int M = 3 ; int A [ ] = { 1 , 2 , 4 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << coutSubSeq ( A , N , M ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSubSeq ( int A [ ] , int N , int M ) { int ans = 0 ;
int h [ M ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) {
int rem = ( M - ( i + j ) % M ) % M ;
if ( rem < j ) continue ;
if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ;
else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ;
else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; }
int main ( ) { int M = 3 ; int A [ ] = { 1 , 2 , 4 , 3 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << countSubSeq ( A , N , M ) ; return 0 ; }
int findTerm ( int n ) { if ( n == 1 ) return n ; else {
int term = 7 ;
for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } }
int main ( ) { int n = 5 ; cout << findTerm ( n ) ; return 0 ; }
int findNumber ( int n ) { n -- ;
int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; }
int main ( ) { int n = 3 ; cout << findNumber ( n ) << endl ; return 0 ; }
float correlationCoefficient ( int X [ ] , int Y [ ] , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
sum_X = sum_X + X [ i ] ;
sum_Y = sum_Y + Y [ i ] ;
sum_XY = sum_XY + X [ i ] * Y [ i ] ;
squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; }
float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ; return corr ; }
int main ( ) { int X [ ] = { 15 , 18 , 21 , 24 , 27 } ; int Y [ ] = { 25 , 25 , 27 , 31 , 32 } ;
int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ;
cout << correlationCoefficient ( X , Y , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void result ( long long n , long long k , long long t ) {
if ( t <= k ) cout << t ;
else if ( t <= n ) cout << k ;
else { long long temp = t - n ; temp = k - temp ; cout << temp ; } }
long long n , k , t ; n = 10 ; k = 5 ; t = 12 ; result ( n , k , t ) ; return 0 ; }
float weightedMean ( int X [ ] , int W [ ] , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) numWeight / sum ; }
int X [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int W [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ;
int n = sizeof ( X ) / sizeof ( X [ 0 ] ) ; int m = sizeof ( W ) / sizeof ( W [ 0 ] ) ;
if ( n == m ) cout << weightedMean ( X , W , n ) ; else cout << " - 1" ; return 0 ; }
double gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ;
if ( fabs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - floor ( a / b ) * b ) ) ; }
int main ( ) { double a = 1.20 , b = 22.5 ; cout << gcd ( a , b ) ; return 0 ; }
float harmonicMean ( float arr [ ] , int n ) {
float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; }
int main ( ) { float arr [ ] = { 13.5 , 14.5 , 14.8 , 15.2 , 16.1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << harmonicMean ( arr , n ) ; return 0 ; }
float harmonicMean ( int arr [ ] , int freq [ ] , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return frequency_sum / sum ; }
int main ( ) { int num [ ] = { 13 , 14 , 15 , 16 , 17 } ; int freq [ ] = { 2 , 5 , 13 , 7 , 3 } ; int n = sizeof ( num ) / sizeof ( num [ 0 ] ) ; cout << harmonicMean ( num , freq , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void point ( int a , int b , int c , int d , int n ) { int x , flag = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
x = b + i * a ;
if ( ( x - d ) % c == 0 and x - d >= 0 ) { cout << x << endl ; flag = 1 ; break ; } }
if ( flag == 0 ) { cout << " No ▁ collision ▁ point " << endl ; } }
int main ( ) { int a = 20 ; int b = 2 ; int c = 9 ; int d = 19 ; int n = 20 ; point ( a , b , c , d , n ) ; return 0 ; }
void findArmstrong ( int low , int high ) { for ( int i = low + 1 ; i < high ; ++ i ) {
int x = i ; int n = 0 ; while ( x != 0 ) { x /= 10 ; ++ n ; }
int pow_sum = 0 ; x = i ; while ( x != 0 ) { int digit = x % 10 ; pow_sum += pow ( digit , n ) ; x /= 10 ; }
if ( pow_sum == i ) cout << i << " ▁ " ; } }
int main ( ) { int num1 = 100 ; int num2 = 400 ; findArmstrong ( num1 , num2 ) ; cout << ' ' ; return 0 ; }
void gcdMax ( int a [ ] , int b [ ] , int n , int N ) {
int cnt [ N ] = { 0 } ;
int first [ N ] = { 0 } , second [ N ] = { 0 } ;
for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ;
for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] ) first [ i ] = max ( first [ i ] , j ) ;
memset ( cnt , 0 , sizeof ( cnt ) ) ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = true ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i )
if ( cnt [ j ] ) second [ i ] = max ( second [ i ] , j ) ;
int i ; for ( i = N - 1 ; i >= 0 ; i -- ) if ( first [ i ] && second [ i ] ) break ; cout << " Maximum ▁ GCD ▁ pair ▁ with ▁ maximum ▁ " " sum ▁ is ▁ " << first [ i ] << " ▁ " << second [ i ] << endl ; }
int main ( ) { int a [ ] = { 3 , 1 , 4 , 2 , 8 } ; int b [ ] = { 5 , 2 , 12 , 8 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
int N = 20 ; gcdMax ( a , b , n , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool printPierpont ( int n ) {
bool arr [ n + 1 ] ; memset ( arr , false , sizeof arr ) ; int two = 1 , three = 1 ; while ( two + 1 < n ) { arr [ two ] = true ; while ( two * three + 1 < n ) { arr [ three ] = true ; arr [ two * three ] = true ; three *= 3 ; } three = 1 ; two *= 2 ; }
vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] ) v . push_back ( i + 1 ) ;
memset ( arr , false , sizeof arr ) ; for ( int p = 2 ; p * p < n ; p ++ ) { if ( arr [ p ] == false ) for ( int i = p * 2 ; i < n ; i += p ) arr [ i ] = true ; }
for ( int i = 0 ; i < v . size ( ) ; i ++ ) if ( ! arr [ v [ i ] ] ) cout << v [ i ] << " ▁ " ; }
int main ( ) { int n = 200 ; printPierpont ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isWoodall ( int x ) {
if ( x % 2 == 0 ) return false ;
if ( x == 1 ) return true ;
int p = 0 ; while ( x % 2 == 0 ) {
x = x / 2 ;
p ++ ;
if ( p == x ) return true ; } return false ; }
int main ( ) { int x = 383 ; ( isWoodall ( x ) ) ? ( cout << " Yes " << endl ) : ( cout << " No " << endl ) ; return 0 ; }
void print_result ( int a [ ] , int n , int k , int m ) {
vector < int > v [ m ] ; for ( int i = 0 ; i < n ; i ++ ) {
int rem = a [ i ] % m ; v [ rem ] . push_back ( a [ i ] ) ;
if ( v [ rem ] . size ( ) == k ) { for ( int j = 0 ; j < k ; j ++ ) cout << v [ rem ] [ j ] << " ▁ " ; return ; } }
cout << " - 1" ; }
int main ( ) { int a [ ] = { 1 , 8 , 4 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; print_result ( a , n , 2 , 3 ) ; return 0 ; }
int smallestX ( int n ) {
int temp [ 10 ] = { 0 } ; if ( n == 0 ) return -1 ;
int count = 0 , x = 0 ; for ( x = 1 ; count < 10 ; x ++ ) { int y = x * n ;
while ( y ) { if ( temp [ y % 10 ] == false ) { count ++ ; temp [ y % 10 ] = true ; } y /= 10 ; } } return x - 1 ; }
int main ( ) { int n = 5 ; cout << smallestX ( n ) ; return 0 ; }
int digSum ( int n ) { int sum = 0 , rem = 0 ; while ( n ) { rem = n % 10 ; sum += rem ; n /= 10 ; } return sum ; }
int findX ( int n ) {
for ( int i = 0 ; i <= n ; i ++ ) if ( i + digSum ( i ) == n ) return i ;
return -1 ; }
int main ( ) { int n = 43 ; cout << " x ▁ = ▁ " << findX ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void complement ( string number ) { for ( int i = 0 ; i < number . length ( ) ; i ++ ) if ( number [ i ] != ' . ' ) number [ i ] = '9' - number [ i ] + '0' ; cout << "9 ' s ▁ complement ▁ is ▁ : ▁ " << number ; }
int main ( ) { string number = "345.45" ; complement ( number ) ; return 0 ; }
int countWays ( int n ) {
int count = 0 ;
for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ;
return count ; }
int main ( ) { int n = 12 ; cout << countWays ( n ) << endl ; return 0 ; }
bool isDigitPresent ( int m , bool hash [ ] ) {
while ( m ) {
if ( hash [ m % 10 ] ) return true ; m = m / 10 ; }
return false ; }
int countDivisibles ( int n ) {
bool hash [ 10 ] = { 0 } ; int m = n ; while ( m ) {
hash [ m % 10 ] = true ;
m = m / 10 ; }
int ans = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) {
if ( n % i == 0 ) {
if ( isDigitPresent ( i , hash ) ) ans ++ ; if ( n / i != i ) {
if ( isDigitPresent ( n / i , hash ) ) ans ++ ; } } }
return ans ; }
int main ( ) { int n = 15 ; cout << countDivisibles ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 100 ; void luDecomposition ( int mat [ ] [ MAX ] , int n ) { int lower [ n ] [ n ] , upper [ n ] [ n ] ; memset ( lower , 0 , sizeof ( lower ) ) ; memset ( upper , 0 , sizeof ( upper ) ) ;
for ( int i = 0 ; i < n ; i ++ ) {
for ( int k = i ; k < n ; k ++ ) {
int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ;
upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; }
for ( int k = i ; k < n ; k ++ ) { if ( i == k )
else {
int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ;
lower [ k ] [ i ] = ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ; } } }
cout << setw ( 6 ) << " Lower ▁ Triangular " << setw ( 32 ) << " Upper ▁ Triangular " << endl ;
for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = 0 ; j < n ; j ++ ) cout << setw ( 6 ) << lower [ i ] [ j ] << " TABSYMBOL " ; cout << " TABSYMBOL " ;
for ( int j = 0 ; j < n ; j ++ ) cout << setw ( 6 ) << upper [ i ] [ j ] << " TABSYMBOL " ; cout << endl ; } }
int main ( ) { int mat [ ] [ MAX ] = { { 2 , -1 , -2 } , { -4 , 6 , 3 } , { -4 , -2 , 8 } } ; luDecomposition ( mat , 3 ) ; return 0 ; }
void printTwoDivisibleParts ( string num , int f , int s ) { int N = num . length ( ) ;
int prefixReminder [ N + 1 ] ; int suffixReminder [ N + 1 ] ; suffixReminder [ 0 ] = 0 ;
for ( int i = 1 ; i < N ; i ++ )
suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( num [ i - 1 ] - '0' ) ) % f ; prefixReminder [ N ] = 0 ; int base = 1 ;
for ( int i = N - 1 ; i >= 0 ; i -- ) {
prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( num [ i ] - '0' ) * base ) % s ;
base = ( base * 10 ) % s ; }
for ( int i = 0 ; i < N ; i ++ ) {
if ( prefixReminder [ i ] == 0 && suffixReminder [ i ] == 0 && num [ i ] != '0' ) { cout << num . substr ( 0 , i ) << " ▁ " << num . substr ( i ) << endl ; return ; } }
cout << " Not ▁ Possible STRNEWLINE " ; }
int main ( ) { string num = "246904096" ; int f = 12345 ; int s = 1024 ; printTwoDivisibleParts ( num , f , s ) ; return 0 ; }
int calculate ( int a [ ] , int n ) {
int ans = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
int r = i + 1 ;
for ( int j = r ; j < n ; j ++ ) {
if ( a [ i ] == a [ j ] ) r += 1 ; else break ; }
int d = r - i ;
ans += ( d * ( d + 1 ) / 2 ) ;
i = r - 1 ; }
return ans ; }
int main ( ) { int a [ ] = { 2 , 4 , 5 , 3 , 3 , 3 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << calculate ( a , n ) ; return 0 ; }
int sum ( int n ) { int rem = 0 ;
int sum_of_digits = 0 ;
while ( n > 0 ) {
rem = n % 10 ;
sum_of_digits += rem ;
n = n / 10 ; }
return sum_of_digits ; }
int count ( int n ) {
int c = 0 ;
for ( int i = n - 97 ; i <= n ; i ++ ) {
int a = sum ( i ) ;
int b = sum ( a ) ;
if ( ( i + a + b ) == n ) { c += 1 ; } }
return c ; }
int main ( ) { int n = 9939 ;
cout << count ( n ) << endl ; return 0 ; }
#include <iostream> NEW_LINE #include <algorithm> NEW_LINE using namespace std ; bool isPowerOfK ( unsigned int n , unsigned int k ) {
bool oneSeen = false ; while ( n > 0 ) {
int digit = n % k ;
if ( digit > 1 ) return false ;
if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; }
int main ( ) { int n = 64 , k = 4 ; if ( isPowerOfK ( n , k ) ) cout << " Yes " ; else cout << " No " ; }
#include <iostream> NEW_LINE using namespace std ; const int MAX_DIGITS = 20 ;
bool isOctal ( long n ) { while ( n ) { if ( ( n % 10 ) >= 8 ) return false ; else n = n / 10 ; } return true ; }
int isPalindrome ( long n ) {
int divide = ( isOctal ( n ) == false ) ? 8 : 10 ;
int octal [ MAX_DIGITS ] ;
int i = 0 ; while ( n != 0 ) { octal [ i ++ ] = n % divide ; n = n / divide ; }
for ( int j = i - 1 , k = 0 ; k <= j ; j -- , k ++ ) if ( octal [ j ] != octal [ k ] ) return false ; return true ; }
int main ( ) { long n = 97 ; if ( isPalindrome ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { cout << fact << " ▁ " ;
fact = fact * x ; x ++ ; } }
int main ( ) { int n = 100 ; printFactorialNums ( n ) ; return 0 ; }
bool isPrime ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isThreeDisctFactors ( long long n ) {
int sq = ( int ) sqrt ( n ) ;
if ( 1LL * sq * sq != n ) return false ;
return isPrime ( sq ) ? true : false ; }
int main ( ) { long long num = 9 ; if ( isThreeDisctFactors ( num ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; num = 15 ; if ( isThreeDisctFactors ( num ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; num = 12397923568441 ; if ( isThreeDisctFactors ( num ) ) cout << " Yes STRNEWLINE " ; else cout << " No STRNEWLINE " ; return 0 ; }
int computeLastDigit ( long long int A , long long int B ) { int variable = 1 ;
return 1 ;
else if ( ( B - A ) >= 5 ) return 0 ; else {
for ( long long int i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) ; return variable % 10 ; } }
int main ( ) { cout << computeLastDigit ( 2632 , 2634 ) ; return 0 ; }
float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; }
int main ( ) { int n = 20 ; float a = 2.5 , d = 1.5 ; cout << sumOfAP ( a , d , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define M  1000000007 NEW_LINE using namespace std ;
long long multiplyFactors ( int n ) { long long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) {
if ( n / i == i ) prod = ( prod * i ) % M ;
else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; }
int main ( ) { int n = 12 ; cout << multiplyFactors ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define M  1000000007 NEW_LINE using namespace std ;
long long power ( long long x , long long y ) { long long res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % M ; y = ( y >> 1 ) % M ; x = ( x * x ) % M ; } return res ; }
int countFactors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) {
if ( n / i == i ) count ++ ;
else count += 2 ; } } return count ; } long long multiplyFactors ( int n ) { int numFactor = countFactors ( n ) ;
long long product = power ( n , numFactor / 2 ) ;
if ( numFactor & 1 ) product = ( product * ( int ) sqrt ( n ) ) % M ; return product ; }
int main ( ) { int n = 12 ; cout << multiplyFactors ( n ) << endl ; return 0 ; }
bool isDivisibleBy10 ( string bin ) { int n = bin . size ( ) ;
if ( bin [ n - 1 ] == '1' ) return false ;
int sum = 0 ;
for ( int i = n - 2 ; i >= 0 ; i -- ) {
if ( bin [ i ] == '1' ) {
int posFromRight = n - i - 1 ;
if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } }
if ( sum % 10 == 0 ) return true ;
return false ; }
int main ( ) { string bin = "11000111001110" ; if ( isDivisibleBy10 ( bin ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printTrib ( int n ) { if ( n < 1 ) return ;
int first = 0 , second = 0 ; int third = 1 ; cout << first << " ▁ " ; if ( n > 1 ) cout << second << " ▁ " ; if ( n > 2 ) cout << second << " ▁ " ;
for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; cout << curr << " ▁ " ; } }
int main ( ) { int n = 10 ; printTrib ( n ) ; return 0 ; }
vector < int > SieveOfEratosthenes ( int n ) {
bool prime [ n + 1 ] ; memset ( prime , false , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == false )
for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = true ; } vector < int > lis ;
for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) lis . push_back ( p ) ; return lis ; }
int setBits ( int n ) { return __builtin_popcount ( n ) ; }
int main ( ) { int x = 4 , y = 8 ; int count = 0 ;
vector < int > primeArr = SieveOfEratosthenes ( ceil ( log2 ( y ) ) ) ; for ( int i = x ; i < y + 1 ; i ++ ) { int temp = setBits ( i ) ; for ( int j = 0 ; j < primeArr . size ( ) ; j ++ ) { if ( temp == primeArr [ j ] ) { count += 1 ; break ; } } } cout << count << endl ; return 0 ; }
int count_square ( int n ) {
int count = 0 ;
for ( int i = 1 ; i <= n ; i = i + 2 ) {
int k = n - i + 1 ; count += ( k * k ) ; }
return count ; }
int main ( ) { int N = 8 ; cout << count_square ( N ) ; return 0 ; }
static int countAnomalies ( int arr [ ] , int n , int k ) {
int cnt = 0 ;
int i , sum = 0 ;
for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;
for ( i = 0 ; i < n ; i ++ ) if ( abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; }
int main ( ) { int arr [ ] = { 1 , 3 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 1 ; cout << countAnomalies ( arr , n , k ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  100005
int d [ N ] , pre [ N ] ;
void Positive_Divisors ( ) {
for ( int i = 1 ; i < N ; i ++ ) {
for ( int j = 1 ; j * j <= i ; j ++ ) {
if ( i % j == 0 ) {
if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } int ans = 0 ;
for ( int i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } }
Positive_Divisors ( ) ; int n = 15 ;
cout << pre [ n ] << endl ; return 0 ; }
int numLen ( int K ) {
if ( K % 2 == 0 K % 5 == 0 ) return -1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) {
number = number * 10 + 1 ;
if ( ( number % K == 0 ) ) return len ; } return -1 ; }
int main ( ) { int K = 7 ; cout << numLen ( K ) ; return 0 ; }
bool doesContainB ( int a , int b , int c ) { if ( a == b ) return true ; if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) return true ; return false ; }
int main ( ) { int a = 1 , b = 7 , c = 3 ; if ( doesContainB ( a , b , c ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
void printPermutation ( int n , int k ) {
for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ;
if ( i <= k ) cout << y << " ▁ " << x << " ▁ " ;
else cout < < x << " ▁ " << y << " ▁ " ; } }
int main ( ) { int n = 2 , k = 1 ; printPermutation ( n , k ) ; return 0 ; }
ll maxSum ( int N ) { ll ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ;
int degreeU = 2 ;
if ( u == 1 u == N ) degreeU = 1 ;
int degreeV = 2 ;
if ( v == 1 v == N ) degreeV = 1 ;
ans += ( degreeU * degreeV ) ; } } return ans ; }
int main ( ) { int N = 6 ; cout << maxSum ( N ) ; }
void maximumFactor ( vector < int > arr ) {
int n = arr . size ( ) ; vector < int > rank ; vector < int > factors ; int max = * max_element ( arr . begin ( ) , arr . end ( ) ) ;
for ( int i = 2 ; i <= max ; i ++ ) {
int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % i == 0 ) count += 1 ; rank . push_back ( count ) ; factors . push_back ( i ) ; } }
int m = * max_element ( rank . begin ( ) , rank . end ( ) ) ; for ( int i = 0 ; i < rank . size ( ) ; i ++ ) {
if ( rank [ i ] == m ) cout << factors [ i ] << " ▁ " ; } }
int main ( ) { vector < int > arr = { 120 , 15 , 24 , 63 , 18 } ; maximumFactor ( arr ) ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int main ( ) { int n = 5 ; cout << findSum ( n ) ; return 0 ; }
double findMedian ( int a [ ] , int n ) {
sort ( a , a + n ) ;
if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; }
int main ( ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " Median ▁ = ▁ " << findMedian ( a , n ) << endl ; return 0 ; }
double findMean ( int a [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; }
int main ( ) { int a [ ] = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " Mean ▁ = ▁ " << findMean ( a , n ) << endl ; return 0 ; }
bool CheckArray ( int arr [ ] , int n ) { int prod = 1 ;
unordered_set < int > freq ;
for ( int i = 0 ; i < n ; ++ i ) { freq . insert ( arr [ i ] ) ; prod *= arr [ i ] ; } int root = sqrt ( prod ) ;
if ( root * root == prod )
if ( freq . find ( root ) != freq . end ( ) ) return true ; return false ; }
int main ( ) { int arr [ ] = { 1 , 2 , 12 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( CheckArray ( arr , n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int toK ( int N , int K ) {
int w = 1 ; int s = 0 ; while ( N != 0 ) { int r = N % K ; N = N / K ; s = r * w + s ; w *= 10 ; } return s ; }
bool check ( int N ) {
bool fl = false ; while ( N != 0 ) { int r = N % 10 ; N = N / 10 ;
if ( fl == true and r == 0 ) return false ; if ( r > 0 ) { fl = false ; continue ; } fl = true ; } return true ; }
void hasConsecutiveZeroes ( int N , int K ) { int z = toK ( N , K ) ; if ( check ( z ) ) cout << " Yes " << endl ; else cout << " No " << endl ; }
int main ( ) { int N = 15 ; int K = 8 ; hasConsecutiveZeroes ( N , K ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  1000000 NEW_LINE bool prime [ MAX + 1 ] ; void SieveOfEratosthenes ( ) {
prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } }
void SumOfKthPrimes ( int arr [ ] , int n , int k ) {
int c = 0 ;
long long int sum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( prime [ arr [ i ] ] ) {
c ++ ;
if ( c % k == 0 ) { sum += arr [ i ] ; c = 0 ; } } } cout << sum << endl ; }
SieveOfEratosthenes ( ) ; int arr [ ] = { 2 , 3 , 5 , 7 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 2 ; SumOfKthPrimes ( arr , n , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  100000 NEW_LINE using namespace std ;
bool prime [ 100002 ] ;
void SieveOfEratosthenes ( ) { memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == true ) for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; }
int superpower ( int n ) { SieveOfEratosthenes ( ) ; int superPower = 0 , factor = 0 ; int i = 2 ;
while ( n > 1 && i <= MAX ) { if ( prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; }
int main ( ) { int n = 256 ; cout << superpower ( n ) ; return 0 ; }
int smallestDivisor ( int n ) {
if ( n % 2 == 0 ) return 2 ;
for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; }
int main ( ) { int n = 31 ; cout << smallestDivisor ( n ) ; return 0 ; }
int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) -2 * ( Heads ) ; count = count / 2 ; return count ; }
int main ( ) { int Heads = 100 , Legs = 300 ; int Rabbits = countRabbits ( Heads , Legs ) ; cout << " Rabbits ▁ = ▁ " << Rabbits << endl ; cout << " Pigeons ▁ = ▁ " << Heads - Rabbits << endl ; return 0 ; }
float calculateSum ( float n ) { int a = int ( n ) ; return 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ; }
int main ( ) { float n = 1.4142 ; cout << ceil ( calculateSum ( n ) ) << endl ; return 0 ; }
class gfg { public : int Sum_upto_nth_Term ( int n ) { return ( 1 - pow ( -2 , n ) ) ; } } ;
int main ( ) { gfg g ; int N = 5 ; cout << g . Sum_upto_nth_Term ( N ) ; }
public : int xorEqualsOrCount ( int N ) {
int count = 0 ; int bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = N / 2 ; } return ( int ) pow ( 2 , count ) ; } } ;
int main ( ) { gfg g ; int N = 7 ; cout << g . xorEqualsOrCount ( N ) ; return 0 ; }
int fact ( int n ) { if ( n == 1 ) return 1 ; return n * fact ( n - 1 ) ; }
double sum ( int x , int n ) { double i , total = 1.0 ;
for ( i = 1 ; i <= n ; i ++ ) { total = total + ( pow ( x , i ) / fact ( i + 1 ) ) ; } return total ; }
int x = 5 , n = 4 ;
cout << " Sum ▁ is : ▁ " << sum ( x , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) {
if ( i % 2 == 0 ) result = result - pow ( i , 2 ) ;
else result = result + pow ( i , 2 ) ; }
int main ( void ) {
int n = 3 ;
cout << sum_of_series ( n ) << endl ;
n = 10 ;
cout << sum_of_series ( n ) << endl ; }
int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; }
int N = 4 ;
cout << findSum ( N ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long int NEW_LINE #define MAX  16 NEW_LINE using namespace std ; ll nCr [ MAX ] [ MAX ] = { 0 } ;
void binomial ( ) {
for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } }
double findCosNTheta ( double sinTheta , ll n ) {
double cosTheta = sqrt ( 1 - sinTheta * sinTheta ) ;
double ans = 0 ;
ll toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * pow ( cosTheta , n - i ) * pow ( sinTheta , i ) * toggle ; toggle = toggle * -1 ; } return ans ; }
int main ( ) { binomial ( ) ; double sinTheta = 0.5 ; ll n = 10 ; cout << findCosNTheta ( sinTheta , n ) << endl ; return 0 ; }
int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; }
int N = 4 ;
cout << nthTerm ( N ) ; return 0 ; }
int findSum ( int n ) {
return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / pow ( 9 , 3 ) - n * ( n + 1 ) / 18 ; }
int main ( ) { int n = 3 ; cout << findSum ( n ) ; return 0 ; }
int solve_sum ( int n ) {
if ( n % 2 == 1 ) return ( n + 1 ) / 2 ;
return - n / 2 ; }
int main ( ) { int n = 8 ; cout << solve_sum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = log ( a ) / log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; }
int main ( ) { int n = 16 ; cout << ( isPower ( n ) ? " Yes " : " No " ) ; return 0 ; }
float rmsValue ( int arr [ ] , int n ) { int square = 0 ; float mean = 0.0 , root = 0.0 ;
for ( int i = 0 ; i < n ; i ++ ) { square += pow ( arr [ i ] , 2 ) ; }
mean = ( square / ( float ) ( n ) ) ;
root = sqrt ( mean ) ; return root ; }
int main ( ) { int arr [ ] = { 10 , 4 , 6 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << rmsValue ( arr , n ) ; return 0 ; }
float Mixture ( int X , int Y , int Z ) { float result = 0.0 , result1 = 0.0 ;
result1 = ( ( X - Y ) / ( float ) X ) ; result = pow ( result1 , Z ) ;
result = result * X ; return result ; }
int main ( ) { int X = 10 , Y = 2 , Z = 2 ; cout << Mixture ( X , Y , Z ) << " ▁ litres " ; return 0 ; }
int power ( int x , int y , int p ) {
while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
int check ( int n ) {
n -- ;
int ans = n * n ;
if ( ans >= mod ) ans %= mod ; ans += n + 2 ; if ( ans >= mod ) ans %= mod ; ans = ( power ( 2 , n , mod ) % mod * ans % mod ) % mod ;
ans = ( ans - 1 + mod ) % mod ; return ans ; }
int main ( ) { int n = 4 ;
cout << check ( n ) << endl ; return 0 ; }
int findLCM ( int a , int b ) { int lar = max ( a , b ) ; int small = min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } }
int main ( ) { int a = 5 , b = 7 ; cout << " LCM ▁ of ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << findLCM ( a , b ) ; return 0 ; }
void primes ( int n ) { int i = 2 ; int j = 0 ;
int result [ n ] ; int z = 0 ; while ( j < n ) { bool flag = true ; for ( int item = 2 ; item <= ( int ) ( i * 1 / 2 ) ; item ++ ) if ( i % item == 0 && i != item ) { flag = false ; break ; } if ( flag ) { result [ z ++ ] = i ; j += 1 ; } i += 1 ; } for ( i = 0 ; i < 5 ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) cout << result [ j ] ; cout << " ▁ " ; } }
void smar_wln ( int n ) {
primes ( n ) ; }
int main ( ) { int n = 5 ; cout << " First ▁ " << n << " ▁ terms ▁ of ▁ the ▁ Sequence ▁ are " << endl ; smar_wln ( n ) ; }
int Pentatope_number ( int n ) {
return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; }
int main ( ) { int n = 7 ; cout << n << " th ▁ Pentatope ▁ number ▁ : " << Pentatope_number ( n ) << endl ; n = 12 ; cout << n << " th ▁ Pentatope ▁ number ▁ : " << Pentatope_number ( n ) << endl ; return 0 ; }
int centeredIcosahedralNum ( int n ) {
return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; }
int main ( ) { int n = 10 ; cout << centeredIcosahedralNum ( n ) << endl ; n = 12 ; cout << centeredIcosahedralNum ( n ) << endl ; return 0 ; }
int centered_square_num ( int n ) {
return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; }
int main ( ) { int n = 7 ; cout << n << " th ▁ Centered ▁ square ▁ number : ▁ " ; cout << centered_square_num ( n ) ; return 0 ; }
int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; }
int main ( ) { int n = 4 ; cout << seriesSum ( n ) ; return 0 ; }
int Dodecagonal_number ( int n ) {
return 5 * n * n - 4 * n ; }
int main ( ) { int n = 7 ; cout << Dodecagonal_number ( n ) << endl ; n = 12 ; cout << Dodecagonal_number ( n ) << endl ; return 0 ; }
void SieveOfEratosthenes ( int n , bool prime [ ] , bool primesquare [ ] , int a [ ] ) { for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= ( n * n + 1 ) ; i ++ ) primesquare [ i ] = false ;
prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } int j = 0 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) {
a [ j ] = p ;
primesquare [ p * p ] = true ; j ++ ; } } }
int countDivisors ( int n ) {
if ( n == 1 ) return 1 ; bool prime [ n + 1 ] , primesquare [ n * n + 1 ] ;
SieveOfEratosthenes ( n , prime , primesquare , a ) ;
int ans = 1 ;
for ( int i = 0 ; ; i ++ ) {
if ( a [ i ] * a [ i ] * a [ i ] > n ) break ;
int cnt = 1 ;
while ( n % a [ i ] == 0 ) { n = n / a [ i ] ;
}
ans = ans * cnt ; }
if ( prime [ n ] ) ans = ans * 2 ;
else if ( primesquare [ n ] ) ans = ans * 3 ;
else if ( n != 1 ) ans = ans * 4 ;
}
int sumofFactors ( int n ) {
int res = 1 ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; }
if ( n >= 2 ) res *= ( 1 + n ) ; return res ; }
bool checkArithmetic ( int n ) { int count = countDivisors ( n ) ; int sum = sumofFactors ( n ) ; return ( sum % count == 0 ) ; }
int main ( ) { int n = 6 ; ( checkArithmetic ( n ) ) ? ( cout << " Yes " ) : ( cout << " No " ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; }
int main ( ) { int N = 6 ; cout << magicOfSequence ( N ) ; return 0 ; }
void nextPower ( int N , vector < int > & power ) { int carry = 0 ; for ( int i = 0 ; i < power . size ( ) ; i ++ ) { int prod = ( power [ i ] * N ) + carry ;
power [ i ] = prod % 10 ;
carry = prod / 10 ; } while ( carry ) {
power . push_back ( carry % 10 ) ; carry = carry / 10 ; } }
void printPowerNumber ( int X , int N ) {
vector < int > power ; power . push_back ( 1 ) ;
vector < int > res ;
for ( int i = 1 ; i <= X ; i ++ ) {
nextPower ( N , power ) ;
res . push_back ( power . back ( ) ) ; res . push_back ( power . front ( ) ) ; } for ( int i = 0 ; i < res . size ( ) ; i ++ ) cout << res [ i ] ; }
int main ( ) { int N = 19 , X = 4 ; printPowerNumber ( X , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstDigit ( int n ) { long long int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ;
while ( fact % 10 == 0 ) fact = fact / 10 ; }
while ( fact >= 10 ) fact = fact / 10 ; return fact ; }
int main ( ) { int n = 5 ; cout << firstDigit ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; }
int main ( ) { cout << sumofseries ( 3 ) << endl ; return 0 ; }
void printGMeans ( int A , int B , int N ) {
float R = ( float ) pow ( float ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ;
for ( int i = 1 ; i <= N ; i ++ ) cout << A * pow ( R , i ) << " ▁ " ; }
int main ( ) { int A = 3 , B = 81 , N = 2 ; printGMeans ( A , B , N ) ; return 0 ; }
int digitSum ( long long int n ) { int digSum = 0 ; while ( n ) { digSum += n % 10 ; n /= 10 ; } return digSum ; }
long long int countInteger ( long long int n , long long int s ) {
if ( n < s ) return 0 ;
for ( long long int i = s ; i <= min ( n , s + 163 ) ; i ++ ) if ( ( i - digitSum ( i ) ) > s ) return ( n - i + 1 ) ;
return 0 ; }
int main ( ) { long long int n = 1000 , s = 100 ; cout << countInteger ( n , s ) ; return 0 ; }
int division ( int num1 , int num2 ) { if ( num1 == 0 ) return 0 ; if ( num2 == 0 ) return INT_MAX ; bool negResult = false ;
if ( num1 < 0 ) { num1 = - num1 ; if ( num2 < 0 ) num2 = - num2 ; else negResult = true ; } else if ( num2 < 0 ) { num2 = - num2 ; negResult = true ; }
int quotient = 0 ; while ( num1 >= num2 ) { num1 = num1 - num2 ; quotient ++ ; }
if ( negResult ) quotient = - quotient ; return quotient ; }
int main ( ) { int num1 = 13 , num2 = 2 ; cout << division ( num1 , num2 ) ; ; return 0 ; }
int Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { cout << i * ( 7 * i - 5 ) / 2 ; cout << " ▁ " ; } }
int main ( ) { int n = 10 ; Nonagonal ( n ) ; return 0 ; }
int seriesFunc ( int n ) {
int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ;
int sumNatural = ( n * ( n + 1 ) / 2 ) ;
return ( sumSquare + sumNatural + 1 ) ; }
int main ( ) { int n = 8 ; cout << seriesFunc ( n ) << endl ; n = 13 ; cout << seriesFunc ( 13 ) ; return 0 ; }
bool checkplusperfect ( int x ) { int temp = x ;
int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; }
x = temp ; int sum = 0 ; while ( x != 0 ) { sum += pow ( x % 10 , n ) ; x /= 10 ; }
return ( sum == temp ) ; }
int main ( ) { int x = 9474 ; if ( checkplusperfect ( x ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int subsetCount ( int arr [ ] , int n ) { return 1 << n ; }
int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << subsetCount ( A , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; float Calculate_GST ( float org_cost , float N_price ) {
return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; }
int main ( ) { float org_cost = 100 ; float N_price = 120 ; cout << " GST ▁ = ▁ " << Calculate_GST ( org_cost , N_price ) << " ▁ % ▁ " ; return 0 ; }
int centeredHexagonalNumber ( int n ) {
return 3 * n * ( n - 1 ) + 1 ; }
int main ( ) { int n = 10 ; cout << n << " th ▁ centered ▁ hexagonal ▁ number : ▁ " ; cout << centeredHexagonalNumber ( n ) ; return 0 ; }
int find_distance ( int n ) { return n * ( ( 3 * n ) + 7 ) ; }
int main ( ) { int n = 5 ; cout << " Distance ▁ = ▁ " << find_distance ( n ) ; return 0 ; }
bool isPrime ( int n ) {
if ( n <= 1 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool twinPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && abs ( n1 - n2 ) == 2 ) ; }
int main ( ) { int n1 = 11 , n2 = 13 ; if ( twinPrime ( n1 , n2 ) ) cout << " Twin ▁ Prime " << endl ; else cout << endl << " Not ▁ Twin ▁ Prime " << endl ; return 0 ; }
float sumOfSeries ( int n ) { return 0.0246 * ( pow ( 10 , n ) - 1 - ( 9 * n ) ) ; }
int main ( ) { int n = 3 ; cout << sumOfSeries ( n ) ; return 0 ; }
int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; }
int main ( ) { int n = 4 ; printf ( " % d " , evenbinomialCoeffSum ( n ) ) ; return 0 ; }
int sumOfTheSeries ( int n ) {
return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; }
int main ( ) { int n = 5 ; cout << " Sum ▁ = ▁ " << sumOfTheSeries ( n ) ; return 0 ; }
int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; }
int main ( ) { int n = 10 ; cout << sumOfSeries ( n ) ; return 0 ; }
int numberOfTriangles ( int n ) { int ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; }
int main ( ) { int n = 2 ; cout << numberOfTriangles ( n ) ; return 0 ; }
int motzkin ( int n ) { int dp [ n + 1 ] ;
dp [ 0 ] = dp [ 1 ] = 1 ;
for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = ( ( 2 * i + 1 ) * dp [ i - 1 ] + ( 3 * i - 3 ) * dp [ i - 2 ] ) / ( i + 2 ) ; return dp [ n ] ; }
int main ( ) { int n = 8 ; cout << motzkin ( n ) << endl ; return 0 ; }
int kthgroupsum ( int k ) { return k * k * k ; }
int main ( ) { int k = 3 ; cout << kthgroupsum ( k ) << endl ; return 0 ; }
void printXYZ ( int n ) { if ( n == 1 ) cout << -1 ; else cout << " x ▁ is ▁ " << n << " STRNEWLINE y ▁ is ▁ " << n + 1 << " STRNEWLINE z ▁ is ▁ " << n * ( n + 1 ) ; }
int main ( ) { int n = 7 ; printXYZ ( n ) ; return 0 ; }
int term ( int n ) { return n * ( n + 1 ) / 2 ; }
int main ( ) { int n = 4 ; cout << term ( n ) ; return 0 ; }
double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; }
int main ( ) { int a = 5 , b = 15 ; double HM = compute ( a , b ) ; cout << " Harmonic ▁ Mean ▁ between ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << HM ; return 0 ; }
int series ( int n ) { return ( 8 * n * n ) + 1 ; }
int main ( ) { int n = 5 ; cout << series ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
bool isDivisible ( int x , int y ) { if ( y == 1 ) return true ; if ( __gcd ( x , y ) == 1 ) return false ; return isDivisible ( x , y / gcd ) ; }
int main ( ) { int x = 18 , y = 12 ; if ( isDivisible ( x , y ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
double sumOfSeries ( double a , double num ) { double res = 0 , prev = 1 ; for ( int i = 1 ; i <= num ; i ++ ) {
prev *= ( a / i ) ;
res = res + prev ; } return ( res ) ; }
int main ( ) { double n = 5 , a = 2 ; cout << sumOfSeries ( a , n ) ; return 0 ; }
float Cel_To_Fah ( float n ) { return ( ( n * 9.0 / 5.0 ) + 32.0 ) ; }
int main ( ) { float n = 20.0 ; cout << Cel_To_Fah ( n ) ; return 0 ; }
void print_sequence ( int n , int k ) {
int b = n / ( k * ( k + 1 ) / 2 ) ;
if ( b == 0 ) { cout << -1 << endl ; } else {
int r = 1 ;
for ( int x = 1 ; x * x <= n ; x ++ ) {
if ( n % x != 0 ) continue ;
if ( x <= b && x > r ) r = x ;
if ( n / x <= b && n / x > r ) r = n / x ; }
for ( int i = 1 ; i < k ; i ++ ) cout << r * i << " ▁ " ;
int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ;
cout << res << endl ; } }
int main ( ) { int n = 24 ; int k = 4 ; print_sequence ( n , k ) ; n = 24 , k = 5 ; print_sequence ( n , k ) ; n = 6 , k = 4 ; print_sequence ( n , k ) ; }
#include <iostream> NEW_LINE using namespace std ; #define ull  unsigned long long NEW_LINE ull countCompositions ( ull n ) {
return ( 1L ) << ( n - 1 ) ; }
int main ( ) { ull n = 4 ; cout << countCompositions ( n ) << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countDigit ( long long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; }
int main ( void ) { long long n = 345289467 ; cout << " Number ▁ of ▁ digits ▁ : " << countDigit ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int printTrib ( int n ) { int dp [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) cout << dp [ i ] << " ▁ " ; }
int main ( ) { int n = 10 ; printTrib ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void multiply ( int T [ 3 ] [ 3 ] , int M [ 3 ] [ 3 ] ) { int a , b , c , d , e , f , g , h , i ; a = T [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 0 ] ; b = T [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 1 ] ; c = T [ 0 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 2 ] ; d = T [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 0 ] ; e = T [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 1 ] ; f = T [ 1 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 2 ] ; g = T [ 2 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 0 ] ; h = T [ 2 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 1 ] ; i = T [ 2 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 2 ] ; T [ 0 ] [ 0 ] = a ; T [ 0 ] [ 1 ] = b ; T [ 0 ] [ 2 ] = c ; T [ 1 ] [ 0 ] = d ; T [ 1 ] [ 1 ] = e ; T [ 1 ] [ 2 ] = f ; T [ 2 ] [ 0 ] = g ; T [ 2 ] [ 1 ] = h ; T [ 2 ] [ 2 ] = i ; }
void power ( int T [ 3 ] [ 3 ] , int n ) {
if ( n == 0 n == 1 ) return ; int M [ 3 ] [ 3 ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ;
power ( T , n / 2 ) ;
multiply ( T , T ) ;
if ( n % 2 ) multiply ( T , M ) ; } int tribonacci ( int n ) { int T [ 3 ] [ 3 ] = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ;
if ( n == 0 n == 1 ) return 0 ; else power ( T , n - 2 ) ;
return T [ 0 ] [ 0 ] ; }
int main ( ) { int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) cout << tribonacci ( i ) << " ▁ " ; cout << endl ; return 0 ; }
float geometricMean ( int arr [ ] , int n ) {
float sum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) sum = sum + log ( arr [ i ] ) ;
sum = sum / n ; return exp ( sum ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << geometricMean ( arr , n ) ; return 0 ; }
long long int smallestNumber ( int n ) {
if ( n >= 0 && n <= 9 ) return n ;
stack < int > digits ;
for ( int i = 9 ; i >= 2 && n > 1 ; i -- ) { while ( n % i == 0 ) {
digits . push ( i ) ; n = n / i ; } }
if ( n != 1 ) return -1 ;
long long int k = 0 ; while ( ! digits . empty ( ) ) { k = k * 10 + digits . top ( ) ; digits . pop ( ) ; }
return k ; }
int main ( ) { int n = 100 ; cout << smallestNumber ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; bool isMagic ( int n ) { int sum = 0 ;
while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; }
return ( sum == 1 ) ; }
int main ( ) { int n = 1234 ; if ( isMagic ( n ) ) cout << " Magic ▁ Number " ; else cout << " Not ▁ a ▁ magic ▁ Number " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  1000000007 NEW_LINE void printSequence ( int n ) {
int a = 1 ;
int ans = 2 ;
for ( int i = 1 ; i <= n ; i ++ ) { cout << ans << " ▁ " ; ans = ( ( a % N ) * ( ans % N ) ) % N ; a = ans ; ans = ( ans + 1 ) % N ; } }
int main ( ) { int n = 6 ; printSequence ( n ) ; return 0 ; }
int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; }
int main ( ) { int n = 5 ; cout << findSum ( n ) ; return 0 ; }
int HailstoneNumbers ( int N ) { static int c ; cout << N << " ▁ " ; if ( N == 1 && c == 0 ) {
return c ; } else if ( N == 1 && c != 0 ) {
c ++ ; return c ; } else if ( N % 2 == 0 ) {
c ++ ; HailstoneNumbers ( N / 2 ) ; } else if ( N % 2 != 0 ) {
c ++ ; HailstoneNumbers ( 3 * N + 1 ) ; } }
int main ( ) { int N = 7 ; int x ;
x = HailstoneNumbers ( N ) ;
cout << endl ; cout << " Number ▁ of ▁ Steps : ▁ " << x ; return 0 ; }
int SUM ( int n , int m ) {
if ( m == 1 ) return ( n * ( n + 1 ) / 2 ) ; int sum = SUM ( n , m - 1 ) ; return ( sum * ( sum + 1 ) / 2 ) ; }
int main ( ) { int n = 5 ; int m = 3 ; cout << " SUM ( " << n << " , ▁ " << m << " ) : ▁ " << SUM ( n , m ) ; return 0 ; }
int xorCalc ( int k ) { if ( k == 1 ) return 2 ;
if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return -1 ; }
int main ( ) { int k = 31 ; cout << xorCalc ( k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string findNthNo ( int n ) { string res = " " ; while ( n >= 1 ) {
if ( n & 1 ) { res = res + "4" ; n = ( n - 1 ) / 2 ; }
else { res = res + "7" ; n = ( n - 2 ) / 2 ; } }
reverse ( res . begin ( ) , res . end ( ) ) ; return res ; }
int main ( ) { int n = 13 ; cout << findNthNo ( n ) ; return 0 ; }
int divCount ( int n ) {
bool hash [ n + 1 ] ; memset ( hash , true , sizeof ( hash ) ) ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = false ;
int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) {
int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; }
int main ( ) { int n = 24 ; cout << divCount ( n ) ; return 0 ; }
int maxPrimefactorNum ( int N ) {
int arr [ N + 1 ] ; memset ( arr , 0 , sizeof ( arr ) ) ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( ! arr [ i ] ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; }
return * max_element ( arr , arr + N ) ; }
int main ( ) { int N = 40 ; cout << maxPrimefactorNum ( N ) << endl ; return 0 ; }
string decToBin ( int n ) { if ( n == 0 ) return "0" ;
string bin = " " ; while ( n > 0 ) {
bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ;
n >>= 1 ; }
return bin ; }
int main ( ) { int n = 38 ; cout << decToBin ( n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int arraySum ( int arr [ ] , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; }
int main ( ) { int arr [ ] = { 10 , 11 , 12 , 13 , 12 , 11 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << arraySum ( arr , n ) ; return 0 ; }
bool isBalancePossible ( int T , int a ) {
vector < int > baseForm ;
while ( T ) { baseForm . push_back ( T % a ) ; T /= a ; }
baseForm . push_back ( 0 ) ;
for ( int i = 0 ; i < baseForm . size ( ) ; i ++ ) {
if ( baseForm [ i ] != 0 && baseForm [ i ] != 1 && baseForm [ i ] != ( a - 1 ) && baseForm [ i ] != a ) return false ;
if ( baseForm [ i ] == a || baseForm [ i ] == ( a - 1 ) ) baseForm [ i + 1 ] += 1 ; }
return true ; }
int main ( ) { int T = 11 ; int a = 4 ; bool balancePossible = isBalancePossible ( T , a ) ; if ( balancePossible ) cout << " Balance ▁ is ▁ possible " << endl ; else cout << " Balance ▁ is ▁ not ▁ possible " << endl ; return 0 ; }
int countDigits ( int a , int b ) {
if ( a == 0 b == 0 ) return 1 ;
return floor ( log10 ( abs ( a ) ) + log10 ( abs ( b ) ) ) + 1 ; }
int main ( ) { int a = 33 ; int b = -24 ; cout << countDigits ( a , b ) ; return 0 ; }
int lastPosition ( int n , int m , int k ) {
if ( m <= n - k + 1 ) return m + k - 1 ;
m = m - ( n - k + 1 ) ;
return ( m % n == 0 ) ? n : ( m % n ) ; }
int main ( ) { int n = 5 ; int m = 8 ; int k = 2 ; cout << lastPosition ( n , m , k ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void primesInRange ( int n ) {
int fact = 1 ; for ( int k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) cout << k << endl ; } }
int main ( ) { int n = 15 ; primesInRange ( n ) ; }
#define EPS  1e-9 NEW_LINE void productPuzzle ( int a [ ] , int n ) {
long double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( long double ) log10 ( a [ i ] ) ;
for ( int i = 0 ; i < n ; i ++ ) cout << ( int ) ( EPS + pow ( ( long double ) 10.00 , sum - log10 ( a [ i ] ) ) ) << " ▁ " ; }
int main ( ) { int a [ ] = { 10 , 3 , 5 , 6 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << " The ▁ product ▁ array ▁ is : ▁ STRNEWLINE " ; productPuzzle ( a , n ) ; return 0 ; }
int changeEvenBits ( int n ) {
int to_subtract = 0 ;
int m = 0 ;
for ( int x = n ; x ; x >>= 2 ) {
if ( x & 1 ) to_subtract += ( 1 << m ) ;
m += 2 ; } return n - to_subtract ; }
int main ( ) { int n = 30 ; cout << changeEvenBits ( n ) << endl ; return 0 ; }
int closestNumber ( int n , int m ) {
int q = n / m ;
int n1 = m * q ;
int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ;
if ( abs ( n - n1 ) < abs ( n - n2 ) ) return n1 ;
return n2 ; }
int main ( ) { int n = 13 , m = 4 ; cout << closestNumber ( n , m ) << endl ; n = -15 ; m = 6 ; cout << closestNumber ( n , m ) << endl ; n = 0 ; m = 8 ; cout << closestNumber ( n , m ) << endl ; n = 18 ; m = -7 ; cout << closestNumber ( n , m ) << endl ; return 0 ; }
bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( sqrt ( x ) ) ; i ++ )
if ( x == i * ( i + 1 ) ) return true ; return false ; }
for ( int i = 0 ; i <= 200 ; i ++ ) if ( checkPronic ( i ) ) cout << i << " ▁ " ; return 0 ; }
int findMinSum ( int num ) { int sum = 0 ;
for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ;
return sum ; }
int main ( ) { int num = 12 ; cout << findMinSum ( num ) ; return 0 ; }
void findMin ( int sum ) { int a = 0 , b = 0 ; while ( sum > 0 ) {
if ( sum % 7 == 0 ) { b ++ ; sum -= 7 ; } else if ( sum % 4 == 0 ) { a ++ ; sum -= 4 ; }
else { a ++ ; sum -= 4 ; } } if ( sum < 0 ) { printf ( " - 1n " ) ; return ; } for ( int i = 0 ; i < a ; i ++ ) printf ( "4" ) ; for ( int i = 0 ; i < b ; i ++ ) printf ( "7" ) ; printf ( " n " ) ; }
int main ( ) { findMin ( 15 ) ; return 0 ; }
int minNum ( int arr [ ] , int n ) {
int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 ) odd += 1 ; return ( odd % 2 ) ? 1 : 2 ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minNum ( arr , n ) << " n " ; return 0 ; }
int printMaxNum ( int num ) {
int count [ 10 ] = { 0 } ;
string str = to_string ( num ) ;
for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ str [ i ] - '0' ] ++ ;
int result = 0 , multiplier = 1 ;
for ( int i = 0 ; i <= 9 ; i ++ ) { while ( count [ i ] > 0 ) { result = result + ( i * multiplier ) ; count [ i ] -- ; multiplier = multiplier * 10 ; } }
return result ; }
int main ( ) { int num = 38293367 ; cout << printMaxNum ( num ) ; return 0 ; }
string largestNumber ( string num ) { int n = num . size ( ) ; int rightMax [ n ] , right ;
rightMax [ n - 1 ] = -1 ;
right = n - 1 ;
for ( int i = n - 2 ; i >= 0 ; i -- ) {
if ( num [ i ] < num [ right ] ) rightMax [ i ] = right ;
else {
rightMax [ i ] = -1 ;
right = i ; } }
for ( int i = 0 ; i < n ; i ++ ) {
if ( rightMax [ i ] != -1 ) {
swap ( num [ i ] , num [ rightMax [ i ] ] ) ; break ; } }
return num ; }
int main ( ) { string num = "8725634" ; cout << " Largest ▁ number : " << largestNumber ( num ) ; return 0 ; }
int nCr ( int n , int r ) {
if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ) ; answer /= i ; } return answer ; }
float binomialProbability ( int n , int k , float p ) { return nCr ( n , k ) * pow ( p , k ) * pow ( 1 - p , n - k ) ; }
int main ( ) { int n = 10 ; int k = 5 ; float p = 1.0 / 3 ; float probability = binomialProbability ( n , k , p ) ; cout << " Probability ▁ of ▁ " << k ; cout << " ▁ heads ▁ when ▁ a ▁ coin ▁ is ▁ tossed ▁ " << n ; cout << " ▁ times ▁ where ▁ probability ▁ of ▁ each ▁ head ▁ is ▁ " << p << endl ; cout << " ▁ is ▁ = ▁ " << probability << endl ; }
int findMaxGCD ( int arr [ ] , int n ) {
int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = max ( high , arr [ i ] ) ;
int divisors [ high + 1 ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) {
for ( int j = 1 ; j <= sqrt ( arr [ i ] ) ; j ++ ) {
if ( arr [ i ] % j == 0 ) {
divisors [ j ] ++ ;
if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } }
for ( int i = high ; i >= 1 ; i -- )
if ( divisors [ i ] > 1 ) return i ; }
int arr [ ] = { 1 , 2 , 4 , 8 , 8 , 12 } ;
int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxGCD ( arr , n ) ; return 0 ; }
int findMaxGCD ( int arr [ ] , int n ) {
int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = max ( high , arr [ i ] ) ;
int count [ high + 1 ] = { 0 } ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ;
int counter = 0 ;
for ( int i = high ; i >= 1 ; i -- ) { int j = i ; counter = 0 ;
while ( j <= high ) {
if ( count [ j ] >= 2 ) return j ; else if ( count [ j ] == 1 ) counter ++ ;
j += i ;
if ( counter == 2 ) return i ; } } }
int arr [ ] = { 1 , 2 , 4 , 8 , 8 , 12 } ;
int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMaxGCD ( arr , n ) ; return 0 ; }
int count_one ( int n ) { int c_one = 0 ; while ( n != 0 ) { int rem = n % 10 ;
if ( rem == 1 ) c_one = c_one + 1 ; n = n / 10 ; } return c_one ; }
int checkEvil ( int n ) { int i = 0 , bin = 0 , n_one = 0 ;
while ( n != 0 ) {
int r = n % 2 ;
bin = bin + r * ( int ) ( pow ( 10 , i ) ) ; n = n / 2 ; }
n_one = count_one ( bin ) ; if ( n_one % 2 == 0 ) return 1 ; else return 0 ; }
int main ( void ) { int i , check , num ; num = 32 ; check = checkEvil ( num ) ; if ( check == 1 ) cout << num << " ▁ is ▁ Evil ▁ Number STRNEWLINE " ; else cout << num << " ▁ is ▁ Odious ▁ Number STRNEWLINE " ; return 0 ; }
int CountPairs ( int n ) {
int k = n ;
int imin = 1 ;
int ans = 0 ; while ( imin <= n ) {
int imax = n / k ;
ans += k * ( imax - imin + 1 ) ;
imin = imax + 1 ; k = n / imin ; } return ans ; }
int main ( ) { cout << CountPairs ( 1 ) << endl ; cout << CountPairs ( 2 ) << endl ; cout << CountPairs ( 3 ) << endl ; return 0 ; }
long long powermod ( long long x , long long y , long long p ) {
while ( y > 0 ) {
if ( y & 1LL ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
long long modInverse ( long long a , long long m ) { long long m0 = m , t , q ; long long x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) {
q = a / m ; t = m ;
m = a % m , a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; }
if ( x1 < 0 ) x1 += m0 ; return x1 ; }
long long evaluteExpression ( long long & n ) {
long long firstsum = 0 , mod = 10 ;
for ( long long i = 2 , j = 0 ; ( 1LL << j ) <= n ; i *= i , ++ j ) firstsum = ( firstsum + i ) % mod ;
long long secondsum = ( powermod ( 4LL , n + 1 , mod ) - 1 ) * modInverse ( 3LL , mod ) ; return ( firstsum * secondsum ) % mod ; }
int main ( ) { long long n = 3 ; cout << evaluteExpression ( n ) << endl ; n = 10 ; cout << evaluteExpression ( n ) ; return 0 ; }
int PowerOFPINnfactorial ( int n , int p ) {
int ans = 0 ;
int temp = p ;
while ( temp <= n ) {
ans += n / temp ;
temp = temp * p ; } return ans ; }
int main ( ) { cout << PowerOFPINnfactorial ( 4 , 2 ) << endl ; return 0 ; }
int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ;
int base = 1 ; int temp = num ; while ( temp ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; }
int main ( ) { int num = 10101001 ; cout << binaryToDecimal ( num ) << endl ; }
long int stirlingFactorial ( int n ) { if ( n == 1 ) return 1 ; long int z ;
z = sqrt ( 2 * 3.14 * n ) * pow ( ( n / e ) , n ) ; return z ; }
int main ( ) { cout << stirlingFactorial ( 1 ) << endl ; cout << stirlingFactorial ( 2 ) << endl ; cout << stirlingFactorial ( 3 ) << endl ; cout << stirlingFactorial ( 4 ) << endl ; cout << stirlingFactorial ( 5 ) << endl ; cout << stirlingFactorial ( 6 ) << endl ; cout << stirlingFactorial ( 7 ) << endl ; return 0 ; }
int countXorPair ( int arr [ ] , int n ) {
int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; }
return odd * even ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countXorPair ( arr , n ) ; return 0 ; }
static int MAX_ITERATIONS = 20 ;
string isLychrel ( long number ) { for ( int i = 0 ; i < MAX_ITERATIONS ; i ++ ) { number = number + reverse ( number ) ; if ( isPalindrome ( number ) ) return " false " ; } return " true " ; }
bool isPalindrome ( long number ) { return number == reverse ( number ) ; }
long reverse ( long number ) { long reverse = 0 ; while ( number > 0 ) { long remainder = number % 10 ; reverse = ( reverse * 10 ) + remainder ; number = number / 10 ; } return reverse ; }
int main ( ) { long number = 295 ; cout << number << " ▁ is ▁ lychrel ? ▁ " << isLychrel ( number ) ; }
int findRectNum ( int n ) { return n * ( n + 1 ) ; }
int main ( ) { int n = 6 ; cout << findRectNum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_ITERATIONS = 10000 ;
float f ( float x ) {
return 1 * pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ; } void Muller ( float a , float b , float c ) { int i ; float res ; for ( i = 0 ; ; ++ i ) {
float f1 = f ( a ) ; float f2 = f ( b ) ; float f3 = f ( c ) ; float d1 = f1 - f3 ; float d2 = f2 - f3 ; float h1 = a - c ; float h2 = b - c ; float a0 = f3 ; float a1 = ( ( ( d2 * pow ( h1 , 2 ) ) - ( d1 * pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; float a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; float x = ( ( -2 * a0 ) / ( a1 + abs ( sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; float y = ( ( -2 * a0 ) / ( a1 - abs ( sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ;
if ( x >= y ) res = x + c ; else res = y + c ;
float m = res * 100 ; float n = c * 100 ; m = floor ( m ) ; n = floor ( n ) ; if ( m == n ) break ; a = b ; b = c ; c = res ; if ( i > MAX_ITERATIONS ) { cout << " Root ▁ cannot ▁ be ▁ found ▁ using " << " ▁ Muller ' s ▁ method " ; break ; } } if ( i <= MAX_ITERATIONS ) cout << " The ▁ value ▁ of ▁ the ▁ root ▁ is ▁ " << res ; }
int main ( ) { float a = 0 , b = 1 , c = 2 ; Muller ( a , b , c ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long NEW_LINE const int MAX = 100001 ;
vector < ll > p ;
void sieve ( ) { ll isPrime [ MAX + 1 ] ; for ( ll i = 2 ; i <= MAX ; i ++ ) {
if ( isPrime [ i ] == 0 ) {
p . push_back ( i ) ;
for ( ll j = 2 ; i * j <= MAX ; j ++ ) isPrime [ i * j ] = 1 ; } } }
ll phi ( ll n ) { ll res = n ;
for ( ll i = 0 ; p [ i ] * p [ i ] <= n ; i ++ ) { if ( n % p [ i ] == 0 ) {
res -= ( res / p [ i ] ) ;
while ( n % p [ i ] == 0 ) n /= p [ i ] ; } }
if ( n > 1 ) res -= ( res / n ) ; return res ; }
sieve ( ) ; cout << phi ( 11 ) << " STRNEWLINE " ; cout << phi ( 21 ) << " STRNEWLINE " ; cout << phi ( 31 ) << " STRNEWLINE " ; cout << phi ( 41 ) << " STRNEWLINE " ; cout << phi ( 51 ) << " STRNEWLINE " ; cout << phi ( 61 ) << " STRNEWLINE " ; cout << phi ( 91 ) << " STRNEWLINE " ; cout << phi ( 101 ) << " STRNEWLINE " ; return 0 ; }
void nthprimedigitsnumber ( long long n ) {
long long len = 1 ;
long long prev_count = 0 ; while ( true ) {
long long curr_count = prev_count + pow ( 4 , len ) ;
if ( prev_count < n && curr_count >= n ) break ;
len ++ ; prev_count = curr_count ; }
for ( int i = 1 ; i <= len ; i ++ ) {
for ( long long j = 1 ; j <= 4 ; j ++ ) {
if ( prev_count + pow ( 4 , len - i ) < n ) prev_count += pow ( 4 , len - i ) ;
else { if ( j == 1 ) cout << "2" ; else if ( j == 2 ) cout << "3" ; else if ( j == 3 ) cout << "5" ; else if ( j == 4 ) cout << "7" ; break ; } } } cout << endl ; }
int main ( ) { nthprimedigitsnumber ( 10 ) ; nthprimedigitsnumber ( 21 ) ; return 0 ; }
int cassini ( int n ) { return ( n & 1 ) ? -1 : 1 ; }
int main ( ) { int n = 5 ; cout << cassini ( n ) ; return 0 ; }
bool findNoIsDivisibleOrNot ( int a [ ] , int n , int l ) { for ( int i = 0 ; i < l ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; }
int main ( ) { int a [ ] = { 14 , 12 , 4 , 18 } ; int n = 2 ; int l = ( sizeof ( a ) / sizeof ( a [ 0 ] ) ) ; if ( findNoIsDivisibleOrNot ( a , n , l ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; }
int printRange ( int n ) { int a = factorial ( n + 2 ) + 2 ; int b = a + n - 1 ; cout << " [ " << a << " , ▁ " << b << " ] " ; return 0 ; }
int main ( ) { int n = 3 ; printRange ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  long long NEW_LINE #define ld  long double NEW_LINE using namespace std ; ll findMinValue ( ll arr [ ] , ll n ) {
sort ( arr , arr + n ) ;
for ( int i = 0 ; i < n ; i ++ ) val += ( ld ) ( log ( ( ld ) ( arr [ i ] ) ) ) ;
ll left = arr [ 0 ] , right = arr [ n - 1 ] + 1 ; ll ans ; while ( left <= right ) { ll mid = ( left + right ) / 2 ;
ld temp = ( ld ) n * ( ld ) ( log ( ( ld ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else left = mid + 1 ; } return ans ; }
int main ( ) { ll arr [ ] = { 4 , 2 , 1 , 10 , 6 } ; ll n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinValue ( arr , n ) << endl ; return 0 ; }
int sumOfTermsInNthRow ( int n ) {
int sum = n * ( 2 * pow ( n , 2 ) + 1 ) ; return sum ; }
int main ( ) { int n = 4 ; cout << " Sum ▁ of ▁ all ▁ the ▁ terms ▁ in ▁ nth ▁ row ▁ = ▁ " << sumOfTermsInNthRow ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int firstDigit ( int x ) {
while ( x >= 10 ) x = x / 10 ; return x ; }
int main ( ) { cout << firstDigit ( 12345 ) << endl ; cout << firstDigit ( 5432 ) << endl ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int getOccurence ( int n , int d ) {
int itr = d ; while ( itr <= n ) {
if ( itr % 10 == d ) result ++ ;
if ( itr != 0 && itr / 10 == d ) {
result ++ ; itr ++ ; }
else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; }
int main ( void ) { int n = 11 , d = 1 ; cout << getOccurence ( n , d ) ; return 0 ; }
void cal_cos ( float n ) { float accuracy = 0.0001 , x1 , denominator , cosx , cosval ;
n = n * ( 3.142 / 180.0 ) ; x1 = 1 ;
cosx = x1 ;
cosval = cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= fabs ( cosval - cosx ) ) ; cout << cosx ; }
int main ( ) { float n = 30 ; cal_cos ( n ) ; }
void multiply ( vector < int > & v , int x ) { int carry = 0 , res ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) {
int res = carry + v [ i ] * x ;
v [ i ] = res % 10 ; carry = res / 10 ; } while ( carry != 0 ) { v . push_back ( carry % 10 ) ; carry /= 10 ; } }
int findSumOfDigits ( int n ) {
for ( int i = 1 ; i <= n ; i ++ ) multiply ( v , i ) ;
int sum = 0 ; int size = v . size ( ) ; for ( int i = 0 ; i < size ; i ++ ) sum += v [ i ] ; return sum ; }
int main ( ) { int n = 1000 ; cout << findSumOfDigits ( n ) ; return 0 ; }
void printOtherSides ( int n ) {
if ( n & 1 ) {
if ( n == 1 ) cout << -1 << endl ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; cout << " b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; } } else {
if ( n == 2 ) cout << -1 << endl ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; cout << " b ▁ = ▁ " << b << " , ▁ c ▁ = ▁ " << c << endl ; } } }
int main ( ) { int a = 3 ; printOtherSides ( a ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int makeOdd ( int n ) {
if ( n % 2 != 0 ) return 1 ;
for ( int i = 2 ; i <= n ; i ++ )
if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) return i ; }
int main ( ) { int n = 36 ; cout << makeOdd ( n ) ; return 0 ; }
int getTotalXorOfSubarrayXors ( int arr [ ] , int N ) {
if ( N % 2 == 0 ) return 0 ;
int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; }
int main ( ) { int arr [ ] = { 3 , 5 , 2 , 4 , 6 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getTotalXorOfSubarrayXors ( arr , N ) ; return 0 ; }
int countIterations ( int arr [ ] , int n ) { bool oneFound = false ; int res = 0 ;
for ( int i = 0 ; i < n ; ) { if ( arr [ i ] == 1 ) oneFound = true ;
while ( i < n && arr [ i ] == 1 ) i ++ ;
int count_zero = 0 ; while ( i < n && arr [ i ] == 0 ) { count_zero ++ ; i ++ ; }
if ( oneFound == false && i == n ) return -1 ;
int curr_count ; if ( i < n && oneFound == true ) {
if ( count_zero & 1 == 0 ) curr_count = count_zero / 2 ;
else curr_count = ( count_zero + 1 ) / 2 ;
count_zero = 0 ; }
else { curr_count = count_zero ; count_zero = 0 ; }
res = max ( res , curr_count ) ; } return res ; }
int main ( ) { int arr [ ] = { 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countIterations ( arr , n ) ; return 0 ; }
void printConsecutive ( int last , int first ) { cout << first ++ ; for ( int x = first ; x <= last ; x ++ ) cout << " ▁ + ▁ " << x ; } void findConsecutive ( int N ) { for ( int last = 1 ; last < N ; last ++ ) { for ( int first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { cout << N << " ▁ = ▁ " ; printConsecutive ( last , first + 1 ) ; return ; } } } cout << " - 1" ; }
int main ( ) { int n = 12 ; findConsecutive ( n ) ; return 0 ; }
int printNthElement ( int n ) {
int arr [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) {
if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; }
int main ( ) { int n = 6 ; cout << printNthElement ( n ) ; return 0 ; }
int maxSumLCM ( int n ) {
for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; }
int main ( ) { int n = 2 ; cout << MaxSumLCM ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE int main ( void ) { double n = 12 ; printf ( " % lf ▁ " , sqrt ( n ) ) ; return 0 ; }
bool func ( int a [ ] , int k , int n ) {
for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; }
int main ( ) { int a [ ] = { 14 , 27 , 38 , 76 , 84 } ; int k = 19 ; bool res = func ( a , k , 5 ) ; if ( res ) cout << " true " ; else cout << " false " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; char * tidyNum ( char str [ ] , int len ) { for ( int i = len - 2 ; i >= 0 ; i -- ) {
if ( str [ i ] > str [ i + 1 ] ) {
( char ) str [ i ] -- ; for ( int j = i + 1 ; j < len ; j ++ ) str [ j ] = '9' ; } } return str ; }
int main ( ) { char str [ ] = "11333445538" ; int len = strlen ( str ) ;
char * num = tidyNum ( str , len ) ; printf ( " % s STRNEWLINE " , num ) ; return 0 ; }
int findCount ( int m , int n ) {
int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ;
int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ;
return ( ( num1 / n ) - ( num2 / n ) ) ; }
int main ( ) { int m = 2 , n = 6 ; printf ( " % d STRNEWLINE " , findCount ( m , n ) ) ; return 0 ; }
int findNthEvenDigitNumber ( int n ) {
int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ;
bool isCurrEvenDigit = true ;
while ( curr != 0 ) {
if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; }
if ( isCurrEvenDigit == true ) count ++ ;
if ( count == n ) return i ; } }
int main ( ) { cout << findNthEvenDigitNumber ( 2 ) << endl ; cout << findNthEvenDigitNumber ( 10 ) << endl ; return 0 ; }
int findNthEvenDigitNumber ( int n ) {
if ( n == 1 ) return 0 ;
vector < int > v ;
n = n - 1 ;
while ( n > 0 ) {
v . push_back ( n % 5 ) ; n = n / 5 ; }
int result = 0 ; for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v [ i ] ; }
return 2 * result ; }
int main ( ) { cout << findNthEvenDigitNumber ( 2 ) << endl ; cout << findNthEvenDigitNumber ( 10 ) << endl ; return 0 ; }
bool isDivisibleBy25 ( string str ) {
int n = str . length ( ) ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - '0' == 0 && str [ n - 2 ] - '0' == 0 ) || ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 25 == 0 ) ; }
int main ( ) { string str = "76955" ; isDivisibleBy25 ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
bool check ( string str ) { int n = str . length ( ) ;
if ( n == 0 && n == 1 ) return false ;
if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ;
if ( n == 3 ) return ( ( ( str [ n - 3 ] - '0' ) * 100 + ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ;
int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; int fourth_last = str [ n - 4 ] - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; }
int main ( ) { string str = "769528" ; check ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE int findIndex ( int n ) {
if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ;
while ( c < n ) { c = a + b ;
res ++ ; a = b ; b = c ; } return res ; }
int main ( ) { int result = findIndex ( 21 ) ; printf ( " % d STRNEWLINE " , result ) ; }
int divisorSum ( int N , int K ) { int sum = 0 ;
for ( int i = 2 ; i <= ceil ( sqrt ( N ) ) ; i ++ )
if ( N % i == 0 ) sum += ( i + N / i ) ; return sum ; }
bool isPrime ( int n ) {
if ( n == 1 n == 0 ) return false ; if ( n <= 3 ) return true ;
if ( n % 2 == 0 n % 3 == 0 ) return false ;
for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; }
bool isHyperPerfect ( int N , int K ) { int sum = divisorSum ( N , K ) ;
if ( ( 1 + K * ( sum ) ) == N ) return true ; else return false ; }
int main ( ) { int N1 = 1570153 , K1 = 12 ; int N2 = 321 , K2 = 3 ;
if ( isHyperPerfect ( N1 , K1 ) ) cout << N1 << " ▁ is ▁ " << K1 << " - HyperPerfect " << " STRNEWLINE " ; else cout << N1 << " ▁ is ▁ not ▁ " << K1 << " - HyperPerfect " << " STRNEWLINE " ; if ( isHyperPerfect ( N2 , K2 ) ) cout << N2 << " ▁ is ▁ " << K2 << " - HyperPerfect " << " STRNEWLINE " ; else cout << N2 << " ▁ is ▁ not ▁ " << K2 << " - HyperPerfect " << " STRNEWLINE " ; return 0 ; }
void printWellOrdered ( int number , int x , int k ) { if ( k == 0 ) { cout << number << " ▁ " ; return ; }
for ( int i = ( x + 1 ) ; i < 10 ; i ++ ) printWellOrdered ( number * 10 + i , i , k - 1 ) ; }
void generateWellOrdered ( int k ) { printWellOrdered ( 0 , 0 , k ) ; }
int main ( ) { int k = 3 ; generateWellOrdered ( k ) ; return 0 ; }
long long moduloMultiplication ( long long a , long long b , long long mod ) {
a %= mod ; while ( b ) {
if ( b & 1 ) res = ( res + a ) % mod ;
a = ( 2 * a ) % mod ;
} return res ; }
int main ( ) { long long a = 426 ; long long b = 964 ; long long m = 235 ; cout << moduloMultiplication ( a , b , m ) ; return 0 ; }
int count2sinRangeAtDigit ( int number , int d ) { int powerOf10 = ( int ) pow ( 10 , d ) ; int nextPowerOf10 = powerOf10 * 10 ; int right = number % powerOf10 ; int roundDown = number - number % nextPowerOf10 ; int roundup = roundDown + nextPowerOf10 ; int digit = ( number / powerOf10 ) % 10 ;
if ( digit < 2 ) return roundDown / 10 ; if ( digit == 2 ) return roundDown / 10 + right + 1 ; return roundup / 10 ; }
int numberOf2sinRange ( int number ) {
stringstream convert ; convert << number ; string s = convert . str ( ) ; int len = s . length ( ) ;
int count = 0 ; for ( int digit = 0 ; digit < len ; digit ++ ) count += count2sinRangeAtDigit ( number , digit ) ; return count ; }
int main ( ) { cout << numberOf2sinRange ( 22 ) << endl ; cout << numberOf2sinRange ( 100 ) ; return 0 ; }
int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; }
int main ( ) { int n = 3 ; cout << findStarNum ( n ) ; return 0 ; }
bool isDivisibleBy5 ( string str ) { int n = str . length ( ) ; return ( ( ( str [ n - 1 ] - '0' ) == 0 ) || ( ( str [ n - 1 ] - '0' ) == 5 ) ) ; }
int main ( ) { string str = "76955" ; isDivisibleBy5 ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
bool isTidy ( int num ) {
int prev = 10 ;
while ( num ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; }
int main ( ) { int num = 1556 ; isTidy ( num ) ? cout << " Yes " : cout << " No " ; return 0 ; }
int squareFree ( int n ) {
int cnt = 0 ;
for ( int i = 1 ; ; i ++ ) { bool isSqFree = true ; for ( int j = 2 ; j * j <= i ; j ++ ) {
if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } }
if ( isSqFree == true ) { cnt ++ ;
if ( cnt == n ) return i ; } } return 0 ; }
int main ( ) { int n = 10 ; cout << squareFree ( n ) << endl ; return 0 ; }
void kFactors ( int n , int k ) {
vector < int > P ;
while ( n % 2 == 0 ) { P . push_back ( 2 ) ; n /= 2 ; }
for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . push_back ( i ) ; } }
if ( n > 2 ) P . push_back ( n ) ;
if ( P . size ( ) < k ) { cout << " - 1" << endl ; return ; }
for ( int i = 0 ; i < k - 1 ; i ++ ) cout << P [ i ] << " , ▁ " ;
int product = 1 ; for ( int i = k - 1 ; i < P . size ( ) ; i ++ ) product = product * P [ i ] ; cout << product << endl ; }
int main ( ) { int n = 54 , k = 3 ; kFactors ( n , k ) ; return 0 ; }
long long nondecdigits ( long long n ) {
long long int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ;
bool flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; }
if ( flag == true ) break ; } return x ; }
int main ( ) { long long n = 200 ; cout << nondecdigits ( n ) ; return 0 ; }
void nondecdigits ( string s ) { long long m = s . size ( ) ;
long long a [ m ] ;
for ( long long i = 0 ; i < m ; i ++ ) a [ i ] = s [ i ] - '0' ;
long long level = m - 1 ; for ( long long i = m - 1 ; i > 0 ; i -- ) {
if ( a [ i ] < a [ i - 1 ] ) { a [ i - 1 ] -- ; level = i - 1 ; } }
if ( a [ 0 ] != 0 ) { for ( long long i = 0 ; i <= level ; i ++ ) cout << a [ i ] ; for ( long long i = level + 1 ; i < m ; i ++ ) cout << "9" ; } else { for ( long long i = 1 ; i < level ; i ++ ) cout << a [ i ] ; for ( long long i = level + 1 ; i < m ; i ++ ) cout << "9" ; } }
int main ( ) { string n = "200" ; nondecdigits ( n ) ; return 0 ; }
int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) {
if ( n / i == i ) cnt ++ ;
cnt = cnt + 2 ; } } return cnt ; }
int main ( ) { printf ( " Total ▁ distinct ▁ divisors ▁ of ▁ 100 ▁ are ▁ : ▁ % d " , countDivisors ( 100 ) ) ; return 0 ; }
bool hasEvenNumberOfFactors ( int n ) { int root_n = sqrt ( n ) ;
if ( ( root_n * root_n ) == n ) return false ;
return true ; }
void printStatusOfDoors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) {
if ( hasEvenNumberOfFactors ( i ) ) cout << " closed " << " ▁ " ;
else cout < < " open " << " ▁ " ; } }
int main ( ) { int n = 5 ; printStatusOfDoors ( n ) ; return 0 ; }
bool validate ( long long int n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long long int temp = n ; int count = 0 ; while ( temp ) {
if ( temp % 10 == i ) count ++ ;
if ( count > i ) return false ; temp /= 10 ; } } return true ; }
int main ( ) { long long int n = 1552793 ; if ( validate ( n ) ) cout << " True " ; else cout << " False " ; return 0 ; }
string divisibleBy36 ( string num ) { int l = num . length ( ) ;
if ( l == 0 ) return " No " ;
if ( l == 1 && num [ 0 ] != '0' ) return " No " ;
int two_digit_num = ( num [ l - 2 ] - '0' ) * 10 + ( num [ l - 1 ] - '0' ) ;
if ( two_digit_num % 4 != 0 ) return " No " ;
int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - '0' ) ;
if ( sum % 9 != 0 ) return " No " ;
return " Yes " ; }
int main ( ) { string num = "92567812197966231384" ; cout << divisibleBy36 ( num ) ; return 0 ; }
bool check ( string str ) { int n = str . length ( ) ;
if ( n == 0 ) return false ;
if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 8 == 0 ) ;
if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 8 == 0 ) ;
int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; }
int main ( ) { string str = "76952" ; check ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n / 10 ; } return count ; }
int checkPrime ( int n ) {
if ( n <= 1 ) return -1 ; if ( n <= 3 ) return 0 ;
if ( n % 2 == 0 n % 3 == 0 ) return -1 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return -1 ; return 0 ; }
void printPrimePoints ( int n ) {
int count = countDigits ( n ) ;
if ( count == 1 count == 2 ) { cout << " - 1" ; return ; }
bool found = false ; for ( int i = 1 ; i < ( count - 1 ) ; i ++ ) {
int left = n / ( ( int ) pow ( 10 , count - i ) ) ;
int right = n % ( ( int ) pow ( 10 , count - i - 1 ) ) ;
if ( checkPrime ( left ) == 0 && checkPrime ( right ) == 0 ) { cout << i << " ▁ " ; found = true ; } }
if ( found == false ) cout << " - 1" ; }
int main ( ) { int n = 2317 ; printPrimePoints ( n ) ; return 0 ; }
int power ( int num , unsigned int n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , n / 2 ) * power ( num , n / 2 ) ; else return num * power ( num , n / 2 ) * power ( num , n / 2 ) ; }
int checkRecursive ( int x , int n , int curr_num = 1 , int curr_sum = 0 ) {
int results = 0 ;
int p = power ( curr_num , n ) ; while ( p + curr_sum < x ) {
results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) ; curr_num ++ ; p = power ( curr_num , n ) ; }
if ( p + curr_sum == x ) results ++ ;
return results ; }
int main ( ) { int x = 10 , n = 2 ; cout << checkRecursive ( x , n ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int printGenerators ( unsigned int n ) {
cout << "1 ▁ " ; for ( int i = 2 ; i < n ; i ++ )
if ( gcd ( i , n ) == 1 ) cout << i << " ▁ " ; }
int main ( ) { int n = 10 ; printGenerators ( n ) ; return 0 ; }
int check ( string str ) {
int n = str . length ( ) ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ;
return ( digitSum % 3 == 0 ) ; }
int main ( ) { string str = "1332" ; check ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX  100001 NEW_LINE int perfectDiv [ MAX ] ;
void precomputeCounts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) {
for ( int j = i * i ; j < MAX ; j += i * i )
++ perfectDiv [ j ] ; } }
int countPerfectDivisors ( int n ) { return perfectDiv [ n ] ; }
int main ( ) { precomputeCounts ( ) ; int n = 16 ; cout << " Total ▁ perfect ▁ divisors ▁ of ▁ " << n << " ▁ = ▁ " << countPerfectDivisors ( n ) << " STRNEWLINE " ; n = 12 ; cout << " Total ▁ perfect ▁ divisors ▁ of ▁ " << n << " ▁ = ▁ " << countPerfectDivisors ( n ) ; return 0 ; }
#include " bits / stdc + + . h " NEW_LINE using namespace std ; #define MAXN  100001
int spf [ MAXN ] ;
void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ )
spf [ i ] = i ;
for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) {
if ( spf [ i ] == i ) {
for ( int j = i * i ; j < MAXN ; j += i )
if ( spf [ j ] == j ) spf [ j ] = i ; } } }
vector < int > getFactorization ( int x ) { vector < int > ret ; while ( x != 1 ) { ret . push_back ( spf [ x ] ) ; x = x / spf [ x ] ; } return ret ; }
sieve ( ) ; int x = 12246 ; cout << " prime ▁ factorization ▁ for ▁ " << x << " ▁ : ▁ " ;
vector < int > p = getFactorization ( x ) ; for ( int i = 0 ; i < p . size ( ) ; i ++ ) cout << p [ i ] << " ▁ " ; cout << endl ; return 0 ; }
int largestGCDSubsequence ( int arr [ ] , int n ) { int ans = 0 ;
int maxele = * max_element ( arr , arr + n ) ;
for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) {
if ( arr [ j ] % i == 0 ) ++ count ; } ans = max ( ans , count ) ; } return ans ; }
int main ( ) { int arr [ ] = { 3 , 6 , 2 , 5 , 4 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << largestGCDSubsequence ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define MAX  1000006 NEW_LINE using namespace std ;
void sieve ( int count [ ] ) { for ( int i = 2 ; i * i <= MAX ; i ++ ) {
if ( count [ i ] == 0 ) { for ( int j = 2 * i ; j < MAX ; j += i ) count [ j ] ++ ;
count [ i ] = 1 ; } } }
int query ( int count [ ] , int l , int r ) { int sum = 0 ;
for ( int i = l ; i <= r ; i ++ ) sum += count [ i ] ; return sum ; }
int main ( ) { int count [ MAX ] ; memset ( count , 0 , sizeof count ) ; sieve ( count ) ; cout << query ( count , 6 , 10 ) << endl << query ( count , 1 , 5 ) ; return 0 ; }
void generateNumbers ( int factor [ ] , int n , int k ) {
int next [ k ] = { 0 } ;
for ( int i = 0 ; i < n ; ) {
int toincrement = 0 ; for ( int j = 0 ; j < k ; j ++ ) if ( next [ j ] < next [ toincrement ] ) toincrement = j ;
if ( output != next [ toincrement ] ) { output = next [ toincrement ] ; printf ( " % d ▁ " , next [ toincrement ] ) ; i ++ ; }
next [ toincrement ] += factor [ toincrement ] ; } }
int main ( ) { int factor [ ] = { 3 , 5 , 7 } ; int n = 10 ; int k = sizeof ( factor ) / sizeof ( factor [ 0 ] ) ; generateNumbers ( factor , n , k ) ; return 0 ; }
int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; }
int multiplicativeOrder ( int A , int N ) { if ( GCD ( A , N ) != 1 ) return -1 ;
unsigned int result = 1 ; int K = 1 ; while ( K < N ) {
result = ( result * A ) % N ;
if ( result == 1 ) return K ;
K ++ ; } return -1 ; }
int main ( ) { int A = 4 , N = 7 ; cout << multiplicativeOrder ( A , N ) ; return 0 ; }
int sumOfRange ( int a , int b ) {
int i = ( a * ( a + 1 ) ) >> 1 ; int j = ( b * ( b + 1 ) ) >> 1 ; return ( i - j ) ; }
int sumofproduct ( int n ) { int sum = 0 ;
int root = sqrt ( n ) ; for ( int i = 1 ; i <= root ; i ++ ) {
int up = n / i ;
int low = max ( n / ( i + 1 ) , root ) ; sum += ( i * sumOfRange ( up , low ) ) ; sum += ( i * ( n / i ) ) ; } return sum ; }
int main ( ) { int n = 10 ; cout << sumofproduct ( n ) << endl ; return 0 ; }
int minPower ( int n , int x ) {
if ( x == 1 ) return n ;
int ans = 0 ; while ( n > 0 ) {
ans += ( n % x ) ;
n /= x ; } return ans ; }
int main ( ) { int n = 5 , x = 3 ; cout << minPower ( n , x ) << endl ; return 0 ; }
int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ;
return 3 ;
return 3 ;
return 5 ;
int sum = 5 ;
while ( n > 2 ) {
sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; }
int main ( ) { int n = 9 ; cout << calSum ( n ) ; return 0 ; }
int findKCF ( int x , int y , int k ) {
int small = min ( x , y ) ;
int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; }
return -1 ; }
int main ( ) { int x = 4 , y = 24 , k = 3 ; cout << findKHCF ( x , y , k ) ; return 0 ; }
int findMinNumber ( int n ) { int count = 0 , ans = 1 ;
while ( n % 2 == 0 ) { count ++ ; n /= 2 ; }
if ( count % 2 ) ans *= 2 ; for ( int i = 3 ; i <= sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; }
if ( count % 2 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; }
int main ( ) { int n = 72 ; cout << findMinNumber ( n ) << endl ; return 0 ; }
bool isToOne ( int n ) {
return ( n > 0 ) ; }
int main ( ) { int n = 5 ; isToOne ( n ) ? cout << " Yes " : cout << " No " ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void findgcd ( int n , int x , int y ) {
int g = gcd ( x , y ) ;
for ( int i = 0 ; i < g ; i ++ ) cout << n ; }
int main ( ) { int n = 123 , x = 5 , y = 2 ; findgcd ( n , x , y ) ; return 0 ; }
int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; }
int firstFactorialDivisibleNumber ( int x ) {
int new_x = x ; for ( i = 1 ; i < x ; i ++ ) {
new_x /= gcd ( i , new_x ) ;
if ( new_x == 1 ) break ; } return i ; }
int countFactorialXNotY ( int x , int y ) {
return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) ; }
int main ( void ) { int x = 15 , y = 25 ; cout << countFactorialXNotY ( x , y ) ; return 0 ; }
int firstFactorialDivisibleNumber ( int x ) {
int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; }
int main ( void ) { int x = 16 ; cout << firstFactorialDivisibleNumber ( x ) ; return 0 ; }
bool SieveOfEratosthenes ( int n , bool isPrime [ ] ) {
isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( isPrime [ p ] == true ) {
for ( int i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
void findPrimePair ( int n ) {
bool isPrime [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ;
for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime [ i ] && isPrime [ n - i ] ) { cout << i << " ▁ " << ( n - i ) ; return ; } } }
int main ( ) { int n = 74 ; findPrimePair ( n ) ; return 0 ; }
int getFirstDigit ( int x ) { while ( x >= 10 ) x /= 10 ; return x ; }
int getCountWithSameStartAndEndFrom1 ( int x ) { if ( x < 10 ) return x ;
int tens = x / 10 ;
int res = tens + 9 ;
int firstDigit = getFirstDigit ( x ) ; int lastDigit = x % 10 ;
if ( lastDigit < firstDigit ) res -- ; return res ; }
int getCountWithSameStartAndEnd ( int start , int end ) { return getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ; }
int main ( ) { int start = 5 , end = 40 ; cout << getCountWithSameStartAndEnd ( start , end ) ; return 0 ; }
bool sieveOfEratosthenes ( int n , bool isPrime [ ] ) {
isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( isPrime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } }
bool rightTruPrime ( int n ) {
bool isPrime [ n + 1 ] ; sieveOfEratosthenes ( n , isPrime ) ;
while ( n ) { if ( isPrime [ n ] ) n = n / 10 ; else return false ; } return true ; }
int main ( ) { int n = 59399 ; if ( rightTruPrime ( n ) ) cout << " Yes " << endl ; else cout << " No " << endl ; return 0 ; }
void SieveOfEratosthenes ( int n , bool prime [ ] ) {
for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } }
void mersennePrimes ( int n ) {
SieveOfEratosthenes ( n , prime ) ;
for ( int k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { long long num = ( 1 << k ) - 1 ;
if ( prime [ num ] ) cout << num << " ▁ " ; } }
int main ( ) { int n = 31 ; cout << " Mersenne ▁ prime ▁ numbers ▁ smaller ▁ " << " than ▁ or ▁ equal ▁ to ▁ " << n << endl ; mersennePrimes ( n ) ; return 0 ; }
int findSum ( int N , int K ) { int ans = 0 ;
for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; }
int main ( ) { int N = 10 , K = 2 ; cout << findSum ( N , K ) << endl ; return 0 ; }
int findSum ( int N , int K ) { int ans = 0 ;
int y = N / K ;
int x = N % K ;
ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; }
int main ( ) { int N = 10 , K = 2 ; cout << findSum ( N , K ) << endl ; return 0 ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
int findnum ( string & str ) {
int n = str . length ( ) ;
int count_after_dot = 0 ;
bool dot_seen = false ;
int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != ' . ' ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( dot_seen == true ) count_after_dot ++ ; } else dot_seen = true ; }
if ( dot_seen == false ) return 1 ;
int dem = ( int ) pow ( 10 , count_after_dot ) ;
return ( dem / gcd ( num , dem ) ) ; }
int main ( ) { string str = "5.125" ; cout << findnum ( str ) << endl ; return 0 ; }
int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; }
int main ( ) { int n = 10 ; cout << maxHandshake ( n ) << endl ; return 0 ; }
bool divisible ( string N , int digit ) { int ans = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) {
ans = ( ans * 10 + ( N [ i ] - '0' ) ) ; ans %= digit ; } return ( ans == 0 ) ; }
int allDigits ( string N ) {
bool divide [ 10 ] = { false } ;
for ( int digit = 2 ; digit <= 9 ; digit ++ ) {
if ( divisible ( N , digit ) ) divide [ digit ] = true ; }
int result = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { if ( divide [ N [ i ] - '0' ] == true ) result ++ ; } return result ; }
int main ( ) { string N = "122324" ; cout << allDigits ( N ) ; return 0 ; }
int countNums ( int n , int x , int y ) {
vector < bool > arr ( n + 1 , false ) ;
if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ;
int result = 0 ;
for ( int i = min ( x , y ) ; i <= n ; i ++ ) {
if ( arr [ i ] ) {
if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ;
result ++ ; } } return result ; }
int main ( ) { int n = 15 , x = 5 , y = 7 ; cout << countNums ( n , x , y ) ; return 0 ; }
int reverse ( int x ) { int rev = 0 ; while ( x > 0 ) { rev = ( rev * 10 ) + x % 10 ; x = x / 10 ; } return rev ; }
void printEmirp ( int n ) {
bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } }
for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) {
int rev = reverse ( p ) ;
if ( p != rev && rev <= n && prime [ rev ] ) { cout << p << " ▁ " << rev << " ▁ " ;
prime [ rev ] = false ; } } } }
int main ( ) { int n = 40 ; printEmirp ( n ) ; return 0 ; }
int getSum ( int n ) { int sum = 0 ;
for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) {
if ( n / i == i ) sum = sum + i ;
{ sum = sum + i ; sum = sum + ( n / i ) ; } } }
sum = sum - n ; return sum ; }
bool checkAbundant ( int n ) {
return ( getSum ( n ) > n ) ; }
int main ( ) { checkAbundant ( 12 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; checkAbundant ( 15 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; return 0 ; }
bool isPowerful ( int n ) {
while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; }
if ( power == 1 ) return false ; }
for ( int factor = 3 ; factor <= sqrt ( n ) ; factor += 2 ) {
int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; }
if ( power == 1 ) return false ; }
return ( n == 1 ) ; }
int main ( ) { isPowerful ( 20 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; isPowerful ( 27 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; return 0 ; }
int divisorsSum ( int n ) {
for ( int i = 1 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) {
if ( n / i == i ) { sum = sum + i ; }
{ sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; }
bool isDeficient ( int n ) {
return ( divisorsSum ( n ) < ( 2 * n ) ) ; }
int main ( ) { isDeficient ( 12 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; isDeficient ( 15 ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 10000 ;
vector < int > primes ;
void sieveSundaram ( ) {
bool marked [ MAX / 2 + 100 ] = { 0 } ;
for ( int i = 1 ; i <= ( sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ;
primes . push_back ( 2 ) ;
for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . push_back ( 2 * i + 1 ) ; }
bool isSmith ( int n ) { int original_no = n ;
int pDigitSum = 0 ; for ( int i = 0 ; primes [ i ] <= n / 2 ; i ++ ) { while ( n % primes [ i ] == 0 ) {
int p = primes [ i ] ; n = n / p ; while ( p > 0 ) { pDigitSum += ( p % 10 ) ; p = p / 10 ; } } }
if ( n != 1 && n != original_no ) { while ( n > 0 ) { pDigitSum = pDigitSum + n % 10 ; n = n / 10 ; } }
int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits = sumDigits + original_no % 10 ; original_no = original_no / 10 ; }
return ( pDigitSum == sumDigits ) ; }
sieveSundaram ( ) ; cout << " Printing ▁ first ▁ few ▁ Smith ▁ Numbers " " ▁ using ▁ isSmith ( ) n " ; for ( int i = 1 ; i < 500 ; i ++ ) if ( isSmith ( i ) ) cout << i << " ▁ " ; return 0 ; }
bool iskaprekar ( int n ) { if ( n == 1 ) return true ;
int sq_n = n * n ; int count_digits = 0 ; while ( sq_n ) { count_digits ++ ; sq_n /= 10 ; }
for ( int r_digits = 1 ; r_digits < count_digits ; r_digits ++ ) { int eq_parts = pow ( 10 , r_digits ) ;
if ( eq_parts == n ) continue ;
int sum = sq_n / eq_parts + sq_n % eq_parts ; if ( sum == n ) return true ; }
return false ; }
int main ( ) { cout << " Printing ▁ first ▁ few ▁ Kaprekar ▁ Numbers " " ▁ using ▁ iskaprekar ( ) STRNEWLINE " ; for ( int i = 1 ; i < 10000 ; i ++ ) if ( iskaprekar ( i ) ) cout << i << " ▁ " ; return 0 ; }
bool isKeith ( int x ) {
vector < int > terms ;
while ( temp > 0 ) { terms . push_back ( temp % 10 ) ; temp = temp / 10 ; n ++ ; }
reverse ( terms . begin ( ) , terms . end ( ) ) ;
int next_term = 0 , i = n ; while ( next_term < x ) { next_term = 0 ;
for ( int j = 1 ; j <= n ; j ++ ) next_term += terms [ i - j ] ; terms . push_back ( next_term ) ; i ++ ; }
return ( next_term == x ) ; }
int main ( ) { isKeith ( 14 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isKeith ( 12 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isKeith ( 197 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
bool canBeSumofConsec ( unsigned int n ) {
return ( ( n & ( n - 1 ) ) && n ) ; }
int main ( ) { unsigned int n = 15 ; canBeSumofConsec ( n ) ? cout << " true " : cout << " false " ; return 0 ; }
int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ;
long long int ef1 = 0 , ef2 = 2 ; long long int sum = ef1 + ef2 ;
while ( ef2 <= limit ) {
long long int ef3 = 4 * ef2 + ef1 ;
if ( ef3 > limit ) break ;
ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; }
int main ( ) { int limit = 400 ; cout << evenFibSum ( limit ) ; return 0 ; }
bool isPerfect ( int n ) { int s = sqrt ( n ) ; return ( s * s == n ) ; }
int divisorsCount ( int n ) {
int count = 0 ; for ( int i = 1 ; i <= sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) {
if ( n / i == i ) count += 1 ;
else count += 2 ; } } return count ; }
int kDivisors ( int a , int b , int k ) {
for ( int i = a ; i <= b ; i ++ ) {
if ( isPerfect ( i ) )
if ( divisors ( i ) == k ) count ++ ; } return count ; }
int main ( ) { int a = 2 , b = 49 , k = 3 ; cout << kDivisors ( a , b , k ) ; return 0 ; }
long int evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ;
return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; }
int main ( ) { int n = 7 ; cout << evenFib ( n ) ; return 0 ; }
const int MAX = 3000 ;
int smartNumber ( int n ) {
int primes [ MAX ] = { 0 } ;
vector < int > result ;
for ( int i = 2 ; i < MAX ; i ++ ) {
if ( primes [ i ] == 0 ) { primes [ i ] = 1 ;
for ( int j = i * 2 ; j < MAX ; j = j + i ) { primes [ j ] -= 1 ;
if ( ( primes [ j ] + 3 ) == 0 ) result . push_back ( j ) ; } } }
sort ( result . begin ( ) , result . end ( ) ) ;
return result [ n - 1 ] ; }
int main ( ) { int n = 50 ; cout << smartNumber ( n ) ; return 0 ; }
int countSteps ( int x , int y ) {
if ( x % y == 0 ) return x / y ;
return x / y + countSteps ( y , x % y ) ; }
int main ( ) { int x = 100 , y = 19 ; cout << countSteps ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; typedef long long ll ; int findCountOfSolutions ( int n , int p ) {
ll ans = 0 ;
for ( ll x = 1 ; x < p ; x ++ ) {
if ( ( x * x ) % p == 1 ) {
ll last = x + p * ( n / p ) ; if ( last > n ) last -= p ;
ans += ( ( last - x ) / p + 1 ) ; } } return ans ; }
int main ( ) { ll n = 10 , p = 5 ; printf ( " % lld STRNEWLINE " , findCountOfSolutions ( n , p ) ) ; return 0 ; }
int kaprekarRec ( int n , int & prev ) { if ( n == 0 ) return 0 ;
prev = n ;
int digits [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { digits [ i ] = n % 10 ; n = n / 10 ; }
sort ( digits , digits + 4 ) ; int asc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) asc = asc * 10 + digits [ i ] ;
sort ( digits , digits + 4 , std :: greater < int > ( ) ) ; int desc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) desc = desc * 10 + digits [ i ] ;
int diff = abs ( asc - desc ) ;
if ( diff == prev ) return diff ;
return kaprekarRec ( diff , prev ) ; }
int kaprekar ( int n ) { int prev = 0 ; return kaprekarRec ( n , prev ) ; }
cout << kaprekar ( 1000 ) << endl ; cout << kaprekar ( 1112 ) << endl ; cout << kaprekar ( 9812 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE float sqroot ( float s ) {
int pSq = 0 ;
int N = 0 ;
for ( int i = static_cast < int > ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; }
float d = s - pSq ;
float P = d / ( 2.0 * N ) ;
float A = N + P ;
float sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; }
int main ( ) { float num = 9.2345 ; float sqroot_of_num = sqroot ( num ) ; std :: cout << " Square ▁ root ▁ of ▁ " << num << " ▁ = ▁ " << sqroot_of_num ; return 0 ; }
int power ( int x , int a ) { int res = 1 ; while ( a ) { if ( a & 1 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; }
int breakInteger ( int N ) {
if ( N == 2 ) return 1 ;
if ( N == 3 ) return 2 ; int maxProduct ;
switch ( N % 3 ) {
case 0 : maxProduct = power ( 3 , N / 3 ) ; break ;
case 1 : maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; break ;
case 2 : maxProduct = 2 * power ( 3 , N / 3 ) ; break ; } return maxProduct ; }
int main ( ) { int maxProduct = breakInteger ( 10 ) ; cout << maxProduct << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digSum ( int n ) { int sum = 0 ;
while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; }
int main ( ) { int n = 1234 ; cout << digSum ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } int main ( ) { int n = 9999 ; cout << digSum ( n ) ; return 0 ; }
int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; }
int main ( ) { cout << " Count ▁ = ▁ " << countMultiples ( 25 ) ; }
int Modulo ( int a , char b [ ] ) {
int mod = 0 ;
for ( int i = 0 ; i < strlen ( b ) ; i ++ ) mod = ( mod * 10 + b [ i ] - '0' ) % a ;
}
int LastDigit ( char a [ ] , char b [ ] ) { int len_a = strlen ( a ) , len_b = strlen ( b ) ;
if ( len_a == 1 && len_b == 1 && b [ 0 ] == '0' && a [ 0 ] == '0' ) return 1 ;
if ( len_b == 1 && b [ 0 ] == '0' ) return 1 ;
if ( len_a == 1 && a [ 0 ] == '0' ) return 0 ;
int exp = ( Modulo ( 4 , b ) == 0 ) ? 4 : Modulo ( 4 , b ) ;
int res = pow ( a [ len_a - 1 ] - '0' , exp ) ;
return res % 10 ; }
int main ( ) { char a [ ] = "117" , b [ ] = "3" ; cout << LastDigit ( a , b ) ; return 0 ; }
long long reversDigits ( long long num ) { long long rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; }
bool isPalindrome ( long long num ) { return ( reversDigits ( num ) == num ) ; }
void ReverseandAdd ( long long num ) { long long rev_num = 0 ; while ( num <= 4294967295 ) {
rev_num = reversDigits ( num ) ;
num = num + rev_num ;
if ( isPalindrome ( num ) ) { printf ( " % lld STRNEWLINE " , num ) ; break ; } else if ( num > 4294967295 ) { printf ( " No ▁ palindrome ▁ exist " ) ; } } }
int main ( ) { ReverseandAdd ( 195 ) ; ReverseandAdd ( 265 ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == b ) return a ;
if ( a == 0 ) return b ; if ( b == 0 ) return a ;
{
return gcd ( a >> 1 , b ) ;
return gcd ( a >> 1 , b >> 1 ) << 1 ; }
return gcd ( a , b >> 1 ) ;
if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; }
int main ( ) { int a = 34 , b = 17 ; printf ( " Gcd ▁ of ▁ given ▁ numbers ▁ is ▁ % d STRNEWLINE " , gcd ( a , b ) ) ; return 0 ; }
void findNDigitNumsUtil ( int n , int sum , char * out , int index ) {
if ( index > n sum < 0 ) return ;
if ( index == n ) {
if ( sum == 0 ) { out [ index ] = ' \0' ; cout << out << " ▁ " ; } return ; }
for ( int i = 0 ; i <= 9 ; i ++ ) {
out [ index ] = i + '0' ;
findNDigitNumsUtil ( n , sum - i , out , index + 1 ) ; } }
void findNDigitNums ( int n , int sum ) {
char out [ n + 1 ] ;
for ( int i = 1 ; i <= 9 ; i ++ ) { out [ 0 ] = i + '0' ; findNDigitNumsUtil ( n , sum - i , out , 1 ) ; } }
int main ( ) { int n = 2 , sum = 3 ; findNDigitNums ( n , sum ) ; return 0 ; }
int oneDigit ( int num ) {
return ( num >= 0 && num < 10 ) ; }
bool isPalUtil ( int num , int * dupNum ) {
if ( oneDigit ( num ) ) return ( num == ( * dupNum ) % 10 ) ;
if ( ! isPalUtil ( num / 10 , dupNum ) ) return false ;
* dupNum /= 10 ;
return ( num % 10 == ( * dupNum ) % 10 ) ; }
int isPal ( int num ) {
if ( num < 0 ) num = - num ;
return isPalUtil ( num , dupNum ) ; }
void printPalPrimesLessThanN ( int n ) {
bool prime [ n + 1 ] ; memset ( prime , true , sizeof ( prime ) ) ; for ( int p = 2 ; p * p <= n ; p ++ ) {
if ( prime [ p ] == true ) {
for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } }
for ( int p = 2 ; p <= n ; p ++ )
if ( prime [ p ] && isPal ( p ) ) cout << p << " ▁ " ; }
int main ( ) { int n = 100 ; printf ( " Palindromic ▁ primes ▁ smaller ▁ than ▁ or ▁ " " equal ▁ to ▁ % d ▁ are ▁ : STRNEWLINE " , n ) ; printPalPrimesLessThanN ( n ) ; }
int countPrimeFactors ( int n ) { int count = 0 ;
while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; }
for ( int i = 3 ; i <= sqrt ( n ) ; i = i + 2 ) {
while ( n % i == 0 ) { n = n / i ; count ++ ; } }
if ( n > 2 ) count ++ ; return ( count ) ; }
void printKAlmostPrimes ( int k , int n ) { for ( int i = 1 , num = 2 ; i <= n ; num ++ ) {
if ( countPrimeFactors ( num ) == k ) { printf ( " % d ▁ " , num ) ;
i ++ ; } } return ; }
int main ( ) { int n = 10 , k = 2 ; printf ( " First ▁ % d ▁ % d - almost ▁ prime ▁ numbers ▁ : ▁ STRNEWLINE " , n , k ) ; printKAlmostPrimes ( k , n ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
void lowest ( int & den3 , int & num3 ) {
int common_factor = gcd ( num3 , den3 ) ;
den3 = den3 / common_factor ; num3 = num3 / common_factor ; }
void addFraction ( int num1 , int den1 , int num2 , int den2 , int & num3 , int & den3 ) {
den3 = gcd ( den1 , den2 ) ;
den3 = ( den1 * den2 ) / den3 ;
num3 = ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ;
lowest ( den3 , num3 ) ; }
int main ( ) { int num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 , den3 , num3 ; addFraction ( num1 , den1 , num2 , den2 , num3 , den3 ) ; printf ( " % d / % d ▁ + ▁ % d / % d ▁ is ▁ equal ▁ to ▁ % d / % d STRNEWLINE " , num1 , den1 , num2 , den2 , num3 , den3 ) ; return 0 ; }
int findPieces ( int n ) {
return ( n * ( n + 1 ) ) / 2 + 1 ; }
int main ( ) { cout << findPieces ( 1 ) << endl ; cout << findPieces ( 2 ) << endl ; cout << findPieces ( 3 ) << endl ; cout << findPieces ( 50 ) << endl ; return 0 ; }
long long findDigits ( int n ) {
if ( n < 0 ) return 0 ;
if ( n <= 1 ) return 1 ;
double x = ( ( n * log10 ( n / M_E ) + log10 ( 2 * M_PI * n ) / 2.0 ) ) ; return floor ( x ) + 1 ; }
int main ( ) { cout << findDigits ( 1 ) << endl ; cout << findDigits ( 50000000 ) << endl ; cout << findDigits ( 1000000000 ) << endl ; cout << findDigits ( 120 ) << endl ; return 0 ; }
int findDigits ( int n ) {
if ( n < 0 ) return 0 ;
if ( n <= 1 ) return 1 ;
double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += log10 ( i ) ; return floor ( digits ) + 1 ; }
int main ( ) { cout << findDigits ( 1 ) << endl ; cout << findDigits ( 5 ) << endl ; cout << findDigits ( 10 ) << endl ; cout << findDigits ( 120 ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countEvenSum ( int arr [ ] , int n ) { int result = 0 ;
for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ even " " ▁ sum ▁ is ▁ " << countEvenSum ( arr , n ) ; return ( 0 ) ; }
#include <iostream> NEW_LINE using namespace std ; int countEvenSum ( int arr [ ] , int n ) {
int temp [ 2 ] = { 1 , 0 } ;
int result = 0 , sum = 0 ;
for ( int i = 0 ; i <= n - 1 ; i ++ ) {
sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 ;
temp [ sum ] ++ ; }
result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) / 2 ) ; result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) / 2 ) ; return ( result ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ even " " ▁ sum ▁ is ▁ " << countEvenSum ( arr , n ) ; return ( 0 ) ; }
int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int fibo [ n + 1 ] ; fibo [ 0 ] = 0 , fibo [ 1 ] = 1 ;
int sum = fibo [ 0 ] + fibo [ 1 ] ;
for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; }
int main ( ) { int n = 4 ; cout << " Sum ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " << calculateSum ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX = 1000 ;
int f [ MAX ] = { 0 } ;
int fib ( int n ) {
if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ;
if ( f [ n ] ) return f [ n ] ; int k = ( n & 1 ) ? ( n + 1 ) / 2 : n / 2 ;
f [ n ] = ( n & 1 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; }
int calculateSum ( int n ) { return fib ( n + 2 ) - 1 ; }
int main ( ) { int n = 4 ; cout << " Sum ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " << calculateSum ( n ) << endl ; return 0 ; }
void findCombinationsUtil ( int arr [ ] , int index , int num , int reducedNum ) {
if ( reducedNum < 0 ) return ;
if ( reducedNum == 0 ) { for ( int i = 0 ; i < index ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; return ; }
int prev = ( index == 0 ) ? 1 : arr [ index - 1 ] ;
for ( int k = prev ; k <= num ; k ++ ) {
arr [ index ] = k ;
findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ; } }
void findCombinations ( int n ) {
int arr [ n ] ;
findCombinationsUtil ( arr , 0 , n , n ) ; }
int main ( ) { int n = 5 ; findCombinations ( n ) ; return 0 ; }
int pow ( int base , int exponent , int modulus ) { int result = 1 ; base = base % modulus ; while ( exponent > 0 ) { if ( exponent % 2 == 1 ) result = ( result * base ) % modulus ; exponent = exponent >> 1 ; base = ( base * base ) % modulus ; } return result ; }
int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; }
int order ( int p , int b ) { if ( gcd ( p , b ) != 1 ) { printf ( " p ▁ and ▁ b ▁ are ▁ not ▁ co - prime . STRNEWLINE " ) ; return -1 ; }
int k = 3 ; while ( 1 ) { if ( pow ( b , k , p ) == 1 ) return k ; k ++ ; } }
int convertx2e ( int x , int & e ) { e = 0 ; while ( x % 2 == 0 ) { x /= 2 ; e ++ ; } return x ; }
int STonelli ( int n , int p ) {
if ( gcd ( n , p ) != 1 ) { printf ( " a ▁ and ▁ p ▁ are ▁ not ▁ coprime STRNEWLINE " ) ; return -1 ; }
if ( pow ( n , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) { printf ( " no ▁ sqrt ▁ possible STRNEWLINE " ) ; return -1 ; }
int s , e ; s = convertx2e ( p - 1 , e ) ;
int q ; for ( q = 2 ; ; q ++ ) {
if ( pow ( q , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) break ; }
int x = pow ( n , ( s + 1 ) / 2 , p ) ; int b = pow ( n , s , p ) ; int g = pow ( q , s , p ) ; int r = e ;
while ( 1 ) { int m ; for ( m = 0 ; m < r ; m ++ ) { if ( order ( p , b ) == -1 ) return -1 ;
if ( order ( p , b ) == pow ( 2 , m ) ) break ; } if ( m == 0 ) return x ;
x = ( x * pow ( g , pow ( 2 , r - m - 1 ) , p ) ) % p ; g = pow ( g , pow ( 2 , r - m ) , p ) ; b = ( b * g ) % p ; if ( b == 1 ) return x ; r = m ; } }
int main ( ) { int n = 2 ;
int p = 113 ; int x = STonelli ( n , p ) ; if ( x == -1 ) printf ( " Modular ▁ square ▁ root ▁ is ▁ not ▁ exist STRNEWLINE " ) ; else printf ( " Modular ▁ square ▁ root ▁ of ▁ % d ▁ and ▁ % d ▁ is ▁ % d STRNEWLINE " , n , p , x ) ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE using namespace std ; bool isPower ( int x , int y ) {
int res1 = log ( y ) / log ( x ) ;
return ( res1 == res2 ) ; }
int main ( ) { cout << isPower ( 27 , 729 ) << endl ; return 0 ; }
void findRoots ( int a , int b , int c ) {
if ( a == 0 ) { cout << " Invalid " ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { cout << " Roots ▁ are ▁ real ▁ and ▁ different ▁ STRNEWLINE " ; cout << ( double ) ( - b + sqrt_val ) / ( 2 * a ) << " STRNEWLINE " << ( double ) ( - b - sqrt_val ) / ( 2 * a ) ; } else if ( d == 0 ) { cout << " Roots ▁ are ▁ real ▁ and ▁ same ▁ STRNEWLINE " ; cout << - ( double ) b / ( 2 * a ) ; }
{ cout << " Roots ▁ are ▁ complex ▁ STRNEWLINE " ; cout << - ( double ) b / ( 2 * a ) << " ▁ + ▁ i " << sqrt_val << " STRNEWLINE " << - ( double ) b / ( 2 * a ) << " ▁ - ▁ i " << sqrt_val ; } }
int main ( ) { int a = 1 , b = -7 , c = 12 ;
findRoots ( a , b , c ) ; return 0 ; }
bool isPerfectSquare ( int n ) {
for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; }
int main ( ) { isPerfectSquare ( 35 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isPerfectSquare ( 49 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
int findCount ( int d ) { return 9 * ( pow ( 10 , d - 1 ) - pow ( 9 , d - 1 ) ) ; }
int main ( ) { int d = 1 ; cout << findCount ( d ) << endl ; d = 2 ; cout << findCount ( d ) << endl ; d = 4 ; cout << findCount ( d ) << endl ; return 0 ; }
int countDyckPaths ( unsigned int n ) {
int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; }
return res / ( n + 1 ) ; }
int main ( ) { int n = 4 ; cout << " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " << countDyckPaths ( n ) ; return 0 ; }
bool isTriangular ( int num ) {
if ( num < 0 ) return false ;
int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; }
int main ( ) { int n = 55 ; if ( isTriangular ( n ) ) cout << " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ; else cout << " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ; return 0 ; }
bool isTriangular ( int num ) { if ( num < 0 ) return false ;
int c = ( -2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ;
float root1 = ( - b + sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - sqrt ( d ) ) / ( 2 * a ) ;
if ( root1 > 0 && floor ( root1 ) == root1 ) return true ;
if ( root2 > 0 && floor ( root2 ) == root2 ) return true ; return false ; }
int main ( ) { int num = 55 ; if ( isTriangular ( num ) ) cout << " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ; else cout << " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ; return 0 ; }
int gcd ( int a , int b ) { int c ; while ( a != 0 ) { c = a ; a = b % a ; b = c ; } return b ; }
void forbenius ( int X , int Y ) {
if ( gcd ( X , Y ) != 1 ) { cout << " NA STRNEWLINE " ; return ; }
int A = ( X * Y ) - ( X + Y ) ; int N = ( X - 1 ) * ( Y - 1 ) / 2 ; cout << " Largest ▁ Amount ▁ = ▁ " << A << endl ; cout << " Total ▁ Count ▁ = ▁ " << N << endl ; }
int main ( ) { int X = 2 , Y = 5 ; forbenius ( X , Y ) ; X = 5 , Y = 10 ; cout << endl ; forbenius ( X , Y ) ; return 0 ; }
char xor_c ( char a , char b ) { return ( a == b ) ? '0' : '1' ; }
char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; }
string binarytoGray ( string binary ) { string gray = " " ;
gray += binary [ 0 ] ;
for ( int i = 1 ; i < binary . length ( ) ; i ++ ) {
gray += xor_c ( binary [ i - 1 ] , binary [ i ] ) ; } return gray ; }
string graytoBinary ( string gray ) { string binary = " " ;
binary += gray [ 0 ] ;
for ( int i = 1 ; i < gray . length ( ) ; i ++ ) {
if ( gray [ i ] == '0' ) binary += binary [ i - 1 ] ;
else binary += flip ( binary [ i - 1 ] ) ; } return binary ; }
int main ( ) { string binary = "01001" ; cout << " Gray ▁ code ▁ of ▁ " << binary << " ▁ is ▁ " << binarytoGray ( binary ) << endl ; string gray = "01101" ; cout << " Binary ▁ code ▁ of ▁ " << gray << " ▁ is ▁ " << graytoBinary ( gray ) << endl ; return 0 ; }
int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ;
if ( current == N + 1 ) return 0 ;
for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ;
return cur + seriesSum ( i , current + 1 , N ) ; }
int N = 5 ;
cout << seriesSum ( 1 , 1 , N ) << endl ; return 0 ; }
int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; }
int main ( ) { int n = 25 , p = 29 ; cout << modFact ( n , p ) ; return 0 ; }
int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ;
while ( a > 1 ) {
q = a / m ; t = m ;
m = a % m , a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; }
if ( x1 < 0 ) x1 += m0 ; return x1 ; }
int findMinX ( int num [ ] , int rem [ ] , int k ) {
int prod = 1 ; for ( int i = 0 ; i < k ; i ++ ) prod *= num [ i ] ;
int result = 0 ;
for ( int i = 0 ; i < k ; i ++ ) { int pp = prod / num [ i ] ; result += rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; }
int main ( void ) { int num [ ] = { 3 , 4 , 5 } ; int rem [ ] = { 2 , 3 , 1 } ; int k = sizeof ( num ) / sizeof ( num [ 0 ] ) ; cout << " x ▁ is ▁ " << findMinX ( num , rem , k ) ; return 0 ; }
int findMinX ( int num [ ] , int rem [ ] , int k ) {
while ( true ) {
int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ;
if ( j == k ) return x ;
x ++ ; } return x ; }
int main ( void ) { int num [ ] = { 3 , 4 , 5 } ; int rem [ ] = { 2 , 3 , 1 } ; int k = sizeof ( num ) / sizeof ( num [ 0 ] ) ; cout << " x ▁ is ▁ " << findMinX ( num , rem , k ) ; return 0 ; }
int nCrModpDP ( int n , int r , int p ) {
int C [ r + 1 ] ; memset ( C , 0 , sizeof ( C ) ) ;
for ( int i = 1 ; i <= n ; i ++ ) {
for ( int j = min ( i , r ) ; j > 0 ; j -- )
C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; }
int nCrModpLucas ( int n , int r , int p ) {
if ( r == 0 ) return 1 ;
int ni = n % p , ri = r % p ;
}
int main ( ) { int n = 1000 , r = 900 , p = 13 ; cout << " Value ▁ of ▁ nCr ▁ % ▁ p ▁ is ▁ " << nCrModpLucas ( n , r , p ) ; return 0 ; }
bool isValid ( int n , int d ) {
int digit = n % 10 ; int sum = digit ;
if ( digit == d ) return false ;
n /= 10 ; while ( n ) {
digit = n % 10 ;
if ( digit == d digit <= sum ) return false ;
else { sum += digit ; n /= 10 ; } } return 1 ; }
void printGoodNumbers ( int L , int R , int d ) {
for ( int i = L ; i <= R ; i ++ ) {
if ( isValid ( i , d ) ) cout << i << " ▁ " ; } }
int main ( ) { int L = 410 , R = 520 , d = 3 ;
printGoodNumbers ( L , R , d ) ; return 0 ; }
int nearestSmallerEqFib ( int n ) {
if ( n == 0 n == 1 ) return n ;
int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; }
void printFibRepresntation ( int n ) { while ( n > 0 ) {
int f = nearestSmallerEqFib ( n ) ;
cout << f << " ▁ " ;
n = n - f ; } }
int main ( ) { int n = 30 ; cout << " Non - neighbouring ▁ Fibonacci ▁ Representation ▁ of ▁ " << n << " ▁ is ▁ STRNEWLINE " ; printFibRepresntation ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int dp [ 5001 ] [ 5001 ] [ 5 ] ;
int countWaysUtil ( int n , int parts , int nextPart ) {
if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 parts <= 0 ) return 0 ;
if ( dp [ n ] [ nextPart ] [ parts ] != -1 ) return dp [ n ] [ nextPart ] [ parts ] ;
for ( int i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ;
return ( dp [ n ] [ nextPart ] [ parts ] = ans ) ; }
int countWays ( int n ) { memset ( dp , -1 , sizeof ( dp ) ) ; return countWaysUtil ( n , 4 , 1 ) ; }
int main ( ) { int n = 8 ; cout << countWays ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printTwins ( int low , int high ) {
bool prime [ high + 1 ] , twin = false ; memset ( prime , true , sizeof ( prime ) ) ; prime [ 0 ] = prime [ 1 ] = false ;
for ( int p = 2 ; p <= floor ( sqrt ( high ) ) + 1 ; p ++ ) {
if ( prime [ p ] ) {
for ( int i = p * 2 ; i <= high ; i += p ) prime [ i ] = false ; } }
for ( int i = low ; i <= high ; i ++ ) { if ( prime [ i ] && prime [ i + 2 ] ) { cout << " Smallest ▁ twins ▁ in ▁ given ▁ range : ▁ ( " << i << " , ▁ " << i + 2 << " ) " ; twin = true ; break ; } } if ( twin == false ) cout << " No ▁ such ▁ pair ▁ exists " << endl ; }
int main ( ) { printTwins ( 10 , 100 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int nextSparse ( int x ) {
vector < bool > bin ; while ( x != 0 ) { bin . push_back ( x & 1 ) ; x >>= 1 ; }
bin . push_back ( 0 ) ;
int last_final = 0 ;
for ( int i = 1 ; i < n - 1 ; i ++ ) {
if ( bin [ i ] == 1 && bin [ i - 1 ] == 1 && bin [ i + 1 ] != 1 ) {
bin [ i + 1 ] = 1 ;
for ( int j = i ; j >= last_final ; j -- ) bin [ j ] = 0 ;
last_final = i + 1 ; } }
int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += bin [ i ] * ( 1 << i ) ; return ans ; }
int main ( ) { int x = 38 ; cout << " Next ▁ Sparse ▁ Number ▁ is ▁ " << nextSparse ( x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int sumBitDifferences ( int arr [ ] , int n ) {
for ( int i = 0 ; i < 32 ; i ++ ) {
int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ;
ans += ( count * ( n - count ) * 2 ) ; } return ans ; }
int main ( ) { int arr [ ] = { 1 , 3 , 5 } ; int n = sizeof arr / sizeof arr [ 0 ] ; cout << sumBitDifferences ( arr , n ) << endl ; return 0 ; }
void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; }
void generateUtil ( int x , int arr [ ] , int curr_sum , int curr_idx ) {
if ( curr_sum == x ) { printArr ( arr , curr_idx ) ; return ; }
int num = 1 ;
while ( num <= x - curr_sum && ( curr_idx == 0 num <= arr [ curr_idx - 1 ] ) ) {
arr [ curr_idx ] = num ;
generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) ;
num ++ ; } }
void generate ( int x ) {
int arr [ x ] ; generateUtil ( x , arr , 0 , 0 ) ; }
int main ( ) { int x = 5 ; generate ( x ) ; return 0 ; }
bool isPerfect ( long long int n ) {
long long int sum = 1 ;
for ( long long int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } }
if ( sum == n && n != 1 ) return true ; return false ; }
int main ( ) { cout << " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000 STRNEWLINE " ; for ( int n = 2 ; n < 10000 ; n ++ ) if ( isPerfect ( n ) ) cout << n << " ▁ is ▁ a ▁ perfect ▁ number STRNEWLINE " ; return 0 ; }
bool checkUtil ( int num , int dig , int base ) {
if ( dig == 1 && num < base ) return true ;
if ( dig > 1 && num >= base ) return checkUtil ( num / base , -- dig , base ) ; return false ; }
bool check ( int num , int dig ) {
for ( int base = 2 ; base <= 32 ; base ++ ) if ( checkUtil ( num , dig , base ) ) return true ; return false ; }
int main ( ) { int num = 8 ; int dig = 3 ; ( check ( num , dig ) ) ? cout << " Yes " : cout << " No " ; return 0 ; }
int mod ( string num , int a ) {
int res = 0 ;
for ( int i = 0 ; i < num . length ( ) ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; }
int main ( ) { string num = "12316767678678" ; cout << mod ( num , 10 ) ; return 0 ; }
int modInverse ( int a , int m ) { for ( int x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; }
int main ( ) { int a = 3 , m = 11 ;
cout << modInverse ( a , m ) ; return 0 ; }
int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) {
int q = a / m ; int t = m ;
m = a % m , a = t ; t = y ;
y = x - q * y ; x = t ; }
if ( x < 0 ) x += m0 ; return x ; }
int main ( ) { int a = 3 , m = 11 ;
cout << " Modular ▁ multiplicative ▁ inverse ▁ is ▁ " << modInverse ( a , m ) ; return 0 ; }
int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; }
int phi ( unsigned int n ) { unsigned int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; }
int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) cout << " phi ( " << n << " ) ▁ = ▁ " << phi ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int phi ( int n ) {
float result = n ;
for ( int p = 2 ; p * p <= n ; ++ p ) {
if ( n % p == 0 ) {
while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / ( float ) p ) ) ; } }
if ( n > 1 ) result *= ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; }
int main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) { cout << " Phi " << " ( " << n << " ) " << " ▁ = ▁ " << phi ( n ) << endl ; } return 0 ; }
int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
double sum ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / factorial ( i ) ; return sum ; }
int main ( ) { int n = 5 ; cout << sum ( n ) ; return 0 ; }
unsigned long int binomialCoeff ( unsigned int n , unsigned int k ) { unsigned long int res = 1 ;
if ( k > n - k ) k = n - k ;
for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; }
unsigned long int catalan ( unsigned int n ) {
unsigned long int c = binomialCoeff ( 2 * n , n ) ;
return c / ( n + 1 ) ; }
unsigned long int findWays ( unsigned n ) {
if ( n & 1 ) return 0 ;
return catalan ( n / 2 ) ; }
int main ( ) { int n = 6 ; cout << " Total ▁ possible ▁ expressions ▁ of ▁ length ▁ " << n << " ▁ is ▁ " << findWays ( 6 ) ; return 0 ; }
bool isOperand ( char c ) { return ( c >= '0' && c <= '9' ) ; }
int value ( char c ) { return ( c - '0' ) ; }
int evaluate ( char * exp ) {
if ( * exp == ' \0' ) return -1 ;
int res = value ( exp [ 0 ] ) ;
for ( int i = 1 ; exp [ i ] ; i += 2 ) {
char opr = exp [ i ] , opd = exp [ i + 1 ] ;
if ( ! isOperand ( opd ) ) return -1 ;
if ( opr == ' + ' ) res += value ( opd ) ; else if ( opr == ' - ' ) res -= value ( opd ) ; else if ( opr == ' * ' ) res *= value ( opd ) ; else if ( opr == ' / ' ) res /= value ( opd ) ;
elsereturn - 1 ; } return res ; }
int main ( ) { char expr1 [ ] = "1 + 2*5 + 3" ; int res = evaluate ( expr1 ) ; ( res == -1 ) ? cout << expr1 << " ▁ is ▁ " << " Invalid STRNEWLINE " : cout << " Value ▁ of ▁ " << expr1 << " ▁ is ▁ " << res << endl ; char expr2 [ ] = "1 + 2*3" ; res = evaluate ( expr2 ) ; ( res == -1 ) ? cout << expr2 << " ▁ is ▁ " << " Invalid STRNEWLINE " : cout << " Value ▁ of ▁ " << expr2 << " ▁ is ▁ " << res << endl ; char expr3 [ ] = "4-2 + 6*3" ; res = evaluate ( expr3 ) ; ( res == -1 ) ? cout << expr3 << " ▁ is ▁ " << " Invalid STRNEWLINE " : cout << " Value ▁ of ▁ " << expr3 << " ▁ is ▁ " << res << endl ; char expr4 [ ] = "1 + + 2" ; res = evaluate ( expr4 ) ; ( res == -1 ) ? cout << expr4 << " ▁ is ▁ " << " Invalid STRNEWLINE " : cout << " Value ▁ of ▁ " << expr4 << " ▁ is ▁ " << res << endl ; return 0 ; }
void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; cout << f1 << " ▁ " ; for ( i = 1 ; i < n ; i ++ ) { cout << f2 << " ▁ " ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } }
int main ( ) { printFibonacciNumbers ( 7 ) ; return 0 ; }
long long gcd ( long long int a , long long int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }
long long lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; }
int main ( ) { int a = 15 , b = 20 ; cout << " LCM ▁ of ▁ " << a << " ▁ and ▁ " << b << " ▁ is ▁ " << lcm ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; # define MAX  11 NEW_LINE bool isMultipleof5 ( int n ) { char str [ MAX ] ; int len = strlen ( str ) ;
if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; }
int main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) cout << n << " ▁ is ▁ multiple ▁ of ▁ 5" << endl ; else cout << n << " ▁ is ▁ not ▁ multiple ▁ of ▁ 5" << endl ; return 0 ; }
int pairORSum ( int arr [ ] , int n ) {
for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << pairORSum ( arr , n ) << endl ; return 0 ; }
long multiplyByFifteen ( long n ) {
long prod = ( n << 4 ) ;
prod = prod - n ; return prod ; }
int main ( ) { long n = 7 ; cout << multiplyByFifteen ( n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void minAND ( int arr [ ] , int n ) { int s = arr [ 0 ] ;
for ( int i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; }
cout << ( s ) << endl ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( int ) ; minAND ( arr , n ) ; }
bool check ( int a [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; }
int main ( ) { int a [ ] = { 0 , 1 , 0 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; check ( a , n ) ? cout << " YES STRNEWLINE " : cout << " NO STRNEWLINE " ; return 0 ; }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
void findArray ( int q [ ] , int n ) { int arr [ n ] , ans ; for ( int k = 0 , j = 0 ; j < n / 4 ; j ++ ) { ans = q [ k ] ^ q [ k + 3 ] ; arr [ k + 1 ] = q [ k + 1 ] ^ ans ; arr [ k + 2 ] = q [ k + 2 ] ^ ans ; arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) ; arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) ; k += 4 ; }
printArray ( arr , n ) ; }
int main ( ) { int q [ ] = { 4 , 1 , 7 , 0 } ; int n = sizeof ( q ) / sizeof ( q [ 0 ] ) ; findArray ( q , n ) ; return 0 ; }
bool isEqualBlock ( int n ) {
int first_bit = n % 2 ; int first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; }
if ( n == 0 ) return false ;
while ( n > 0 ) { int first_bit = n % 2 ; int curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; }
int main ( ) { int n = 51 ; if ( isEqualBlock ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
void binToDecimal3 ( int n ) {
int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ;
n = n >> 3 ; while ( n > 7 ) n = n >> 1 ;
int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ;
cout << first_3 << " ▁ " << last_3 ; }
int main ( ) { int n = 86 ; binToDecimal3 ( n ) ; return 0 ; }
bool isPowerOfTwo ( int x ) { if ( x == 0 ) return false ;
if ( ! ( x & ( x - 1 ) ) ) return true ; else return false ; }
int countNum ( int a [ ] , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( isPowerOfTwo ( a [ i ] ) || isPowerOfTwo ( a [ i ] + 1 ) ) count ++ ; } return count ; }
int main ( ) { int arr [ ] = { 5 , 6 , 9 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countNum ( arr , n ) ; return 0 ; }
bool checkEvenParity ( int x ) {
int parity = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; parity ++ ; } if ( parity % 2 == 0 ) return true ; else return false ; }
long sumlist ( int a [ ] , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( checkEvenParity ( a [ i ] ) ) sum += a [ i ] ; } return sum ; }
int main ( ) { int arr [ ] = { 2 , 4 , 3 , 5 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << sumlist ( arr , n ) ; return 0 ; }
int findOddPair ( int A [ ] , int N ) { int oddPair = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) {
if ( ( A [ i ] A [ j ] ) % 2 != 0 ) oddPair ++ ; } }
return oddPair ; }
int main ( ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << findOddPair ( A , N ) << endl ; return 0 ; }
int findevenPair ( int A [ ] , int N ) { int i , j ;
int evenPair = 0 ;
for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) {
if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) evenPair ++ ; } }
return evenPair ; }
int main ( ) { int A [ ] = { 5 , 4 , 7 , 2 , 1 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ;
cout << findevenPair ( A , N ) << endl ; return 0 ; }
int findEvenPair ( int A [ ] , int N ) { int count = 0 ;
for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 != 0 ) count ++ ; } int totalPairs = ( N * ( N - 1 ) / 2 ) ; int oddEvenPairs = count * ( N - count ) ;
return totalPairs - oddEvenPairs ; }
int main ( ) { int a [ ] = { 5 , 4 , 7 , 2 , 1 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
cout << findEvenPair ( a , n ) << endl ; return 0 ; }
int findevenPair ( int A [ ] , int N ) { int i , j ;
int evenPair = 0 ;
for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) {
if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } }
return evenPair ; }
int main ( ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findevenPair ( a , n ) << endl ; return 0 ; }
int findevenPair ( int A [ ] , int N ) { int count = 0 ;
for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ;
int oddCount = count * ( count - 1 ) / 2 ;
return ( N * ( N - 1 ) / 2 ) - oddCount ; }
int main ( ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << findevenPair ( a , n ) << endl ; return 0 ; }
int calculate ( int X ) {
int number_of_bits = 8 ;
return ( ( 1 << number_of_bits ) - 1 ) ^ X ; }
int main ( ) { int X = 4 ; cout << " Required ▁ Number ▁ is ▁ : ▁ " << calculate ( X ) << endl ; return 0 ; }
void ReplaceElements ( int arr [ ] , int n ) { int X = 0 ;
for ( int i = 0 ; i < n ; ++ i ) { X ^= arr [ i ] ; }
for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = X ^ arr [ i ] ; } }
int main ( ) { int arr [ ] = { 2 , 3 , 3 , 5 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; ReplaceElements ( arr , n ) ;
for ( int i = 0 ; i < n ; ++ i ) { cout << arr [ i ] << " ▁ " ; } return 0 ; }
void alternate ( int & a , int & b , int & x ) { x = a ^ b ^ x ; }
int main ( ) { int a = -10 ; int b = 15 ; int x = a ; cout << " x ▁ is ▁ : ▁ " << x ; alternate ( a , b , x ) ; cout << " After exchange " cout << " STRNEWLINE x ▁ is ▁ : ▁ " << x ; return 0 ; }
int countZeros ( int x ) { unsigned y ; int n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; }
int main ( ) { int x = 101 ; cout << countZeros ( x ) ; return 0 ; }
void LeadingZeros ( int x , int y ) {
if ( ( x ^ y ) <= ( x & y ) ) cout << " Equal "
else if ( ( x & ( ~ y ) ) > y ) cout << y ; else cout < < x ; }
int main ( ) { int x = 10 , y = 16 ; LeadingZeros ( x , y ) ; return 0 ; }
void solve ( int A , int B ) { int count = 0 ;
for ( int i = 0 ; i < 32 ; i ++ ) {
if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } cout << " Number ▁ of ▁ different ▁ bits ▁ : ▁ " << count << endl ; }
int main ( ) { int A = 12 , B = 15 ;
solve ( A , B ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int setRightmostUnsetBit ( int n ) {
if ( ( n & ( n + 1 ) ) == 0 ) return n ;
return n | ( n + 1 ) ; }
int main ( ) { int n = 21 ; cout << setRightmostUnsetBit ( n ) ; return 0 ; }
int AND ( int a [ ] , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; }
int main ( ) { int a [ ] = { 1 , 2 , 3 } ;
int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
cout << AND ( a , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; string TwoscomplementbyXOR ( string str ) { int n = str . length ( ) ;
bool check_bit = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' && check_bit == 0 ) { continue ; } else {
if ( check_bit == 1 ) str [ i ] = ( str [ i ] - '0' ) ^ 1 + '0' ;
check_bit = 1 ; } }
if ( check_bit == 0 ) return "1" + str ; else return str ; }
int main ( ) { string str = "101" ; cout << TwoscomplementbyXOR ( str ) ; return 0 ; }
bool bitsAreInAltPatrnInGivenTRange ( unsigned int n , unsigned int l , unsigned int r ) { unsigned int num , prev , curr ;
num = n >> ( l - 1 ) ;
prev = num & 1 ;
num = num >> 1 ;
for ( int i = 1 ; i <= ( r - l ) ; i ++ ) {
curr = num & 1 ;
if ( curr == prev ) return false ;
prev = curr ;
num = num >> 1 ; }
return true ; }
int main ( ) { unsigned int n = 18 ; unsigned int l = 1 , r = 3 ; if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int increment ( unsigned int i ) {
i = - ( ~ i ) ; return i ; }
int main ( ) { int n = 3 ; cout << increment ( n ) ; return 0 ; }
int bit_count ( int n ) { int count = 0 ;
while ( n ) { count ++ ; n = n & ( n - 1 ) ; } return count ; }
int maxsum ( int arr [ ] , int n ) { int bits [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) { bits [ i ] = bit_count ( arr [ i ] ) ; }
int sum [ 32 ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) { sum [ bits [ i ] ] += arr [ i ] ; } int maximum = 0 ;
for ( int i = 0 ; i < 32 ; i ++ ) { maximum = max ( sum [ i ] , maximum ) ; } return maximum ; }
int main ( ) { int arr [ ] = { 2 , 3 , 8 , 5 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << maxsum ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int xorPairSum ( int ar [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << xorPairSum ( arr , n ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findEvenPair ( int A [ ] , int N ) {
int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ;
return count * ( count - 1 ) / 2 ; }
int main ( ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << findEvenPair ( A , N ) << endl ; return 0 ; }
bool allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) {
int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ;
int new_num = n & num ;
if ( new_num == 0 ) return true ;
return false ; }
int main ( ) { unsigned int n = 17 ; unsigned int l = 2 , r = 4 ; if ( allBitsSetInTheGivenRange ( n , l , r ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool checkSame ( int n ) { int set = 0 , unset = 0 ;
while ( n ) {
if ( n & 1 ) set ++ ;
else unset ++ ;
n = n >> 1 ; }
if ( set == unset ) return true ; else return false ; }
int main ( ) { int n = 12 ;
if ( checkSame ( n ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
void KthCharacter ( int m , int n , int k ) {
int distance = pow ( 2 , n ) ; int Block_number = k / distance ; int remaining = k % distance ; int s [ 32 ] , x = 0 ;
for ( ; m > 0 ; x ++ ) { s [ x ] = m % 2 ; m = m / 2 ; }
int root = s [ x - 1 - Block_number ] ; if ( remaining == 0 ) { cout << root << endl ; return ; }
bool flip = true ; while ( remaining > 1 ) { if ( remaining & 1 ) { flip = ! flip ; } remaining = remaining >> 1 ; } if ( flip ) { cout << ! root << endl ; } else { cout << root << endl ; } }
int main ( ) { int m = 5 , k = 5 , n = 3 ; KthCharacter ( m , n , k ) ; return 0 ; }
bool onlyFirstAndLastAreSet ( unsigned int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; }
int main ( ) { unsigned int n = 9 ; if ( onlyFirstAndLastAreSet ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int getInteger ( int L , int R ) { int number = 0 ;
for ( int i = L ; i <= R ; i ++ ) number += pow ( 2 , i ) ; return number ; }
int main ( ) { int L = 2 , R = 5 ; cout << getInteger ( L , R ) ; return 0 ; }
int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; }
int main ( ) { int L = 2 , R = 5 ; cout << setbitsfromLtoR ( L , R ) ; return 0 ; }
int findXor ( int arr [ ] , int n ) {
int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; }
return xoR * 2 ; }
int main ( ) { int arr [ 3 ] = { 1 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findXor ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void printOdds ( int arr [ ] , int n ) {
int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ;
int set_bit = res & ( ~ ( res - 1 ) ) ;
int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; }
cout << x << " ▁ " << y ; }
int main ( ) { int arr [ ] = { 2 , 3 , 3 , 4 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printOdds ( arr , n ) ; return 0 ; }
void subsetBitwiseORk ( int arr [ ] , int n , int k ) { vector < int > v ; for ( int i = 0 ; i < n ; i ++ ) {
if ( ( arr [ i ] k ) == k ) v . push_back ( arr [ i ] ) ; }
int ans = 0 ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) ans |= v [ i ] ;
if ( ans != k ) { cout << " Subset ▁ does ▁ not ▁ exist " << endl ; return ; } for ( int i = 0 ; i < v . size ( ) ; i ++ ) cout << v [ i ] << ' ▁ ' ; }
int main ( ) { int k = 3 ; int arr [ ] = { 1 , 4 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; subsetBitwiseORk ( arr , n , k ) ; return 0 ; }
int findEletobeInserted ( int A [ ] , int n , int k ) {
int ans = k ; for ( int i = 0 ; i < n ; i ++ )
return ans ; }
int main ( ) { int A [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int k = 10 ; cout << findEletobeInserted ( A , n , k ) << " ▁ has ▁ to ▁ be ▁ inserted " " ▁ in ▁ the ▁ given ▁ array ▁ to ▁ make ▁ xor ▁ sum ▁ of ▁ " << k << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define BITS  32 NEW_LINE int andSum ( int arr [ ] , int n ) { int ans = 0 ;
for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ;
for ( int j = 0 ; j < n ; j ++ ) {
if ( arr [ j ] & ( 1 << i ) ) countSetBits ++ ; }
int subset = ( 1 << countSetBits ) - 1 ;
subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int size = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << andSum ( arr , size ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE #define ll  unsigned int NEW_LINE using namespace std ;
ll maximize ( ll a ) {
ll n = _popcnt32 ( a ) ;
if ( n == 32 ) return a ;
ll res = ( 1 << n ) - 1 ;
return ( res << ( 32 - n ) ) ; }
int main ( ) { ll a = 3 ; cout << maximize ( a ) << endl ; return 0 ; }
unsigned int countSetBits ( unsigned int n ) { unsigned int count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; }
int main ( ) { int i = 3 ; cout << countSetBits ( i ) ; return 0 ; }
bool isEven ( int n ) { bool isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; }
int main ( ) { int n = 101 ; isEven ( n ) ? cout << " Even " : cout << " Odd " ; return 0 ; }
bool isEven ( int n ) {
return ( ( n / 2 ) * 2 == n ) ; }
int main ( ) { int n = 101 ; isEven ( n ) ? cout << " Even " : cout << " Odd " ; return 0 ; }
bool checkValidPair ( int num1 , int num2 ) {
string s1 = to_string ( num1 ) ; string s2 = to_string ( num2 ) ;
for ( int i = 0 ; i < s1 . size ( ) ; i ++ ) for ( int j = 0 ; j < s2 . size ( ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] ) return true ;
return false ; }
int countPairs ( int arr [ ] , int n ) { int numberOfPairs = 0 ;
for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) numberOfPairs ++ ; return numberOfPairs ; }
int main ( ) { int arr [ ] = { 10 , 12 , 24 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countPairs ( arr , n ) << endl ; return 0 ; }
bool isPowerOf2 ( int num ) { return ( num && ! ( num & ( num - 1 ) ) ) ; }
bool checkSubsequence ( int arr [ ] , int n ) {
if ( n == 1 ) return isPowerOf2 ( arr [ 0 ] ) ;
int total = 0 ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) total = total | ( 1 << i ) ;
for ( int i = 0 ; i < NUM_BITS ; i ++ ) { int ans = total ; for ( int j = 0 ; j < n ; j ++ ) {
if ( arr [ j ] & ( 1 << i ) ) ans = ans & arr [ j ] ; }
if ( isPowerOf2 ( ans ) ) return true ; } return false ; }
int main ( ) { int arr [ ] = { 12 , 13 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( checkSubsequence ( arr , n ) ) printf ( " YES STRNEWLINE " ) ; else printf ( " NO STRNEWLINE " ) ; return 0 ; }
string findWinner ( int A [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= A [ i ] ;
if ( res == 0 n % 2 == 0 ) return " Alice " ;
else return " Bob " ; }
int main ( ) { int A [ ] = { 1 , 4 , 3 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << " Winner ▁ = ▁ " << findWinner ( A , n ) ; return 0 ; }
bool isFibbinaryNum ( unsigned int n ) {
if ( ( n & ( n >> 1 ) ) == 0 ) return true ;
return false ; }
int main ( ) { unsigned int n = 10 ; if ( isFibbinaryNum ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int maxXOR ( int n , int k ) { int c = log2 ( n ) + 1 ;
return ( ( 1 << c ) - 1 ) ; }
int main ( ) { int n = 12 ; int k = 3 ; cout << maxXOR ( n , k ) ; return 0 ; }
int divide ( long long dividend , long long divisor ) {
int sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? -1 : 1 ;
dividend = abs ( dividend ) ; divisor = abs ( divisor ) ;
long long quotient = 0 , temp = 0 ;
for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1LL << i ; } }
if ( sign == -1 ) quotient = - quotient ; return quotient ; }
int main ( ) { int a = 10 , b = 3 ; cout << divide ( a , b ) << " STRNEWLINE " ; a = 43 , b = -8 ; cout << divide ( a , b ) ; return 0 ; }
int count ( int n ) {
int c = 0 ;
while ( n ) { c ++ ;
n = n >> 1 ; } return c ; }
int XOR ( int a , int b ) {
int c = min ( a , b ) ; int d = max ( a , b ) ;
if ( count ( c ) < count ( d ) ) c = c << ( count ( d ) - count ( c ) ) ; return ( c ^ d ) ; }
int main ( ) { int a = 13 , b = 5 ; cout << XOR ( a , b ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; unsigned int swapBitsInPair ( unsigned int x ) {
return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; }
int main ( ) { unsigned int x = 4 ; cout << swapBitsInPair ( x ) ; return 0 ; }
int setevenbits ( int n ) { int temp = n ; int count = 0 ;
int res = 0 ;
for ( temp = n ; temp > 0 ; temp >>= 1 ) {
if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; }
return ( n & res ) ; }
int setoddbits ( int m ) { int count = 0 ;
int res = 0 ;
for ( int temp = m ; temp > 0 ; temp >>= 1 ) {
if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; }
return ( m & res ) ; } int getAlternateBits ( int n , int m ) {
int tempn = setevenbits ( n ) ;
int tempm = setoddbits ( m ) ;
return ( tempn tempm ) ; }
int main ( ) { int n = 10 ; int m = 11 ;
cout << getAlternateBits ( n , m ) ; return 0 ; }
bool isDivisibleBy10 ( char bin [ ] , int n ) {
if ( bin [ n - 1 ] == '1' ) return false ;
int sum = 0 ;
for ( int i = n - 2 ; i >= 0 ; i -- ) {
if ( bin [ i ] == '1' ) {
int posFromRight = n - i - 1 ;
if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } }
if ( sum % 10 == 0 ) return true ;
return false ; }
bool isDivisibleBy20 ( char bin [ ] , int n ) {
if ( bin [ n - 1 ] == '1' ) return false ;
return isDivisibleBy10 ( bin , n - 1 ) ; }
int main ( ) { char bin [ ] = "101000" ; int n = sizeof ( bin ) / sizeof ( bin [ 0 ] ) ; if ( isDivisibleBy20 ( bin , n - 1 ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int toggleBits ( int n1 , int n2 ) { return n1 ^ n2 ; }
int main ( ) { int n1 = 2 , n2 = 5 ; cout << toggleBitst ( n1 , n2 ) << endl ; return 0 ; }
int evenbittogglenumber ( int n ) {
int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) {
if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; }
return n ^ res ; }
int main ( ) { int n = 11 ; cout << evenbittogglenumber ( n ) ; return 0 ; }
int takeLandFsetbits ( int n ) {
n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ;
return ( ( n + 1 ) >> 1 ) + 1 ; } int toggleFandLbits ( int n ) {
if ( n == 1 ) return 0 ;
return n ^ takeLandFsetbits ( n ) ; }
int main ( ) { int n = 10 ; cout << toggleFandLbits ( n ) ; return 0 ; }
int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int checkOdious ( int n ) { return ( countSetBits ( n ) % 2 == 1 ) ; }
int main ( ) { int num = 32 ; if ( checkOdious ( num ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int setleftmostunsetbit ( int n ) {
if ( ( n & ( n + 1 ) ) == 0 ) return n ;
int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ )
if ( ( temp & 1 ) == 0 ) pos = count ;
return ( n | ( 1 << ( pos ) ) ) ; }
int main ( ) { int n = 10 ; cout << setleftmostunsetbit ( n ) ; return 0 ; }
int maxXorSum ( int n , int k ) {
if ( k == 1 ) return n ;
int res = 1 ; while ( res <= n ) res <<= 1 ;
return res - 1 ; }
int main ( ) { int n = 4 , k = 3 ; cout << maxXorSum ( n , k ) ; return 0 ; }
int getPosOfRightmostSetBit ( int n ) { return log2 ( n & - n ) ; }
unsigned int toggleLastKBits ( unsigned int n , unsigned int k ) {
unsigned int num = ( 1 << k ) - 1 ;
return ( n ^ num ) ; }
unsigned int incrementByOne ( unsigned int n ) {
int k = getPosOfRightmostSetBit ( ~ n ) ;
n = ( ( 1 << k ) n ) ;
if ( k != 0 ) n = toggleLastKBits ( n , k ) ;
return n ; }
int main ( ) { unsigned int n = 15 ; cout << incrementByOne ( n ) ; return 0 ; }
int xnor ( int a , int b ) {
if ( a < b ) swap ( a , b ) ; if ( a == 0 && b == 0 ) return 1 ;
int a_rem = 0 ;
int b_rem = 0 ;
int count = 0 ;
int xnornum = 0 ;
while ( a ) {
a_rem = a & 1 ;
b_rem = b & 1 ;
if ( a_rem == b_rem ) xnornum |= ( 1 << count ) ;
count ++ ; a = a >> 1 ; b = b >> 1 ; } return xnornum ; }
int main ( ) { int a = 10 , b = 50 ; cout << xnor ( a , b ) ; return 0 ; }
int togglebit ( int n ) { if ( n == 0 ) return 1 ;
int i = n ;
n |= n >> 1 ;
n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return i ^ n ; }
int XNOR ( int num1 , int num2 ) {
if ( num1 < num2 ) swap ( num1 , num2 ) ; num1 = togglebit ( num1 ) ; return num1 ^ num2 ; }
int main ( ) { int num1 = 10 , num2 = 20 ; cout << XNOR ( num1 , num2 ) ; return 0 ; }
void MaximumSum ( int a [ ] , int b [ ] , int n ) { int sum1 = 0 , sum2 = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } cout << sum1 + sum2 << endl ; }
int main ( ) { int A [ ] = { 1 , 2 , 4 , 3 , 2 } ; int B [ ] = { 2 , 3 , 3 , 12 , 1 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; MaximumSum ( A , B , n ) ; return 0 ; }
bool isPowerOfTwo ( unsigned int x ) {
return x && ( ! ( x & ( x - 1 ) ) ) ; }
bool differAtOneBitPos ( unsigned int a , unsigned int b ) { return isPowerOfTwo ( a ^ b ) ; }
int main ( ) { unsigned int a = 13 , b = 9 ; if ( differAtOneBitPos ( a , b ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
ll power2 ( ll n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 2 ; return power2 ( n / 2 ) * power2 ( n / 2 ) ; } ll multiply ( ll x , ll n ) { return x * power2 ( n ) ; }
int main ( ) { ll x = 70 , n = 2 ; cout << multiply ( x , n ) ; return 0 ; }
#include <stdio.h> NEW_LINE typedef long long int ll ; ll multiply ( ll x , ll n ) { return x << n ; }
int main ( ) { ll x = 70 , n = 2 ; printf ( " % lld " , multiply ( x , n ) ) ; return 0 ; }
bool isDivBy2PowerM ( unsigned int n , unsigned int m ) {
if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ;
return false ; }
int main ( ) { unsigned int n = 8 , m = 2 ; if ( isDivBy2PowerM ( n , m ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool findWinner ( int N ) {
return N & 1 ; }
int main ( ) { int N = 15 ; findWinner ( N ) ? ( cout << " Player ▁ A " ; ) : ( cout << " Player ▁ B " ; ) ; return 0 ; }
int evenbittogglenumber ( int n ) {
int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) {
if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; }
return n ^ res ; }
int main ( ) { int n = 11 ; cout << evenbittogglenumber ( n ) ; return 0 ; }
void divide ( int n , int m ) {
cout << " Remainder ▁ = ▁ " << ( ( n ) & ( m - 1 ) ) ;
cout << " Quotient = " }
int main ( ) { int n = 43 , m = 8 ; divide ( n , m ) ; return 0 ; }
int maxAND ( int arr [ ] , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = max ( res , arr [ i ] & arr [ j ] ) ; return res ; }
int main ( ) { int arr [ ] = { 4 , 8 , 6 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Maximum ▁ AND ▁ Value ▁ = ▁ " << maxAND ( arr , n ) ; return 0 ; }
int index ( int i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; } void check ( int n ) {
string s [ ] = { " negative " , " zero " , " positive " } ;
int val = index ( n ) ; cout << n << " ▁ is ▁ " << s [ val ] << endl ; }
int main ( ) { check ( 30 ) ; check ( -20 ) ; check ( 0 ) ; return 0 ; }
bool checking ( string s ) {
int c = 0 ;
int n = s . length ( ) ;
for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' ) c ++ ; if ( c >= 6 and s [ i ] == '1' ) return true ; } return false ; }
int main ( ) { string s = "100010001" ; if ( checking ( s ) ) cout << " Possible " ; else cout << " Not ▁ possible " ; return 0 ; }
int modifyBit ( int n , int p , int b ) { int mask = 1 << p ; return ( ( n & ~ mask ) | ( b << p ) ) ; }
int main ( ) { cout << modifyBit ( 6 , 2 , 0 ) << endl ; cout << modifyBit ( 6 , 5 , 1 ) << endl ; return 0 ; }
unsigned int countSetBits ( int n ) { unsigned int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
unsigned int countSetBitsInGivenRange ( unsigned int n , unsigned int l , unsigned int r ) {
int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ;
return countSetBits ( n & num ) ; }
int main ( ) { unsigned int n = 42 ; unsigned int l = 2 , r = 5 ; cout << countSetBitsInGivenRange ( n , l , r ) ; return 0 ; }
bool areAllBitsSet ( unsigned int n ) {
if ( n == 0 ) return false ;
if ( ( ( n + 1 ) & n ) == 0 ) return true ;
return false ; }
bool isOnesComplementOfOther ( unsigned int a , unsigned int b ) { return areAllBitsSet ( a ^ b ) ; }
int main ( ) { unsigned int a = 10 , b = 5 ; if ( isOnesComplementOfOther ( a , b ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findUnique ( unsigned int a [ ] , int n , int k ) {
int INT_SIZE = 8 * sizeof ( unsigned int ) ; int count [ INT_SIZE ] ; memset ( count , 0 , sizeof ( count ) ) ;
for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ;
unsigned res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; }
int main ( ) { unsigned int a [ ] = { 6 , 2 , 5 , 2 , 2 , 6 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int k = 3 ; cout << findUnique ( a , n , k ) ; return 0 ; }
bool powerOfTwo ( unsigned int n ) { return ( ! ( n & n - 1 ) ) ; }
bool onlyFirstAndLastAreSet ( unsigned int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return powerOfTwo ( n - 1 ) ; }
int main ( ) { unsigned int n = 9 ; if ( onlyFirstAndLastAreSet ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool allBitsAreSet ( unsigned int n ) {
if ( ( ( n + 1 ) & n ) == 0 ) return true ;
return false ; }
bool bitsAreInAltOrder ( unsigned int n ) { unsigned int num = n ^ ( n >> 1 ) ;
return allBitsAreSet ( num ) ; }
int main ( ) { unsigned int n = 10 ; if ( bitsAreInAltOrder ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int setBit ( int xorValue ) { int count = 0 ; while ( xorValue ) { if ( xorValue % 2 ) count ++ ; xorValue /= 2 ; }
return count ; }
int minFlip ( int n , int k ) {
int size = log2 ( n ) + 1 ;
int max = pow ( 2 , k ) - 1 ; max = max << ( size - k ) ;
int xorValue = ( n ^ max ) ; return ( setBit ( xorValue ) ) ; }
int main ( ) { int n = 27 , k = 3 ; cout << " Min ▁ Flips ▁ = ▁ " << minFlip ( n , k ) ; return 0 ; }
int setallbitgivenrange ( int n , int l , int r ) {
int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; }
int main ( ) { int n = 17 , l = 2 , r = 3 ; cout << setallbitgivenrange ( n , l , r ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cmath> NEW_LINE unsigned countBits ( unsigned int number ) {
return ( int ) log2 ( number ) + 1 ; }
int main ( ) { unsigned int num = 65 ; std :: cout << countBits ( num ) << ' ' ; return 0 ; }
string allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) {
int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ;
int new_num = n & num ;
if ( new_num == 0 ) return " Yes " ;
return " No " ; }
int main ( ) { unsigned int n = 17 ; unsigned int l = 2 , r = 4 ; cout << allBitsSetInTheGivenRange ( n , l , r ) ; return 0 ; }
int setAllBitsAfterMSB ( int n ) {
n |= n >> 1 ;
n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; } void toggle ( int & n ) { n = n ^ setAllBitsAfterMSB ( n ) ; }
int main ( ) { int n = 10 ; toggle ( n ) ; cout << n ; return 0 ; }
int getRightMostSetBit ( unsigned int n ) { return log2 ( n & - n ) + 1 ; }
int posOfRightMostSameBit ( unsigned int m , unsigned int n ) {
return getRightMostSetBit ( ~ ( m ^ n ) ) ; }
int main ( ) { int m = 16 , n = 7 ; cout << " Position ▁ = ▁ " << posOfRightMostSameBit ( m , n ) ; return 0 ; }
string allBitsSetInTheGivenRange ( unsigned int n , unsigned int l , unsigned int r ) {
int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ;
int new_num = n & num ;
if ( num == new_num ) return " Yes " ;
return " No " ; }
int main ( ) { unsigned int n = 22 ; unsigned int l = 2 , r = 3 ; cout << allBitsSetInTheGivenRange ( n , l , r ) ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; void printNonConsecutive ( int n ) {
int p = ( 1 << n ) ;
for ( int i = 1 ; i < p ; i ++ )
if ( ( i & ( i << 1 ) ) == 0 ) cout << i << " ▁ " ; }
int main ( ) { int n = 3 ; printNonConsecutive ( n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <bits/stdc++.h> NEW_LINE using namespace std ;
int constructNthNumber ( int group_no , int aux_num , int op ) { int INT_SIZE = 32 ; int a [ INT_SIZE ] = { 0 } ; int num = 0 , len_f ; int i = 0 ;
if ( op == 2 ) {
len_f = 2 * group_no ;
a [ len_f - 1 ] = a [ 0 ] = 1 ;
while ( aux_num ) {
a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } }
else if ( op == 0 ) {
len_f = 2 * group_no + 1 ;
a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ;
while ( aux_num ) {
a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } }
else {
len_f = 2 * group_no + 1 ;
a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ;
while ( aux_num ) {
a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } }
for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; }
int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ;
while ( count_temp < n ) { group_no ++ ;
count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; }
group_offset = n - count_upto_group - 1 ;
if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) {
aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 )
op = 0 ; else
op = 1 ; aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; }
int main ( ) { int n = 9 ;
cout << getNthNumber ( n ) ; return 0 ; }
int countSetBits ( int n ) { int count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; }
int findSum ( int n ) { int sum = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) if ( countSetBits ( i ) == 2 ) sum += i ; return sum ; }
int main ( ) { int n = 10 ; cout << findSum ( n ) ; return 0 ; }
unsigned int toggleLastMBits ( unsigned int n , unsigned int m ) {
unsigned int num = ( 1 << m ) - 1 ;
return ( n ^ num ) ; }
int main ( ) { unsigned int n = 107 ; unsigned int m = 4 ; cout << toggleLastMBits ( n , m ) ; return 0 ; }
int getFirstSetBitPos ( int n ) { return log2 ( n & - n ) + 1 ; }
int previousSmallerInteger ( int n ) {
int pos = getFirstSetBitPos ( n ) ;
return ( n & ~ ( 1 << ( pos - 1 ) ) ) ; }
int main ( ) { int n = 25 ; cout << previousSmallerInteger ( n ) ; return 0 ; }
string areAllBitsSet ( int n ) {
if ( n == 0 ) return " No " ;
while ( n > 0 ) {
if ( ( n & 1 ) == 0 ) return " No " ;
n = n >> 1 ; }
return " Yes " ; }
int main ( ) { int n = 7 ; cout << areAllBitsSet ( n ) ; return 0 ; }
string areAllBitsSet ( int n ) {
if ( n == 0 ) return " No " ;
if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ;
return " No " ; }
int main ( ) { int n = 7 ; cout << areAllBitsSet ( n ) ; return 0 ; }
int getFirstSetBitPos ( int n ) { return ( log2 ( n & - n ) + 1 ) - 1 ; }
int nextGreaterWithOneMoreSetBit ( int n ) {
int pos = getFirstSetBitPos ( ~ n ) ;
if ( pos > -1 ) return ( 1 << pos ) | n ;
return ( ( n << 1 ) + 1 ) ; }
int main ( ) { int n = 10 ; cout << " Next ▁ greater ▁ integer ▁ = ▁ " << nextGreaterWithOneMoreSetBit ( n ) ; return 0 ; }
long CountZeroBit ( long x ) { unsigned int count = 0 ; while ( x ) { if ( ! ( x & 1LL ) ) count ++ ; x >>= 1LL ; } return count ; }
long CountXORandSumEqual ( long x ) {
long count = CountZeroBit ( x ) ;
return ( 1LL << count ) ; }
int main ( ) { long x = 10 ;
cout << CountXORandSumEqual ( x ) ; return 0 ; }
int missingNumber ( int arr1 [ ] , int arr2 [ ] , int n ) {
int mnum = 0 ;
for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ;
for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ;
return mnum ; }
int main ( ) { int arr1 [ ] = { 4 , 8 , 1 , 3 , 7 } ; int arr2 [ ] = { 7 , 4 , 3 , 1 } ; int n = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << " Missing ▁ number ▁ = ▁ " << missingNumber ( arr1 , arr2 , n ) ; return 0 ; }
int max ( int a , int b , int c ) { return max ( a , max ( b , c ) ) ; }
int bitCount ( int N ) { int cnt = 0 ; while ( N ) { cnt ++ ; N >>= 1 ; } return cnt ; }
bool at_position ( int num , int pos ) { bool bit = num & ( 1 << pos ) ; return bit ; }
void toggle ( int & num , int pos ) { num ^= ( 1 << pos ) ; }
void minChangeToReachTaregetOR ( int A , int B , int K , int T ) { int maxlen = max ( bitCount ( A ) , bitCount ( B ) , bitCount ( T ) ) ;
for ( int i = maxlen - 1 ; i >= 0 ; i -- ) { bool bitA = at_position ( A , i ) ; bool bitB = at_position ( B , i ) ; bool bitT = at_position ( T , i ) ;
if ( bitT ) { if ( ! bitA && ! bitB ) { toggle ( B , i ) ; K -- ; } } else {
if ( bitA ) { toggle ( A , i ) ; K -- ; }
if ( bitB ) { toggle ( B , i ) ; K -- ; } } }
if ( K < 0 ) { cout << " Not ▁ possible STRNEWLINE " ; return ; }
for ( int i = maxlen - 1 ; K > 0 && i >= 0 ; -- i ) { bool bitA = at_position ( A , i ) ; bool bitB = at_position ( B , i ) ; bool bitT = at_position ( T , i ) ; if ( bitT ) {
if ( bitA && bitB ) { toggle ( A , i ) ; K -- ; } }
if ( bitA && ! bitB && K >= 2 ) { toggle ( A , i ) ; toggle ( B , i ) ; K -= 2 ; } }
cout << A << " ▁ " << B << endl ; }
int main ( ) { int A = 175 , B = 66 , K = 5 , T = 100 ; minChangeToReachTaregetOR ( A , B , K , T ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countValues ( int x ) {
int count = 0 , n = 1 ;
while ( x != 0 ) {
if ( x % 2 == 0 ) count += n ;
n *= 2 ;
x /= 2 ; } return count ; }
int main ( ) { int x = 10 ; cout << countValues ( x ) ; return 0 ; }
void constructXOR ( int A [ ] , int n ) {
int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ;
for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; }
int main ( ) { int A [ ] = { 2 , 4 , 1 , 3 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; constructXOR ( A , n ) ;
for ( int i = 0 ; i < n ; i ++ ) cout << A [ i ] << " ▁ " ; return 0 ; }
int bitCount ( int n ) { int count = 0 ; while ( n ) { if ( n & 1 ) ++ count ; n >>= 1 ; } return count ; }
long long countPairsWithKDiff ( int arr [ ] , int n , int k ) {
for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int xoredNum = arr [ i ] ^ arr [ j ] ;
if ( k == bitCount ( xoredNum ) ) ++ ans ; } } return ans ; }
int main ( ) { int k = 2 ; int arr [ ] = { 2 , 4 , 1 , 3 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Total ▁ pairs ▁ for ▁ k ▁ = ▁ " << k << " ▁ are ▁ " << countPairsWithKDiff ( arr , n , k ) << " STRNEWLINE " ; return 0 ; }
int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m ) {
if ( m % 2 == 1 ) ans += n << count ;
count ++ ; m /= 2 ; } return ans ; }
int main ( ) { int n = 20 , m = 13 ; cout << multiply ( n , m ) ; return 0 ; }
bool EqualNumber ( int A , int B ) { return ( A ^ B ) ; }
int main ( ) { int A = 5 , B = 6 ; cout << ! EqualNumber ( A , B ) << endl ; return 0 ; }
bool areSetBitsIncreasing ( int n ) {
int prev_count = INT_MAX ;
while ( n > 0 ) {
while ( n > 0 && n % 2 == 0 ) n = n / 2 ;
int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; }
if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; }
int main ( ) { int n = 10 ; if ( areSetBitsIncreasing ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
bool findPattern ( int n ) {
int prev = n % 2 ; n = n / 2 ;
while ( n > 0 ) { int curr = n % 2 ;
if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; }
int main ( ) { int n = 10 ; if ( findPattern ( n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n ) {
( n % 2 == 0 ) ? count0 ++ : count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; }
int main ( ) { int n = 31 ; cout << countXOR ( n ) ; return 0 ; }
int msbPos ( ll n ) { int msb_p = -1 ; while ( n ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; }
ll andOperator ( ll x , ll y ) {
while ( x && y ) {
int msb_p1 = msbPos ( x ) ; int msb_p2 = msbPos ( y ) ;
if ( msb_p1 != msb_p2 ) break ;
ll msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ;
x = x - msb_val ; y = y - msb_val ; } return res ; }
int main ( ) { ll x = 10 , y = 15 ; cout << andOperator ( x , y ) ; return 0 ; }
int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; }
int main ( ) { int n = 50 ; cout << multiplyTen ( n ) ; return 0 ; }
int countValues ( int n ) { int countV = 0 ;
for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; }
int main ( ) { int n = 12 ; cout << countValues ( n ) ; return 0 ; }
int countValues ( int n ) {
int unset_bits = 0 ; while ( n ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; }
return 1 << unset_bits ; }
int main ( ) { int n = 12 ; cout << countValues ( n ) ; return 0 ; }
char findProffesion ( int level , int pos ) {
if ( level == 1 ) return ' e ' ;
if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' d ' ) return ( pos % 2 ) ? ' d ' : ' e ' ;
return ( pos % 2 ) ? ' e ' : ' d ' ; }
int main ( void ) { int level = 4 , pos = 2 ; ( findProffesion ( level , pos ) == ' e ' ) ? cout << " Engineer " : cout << " Doctor " ; return 0 ; }
void printTwoSetBitNums ( int n ) {
int x = 1 ;
while ( n > 0 ) {
int y = 0 ; while ( y < x ) {
cout << ( 1 << x ) + ( 1 << y ) << " ▁ " ;
n -- ; if ( n == 0 ) return ;
y ++ ; }
x ++ ; } }
int main ( ) { printTwoSetBitNums ( 4 ) ; return 0 ; }
int rand50 ( ) {
return rand ( ) & 1 ; }
bool rand75 ( ) { return rand50 ( ) | rand50 ( ) ; }
int main ( ) {
srand ( time ( NULL ) ) ; for ( int i = 0 ; i < 50 ; i ++ ) cout << rand75 ( ) ; return 0 ; }
void printRepeatingEven ( int arr [ ] , int n ) { long long _xor = 0L ; long long pos ;
for ( int i = 0 ; i < n ; ++ i ) {
pos = 1 << arr [ i ] ;
_xor ^= pos ; }
for ( int i = 0 ; i < n ; ++ i ) {
pos = 1 << arr [ i ] ;
if ( ! ( pos & _xor ) ) {
cout << arr [ i ] << " ▁ " ;
_xor ^= pos ; } } }
int main ( ) { int arr [ ] = { 9 , 12 , 23 , 10 , 12 , 12 , 15 , 23 , 14 , 12 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printRepeatingEven ( arr , n ) ; return 0 ; }
int countSetBits ( int x ) { unsigned int count = 0 ; while ( x ) { x &= ( x - 1 ) ; count ++ ; } return count ; }
bool isBleak ( int n ) {
for ( int x = 1 ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; }
int main ( ) { isBleak ( 3 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; isBleak ( 4 ) ? cout << " Yes STRNEWLINE " : cout << " No STRNEWLINE " ; return 0 ; }
#define INT_BITS  32
int maxSubarrayXOR ( int set [ ] , int n ) {
int index = 0 ;
for ( int i = INT_BITS - 1 ; i >= 0 ; i -- ) {
int maxInd = index ; int maxEle = INT_MIN ; for ( int j = index ; j < n ; j ++ ) {
if ( ( set [ j ] & ( 1 << i ) ) != 0 && set [ j ] > maxEle ) maxEle = set [ j ] , maxInd = j ; }
if ( maxEle == INT_MIN ) continue ;
swap ( set [ index ] , set [ maxInd ] ) ;
maxInd = index ;
for ( int j = 0 ; j < n ; j ++ ) {
if ( j != maxInd && ( set [ j ] & ( 1 << i ) ) != 0 ) set [ j ] = set [ j ] ^ set [ maxInd ] ; }
index ++ ; }
int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= set [ i ] ; return res ; }
int main ( ) { int set [ ] = { 9 , 8 , 5 } ; int n = sizeof ( set ) / sizeof ( set [ 0 ] ) ; cout << " Max ▁ subset ▁ XOR ▁ is ▁ " ; cout << maxSubarrayXOR ( set , n ) ; return 0 ; }
int findXOR ( int Set [ ] , int n ) {
if ( n == 1 ) return Set [ 0 ] ; else return 0 ; }
int main ( ) { int Set [ ] = { 1 , 2 , 3 } ; int n = sizeof ( Set ) / sizeof ( Set [ 0 ] ) ; cout << " XOR ▁ of ▁ XOR ' s ▁ of ▁ all ▁ subsets ▁ is ▁ " << findXOR ( Set , n ) ; return 0 ; }
int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; }
int main ( ) { int x = 3 , y = 5 ; cout << " XOR ▁ is ▁ " << myXOR ( x , y ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define N  2
int freivald ( int a [ ] [ N ] , int b [ ] [ N ] , int c [ ] [ N ] ) {
bool r [ N ] ; for ( int i = 0 ; i < N ; i ++ ) r [ i ] = random ( ) % 2 ;
int br [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) br [ i ] = br [ i ] + b [ i ] [ j ] * r [ j ] ;
int cr [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) cr [ i ] = cr [ i ] + c [ i ] [ j ] * r [ j ] ;
int axbr [ N ] = { 0 } ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) axbr [ i ] = axbr [ i ] + a [ i ] [ j ] * br [ j ] ;
for ( int i = 0 ; i < N ; i ++ ) if ( axbr [ i ] - cr [ i ] != 0 ) false ; return true ; }
bool isProduct ( int a [ ] [ N ] , int b [ ] [ N ] , int c [ ] [ N ] , int k ) { for ( int i = 0 ; i < k ; i ++ ) if ( freivald ( a , b , c ) == false ) return false ; return true ; }
int main ( ) { int a [ N ] [ N ] = { { 1 , 1 } , { 1 , 1 } } ; int b [ N ] [ N ] = { { 1 , 1 } , { 1 , 1 } } ; int c [ N ] [ N ] = { { 2 , 2 } , { 2 , 2 } } ; int k = 2 ; if ( isProduct ( a , b , c , k ) ) printf ( " Yes " ) ; else printf ( " No " ) ; return 0 ; }
float calc_Expectation ( float a [ ] , float n ) {
float prb = ( 1 / n ) ;
float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ;
return sum ; }
int main ( ) { float expect , n = 6.0 ; float a [ 6 ] = { 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 } ;
expect = calc_Expectation ( a , n ) ;
cout << " Expectation ▁ of ▁ array ▁ E ( X ) ▁ is ▁ : ▁ " << expect << " STRNEWLINE " ; return 0 ; }
void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? min ( l1 , l2 ) : -1 ; int y = ( r1 != r2 ) ? max ( r1 , r2 ) : -1 ; cout << x << " ▁ " << y ; }
int main ( ) { int l1 = 5 , r1 = 10 , l2 = 1 , r2 = 7 ; findPoints ( l1 , r1 , l2 , r2 ) ; }
#include <iostream> NEW_LINE using namespace std ; unsigned int fact ( unsigned int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; }
int main ( ) { cout << fact ( 5 ) ; return 0 ; }
void printElements ( int a [ ] , int n ) {
sort ( a , a + n , greater < int > ( ) ) ; int cnt = 1 ;
for ( int i = 0 ; i < n - 1 ; i ++ ) {
if ( a [ i ] != a [ i + 1 ] ) { cout << a [ i ] << " ▁ occurs ▁ " << cnt << " ▁ times STRNEWLINE " ; cnt = 1 ; } else cnt += 1 ; }
cout << a [ n - 1 ] << " ▁ occurs ▁ " << cnt << " ▁ times STRNEWLINE " ; }
int main ( ) { int a [ ] = { 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printElements ( a , n ) ; return 0 ; }
#include <iostream> NEW_LINE #include <math.h> NEW_LINE #define SMALL_N  1000000 NEW_LINE #define LARGE_N  1000000000000000 NEW_LINE using namespace std ;
long long func ( long long a , long long b , long long c , long long n ) { long long res = a * n ; long long logVlaue = floor ( log2 ( n ) ) ; res += b * n * logVlaue ; res += c * ( n * n * n ) ; return res ; } long long getPositionInSeries ( long long a , long long b , long long c , long long k ) { long long start = 1 , end = SMALL_N ;
if ( c == 0 ) { end = LARGE_N ; } long long ans = 0 ;
while ( start <= end ) { long long mid = ( start + end ) / 2 ; long long val = func ( a , b , c , mid ) ; if ( val == k ) { ans = mid ; break ; } else if ( val > k ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; }
int main ( ) { long long a = 2 , b = 1 , c = 1 ; long long k = 12168587437017 ; cout << getPositionInSeries ( a , b , c , k ) ; return 0 ; }
bool checkIndices ( int Arr [ ] , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) {
if ( Arr [ i ] != Arr [ j ] ) {
if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; }
int main ( ) { int Arr [ ] = { 3 , 2 , 1 , 1 , 4 } ; int N = sizeof ( Arr ) / sizeof ( Arr [ 0 ] ) ;
checkIndices ( Arr , N ) ? cout << " Yes " : cout << " No " ; return 0 ; }
int printPairs ( int arr [ ] , int n , int sum ) {
for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) cout << " ( " << arr [ i ] << " , ▁ " << arr [ j ] << " ) " << endl ; }
int main ( ) { int arr [ ] = { 1 , 5 , 7 , -1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int sum = 6 ; printPairs ( arr , n , sum ) ; return 0 ; }
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) {
int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; }
int main ( ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , n ) << endl ; return 0 ; }
int minSum ( int arr [ ] , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) {
if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; }
else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; }
int main ( ) { int arr [ ] = { 2 , 2 , 3 , 5 , 6 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minSum ( arr , n ) << endl ; return 0 ; }
bool isPandigital ( string str ) { if ( str . length ( ) != 9 ) return false ; char ch [ str . length ( ) ] ; strcpy ( ch , str . c_str ( ) ) ; sort ( ch , ch + str . length ( ) ) ; string s = ch ; if ( s . compare ( "123456789" ) == 0 ) return true ; else return true ; }
bool PandigitalProduct_1_9 ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 && isPandigital ( to_string ( n ) + to_string ( i ) + to_string ( n / i ) ) ) return true ; return false ; }
int main ( ) { int n = 6952 ; if ( PandigitalProduct_1_9 ( n ) == true ) cout << " yes " ; else cout << " no " ; return 0 ; }
void printModeMedian ( int a [ ] , int n ) {
int b [ n ] ;
int max = * max_element ( a , a + n ) ;
int t = max + 1 ; int count [ t ] ; for ( int i = 0 ; i < t ; i ++ ) count [ i ] = 0 ;
for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ;
int mode = 0 ; int k = count [ 0 ] ; for ( int i = 1 ; i < t ; i ++ ) { if ( count [ i ] > k ) { k = count [ i ] ; mode = i ; } }
for ( int i = 1 ; i < t ; i ++ ) count [ i ] = count [ i ] + count [ i - 1 ] ;
for ( int i = 0 ; i < n ; i ++ ) { b [ count [ a [ i ] ] - 1 ] = a [ i ] ; count [ a [ i ] ] -- ; }
float median ; if ( n % 2 != 0 ) median = b [ n / 2 ] ; else median = ( b [ ( n - 1 ) / 2 ] + b [ ( n / 2 ) ] ) / 2.0 ;
cout << " median ▁ = ▁ " << median << endl ; cout << " mode ▁ = ▁ " << mode ; }
int main ( ) { int a [ ] = { 1 , 4 , 1 , 2 , 7 , 1 , 2 , 5 , 3 , 6 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; printModeMedian ( a , n ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream> NEW_LINE #include <string> NEW_LINE using namespace std ; # define MAX  26
bool function ( string str ) { int l = str . length ( ) ;
int counter1 [ MAX ] ; int counter2 [ MAX ] ; memset ( counter1 , 0 , sizeof ( counter1 ) ) ; memset ( counter2 , 0 , sizeof ( counter2 ) ) ; for ( int i = 0 ; i < l / 2 ; i ++ ) counter1 [ str [ i ] - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter2 [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX ; i ++ ) if ( counter2 [ i ] != counter1 [ i ] ) return true ; return false ; }
int main ( ) { string str = " abcasdsabcae " ; if ( function ( str ) ) cout << " Yes , ▁ both ▁ halves ▁ differ " << " ▁ by ▁ at ▁ least ▁ one ▁ character " ; else cout << " No , ▁ both ▁ halves ▁ do ▁ " << " not ▁ differ ▁ at ▁ all " ; return 0 ; }
int minDifferenceAmongMaxMin ( int arr [ ] , int N , int K ) {
sort ( arr , arr + N ) ;
int res = INT_MAX ;
for ( int i = 0 ; i <= ( N - K ) ; i ++ ) {
int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = min ( res , curSeqDiff ) ; } return res ; }
int main ( ) { int arr [ ] = { 10 , 20 , 30 , 100 , 101 , 102 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; cout << minDifferenceAmongMaxMin ( arr , N , K ) ; return 0 ; }
int getIndexInSortedArray ( int arr [ ] , int n , int idx ) {
int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( arr [ i ] < arr [ idx ] ) result ++ ;
if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; }
int main ( ) { int arr [ ] = { 3 , 4 , 3 , 5 , 2 , 3 , 4 , 3 , 1 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int idxOfEle = 5 ; cout << getIndexInSortedArray ( arr , n , idxOfEle ) ; return 0 ; }
int getMaxValue ( int arr [ ] , int arr_size ) { int i , first , second ;
if ( arr_size < 2 ) { return 0 ; }
first = second = INT_MIN ; for ( i = 0 ; i < arr_size ; i ++ ) {
if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; }
else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; }
if ( second == INT_MIN ) return 0 ; else return second ; }
int main ( ) { int arr [ ] = { 4 , 5 , 1 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << getMaxValue ( arr , n ) ; return 0 ; }
int maximumResult ( int a , int b , int c ) {
int countOfNegative = 0 ;
int sum = a + b + c ;
int product = a * b * c ;
int largest = max ( a , max ( b , c ) ) ; int smallest = min ( a , min ( b , c ) ) ;
if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ;
switch ( countOfNegative ) {
case 0 : return ( sum - largest ) * largest ;
case 1 : return ( product / smallest ) + smallest ;
case 2 : return ( product / largest ) + largest ;
case 3 : return ( sum - smallest ) * smallest ; } }
int main ( ) { int a = -2 , b = -1 , c = -4 ; cout << maximumResult ( a , b , c ) ; return 0 ; }
int check ( int n , int marks [ ] ) {
int * x = std :: max_element ( marks , marks + 5 ) ;
int bonus = 100 - ( int ) ( * x ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; }
int main ( ) { int n = 5 ; int marks [ ] = { 0 , 21 , 83 , 45 , 64 } ; cout << check ( n , marks ) << endl ; return 0 ; }
int find_sum ( int n , int k ) {
int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) {
total_sum -= power ;
power *= k ; } return total_sum ; }
int main ( ) { int n = 11 , k = 2 ; cout << find_sum ( n , k ) ; return 0 ; }
int minOperations ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
for ( int i = 0 ; i < n ; i ++ ) hashTable [ arr [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] ) { for ( int j = i ; j < n ; j ++ ) if ( arr [ j ] % arr [ i ] == 0 ) hashTable [ arr [ j ] ] = 0 ; res ++ ; } } return res ; }
int main ( ) { int arr [ ] = { 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minOperations ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; bool ifPossible ( int arr [ ] , int n ) { int cp [ n ] ;
copy ( arr , arr + n , cp ) ;
sort ( cp , cp + n ) ; for ( int i = 0 ; i < n ; i ++ ) {
if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false ; } return true ; }
int main ( ) { int arr [ ] = { 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( ifPossible ( arr , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int FindMinimumCost ( int ind , int a [ ] , int n , int k , int dp [ ] ) {
if ( ind == ( n - 1 ) ) return 0 ;
else if ( dp [ ind ] != -1 ) return dp [ ind ] ; else {
int ans = INT_MAX ;
for ( int i = 1 ; i <= k ; i ++ ) {
if ( ind + i < n ) ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ;
else break ; }
return dp [ ind ] = ans ; } }
int main ( ) { int a [ ] = { 10 , 30 , 40 , 50 , 20 } ; int k = 3 ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; int dp [ n ] ; memset ( dp , -1 , sizeof dp ) ; cout << FindMinimumCost ( 0 , a , n , k , dp ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define ll  long long int NEW_LINE const int MAX = 100000 ; ll prefix [ MAX ] ;
void sieve_modified ( ) { for ( int i = 2 ; i < MAX ; i += 2 ) {
for ( int j = i ; j < MAX ; j += i ) prefix [ j ] += i ; }
for ( int i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; }
ll sumEvenFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; }
int main ( ) { sieve_modified ( ) ; int l = 6 , r = 10 ; cout << sumEvenFactors ( l , r ) ; return 0 ; }
int find ( int index , int openbrk , int n , int dp [ N ] [ N ] , int adj [ ] ) {
if ( openbrk < 0 ) return 0 ;
if ( index == n ) {
if ( openbrk == 0 ) return 1 ; else return 0 ; }
if ( dp [ index ] [ openbrk ] != -1 ) return dp [ index ] [ openbrk ] ;
if ( adj [ index ] == 1 ) {
dp [ index ] [ openbrk ] = find ( index + 1 , openbrk + 1 , n , dp , adj ) ; } else {
dp [ index ] [ openbrk ] = find ( index + 1 , openbrk + 1 , n , dp , adj ) + find ( index + 1 , openbrk - 1 , n , dp , adj ) ; }
return dp [ index ] [ openbrk ] ; }
int dp [ N ] [ N ] ; int n = 2 ; memset ( dp , -1 , sizeof ( dp ) ) ;
int adj [ 4 ] = { 1 , 0 , 0 , 0 } ;
cout << find ( 0 , 0 , 2 * n , dp , adj ) << endl ; return 0 ; }
void findMaxValUtil ( int arr [ ] , int n , int num , int maxLimit , int ind , int & ans ) {
if ( ind == n ) { ans = max ( ans , num ) ; return ; }
if ( num - arr [ ind ] >= 0 ) { findMaxValUtil ( arr , n , num - arr [ ind ] , maxLimit , ind + 1 , ans ) ; }
if ( num + arr [ ind ] <= maxLimit ) { findMaxValUtil ( arr , n , num + arr [ ind ] , maxLimit , ind + 1 , ans ) ; } }
int findMaxVal ( int arr [ ] , int n , int num , int maxLimit ) {
int ans = 0 ;
int ind = 0 ;
findMaxValUtil ( arr , n , num , maxLimit , ind , ans ) ; return ans ; }
int main ( ) { int num = 1 ; int arr [ ] = { 3 , 10 , 6 , 4 , 5 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int maxLimit = 15 ; cout << findMaxVal ( arr , n , num , maxLimit ) ; return 0 ; }
void printSets ( vector < int > set1 , vector < int > set2 ) { int i ;
for ( i = 0 ; i < set1 . size ( ) ; i ++ ) { cout << set1 [ i ] << " ▁ " ; } cout << " STRNEWLINE " ;
for ( i = 0 ; i < set2 . size ( ) ; i ++ ) { cout << set2 [ i ] << " ▁ " ; } }
bool findSets ( int arr [ ] , int n , vector < int > & set1 , vector < int > & set2 , int sum1 , int sum2 , int pos ) {
if ( pos == n ) {
if ( sum1 == sum2 ) { printSets ( set1 , set2 ) ; return true ; }
else return false ; }
set1 . push_back ( arr [ pos ] ) ;
bool res = findSets ( arr , n , set1 , set2 , sum1 + arr [ pos ] , sum2 , pos + 1 ) ;
if ( res ) return res ;
set1 . pop_back ( ) ; set2 . push_back ( arr [ pos ] ) ;
res = findSets ( arr , n , set1 , set2 , sum1 , sum2 + arr [ pos ] , pos + 1 ) ; if ( res == false ) if ( ! set2 . empty ( ) ) set2 . pop_back ( ) ; return res ; }
bool isPartitionPoss ( int arr [ ] , int n ) {
int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ;
if ( sum % 2 != 0 ) return false ;
vector < int > set1 , set2 ;
return findSets ( arr , n , set1 , set2 , 0 , 0 , 0 ) ; }
int main ( ) { int arr [ ] = { 5 , 5 , 1 , 11 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; if ( ! isPartitionPoss ( arr , n ) ) { cout << " - 1" ; } return 0 ; }
int maximumSumSubarray ( int arr [ ] , int n ) {
int min_prefix_sum = 0 ;
int res = numeric_limits < int > :: min ( ) ;
int prefix_sum [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ;
for ( int i = 0 ; i < n ; i ++ ) { res = max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; }
int arr1 [ ] = { -2 , -3 , 4 , -1 , -2 , 1 , 5 , -3 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; cout << maximumSumSubarray ( arr1 , n1 ) << endl ;
int arr2 [ ] = { 4 , -8 , 9 , -4 , 1 , -8 , -1 , 6 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; cout << maximumSumSubarray ( arr2 , n2 ) ; return 0 ; }
#include <cstring> NEW_LINE #include <iostream>
int static const DP_s = 9 ; int getNumMonotone ( int len ) {
int DP [ len ] [ DP_s ] ; memset ( DP , 0 , sizeof ( DP ) ) ;
for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ;
for ( int i = 0 ; i < len ; ++ i ) DP [ i ] [ 0 ] = 1 ;
for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; }
int main ( ) { std :: cout << getNumMonotone ( 10 ) ; return 0 ; }
int sequence ( int n ) {
int f [ n + 1 ] ; int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; }
int main ( ) { int n = 10 ; cout << sequence ( n ) ; return 0 ; }
ll lis ( ll arr [ ] , ll n ) { ll mpis [ n ] ;
for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ;
for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ;
return * max_element ( mpis , mpis + n ) ; }
int main ( ) { ll arr [ ] = { 3 , 100 , 4 , 5 , 150 , 6 } ; ll n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; printf ( " % lld " , lis ( arr , n ) ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int Hosoya ( int n , int m ) {
if ( ( n == 0 && m == 0 ) || ( n == 1 && m == 0 ) || ( n == 1 && m == 1 ) || ( n == 2 && m == 1 ) ) return 1 ;
if ( n > m ) return Hosoya ( n - 1 , m ) + Hosoya ( n - 2 , m ) ; else if ( m == n ) return Hosoya ( n - 1 , m - 1 ) + Hosoya ( n - 2 , m - 2 ) ; else return 0 ; }
void printHosoya ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) cout << Hosoya ( i , j ) << " ▁ " ; cout << endl ; } }
int main ( ) { int n = 5 ; printHosoya ( n ) ; return 0 ; }
int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; }
int main ( ) { int n = 3 , m = 1 ; cout << eulerian ( n , m ) << endl ; return 0 ; }
int largestSubset ( int a [ ] , int n ) {
int dp [ n ] ;
dp [ n - 1 ] = 1 ;
for ( int i = n - 2 ; i >= 0 ; i -- ) {
int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) mxm = max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; }
return * max_element ( dp , dp + n ) ; }
int main ( ) { int a [ ] = { 1 , 3 , 6 , 13 , 17 , 18 } ; int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ; cout << largestSubset ( a , n ) << endl ; return 0 ; }
int countFriendsPairings ( int n ) { int dp [ n + 1 ] ;
for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; }
int main ( ) { int n = 4 ; cout << countFriendsPairings ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; }
int main ( ) { int n = 4 ; cout << countFriendsPairings ( n ) ; return 0 ; }
int lcsOf3 ( string X , string Y , string Z , int m , int n , int o ) { int L [ m + 1 ] [ n + 1 ] [ o + 1 ] ;
for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } }
return L [ m ] [ n ] [ o ] ; }
int main ( ) { string X = " AGGT12" ; string Y = "12TXAYB " ; string Z = "12XBA " ; int m = X . length ( ) ; int n = Y . length ( ) ; int o = Z . length ( ) ; cout << " Length ▁ of ▁ LCS ▁ is ▁ " << lcsOf3 ( X , Y , Z , m , n , o ) ; return 0 ; }
int findLongestRepeatingSubSeq ( string str ) { int n = str . length ( ) ;
int dp [ n + 1 ] [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ;
for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) {
if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ;
else dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
int main ( ) { string str = " aabb " ; cout << " The ▁ length ▁ of ▁ the ▁ largest ▁ subsequence ▁ that " " ▁ repeats ▁ itself ▁ is ▁ : ▁ " << findLongestRepeatingSubSeq ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int numberOfPaths ( int m , int n ) {
int dp [ n ] = { 1 } ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; }
int main ( ) { cout << numberOfPaths ( 3 , 3 ) ; }
int factorial ( int N ) {
if ( N == 0 N == 1 ) return 1 ;
return N * factorial ( N - 1 ) ; }
int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; }
int main ( ) { int N = 6 ; cout << nthTerm ( N ) ; return 0 ; }
bool isFrequencyEqual ( string str , int len ) {
if ( len % 2 == 1 ) return false ;
int i , freq [ 26 ] = { 0 } ;
for ( i = 0 ; i < len ; i ++ ) freq [ str [ i ] - ' a ' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) if ( freq [ i ] == len / 2 ) return true ;
return false ; }
int main ( ) { string str = " geeksforgeeks " ; int len = str . length ( ) ; if ( isFrequencyEqual ( str , len ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int countMinimalReplacements ( string s ) {
int n = s . length ( ) ; int cnt = 0 ;
for ( int i = 1 ; i < n ; i ++ ) {
if ( s [ i ] == s [ i - 1 ] ) { cnt += 1 ;
if ( i != ( n - 1 ) ) {
for ( auto it : "012" ) { if ( it != s [ i + 1 ] && it != s [ i - 1 ] ) { s [ i ] = it ; break ; } } }
{
for ( auto it : "012" ) { if ( it != s [ i - 1 ] ) { s [ i ] = it ; break ; } } } } } return cnt ; }
int main ( ) { string s = "201220211" ; cout << countMinimalReplacements ( s ) ; return 0 ; }
int nextIndex ( string str , int start , char c ) {
for ( int i = start ; i < str . length ( ) ; i ++ ) {
if ( str [ i ] == c ) return i ; }
return -1 ; }
int countSubStrings ( string str ) { int i , n = str . length ( ) ;
int countX [ n ] ; int count = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' x ' ) count ++ ; countX [ i ] = count ; }
int nextIndexX = nextIndex ( str , 0 , ' x ' ) ;
int nextIndexY = nextIndex ( str , 0 , ' y ' ) ;
count = 0 ; while ( nextIndexX != -1 && nextIndexY != -1 ) {
if ( nextIndexX > nextIndexY ) {
nextIndexY = nextIndex ( str , nextIndexY + 1 , ' y ' ) ; continue ; }
else { count += countX [ nextIndexY ] ;
nextIndexX = nextIndex ( str , nextIndexX + 1 , ' x ' ) ; } }
return count ; }
int main ( ) { string s = " xyyxx " ; cout << countSubStrings ( s ) ; }
string minimize ( string str ) { string mstr = " ▁ " ; int l , i , flagchar [ 26 ] = { 0 } ; char ch ; l = str . length ( ) ;
for ( i = 0 ; i < str . length ( ) ; i ++ ) { ch = str . at ( i ) ;
if ( flagchar [ ch - 97 ] == 0 ) { mstr = mstr + ch ; flagchar [ ch - 97 ] = 1 ; } }
}
void replaceMinimizeUtil ( string str ) { string minimizedStr , finalStr = " " ; int i , index , l ; char ch ; l = str . length ( ) ;
for ( i = 0 ; i < minimizedStr . length ( ) ; i ++ ) { ch = minimizedStr . at ( i ) ;
index = ( ch * ch ) % l ; finalStr = finalStr + str . at ( index ) ; }
}
int main ( ) { string str = " geeks " ; replaceMinimizeUtil ( str ) ; return 0 ; }
void cipher ( char str [ ] ) { for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( isalpha ( str [ i ] ) == 0 && str [ i ] != ' ▁ ' ) { printf ( " Enter ▁ only ▁ alphabets ▁ and ▁ space STRNEWLINE " ) ; return ; } } printf ( " Encrypted ▁ Code ▁ using ▁ Latin ▁ Alphabet STRNEWLINE " ) ; for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) printf ( " % d ▁ " , str [ i ] - ' A ' + 1 ) ; else if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) printf ( " % d ▁ " , str [ i ] - ' a ' + 1 ) ; if ( str [ i ] == ' ▁ ' ) printf ( " % c " , str [ i ] ) ; } printf ( " STRNEWLINE " ) ; }
int main ( ) { char str [ ] = " geeksforgeeks " ; cipher ( str ) ; return 0 ; }
int round ( int n ) {
int a = ( n / 10 ) * 10 ;
int b = a + 10 ;
return ( n - a > b - n ) ? b : a ; }
int main ( ) { int n = 4722 ; cout << round ( n ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countOccurrences ( string s , int K ) { int n = s . length ( ) ; int C , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' )
c1 ++ ; if ( s [ i ] == ' b ' ) {
c2 ++ ;
C += c1 ; } }
return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; }
int main ( ) { string S = " abcb " ; int k = 2 ; cout << countOccurrences ( S , k ) << endl ; return 0 ; }
string findString ( int n , int k ) {
string res = " " ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' a ' + i ) ;
int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; }
int main ( ) { int n = 5 , k = 2 ; cout << findString ( n , k ) ; return 0 ; }
bool isVowel ( char ch ) { ch = toupper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; }
int countVovels ( string str , int n ) { if ( n == 1 ) return isVowel ( str [ n - 1 ] ) ; return countVovels ( str , n - 1 ) + isVowel ( str [ n - 1 ] ) ; }
string str = " abc ▁ de " ;
cout << countVovels ( str , str . length ( ) ) << endl ; return 0 ; }
void printRotatedString ( char str [ ] ) { int n = strlen ( str ) ;
char temp [ 2 * n + 1 ] ; strcpy ( temp , str ) ; strcat ( temp , str ) ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) printf ( " % c " , temp [ i + j ] ) ; printf ( " STRNEWLINE " ) ; } }
int main ( ) { char str [ ] = " geeks " ; printRotatedString ( str ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define M  26
int getIdx ( char ch ) { return ( ch - ' a ' ) ; }
bool allSame ( int freq [ ] , int N ) { int same ;
int i ; for ( i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 0 ) { same = freq [ i ] ; break ; } }
for ( int j = i + 1 ; j < N ; j ++ ) if ( freq [ j ] > 0 && freq [ j ] != same ) return false ; return true ; }
bool possibleSameCharFreqByOneRemoval ( string str ) { int l = str . length ( ) ;
int freq [ M ] = { 0 } ; for ( int i = 0 ; i < l ; i ++ ) freq [ getIdx ( str [ i ] ) ] ++ ;
if ( allSame ( freq , M ) ) return true ;
for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int i = getIdx ( c ) ;
if ( freq [ i ] > 0 ) { freq [ i ] -- ; if ( allSame ( freq , M ) ) return true ; freq [ i ] ++ ; } } return false ; }
int main ( ) { string str = " xyyzz " ; if ( possibleSameCharFreqByOneRemoval ( str ) ) cout << " Yes " ; else cout << " No " ; }
int check ( string str ) { int n = str . length ( ) ;
int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ; else evenDigSum += ( str [ i ] - '0' ) ; }
return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; }
int main ( ) { string str = "76945" ; check ( str ) ? cout << " Yes " : cout << " No ▁ " ; return 0 ; }
int hammingDist ( char * str1 , char * str2 ) { int i = 0 , count = 0 ; while ( str1 [ i ] != ' \0' ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; }
int main ( ) { char str1 [ ] = " geekspractice " ; char str2 [ ] = " nerdspractise " ;
cout << hammingDist ( str1 , str2 ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; const int MAX_CHAR = 26 ;
bool arekAnagrams ( string str1 , string str2 , int k ) {
int n = str1 . length ( ) ; if ( str2 . length ( ) != n ) return false ; int count1 [ MAX_CHAR ] = { 0 } ; int count2 [ MAX_CHAR ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; int count = 0 ;
for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + abs ( count1 [ i ] - count2 [ i ] ) ;
return ( count <= k ) ; }
int main ( ) { string str1 = " anagram " ; string str2 = " grammar " ; int k = 2 ; if ( arekAnagrams ( str1 , str2 , k ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countSubStr ( char str [ ] ) {
for ( int i = 0 ; str [ i ] != ' \0' ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; }
return m * ( m - 1 ) / 2 ; }
int main ( ) { char str [ ] = "00100101" ; cout << countSubStr ( str ) ; return 0 ; }
#include <iostream> NEW_LINE #include <cstring> NEW_LINE using namespace std ; int count9s ( char number [ ] ) {
int n = strlen ( number ) ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( number [ i ] == '9' ) count ++ ;
for ( int j = i + 1 ; j < n ; j ++ ) {
sum = ( sum + number [ j ] - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; }
int main ( ) { cout << count9s ( "4189" ) << endl ; cout << count9s ( "1809" ) ; return 0 ; }
int minStepsRecur ( int height [ ] , int l , int r , int h ) {
if ( l >= r ) return 0 ;
int m = l ; for ( int i = l ; i < r ; i ++ ) if ( height [ i ] < height [ m ] ) m = i ;
return min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) ; }
int minSteps ( int height [ ] , int N ) { return minStepsRecur ( height , 0 , N , 0 ) ; }
int main ( ) { int height [ ] = { 2 , 1 , 2 , 5 , 1 } ; int N = sizeof ( height ) / sizeof ( int ) ; cout << minSteps ( height , N ) << endl ; return 0 ; }
float ReuleauxArea ( float a ) {
if ( a < 0 ) return -1 ;
float A = 0.70477 * pow ( a , 2 ) ; return A ; }
int main ( ) { float a = 6 ; cout << ReuleauxArea ( a ) << endl ; return 0 ; }
float hexagonside ( float a ) {
if ( a < 0 ) return -1 ;
float x = 0.5176 * a ; return x ; }
int main ( ) { float a = 6 ; cout << hexagonside ( a ) << endl ; return 0 ; }
float hexagonside ( float a ) {
if ( a < 0 ) return -1 ;
float x = a / 3 ; return x ; }
int main ( ) { float a = 6 ; cout << hexagonside ( a ) << endl ; return 0 ; }
int findSegment ( int n , int m , int segment_length [ ] ) {
double meet_point = ( 1.0 * n ) / 2.0 ; int sum = 0 ;
int segment_number = 0 ; for ( int i = 0 ; i < m ; i ++ ) {
sum += segment_length [ i ] ;
if ( ( double ) sum == meet_point ) { segment_number = -1 ; break ; }
if ( sum > meet_point ) { segment_number = i + 1 ; break ; } } return segment_number ; }
int main ( ) { int n = 13 ; int m = 3 ; int segment_length [ ] = { 3 , 2 , 8 } ; int ans = findSegment ( n , m , segment_length ) ; cout << ( ans ) ; return 0 ; }
ll countMaxIntersect ( ll n ) { return ( n ) * ( n - 1 ) / 2 ; }
ll n = 8 ; cout << countMaxIntersect ( n ) << endl ; return 0 ; }
float surfaceArea ( float a , float b , float h ) { return 5 * a * b + 5 * b * h ; }
float volume ( float b , float h ) { return ( 5 * b * h ) / 2 ; }
int main ( ) { float a = 5 ; float b = 3 ; float h = 7 ; cout << " surface ▁ area = ▁ " << surfaceArea ( a , b , h ) << " , ▁ " ; cout << " volume = ▁ " << volume ( b , h ) ; }
int checkpoint ( int h , int k , int x , int y , int a ) {
int p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; }
int main ( ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 ; if ( checkpoint ( h , k , x , y , a ) > 0 ) cout << " Outside " << endl ; else if ( checkpoint ( h , k , x , y , a ) == 0 ) cout << " On ▁ the ▁ parabola " << endl ; else cout << " Inside " << endl ; return 0 ; }
int checkpoint ( int h , int k , int x , int y , int a , int b ) {
int p = ( pow ( ( x - h ) , 2 ) / pow ( a , 2 ) ) + ( pow ( ( y - k ) , 2 ) / pow ( b , 2 ) ) ; return p ; }
int main ( ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 , b = 5 ; if ( checkpoint ( h , k , x , y , a , b ) > 1 ) cout << " Outside " << endl ; else if ( checkpoint ( h , k , x , y , a , b ) == 1 ) cout << " On ▁ the ▁ ellipse " << endl ; else cout << " Inside " << endl ; return 0 ; }
float circlearea ( float a , float b ) {
if ( a < 0 b < 0 ) return -1 ;
float A = ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ; return A ; }
int main ( ) { float a = 8 , b = 10 ; cout << circlearea ( a , b ) << endl ; return 0 ; }
float circlearea ( float l , float b ) {
if ( l < 0 b < 0 ) return -1 ;
if ( l < b ) return 3.14 * pow ( l / 2 , 2 ) ; else return 3.14 * pow ( b / 2 , 2 ) ; }
int main ( ) { float l = 4 , b = 8 ; cout << circlearea ( l , b ) << endl ; return 0 ; }
int centered_cube ( int n ) {
return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; }
int main ( ) { int n = 3 ; cout << n << " th ▁ Centered ▁ cube ▁ number : ▁ " ; cout << centered_cube ( n ) ; cout << endl ; n = 10 ; cout << n << " th ▁ Centered ▁ cube ▁ number : ▁ " ; cout << centered_cube ( n ) ; return 0 ; }
void center ( int x1 , int x2 , int y1 , int y2 ) { cout << ( float ) ( x1 + x2 ) / 2 << " , ▁ " << ( float ) ( y1 + y2 ) / 2 ; }
int main ( ) { int x1 = -9 , y1 = 3 , x2 = 5 , y2 = -7 ; center ( x1 , x2 , y1 , y2 ) ; return 0 ; }
double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( sqrt ( 2 ) / 3 ) ) ; }
int main ( ) { double side = 3 ; cout << " Volume ▁ of ▁ octahedron ▁ = " << vol_of_octahedron ( side ) << endl ; }
float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; }
int main ( ) { float r1 = 2.3 , r2 = 3.4 , r3 = 5.7 ; cout << " volume ▁ of ▁ ellipsoid ▁ is ▁ : ▁ " << volumeOfEllipsoid ( r1 , r2 , r3 ) ; return 0 ; }
double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + sqrt ( 2 ) ) * side * side ) ; }
int main ( ) { double side = 4 ; cout << " Area ▁ of ▁ Regular ▁ Octagon ▁ = ▁ " << areaOctagon ( side ) << endl ; return 0 ; }
double areaCube ( double a ) { return ( a * a * a ) ; } double surfaceCube ( double a ) { return ( 6 * a * a ) ; }
int main ( ) { double a = 5 ; cout << " Area ▁ = ▁ " << areaCube ( a ) << endl ; cout << " Total ▁ surface ▁ area ▁ = ▁ " << surfaceCube ( a ) ; return 0 ; }
int minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return ceil ( d / ( 2 * r ) ) ; }
int main ( ) { int r = 2 , x1 = 0 , y1 = 0 , x2 = 0 , y2 = 4 ; cout << minRevolutions ( r , x1 , y1 , x2 , y2 ) ; return 0 ; }
#define eps  1e-6
double getArea ( double base , double hypotenuse ) { double height = sqrt ( hypotenuse * hypotenuse - base * base ) ; return 0.5 * base * height ; }
void printRightAngleTriangle ( int hypotenuse , int area ) { int hsquare = hypotenuse * hypotenuse ;
double sideForMaxArea = sqrt ( hsquare / 2.0 ) ; double maxArea = getArea ( sideForMaxArea , hypotenuse ) ;
if ( area > maxArea ) { cout << " Not ▁ possiblen " ; return ; } double low = 0.0 ; double high = sideForMaxArea ; double base ;
while ( abs ( high - low ) > eps ) { base = ( low + high ) / 2.0 ; if ( getArea ( base , hypotenuse ) >= area ) high = base ; else low = base ; }
double height = sqrt ( hsquare - base * base ) ; cout << base << " ▁ " << height << endl ; }
int main ( ) { int hypotenuse = 5 ; int area = 6 ; printRightAngleTriangle ( hypotenuse , area ) ; return 0 ; }
int countLattice ( int r ) { if ( r <= 0 ) return 0 ;
int result = 4 ;
for ( int x = 1 ; x < r ; x ++ ) {
int ySquare = r * r - x * x ; int y = sqrt ( ySquare ) ;
if ( y * y == ySquare ) result += 4 ; } return result ; }
int main ( ) { int r = 5 ; cout << countLattice ( r ) ; return 0 ; }
int power ( int x , unsigned int y , int p ) {
int res = 1 ;
x = x % p ; while ( y > 0 ) {
if ( y & 1 ) res = ( res * x ) % p ;
x = ( x * x ) % p ; } return res ; }
int main ( ) { int L = 2 , P = pow ( 10 , 9 ) ; int ans = power ( 325 , L , P ) ; cout << ans << " STRNEWLINE " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAXN  30
int countMaxLength ( int N ) {
int res ;
int pre [ MAXN ] , p = 1 ;
pre [ 0 ] = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { p *= 2 ; pre [ i ] = pre [ i - 1 ] + i * p ; }
int ind ;
for ( int i = 1 ; i < MAXN ; i ++ ) { if ( pre [ i ] >= N ) { ind = i ; break ; } } int x = N - pre [ ind - 1 ] ; int y = 2 * ind - 1 ; if ( x >= y ) res = min ( x , y ) ; else res = max ( x , 2 * ( ind - 2 ) + 1 ) ; return res ; }
int main ( ) { int N = 25 ; cout << countMaxLength ( N ) ; return 0 ; }
int factorialUsingRecursion ( int n ) { if ( n == 0 ) return 1 ;
return n * factorialUsingRecursion ( n - 1 ) ; }
int factorialUsingIteration ( int n ) { int res = 1 , i ;
for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; }
int main ( ) { int num = 5 ; cout << " Factorial ▁ of ▁ " << num << " ▁ using ▁ Recursion ▁ is : ▁ " << factorialUsingRecursion ( 5 ) << endl ; cout << " Factorial ▁ of ▁ " << num << " ▁ using ▁ Iteration ▁ is : ▁ " << factorialUsingIteration ( 5 ) ; return 0 ; }
int maxSum ( int arr [ ] , int n , int K ) {
int maximum = INT_MIN ;
int sum [ n ] = { 0 } ;
for ( int i = n - 1 ; i >= 0 ; i -- ) {
if ( i + K < n ) sum [ i ] = sum [ i + K ] + arr [ i ] ; else sum [ i ] = arr [ i ] ;
maximum = max ( maximum , sum [ i ] ) ; } return maximum ; }
int main ( ) { int arr [ ] = { 3 , 6 , 4 , 7 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 2 ; cout << maxSum ( arr , n , K ) ; return ( 0 ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void findpair ( int l , int r ) { int c = 0 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { cout << i << " , ▁ " << j ; c = 1 ; break ; } } if ( c == 1 ) break ; } }
int main ( ) { int l = 1 , r = 10 ; findpair ( l , r ) ; }
bool check ( int arr [ ] , int N , int K ) {
set < int > unique ;
if ( unique . size ( ) == K ) return true ; return false ; }
int main ( ) { int arr [ ] = { 1 , 1 , 2 , 3 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int K = 3 ; if ( check ( arr , N , K ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int minIndex ( int arr [ ] , int n , int pos ) { int num = arr [ pos ] ;
int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; }
return i + 1 ; }
int main ( ) { int arr [ ] = { 2 , 1 , 1 , 1 , 5 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int pos = 4 ;
cout << minIndex ( arr , n , pos ) ; return 0 ; }
int findAnswer ( string str1 , string str2 , int n ) { int l , r ; int ans = 2 ;
for ( int i = 0 ; i < n ; ++ i ) { if ( str1 [ i ] != str2 [ i ] ) { l = i ; break ; } }
for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str1 [ i ] != str2 [ i ] ) { r = i ; break ; } }
if ( r < l ) return 26 * ( n + 1 ) ;
else if ( l == r ) return ans ; else {
for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 [ i ] != str2 [ i - 1 ] ) { ans -- ; break ; } }
for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 [ i - 1 ] != str2 [ i ] ) { ans -- ; break ; } } return ans ; } }
int main ( ) { string str1 = " toy " , str2 = " try " ; int n = str1 . length ( ) ; cout << findAnswer ( str1 , str2 , n ) ; return 0 ; }
int findMinDifference ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int diff1 = arr [ n - 1 ] - arr [ 1 ] ;
int diff2 = arr [ n - 2 ] - arr [ 0 ] ;
return min ( diff1 , diff2 ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findMinDifference ( arr , n ) ; return 0 ; }
int findMinDifference ( int arr [ ] , int n ) { int min__ , secondMin , max__ , secondMax ; min__ = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max__ = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) {
if ( arr [ i ] > max__ ) {
secondMax = max__ ;
max__ = arr [ i ] ; }
else if ( arr [ i ] > secondMax ) {
secondMax = arr [ i ] ; }
else if ( arr [ i ] < min__ ) {
secondMin = min__ ;
min__ = arr [ i ] ; }
else if ( arr [ i ] < secondMin ) {
secondMin = arr [ i ] ; } }
int diff = min ( max__ - secondMin , secondMax - min__ ) ; return diff ; }
int main ( ) { int arr [ ] = { 1 , 2 , 4 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << ( findMinDifference ( arr , n ) ) ; }
bool checkDistinct ( int x ) {
int last = x % 10 ;
while ( x ) { if ( x % 10 != last ) return false ;
x = x / 10 ; } return true ; }
int findCount ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) {
if ( checkDistinct ( i ) ) count += 1 ; } return count ; }
int main ( ) { int L = 10 , R = 50 ; cout << findCount ( L , R ) ; return 0 ; }
int smallest_pair ( int a [ ] , int n ) { int min = INT_MAX , secondMin = INT_MAX ; for ( int j = 0 ; j < n ; j ++ ) {
if ( a [ j ] < min ) {
secondMin = min ;
min = a [ j ] ; }
else if ( ( a [ j ] < secondMin ) && a [ j ] != min )
secondMin = a [ j ] ; }
return ( secondMin + min ) ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << smallest_pair ( arr , n ) ; return 0 ; }
int longestsubarray ( int arr [ ] , int n , int k ) { int current_count = 0 ;
int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = max ( current_count , max_count ) ; } return max_count ; }
int main ( ) { int arr [ ] = { 2 , 5 , 11 , 32 , 64 , 88 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 8 ; cout << longestsubarray ( arr , n , k ) ; return 0 ; }
bool check ( string s ) { for ( int i = 0 ; i < s . length ( ) - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; }
int main ( ) { string s = " xzyyz " ; if ( check ( s ) ) cout << " YES " << endl ; else cout << " NO " << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int countAnomalies ( int arr [ ] , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; }
int main ( ) { int arr [ ] = { 7 , 1 , 8 } , k = 5 ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << countAnomalies ( arr , n , k ) ; return 0 ; }
int colMaxDiff ( int mat [ N ] [ N ] ) { int max_diff = INT_MIN ;
for ( int i = 0 ; i < N ; i ++ ) {
int max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = max ( max_val , mat [ j ] [ i ] ) ; min_val = min ( min_val , mat [ j ] [ i ] ) ; }
max_diff = max ( max_diff , max_val - min_val ) ; } return max_diff ; }
int main ( ) { int mat [ N ] [ N ] = { { 1 , 2 , 3 , 4 , 5 } , { 5 , 3 , 5 , 4 , 0 } , { 5 , 6 , 7 , 8 , 9 } , { 0 , 6 , 3 , 4 , 12 } , { 9 , 7 , 12 , 4 , 3 } , } ; cout << " Max ▁ difference ▁ : ▁ " << colMaxDiff ( mat ) << endl ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int search ( int ar [ ] , int size ) { int a = 0 , b = size - 1 ; int mid ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; }
int main ( ) { int ar [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 8 } ; int size = sizeof ( ar ) / sizeof ( ar [ 0 ] ) ; cout << " Missing ▁ number : " << search ( ar , size ) ; }
int deleteElement ( int A [ ] , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } }
return j ; }
int main ( ) { int A [ ] = { 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 } ; int L = 2 , R = 7 ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; int res_size = deleteElement ( A , L , R , n ) ; for ( int i = 0 ; i < res_size ; i ++ ) cout << A [ i ] << " ▁ " ; return 0 ; }
#include <iostream> NEW_LINE using namespace std ; int findmissing ( int ar [ ] , int N ) { int l = 0 , r = N - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ;
if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return mid + 1 ;
if ( ar [ mid ] != mid + 1 ) r = mid - 1 ;
else l = mid + 1 ; }
return -1 ; }
int main ( ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int N = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findmissing ( arr , N ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFirst ( int arr [ ] , int n , int x ) { sort ( arr , arr + n ) ;
int * ptr = lower_bound ( arr , arr + n , x ) ;
return ( * ptr != x ) ? -1 : ( ptr - arr ) ; }
int main ( ) { int x = 20 , arr [ ] = { 10 , 30 , 20 , 50 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findFirst ( arr , n , x ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int findFirst ( int arr [ ] , int n , int x ) { int count = 0 ; bool isX = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) isX = true ; else if ( arr [ i ] < x ) count ++ ; } return ( isX == false ) ? -1 : count ; }
int main ( ) { int x = 20 , arr [ ] = { 10 , 30 , 20 , 50 , 20 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << findFirst ( arr , n , x ) ; return 0 ; }
int findDuplicate ( int arr [ ] ) {
int slow = arr [ 0 ] ; int fast = arr [ 0 ] ; do { slow = arr [ slow ] ; fast = arr [ arr [ fast ] ] ; } while ( slow != fast ) ;
int ptr1 = arr [ 0 ] ; int ptr2 = slow ; while ( ptr1 != ptr2 ) { ptr1 = arr [ ptr1 ] ; ptr2 = arr [ ptr2 ] ; } return ptr1 ; }
int main ( ) { int arr [ ] = { 1 , 3 , 2 , 1 } ; cout << findDuplicate ( arr ) << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MAX_CHAR  26 NEW_LINE void printGreaterCount ( string str ) { int len = str . length ( ) ;
int ans [ len ] = { 0 } , count [ MAX_CHAR ] = { 0 } ;
for ( int i = len - 1 ; i >= 0 ; i -- ) { count [ str [ i ] - ' a ' ] ++ ; for ( int j = str [ i ] - ' a ' + 1 ; j < MAX_CHAR ; j ++ ) ans [ i ] += count [ j ] ; } for ( int i = 0 ; i < len ; i ++ ) cout << ans [ i ] << " ▁ " ; }
int main ( ) { string str = " abcd " ; printGreaterCount ( str ) ; return 0 ; }
int maxProduct ( int arr [ ] , int n ) {
if ( n < 4 ) return -1 ;
int maxA = INT_MIN , maxB = INT_MIN , maxC = INT_MIN , maxD = INT_MIN ;
int minA = INT_MAX , minB = INT_MAX , minC = INT_MAX , minD = INT_MAX ; for ( int i = 0 ; i < n ; i ++ ) {
if ( arr [ i ] > maxA ) { maxD = maxC ; maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; }
else if ( arr [ i ] > maxB ) { maxD = maxC ; maxC = maxB ; maxB = arr [ i ] ; }
else if ( arr [ i ] > maxC ) { maxD = maxC ; maxC = arr [ i ] ; }
else if ( arr [ i ] > maxD ) maxD = arr [ i ] ;
if ( arr [ i ] < minA ) { minD = minC ; minC = minB ; minB = minA ; minA = arr [ i ] ; }
else if ( arr [ i ] < minB ) { minD = minC ; minC = minB ; minB = arr [ i ] ; }
else if ( arr [ i ] < minC ) { minD = minC ; minC = arr [ i ] ; }
else if ( arr [ i ] < minD ) minD = arr [ i ] ; } int x = maxA * maxB * maxC * maxD ; int y = minA * minB * minC * minD ; int z = minA * minB * maxA * maxB ;
return max ( x , max ( y , z ) ) ; }
int main ( ) { int arr [ ] = { 1 , -4 , 3 , -6 , 7 , 0 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int max = maxProduct ( arr , n ) ; if ( max == -1 ) cout << " No ▁ Quadruple ▁ Exists " ; else cout << " Maximum ▁ product ▁ is ▁ " << max ; return 0 ; }
int countTripletsLessThanL ( int n , int L , int * arr ) {
sort ( arr , arr + n ) ; int ways = 0 ;
for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) {
int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; }
int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int L = 3 ; int ans = countTripletsLessThanL ( n , L , arr ) ; cout << " Total ▁ Number ▁ of ▁ ways ▁ = ▁ " << ans << " STRNEWLINE " ; return 0 ; }
int missingNum ( int arr [ ] , int n ) { int minvalue = * min_element ( arr , arr + n ) ;
int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; }
return xornum ^ minvalue ; }
int main ( ) { int arr [ ] = { 13 , 12 , 11 , 15 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << missingNum ( arr , n ) ; return 0 ; }
int findLastIndex ( string & str , char x ) { int index = -1 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; }
string str = " geeksforgeeks " ;
char x = ' e ' ; int index = findLastIndex ( str , x ) ; if ( index == -1 ) cout << " Character ▁ not ▁ found " ; else cout << " Last ▁ index ▁ is ▁ " << index ; return 0 ; }
int findLastIndex ( string & str , char x ) {
for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return -1 ; }
int main ( ) { string str = " geeksforgeeks " ; char x = ' e ' ; int index = findLastIndex ( str , x ) ; if ( index == -1 ) cout << " Character ▁ not ▁ found " ; else cout << " Last ▁ index ▁ is ▁ " << index ; return 0 ; }
int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; }
int main ( ) { int l = 1 , r = 5 ; cout << countMaxSetBits ( l , r ) << " STRNEWLINE " ; l = 1 , r = 10 ; cout << countMaxSetBits ( l , r ) ; return 0 ; }
int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ;
while ( l <= r ) {
int mid = ( l + r ) / 2 ;
int sum = mid * ( mid + 1 ) / 2 ;
if ( sum == s ) return mid ;
else if ( sum > s ) r = mid - 1 ;
else l = mid + 1 ; }
return -1 ; }
int main ( ) { int s = 15 ; int n = findS ( s ) ; n == -1 ? cout << " - 1" : cout << n ; return 0 ; }
void pendulumArrangement ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ; int odd , temp , in , pos ;
pos = n - 1 ;
if ( n % 2 == 0 ) odd = n - 1 ; else odd = n - 2 ;
while ( odd > 0 ) { temp = arr [ odd ] ; in = odd ;
while ( in != pos ) { arr [ in ] = arr [ in + 1 ] ; in ++ ; } arr [ in ] = temp ; odd = odd - 2 ; pos = pos - 1 ; }
int start = 0 , end = ( n - 1 ) / 2 ; for ( ; start < end ; start ++ , end -- ) { temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; }
for ( int i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 11 , 2 , 4 , 55 , 6 , 8 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pendulumArrangement ( arr , n ) ; return 0 ; }
int findNumber ( int arr [ ] , int n ) {
sort ( arr , arr + n ) ;
int max = arr [ n - 1 ] ;
int table [ ( 2 * max ) + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = INT_MAX ; int ans = -1 ;
for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { int res = table [ i - arr [ j ] ] ; if ( res != INT_MAX && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } }
if ( i > arr [ n - 1 ] && table [ i ] == INT_MAX ) { ans = i ; break ; } } return ans ; }
int main ( ) { int arr [ ] = { 6 , 7 , 15 } ; int n = ( sizeof ( arr ) / sizeof ( int ) ) ; cout << findNumber ( arr , n ) ; return 0 ; }
int countPoints ( int n , int m , vector < int > a , vector < int > b , int x , int y ) {
sort ( a . begin ( ) , a . end ( ) ) ; sort ( b . begin ( ) , b . end ( ) ) ;
int j = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
while ( j < m ) {
if ( a [ i ] + y < b [ j ] ) break ;
if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; }
else j ++ ; } }
return count ; }
int main ( ) { int x = 1 , y = 4 ; vector < int > a = { 1 , 5 } ; int n = a . size ( ) ; vector < int > b = { 1 , 1 , 2 } ; int m = a . size ( ) ; cout << countPoints ( n , m , a , b , x , y ) ; return 0 ; }
int minSubarray ( int A [ ] , int n ) {
int minValue = * min_element ( A , A + n ) ; int maxValue = * max_element ( A , A + n ) ; int pos_min = -1 , pos_max = -1 , ans = INT_MAX ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( A [ i ] == minValue ) pos_min = i ;
if ( A [ i ] == maxValue ) pos_max = i ; if ( pos_max != -1 and pos_min != -1 ) ans = min ( ans , abs ( pos_min - pos_max ) + 1 ) ; } return ans ; }
int main ( ) { int A [ ] = { 1 , 5 , 9 , 7 , 1 , 9 , 4 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minSubarray ( A , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int countSequences ( int arr [ ] , int n ) { int count = 1 ; sort ( arr , arr + n ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; }
int main ( ) { int arr [ ] = { 1 , 7 , 3 , 5 , 10 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << countSequences ( arr , n ) ; return 0 ; }
long long minimumMoves ( int a [ ] , int n ) { long long operations = 0 ;
sort ( a , a + n ) ;
for ( int i = 0 ; i < n ; i ++ ) operations += abs ( a [ i ] - ( i + 1 ) ) ; return operations ; }
int main ( ) { int arr [ ] = { 5 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << minimumMoves ( arr , n ) ; return 0 ; }
void printCase ( int n ) {
if ( n <= 2 ) { cout << -1 ; return ; } for ( int i = n ; i >= 1 ; i -- ) cout << i << " ▁ " ; }
int main ( ) { int n = 3 ; printCase ( n ) ; return 0 ; }
void findMissingNumber ( vector < pair < int , int > > ranges , int m ) {
sort ( ranges . begin ( ) , ranges . end ( ) ) ;
vector < int > ans ;
int prev = 0 ;
for ( int j = 0 ; j < ranges . size ( ) ; j ++ ) { int start = ranges [ j ] . first ; int end = ranges [ j ] . second ; for ( int i = prev + 1 ; i < start ; i ++ ) ans . push_back ( i ) ; prev = end ; }
for ( int i = prev + 1 ; i <= m ; i ++ ) ans . push_back ( i ) ;
for ( int i = 0 ; i < ans . size ( ) ; i ++ ) { if ( ans [ i ] <= m ) cout << ans [ i ] << " ▁ " ; } }
int main ( ) { int N = 2 , M = 6 ;
vector < pair < int , int > > ranges ; ranges . push_back ( { 1 , 2 } ) ; ranges . push_back ( { 4 , 5 } ) ; findMissingNumber ( ranges , M ) ; return 0 ; }
static bool check ( int n , int k , int * a , int * b ) {
sort ( a , a + n ) ; sort ( b , b + n ) ;
bool fl = false ;
int ind = -1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) {
if ( fl == true ) { return false ; } fl = true ; ind = i ; } }
if ( ind == -1 | abs ( a [ ind ] - b [ ind ] ) <= k ) { return true ; } return false ; }
int main ( ) { int n = 2 , k = 4 ; int a [ ] = { 1 , 5 } ; int b [ ] = { 1 , 1 } ; if ( check ( n , k , a , b ) ) { printf ( " Yes " ) ; } else { printf ( " No " ) ; } return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; #define MOD  1000000007
int SubseqWidths ( int A [ ] , int n ) {
sort ( A , A + n ) ; int pow2 [ n ] ; pow2 [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; }
int main ( ) { int A [ ] = { 5 , 6 , 4 , 3 , 8 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << SubseqWidths ( A , n ) ; return 0 ; }
int maxArrayCover ( vector < int > a , int n , int x ) {
sort ( a . begin ( ) , a . end ( ) ) ;
int cc = 0 ;
int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += a [ i ] ;
if ( s > x ) { break ; }
cc += 1 ; }
if ( accumulate ( a . begin ( ) , a . end ( ) , 0 ) == x ) { return n ; } else {
if ( cc == n ) { return n - 1 ; } else { return cc ; } } }
int main ( ) { int n = 3 ; int x = 70 ; vector < int > a = { 10 , 20 , 30 } ; printf ( " % d STRNEWLINE " , maxArrayCover ( a , n , x ) ) ; return 0 ; }
int maximumSOP ( int * a , int * b ) {
int sop = 0 ;
int n = sizeof ( a ) / sizeof ( a [ 0 ] ) ;
sort ( a , a + n + 1 ) ; sort ( b , b + n + 1 ) ;
for ( int i = 0 ; i <= n ; i ++ ) { sop += a [ i ] * b [ i ] ; } return sop ; }
int main ( ) { int A [ ] = { 1 , 2 , 3 } ; int B [ ] = { 4 , 5 , 1 } ; cout << maximumSOP ( A , B ) ; return 0 ; }
int countTriplets ( int arr [ ] , int n , int m ) { int count = 0 ;
sort ( arr , arr + n ) ; int end , start , mid ;
for ( end = n - 1 ; end >= 2 ; end -- ) { int start = 0 , mid = end - 1 ; while ( start < mid ) {
long int prod = arr [ end ] * arr [ start ] * arr [ mid ] ;
if ( prod > m ) mid -- ;
else if ( prod < m ) start ++ ;
else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; }
int main ( ) { int arr [ ] = { 1 , 1 , 1 , 1 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int m = 1 ; cout << countTriplets ( arr , n , m ) ; return 0 ; }
#include <algorithm> NEW_LINE #include <iostream> NEW_LINE using namespace std ; int sort3 ( int arr [ ] ) {
if ( arr [ 1 ] < arr [ 0 ] ) swap ( arr [ 0 ] , arr [ 1 ] ) ;
if ( arr [ 2 ] < arr [ 1 ] ) { swap ( arr [ 1 ] , arr [ 2 ] ) ; if ( arr [ 1 ] < arr [ 0 ] ) swap ( arr [ 1 ] , arr [ 0 ] ) ; } }
int main ( ) { int a [ ] = { 10 , 12 , 5 } ; sort3 ( a ) ; for ( int i = 0 ; i < 3 ; i ++ ) cout << a [ i ] << " ▁ " ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; int printTriplets ( int arr [ ] , int n , int sum ) {
sort ( arr , arr + n ) ;
for ( int i = 0 ; i < n - 2 ; i ++ ) {
int j = i + 1 , k = n - 1 ;
while ( j < k ) {
if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ;
else {
for ( int x = j + 1 ; x <= k ; x ++ ) cout << arr [ i ] << " , ▁ " << arr [ j ] << " , ▁ " << arr [ x ] << endl ; j ++ ; } } } }
int main ( ) { int arr [ ] = { 5 , 1 , 3 , 4 , 7 } ; int n = sizeof arr / sizeof arr [ 0 ] ; int sum = 12 ; printTriplets ( arr , n , sum ) ; return 0 ; }
bool checkFittingArrays ( int A [ ] , int B [ ] , int N ) {
sort ( A , A + N ) ; sort ( B , B + N ) ;
for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; }
int main ( ) { int A [ ] = { 7 , 5 , 3 , 2 } ; int B [ ] = { 5 , 4 , 8 , 7 } ; int N = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( checkFittingArrays ( A , B , N ) ) cout << " YES " ; else cout << " NO " ; return 0 ; }
int maximum_toys ( int cost [ ] , int N , int K ) { int count = 0 , sum = 0 ;
sort ( cost , cost + N ) ; for ( int i = 0 ; i < N ; i ++ ) {
if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ;
count ++ ; } } return count ; }
int main ( ) { int K = 50 ; int cost [ ] = { 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 } ; int N = sizeof ( cost ) / sizeof ( cost [ 0 ] ) ; cout << maximum_toys ( cost , N , K ) << endl ; return 0 ; }
bool almostSort ( int A [ ] , int n ) {
for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { swap ( A [ i ] , A [ i + 1 ] ) ; i ++ ; } }
for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ;
return true ; }
int main ( ) { int A [ ] = { 1 , 3 , 2 , 4 , 6 , 5 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; if ( almostSort ( A , n ) ) cout << " Yes " ; else cout << " No " ; return 0 ; }
int nextGap ( int gap ) { if ( gap <= 1 ) return 0 ; return ( gap / 2 ) + ( gap % 2 ) ; } void merge ( int * arr1 , int * arr2 , int n , int m ) { int i , j , gap = n + m ; for ( gap = nextGap ( gap ) ; gap > 0 ; gap = nextGap ( gap ) ) {
for ( i = 0 ; i + gap < n ; i ++ ) if ( arr1 [ i ] > arr1 [ i + gap ] ) swap ( arr1 [ i ] , arr1 [ i + gap ] ) ;
for ( j = gap > n ? gap - n : 0 ; i < n && j < m ; i ++ , j ++ ) if ( arr1 [ i ] > arr2 [ j ] ) swap ( arr1 [ i ] , arr2 [ j ] ) ; if ( j < m ) {
for ( j = 0 ; j + gap < m ; j ++ ) if ( arr2 [ j ] > arr2 [ j + gap ] ) swap ( arr2 [ j ] , arr2 [ j + gap ] ) ; } } }
int main ( ) { int a1 [ ] = { 10 , 27 , 38 , 43 , 82 } ; int a2 [ ] = { 3 , 9 } ; int n = sizeof ( a1 ) / sizeof ( int ) ; int m = sizeof ( a2 ) / sizeof ( int ) ;
merge ( a1 , a2 , n , m ) ; printf ( " First ▁ Array : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) printf ( " % d ▁ " , a1 [ i ] ) ; printf ( " Second Array : " for ( int i = 0 ; i < m ; i ++ ) printf ( " % d ▁ " , a2 [ i ] ) ; printf ( " STRNEWLINE " ) ; return 0 ; }
void mergeArrays ( int arr1 [ ] , int arr2 [ ] , int n1 , int n2 , int arr3 [ ] ) { int i = 0 , j = 0 , k = 0 ;
while ( i < n1 && j < n2 ) {
if ( arr1 [ i ] < arr2 [ j ] ) arr3 [ k ++ ] = arr1 [ i ++ ] ; else arr3 [ k ++ ] = arr2 [ j ++ ] ; }
while ( i < n1 ) arr3 [ k ++ ] = arr1 [ i ++ ] ;
while ( j < n2 ) arr3 [ k ++ ] = arr2 [ j ++ ] ; }
int main ( ) { int arr1 [ ] = { 1 , 3 , 5 , 7 } ; int n1 = sizeof ( arr1 ) / sizeof ( arr1 [ 0 ] ) ; int arr2 [ ] = { 2 , 4 , 6 , 8 } ; int n2 = sizeof ( arr2 ) / sizeof ( arr2 [ 0 ] ) ; int arr3 [ n1 + n2 ] ; mergeArrays ( arr1 , arr2 , n1 , n2 , arr3 ) ; cout << " Array ▁ after ▁ merging " << endl ; for ( int i = 0 ; i < n1 + n2 ; i ++ ) cout << arr3 [ i ] << " ▁ " ; return 0 ; }
int findMinDiff ( int arr [ ] , int n , int m ) {
if ( m == 0 n == 0 ) return 0 ;
sort ( arr , arr + n ) ;
if ( n < m ) return -1 ;
int min_diff = INT_MAX ;
for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; }
int main ( ) { int arr [ ] = { 12 , 4 , 7 , 9 , 2 , 23 , 25 , 41 , 30 , 40 , 28 , 42 , 30 , 44 , 48 , 43 , 50 } ;
int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Minimum ▁ difference ▁ is ▁ " << findMinDiff ( arr , n , m ) ; return 0 ; }
int distinctCount ( int arr [ ] , int n ) {
int count = n ; int i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) {
while ( i != j && arr [ i ] == arr [ i + 1 ] ) count -- , i ++ ;
while ( i != j && arr [ j ] == arr [ j - 1 ] ) count -- , j -- ;
if ( i == j ) break ;
sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) {
count -- ; i ++ , j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; }
int main ( ) { int arr [ ] = { -2 , -1 , 0 , 1 , 1 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Count ▁ of ▁ absolute ▁ distinct ▁ values ▁ : ▁ " << distinctCount ( arr , n ) ; return 0 ; }
void sortByOneSwap ( int arr [ ] , int n ) {
for ( int i = n - 1 ; i > 0 ; i -- ) {
if ( arr [ i ] < arr [ i - 1 ] ) {
int j = i - 1 ; while ( j >= 0 && arr [ i ] < arr [ j ] ) j -- ;
swap ( arr [ i ] , arr [ j + 1 ] ) ; break ; } } }
void printArray ( int arr [ ] , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) cout << arr [ i ] << " ▁ " ; cout << endl ; }
int main ( ) { int arr [ ] = { 10 , 30 , 20 , 40 , 50 , 60 , 70 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; cout << " Given ▁ array ▁ is ▁ STRNEWLINE " ; printArray ( arr , n ) ; sortByOneSwap ( arr , n ) ; cout << " Sorted ▁ array ▁ is ▁ STRNEWLINE " ; printArray ( arr , n ) ; return 0 ; }
void flip ( int arr [ ] , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } }
int findMax ( int arr [ ] , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; }
void pancakeSort ( int * arr , int n ) {
for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) {
int mi = findMax ( arr , curr_size ) ;
if ( mi != curr_size - 1 ) {
flip ( arr , mi ) ;
flip ( arr , curr_size - 1 ) ; } } }
void printArray ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << " ▁ " ; }
int main ( ) { int arr [ ] = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; pancakeSort ( arr , n ) ; cout << " Sorted ▁ Array ▁ " << endl ; printArray ( arr , n ) ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ;
string get_maximum ( string s , int a [ ] ) { int n = s . size ( ) ;
for ( int i = 0 ; i < n ; i ++ ) {
if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ;
while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = '0' + a [ s [ j ] - '0' ] ; j ++ ; } return s ; } }
return s ; }
int main ( ) { string s = "1337" ; int a [ ] = { 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 } ; cout << get_maximum ( s , a ) ; return 0 ; }
int countSteps ( int n ) {
int steps = 0 ;
while ( n ) {
int largest = sqrt ( n ) ; n -= ( largest * largest ) ;
steps ++ ; }
return steps ; }
int main ( ) { int n = 85 ; cout << countSteps ( n ) ; return 0 ; }
int sumArr ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; }
int maxSum ( int arr [ ] , int n , int k ) {
sort ( arr , arr + n ) ; int i = 0 ;
while ( i < n && k > 0 && arr [ i ] < 0 ) { arr [ i ] *= -1 ; k -- ; i ++ ; }
if ( k % 2 == 1 ) {
int min = 0 ; for ( i = 1 ; i < n ; i ++ )
if ( arr [ min ] > arr [ i ] ) min = i ;
arr [ min ] *= -1 ; }
return sumArr ( arr , n ) ; }
int main ( ) { int arr [ ] = { -5 , 4 , 1 , 3 , 2 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ; int k = 4 ; cout << maxSum ( arr , n , k ) << endl ; return 0 ; }
int Maxsum ( int c1 , int c2 , int c3 , int c4 ) {
int sum = 0 ;
int two34 = min ( c2 , min ( c3 , c4 ) ) ;
sum = two34 * 234 ;
c2 -= two34 ;
sum += min ( c2 , c1 ) * 12 ;
return sum ; }
int main ( ) { int c1 = 5 , c2 = 2 , c3 = 3 , c4 = 4 ; cout << Maxsum ( c1 , c2 , c3 , c4 ) ; return 0 ; }
int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ;
ans += n * ( a / n ) * ( b / n ) ;
ans += ( a / n ) * ( b % n ) ;
ans += ( a % n ) * ( b / n ) ;
ans += ( ( a % n ) + ( b % n ) ) / n ;
return ans ; }
int main ( ) { int a = 5 , b = 13 , n = 3 ; cout << findCountOfPairs ( a , b , n ) ; return 0 ; }
void findArray ( int N , int P ) {
int ans = ( P * ( P + 1 ) ) / 2 + ( N - P ) ;
int arr [ N + 1 ] ;
for ( int i = 1 ; i <= P ; i ++ ) arr [ i ] = i ;
for ( int i = P + 1 ; i <= N ; i ++ ) arr [ i ] = 1 ; cout << " The ▁ Minimum ▁ Possible ▁ Sum ▁ is : ▁ " << ans << " STRNEWLINE " ; cout << " The ▁ Array ▁ Elements ▁ are : ▁ STRNEWLINE " ; for ( int i = 1 ; i <= N ; i ++ ) cout << arr [ i ] << ' ▁ ' ; }
int main ( ) { int N = 5 , P = 3 ; findArray ( N , P ) ; return 0 ; }
void findIntersection ( int intervals [ ] [ 2 ] , int N ) {
int l = intervals [ 0 ] [ 0 ] ; int r = intervals [ 0 ] [ 1 ] ;
for ( int i = 1 ; i < N ; i ++ ) {
if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { cout << -1 ; return ; }
else { l = max ( l , intervals [ i ] [ 0 ] ) ; r = min ( r , intervals [ i ] [ 1 ] ) ; } } cout << " [ " << l << " , ▁ " << r << " ] " ; }
int main ( ) { int intervals [ ] [ 2 ] = { { 1 , 6 } , { 2 , 8 } , { 3 , 10 } , { 5 , 8 } } ; int N = sizeof ( intervals ) / sizeof ( intervals [ 0 ] ) ; findIntersection ( intervals , N ) ; }
int cmp ( int a , int b ) { return ( a > b ) - ( a < b ) ; }
int maxSubarraySize ( int arr [ ] , int n ) { int ans = 1 ; int anchor = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int c = cmp ( arr [ i - 1 ] , arr [ i ] ) ; if ( c == 0 ) anchor = i ; else if ( i == n - 1 || c * cmp ( arr [ i ] , arr [ i + 1 ] ) != -1 ) { ans = max ( ans , i - anchor + 1 ) ; anchor = i ; } } return ans ; }
int main ( ) { int arr [ ] = { 9 , 4 , 2 , 10 , 7 , 8 , 8 , 1 , 9 } ; int n = sizeof ( arr ) / sizeof ( arr [ 0 ] ) ;
cout << maxSubarraySize ( arr , n ) ; }
int ValidPairs ( int arr [ ] , int n ) {
int count [ 121 ] = { 0 } ;
for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] += 1 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) continue ; if ( abs ( arr [ i ] - arr [ j ] ) % 2 == 1 ) continue ;
ans += count [ arr [ i ] ] * count [ arr [ j ] ] ; if ( arr [ i ] == arr [ j ] )
ans -= count [ arr [ i ] ] ; } return ans ; }
int main ( ) { int arr [ ] = { 16 , 17 , 18 } ; int n = sizeof ( arr ) / sizeof ( int ) ;
cout << ( ValidPairs ( arr , n ) ) ; return 0 ; }
int minChanges ( int A [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } }
return cnt ; }
int main ( ) { int A [ ] = { 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 } ; int n = sizeof ( A ) / sizeof ( A [ 0 ] ) ; cout << minChanges ( A , n ) ; return 0 ; }
void completeSuquence ( string s ) {
int n = s . length ( ) ; int open = 0 , close = 0 ; for ( int i = 0 ; i < n ; i ++ ) {
if ( s [ i ] == ' ( ' ) open ++ ; else
close ++ ;
if ( close > open ) { cout << " Impossible " << endl ; return ; } }
cout << s ; for ( int i = 0 ; i < open - close ; i ++ ) cout << ' ) ' ; cout << endl ; }
int main ( ) { string s = " ( ( ) ( ( ) ( " ; completeSuquence ( s ) ; return 0 ; }
string smallestPermute ( int n ) { char res [ n + 1 ] ;
if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = 48 + i + 2 ; else res [ i ] = 48 + i ; } }
else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = 48 + i + 2 ; else res [ i ] = 48 + i ; }
res [ n - 1 ] = 48 + n - 2 ; res [ n - 2 ] = 48 + n ; res [ n - 3 ] = 48 + n - 1 ; }
res [ n ] = ' \0' ; return res ; }
int main ( ) { int n = 7 ; cout << smallestPermute ( n ) ; return 0 ; }
int minInsertions ( int H [ ] , int n , int K ) {
int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += ceil ( diff / K ) - 1 ; }
return inser ; }
int main ( ) { int H [ ] = { 2 , 4 , 8 , 16 } , K = 3 ; int n = sizeof ( H ) / sizeof ( H [ 0 ] ) ; cout << minInsertions ( H , n , K ) ; return 0 ; }
int count_minimum_operations ( long long n ) {
int count = 0 ; while ( n > 1 ) {
if ( n % 3 == 0 ) n /= 3 ;
else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ;
else n ++ ; }
count ++ ; } return count ; }
int main ( ) { long long n = 4 ; long long ans = count_minimum_operations ( n ) ; cout << ans << endl ; return 0 ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void maxSum ( int * a , int n ) { vector < int > l ;
int s = 0 ;
for ( int i = 0 ; i < n ; i ++ ) {
s += abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ;
if ( i == 0 ) l . push_back ( i + 1 ) ; else { l . push_back ( i + 1 ) ; l . push_back ( i ) ; } }
cout << s << endl ;
for ( int i = 0 ; i < l . size ( ) ; i ++ ) cout << l [ i ] << " ▁ " ; }
int main ( ) { int n = 4 ; int a [ ] = { 1 , -2 , -3 , 4 } ; maxSum ( a , n ) ; }
#include <bits/stdc++.h> NEW_LINE using namespace std ; void LengthLCP ( string x , string y ) { int fr [ 26 ] = { 0 } ;
for ( int i = 0 ; i < b ; i ++ ) {
fr [ y [ i ] - 97 ] += 1 ; }
int c = 0 ; for ( int i = 0 ; i < a ; i ++ ) {
if ( fr [ x [ i ] - 97 ] > 0 ) { c += 1 ; fr [ x [ i ] - 97 ] -= 1 ; } else break ; } cout << ( c ) << endl ; }
int main ( ) { string x = " here " , y = " there " ; LengthLCP ( x , y ) ; return 0 ; }
void CountPair ( int L , int R ) {
int x = ( R - L + 1 ) ;
cout << x / 2 << " STRNEWLINE " ; }
int main ( ) { int L , R ; L = 1 , R = 8 ; CountPair ( L , R ) ; return 0 ; }
int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; }
int main ( ) { int K , P , N ; K = 4 ; P = 1 ; N = 10 ; cout << problemsLeft ( K , P , N ) ; return 0 ; }
int results ( int n , int k ) { return round ( pow ( n , ( 1.0 / pow ( 2 , k ) ) ) ) ; }
int main ( ) { int k = 3 , n = 100000000 ; cout << " Chocolates ▁ left ▁ after ▁ " << k << " ▁ iterations ▁ are ▁ " << results ( n , k ) ; return 0 ; }
int steps ( int N , int M ) {
if ( N == 1 ) return 0 ;
return M ; return 2 * M + ( N - 3 ) ; }
int main ( ) { int N = 4 , M = 4 ; cout << steps ( N , M ) ; return 0 ; }
void survival ( int S , int N , int M ) {
if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) cout << " No STRNEWLINE " ; else {
int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; cout << " Yes ▁ " << days << endl ; } }
int main ( ) { int S = 10 , N = 16 , M = 2 ; survival ( S , N , M ) ; return 0 ; }
