using System ; class GFG { static bool isEven ( int [ ] arr , int n , int r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { int oddCount = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; } public static void Main ( ) { int [ ] arr = { 1 , 0 } ; int n = arr . Length ; int r = 2 ; if ( isEven ( arr , n , r ) ) Console . WriteLine ( " Even " ) ; else Console . WriteLine ( " Odd " ) ; } }
using System ; class GFG { static void solve ( int [ ] a , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; bool evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; } static public void Main ( ) { int [ ] a = { 1 , 2 , 1 , 2 , 1 } ; int n = a . Length ; solve ( a , n ) ; } }
using System ; class GFG { static void CreateArray ( int N , int even , int odd ) { int EvenPreSums = 1 ; int temp = - 1 ; int OddPreSums = 0 ; for ( int i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } } if ( temp == - 1 ) { Console . WriteLine ( temp ) ; } else { EvenPreSums = ( ( N + 1 ) - OddPreSums ) ; int e = 1 ; int o = 0 ; int CurrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( CurrSum % 2 == 0 ) { if ( e < EvenPreSums ) { e ++ ; Console . Write ( "0 ▁ " ) ; } else { o ++ ; Console . Write ( "1 ▁ " ) ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; Console . Write ( "1 ▁ " ) ; CurrSum ++ ; } else { o ++ ; Console . Write ( "0 ▁ " ) ; } } } Console . WriteLine ( ) ; } } static public void Main ( ) { int N = 15 ; int even = 60 , odd = 60 ; CreateArray ( N , even , odd ) ; } }
using System ; class GFG { static int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; } public static void Main ( String [ ] args ) { int A = 2 , B = 3 ; int X = findX ( A , B ) ; Console . WriteLine ( " X ▁ = ▁ " + X + " , ▁ Sum ▁ = ▁ " + ( ( A ^ X ) + ( B ^ X ) ) ) ; } }
using System ; class GFG { static bool isSumEqual ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 10 } ; int n = arr . Length ; if ( isSumEqual ( arr , n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static double perfectSquares ( int a , int b ) { return ( Math . Floor ( Math . Sqrt ( b ) ) - Math . Ceiling ( Math . Sqrt ( a ) ) + 1 ) ; } static double countOnes ( int [ ] arr , int n ) { return perfectSquares ( 1 , n ) ; } static public void Main ( ) { int N = 10 ; int [ ] arr = { 0 } ; Console . WriteLine ( countOnes ( arr , N ) ) ; } }
using System ; class GFG { static void printPosition ( int [ ] A , int [ ] B , int sizeOfA , int sizeOfB ) { for ( int i = 1 ; i < sizeOfA ; i ++ ) { A [ i ] += A [ i - 1 ] ; } for ( int i = 0 ; i < sizeOfB ; i ++ ) { int row = lower_bound ( A , 0 , A . Length , B [ i ] ) ; int boxNumber = ( row >= 1 ) ? B [ i ] - A [ row - 1 ] : B [ i ] ; Console . WriteLine ( row + 1 + " , ▁ " + boxNumber + " STRNEWLINE " ) ; } } private static int lower_bound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) { low = middle + 1 ; } else { high = middle ; } } return low ; } static public void Main ( ) { int [ ] A = { 2 , 2 , 2 , 2 } ; int [ ] B = { 1 , 2 , 3 , 4 } ; int sizeOfA = A . Length ; int sizeOfB = B . Length ; printPosition ( A , B , sizeOfA , sizeOfB ) ; } }
using System ; class GFG { static void primeFactors ( int n , int [ ] freq ) { int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; } if ( n > 2 ) freq [ n ] = 1 ; } static int getMaximumPower ( int n , int m ) { int [ ] freq1 = new int [ n + 1 ] ; int [ ] freq2 = new int [ m + 1 ] ; primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; int maxi = 0 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ; if ( freq2 [ i ] > freq1 [ i ] ) return 0 ; if ( freq2 [ i ] != 0 ) { maxi = Math . Max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; } public static void Main ( String [ ] args ) { int n = 48 , m = 4 ; Console . WriteLine ( getMaximumPower ( n , m ) ) ; } }
using System ; class GFG { static void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( div [ i ] + " ▁ " ) ; } static void Main ( ) { int n = 10 ; findDivisors ( n ) ; } }
using System ; class GFG { static int decideWinner ( int [ ] a , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; } public static void Main ( ) { int [ ] a = { 4 , 8 , 5 , 9 } ; int n = a . Length ; if ( decideWinner ( a , n ) == 1 ) Console . Write ( " X ▁ wins " ) ; else Console . Write ( " Y ▁ wins " ) ; } }
using System ; class GFG { public static int CntDivbyX ( int [ ] arr , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = 7 ; int x = 2 ; Console . Write ( CntDivbyX ( arr , n , x ) ) ; } }
using System ; class GFG { public static int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; } public static void Main ( ) { int K = 7 ; Console . WriteLine ( numLen ( K ) ) ; } }
using System ; class GFG { static int max_Element = ( int ) ( 1e6 + 5 ) ; static int [ ] sum1 = new int [ max_Element ] ; static int [ ] sum2 = new int [ max_Element ] ; static int [ ] sum3 = new int [ max_Element ] ; static void precomputation ( int [ ] arr , int n ) { for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( sum3 [ arr [ i ] ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 9 , 5 , 6 } ; int n = arr . Length ; precomputation ( arr , n ) ; } }
using System ; class GFG { static int fib ( int n ) { double phi = ( 1 + Math . Sqrt ( 5 ) ) / 2 ; return ( int ) Math . Round ( Math . Pow ( phi , n ) / Math . Sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } public static void Main ( ) { int l = 4 , r = 8 ; Console . WriteLine ( calculateSum ( l , r ) ) ; } }
using System ; class GFG { static void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( int i = 1 ; i <= a ; i ++ ) Console . Write ( " ( ( " ) ; for ( int i = 1 ; i <= c ; i ++ ) Console . Write ( " ) ( " ) ; for ( int i = 1 ; i <= d ; i ++ ) Console . Write ( " ) ) " ) ; for ( int i = 1 ; i <= b ; i ++ ) Console . Write ( " ( ) " ) ; } else Console . Write ( - 1 ) ; } public static void Main ( ) { int a = 3 , b = 1 , c = 4 , d = 3 ; printBalancedExpression ( a , b , c , d ) ; } }
using System ; class GFG { static int factorial ( int f ) { int fact = 1 ; for ( int i = 2 ; i <= f ; i ++ ) fact *= ( int ) i ; return fact ; } static int findPermutation ( int N , int M ) { int permutation = factorial ( N + M - 1 ) / ( factorial ( N ) * factorial ( M - 1 ) ) ; return permutation ; } public static void Main ( ) { int N = 3 , M = 3 ; Console . Write ( findPermutation ( N , M ) ) ; } }
using System ; class GFG { static int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( maxValue ( n ) ) ; } }
using System ; class GFG { static void findCount ( int n ) { long a = 1 , b = 0 , c = 0 ; int x = n / 60 ; a = ( long ) Math . Pow ( 32 , x ) ; x = 60 * x ; for ( int i = x + 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { b += a ; a = 0 ; } if ( i % 5 == 0 ) { c += b ; b = 0 ; } if ( i % 12 == 0 ) { a += ( 2 * c ) ; c = 0 ; } } Console . WriteLine ( " a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } static void Main ( ) { int n = 72 ; findCount ( n ) ; } }
using System ; class GFG { static int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; } static int gcdOfFactorial ( int [ ] arr , int n ) { int minm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minm = minm > arr [ i ] ? arr [ i ] : minm ; return factorial ( minm ) ; } static void Main ( ) { int [ ] arr = { 9 , 12 , 122 , 34 , 15 } ; int n = arr . Length ; Console . WriteLine ( gcdOfFactorial ( arr , n ) ) ; } }
using System ; class GFG { static long sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( long ) Math . Pow ( n , n ) + sum ( n - 1 ) ) ; } public static void Main ( ) { int n = 2 ; Console . Write ( sum ( n ) ) ; } }
using System ; class GFG { static int mod = 1000000007 ; static long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( ( n & 1 ) == 1 ) p = ( p * a ) % mod ; return p ; } static int countPermutations ( int n ) { if ( n == 1 ) { return 0 ; } return ( ( int ) power ( 2 , n - 1 ) - 2 ) % mod ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( countPermutations ( n ) ) ; } }
using System ; class GFG { static long numbers ( int n ) { return ( long ) ( Math . Pow ( 2 , n + 1 ) ) - 2 ; } static void Main ( ) { int n = 2 ; Console . WriteLine ( numbers ( n ) ) ; } }
using System ; class GFG { public static long NumberofWays ( int n ) { long x = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; long y = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) ; return ( 1l * x * y ) ; } public static void Main ( string [ ] args ) { int n = 4 ; Console . WriteLine ( NumberofWays ( n ) ) ; } }
using System ; public class GFG { public static int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; } public static void Main ( string [ ] args ) { int N = 5 ; Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; public class GFG { public static void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { Console . Write ( ( ( 2 * i ) - 1 ) + " ▁ " ) ; i ++ ; } } public static void Main ( string [ ] args ) { int n = 3 ; findNumbers ( n ) ; } }
using System ; class GFG { static void findMissingNums ( int [ ] even , int sizeEven , int [ ] odd , int sizeOdd ) { int minEven = int . MaxValue ; int maxEven = int . MinValue ; int minOdd = int . MaxValue ; int maxOdd = int . MinValue ; int sumEvenArr = 0 , sumOddArr = 0 ; for ( int i = 0 ; i < sizeEven ; i ++ ) { minEven = Math . Min ( minEven , even [ i ] ) ; maxEven = Math . Max ( maxEven , even [ i ] ) ; sumEvenArr += even [ i ] ; } for ( int i = 0 ; i < sizeOdd ; i ++ ) { minOdd = Math . Min ( minOdd , odd [ i ] ) ; maxOdd = Math . Max ( maxOdd , odd [ i ] ) ; sumOddArr += odd [ i ] ; } int totalTerms = 0 , reqSum = 0 ; totalTerms = minEven / 2 ; int evenSumMin = ( totalTerms * ( totalTerms + 1 ) ) ; totalTerms = maxEven / 2 ; int evenSumMax = ( totalTerms * ( totalTerms + 1 ) ) ; reqSum = evenSumMax - evenSumMin + minEven ; Console . WriteLine ( " Even ▁ = ▁ " + ( reqSum - sumEvenArr ) ) ; totalTerms = ( minOdd / 2 ) + 1 ; int oddSumMin = totalTerms * totalTerms ; totalTerms = ( maxOdd / 2 ) + 1 ; int oddSumMax = totalTerms * totalTerms ; reqSum = oddSumMax - oddSumMin + minOdd ; Console . WriteLine ( " Odd ▁ = ▁ " + ( reqSum - sumOddArr ) ) ; } static void Main ( ) { int [ ] even = { 6 , 4 , 8 , 14 , 10 } ; int sizeEven = even . Length ; int [ ] odd = { 7 , 5 , 3 , 11 , 13 } ; int sizeOdd = odd . Length ; findMissingNums ( even , sizeEven , odd , sizeOdd ) ; } }
using System ; class GFG { static int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; } static public void Main ( ) { int x = 6 , y = 5 ; Console . WriteLine ( findMinimum ( x , y ) ) ; } }
using System ; class GFG { static int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; } static int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 == 0 ) count ++ ; } return count ; } public static void Main ( ) { int l = 1000 , r = 6000 ; Console . WriteLine ( countNumbers ( l , r ) ) ; } }
using System ; class GfG { static int findMinSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 5 , 7 , 8 } ; int n = arr . Length ; Console . WriteLine ( findMinSum ( arr , n ) ) ; } }
using System ; class GFG { static int maxLenSubArr ( int [ ] a , int n ) { int count , j ; int cm = 1 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( int i = 0 ; i < n - 1 ; ) { count = 1 ; if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; } static public void Main ( ) { int [ ] arr = { 6 , 1 , 6 , 6 , 0 } ; int n = arr . Length ; Console . WriteLine ( maxLenSubArr ( arr , n ) ) ; } }
using System ; class GFG { static int minSum ( int [ ] arr , int n , int x ) { int sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; int sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . Min ( sum , sumAfterOperation ) ; } public static void Main ( ) { int [ ] arr = { 5 , 5 , 5 , 5 , 6 } ; int n = arr . Length ; int x = 3 ; Console . WriteLine ( minSum ( arr , n , x ) ) ; } }
using System ; class GfG { static int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } } public static void Main ( ) { int L = 1 , R = 632 ; Console . WriteLine ( maxAND ( L , R ) ) ; } }
using System ; class GFG { static bool checkSpecialPrime ( bool [ ] sieve , int num ) { while ( num > 0 ) { if ( sieve [ num ] ) { return false ; } num /= 10 ; } return true ; } static void findSpecialPrime ( int N ) { bool [ ] sieve = new bool [ N * 10 + 1 ] ; sieve [ 0 ] = sieve [ 1 ] = true ; for ( int i = 2 ; i <= N * 10 ; i ++ ) { if ( ! sieve [ i ] ) { for ( int j = i * i ; j <= N * 10 ; j += i ) { sieve [ j ] = true ; } } } while ( true ) { if ( checkSpecialPrime ( sieve , N ) ) { Console . WriteLine ( N ) ; break ; } else N ++ ; } } static void Main ( ) { int N = 379 ; findSpecialPrime ( N ) ; N = 100 ; findSpecialPrime ( N ) ; } }
using System ; class GFG { static int minMoves ( int n ) { string s = n . ToString ( ) ; int ans = Int32 . MaxValue ; int len = s . Length ; for ( int i = 0 ; i < len ; ++ i ) { for ( int j = 0 ; j < len ; ++ j ) { if ( i == j ) continue ; char [ ] t = s . ToCharArray ( ) ; int cur = 0 ; for ( int k = i ; k < len - 1 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } for ( int k = j - ( ( j > i ) ? 1 : 0 ) ; k < len - 2 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } int pos = - 1 ; for ( int k = 0 ; k < len ; ++ k ) { if ( t [ k ] != '0' ) { pos = k ; break ; } } for ( int k = pos ; k > 0 ; -- k ) { swap ( t , k , k - 1 ) ; ++ cur ; } int nn = Convert . ToInt32 ( new String ( t ) ) ; if ( nn % 25 == 0 ) ans = Math . Min ( ans , cur ) ; } } if ( ans == Int32 . MaxValue ) return - 1 ; return ans ; } static void swap ( char [ ] t , int i , int j ) { char temp = t [ i ] ; t [ i ] = t [ j ] ; t [ j ] = temp ; } static void Main ( ) { int n = 509201 ; Console . WriteLine ( minMoves ( n ) ) ; } }
using System ; class GFG { static int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; } public static void Main ( ) { int a = 2 , b = 10 , c = 3 ; Console . WriteLine ( getMaxNum ( a , b , c ) ) ; } }
using System ; class GFG { static int countSquares ( int row , int column ) { int topLeft = Math . Min ( row , column ) - 1 ; int bottomRight = 8 - Math . Max ( row , column ) ; int topRight = Math . Min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - Math . Max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; } public static void Main ( ) { int row = 4 , column = 4 ; Console . WriteLine ( countSquares ( row , column ) ) ; } }
using System ; class GFG { static bool canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; } public static void Main ( ) { int bishopX = 5 , bishopY = 5 ; int pawnX = 1 , pawnY = 1 ; if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int N = 1000005 ; static int [ ] primeFactors = new int [ N ] ; static void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; } static public void Main ( ) { findPrimeFactors ( ) ; int a = 6 , b = 3 ; Console . WriteLine ( primeFactors [ a ] - primeFactors [ b ] ) ; } }
using System ; class GFG { static int digitSum ( int n ) { int ans = 0 ; while ( n != 0 ) { ans += n % 10 ; n /= 10 ; } return ans ; } static int findInt ( int n , int m ) { int minDigit = ( int ) Math . Floor ( ( double ) ( m / 9 ) ) ; int start = ( int ) Math . Pow ( 10 , minDigit ) - ( int ) Math . Pow ( 10 , minDigit ) % n ; while ( start < int . MaxValue ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return - 1 ; } static public void Main ( ) { int n = 13 , m = 32 ; Console . WriteLine ( findInt ( n , m ) ) ; } }
using System ; class GFG { static double smallestDivisor ( int n ) { double mx = Math . Sqrt ( n ) ; for ( int i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; } static double maxSum ( int n ) { long res = n ; while ( n > 1 ) { double divi = smallestDivisor ( n ) ; n /= ( int ) divi ; res += n ; } return res ; } public static void Main ( ) { int n = 34 ; Console . WriteLine ( maxSum ( n ) ) ; } }
using System ; class GFG { static bool isPossible ( int n , int k , int [ ] arr ) { int sum = arr [ 0 ] ; int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . Max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; } public static void Main ( ) { int k = 8 ; int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . Length ; if ( isPossible ( n , k , arr ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) c ; if ( Math . Floor ( z ) == Math . Ceiling ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . Max ( maxVal , x + y + ( int ) z ) ; } } return maxVal ; } public static void Main ( String [ ] args ) { int n = 10 , a = 5 , b = 3 , c = 4 ; Console . WriteLine ( maxResult ( n , a , b , c ) ) ; } }
using System ; class GFG { static bool EqualNumbers ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] /= 2 ; } while ( a [ i ] % 3 == 0 ) { a [ i ] /= 3 ; } if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; } public static void Main ( ) { int [ ] a = { 50 , 75 , 150 } ; int n = a . Length ; if ( EqualNumbers ( a , n ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static long max_gcd ( long n , long p ) { int count = 0 ; long gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= ( long ) Math . Pow ( 2 , count / n ) ; for ( long i = 3 ; i <= Math . Sqrt ( p ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = p / i ; } if ( count > 0 ) { gcd *= ( long ) Math . Pow ( i , count / n ) ; } } if ( p > 2 ) gcd *= ( long ) Math . Pow ( p , 1 / n ) ; return gcd ; } public static void Main ( ) { long n = 3 ; long p = 80 ; Console . WriteLine ( max_gcd ( n , p ) ) ; } }
using System ; class GFG { static int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; } static public void Main ( ) { int a = 2 , b = 4 , c = 4 ; Console . WriteLine ( getMinNum ( a , b , c ) ) ; } }
using System ; class GFG { static int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( countPairs ( n ) ) ; } }
using System ; class GFG { static bool checkSub ( string sub , string s ) { int j = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) if ( sub [ j ] == s [ i ] ) j ++ ; return j == sub . Length ; } static int getMultiple ( string s ) { for ( int i = 0 ; i < 1e3 ; i += 8 ) { if ( checkSub ( i . ToString ( ) , s ) ) return i ; } return - 1 ; } static void Main ( ) { string s = "3454" ; Console . WriteLine ( getMultiple ( s ) ) ; } }
using System ; class GFG { static float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; } public static void Main ( ) { Console . WriteLine ( sum ( 8 ) ) ; Console . WriteLine ( sum ( 10 ) ) ; } }
using System ; using System . Collections ; class GFG { static ArrayList findingValues ( int m , int n , int mth , int nth ) { int d = ( Math . Abs ( mth - nth ) ) / Math . Abs ( ( m - 1 ) - ( n - 1 ) ) ; int a = mth - ( ( m - 1 ) * d ) ; ArrayList res = new ArrayList ( ) ; res . Add ( a ) ; res . Add ( d ) ; return res ; } static int findSum ( int m , int n , int mth , int nth , int p ) { ArrayList ad = findingValues ( m , n , mth , nth ) ; int a = ( int ) ad [ 0 ] ; int d = ( int ) ad [ 1 ] ; int sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 ; return sum ; } public static void Main ( ) { int m = 6 , n = 10 , mTerm = 12 , nTerm = 20 , p = 5 ; Console . WriteLine ( findSum ( m , n , mTerm , nTerm , p ) ) ; } }
using System ; using System . Linq ; using System . Collections . Generic ; using System . Collections ; class GFG { static void powerfulIntegers ( int x , int y , int bound ) { HashSet < int > s = new HashSet < int > ( ) ; ArrayList powersOfY = new ArrayList ( ) ; int i ; powersOfY . Add ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . Add ( i ) ; i = 0 ; while ( true ) { int xPowI = ( int ) Math . Pow ( x , i ) ; for ( int j = 0 ; j != powersOfY . Count ; ++ j ) { int num = xPowI + ( int ) powersOfY [ j ] ; if ( num <= bound ) s . Add ( num ) ; else break ; } if ( xPowI >= bound x == 1 ) break ; i ++ ; } int [ ] ar = s . ToArray ( ) ; Array . Sort ( ar ) ; s . Clear ( ) ; s . UnionWith ( ar ) ; foreach ( int t in s ) { Console . Write ( t + " ▁ " ) ; } } static void Main ( ) { int x = 2 , y = 3 , bound = 10 ; powerfulIntegers ( x , y , bound ) ; } }
using System ; class GFG { static void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int [ ] arr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; while ( n > 0 ) { int f1 = ( ind - 1 ) * k ; int f2 = ind * k ; int sum1 = ( f1 * ( f1 + 1 ) ) / 2 ; int sum2 = ( f2 * ( f2 + 1 ) ) / 2 ; int res = sum2 - sum1 ; if ( res <= n ) { count ++ ; n -= res ; ind ++ ; } { int i = 0 ; int term = ( ( ind - 1 ) * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ i ++ ] = term ; n -= term ; term ++ ; } else { arr [ i ++ ] = n ; n = 0 ; } } } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int n = 10 , k = 3 ; candies ( n , k ) ; } }
using System ; class GFG { static void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int [ ] arr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; int sum = ( mid * ( mid + 1 ) ) >> 1 ; if ( sum <= n ) { count = mid / k ; low = mid + 1 ; } else { high = mid - 1 ; } } int last = ( count * k ) ; n -= ( last * ( last + 1 ) ) / 2 ; int j = 0 ; int term = ( count * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ j ++ ] = term ; n -= term ; term ++ ; } else { arr [ j ] += n ; n = 0 ; } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int n = 7 , k = 4 ; candies ( n , k ) ; } }
using System ; public class GFG { static int printSmallest ( int [ ] a ) { Array . Sort ( a ) ; int i , j , num ; for ( i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] % 3 == 0 ) { return a [ i ] ; } } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { num = ( a [ i ] * 10 ) + a [ j ] ; if ( num % 3 == 0 ) { return num ; } } } return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] ; } public static void Main ( ) { int [ ] arr = { 7 , 7 , 1 } ; Console . Write ( printSmallest ( arr ) ) ; } }
using System ; public class GFG { static void updateMatrix ( int n , int [ , ] q , int [ , ] mat ) { int i , j ; for ( i = 0 ; i < q . GetLength ( 0 ) ; i ++ ) { int X1 = q [ i , 0 ] ; int Y1 = q [ i , 1 ] ; int X2 = q [ i , 2 ] ; int Y2 = q [ i , 3 ] ; mat [ X1 , Y1 ] ++ ; if ( Y2 + 1 < n ) mat [ X2 , Y2 + 1 ] -- ; else if ( X2 + 1 < n ) mat [ X2 + 1 , 0 ] -- ; } int sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { sum += mat [ i , j ] ; Console . Write ( sum + " ▁ " ) ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 5 ; int [ , ] mat = new int [ n , n ] ; int [ , ] q = { { 0 , 0 , 1 , 2 } , { 1 , 2 , 3 , 4 } , { 1 , 4 , 3 , 4 } } ; updateMatrix ( n , q , mat ) ; } }
using System ; class GFG { static void printArr ( float [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } static void replaceMax ( float [ ] arr , int n ) { float max = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } float min = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } float range = max - min ; float coeffOfRange = range / ( max + min ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } } printArr ( arr , n ) ; } public static void Main ( ) { float [ ] arr = { 15 , 16 , 10 , 9 , 6 , 7 , 17 } ; int n = arr . Length ; replaceMax ( arr , n ) ; } }
using System ; class GFG { static void divide ( int a , int b ) { for ( int i = 2 ; i <= Math . Min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } Console . WriteLine ( " A ▁ = ▁ " + a + " , ▁ B ▁ = ▁ " + b ) ; } static public void Main ( ) { int A = 10 , B = 15 ; divide ( A , B ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void commDiv ( int a , int b ) { int n = gcd ( a , b ) ; a = a / n ; b = b / n ; Console . WriteLine ( " A ▁ = ▁ " + a + " , ▁ B ▁ = ▁ " + b ) ; } public static void Main ( ) { int a = 10 , b = 15 ; commDiv ( a , b ) ; } }
using System ; public class GFG { static int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . Floor ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; int right = left * 2 ; return Math . Min ( ( n - left ) , ( right - n ) ) ; } static public void Main ( ) { int n = 15 ; Console . WriteLine ( minAbsDiff ( n ) ) ; } }
using System ; class GFG { static double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; } public static void Main ( ) { double p = 1 , q = 2 , r = 1 , s = 2 ; Console . WriteLine ( find_probability ( p , q , r , s ) ) ; } }
using System ; class GfG { public static void FindAllElements ( int n , int k ) { int sum = k ; int [ ] A = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) A [ i ] = 1 ; for ( int i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { Console . Write ( " Impossible " ) ; } else { for ( int i = 0 ; i < k ; ++ i ) Console . Write ( A [ i ] + " ▁ " ) ; } } public static void Main ( String [ ] args ) { int n = 12 ; int k = 6 ; FindAllElements ( n , k ) ; } }
using System ; class GFG { public static int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; } public static bool isEqual ( int a , int b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; } public static void Main ( ) { int a = 105 , b = 106 ; if ( isEqual ( a , b ) == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class Geeks { public static void sumArray ( int [ ] arr , int n ) { int [ ] leftSum = new int [ n ] ; int [ ] rightSum = new int [ n ] ; int [ ] Sum = new int [ n ] ; int i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( Sum [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 3 , 6 , 4 , 8 , 9 } ; int n = arr . Length ; sumArray ( arr , n ) ; } }
using System ; class solution { static int minimumX ( int n , int k ) { int mini = int . MaxValue ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . Min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . Min ( num2 , mini ) ; } } return mini ; } public static void Main ( ) { int n = 4 , k = 6 ; Console . WriteLine ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; Console . WriteLine ( minimumX ( n , k ) ) ; } }
using System ; public class GFG { static int minimumX ( int n , int k ) { int ans = int . MaxValue ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . Min ( ans , rem + ( n / rem ) * k ) ; } return ans ; } static public void Main ( ) { int n = 4 , k = 6 ; Console . WriteLine ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; Console . WriteLine ( minimumX ( n , k ) ) ; } }
using System ; class GFG { static int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; } public static void Main ( ) { int n = 6 ; Console . WriteLine ( getHermiteNumber ( n ) ) ; } }
using System ; class GFG { static void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { Console . Write ( " a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b ) ; } else Console . WriteLine ( - 1 ) ; } public static void Main ( ) { int n = 10 ; find ( n ) ; } }
using System ; class GFG { static bool isPerfect ( int N ) { if ( ( Math . Sqrt ( N ) - Math . Floor ( Math . Sqrt ( N ) ) ) != 0 ) return false ; return true ; } static void getClosestPerfectSquare ( int N ) { if ( isPerfect ( N ) ) { Console . WriteLine ( N + " ▁ " + "0" ) ; return ; } int aboveN = - 1 , belowN = - 1 ; int n1 ; n1 = N + 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } int diff1 = aboveN - N ; int diff2 = N - belowN ; if ( diff1 > diff2 ) Console . WriteLine ( belowN + " ▁ " + diff2 ) ; else Console . WriteLine ( aboveN + " ▁ " + diff1 ) ; } public static void Main ( ) { int N = 1500 ; getClosestPerfectSquare ( N ) ; } }
using System ; class GFG { static int den3 , num3 ; static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void lowest ( ) { int common_factor = gcd ( num3 , den3 ) ; den3 = den3 / common_factor ; num3 = num3 / common_factor ; } static void addFraction ( int num1 , int den1 , int num2 , int den2 ) { den3 = gcd ( den1 , den2 ) ; den3 = ( den1 * den2 ) / den3 ; num3 = ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ; lowest ( ) ; } public static void Main ( String [ ] args ) { int num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 ; addFraction ( num1 , den1 , num2 , den2 ) ; Console . Write ( " { 0 } / { 1 } ▁ + ▁ { 2 } / { 3 } ▁ is ▁ equal ▁ to ▁ { 4 } / { 5 } STRNEWLINE " , num1 , den1 , num2 , den2 , num3 , den3 ) ; } }
using System ; public class GFG { static int findLargestDivisor ( int n ) { for ( int i = 2 ; i < Math . Sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; } public static void Main ( ) { int n = 12 ; Console . WriteLine ( findLargestDivisor ( n ) ) ; n = 97 ; Console . WriteLine ( findLargestDivisor ( n ) ) ; } }
using System ; class GFG { static bool checkIsAP ( int [ ] arr , int n ) { if ( n == 1 ) return true ; Array . Sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } public static void Main ( ) { int [ ] arr = { 20 , 15 , 5 , 0 , 10 } ; int n = arr . Length ; if ( checkIsAP ( arr , n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class GFG { static bool isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; } public static void Main ( ) { int n = 120 ; if ( isTriPerfect ( n ) ) Console . WriteLine ( n + " ▁ is ▁ a ▁ Triperfect ▁ number " ) ; } }
using System ; public class GFG { static int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; } public static void Main ( ) { int N = 14 ; int X = 3 , Y = 5 ; Console . Write ( sum ( N , X , Y ) ) ; } }
using System ; class GFG { static int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; } static public void Main ( ) { int l = 1 , r = 10 ; Console . WriteLine ( findTwoThreePrime ( l , r ) ) ; } }
using System ; class GFG { static String getNumber ( string s ) { int number_of_digits = s . Length ; int [ ] freq = new int [ 10 ] ; for ( int i = 0 ; i < number_of_digits ; i ++ ) { if ( s [ i ] == '1' s [ i ] == '2' s [ i ] == '3' s [ i ] == '5' s [ i ] == '7' ) { freq [ s [ i ] - 48 ] += 1 ; } if ( s [ i ] == '4' ) { freq [ 2 ] += 2 ; freq [ 3 ] ++ ; } if ( s [ i ] == '6' ) { freq [ 5 ] ++ ; freq [ 3 ] ++ ; } if ( s [ i ] == '8' ) { freq [ 7 ] ++ ; freq [ 2 ] += 3 ; } if ( s [ i ] == '9' ) { freq [ 7 ] ++ ; freq [ 3 ] += 2 ; freq [ 2 ] ++ ; } } string t = " " ; if ( freq [ 1 ] == number_of_digits || freq [ 0 ] == number_of_digits || ( freq [ 0 ] + freq [ 1 ] ) == number_of_digits ) { return s ; } else { for ( int i = 9 ; i >= 2 ; i -- ) { int ctr = freq [ i ] ; while ( ( ctr -- ) > 0 ) { t += ( char ) ( i + 48 ) ; } } return t ; } } public static void Main ( ) { string s = "1280" ; Console . WriteLine ( getNumber ( s ) ) ; } }
using System ; public class GFG { static int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static void icanobifNumbers ( int N ) { int first = 0 , second = 1 ; if ( N == 1 ) Console . Write ( first ) ; else if ( N == 2 ) Console . Write ( first + " ▁ " + second ) ; else { Console . Write ( first + " ▁ " + second + " ▁ " ) ; for ( int i = 3 ; i <= N ; i ++ ) { int x = reversDigits ( first ) ; int y = reversDigits ( second ) ; Console . Write ( x + y + " ▁ " ) ; int temp = second ; second = x + y ; first = temp ; } } } public static void Main ( ) { int N = 12 ; icanobifNumbers ( N ) ; } }
using System ; class GFG { static int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; } public static void Main ( ) { int a = 5 , b = 3 , n = 3 ; Console . WriteLine ( addNDigits ( a , b , n ) ) ; } }
using System ; class GFG { static int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = ( int ) Math . Sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; } static void Main ( ) { int n = 10 ; Console . WriteLine ( Triplets ( n ) ) ; } }
using System ; class GFG { static int solve ( int n , int base1 ) { int sum = 0 ; while ( n > 0 ) { int remainder1 = n % base1 ; sum += remainder1 ; n = n / base1 ; } return sum ; } static void SumsOfDigits ( int n ) { int sum = 0 ; for ( int base1 = 2 ; base1 <= n / 2 ; ++ base1 ) sum += solve ( n , base1 ) ; Console . WriteLine ( sum ) ; } public static void Main ( String [ ] args ) { int n = 8 ; SumsOfDigits ( n ) ; } }
using System ; public class GFG { static bool checkPerfectcube ( int n ) { int d = ( int ) Math . Ceiling ( Math . Pow ( n , ( double ) 1 / 3 ) ) ; if ( d * d * d == n ) return true ; return false ; } static int largestNonPerfectcubeNumber ( int [ ] a , int n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectcube ( a [ i ] ) == false ) maxi = Math . Max ( a [ i ] , maxi ) ; } return maxi ; } public static void Main ( ) { int [ ] a = { 16 , 64 , 25 , 2 , 3 , 10 } ; int n = a . Length ; Console . WriteLine ( largestNonPerfectcubeNumber ( a , n ) ) ; } }
using System ; class GFG { static void checkIfPossibleRec ( int x , int a , int b , bool [ ] isPossible , int n ) { if ( x > n ) return ; if ( isPossible [ x ] ) return ; isPossible [ x ] = true ; checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; } static bool checkPossible ( int n , int a , int b ) { bool [ ] isPossible = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) isPossible [ i ] = false ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; } static public void Main ( ) { int a = 3 , b = 7 , n = 8 ; if ( checkPossible ( a , b , n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int sumOdd ( int n ) { int terms = ( n + 1 ) / 2 ; int sum = terms * terms ; return sum ; } static int suminRange ( int l , int r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; } public static void Main ( ) { int l = 2 , r = 5 ; Console . WriteLine ( " Sum ▁ of ▁ odd ▁ natural ▁ numbers ▁ " + " from ▁ L ▁ to ▁ R ▁ is ▁ " + suminRange ( l , r ) ) ; } }
using System ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int sumcommDiv ( int a , int b ) { int n = gcd ( a , b ) ; int sum = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; } static public void Main ( ) { int a = 10 , b = 15 ; Console . WriteLine ( " Sum ▁ = ▁ " + sumcommDiv ( a , b ) ) ; } }
using System ; class GFG { static String checkNumber ( int N ) { int temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp /= 1000 ; else if ( temp % 100 == 14 ) temp /= 100 ; else if ( temp % 10 == 1 ) temp /= 10 ; else { return " NO " ; } } return " YES " ; } public static void Main ( ) { int N = 1414 ; Console . WriteLine ( checkNumber ( N ) ) ; } }
using System ; class GFG { static int getResult ( int n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( getResult ( n ) ) ; } }
using System ; class GFG { static void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { Console . WriteLine ( " NO " ) ; return ; } double a = ( N + Math . Sqrt ( val ) ) / 2.0 ; double b = ( N - Math . Sqrt ( val ) ) / 2.0 ; Console . WriteLine ( " a ▁ = ▁ " + a ) ; Console . WriteLine ( " b ▁ = ▁ " + b ) ; } static void Main ( ) { double N = 69.0 ; findAandB ( N ) ; } }
class GFG { static int minOperations ( int [ ] A , int n ) { if ( ( n & 1 ) > 0 ) return - 1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; } static void Main ( ) { int [ ] A = new int [ ] { 1 , 1 , 0 , 0 } ; int n = A . Length ; System . Console . WriteLine ( minOperations ( A , n ) ) ; } }
using System ; class GFG { static int countdig ( int m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( m / 10 ) ; } static int countSteps ( int x ) { int c = 0 ; int last = x ; while ( last > 0 ) { int digits = countdig ( last ) ; digits -= 1 ; int divisor = ( int ) Math . Pow ( 10 , digits ) ; int first = last / divisor ; int lastnumber = first * divisor ; int skipped = ( last - lastnumber ) / first ; skipped += 1 ; c += skipped ; last = last - ( first * skipped ) ; } return c ; } static void Main ( ) { int n = 14 ; Console . WriteLine ( countSteps ( n ) ) ; } }
using System ; class GFG { static long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long powerGCD ( long a , long b , long n ) { long e = power ( a , n , b ) ; return gcd ( e , b ) ; } public static void Main ( ) { long a = 5 , b = 4 , n = 2 ; Console . Write ( powerGCD ( a , b , n ) ) ; } }
using System ; class GFG { static bool allOddDigits ( int n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n /= 10 ; } return true ; } static int largestNumber ( int n ) { if ( n % 2 == 0 ) n -- ; for ( int i = n ; ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; } public static void Main ( ) { int N = 23 ; Console . WriteLine ( largestNumber ( N ) ) ; } }
using System ; class GFG { static int countNumbers ( int N ) { return ( int ) ( Math . Sqrt ( N ) ) - 1 ; } public static void Main ( ) { int N = 36 ; Console . Write ( countNumbers ( N ) ) ; } }
using System ; public class GFG { static int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= ( int ) Math . Sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= ( int ) ( Math . Sqrt ( N - 1 ) ) ; return count_pairs ; } static public void Main ( ) { int N = 5 ; Console . WriteLine ( countOrderedPairs ( N ) ) ; } }
using System ; class GFG { static void pairwiseDifference ( int [ ] arr , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; Console . WriteLine ( diff + " ▁ " ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 10 , 15 , 5 , 6 } ; int n = arr . Length ; pairwiseDifference ( arr , n ) ; } }
using System ; public class GFG { static long sumAP ( long n , long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } static long sumMultiples ( long n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; } static public void Main ( ) { long n = 20 ; Console . WriteLine ( sumMultiples ( n ) ) ; } }
using System ; class GFG { static int markingScheme ( int N , int [ ] answerKey , int [ ] studentAnswer ) { int positive = 0 , negative = 0 , notattempt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( studentAnswer [ i ] == 0 ) notattempt ++ ; else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ; else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; } return ( positive * 3 ) + ( negative * - 1 ) ; } static public void Main ( ) { int [ ] answerKey = { 1 , 2 , 3 , 4 , 1 } ; int [ ] studentAnswer = { 1 , 2 , 3 , 4 , 0 } ; int N = answerKey . Length ; int marking_Scheme = markingScheme ( N , answerKey , studentAnswer ) ; Console . WriteLine ( marking_Scheme ) ; } }
class GFG { static int MAX = 10000 ; static bool [ ] prime = new bool [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { prime [ 1 ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } } static int solve ( int n ) { int count = 0 , num = 1 ; int prod = 1 ; while ( count < n ) { if ( ! prime [ num ] ) { prod *= num ; count ++ ; } num ++ ; } return prod ; } public static void Main ( ) { SieveOfEratosthenes ( ) ; int n = 5 ; System . Console . WriteLine ( solve ( n ) ) ; } }
using System ; public class GFG { static bool Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; } public static void Main ( ) { int l = 30 , r = 70 , k = 10 ; if ( Check_is_possible ( l , r , k ) ) { Console . WriteLine ( " YES " ) ; } else { Console . WriteLine ( " NO " ) ; } } }
using System ; class gfg { public static double nth_group ( int n ) { return n * ( 2 * Math . Pow ( n , 2 ) + 1 ) ; } public static int Main ( ) { int N = 5 ; Console . WriteLine ( nth_group ( N ) ) ; return 0 ; } }
using System ; class GFG { static void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) Console . Write ( " NO " ) ; else Console . Write ( " YES " ) ; } public static void Main ( ) { int a = 2 , b = 4 , c = 2 ; printPossible ( a , b , c ) ; } }
using System ; class GFG { static void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; Console . Write ( r ) ; } public static void Main ( ) { int N = 5 ; Sum_upto_nth_Term ( N ) ; } }
using System ; class GFG { static int CalculateDifference ( int [ ] arr , int n ) { int max_val = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } bool [ ] prime = new bool [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int S1 = 0 , S2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return Math . Abs ( S2 - S1 ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 1 , 3 , 5 , 10 , 15 , 7 } ; int n = arr . Length ; Console . WriteLine ( CalculateDifference ( arr , n ) ) ; } }
using System ; class GFG { static int numberOfDivisors ( int num ) { int c = 0 ; for ( int i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; } static int countNumbers ( int n ) { int c = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; } public static void Main ( ) { int n = 1000 ; Console . Write ( countNumbers ( n ) ) ; } }
using System ; class GFG { static int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( numberOfDistinct ( n ) ) ; } }
using System ; class GFG { static int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; } public static void Main ( ) { int n = 3 , m = 3 ; Console . WriteLine ( NumberOfRectangles ( n , m ) ) ; } }
using System ; class GFG { static long findNumUtil ( long res , int a , int aCount , int b , int bCount , int n ) { if ( res > 1e11 ) return ( long ) 1e11 ; if ( aCount == bCount && res >= n ) return res ; return Math . Min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; } static int findNum ( int n , int a , int b ) { int result = 0 ; int aCount = 0 ; int bCount = 0 ; return ( int ) findNumUtil ( result , a , aCount , b , bCount , n ) ; } public static void Main ( ) { int N = 4500 ; int A = 4 ; int B = 7 ; Console . WriteLine ( findNum ( N , A , B ) ) ; } }
using System ; class GFG { public static void Main ( ) { int n = 7 ; int k = 3 ; if ( n % k == 0 ) Console . WriteLine ( n / k + " ▁ " + n / k ) ; else Console . WriteLine ( ( n - ( n % k ) ) / k + " ▁ " + ( ( ( n - ( n % k ) ) / k ) + 1 ) ) ; } }
using System ; class GFG { public static void Main ( ) { float m = 50 , n = 5 , x = 67 , h = 2927 ; int z = ( int ) ( Math . Ceiling ( ( h / 60 * 1.0 ) ) ) ; if ( z <= n ) Console . WriteLine ( z * m ) ; else Console . WriteLine ( n * m + ( z - n ) * x ) ; } }
using System ; class GFG { static double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( - 1 * b ) / a ; double rootProduct = ( double ) e / a ; return Math . Abs ( rootSum - rootProduct ) ; } public static void Main ( ) { Console . Write ( sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ) ; } }
using System ; class GFG { static int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + ( n ^ x ) ) ++ c ; return c ; } public static void Main ( ) { int n = 3 ; Console . Write ( numberOfSolutions ( n ) ) ; } }
using System ; class GFG { static int minimumLectures ( int m , int n ) { int ans = 0 ; if ( n < ( int ) Math . Ceiling ( 0.75 * m ) ) ans = ( int ) Math . Ceiling ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; } public static void Main ( ) { int M = 9 , N = 1 ; Console . WriteLine ( minimumLectures ( M , N ) ) ; } }
using System ; class GFG { static int countNumbers ( int N ) { return ( int ) ( Math . Pow ( 10 , N ) - Math . Pow ( 8 , N ) ) / 2 ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( countNumbers ( n ) ) ; } }
using System ; class GFG { static int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( " Sum ▁ = ▁ " + calculateSum ( n ) ) ; } }
using System ; class GFG { static void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) Console . WriteLine ( "2 ▁ solutions " ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) Console . WriteLine ( "1 ▁ solution " ) ; else Console . WriteLine ( " No ▁ solutions " ) ; } public static void Main ( ) { int a = 2 , b = 5 , c = 2 ; checkSolution ( a , b , c ) ; } }
using System ; class GFG { static long Bits ( int kilobytes ) { long Bits = 0 ; Bits = kilobytes * 8192 ; return Bits ; } static long Bytes ( int kilobytes ) { long Bytes = 0 ; Bytes = kilobytes * 1024 ; return Bytes ; } static public void Main ( ) { int kilobytes = 1 ; Console . WriteLine ( kilobytes + " ▁ Kilobytes ▁ = ▁ " + Bytes ( kilobytes ) + " ▁ Bytes ▁ and ▁ " + Bits ( kilobytes ) + " ▁ Bits . " ) ; } }
using System ; class GFG { public static void Main ( ) { int n = 3 ; int [ ] a = { 1 , 2 , 3 } ; int i = 0 ; long sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } long x = sum / n ; if ( x * n == sum ) Console . WriteLine ( x ) ; else Console . WriteLine ( " - 1" ) ; } }
using System ; class GFG { static double findSum ( long n ) { return Math . Sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; } public static void Main ( ) { long n = 10 ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; class GFG { static int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . Pow ( x , 2 ) * ( Math . Pow ( x , 2 * n ) - 1 ) ) / ( Math . Pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . Pow ( x , n ) * Math . Pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; } public static void Main ( ) { int x = 2 , y = 2 , n = 2 ; Console . Write ( sum ( x , y , n ) ) ; } }
using System ; class GFG { static void printPair ( int g , int l ) { Console . Write ( g + " ▁ " + l ) ; } public static void Main ( ) { int g = 3 , l = 12 ; printPair ( g , l ) ; } }
using System ; class GFG { static int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( int ) ( Math . Pow ( r , n ) - 1 ) / ( r - 1 ) ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( " Sum ▁ = ▁ " + calculateSum ( n ) ) ; } }
using System ; class GFG { static Boolean ispower ( long n ) { if ( n < 125 ) { return ( n == 1 n == 5 n == 25 ) ; } if ( n % 125 != 0 ) { return false ; } else { return ispower ( n / 125 ) ; } } static long number ( String s , int i , int j ) { long ans = 0 ; for ( int x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s [ x ] - '0' ) ; } return ans ; } static int minCuts ( String s , int n ) { int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = n + 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( s [ i - 1 ] == '0' ) { continue ; } for ( int j = 0 ; j < i ; j ++ ) { if ( s [ j ] == '0' ) { continue ; } long num = number ( s , j , i ) ; if ( ! ispower ( num ) ) { continue ; } dp [ i ] = Math . Min ( dp [ i ] , dp [ j ] + 1 ) ; } } return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : - 1 ) ; } public static void Main ( String [ ] args ) { String s = "101101101" ; int n = s . Length ; Console . WriteLine ( minCuts ( s , n ) ) ; } }
using System ; class GFG { static int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . Min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; } static public void Main ( ) { int num = 15 ; Console . WriteLine ( MinOfCubed ( num ) ) ; } }
using System ; class GFG { static int MinOfCubedDP ( int k ) { int [ ] DP = new int [ k + 1 ] ; int j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = int . MaxValue ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; } public static void Main ( ) { int num = 15 ; Console . WriteLine ( MinOfCubedDP ( num ) ) ; } }
using System ; class GFG { static int maxSum ( int [ ] a , int n ) { int ans = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int [ , ] dp = new int [ n + 1 , 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i , 0 ] = Math . Max ( arr [ i ] , dp [ i - 1 , 0 ] + arr [ i ] ) ; dp [ i , 1 ] = Math . Max ( 0 , dp [ i - 1 , 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , dp [ i - 1 , 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i , 2 ] = dp [ i - 1 , 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i , 2 ] = Math . Max ( dp [ i , 2 ] , dp [ i - 1 , 2 ] + arr [ i ] ) ; ans = Math . Max ( ans , dp [ i , 0 ] ) ; ans = Math . Max ( ans , dp [ i , 1 ] ) ; ans = Math . Max ( ans , dp [ i , 2 ] ) ; } return ans ; } public static void Main ( ) { int [ ] arr = { - 5 , 3 , 2 , 7 , - 8 , 3 , 7 , - 9 , 10 , 12 , - 6 } ; int n = arr . Length ; Console . WriteLine ( maxSum ( arr , n ) ) ; } }
using System ; class GFG { public static int MinimumCost ( int [ ] a , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = Math . Min ( a [ i ] , 2 * a [ i - 1 ] ) ; } int ind = 0 ; int sum = 0 ; while ( x > 0 ) { if ( x != 0 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; } public static void Main ( ) { int [ ] a = { 20 , 50 , 60 , 90 } ; int x = 7 ; int n = a . Length ; Console . WriteLine ( MinimumCost ( a , n , x ) ) ; } }
using System ; class GFG { static int countWays ( int n , int l , int r ) { int tL = l , tR = r ; int [ ] L = new int [ 3 ] ; int [ ] R = new int [ 3 ] ; L [ l % 2 ] = l ; R [ r % 2 ] = r ; l ++ ; r -- ; if ( l <= tR && r >= tL ) { L [ l % 2 ] = l ; R [ r % 2 ] = r ; } int cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] > 0 && L [ 0 ] > 0 ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] > 0 && L [ 1 ] > 0 ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; int [ , ] dp = new int [ n + 1 , 3 ] ; dp [ 1 , 0 ] = cnt0 ; dp [ 1 , 1 ] = cnt1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i , 0 ] = ( cnt0 * dp [ i - 1 , 0 ] + cnt1 * dp [ i - 1 , 1 ] ) ; dp [ i , 1 ] = ( cnt0 * dp [ i - 1 , 1 ] + cnt1 * dp [ i - 1 , 0 ] ) ; } return dp [ n , 0 ] ; } static void Main ( ) { int n = 2 , l = 1 , r = 3 ; Console . WriteLine ( countWays ( n , l , r ) ) ; } }
using System ; class GFG { static int M = 1001 ; static int MOD = 998244353 ; static int [ , ] dp = new int [ M , M ] ; static int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx , diff ] != - 1 ) return dp [ idx , diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx , diff ] = ans % MOD ; } public static void Main ( ) { int N = 3 , M = 3 , K = 0 ; for ( int i = 0 ; i <= M ; i ++ ) for ( int j = 0 ; j <= M ; j ++ ) dp [ i , j ] = - 1 ; Console . WriteLine ( ( M * solve ( 2 , 0 , N , M , K ) ) ) ; } }
using System ; class GFG { static int N = 3 ; static int maxPathSum ( int [ , ] tri ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i , j ] += Math . Max ( tri [ i + 1 , j ] , tri [ i + 1 , j - 1 ] ) ; else tri [ i , j ] += tri [ i + 1 , j ] ; ans = Math . Max ( ans , tri [ i , j ] ) ; } } return ans ; } public static void Main ( ) { int [ , ] tri = { { 1 , 5 , 3 } , { 4 , 8 , 0 } , { 1 , 0 , 0 } } ; Console . WriteLine ( maxPathSum ( tri ) ) ; } }
using System ; class GFG { static int subsetXOR ( int [ ] arr , int n , int K ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . Log ( max_ele ) / Math . Log ( 2 ) + 1 ) ) - 1 ; int [ , , ] dp = new int [ n + 1 , m + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) dp [ i , j , k ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { dp [ i , j , k ] = dp [ i - 1 , j , k ] ; if ( k != 0 ) { dp [ i , j , k ] += k * dp [ i - 1 , j ^ arr [ i - 1 ] , k - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ n , K , i ] ; } return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int k = 1 ; int n = arr . Length ; Console . WriteLine ( subsetXOR ( arr , n , k ) ) ; } }
using System ; class GFG { static int get_max_splits ( String num_String ) { int count = 0 , current_num ; int running_sum = 0 ; for ( int i = 0 ; i < num_String . Length ; i ++ ) { current_num = num_String [ i ] - '0' ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; } public static void Main ( String [ ] args ) { Console . Write ( get_max_splits ( "12345" ) + " STRNEWLINE " ) ; } }
using System ; class GFG { static int findMinimumCost ( int n , int x , int y ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . Min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = Math . Min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; } public static void Main ( ) { int n = 4 , x = 2 , y = 1 ; Console . WriteLine ( findMinimumCost ( n , x , y ) ) ; } }
using System ; public class GFG { static int nCr ( int n , int r ) { int ans = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; i ++ ) { ans *= ( n - i ) ; ans /= ( i + 1 ) ; } return ans ; } static int countDerangements ( int n ) { int [ ] der = new int [ n + 3 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; } static int countPermutations ( int n , int k ) { int ans = 0 ; for ( int i = n - k ; i <= n ; i ++ ) { int ways = nCr ( n , i ) ; ans += ( ways * countDerangements ( n - i ) ) ; } return ans ; } public static void Main ( ) { int n = 5 , k = 3 ; Console . WriteLine ( countPermutations ( n , k ) ) ; } }
using System ; class GFG { static int squares ( int i ) { if ( ( i & 1 ) == 1 ) return i / 4 * 2 + 1 ; else return ( i - 1 ) / 4 * 2 + 2 ; } static long bishop_placements ( int n , int k ) { if ( k > 2 * n - 1 ) return 0 ; long [ , ] dp = new long [ n * 2 , k + 1 ] ; for ( int i = 0 ; i < n * 2 ; i ++ ) dp [ i , 0 ] = 1 ; dp [ 1 , 1 ] = 1 ; for ( int i = 2 ; i < n * 2 ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) dp [ i , j ] = dp [ i - 2 , j ] + dp [ i - 2 , j - 1 ] * ( squares ( i ) - j + 1 ) ; } long ans = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 , i ] * dp [ n * 2 - 2 , k - i ] ; } return ans ; } static public void Main ( ) { int n = 2 ; int k = 2 ; long ans = bishop_placements ( n , k ) ; Console . WriteLine ( ans ) ; } }
using System ; class GFG { static int countStaircases ( int N ) { int [ , ] memo = new int [ N + 5 , N + 5 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { memo [ i , j ] = 0 ; } } memo [ 3 , 2 ] = memo [ 4 , 2 ] = 1 ; for ( int i = 5 ; i <= N ; i ++ ) { for ( int j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i , j ] = memo [ i - j , j ] + 1 ; } else { memo [ i , j ] = memo [ i - j , j ] + memo [ i - j , j - 1 ] ; } } } int answer = 0 ; for ( int i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N , i ] ; return answer ; } public static void Main ( ) { int N = 7 ; Console . WriteLine ( countStaircases ( N ) ) ; } }
using System ; class GFG { public int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; } public static void Main ( ) { GFG g = new GFG ( ) ; int n = 5 , m = 5 ; Console . WriteLine ( g . countPaths ( n , m ) ) ; Console . Read ( ) ; } }
using System ; class GFG { static int countPaths ( int m , int n ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i , j ] = 1 ; else dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] ; } } return dp [ m , n ] ; } public static void Main ( ) { int n = 5 ; int m = 5 ; Console . WriteLine ( countPaths ( n , m ) ) ; } }
using System ; class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( catalan ( n ) ) ; } }
using System ; class GFG { static void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; Console . Write ( f1 + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) Console . Write ( f3 + " ▁ " ) ; f1 = f2 ; f2 = f3 ; } } public static void Main ( ) { int N = 15 ; alternateFib ( N ) ; } }
using System ; class GFG { static int totalWays ( int N , int M , int X ) { int [ , ] dp = new int [ N + 1 , 2 ] ; if ( X == 1 ) { dp [ 0 , 0 ] = 1 ; } else { dp [ 0 , 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 , 0 ] = 0 ; dp [ 1 , 1 ] = M - 1 ; } else { dp [ 1 , 0 ] = 1 ; dp [ 1 , 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i , 0 ] = dp [ i - 1 , 1 ] ; dp [ i , 1 ] = dp [ i - 1 , 0 ] * ( M - 1 ) + dp [ i - 1 , 1 ] * ( M - 2 ) ; } return dp [ N - 1 , 0 ] ; } public static void Main ( ) { int N = 4 , M = 3 , X = 2 ; Console . WriteLine ( totalWays ( N , M , X ) ) ; } }
using System ; class GFG { static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } static public void Main ( ) { int n = 6 ; Console . WriteLine ( fib ( n ) ) ; } }
using System ; class GFG { static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int sumOfproduct ( int n ) { return binomialCoeff ( 2 * n , n - 1 ) ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( sumOfproduct ( n ) ) ; } }
using System ; class GFG { static void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) Console . Write ( a + " ▁ " ) ; if ( n >= 1 ) Console . Write ( b + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; Console . Write ( c + " ▁ " ) ; a = b ; b = c ; } } public static void Main ( ) { fib ( 9 ) ; } }
using System ; class GFG { static int pre_compute ( int [ ] a , int n , int index , int k ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 , i ] = a [ i ] + a [ 0 ] ; else dp [ 0 , i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 , i ] + a [ j ] > dp [ i - 1 , j ] ) dp [ i , j ] = dp [ i - 1 , i ] + a [ j ] ; else dp [ i , j ] = dp [ i - 1 , j ] ; } else dp [ i , j ] = dp [ i - 1 , j ] ; } } return dp [ index , k ] ; } static public void Main ( ) { int [ ] a = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = a . Length ; int index = 4 , k = 6 ; Console . WriteLine ( pre_compute ( a , n , index , k ) ) ; } }
using System ; class GFG { static int gen ( int n ) { int [ ] S = new int [ n + 1 ] ; S [ 0 ] = 0 ; if ( n != 0 ) S [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) S [ i ] = 4 * S [ i / 2 ] ; else S [ i ] = 4 * S [ i / 2 ] + 1 ; } return S [ n ] ; } static void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( gen ( i ) + " ▁ " ) ; } public static void Main ( ) { int n = 15 ; Console . WriteLine ( " First ▁ " + n + " ▁ terms ▁ of ▁ " + " Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ " ) ; moserDeBruijn ( n ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int LCSubStr ( string X , string Y ) { int m = X . Length ; int n = Y . Length ; int result = 0 ; int [ , ] len = new int [ 2 , n ] ; int currRow = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow , j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow , j ] = len [ ( 1 - currRow ) , ( j - 1 ) ] + 1 ; result = Math . Max ( result , len [ currRow , j ] ) ; } else { len [ currRow , j ] = 0 ; } } currRow = 1 - currRow ; } return result ; } public static void Main ( ) { string X = " GeeksforGeeks " ; string Y = " GeeksQuiz " ; Console . Write ( LCSubStr ( X , Y ) ) ; } }
using System ; class GFG { static int minimalSteps ( String s , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = int . MaxValue ; String s1 = " " , s2 = " " ; dp [ 0 ] = 1 ; s1 += s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s [ i ] ; s2 = s . Substring ( i , 1 ) ; dp [ i ] = Math . Min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = Math . Min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; } public static void Main ( String [ ] args ) { String s = " aaaaaaaa " ; int n = s . Length ; Console . Write ( minimalSteps ( s , n ) / 2 ) ; } }
using System ; class GFG { static void printGolomb ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 1 ; Console . Write ( dp [ 1 ] + " ▁ " ) ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; Console . Write ( dp [ i ] + " ▁ " ) ; } } public static void Main ( ) { int n = 9 ; printGolomb ( n ) ; } }
using System ; class GFG { public static int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . Max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; } public static void Main ( string [ ] args ) { string str = "11000010001" ; int n = str . Length ; Console . WriteLine ( findLength ( str , n ) ) ; } }
using System ; class GFG { static int DP_s = 9 ; static int getNumStrictMonotone ( int len ) { int [ , ] DP = new int [ len , DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 , i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i , j ] = DP [ i - 1 , j - 1 ] + DP [ i , j - 1 ] ; return DP [ len - 1 , DP_s - 1 ] ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( getNumStrictMonotone ( n ) ) ; } }
using System ; class GFG { static int chordCnt ( int A ) { int n = 2 * A ; int [ ] dpArray = new int [ n + 1 ] ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; } public static void Main ( ) { int N ; N = 2 ; Console . WriteLine ( chordCnt ( N ) ) ; N = 1 ; Console . WriteLine ( chordCnt ( N ) ) ; N = 4 ; Console . WriteLine ( chordCnt ( N ) ) ; } }
using System ; class GFG { static bool isPath ( int [ , ] arr ) { arr [ 0 , 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ i , 0 ] != - 1 ) arr [ i , 0 ] = arr [ i - 1 , 0 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 , j ] != - 1 ) arr [ 0 , j ] = arr [ 0 , j - 1 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i , j ] != - 1 ) arr [ i , j ] = Math . Max ( arr [ i , j - 1 ] , arr [ i - 1 , j ] ) ; return ( arr [ 5 - 1 , 5 - 1 ] == 1 ) ; } public static void Main ( ) { int [ , ] arr = { { 0 , 0 , 0 , - 1 , 0 } , { - 1 , 0 , 0 , - 1 , - 1 } , { 0 , 0 , 0 , - 1 , 0 } , { - 1 , 0 , - 1 , 0 , - 1 } , { 0 , 0 , - 1 , 0 , 0 } } ; if ( isPath ( arr ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( nswp ( n ) ) ; } }
using System ; class GFG { static int nswp ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( nswp ( n ) ) ; } }
using System ; public class GfG { static int lcs ( string X , string Y , int m , int n ) { int [ , ] L = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 2 * ( X [ i - 1 ] - '0' ) ; else L [ i , j ] = L [ i - 1 , j ] > L [ i , j - 1 ] ? L [ i - 1 , j ] : L [ i , j - 1 ] ; } } return L [ m , n ] ; } static int findMinCost ( string X , string Y ) { int m = X . Length , n = Y . Length ; int cost = 0 ; for ( int i = 0 ; i < m ; ++ i ) cost += X [ i ] - '0' ; for ( int i = 0 ; i < n ; ++ i ) cost += Y [ i ] - '0' ; return cost - lcs ( X , Y , m , n ) ; } public static void Main ( ) { string X = "3759" ; string Y = "9350" ; Console . WriteLine ( " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings " + " ▁ identical ▁ is ▁ = ▁ " + findMinCost ( X , Y ) ) ; } }
using System ; class GFG { static bool isSubSeqDivisible ( String str ) { int n = str . Length ; int [ , ] dp = new int [ n + 1 , 10 ] ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = ( int ) ( str [ i - 1 ] - '0' ) ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i , arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 , j ] > dp [ i , ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i , ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 , j ] ; if ( dp [ i - 1 , j ] > dp [ i , j ] ) dp [ i , j ] = dp [ i - 1 , j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i , 0 ] == 1 ) return true ; } return false ; } public static void Main ( ) { string str = "3144" ; if ( isSubSeqDivisible ( str ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int maxLength ( String s , int n ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ( ' && s [ i + 1 ] == ' ) ' ) dp [ i , i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ( ' && s [ j ] == ' ) ' ) dp [ i , j ] = 2 + dp [ i + 1 , j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i , k ] + dp [ k + 1 , j ] ) ; } } return dp [ 0 , n - 1 ] ; } public static void Main ( ) { string s = " ( ) ( ( ( ( ( ( ) " ; int n = s . Length ; Console . WriteLine ( maxLength ( s , n ) ) ; } }
using System ; class GFG { static int smallestSumSubarr ( int [ ] arr , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . Min ( min_so_far , min_ending_here ) ; } return min_so_far ; } public static void Main ( ) { int [ ] arr = { 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 } ; int n = arr . Length ; Console . Write ( " Smallest ▁ sum : ▁ " + smallestSumSubarr ( arr , n ) ) ; } }
using System ; class GFG { static long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; long same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; } static void Main ( ) { int n = 3 , k = 2 ; Console . Write ( countWays ( n , k ) ) ; } }
using System ; public class GFG { public static long sumOfSubstrings ( string num ) { long sum = 0 ; long mf = 1 ; for ( int i = num . Length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; } public static void Main ( ) { string num = "6759" ; Console . WriteLine ( sumOfSubstrings ( num ) ) ; } }
using System ; class Test { static int maxSumWithK ( int [ ] a , int n , int k ) { int [ ] maxSum = new int [ n ] ; maxSum [ 0 ] = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = Math . Max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; } int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += a [ i ] ; int result = sum ; for ( int i = k ; i < n ; i ++ ) { sum = sum + a [ i ] - a [ i - k ] ; result = Math . Max ( result , sum ) ; result = Math . Max ( result , sum + maxSum [ i - k ] ) ; } return result ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , - 10 , - 3 } ; int k = 4 ; Console . Write ( maxSumWithK ( arr , arr . Length , k ) ) ; ; } }
using System ; class Gfg { static int [ ] arr = { 1 , 5 , 6 } ; static int countWays ( int N ) { int [ ] count = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < arr . Length ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; } public static void Main ( ) { int N = 7 ; Console . Write ( " Total ▁ number ▁ of ▁ ways ▁ = ▁ " + countWays ( N ) ) ; } }
using System ; class GFG { static int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; } public static void Main ( ) { int m = 10 ; int n = 4 ; Console . Write ( " Total ▁ number ▁ of ▁ possible ▁ sequences ▁ " + getTotalNumberOfSequences ( m , n ) ) ; } }
using System ; class Sequences { static int getTotalNumberOfSequences ( int m , int n ) { int [ , ] T = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i , j ] = 0 ; else if ( i < j ) T [ i , j ] = 0 ; else if ( j == 1 ) T [ i , j ] = i ; else T [ i , j ] = T [ i - 1 , j ] + T [ i / 2 , j - 1 ] ; } } return T [ m , n ] ; } public static void Main ( ) { int m = 10 ; int n = 4 ; Console . WriteLine ( " Total ▁ number ▁ of ▁ possible ▁ sequences ▁ " + getTotalNumberOfSequences ( m , n ) ) ; } }
using System ; class GfG { static int lis ( int [ ] arr , int n ) { int result = 0 ; int [ ] lis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; } static int minimumNumberOfDeletions ( int [ ] arr , int n ) { int len = lis ( arr , n ) ; return ( n - len ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 } ; int n = arr . Length ; Console . Write ( " Minimum ▁ number ▁ of " + " ▁ deletions ▁ = ▁ " + minimumNumberOfDeletions ( arr , n ) ) ; } }
using System ; class GFG { static int lps ( String str ) { int n = str . Length ; int [ , ] L = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i , i ] = 1 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i , j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i , j ] = L [ i + 1 , j - 1 ] + 2 ; else L [ i , j ] = Math . Max ( L [ i , j - 1 ] , L [ i + 1 , j ] ) ; } } return L [ 0 , n - 1 ] ; } static int minimumNumberOfDeletions ( string str ) { int n = str . Length ; int len = lps ( str ) ; return ( n - len ) ; } public static void Main ( ) { string str = " geeksforgeeks " ; Console . Write ( " Minimum ▁ number ▁ of " + " ▁ deletions ▁ = ▁ " + minimumNumberOfDeletions ( str ) ) ; } }
using System ; class GFG { static int offeringNumber ( int n , int [ ] templeHeight ) { for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . Max ( right , left ) + 1 ; } return sum ; } static public void Main ( ) { int [ ] arr1 = { 1 , 2 , 2 } ; Console . WriteLine ( offeringNumber ( 3 , arr1 ) ) ; int [ ] arr2 = { 1 , 4 , 3 , 6 , 2 , 1 } ; Console . WriteLine ( offeringNumber ( 6 , arr2 ) ) ; } }
using System ; class GFG { static bool modularSum ( int [ ] arr , int n , int m ) { if ( n > m ) return true ; bool [ ] DP = new bool [ m ] ; for ( int l = 0 ; l < DP . Length ; l ++ ) DP [ l ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool [ ] temp = new bool [ m ] ; for ( int l = 0 ; l < temp . Length ; l ++ ) temp [ l ] = false ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; } public static void Main ( ) { int [ ] arr = { 1 , 7 } ; int n = arr . Length ; int m = 5 ; if ( modularSum ( arr , n , m ) ) Console . Write ( " YES STRNEWLINE " ) ; else Console . Write ( " NO STRNEWLINE " ) ; } }
using System ; class GFG { static int maxSum ( int [ , ] tri , int n ) { if ( n > 1 ) tri [ 1 , 1 ] = tri [ 1 , 1 ] + tri [ 0 , 0 ] ; tri [ 1 , 0 ] = tri [ 1 , 0 ] + tri [ 0 , 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { tri [ i , 0 ] = tri [ i , 0 ] + tri [ i - 1 , 0 ] ; tri [ i , i ] = tri [ i , i ] + tri [ i - 1 , i - 1 ] ; for ( int j = 1 ; j < i ; j ++ ) { if ( tri [ i , j ] + tri [ i - 1 , j - 1 ] >= tri [ i , j ] + tri [ i - 1 , j ] ) tri [ i , j ] = tri [ i , j ] + tri [ i - 1 , j - 1 ] ; else tri [ i , j ] = tri [ i , j ] + tri [ i - 1 , j ] ; } } int max = tri [ n - 1 , 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 , i ] ) max = tri [ n - 1 , i ] ; } return max ; } public static void Main ( ) { int [ , ] tri = { { 1 , 0 , 0 } , { 2 , 1 , 0 } , { 3 , 3 , 2 } } ; Console . Write ( maxSum ( tri , 3 ) ) ; } }
using System ; class GFG { static int maximumDifferenceSum ( int [ ] arr , int N ) { int [ , ] dp = new int [ N , 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i , 0 ] = dp [ i , 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 , 0 ] = Math . Max ( dp [ i , 0 ] , dp [ i , 1 ] + Math . Abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 , 1 ] = Math . Max ( dp [ i , 0 ] + Math . Abs ( arr [ i + 1 ] - 1 ) , dp [ i , 1 ] + Math . Abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . Max ( dp [ N - 1 , 0 ] , dp [ N - 1 , 1 ] ) ; } public static void Main ( ) { int [ ] arr = { 3 , 2 , 1 , 4 , 5 } ; int N = arr . Length ; Console . Write ( maximumDifferenceSum ( arr , N ) ) ; } }
using System ; class GFG { static int N = 8 ; static int [ ] dx = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; static int [ ] dy = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; static bool inside ( int x , int y ) { return ( x >= 0 && x < N && y >= 0 && y < N ) ; } static double findProb ( int start_x , int start_y , int steps ) { double [ , , ] dp1 = new double [ N , N , steps + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) dp1 [ i , j , 0 ] = 1 ; for ( int s = 1 ; s <= steps ; ++ s ) { for ( int x = 0 ; x < N ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) { double prob = 0.0 ; for ( int i = 0 ; i < 8 ; ++ i ) { int nx = x + dx [ i ] ; int ny = y + dy [ i ] ; if ( inside ( nx , ny ) ) prob += dp1 [ nx , ny , s - 1 ] / 8.0 ; } dp1 [ x , y , s ] = prob ; } } } return dp1 [ start_x , start_y , steps ] ; } static void Main ( ) { int K = 3 ; Console . WriteLine ( findProb ( 0 , 0 , K ) ) ; } }
using System ; class GFG { static int countSubarray ( int [ ] arr , int n , int k ) { int s = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += ( ( count * ( count + 1 ) ) / 2 ) ; } return ( n * ( n + 1 ) / 2 - s ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int k = 2 ; int n = arr . Length ; Console . WriteLine ( countSubarray ( arr , n , k ) ) ; } }
using System ; class GFG { static int nCr ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; } static double resultOfAllSubsets ( int [ ] arr , int N ) { double result = 0.0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( int n = 1 ; n <= N ; n ++ ) result += ( double ) ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 5 , 7 } ; int N = arr . Length ; Console . WriteLine ( resultOfAllSubsets ( arr , N ) ) ; } }
using System ; class GFG { static int [ ] arr = { 100 , 1000 , 100 , 1000 , 1 } ; static int [ ] sum = new int [ 10000 ] ; static int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . Max ( Math . Max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; } public static void Main ( String [ ] args ) { int n = arr . Length ; for ( int i = 0 ; i < sum . Length ; i ++ ) sum [ i ] = - 1 ; Console . WriteLine ( maxSumWO3Consec ( n ) ) ; } }
using System ; class GFG { static int maxSumPairWithDifferenceLessThanK ( int [ ] arr , int N , int k ) { int maxSum = 0 ; Array . Sort ( arr ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; } public static void Main ( ) { int [ ] arr = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = arr . Length ; int K = 4 ; Console . Write ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) ; } }
using System ; class GFG { static int countGroups ( int position , int previous_sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; } public static void Main ( ) { String num = "1119" ; int len = num . Length ; Console . Write ( countGroups ( 0 , 0 , len , num ) ) ; } }
using System ; class GFG { static int count ( String a , String b ) { int m = a . Length ; int n = b . Length ; int [ , ] lookup = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 , i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i , 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i , j ] = lookup [ i - 1 , j - 1 ] + lookup [ i - 1 , j ] ; else lookup [ i , j ] = lookup [ i - 1 , j ] ; } } return lookup [ m , n ] ; } public static void Main ( ) { String a = " GeeksforGeeks " ; String b = " Gks " ; Console . WriteLine ( count ( a , b ) ) ; } }
using System ; class GFG { public static int lcs ( string X , string Y ) { int m = X . Length , n = Y . Length ; int [ , ] L = new int [ 2 , n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi , j ] = L [ 1 - bi , j - 1 ] + 1 ; else L [ bi , j ] = Math . Max ( L [ 1 - bi , j ] , L [ bi , j - 1 ] ) ; } } return L [ bi , n ] ; } public static void Main ( ) { string X = " AGGTAB " ; string Y = " GXTXAYB " ; Console . Write ( " Length ▁ of ▁ LCS ▁ is ▁ " + lcs ( X , Y ) ) ; } }
using System ; class GFG { static int subsetXOR ( int [ ] arr , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . Log ( max_ele , 2 ) + 1 ) ) - 1 ; if ( k > m ) { return 0 ; } int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i , j ] = 0 ; dp [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 1 , j ^ arr [ i - 1 ] ] ; return dp [ n , k ] ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int k = 4 ; int n = arr . Length ; Console . WriteLine ( " Count ▁ of ▁ subsets ▁ is ▁ " + subsetXOR ( arr , n , k ) ) ; } }
using System ; class GFG { static int countSol ( int [ ] coeff , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; } public static void Main ( ) { int [ ] coeff = { 2 , 2 , 5 } ; int rhs = 4 ; int n = coeff . Length ; Console . Write ( countSol ( coeff , 0 , n - 1 , rhs ) ) ; } }
using System ; class GFG { static int steps ( int source , int step , int dest ) { if ( Math . Abs ( source ) > ( dest ) ) return int . MaxValue ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . Min ( pos , neg ) ; } public static void Main ( ) { int dest = 11 ; Console . WriteLine ( " No . ▁ of ▁ steps ▁ required " + " ▁ to ▁ reach ▁ " + dest + " ▁ is ▁ " + steps ( 0 , 0 , dest ) ) ; } }
using System ; class GFG { static String X , Y ; static int lcs ( int i , int j , int count ) { if ( i == 0 j == 0 ) { return count ; } if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . Max ( count , Math . Max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; } public static void Main ( ) { int n , m ; X = " abcdxyz " ; Y = " xyzabcd " ; n = X . Length ; m = Y . Length ; Console . Write ( lcs ( n , m , 0 ) ) ; } }
using System ; class GFG { static int no_of_characters ( int M ) { int k = 1 ; while ( true ) { if ( ( int ) Math . Pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; } return k ; } static void print_string ( int M ) { int k , num , N ; k = no_of_characters ( M ) ; N = M - ( ( int ) Math . Pow ( 2 , k ) - 2 ) ; while ( k > 0 ) { num = ( int ) Math . Pow ( 2 , k - 1 ) ; if ( num >= N ) Console . Write ( " A " ) ; else { Console . Write ( " B " ) ; N -= num ; } k -- ; } Console . WriteLine ( ) ; } public static void Main ( ) { int M ; M = 30 ; print_string ( M ) ; M = 55 ; print_string ( M ) ; M = 100 ; print_string ( M ) ; } }
using System ; class GFG { static string updateString ( string S , string A , string B ) { int l = A . Length ; for ( int i = 0 ; i + l <= S . Length ; i ++ ) { string curr = S . Substring ( i , l ) ; if ( curr . Equals ( A ) ) { string new_string = S . Substring ( 0 , i ) + B + S . Substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { string new_string = S . Substring ( 0 , i ) + A + S . Substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; } public static void Main ( ) { string S = " aab " ; string A = " aa " ; string B = " bb " ; Console . WriteLine ( updateString ( S , A , B ) ) ; } }
using System ; class GFG { static void printPattern ( int n , int m ) { if ( m > 2 * ( n + 1 ) m < n - 1 ) { Console . Write ( " - 1" ) ; } else if ( Math . Abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { Console . Write ( "01" ) ; n -- ; m -- ; } if ( n != 0 ) { Console . Write ( "0" ) ; } if ( m != 0 ) { Console . Write ( "1" ) ; } } else { while ( m - n > 1 && n > 0 ) { Console . Write ( "110" ) ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { Console . Write ( "10" ) ; n -- ; m -- ; } while ( m > 0 ) { Console . Write ( "1" ) ; m -- ; } } } public static void Main ( ) { int n = 4 , m = 8 ; printPattern ( n , m ) ; } }
using System ; class GFG { static int countDecreasing ( int [ ] A , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } static void Main ( ) { int [ ] A = { 100 , 3 , 1 , 13 } ; int n = A . Length ; Console . WriteLine ( countDecreasing ( A , n ) ) ; } }
using System ; class GFG { static int minimumChar ( String S1 , String S2 ) { int n = S1 . Length ; int m = S2 . Length ; int ans = Int32 . MaxValue ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . Min ( minRemovedChar , ans ) ; } return ans ; } public static void Main ( ) { String S1 = " abc " ; String S2 = " paxzk " ; Console . WriteLine ( minimumChar ( S1 , S2 ) ) ; } }
using System ; public class GFG { static int countFreq ( String pat , String txt ) { int M = pat . Length ; int N = txt . Length ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; } static public void Main ( ) { String txt = " dhimanman " ; String pat = " man " ; Console . Write ( countFreq ( pat , txt ) ) ; } }
using System ; class GFG { static void search ( string pat , string txt ) { int M = pat . Length ; int N = txt . Length ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; { Console . WriteLine ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j = = 0 ) i = i + 1 ; else i = i + j ; } } static void Main ( ) { string txt = " ABCEABCDABCEABCD " ; string pat = " ABCD " ; search ( pat , txt ) ; } }
using System ; class GFG { static void printMatrix ( int n , int m ) { if ( n < 5 m < 5 ) { Console . Write ( - 1 ) ; return ; } char [ ] s = " aeiou " . ToCharArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { Console . Write ( s [ j % 5 ] + " ▁ " ) ; } Console . WriteLine ( ) ; char c = s [ 0 ] ; for ( int k = 0 ; k < 4 ; k ++ ) { s [ k ] = s [ k + 1 ] ; } s [ 4 ] = c ; } } public static void Main ( String [ ] args ) { int n = 5 , m = 5 ; printMatrix ( n , m ) ; } }
using System ; class GFG { static int minOperations ( int n , string a , string b , string c ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a [ i ] ; char y = b [ i ] ; char z = c [ i ] ; if ( x == y && y == z ) { ; } else if ( x == y y == z x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; } public static void Main ( ) { string a = " place " ; string b = " abcde " ; string c = " plybe " ; int n = a . Length ; Console . Write ( minOperations ( n , a , b , c ) ) ; } }
using System ; class GFG { static bool check ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; } public static void Main ( String [ ] args ) { String s = " geeksforgeeks " ; if ( check ( s ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int countSubStr ( String str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; } public static void Main ( String [ ] args ) { String str = " abcabc " ; int n = str . Length ; char x = ' c ' ; Console . WriteLine ( countSubStr ( str , n , x ) ) ; } }
using System ; class GFG { static int countSubStr ( string str , int n ) { int len = str . Length ; return ( len - n + 1 ) ; } public static void Main ( ) { string str = " geeksforgeeks " ; int n = 5 ; Console . WriteLine ( countSubStr ( str , n ) ) ; } }
using System ; class GFG { static int countSubstrings ( string s , char c ) { int n = s . Length ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; } public static void Main ( ) { string s = " baa " ; char c = ' b ' ; Console . Write ( countSubstrings ( s , c ) ) ; } }
using System ; class GFG { static bool isPalindrome ( string s ) { int i = 0 ; int j = s . Length - 1 ; while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; } static int getIndex ( string S1 , string S2 , int n ) { string S = " " ; for ( int i = 0 ; i < n ; i ++ ) { S = S + S1 [ i ] ; string Temp = " " ; for ( int j = i + 1 ; j < n ; j ++ ) Temp += S2 [ j ] ; if ( isPalindrome ( S + Temp ) ) { return i ; } } return - 1 ; } public static void Main ( ) { string S1 = " abcdf " , S2 = " sfgba " ; int n = S1 . Length ; Console . WriteLine ( getIndex ( S1 , S2 , n ) ) ; } }
using System ; class GFG { static bool valid ( int [ ] cnt ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; } static string getGoodString ( string ss , int n ) { char [ ] s = ss . ToCharArray ( ) ; if ( n < 26 ) return " - 1" ; int [ ] cnt = new int [ 27 ] ; for ( int i = 25 ; i < n ; i ++ ) { for ( int j = i ; j >= i - 25 ; j -- ) { if ( s [ j ] != ' ? ' ) cnt [ ( ( int ) s [ j ] - ( int ) ' a ' ) ] ++ ; } if ( valid ( cnt ) ) { int cur = 0 ; while ( cnt [ cur ] > 0 ) cur ++ ; for ( int j = i - 25 ; j <= i ; j ++ ) { if ( s [ j ] == ' ? ' ) { s [ j ] = ( char ) ( cur + ( int ) ( ' a ' ) ) ; cur ++ ; while ( cnt [ cur ] > 0 ) cur ++ ; } } return new String ( s ) ; } } return " - 1" ; } static void Main ( ) { string s = " abcdefghijkl ? nopqrstuvwxy ? " ; int n = s . Length ; Console . WriteLine ( getGoodString ( s , n ) ) ; } }
using System ; class GFG { static bool isVowel ( char c ) { c = char . ToLower ( c ) ; if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) { return true ; } return false ; } static String swapRepeated ( char [ ] str ) { for ( int i = 0 ; i < str . Length - 1 ; i ++ ) { char c = ( char ) 0 ; if ( ( isVowel ( str [ i ] ) && isVowel ( str [ i + 1 ] ) ) || ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i + 1 ] ) ) ) { c = str [ i ] ; str [ i ] = str [ i + 1 ] ; str [ i + 1 ] = c ; } } return String . Join ( " " , str ) ; } public static void Main ( String [ ] args ) { String str = " geeksforgeeks " ; Console . WriteLine ( swapRepeated ( str . ToCharArray ( ) ) ) ; } }
using System ; class GFG { static string largestPalinSub ( string s ) { string res = " " ; char mx = s [ 0 ] ; for ( int i = 1 ; i < s . Length ; i ++ ) mx = ( char ) Math . Max ( ( int ) mx , ( int ) s [ i ] ) ; for ( int i = 0 ; i < s . Length ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; } public static void Main ( ) { string s = " geeksforgeeks " ; Console . WriteLine ( largestPalinSub ( s ) ) ; } }
using System ; class GFG { static void printString ( char [ ] str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; bool used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) Console . Write ( "1" ) ; } if ( str [ i ] != '1' ) Console . Write ( str [ i ] ) ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) Console . Write ( "1" ) ; } public static void Main ( String [ ] args ) { String str = "100210" ; int n = str . Length ; printString ( str . ToCharArray ( ) , n ) ; } }
using System ; class solution { static int findPermutation ( string str , int k ) { bool [ ] has = new bool [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) has [ i ] = false ; int cnt = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( ! has [ str [ i ] - ' a ' ] ) { cnt ++ ; has [ str [ i ] - ' a ' ] = true ; } } int ans = 1 ; for ( int i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( int i = cnt - k ; i > 1 ; i -- ) ans /= i ; return ans ; } public static void Main ( ) { string str = " geeksforgeeks " ; int k = 4 ; Console . WriteLine ( findPermutation ( str , k ) ) ; } }
using System ; class GFG { static int product ( int x ) { int prod = 1 ; while ( x > 0 ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; } static int findNumber ( int l , int r ) { string b = r . ToString ( ) ; int ans = r ; for ( int i = 0 ; i < b . Length ; i ++ ) { if ( b [ i ] == '0' ) continue ; char [ ] curr = b . ToCharArray ( ) ; curr [ i ] = ( char ) ( ( ( int ) ( curr [ i ] - ( int ) '0' ) - 1 ) + ( int ) ( '0' ) ) ; for ( int j = i + 1 ; j < curr . Length ; j ++ ) curr [ j ] = '9' ; int num = 0 ; for ( int j = 0 ; j < curr . Length ; j ++ ) num = num * 10 + ( curr [ j ] - '0' ) ; if ( num >= l && product ( ans ) < product ( num ) ) ans = num ; } return ans ; } static void Main ( ) { int l = 1 , r = 10 ; Console . WriteLine ( findNumber ( l , r ) ) ; l = 51 ; r = 62 ; Console . WriteLine ( findNumber ( l , r ) ) ; } }
using System ; class GFG { static void constructBinString ( int a , int b , int x ) { int d , i ; d = x / 2 ; if ( x % 2 == 0 && x / 2 != a ) { d -- ; Console . Write ( "0" ) ; a -- ; } for ( i = 0 ; i < d ; i ++ ) Console . Write ( "10" ) ; a = a - d ; b = b - d ; for ( i = 0 ; i < b ; i ++ ) { Console . Write ( "1" ) ; } for ( i = 0 ; i < a ; i ++ ) { Console . Write ( "0" ) ; } } public static void Main ( ) { int a = 4 , b = 3 , x = 2 ; constructBinString ( a , b , x ) ; } }
using System ; public class GFG { static bool matchPattern ( string s ) { int count = 0 ; int n = s . Length ; int i = 0 ; while ( i < n ) { while ( i < n && s [ i ] == ' a ' ) { count ++ ; i ++ ; } while ( i < n && s [ i ] == ' b ' ) { count -- ; i ++ ; } if ( count != 0 ) return false ; } return true ; } public static void Main ( ) { string s = " bb " ; if ( matchPattern ( s ) == true ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int maximum_one ( string s , int n ) { int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) cnt_one ++ ; } int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; if ( s [ 0 ] == '1' ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s [ n - 1 ] == '1' ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) left [ i ] = left [ i - 1 ] + 1 ; else left [ i ] = 0 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } int cnt = 0 , max_cnt = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == '0' ) { int sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) cnt = sum + 1 ; else cnt = sum ; max_cnt = Math . Max ( max_cnt , cnt ) ; cnt = 0 ; } } return max_cnt ; } public static void Main ( ) { string s = "111011101" ; Console . WriteLine ( maximum_one ( s , s . Length ) ) ; } }
using System ; class GFG { static int maxFreq ( string s , int a , int b ) { int [ ] fre = new int [ 10 ] ; int n = s . Length ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - '0' ] ++ ; if ( fre [ a ] == 0 && fre [ b ] == 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; } public static void Main ( ) { int a = 4 , b = 7 ; string s = "47744" ; Console . WriteLine ( maxFreq ( s , a , b ) ) ; } }
using System ; class GFG { static void convert ( int n , String a , String b ) { int [ ] l = new int [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) l [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) l [ i ] = 1 ; } int cc = 0 ; int vl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( l [ i ] == 0 ) { if ( vl != 0 ) cc += 1 ; vl = 0 ; } else vl += 1 ; } if ( vl != 0 ) cc += 1 ; Console . WriteLine ( cc ) ; } static public void Main ( ) { String a = "101010" ; String b = "110011" ; int n = a . Length ; convert ( n , a , b ) ; } }
using System ; class GFG { static int countWays ( string s1 , string s2 , int n ) { int a , b , c , d ; a = b = c = d = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s2 [ i ] == '0' ) { if ( s1 [ i ] == '0' ) { c ++ ; } else { d ++ ; } } else { if ( s1 [ i ] == '0' ) { a ++ ; } else { b ++ ; } } } result = a * d + b * c + c * d ; return result ; } public static void Main ( ) { int n = 5 ; string s1 = "01011" ; string s2 = "11001" ; Console . WriteLine ( countWays ( s1 , s2 , n ) ) ; } }
using System ; class GfG { static int returnWinner ( String s , int l ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] % 2 != 0 ) cnt ++ ; } if ( ( cnt == 0 ) || ( cnt & 1 ) == 1 ) return 1 ; else return 2 ; } public static void Main ( String [ ] args ) { String s = " abaaab " ; int l = s . Length ; int winner = returnWinner ( s , l ) ; Console . WriteLine ( " Player - " + winner ) ; } }
using System ; class GFG { static void maxProductSum ( string str , int m ) { int n = str . Length ; int maxProd = int . MinValue , maxSum = int . MinValue ; for ( int i = 0 ; i <= n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str [ j ] - '0' ) ; sum = sum + ( str [ j ] - '0' ) ; } maxProd = Math . Max ( maxProd , product ) ; maxSum = Math . Max ( maxSum , sum ) ; } Console . WriteLine ( " Maximum ▁ Product ▁ = ▁ " + maxProd ) ; Console . Write ( " STRNEWLINE Maximum ▁ Sum ▁ = ▁ " + maxSum ) ; } public static void Main ( ) { string str = "3605356297" ; int m = 3 ; maxProductSum ( str , m ) ; } }
using System ; class GFG { static int maxLength ( string s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = int . MinValue ; s = s + '1' ; for ( int i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == ' o ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == ' x ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == ' x ' ) ) left = 1 ; coun = ( int ) Math . Ceiling ( ( double ) coun / ( right + left ) ) ; max_length = Math . Max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; } public static void Main ( ) { string s = " oooxoooooooooxooo " ; int n = s . Length ; Console . Write ( maxLength ( s , n ) ) ; } }
using System ; class GFG { public static bool areVowelsInOrder ( string s ) { int n = s . Length ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { if ( s [ i ] < c ) { return false ; } else { c = s [ i ] ; } } } return true ; } public static void Main ( string [ ] args ) { string s = " aabbbddeecc " ; if ( areVowelsInOrder ( s ) ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } } }
using System ; class GFG { static int Remainder ( String str , int R ) { int len = str . Length ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - '0' ) ; Rem = Num % R ; } return Rem ; } public static void Main ( ) { String str = "13589234356546756" ; int R = 13 ; Console . WriteLine ( Remainder ( str , R ) ) ; } }
using System ; class GFG { static int count_carry ( string a , string b ) { int carry = 0 ; int count = 0 ; int len_a = a . Length , len_b = b . Length ; while ( len_a != 0 len_b != 0 ) { int x = 0 , y = 0 ; if ( len_a > 0 ) { x = a [ len_a - 1 ] - '0' ; len_a -- ; } if ( len_b > 0 ) { y = b [ len_b - 1 ] - '0' ; len_b -- ; } int sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; } public static void Main ( ) { string a = "9555" , b = "555" ; int count = count_carry ( a , b ) ; if ( count == 0 ) Console . Write ( "0 STRNEWLINE " ) ; else if ( count == 1 ) Console . Write ( "1 STRNEWLINE " ) ; else Console . Write ( count ) ; } }
using System ; class GFG { static bool isInGivenBase ( String str , int bas ) { if ( bas > 16 ) return false ; else if ( bas <= 10 ) { for ( int i = 0 ; i < str . Length ; i ++ ) if ( ! ( str [ i ] >= '0' && str [ i ] < ( '0' + bas ) ) ) return false ; } else { for ( int i = 0 ; i < str . Length ; i ++ ) if ( ! ( ( str [ i ] >= '0' && str [ i ] < ( '0' + bas ) ) || ( str [ i ] >= ' A ' && str [ i ] < ( ' A ' + bas - 10 ) ) ) ) return false ; } return true ; } public static void Main ( String [ ] args ) { String str = " AF87" ; if ( isInGivenBase ( str , 16 ) == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static void printIndex ( String str , String s ) { bool flag = false ; for ( int i = 0 ; i < str . Length - s . Length + 1 ; i ++ ) { if ( str . Substring ( i , s . Length ) . Equals ( s ) ) { Console . Write ( i + " ▁ " ) ; flag = true ; } } if ( flag == false ) { Console . WriteLine ( " NONE " ) ; } } public static void Main ( String [ ] args ) { String str1 = " GeeksforGeeks " ; String str2 = " Geeks " ; printIndex ( str1 , str2 ) ; } }
using System ; public class GFG { static int matchClosing ( char [ ] X , int start , int end , char open , char close ) { int c = 1 ; int i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i ++ ; } return i ; } static int matchingOpening ( char [ ] X , int start , int end , char open , char close ) { int c = - 1 ; int i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i -- ; } return - 1 ; } static bool isBalanced ( char [ ] X , int n ) { int i , j = 0 , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) { if ( X [ i ] == ' ( ' ) { j = matchClosing ( X , i , n - 1 , ' ( ' , ' ) ' ) ; } else if ( X [ i ] == ' { ' ) { j = matchClosing ( X , i , n - 1 , ' { ' , ' } ' ) ; } else if ( X [ i ] == ' [ ' ) { j = matchClosing ( X , i , n - 1 , ' [ ' , ' ] ' ) ; } else { if ( X [ i ] == ' ) ' ) { j = matchingOpening ( X , 0 , i , ' ( ' , ' ) ' ) ; } else if ( X [ i ] == ' } ' ) { j = matchingOpening ( X , 0 , i , ' { ' , ' } ' ) ; } else if ( X [ i ] == ' ] ' ) { j = matchingOpening ( X , 0 , i , ' [ ' , ' ] ' ) ; } if ( j < 0 j >= i ) { return false ; } continue ; } if ( j >= n j < 0 ) { return false ; } start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == ' ( ' ) { x = matchClosing ( X , k , end , ' ( ' , ' ) ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ) ' ) { x = matchingOpening ( X , start , k , ' ( ' , ' ) ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' { ' ) { x = matchClosing ( X , k , end , ' { ' , ' } ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' } ' ) { x = matchingOpening ( X , start , k , ' { ' , ' } ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' [ ' ) { x = matchClosing ( X , k , end , ' [ ' , ' ] ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ] ' ) { x = matchingOpening ( X , start , k , ' [ ' , ' ] ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; } public static void Main ( ) { char [ ] X = " [ ( ) ] ( ) " . ToCharArray ( ) ; int n = 6 ; if ( isBalanced ( X , n ) ) Console . Write ( " Yes STRNEWLINE " ) ; else Console . Write ( " No STRNEWLINE " ) ; char [ ] Y = " [ [ ( ) ] ] ) " . ToCharArray ( ) ; n = 7 ; if ( isBalanced ( Y , n ) ) Console . Write ( " Yes STRNEWLINE " ) ; else Console . Write ( " No STRNEWLINE " ) ; } }
using System ; class GFG { static string possibleToSort ( int [ ] arr , int n , string str ) { int max_element = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { max_element = Math . Max ( max_element , arr [ i ] ) ; if ( str [ i ] == '0' ) { if ( max_element > i + 1 ) return " No " ; } } return " Yes " ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; int n = arr . Length ; string str = "01110" ; Console . WriteLine ( possibleToSort ( arr , n , str ) ) ; } }
using System ; class GFG { public static bool isPrimeString ( string str ) { int len = str . Length , n = 0 ; for ( int i = 0 ; i < len ; i ++ ) { n += ( int ) str [ i ] ; } if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } public static void Main ( string [ ] args ) { string str = " geekRam " ; if ( isPrimeString ( str ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static int MAX = 256 ; static long fact ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int countPalinPermutations ( string str ) { int n = str . Length ; int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] ] ++ ; long res = fact ( n / 2 ) ; bool oddFreq = false ; for ( int i = 0 ; i < MAX ; i ++ ) { int half = freq [ i ] / 2 ; if ( freq [ i ] % 2 != 0 ) { if ( oddFreq == true ) return 0 ; oddFreq = true ; } res = res / fact ( half ) ; } return ( int ) res ; } public static void Main ( ) { string str = " gffg " ; Console . WriteLine ( countPalinPermutations ( str ) ) ; } }
using System ; class GFG { static bool checkPalindrome ( string str ) { int n = str . Length ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; } public static void Main ( ) { string str = " abccaa " ; if ( checkPalindrome ( str ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { result += ( n - i ) ; } } return result ; } public static void Main ( ) { string str = "10010" ; int n = 5 ; Console . WriteLine ( evenDecimalValue ( str , n ) ) ; } }
using System ; class GFG { static int countSubstr ( string s ) { int n = s . Length ; int [ ] auxArr = new int [ n ] ; if ( s [ 0 ] == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == '1' ) count += auxArr [ i ] ; return count ; } public static void Main ( ) { string s = "1101" ; Console . WriteLine ( countSubstr ( s ) ) ; } }
using System ; class GFG { static int MAX = 256 ; static bool canMakeStr2 ( string str1 , string str2 ) { int [ ] count = new int [ MAX ] ; for ( int i = 0 ; i < str1 . Length ; i ++ ) count [ str1 [ i ] ] ++ ; for ( int i = 0 ; i < str2 . Length ; i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false ; count [ str2 [ i ] ] -- ; } return true ; } static public void Main ( ) { string str1 = " geekforgeeks " ; string str2 = " for " ; if ( canMakeStr2 ( str1 , str2 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static void finalPosition ( String move ) { int l = move . Length ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( move [ i ] == ' U ' ) countUp ++ ; else if ( move [ i ] == ' D ' ) countDown ++ ; else if ( move [ i ] == ' L ' ) countLeft ++ ; else if ( move [ i ] == ' R ' ) countRight ++ ; } Console . WriteLine ( " Final ▁ Position : ▁ ( " + ( countRight - countLeft ) + " , ▁ " + ( countUp - countDown ) + " ) " ) ; } public static void Main ( ) { String move = " UDDLLRUUUDUURUDDUULLDRRRR " ; finalPosition ( move ) ; } }
using System ; class GFG { static int maxbalancedprefix ( string str , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; } public static void Main ( ) { string str = " ( ( ( ) ( ) ) ( ) ) ( ( " ; int n = str . Length ; Console . WriteLine ( maxbalancedprefix ( str , n ) ) ; } }
using System ; class GFG { static int cost ( String str ) { int len = str . Length ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str [ i ] != str [ j ] ) res += Math . Min ( str [ i ] , str [ j ] ) - ' a ' + 1 ; return res ; } public static void Main ( ) { string str = " abcdef " ; Console . WriteLine ( cost ( str ) ) ; } }
using System ; public class GFG { static int MAX_CHAR = 256 ; static bool isPresent ( string s , string q ) { int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . Length ; i ++ ) freq [ s [ i ] ] ++ ; for ( int i = 0 ; i < q . Length ; i ++ ) { freq [ q [ i ] ] -- ; if ( freq [ q [ i ] ] < 0 ) return false ; } return true ; } static public void Main ( ) { string s = " abctd " ; string q = " cat " ; if ( isPresent ( s , q ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int countReduce ( string str ) { int n = str . Length ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += Math . Abs ( str [ i ] - str [ n - i - 1 ] ) ; return res ; } public static void Main ( ) { string str = " abcd " ; Console . WriteLine ( countReduce ( str ) ) ; } }
using System ; class GFG { static int calculate ( string s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s [ 0 ] - '0' ) c ++ ; if ( j != s [ 1 ] - '0' ) c ++ ; if ( k != s [ 2 ] - '0' ) c ++ ; if ( l != s [ 3 ] - '0' ) c ++ ; if ( m != s [ 4 ] - '0' ) c ++ ; if ( n != s [ 5 ] - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; } static public void Main ( ) { string s = "123456" ; Console . WriteLine ( calculate ( s ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static bool makeAndCheckString ( List < String > words , String str ) { int n = words . Count ; bool first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; } public static void Main ( String [ ] args ) { String str = " ya " ; String [ ] array = { " ah " , " oy " , " to " , " ha " } ; List < String > words = new List < String > ( array ) ; if ( makeAndCheckString ( words , str ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class GFG { static bool sentencePalindrome ( String str ) { int l = 0 ; int h = str . Length - 1 ; str = str . ToLower ( ) ; while ( l <= h ) { char getAtl = str [ l ] ; char getAth = str [ h ] ; if ( ! ( getAtl >= ' a ' && getAtl <= ' z ' ) ) l ++ ; else if ( ! ( getAth >= ' a ' && getAth <= ' z ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; } public static void Main ( ) { String str = " Too ▁ hot ▁ to ▁ hoot . " ; if ( sentencePalindrome ( str ) ) Console . Write ( " Sentence ▁ is ▁ palindrome " ) ; else Console . Write ( " Sentence ▁ is ▁ not " + " ▁ " + " palindrome " ) ; } }
using System ; class GFG { static int xorZero ( string s ) { int one_count = 0 , zero_count = 0 ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; } public static void Main ( ) { string s = "11111" ; Console . WriteLine ( xorZero ( s ) ) ; } }
using System ; public class GFG { static int MAX_CHAR = 26 ; static bool checkCorrectOrNot ( String s ) { int [ ] count = new int [ MAX_CHAR ] ; int n = s . Length ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s [ i ] - ' a ' ] ++ ; count [ s [ j ] - ' a ' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; } public static void Main ( String [ ] args ) { String s = " abab " ; if ( checkCorrectOrNot ( s ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { public virtual bool uniqueCharacters ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { int bitAtIndex = str [ i ] - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; } public static void Main ( string [ ] args ) { GFG obj = new GFG ( ) ; string input = " geekforgeeks " ; if ( obj . uniqueCharacters ( input ) ) { Console . WriteLine ( " The ▁ String ▁ " + input + " ▁ has ▁ all ▁ unique ▁ characters " ) ; } else { Console . WriteLine ( " The ▁ String ▁ " + input + " ▁ has ▁ duplicate ▁ characters " ) ; } } }
using System ; class GFG { public static void isKthBitSet ( int n , int k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) Console . Write ( " SET " ) ; else Console . Write ( " NOT ▁ SET " ) ; } public static void Main ( ) { int n = 5 , k = 1 ; isKthBitSet ( n , k ) ; } }
using System ; class GFG { static bool isPalRec ( String str , int s , int e ) { if ( s == e ) return true ; if ( ( str [ s ] ) != ( str [ e ] ) ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } static bool isPalindrome ( String str ) { int n = str . Length ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; } public static void Main ( ) { String str = " geeg " ; if ( isPalindrome ( str ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static readonly int MAX_CHAR = 26 ; static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . Length ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; } public static void Main ( ) { String s = " abcab " ; Console . Write ( countSubstringWithEqualEnds ( s ) ) ; } }
using System ; class GFG { static char maxRepeating ( string str ) { int n = str . Length ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; } public static void Main ( ) { string str = " aaaabbaaccde " ; Console . Write ( maxRepeating ( str ) ) ; } }
using System ; public class GFG { static void query ( string s , int i , int j ) { int n = s . Length ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } static public void Main ( ) { string X = " geeksforgeeks " ; query ( X , 0 , 8 ) ; query ( X , 8 , 13 ) ; query ( X , 6 , 15 ) ; } }
using System ; class Test { static int countPairs ( string str ) { int result = 0 ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( str [ i ] - str [ j ] ) == Math . Abs ( i - j ) ) result ++ ; return result ; } public static void Main ( ) { string str = " geeksforgeeks " ; Console . WriteLine ( countPairs ( str ) ) ; } }
using System ; class GFG { static void longestString ( String str1 , String str2 ) { int [ ] count1 = new int [ 26 ] ; int [ ] count2 = new int [ 26 ] ; for ( int i = 0 ; i < str1 . Length ; i ++ ) { count1 [ str1 [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < str2 . Length ; i ++ ) { count2 [ str2 [ i ] - ' a ' ] ++ ; } String result = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . Min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += ( char ) ( ' a ' + i ) ; } } Console . Write ( result ) ; } public static void Main ( ) { String str1 = " geeks " , str2 = " cake " ; longestString ( str1 , str2 ) ; } }
using System ; public class CountKSubStr { int countkDist ( string str , int k ) { int res = 0 ; int n = str . Length ; int [ ] cnt = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; Array . Clear ( cnt , 0 , cnt . Length ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - ' a ' ] == 0 ) dist_count ++ ; cnt [ str [ j ] - ' a ' ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; } public static void Main ( ) { CountKSubStr ob = new CountKSubStr ( ) ; string ch = " abcbaa " ; int k = 3 ; Console . Write ( " Total ▁ substrings ▁ with ▁ exactly ▁ " + k + " ▁ distinct ▁ characters ▁ : ▁ " + ob . countkDist ( ch , k ) ) ; } }
using System ; class GFG { static long removeRecur ( long n ) { long prev_digit = n % 10 ; long pow = 10 ; long res = prev_digit ; while ( n > 0 ) { long curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; } public static void Main ( ) { long n = 12224 ; Console . WriteLine ( removeRecur ( n ) ) ; } }
using System ; class GFG { static void printTheArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } Console . WriteLine ( ) ; } static void generateAllBinaryStrings ( int n , int [ ] arr , int i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; } public static void Main ( String [ ] args ) { int n = 4 ; int [ ] arr = new int [ n ] ; generateAllBinaryStrings ( n , arr , 0 ) ; } }
using System ; class GFG { static int firstDigit ( int n ) { while ( n >= 10 ) { n /= 10 ; } return n ; } static int getCount ( int n ) { int count = 1 ; while ( n != 0 ) { int leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; } static int getLargestNumber ( int k ) { int left = k ; int right = k * 10 ; int mid = ( left + right ) / 2 ; int len = getCount ( mid ) ; while ( len != k ) { mid = ( left + right ) / 2 ; len = getCount ( mid ) ; if ( len > k ) { right = mid ; } else { left = mid ; } } while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; } public static void Main ( String [ ] args ) { int k = 3 ; Console . WriteLine ( getLargestNumber ( k ) ) ; } }
using System ; class GFG { static void diameter ( double r ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " + " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " + 2 * r ) ; } public static void Main ( String [ ] args ) { double r = 4 ; diameter ( r ) ; } }
class GFG { static double getSlope ( double m ) { return m ; } static void Main ( ) { double m = 2 ; System . Console . Write ( getSlope ( m ) ) ; } }
using System ; class GFG { public static int totalTriangles ( int h , int v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; int total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; } public static void Main ( ) { int h = 2 , v = 2 ; Console . Write ( totalTriangles ( h , v ) ) ; } }
using System ; class gfg { static float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; float x = r ; float V = ( float ) ( 4 * 3.14f * Math . Pow ( r , 3 ) ) / 3 ; return V ; } public static void Main ( ) { float r = 5 , R = 8 , h = 11 ; Console . WriteLine ( sph ( r , R , h ) ) ; } }
using System ; class GFG { static bool checkOrtho ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int m1 , m2 ; if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ; else if ( x2 - x1 == 0 ) { m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m2 == 0 ) return true ; else return false ; } else if ( x4 - x3 == 0 ) { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; if ( m1 == 0 ) return true ; else return false ; } else { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m1 * m2 == - 1 ) return true ; else return false ; } } public static void Main ( ) { int x1 = 0 , y1 = 4 , x2 = 0 , y2 = - 9 ; int x3 = 2 , y3 = 0 , x4 = - 1 , y4 = 0 ; if ( checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class GFG { static double pentdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.22 * a ; return d ; } static public void Main ( ) { double a = 6 ; Console . WriteLine ( pentdiagonal ( a ) ) ; } }
using System ; public class GFG { public static float hexagonArea ( float d ) { return ( float ) ( ( 3 * Math . Sqrt ( 3 ) * d * d ) / 8 ) ; } static public void Main ( ) { float d = 10 ; Console . WriteLine ( " Area ▁ of ▁ hexagon : ▁ " + hexagonArea ( d ) ) ; } }
using System ; class GFG { static int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; } static void Main ( ) { int n = 6 , m = 6 , a = 4 ; Console . WriteLine ( Squares ( n , m , a ) ) ; } }
using System ; class GFG { static double octadiagonal ( double a ) { if ( a < 0 ) return - 1 ; return a * Math . Sqrt ( 4 + ( 2 * Math . Sqrt ( 2 ) ) ) ; } public static void Main ( ) { double a = 4 ; Console . WriteLine ( octadiagonal ( a ) ) ; } }
using System ; class GFG { static void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; Console . WriteLine ( " The ▁ Perimeter ▁ of ▁ " + " Decagon ▁ is ▁ : ▁ " + Perimeter ) ; } public static void Main ( ) { CalPeri ( ) ; } }
using System ; public class GFG { static double findEdges ( double s1 , double s2 , double s3 ) { double a = Math . Sqrt ( s1 * s2 / s3 ) ; double b = Math . Sqrt ( s3 * s1 / s2 ) ; double c = Math . Sqrt ( s3 * s2 / s1 ) ; double sum = a + b + c ; return 4 * sum ; } static public void Main ( ) { double s1 , s2 , s3 ; s1 = 65 ; s2 = 156 ; s3 = 60 ; Console . WriteLine ( findEdges ( s1 , s2 , s3 ) ) ; } }
using System ; class GFG { public static int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; } static public void Main ( ) { int n = 3 ; Console . Write ( " Max ▁ number ▁ of ▁ pieces ▁ for ▁ n ▁ = ▁ " + n + " ▁ is ▁ " + findMaximumPieces ( 3 ) ) ; } }
using System ; class GFG { static void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) Console . WriteLine ( " Coplanar " ) ; else Console . WriteLine ( " Not ▁ Coplanar " ) ; } static public void Main ( ) { int x1 = 3 ; int y1 = 2 ; int z1 = - 5 ; int x2 = - 1 ; int y2 = 4 ; int z2 = - 3 ; int x3 = - 3 ; int y3 = 8 ; int z3 = - 5 ; int x4 = - 3 ; int y4 = 2 ; int z4 = 1 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; } }
using System ; class GFG { static void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = ( float ) Math . Sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = ( float ) Math . Sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = ( float ) 3.14159 ; float A = ( 180 / pi ) * ( float ) ( Math . Acos ( d ) ) ; Console . Write ( " Angle ▁ is ▁ " + A + " ▁ degree " ) ; } public static void Main ( ) { float a1 = 1 ; float b1 = 1 ; float c1 = 2 ; float a2 = 2 ; float b2 = - 1 ; float c2 = 1 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ; } }
using System ; class GFG { static void mirror_point ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; Console . Write ( " x3 ▁ = ▁ " + x3 + " ▁ " ) ; Console . Write ( " y3 ▁ = ▁ " + y3 + " ▁ " ) ; Console . Write ( " z3 ▁ = ▁ " + z3 + " ▁ " ) ; } static public void Main ( ) { int a = 1 ; int b = - 2 ; int c = 0 ; int d = 0 ; int x1 = - 1 ; int y1 = 3 ; int z1 = 4 ; mirror_point ( a , b , c , d , x1 , y1 , z1 ) ; } }
using System ; class GFG { static int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; } public static void Main ( ) { int radius = 2 ; int totalRectangles ; totalRectangles = countRectangles ( radius ) ; Console . WriteLine ( totalRectangles + " ▁ rectangles ▁ can ▁ be ▁ " + " cut ▁ from ▁ a ▁ circle ▁ of " + " ▁ Radius ▁ " + radius ) ; } }
using System ; class GFG1 { static int simi_aaa ( int [ ] a1 , int [ ] a2 ) { Array . Sort ( a1 ) ; Array . Sort ( a2 ) ; if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; } static int simi_sas ( int [ ] s1 , int [ ] s2 , int [ ] a1 , int [ ] a2 ) { Array . Sort ( a1 ) ; Array . Sort ( a2 ) ; Array . Sort ( s1 ) ; Array . Sort ( s2 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) { if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; } static int simi_sss ( int [ ] s1 , int [ ] s2 ) { Array . Sort ( s1 ) ; Array . Sort ( s2 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; } public static void Main ( ) { int [ ] s1 = { 2 , 3 , 3 } ; int [ ] s2 = { 4 , 6 , 6 } ; int [ ] a1 = { 80 , 60 , 40 } ; int [ ] a2 = { 40 , 60 , 80 } ; int aaa = simi_aaa ( a1 , a2 ) ; int sss = simi_sss ( s1 , s2 ) ; int sas = simi_sas ( s1 , s2 , a1 , a2 ) ; if ( aaa == 1 sss == 1 sas == 1 ) { Console . Write ( " Triangles ▁ are ▁ " + " similar ▁ by ▁ " ) ; if ( aaa == 1 ) Console . Write ( " AAA ▁ " ) ; if ( sss == 1 ) Console . Write ( " SSS ▁ " ) ; if ( sas == 1 ) Console . Write ( " SAS . " ) ; } else Console . WriteLine ( " Triangles ▁ are ▁ " + " not ▁ similar " ) ; } }
using System ; class GFG { static long center_pentadecagonal_num ( long n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; } static public void Main ( ) { long n = 3 ; Console . Write ( n + " th ▁ number ▁ : ▁ " ) ; Console . WriteLine ( center_pentadecagonal_num ( n ) ) ; n = 10 ; Console . Write ( n + " th ▁ number ▁ : ▁ " ) ; Console . WriteLine ( center_pentadecagonal_num ( n ) ) ; } }
using System ; class GFG { static int center_nonadecagon_num ( int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; } static public void Main ( ) { int n = 2 ; Console . Write ( n + " th ▁ centered ▁ " + " nonadecagonal ▁ number ▁ : ▁ " ) ; Console . WriteLine ( center_nonadecagon_num ( n ) ) ; n = 7 ; Console . Write ( n + " th ▁ centered ▁ " + " nonadecagonal ▁ number ▁ : ▁ " ) ; Console . WriteLine ( center_nonadecagon_num ( n ) ) ; } }
using System ; class GFG { static int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; } static public void Main ( ) { int n = 3 ; Console . Write ( n + " rd ▁ Hendecagonal ▁ number : ▁ " ) ; Console . WriteLine ( hendecagonal_num ( n ) ) ; n = 10 ; Console . Write ( n + " th ▁ Hendecagonal ▁ number : ▁ " ) ; Console . WriteLine ( hendecagonal_num ( n ) ) ; } }
using System ; public class GFG { static long cen_octagonalnum ( long n ) { return ( 4 * n * n - 4 * n + 1 ) ; } static public void Main ( ) { long n = 6 ; Console . WriteLine ( n + " th ▁ centered " + " ▁ octagonal ▁ number ▁ : ▁ " + cen_octagonalnum ( n ) ) ; n = 11 ; Console . WriteLine ( n + " th ▁ centered " + " ▁ octagonal ▁ number ▁ : ▁ " + cen_octagonalnum ( n ) ) ; } }
using System ; class GFG { static bool isValid ( int [ ] arr , int i , int j , int m , int c ) { if ( i == j ) return false ; int lhs = arr [ j ] ; int rhs = m * arr [ i ] + c ; return ( lhs == rhs ) ; } static int findOrderedPoints ( int [ ] arr , int n , int m , int c ) { int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int firstIndex = i , secondIndex = j ; if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 2 } ; int n = arr . Length ; int m = 1 , c = 1 ; Console . Write ( findOrderedPoints ( arr , n , m , c ) ) ; } }
using System ; class ring { public static bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . Sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; } public static void Main ( ) { int r = 8 , R = 4 , r1 = 2 , x1 = 6 , y1 = 0 ; if ( checkcircle ( r , R , r1 , x1 , y1 ) ) Console . WriteLine ( " yes " ) ; else Console . WriteLine ( " no " ) ; } }
using System ; class GFG { static double surface_area_octahedron ( double side ) { return ( 2 * ( Math . Sqrt ( 3 ) ) * ( side * side ) ) ; } public static void Main ( ) { double side = 7 ; Console . WriteLine ( " Surface ▁ area ▁ of ▁ octahedron ▁ = " + surface_area_octahedron ( side ) ) ; } }
using System ; public class GfG { public static int nCk ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } public static int count_Straightlines ( int n , int m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; } public static void Main ( String [ ] args ) { int n = 4 , m = 3 ; Console . WriteLine ( count_Straightlines ( n , m ) ) ; } }
using System ; public class GFG { static float vol_of_dodecahedron ( int side ) { return ( float ) ( ( ( 15 + ( 7 * ( Math . Sqrt ( 5 ) ) ) ) / 4 ) * ( Math . Pow ( side , 3 ) ) ) ; } static public void Main ( ) { int side = 4 ; Console . WriteLine ( " Volume ▁ of ▁ dodecahedron ▁ = ▁ " + vol_of_dodecahedron ( side ) ) ; } }
using System ; class GFG { static void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { Console . WriteLine ( " Overflow " ) ; } else { Console . WriteLine ( " Not ▁ in ▁ overflow ▁ state " ) ; } } public static void Main ( ) { int H = 10 , r = 5 , h = 5 , N = 2 , R = 2 ; overflow ( H , r , h , N , R ) ; } }
using System ; class Number { public static float volume ( int radius , int height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; } public static void check_and_print ( double required_time , double given_time ) { if ( required_time < given_time ) Console . WriteLine ( " Overflow " ) ; else if ( required_time > given_time ) Console . WriteLine ( " Underflow " ) ; else Console . WriteLine ( " Filled " ) ; } public static void Main ( ) { int radius = 5 , height = 10 , rate_of_flow = 10 ; double given_time = 70.0 ; double required_time = volume ( radius , height ) / rate_of_flow ; check_and_print ( required_time , given_time ) ; } }
using System ; class GFG { static float cal_cos ( float n ) { float accuracy = 0.0001f , x1 ; float denominator , cosx , cosval ; n = n * ( 3.142f / 180.0f ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . Cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . Abs ( cosval - cosx ) ) ; return cosx ; } static float third_side ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return ( float ) Math . Sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; } public static void Main ( ) { float c = 49 ; int a = 5 , b = 8 ; Console . WriteLine ( Math . Round ( third_side ( a , b , c ) * 100000.0 ) / 100000.0 ) ; } }
using System ; class GFG { static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . Sqrt ( Math . Pow ( x , 2 ) + Math . Pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) Console . WriteLine ( " Fits " ) ; else Console . WriteLine ( " Doesn ' t ▁ Fit " ) ; } public static void Main ( ) { int R = 8 , r = 4 ; int x = 5 , y = 3 , rad = 3 ; fitOrNotFit ( R , r , x , y , rad ) ; } }
using System ; class GFG { static bool checkPolygonWithMidpoints ( int [ ] arr , int N , int midpoints ) { for ( int j = 0 ; j < midpoints ; j ++ ) { int val = 1 ; for ( int k = j ; k < N ; k += midpoints ) { val &= arr [ k ] ; } if ( val != 0 && N / midpoints > 2 ) { Console . WriteLine ( " Polygon ▁ possible ▁ with ▁ " + " side ▁ length ▁ " + N / midpoints ) ; return true ; } } return false ; } static void isPolygonPossible ( int [ ] arr , int N ) { int limit = ( int ) Math . Sqrt ( N ) ; for ( int i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , ( N / i ) ) ) return ; } } Console . WriteLine ( " Not ▁ possible " ) ; } static public void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; isPolygonPossible ( arr , arr . Length ) ; } }
using System ; class GFG { static float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001f ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } static int findMaximumHeight ( int N ) { int n = 1 + 8 * N ; int maxH = ( int ) ( - 1 + squareRoot ( n ) ) / 2 ; return maxH ; } public static void Main ( ) { int N = 12 ; Console . Write ( findMaximumHeight ( N ) ) ; } }
using System ; class GFG { static void calculateSpan ( int [ ] price , int n , int [ ] S ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } static void printArray ( int [ ] arr ) { string result = string . Join ( " ▁ " , arr ) ; Console . WriteLine ( result ) ; } public static void Main ( ) { int [ ] price = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = price . Length ; int [ ] S = new int [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S ) ; } }
using System ; class GFG { static void printNGE ( int [ ] arr , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } Console . WriteLine ( arr [ i ] + " ▁ - - ▁ " + next ) ; } } public static void Main ( ) { int [ ] arr = { 11 , 13 , 21 , 3 } ; int n = arr . Length ; printNGE ( arr , n ) ; } }
using System ; class GFG { static void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod ) { if ( n == 1 ) { Console . WriteLine ( " Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; Console . WriteLine ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; } public static void Main ( String [ ] args ) { int n = 4 ; towerOfHanoi ( n , ' A ' , ' C ' , ' B ' ) ; } }
using System ; class GFG { static int [ ] arr = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; static void printMaxOfMin ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = int . MinValue ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } Console . Write ( maxOfMin + " ▁ " ) ; } } public static void Main ( ) { printMaxOfMin ( arr . Length ) ; } }
using System ; using System . Collections . Generic ; class GFG { public static Stack < int > st = new Stack < int > ( ) ; public static void push_digits ( int number ) { while ( number != 0 ) { st . Push ( number % 10 ) ; number = number / 10 ; } } public static int reverse_number ( int number ) { push_digits ( number ) ; int reverse = 0 ; int i = 1 ; while ( st . Count > 0 ) { reverse = reverse + ( st . Peek ( ) * i ) ; st . Pop ( ) ; i = i * 10 ; } return reverse ; } public static void Main ( string [ ] args ) { int number = 39997 ; Console . WriteLine ( reverse_number ( number ) ) ; } }
using System ; public class HeapSort { void heapify ( int [ ] arr , int n , int i ) { int largest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { int swap = arr [ i ] ; arr [ i ] = arr [ largest ] ; arr [ largest ] = swap ; heapify ( arr , n , largest ) ; } } public void sort ( int [ ] arr ) { int n = arr . Length ; for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { int temp = arr [ 0 ] ; arr [ 0 ] = arr [ i ] ; arr [ i ] = temp ; heapify ( arr , i , 0 ) ; } } static void printArray ( int [ ] arr ) { int n = arr . Length ; for ( int i = 0 ; i < n ; ++ i ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . Read ( ) ; } public static void Main ( ) { int [ ] arr = { 12 , 11 , 13 , 5 , 6 , 7 } ; int n = arr . Length ; HeapSort ob = new HeapSort ( ) ; ob . sort ( arr ) ; Console . WriteLine ( " Sorted ▁ array ▁ is " ) ; printArray ( arr ) ; } }
using System ; class GFG { static bool isHeap ( int [ ] arr , int i , int n ) { if ( i >= ( n - 2 ) / 2 ) { return true ; } if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) { return true ; } return false ; } public static void Main ( String [ ] args ) { int [ ] arr = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . Length - 1 ; if ( isHeap ( arr , 0 , n ) ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } } }
using System ; class GFG { static bool isHeap ( int [ ] arr , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; } public static void Main ( ) { int [ ] arr = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . Length ; if ( isHeap ( arr , n ) ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } } }
using System ; class GFG { static void generate_derangement ( int N ) { int [ ] S = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int [ ] D = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( D [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } public static void Main ( ) { generate_derangement ( 10 ) ; } }
using System ; class GFG { static int Profit ( int costPrice , int sellingPrice ) { int profit = ( sellingPrice - costPrice ) ; return profit ; } static int Loss ( int costPrice , int sellingPrice ) { int Loss = ( costPrice - sellingPrice ) ; return Loss ; } public static void Main ( ) { int costPrice = 1500 , sellingPrice = 2000 ; if ( sellingPrice == costPrice ) Console . Write ( " No ▁ profit ▁ nor ▁ Loss " ) ; else if ( sellingPrice > costPrice ) Console . Write ( Profit ( costPrice , sellingPrice ) + " ▁ Profit ▁ " ) ; else Console . Write ( Loss ( costPrice , sellingPrice ) + " ▁ Loss ▁ " ) ; } }
using System ; class GFG { static int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . Floor ( Math . Sqrt ( N ) ) + 1 ; return nextN * nextN ; } public static void Main ( ) { int n = 35 ; Console . WriteLine ( nextPerfectSquare ( n ) ) ; } }
using System ; class GFG { static void printSubstrings ( int n ) { int s = ( int ) Math . Log10 ( n ) ; int d = ( int ) ( Math . Pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { Console . WriteLine ( n / d ) ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } } public static void Main ( ) { int n = 123 ; printSubstrings ( n ) ; } }
using System ; class GFG { static long MOD = ( long ) ( 1e9 + 7 ) ; static long powerLL ( long x , long n ) { long result = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { result = result * x % MOD ; } n = n / 2 ; x = x * x % MOD ; } return result ; } static long powerStrings ( String sa , String sb ) { long a = 0 , b = 0 ; for ( int i = 0 ; i < sa . Length ; i ++ ) { a = ( a * 10 + ( sa [ i ] - '0' ) ) % MOD ; } for ( int i = 0 ; i < sb . Length ; i ++ ) { b = ( b * 10 + ( sb [ i ] - '0' ) ) % ( MOD - 1 ) ; } return powerLL ( a , b ) ; } public static void Main ( String [ ] args ) { String sa = "2" , sb = "3" ; Console . WriteLine ( powerStrings ( sa , sb ) ) ; } }
using System ; class GFG { static bool isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static int previousPowerOfTwo ( int n ) { while ( ( n & n - 1 ) > 1 ) { n = n & n - 1 ; } return n ; } static bool checkSum ( int n ) { if ( n == 0 n == 1 ) { Console . WriteLine ( " No " ) ; return false ; } else if ( isPowerOfTwo ( n ) ) { Console . WriteLine ( n / 2 + " ▁ " + n / 2 ) ; return true ; } else { int x = previousPowerOfTwo ( n ) ; int y = n - x ; if ( isPowerOfTwo ( y ) ) { Console . WriteLine ( x + " ▁ " + y ) ; return true ; } else { return false ; } } } public static void Main ( ) { int n1 = 20 ; if ( checkSum ( n1 ) == false ) Console . WriteLine ( " No " ) ; Console . WriteLine ( ) ; int n2 = 11 ; if ( checkSum ( n2 ) == false ) Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int complement ( int num ) { int len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = num / 10 ; if ( Math . Abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . Pow ( 10 , len ) - num ; return comp ; } public static void Main ( ) { Console . WriteLine ( complement ( 25 ) ) ; Console . WriteLine ( complement ( 456 ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } public static void Main ( ) { int a = 98 , b = 56 ; Console . WriteLine ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
using System ; public class GFG { static long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( " Sum ▁ of ▁ all ▁ elements : " + calculateSum ( n ) ) ; } }
using System ; public class GFG { static int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return ( int ) ( Math . Pow ( 2 , N / 2 + 1 ) + Math . Pow ( 2 , N / 2 ) - 2 ) ; } else { return ( int ) ( Math . Pow ( 2 , ( N + 1 ) / 2 ) + Math . Pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } } public static void Main ( ) { int N = 2 ; Console . WriteLine ( findAllSequence ( N ) ) ; } }
using System ; class GFG { static int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; } static public void Main ( ) { int n = 13 ; Console . WriteLine ( countOnes ( n ) ) ; } }
using System ; class GFG { static int largestNum ( int a , int b ) { return a * ( ( a / b ) > 0 ? 1 : 0 ) + b * ( ( b / a ) > 0 ? 1 : 0 ) ; } public static void Main ( String [ ] args ) { int a = 22 , b = 1231 ; Console . Write ( largestNum ( a , b ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { int c = a % b ; while ( c != 0 ) { a = b ; b = c ; c = a % b ; } return b ; } static int numberOfmeet ( int a , int b ) { int ans ; if ( a > b ) ans = a - b ; else ans = b - a ; if ( a < 0 ) a = a * ( - 1 ) ; if ( b < 0 ) b = b * ( - 1 ) ; return ans / gcd ( a , b ) ; } static public void Main ( ) { int a = 1 , b = - 1 ; Console . WriteLine ( numberOfmeet ( a , b ) ) ; } }
using System ; class GFG { static void printGreater ( int x , int y ) { double X = y * Math . Log ( x ) ; double Y = x * Math . Log ( y ) ; if ( Math . Abs ( X - Y ) < 1e-9 ) { Console . WriteLine ( " Equal " ) ; } else if ( X > Y ) { Console . WriteLine ( x + " ^ " + y ) ; } else { Console . WriteLine ( y + " ^ " + x ) ; } } public static void Main ( ) { int x = 5 , y = 8 ; printGreater ( x , y ) ; } }
using System ; class Series { static int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( sumOfSeries ( n ) ) ; } }
using System ; public class GFG { static double mulmod ( long a , long b , long mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } static long findProduct ( long N ) { long product = 1 , fact = 1 ; long MOD = ( long ) ( 1e9 + 7 ) ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( long ) mulmod ( fact , i , MOD ) ; product = ( long ) mulmod ( product , fact , MOD ) ; if ( product == 0 ) return 0 ; } return product ; } static public void Main ( ) { long N = 3 ; Console . WriteLine ( findProduct ( N ) ) ; N = 5 ; Console . WriteLine ( findProduct ( N ) ) ; } }
using System ; class GFG { static int divSum ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + n / i ; return sum ; } static bool areEquivalent ( int num1 , int num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; } static public void Main ( ) { int num1 = 559 ; int num2 = 703 ; if ( areEquivalent ( num1 , num2 ) ) Console . WriteLine ( " Equivalent " ) ; else Console . WriteLine ( " Not ▁ Equivalent " ) ; } }
using System ; class GFG { static int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; } public static void Main ( ) { int n = 5 ; Console . Write ( n + " the ▁ Dodecahedral " + " ▁ number : " ) ; Console . WriteLine ( dodecahedral_num ( n ) ) ; } }
using System ; class GFG { static int bit ( int x ) { int ans = 0 ; while ( x > 0 ) { x /= 2 ; ans ++ ; } return ans ; } static bool check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; } static int bs ( int n ) { int l = 1 , r = ( int ) Math . Sqrt ( n ) ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; } static int countDivisor ( int n ) { return n - bs ( n ) + 1 ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( countDivisor ( n ) ) ; } }
using System ; class GFG { static void swap ( ref int a , ref int b ) { int t = a ; a = b ; b = t ; } static bool everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( ref x1 , ref x2 ) ; swap ( ref v1 , ref v2 ) ; } while ( x1 >= x2 ) { if ( x1 == x2 ) return true ; x1 = x1 + v1 ; x2 = x2 + v2 ; } return false ; } static void Main ( ) { int x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static String check ( int k , int d0 , int d1 ) { int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x = 0 ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } int sum = d0 + d1 + ( ( ( k - 3 ) / 4 ) * s + x ) ; if ( sum % 3 == 0 ) return " YES " ; return " NO " ; } static public void Main ( ) { int k , d0 , d1 ; k = 13 ; d0 = 8 ; d1 = 1 ; Console . WriteLine ( check ( k , d0 , d1 ) ) ; k = 5 ; d0 = 3 ; d1 = 4 ; Console . WriteLine ( check ( k , d0 , d1 ) ) ; } }
using System ; class GFG { static void Main ( ) { int a = 4 ; int b = 3 , val = 0 ; if ( ( a % b ) != 0 ) val = ( a / b ) + ( a % b ) ; else val = ( a / b ) ; Console . WriteLine ( " The ▁ ceiling ▁ " + " value ▁ of ▁ 4/3 ▁ is ▁ " + val ) ; a = 6 ; b = 3 ; if ( ( a % b ) != 0 ) val = ( a / b ) + ( a % b ) ; else val = ( a / b ) ; Console . WriteLine ( " The ▁ ceiling ▁ " + " value ▁ of ▁ 6/3 ▁ is ▁ " + val ) ; } }
using System ; class GFG { static void printCollatz ( int n ) { while ( n != 1 ) { Console . Write ( n + " ▁ " ) ; if ( ( n & 1 ) == 1 ) n = 3 * n + 1 ; else n = n / 2 ; } Console . Write ( n ) ; } static void Main ( ) { printCollatz ( 6 ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void block ( long x ) { List < int > v = new List < int > ( ) ; Console . Write ( " Blocks ▁ for ▁ " + x + " ▁ : ▁ " ) ; while ( x > 0 ) { v . Add ( ( int ) x % 2 ) ; x = x / 2 ; } for ( int i = 0 ; i < v . Count ; i ++ ) { if ( v [ i ] == 1 ) { Console . Write ( i ) ; if ( i != v . Count - 1 ) Console . Write ( " , ▁ " ) ; } } Console . WriteLine ( ) ; } public static void Main ( ) { block ( 71307 ) ; block ( 1213 ) ; block ( 29 ) ; block ( 100 ) ; } }
using System ; class GFG { static void findNumberOfDigits ( long n , int b ) { int dig = ( int ) ( Math . Floor ( Math . Log ( n ) / Math . Log ( b ) ) + 1 ) ; Console . Write ( " The ▁ Number ▁ of ▁ digits " + " ▁ of ▁ Number ▁ " + n + " ▁ in ▁ base ▁ " + b + " ▁ is ▁ " + dig ) ; } public static void Main ( ) { long n = 1446 ; int b = 7 ; findNumberOfDigits ( n , b ) ; } }
using System ; class GFG { static bool isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; } static public void Main ( ) { double a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) == true ) { Console . Write ( " Nesbitt ' s ▁ inequality " + " ▁ satisfied ▁ " ) ; Console . WriteLine ( " for ▁ real ▁ numbers ▁ " + a + " , ▁ " + b + " , ▁ " + c ) ; } else Console . WriteLine ( " Nesbitts ▁ inequality " + " ▁ not ▁ satisfied " ) ; } }
using System ; class GFG { public static void printCubeFree ( int n ) { bool [ ] cubFree = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( int i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( int multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) Console . Write ( i + " ▁ " ) ; } } public static void Main ( ) { printCubeFree ( 20 ) ; } }
using System ; class GFG { static int isTriangular ( int num ) { if ( num < 0 ) return 0 ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return - 1 ; double root1 = ( - b + Math . Sqrt ( d ) ) / ( 2 * a ) ; double root2 = ( - b - Math . Sqrt ( d ) ) / ( 2 * a ) ; if ( ( int ) ( root1 ) > 0 && ( int ) ( Math . Floor ( root1 ) ) == ( int ) ( root1 ) ) return ( int ) ( root1 ) ; if ( ( int ) ( root2 ) > 0 && ( int ) ( Math . Floor ( root2 ) ) == ( int ) ( root2 ) ) return ( int ) ( root2 ) ; return - 1 ; } static int isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; if ( ( sr - Math . Floor ( sr ) ) == 0 ) return ( int ) ( Math . Floor ( sr ) ) ; else return - 1 ; } static int findS ( int s ) { int sr = isPerfectSquare ( s ) ; if ( sr == - 1 ) return - 1 ; return isTriangular ( sr ) ; } public static void Main ( ) { int s = 9 ; int n = findS ( s ) ; if ( n == - 1 ) Console . Write ( " - 1" ) ; else Console . Write ( n ) ; } }
using System ; class GFG { static int trickyCase ( string s , int index ) { int index1 = - 1 ; for ( int i = index - 1 ; i >= 0 ; i -- ) { int digit = s [ i ] - '0' ; if ( digit != 8 ) { index1 = i ; break ; } } if ( index1 == - 1 ) return 2 * ( int ) Math . Pow ( 10 , s . Length ) ; int num = 0 ; for ( int i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; if ( s [ index1 ] % 2 == 0 ) num = num * 10 + ( s [ index1 ] - '0' + 2 ) ; else num = num * 10 + ( s [ index1 ] - '0' + 1 ) ; for ( int i = index1 + 1 ; i < s . Length ; i ++ ) num = num * 10 ; return num ; } static int smallestNumber ( int n ) { int num = 0 ; string s = " " ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { int digit = s [ i ] - '0' ; int val = digit & 1 ; if ( val == 1 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; if ( s [ index ] == '9' ) { num = trickyCase ( s , index ) ; return num ; } for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' + 1 ) ; for ( int i = index + 1 ; i < s . Length ; i ++ ) num = num * 10 ; return num ; } public static void Main ( ) { int N = 2397 ; Console . Write ( smallestNumber ( N ) ) ; } } ? >
using System ; class GFG { public static int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } } static public void Main ( ) { Console . WriteLine ( findNth ( 5 ) ) ; } }
class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; } public static void Main ( ) { int n = 5 ; System . Console . WriteLine ( findSum ( n ) ) ; } }
using System ; class GFG { static int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; class GFG { static int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = ( int ) Math . Pow ( 10 , digit - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; } public static void Main ( ) { int n = 3 , number = 7 ; Console . WriteLine ( totalSumDivisibleByNum ( n , number ) ) ; } }
using System ; class GFG { public static int Nth_of_AP ( int a , int d , int N ) { return ( a + ( N - 1 ) * d ) ; } public static void Main ( ) { int a = 2 ; int d = 1 ; int N = 5 ; Console . WriteLine ( " The ▁ " + N + " th ▁ term ▁ of ▁ the ▁ series ▁ is ▁ : ▁ " + Nth_of_AP ( a , d , N ) ) ; } }
using System ; class GFG { static bool checkFibinnary ( int n ) { int prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; } public static void Main ( ) { int n = 10 ; if ( checkFibinnary ( n ) == true ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . Pow ( 10 , n ) - 1 ) - 0.55 * n ) ; } public static void Main ( ) { int n = 2 ; Console . Write ( sumOfSeries ( n ) ) ; } }
using System ; class GFG { static int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; } public static void Main ( ) { int n = 10 ; Console . Write ( Nonagonal ( n ) ) ; } }
using System ; using System . Text ; class GFG { static bool divisibleBy20 ( String num ) { int lastTwoDigits = Int32 . Parse ( num . Substring ( 2 ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; } static public void Main ( ) { String num = "63284689320" ; if ( divisibleBy20 ( num ) == true ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static bool isDvisibleBy12 ( string num ) { if ( num . Length >= 3 ) { int d1 = ( int ) num [ num . Length - 1 ] ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num [ num . Length - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = int . Parse ( num ) ; return ( number % 12 == 0 ) ; } } public static void Main ( ) { String num = "12244824607284961224" ; if ( isDvisibleBy12 ( num ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GfG { static bool check ( int n ) { int d = ( int ) Math . Sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } static int largestNonPerfectSquareNumber ( int [ ] a , int n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! check ( a [ i ] ) ) maxi = Math . Max ( a [ i ] , maxi ) ; } return maxi ; } public static void Main ( ) { int [ ] a = { 16 , 20 , 25 , 2 , 3 , 10 } ; int n = a . Length ; Console . WriteLine ( largestNonPerfectSquareNumber ( a , n ) ) ; } }
using System ; class GFG { static void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( curr_term + " ▁ " ) ; curr_term += d ; } } public static void Main ( ) { int a = 2 ; int d = 1 ; int n = 5 ; printAP ( a , d , n ) ; } }
using System ; class GFG { static void printNonSquare ( int n ) { int curr_count = 2 , num = 2 , count = 0 ; while ( count < n ) { for ( int i = 0 ; i < curr_count && count < n ; i ++ ) { Console . Write ( num + " ▁ " ) ; count ++ ; num ++ ; } num ++ ; curr_count += 2 ; } } static public void Main ( ) { int n = 10 ; printNonSquare ( n ) ; } }
using System ; public class GfG { public static int countZeroso ( int [ ] a , int n ) { int count2 = 0 , count5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] = a [ i ] / 2 ; count2 ++ ; } while ( a [ i ] % 5 == 0 ) { a [ i ] = a [ i ] / 5 ; count5 ++ ; } } return ( count2 < count5 ) ? count2 : count5 ; } public static void Main ( ) { int [ ] a = new int [ ] { 10 , 100 , 20 , 30 , 50 , 91 , 12 , 80 } ; int n = 8 ; Console . WriteLine ( countZeroso ( a , n ) ) ; } }
using System ; class GFG { static int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; } public static void Main ( ) { Console . Write ( squareSum ( 8 ) ) ; } }
using System ; class GFG { static long [ ] pwr ; static bool isMunchhausen ( int n ) { long sum = 0 ; int temp = n ; while ( temp > 0 ) { int index = temp % 10 ; sum = sum + pwr [ index ] ; temp /= 10 ; } return ( sum == n ) ; } static void printMunchhausenNumbers ( int n ) { pwr = new long [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) pwr [ i ] = ( long ) Math . Pow ( ( float ) i , ( float ) i ) ; for ( int i = 1 ; i <= n ; i ++ ) if ( isMunchhausen ( i ) == true ) Console . WriteLine ( i ) ; } public static void Main ( ) { int n = 10000 ; printMunchhausenNumbers ( n ) ; } }
using System ; public class GfG { public static int kthdigit ( int a , int b , int k ) { int p = ( int ) Math . Pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; } public static void Main ( ) { int a = 5 , b = 2 ; int k = 1 ; Console . WriteLine ( kthdigit ( a , b , k ) ) ; } }
using System ; class GFG { static long digSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } static long PowDigSum ( long n , long x ) { long sum = digSum ( n ) ; long rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( ( long ) Math . Pow ( sum , 6 ) ) ; else return digSum ( ( long ) Math . Pow ( sum , rem ) ) ; } public static void Main ( ) { int n = 33333 ; int x = 332654 ; Console . WriteLine ( PowDigSum ( n , x ) ) ; } }
using System ; class Area { public static int maxArea ( int [ ] A , int len ) { int l = 0 ; int r = len - 1 ; int area = 0 ; while ( l < r ) { area = Math . Max ( area , Math . Min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; } public static void Main ( ) { int [ ] a = { 1 , 5 , 4 , 3 } ; int [ ] b = { 3 , 1 , 2 , 4 , 5 } ; int len1 = 4 ; Console . WriteLine ( maxArea ( a , len1 ) ) ; int len2 = 5 ; Console . WriteLine ( maxArea ( b , len2 ) ) ; } }
using System ; class GFG { static int mobius ( int n ) { int p = 0 ; if ( n % 2 == 0 ) { n = n / 2 ; p ++ ; if ( n % 2 == 0 ) return 0 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; p ++ ; if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? - 1 : 1 ; } public static void Main ( ) { int N = 17 ; Console . WriteLine ( " Mobius ▁ Functions " + " ▁ M ( N ) ▁ at ▁ N ▁ = ▁ " + N + " ▁ is : ▁ " + mobius ( N ) ) ; Console . WriteLine ( " Mobius ▁ Functions " + " M ( N ) ▁ at ▁ N ▁ = ▁ " + 25 + " ▁ is : ▁ " + mobius ( 25 ) ) ; Console . WriteLine ( " Mobius ▁ Functions " + " M ( N ) ▁ at ▁ N ▁ = ▁ " + 6 + " ▁ is : ▁ " + mobius ( 6 ) ) ; } }
using System ; class GFG { static int factorial ( int start , int end ) { int res = 1 ; for ( int i = start ; i <= end ; i ++ ) res *= i ; return res ; } static int sumofsquare ( int n ) { return factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( sumofsquare ( n ) ) ; } }
using System ; class GFG { static double PHI = 1.6180339 ; static int [ ] f = { 0 , 1 , 1 , 2 , 3 , 5 } ; static int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . Round ( fn * PHI ) ; t ++ ; } return fn ; } public static void Main ( ) { int n = 9 ; Console . WriteLine ( n + " th ▁ Fibonacci " + " ▁ Number ▁ = ▁ " + fib ( n ) ) ; } }
using System ; class GFG { static float func ( float x , float y ) { return ( x + y + x * y ) ; } static void euler ( float x0 , float y , float h , float x ) { while ( x0 < x ) { y = y + h * func ( x0 , y ) ; x0 = x0 + h ; } Console . WriteLine ( " Approximate ▁ solution ▁ at ▁ x ▁ = ▁ " + x + " ▁ is ▁ " + y ) ; } public static void Main ( ) { float x0 = 0 ; float y0 = 1 ; float h = 0.025f ; float x = 0.1f ; euler ( x0 , y0 , h , x ) ; } }
using System ; class GfG { static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { Console . Write ( " x ▁ = ▁ " + i + " , ▁ y ▁ = ▁ " + ( n - ( i * a ) ) / b ) ; return ; } } Console . Write ( " No ▁ solution " ) ; } public static void Main ( ) { int a = 2 , b = 3 , n = 7 ; solution ( a , b , n ) ; } }
using System ; class GFG { static int binomialCoeffSum ( int n ) { return ( 1 << n ) ; } static public void Main ( ) { int n = 4 ; Console . WriteLine ( binomialCoeffSum ( n ) ) ; } }
using System ; class Eulerian { public static void precisionCompute ( int x , int y , int n ) { if ( y == 0 ) { Console . WriteLine ( " Infinite " ) ; return ; } if ( x == 0 ) { Console . WriteLine ( "0" ) ; return ; } if ( n <= 0 ) { Console . WriteLine ( x / y ) ; return ; } if ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) { Console . WriteLine ( " - " ) ; x = x > 0 ? x : - x ; y = y > 0 ? y : - y ; } int d = x / y ; for ( int i = 0 ; i <= n ; i ++ ) { Console . Write ( d ) ; x = x - ( y * d ) ; if ( x == 0 ) break ; x = x * 10 ; d = x / y ; if ( i == 0 ) Console . Write ( " . " ) ; } } public static void Main ( ) { int x = 22 , y = 7 , n = 15 ; precisionCompute ( x , y , n ) ; } }
using System ; class GFG { static void quadrant ( int x , int y ) { if ( x > 0 && y > 0 ) Console . WriteLine ( " lies ▁ in ▁ First ▁ quadrant " ) ; else if ( x < 0 && y > 0 ) Console . WriteLine ( " lies ▁ in ▁ Second ▁ quadrant " ) ; else if ( x < 0 && y < 0 ) Console . WriteLine ( " lies ▁ in ▁ Third ▁ quadrant " ) ; else if ( x > 0 && y < 0 ) Console . WriteLine ( " lies ▁ in ▁ Fourth ▁ quadrant " ) ; else if ( x == 0 && y > 0 ) Console . WriteLine ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) ; else if ( x == 0 && y < 0 ) Console . WriteLine ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) ; else if ( y == 0 && x < 0 ) Console . WriteLine ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) ; else if ( y == 0 && x > 0 ) Console . WriteLine ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) ; else Console . WriteLine ( " lies ▁ at ▁ origin " ) ; } public static void Main ( ) { int x = 1 , y = 1 ; quadrant ( x , y ) ; } }
using System ; class Prime { public static bool checkDigits ( int n ) { while ( n > 0 ) { int dig = n % 10 ; if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n /= 10 ; } return true ; } public static bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } public static bool isFullPrime ( int n ) { return ( checkDigits ( n ) && prime ( n ) ) ; } public static void Main ( ) { int n = 53 ; if ( isFullPrime ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int MAX = 500 ; static int nthSHN ( int n , int [ ] dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; } public static void Main ( ) { int n = 6 ; int [ ] dp = new int [ MAX ] ; for ( int i = 0 ; i < dp . Length ; i ++ ) dp [ i ] = - 1 ; Console . Write ( nthSHN ( n , dp ) ) ; } }
using System ; public class GfG { static int evenSum ( int n ) { int curr = 2 , sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; } public static void Main ( ) { int n = 20 ; Console . WriteLine ( " Sum ▁ of ▁ first ▁ " + n + " ▁ Even ▁ numbers ▁ is : ▁ " + evenSum ( n ) ) ; } }
using System ; public class GfG { static int evenSum ( int n ) { return ( n * ( n + 1 ) ) ; } public static void Main ( ) { int n = 20 ; Console . WriteLine ( " Sum ▁ of ▁ first ▁ " + n + " ▁ Even ▁ numbers ▁ is : ▁ " + evenSum ( n ) ) ; } }
using System ; class GFG { static double kmphTOmph ( double kmph ) { return 0.6214 * kmph ; } static double mphTOkmph ( double mph ) { return mph * 1.60934 ; } public static void Main ( ) { double kmph = 150 ; double mph = 100 ; Console . WriteLine ( " speed ▁ in ▁ miles / hr ▁ is ▁ " + kmphTOmph ( kmph ) ) ; Console . WriteLine ( " speed ▁ in ▁ km / hr ▁ is ▁ " + mphTOkmph ( mph ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findNumber ( int [ ] arr , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return - 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 2 , 4 } ; int n = arr . Length ; Console . WriteLine ( findNumber ( arr , n ) ) ; } }
using System ; using System . Collections ; class GFG { static ArrayList primes = new ArrayList ( ) ; static void SieveofEratosthenes ( int n ) { bool [ ] visited = new bool [ n * n + 2 ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( int j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . Add ( i ) ; } } static bool specialPrimeNumbers ( int n , int k ) { SieveofEratosthenes ( n ) ; int count = 0 ; for ( int i = 0 ; i < primes . Count ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( ( int ) primes [ j ] + ( int ) primes [ j + 1 ] + 1 == ( int ) primes [ i ] ) { count ++ ; break ; } } if ( count == k ) return true ; } return false ; } public static void Main ( ) { int n = 27 , k = 2 ; if ( specialPrimeNumbers ( n , k ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; public class GFG { static void factorize ( long n ) { int count = 0 ; while ( ! ( n % 2 > 0 ) ) { n >>= 1 ; count ++ ; } if ( count > 0 ) Console . WriteLine ( "2" + " ▁ " + count ) ; for ( long i = 3 ; i <= ( long ) Math . Sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count > 0 ) Console . WriteLine ( i + " ▁ " + count ) ; } if ( n > 2 ) Console . WriteLine ( n + " ▁ " + "1" ) ; } static public void Main ( ) { long n = 1000000000000000000 ; factorize ( n ) ; } }
using System ; class GFG { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } static int minimumMoves ( int [ ] A , int N ) { int one = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ; if ( one != 0 ) return N - one ; int minimum = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { int g = A [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = Math . Min ( minimum , j - i ) ; break ; } } } if ( minimum == int . MaxValue ) return - 1 ; else return N + minimum - 1 ; } public static void Main ( ) { int [ ] A = { 2 , 4 , 3 , 9 } ; int N = A . Length ; Console . WriteLine ( minimumMoves ( A , N ) ) ; } }
using System ; public class GfG { public static void series ( int n , int d ) { if ( d == 0 ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( "0" ) ; Console . WriteLine ( ) ; return ; } if ( n % 2 == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( Math . Pow ( - 1 , i ) * d + " ▁ " ) ; } Console . WriteLine ( ) ; } else { float m = n ; float r = ( m / ( m - 1 ) ) ; float g = ( float ) ( d * ( float ) ( Math . Sqrt ( r ) ) ) ; Console . Write ( "0 ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { Console . Write ( Math . Pow ( - 1 , i ) * g + " ▁ " ) ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 3 , d = 3 ; series ( n , d ) ; } }
using System ; class GFG { static int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { string str = i . ToString ( ) ; countr += str . Split ( "1" ) . Length - 1 ; } return countr ; } public static void Main ( ) { int n = 13 ; Console . WriteLine ( countDigitOne ( n ) ) ; n = 131 ; Console . WriteLine ( countDigitOne ( n ) ) ; n = 159 ; Console . WriteLine ( countDigitOne ( n ) ) ; } }
using System ; class GFG { static long N = 1000000007L ; static long exponentiation ( long bas , long exp ) { long t = 1L ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * bas ) % N ; bas = ( bas * bas ) % N ; exp /= 2 ; } return t % N ; } public static void Main ( ) { long bas = 5 ; long exp = 100000 ; long modulo = exponentiation ( bas , exp ) ; Console . WriteLine ( modulo ) ; } }
using System ; public class GFG { static int factorial ( int x ) { if ( x <= 1 ) return 1 ; int res = 2 ; for ( int i = 3 ; i <= x ; i ++ ) res = res * i ; return res ; } static int gcdOfFactorial ( int m , int n ) { int min = m < n ? m : n ; return factorial ( min ) ; } public static void Main ( ) { int m = 5 , n = 9 ; Console . WriteLine ( gcdOfFactorial ( m , n ) ) ; } }
using System ; class GFG { static int recDigSum ( int n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } } static void check ( int n ) { n = recDigSum ( n ) ; if ( n == 2 n == 3 n == 5 n == 7 ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } public static void Main ( ) { int n = 5602 ; check ( n ) ; } }
using System ; class GFG { static int findNumber ( int n ) { int x = ( int ) Math . Floor ( ( - 1 + Math . Sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int Base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - Base + 1 ; } public static void Main ( ) { int n = 55 ; Console . WriteLine ( findNumber ( n ) ) ; } }
using System ; public class GFG { static int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( weightedMean ( n ) ) ; } }
using System ; class GFG { static void calculate ( int [ ] a , int [ ] b , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . Floor ( ( double ) ( a [ i ] / mul ) ) ; Console . Write ( x + " ▁ " ) ; } } public static void Main ( ) { int [ ] a = { 5 , 100 , 8 } ; int [ ] b = { 2 , 3 } ; int n = a . Length ; int m = b . Length ; calculate ( a , b , n , m ) ; } }
using System ; class GFG { static void print ( int n ) { Console . WriteLine ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) Console . Write ( i + " ▁ " ) ; for ( int i = 1 ; i <= n ; i += 2 ) Console . Write ( i + " ▁ " ) ; for ( int i = 2 ; i <= n ; i += 2 ) Console . Write ( i + " ▁ " ) ; } public static void Main ( ) { int n = 3 ; print ( n ) ; } }
class GFG { static int lcm_fun ( int a , int b ) { if ( b == 0 ) return a ; return lcm_fun ( b , a % b ) ; } static int digitLCM ( int n ) { int lcm = 1 ; while ( n > 0 ) { lcm = ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ; if ( lcm == 0 ) return 0 ; n = n / 10 ; } return lcm ; } public static void Main ( ) { int n = 397 ; System . Console . WriteLine ( digitLCM ( n ) ) ; } }
using System ; class GFG { static double e = 2.71828 ; static int roundNo ( float num ) { return ( int ) ( num < 0 ? num - 0.5 : num + 0.5 ) ; } static void printBestCandidate ( int [ ] candidate , int n ) { int sample_size = roundNo ( ( float ) ( n / e ) ) ; Console . WriteLine ( " STRNEWLINE STRNEWLINE Sample ▁ size ▁ is ▁ " + sample_size ) ; int best = 0 ; for ( int i = 1 ; i < sample_size ; i ++ ) if ( candidate [ i ] > candidate [ best ] ) best = i ; for ( int i = sample_size ; i < n ; i ++ ) if ( candidate [ i ] >= candidate [ best ] ) { best = i ; break ; } if ( best >= sample_size ) Console . WriteLine ( " found is " ( best + 1 ) + " ▁ with ▁ talent ▁ " + candidate [ best ] ) ; else Console . Write ( " Couldn ' t ▁ find ▁ a ▁ best ▁ candidate STRNEWLINE " ) ; } public static void Main ( String [ ] args ) { int n = 8 ; int [ ] candidate = new int [ n ] ; Random rand = new Random ( ) ; for ( int i = 0 ; i < n ; i ++ ) candidate [ i ] = 1 + rand . Next ( 1 , 8 ) ; Console . Write ( " Candidate ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( i + 1 + " ▁ " ) ; Console . WriteLine ( ) ; Console . Write ( " Talents ▁ : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( candidate [ i ] + " ▁ " ) ; printBestCandidate ( candidate , n ) ; } }
using System ; class GFG { static double u_cal ( double u , int n ) { double temp = u ; for ( int i = 1 ; i < n ; i ++ ) temp = temp * ( u + i ) ; return temp ; } static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } static void Main ( ) { int n = 5 ; double [ ] x = { 1891 , 1901 , 1911 , 1921 , 1931 } ; double [ , ] y = new double [ n , n ] ; y [ 0 , 0 ] = 46 ; y [ 1 , 0 ] = 66 ; y [ 2 , 0 ] = 81 ; y [ 3 , 0 ] = 93 ; y [ 4 , 0 ] = 101 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= i ; j -- ) y [ j , i ] = y [ j , i - 1 ] - y [ j - 1 , i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) Console . Write ( y [ i , j ] + " TABSYMBOL " ) ; Console . WriteLine ( " " ) ; ; } double value = 1925 ; double sum = y [ n - 1 , 0 ] ; double u = ( value - x [ n - 1 ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { sum = sum + ( u_cal ( u , i ) * y [ n - 1 , i ] ) / fact ( i ) ; } Console . WriteLine ( " STRNEWLINE ▁ Value ▁ at ▁ " + value + " ▁ is ▁ " + Math . Round ( sum , 4 ) ) ; } }
using System ; class GFG { static int sumDigitSquare ( int n ) { int sq = 0 ; while ( n != 0 ) { int digit = n % 10 ; sq += digit * digit ; n = n / 10 ; } return sq ; } static bool isHappy ( int n ) { while ( true ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( n == 4 ) return false ; } } static public void Main ( ) { int n = 23 ; if ( isHappy ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( findSumSubsets ( n ) ) ; } }
using System ; class GFG { static int findMin ( int [ ] a , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . Log ( a [ i ] ) ; int x = ( int ) Math . Exp ( sum / n ) ; return x + 1 ; } public static void Main ( ) { int [ ] a = { 3 , 2 , 1 , 4 } ; int n = a . Length ; Console . WriteLine ( findMin ( a , n ) ) ; } }
using System ; class GFG { static int countdigits ( int N ) { int count = 0 ; while ( N > 0 ) { count ++ ; N = N / 10 ; } return count ; } static void cyclic ( int N ) { int num = N ; int n = countdigits ( N ) ; while ( true ) { Console . WriteLine ( num ) ; int rem = num % 10 ; int dev = num / 10 ; num = ( int ) ( ( Math . Pow ( 10 , n - 1 ) ) * rem + dev ) ; if ( num == N ) break ; } } public static void Main ( ) { int N = 5674 ; cyclic ( N ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool checkCircular ( int N ) { int count = 0 , temp = N ; while ( temp > 0 ) { count ++ ; temp /= 10 ; } int num = N ; while ( isPrime ( num ) ) { int rem = num % 10 ; int div = num / 10 ; num = ( int ) ( ( Math . Pow ( 10 , count - 1 ) ) * rem ) + div ; if ( num == N ) return true ; } return false ; } public static void Main ( ) { int N = 1193 ; if ( checkCircular ( N ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static bool sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; } public static void Main ( ) { int p1 = 4 , s1 = 4 , p2 = 8 , s2 = 2 ; if ( sackRace ( p1 , s1 , p2 , s2 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { public static void solve ( int n ) { double a = n / 2 ; if ( n % 2 != 0 ) { Console . WriteLine ( ( Math . Ceiling ( a ) - 1 ) + " ▁ " + ( Math . Floor ( a ) + 1 ) ) ; } else { if ( ( int ) ( a ) % 2 == 0 ) { Console . WriteLine ( ( Math . Ceiling ( a ) - 1 ) + " ▁ " + ( Math . Floor ( a ) + 1 ) ) ; } else { Console . WriteLine ( ( Math . Ceiling ( a ) - 2 ) + " ▁ " + ( Math . Floor ( a ) + 2 ) ) ; } } } public static void Main ( ) { int n = 34 ; solve ( n ) ; } }
using System ; class GFG { public static void Main ( ) { float P = 1 , R = 1 , T = 1 ; float SI = ( P * T * R ) / 100 ; Console . Write ( " Simple ▁ interest ▁ = ▁ " + SI ) ; } }
using System ; class GFG { static int countDigits ( int a , int b ) { int count = 0 ; int p = Math . Abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; } public static void Main ( ) { int a = 33 ; int b = - 24 ; Console . WriteLine ( " Number ▁ of ▁ digits ▁ = ▁ " + countDigits ( a , b ) ) ; } }
using System ; public class GFG { static void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) Console . WriteLine ( "1" ) ; else Console . WriteLine ( "0" ) ; } int mul = ( int ) Math . Pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; Console . WriteLine ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; } static public void Main ( ) { int a = 349 , b = 1 , x = 4 ; multiple ( a , b , x ) ; } }
using System ; public class main { static int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( maxSum ( n ) ) ; } }
using System ; class GFG { static int minNum ( int [ ] arr , int n ) { bool odd = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . Length ; Console . Write ( minNum ( arr , n ) ) ; } }
using System ; class GFG { static bool checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . Abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; } public static void Main ( ) { int num = - 1234 ; if ( checkJumbled ( num ) ) Console . WriteLine ( " True ▁ " ) ; else Console . WriteLine ( " False ▁ " ) ; num = - 1247 ; if ( checkJumbled ( num ) ) Console . WriteLine ( " True " ) ; else Console . WriteLine ( " False " ) ; } }
using System ; public class GFG { static int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; } static int josephify ( int n ) { int position = msbPos ( n ) ; int j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; } public static void Main ( ) { int n = 41 ; Console . WriteLine ( josephify ( n ) ) ; } }
using System ; public class CountXor { static int countXorPair ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; Console . WriteLine ( countXorPair ( arr , arr . Length ) ) ; } }
using System ; class GFG { static int powmod ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . Sqrt ( m ) + 1 ) ; int [ ] value = new int [ m ] ; for ( int i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( int j = 0 ; j < n ; ++ j ) { int cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return - 1 ; } static void Main ( ) { int a = 2 , b = 3 , m = 5 ; Console . WriteLine ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; Console . WriteLine ( discreteLogarithm ( a , b , m ) ) ; } }
using System ; class GFG { static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . Sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; } static void Main ( ) { int a = 2 , b = 3 , m = 5 ; Console . WriteLine ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; Console . WriteLine ( discreteLogarithm ( a , b , m ) ) ; } }
using System ; class GFG { static string nthprimedigitsnumber ( int number ) { int rem ; string num = " " ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += '2' ; break ; case 2 : num += '3' ; break ; case 3 : num += '5' ; break ; case 0 : num += '7' ; break ; } if ( number % 4 == 0 ) number -- ; number = number / 4 ; } char [ ] st = num . ToCharArray ( ) ; Array . Reverse ( st ) ; return new string ( st ) ; } static void Main ( ) { int number = 21 ; Console . WriteLine ( nthprimedigitsnumber ( 10 ) ) ; Console . WriteLine ( nthprimedigitsnumber ( number ) ) ; } }
using System ; class Test { static int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . Pow ( N , ( 1.0 / 3.0 ) ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = ( int ) Math . Pow ( diff , ( 1.0 / 3.0 ) ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; } public static void Main ( ) { for ( int i = 1 ; i <= 10 ; i ++ ) Console . Write ( " For ▁ n ▁ = ▁ " + i + " , ▁ " + + countPairs ( i ) + " ▁ pair ▁ exists " + " STRNEWLINE " ) ; } }
using System ; using System . Collections ; class Test { static void printEqualModNumbers ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { Console . write ( " Infinite ▁ solution " ) ; return ; } ArrayList v = new ArrayList ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . Add ( i ) ; if ( i != d / i ) v . Add ( d / i ) ; } } for ( int i = 0 ; i < v . Count ; i ++ ) { int temp = arr [ 0 ] % ( int ) v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % ( int ) v [ i ] != temp ) break ; if ( j == n ) Console . Write ( v [ i ] + " ▁ " ) ; } } public static void Main ( ) { int [ ] arr = { 38 , 6 , 34 } ; printEqualModNumbers ( arr , arr . Length ) ; } }
using System ; public class GFG { static int FirstDigit ( int [ ] arr , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . Log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . Floor ( S ) ; int ans = ( int ) Math . Pow ( 10 , fract_S ) ; return ans ; } public static void Main ( ) { int [ ] arr = { 5 , 8 , 3 , 7 } ; int n = arr . Length ; Console . WriteLine ( FirstDigit ( arr , n ) ) ; } }
using System ; class GFG { static int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; } public static void Main ( ) { int n = 1012 ; Console . Write ( countDigit ( n ) ) ; } }
using System ; class GFG { static int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int ans = 1 ; while ( n % 2 == 0 ) { n /= 2 ; ans *= 2 ; } return ans ; } public static void Main ( ) { int n = 36 ; int res = makeOdd ( n ) ; Console . Write ( res ) ; } }
using System ; class Solution { static int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; } public static void Main ( ) { int n = 56287 , x = 27 ; Console . WriteLine ( closestMultiple ( n , x ) ) ; } }
using System ; class GFG { static void printCubes ( int a , int b ) { int acrt = ( int ) Math . Pow ( a , ( double ) 1 / 3 ) ; int bcrt = ( int ) Math . Pow ( b , ( double ) 1 / 3 ) ; for ( int i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) Console . Write ( i * i * i + " ▁ " ) ; } static public void Main ( ) { int a = 24 ; int b = 576 ; Console . WriteLine ( " Perfect ▁ cubes ▁ " + " in ▁ given ▁ range : " ) ; printCubes ( a , b ) ; } }
using System ; class GFG { static int number0f2s ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = n / 10 ; } return count ; } static int numberOf2sinRange ( int n ) { int count = 0 ; for ( int i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; } public static void Main ( ) { Console . Write ( numberOf2sinRange ( 22 ) ) ; Console . WriteLine ( ) ; Console . Write ( numberOf2sinRange ( 100 ) ) ; } }
using System ; class GFG { static int minToggle ( int [ ] arr , int n ) { int [ ] zero = new int [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = Math . Min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 1 , 0 } ; int n = arr . Length ; Console . WriteLine ( minToggle ( arr , n ) ) ; } }
using System ; class GFG { static bool check ( String str ) { int n = str . Length ; if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; } public static void Main ( ) { String str = "1332" ; if ( check ( str ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class Solution { static int res = 0 ; static int checkRecursive ( int num , int x , int k , int n ) { if ( x == 0 ) res ++ ; int r = ( int ) Math . Floor ( Math . Pow ( num , 1.0 / n ) ) ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) Math . Pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - ( int ) Math . Pow ( i , n ) , i , n ) ; } return res ; } static int check ( int x , int n ) { return checkRecursive ( x , x , 0 , n ) ; } public static void Main ( ) { Console . WriteLine ( check ( 10 , 2 ) ) ; } }
using System ; class GFG { static int reverseNum ( int n ) { int rem , rev = 0 ; while ( n > 0 ) { rem = n % 10 ; rev = rev * 10 + rem ; n /= 10 ; } return rev ; } static bool isPalindrom ( int num ) { return num == reverseNum ( num ) ; } static int nthPalindrome ( int n , int k ) { int num = ( int ) Math . Pow ( 10 , k - 1 ) ; while ( true ) { if ( isPalindrom ( num ) ) -- n ; if ( n == 0 ) break ; ++ num ; } return num ; } public static void Main ( ) { int n = 6 , k = 5 ; Console . WriteLine ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " + nthPalindrome ( n , k ) ) ; n = 10 ; k = 6 ; Console . WriteLine ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " + nthPalindrome ( n , k ) ) ; } }
using System ; class GFG { static void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . Pow ( 10 , temp ) ; palindrome += n - 1 ; Console . Write ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { Console . Write ( palindrome % 10 ) ; palindrome /= 10 ; } Console . WriteLine ( " " ) ; } static public void Main ( ) { int n = 6 , k = 5 ; Console . Write ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; n = 10 ; k = 6 ; Console . Write ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; } }
using System ; class GFG { static int MAX = 100001 ; static long [ ] phi = new long [ MAX ] ; static long [ ] result = new long [ MAX ] ; static void computeTotient ( ) { phi [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( phi [ i ] == 0 ) { phi [ i ] = i - 1 ; for ( int j = ( i << 1 ) ; j < MAX ; j += i ) { if ( phi [ j ] == 0 ) phi [ j ] = j ; phi [ j ] = ( phi [ j ] / i ) * ( i - 1 ) ; } } } } static void sumOfGcdPairs ( ) { computeTotient ( ) ; for ( int i = 1 ; i < MAX ; ++ i ) { for ( int j = 2 ; i * j < MAX ; ++ j ) result [ i * j ] += i * phi [ j ] ; } for ( int i = 2 ; i < MAX ; i ++ ) result [ i ] += result [ i - 1 ] ; } public static void Main ( ) { sumOfGcdPairs ( ) ; int N = 4 ; Console . WriteLine ( " Summation ▁ of ▁ " + N + " ▁ = ▁ " + result [ N ] ) ; N = 12 ; Console . WriteLine ( " Summation ▁ of ▁ " + N + " ▁ = ▁ " + result [ N ] ) ; N = 5000 ; Console . Write ( " Summation ▁ of ▁ " + N + " ▁ = ▁ " + + result [ N ] ) ; } }
using System ; using System . Collections ; class GFG { static final int N = 3 ; static ArrayList solve ( int [ ] v ) { ArrayList res = new ArrayList ( ) ; int all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] ; res . Add ( all3 - v [ 1 ] * 2 ) ; res . Add ( all3 - v [ 2 ] * 2 ) ; res . Add ( all3 - v [ 0 ] * 2 ) ; return res ; } static void findVertex ( int [ ] xmid , int [ ] ymid ) { ArrayList V1 = solve ( xmid ) ; ArrayList V2 = solve ( ymid ) ; for ( int i = 0 ; i < 3 ; i ++ ) { Console . WriteLine ( V1 [ i ] + " ▁ " + V2 [ i ] ) ; } } public static void Main ( ) { int [ ] xmid = { 5 , 4 , 5 } ; int [ ] ymid = { 3 , 4 , 5 } ; findVertex ( xmid , ymid ) ; } }
using System ; using System . Collections ; class GFG { static int nthElement ( int a , int b , int n ) { ArrayList seq = new ArrayList ( ) ; for ( int i = 1 ; i <= n ; i ++ ) seq . Add ( a * i ) ; seq . Sort ( ) ; for ( int i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . Contains ( b * i ) ) { seq . Add ( b * i ) ; seq . Sort ( ) ; k -- ; } } return ( int ) seq [ n - 1 ] ; } static void Main ( ) { int a = 3 , b = 5 , n = 5 ; Console . WriteLine ( nthElement ( a , b , n ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { return b > 0 ? gcd ( b , a % b ) : a ; } static int countGCD ( int L , int R , int g ) { L = ( L + g - 1 ) / g ; R = R / g ; int ans = 0 ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; } public static void Main ( ) { int L = 1 , R = 11 , g = 5 ; Console . WriteLine ( countGCD ( L , R , g ) ) ; } }
using System ; class GFG { static int [ ] dig = { 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 } ; static int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; } public static void Main ( ) { int n = 14 ; Console . Write ( lastNon0Digit ( n ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; } static int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; } public static void Main ( ) { int x = 16 ; Console . Write ( firstFactorialDivisibleNumber ( x ) ) ; } }
using System ; class GFG { static void sieve ( bool [ ] prime , int n ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } static int maxDigitInPrimes ( int L , int R ) { bool [ ] prime = new bool [ R + 1 ] ; for ( int i = 0 ; i < R + 1 ; i ++ ) prime [ i ] = false ; sieve ( prime , R ) ; int [ ] freq = new int [ 10 ] ; for ( int i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) { while ( p > 0 ) { freq [ p % 10 ] ++ ; p /= 10 ; } } } int max = freq [ 0 ] , ans = 0 ; for ( int j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ( max != 0 ) ? ans : - 1 ; } public static void Main ( ) { int L = 1 , R = 20 ; Console . Write ( maxDigitInPrimes ( L , R ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int commDiv ( int a , int b ) { int n = gcd ( a , b ) ; int result = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) result += 1 ; else result += 2 ; } } return result ; } public static void Main ( String [ ] args ) { int a = 12 , b = 24 ; Console . Write ( commDiv ( a , b ) ) ; } }
using System ; class GFG { static long spellsCount ( String num ) { int n = num . Length ; long result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * ( long ) Math . Pow ( 2 , count - 1 ) ; } return result ; } public static void Main ( ) { String num = "11112" ; Console . Write ( spellsCount ( num ) ) ; } }
using System ; class GFG { static int numSquareSum ( int n ) { int squareSum = 0 ; while ( n != 0 ) { squareSum += ( n % 10 ) * ( n % 10 ) ; n /= 10 ; } return squareSum ; } static bool isHappynumber ( int n ) { int slow , fast ; slow = fast = n ; do { slow = numSquareSum ( slow ) ; fast = numSquareSum ( numSquareSum ( fast ) ) ; } while ( slow != fast ) ; return ( slow == 1 ) ; } public static void Main ( ) { int n = 13 ; if ( isHappynumber ( n ) ) Console . WriteLine ( n + " ▁ is ▁ a ▁ Happy ▁ number " ) ; else Console . WriteLine ( n + " ▁ is ▁ not ▁ a ▁ Happy ▁ number " ) ; } }
using System ; using System . Collections ; class GFG { static ArrayList allPrimes = new ArrayList ( ) ; static void sieve ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . Add ( p ) ; } static int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . Count ; i ++ ) { int p = ( int ) allPrimes [ i ] ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * ( int ) allPrimes [ i ] ; } result = result * ( exp + 1 ) ; } return result ; } public static void Main ( ) { Console . WriteLine ( factorialDivisors ( 6 ) ) ; } }
using System ; class GFG { static int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; } public static void Main ( ) { Console . WriteLine ( nonFibonacci ( 5 ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; } public static void Main ( ) { int a = 34 , b = 17 ; Console . Write ( " Gcd ▁ of ▁ given ▁ " + " numbers ▁ is ▁ " + gcd ( a , b ) ) ; } }
using System ; class GFG { static void findNDigitNumsUtil ( int n , char [ ] ou , int index , int evenSum , int oddSum ) { if ( index > n ) return ; if ( index == n ) { if ( Math . Abs ( evenSum - oddSum ) == 1 ) { ou [ index ] = ' \0' ; Console . Write ( ou ) ; Console . Write ( " ▁ " ) ; } return ; } if ( index % 2 != 0 ) { for ( int i = 0 ; i <= 9 ; i ++ ) { ou [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , ou , index + 1 , evenSum , oddSum + i ) ; } } { for ( int i = 0 ; i <= 9 ; i ++ ) { ou [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , ou , index + 1 , evenSum + i , oddSum ) ; } } } static void findNDigitNums ( int n ) { char [ ] ou = new char [ n + 1 ] ; int index = 0 ; int evenSum = 0 , oddSum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { ou [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , ou , index + 1 , evenSum + i , oddSum ) ; } } public static void Main ( ) { int n = 3 ; findNDigitNums ( n ) ; } }
using System ; class GFG { static string [ ] one = { " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " } ; static string [ ] ten = { " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " } ; static string numToWords ( int n , string s ) { string str = " " ; if ( n > 19 ) { str += ten [ n / 10 ] + one [ n % 10 ] ; } else { str += one [ n ] ; } if ( n != 0 ) { str += s ; } return str ; } static string convertToWords ( long n ) { string out1 = " " ; out1 += numToWords ( ( int ) ( n / 10000000 ) , " crore ▁ " ) ; out1 += numToWords ( ( int ) ( ( n / 100000 ) % 100 ) , " lakh ▁ " ) ; out1 += numToWords ( ( int ) ( ( n / 1000 ) % 100 ) , " thousand ▁ " ) ; out1 += numToWords ( ( int ) ( ( n / 100 ) % 10 ) , " hundred ▁ " ) ; if ( n > 100 && n % 100 > 0 ) { out1 += " and ▁ " ; } out1 += numToWords ( ( int ) ( n % 100 ) , " " ) ; return out1 ; } static void Main ( ) { long n = 438237764 ; Console . WriteLine ( convertToWords ( n ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { return ( a % b == 0 ) ? Math . Abs ( b ) : gcd ( b , a % b ) ; } static bool isPossible ( int a , int b , int c ) { return ( c % gcd ( a , b ) == 0 ) ; } public static void Main ( ) { int a = 3 , b = 6 , c = 9 ; if ( isPossible ( a , b , c ) ) Console . WriteLine ( " Possible " ) ; else Console . WriteLine ( " Not ▁ Possible " ) ; a = 3 ; b = 6 ; c = 8 ; if ( isPossible ( a , b , c ) ) Console . WriteLine ( " Possible " ) ; else Console . WriteLine ( " Not ▁ Possible " ) ; a = 2 ; b = 5 ; c = 1 ; if ( isPossible ( a , b , c ) ) Console . WriteLine ( " Possible " ) ; else Console . WriteLine ( " Not ▁ Possible " ) ; } }
using System ; public class GFG { static void farey ( int n ) { double x1 = 0 , y1 = 1 , x2 = 1 , y2 = n ; Console . Write ( " { 0 : F0 } / { 1 : F0 } ▁ { 2 : F0 } / { 3 : F0 } " , x1 , y1 , x2 , y2 ) ; while ( y != 1.0 ) { x = Math . Floor ( ( y1 + n ) / y2 ) * x2 - x1 ; y = Math . Floor ( ( y1 + n ) / y2 ) * y2 - y1 ; Console . Write ( " ▁ { 0 : F0 } / { 1 : F0 } " , x , y ) ; x1 = x2 ; x2 = x ; y1 = y2 ; y2 = y ; } } public static void Main ( String [ ] args ) { int n = 7 ; Console . Write ( " Farey ▁ Sequence ▁ of ▁ order ▁ " + n + " ▁ is STRNEWLINE " ) ; farey ( n ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; } static void findSmallest ( int a , int b ) { int lcm = ( a * b ) / gcd ( a , b ) ; Console . Write ( " x ▁ = ▁ " + lcm / a + " y = " } public static void Main ( ) { int a = 25 , b = 35 ; findSmallest ( a , b ) ; } }
using System ; class GFG { public int power ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } public int modInverse ( int a , int p ) { return power ( a , p - 2 , p ) ; } public int modFact ( int n , int p ) { if ( p <= n ) return 0 ; int res = ( p - 1 ) ; for ( int i = n + 1 ; i < p ; i ++ ) res = ( res * modInverse ( i , p ) ) % p ; return res ; } public static void Main ( ) { GFG g = new GFG ( ) ; int n = 25 , p = 29 ; Console . WriteLine ( g . modFact ( n , p ) ) ; } }
using System ; class GFG { static int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; } static public void Main ( ) { int n = 8 ; Console . WriteLine ( countWays ( n ) ) ; } }
using System ; class GFG { static int pairAndSum ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; } public static void Main ( ) { int [ ] arr = { 5 , 10 , 15 } ; int n = arr . Length ; Console . Write ( pairAndSum ( arr , n ) ) ; } }
using System ; class GFG { static int pairAndSum ( int [ ] arr , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int k = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) k ++ ; } ans += ( 1 << i ) * ( k * ( k - 1 ) / 2 ) ; } return ans ; } public static void Main ( ) { int [ ] arr = new int [ ] { 5 , 10 , 15 } ; int n = arr . Length ; Console . Write ( pairAndSum ( arr , n ) ) ; } }
using System ; namespace prime { public class GFG { public static bool isprime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } public static void Main ( ) { if ( isprime ( 11 ) ) Console . WriteLine ( " true " ) ; else Console . WriteLine ( " false " ) ; if ( isprime ( 15 ) ) Console . WriteLine ( " true " ) ; else Console . WriteLine ( " false " ) ; } } }
using System ; class GFG { static void computeTotient ( int n ) { long [ ] phi = new long [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= n ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } for ( int i = 1 ; i <= n ; i ++ ) Console . WriteLine ( " Totient ▁ of ▁ " + i + " ▁ is ▁ " + phi [ i ] ) ; } public static void Main ( ) { int n = 12 ; computeTotient ( n ) ; } }
using System ; class GFG { static int sumBetweenTwoKth ( int [ ] arr , int n , int k1 , int k2 ) { Array . Sort ( arr ) ; int result = 0 ; for ( int i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; } public static void Main ( ) { int [ ] arr = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; int k1 = 3 , k2 = 6 ; int n = arr . Length ; Console . Write ( sumBetweenTwoKth ( arr , n , k1 , k2 ) ) ; } }
using System ; public class GFG { static int countSquares ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( " Count ▁ of " + " squares ▁ is ▁ " + countSquares ( n ) ) ; } }
using System ; public class GFG { static int nthMagicNo ( int n ) { int pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( int ) ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( " nth ▁ magic " + " ▁ number ▁ is ▁ " + nthMagicNo ( n ) ) ; } }
using System ; public class GFG { static uint countOfMultiples ( uint n ) { return ( n / 3 + n / 5 - n / 15 ) ; } static public void Main ( ) { Console . WriteLine ( countOfMultiples ( 6 ) ) ; Console . WriteLine ( countOfMultiples ( 16 ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } public static void Main ( ) { int a = 98 , b = 56 ; Console . WriteLine ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
using System ; class GfG { static bool isDefeat ( string s1 , string s2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == '0' && s2 [ i ] == '1' ) || ( s1 [ i ] == '1' && s2 [ i ] == '0' ) ) continue ; else if ( ( s1 [ i ] == '0' && s2 [ i ] == ' Z ' ) || ( s1 [ i ] == ' Z ' && s2 [ i ] == '0' ) ) continue ; else { return true ; } } return false ; } public static void Main ( ) { string s1 = ( "01001101ZZ " ) ; string s2 = ( "10Z1001000" ) ; int n = 10 ; if ( isDefeat ( s1 , s2 , n ) ) Console . WriteLine ( " Defeat " ) ; else Console . WriteLine ( " Victory " ) ; } }
using System ; class GFG { static readonly int N = 3 , M = 3 ; static bool check ( int [ , ] a , int [ , ] b ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( a [ i , j ] != b [ i , j ] ) { a [ i , j ] ^= 1 ; a [ 0 , 0 ] ^= 1 ; a [ 0 , j ] ^= 1 ; a [ i , 0 ] ^= 1 ; } } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( a [ i , j ] != b [ i , j ] ) return false ; } } return true ; } public static void Main ( String [ ] args ) { int [ , ] a = { { 0 , 1 , 0 } , { 0 , 1 , 0 } , { 1 , 0 , 0 } } ; int [ , ] b = { { 1 , 0 , 0 } , { 1 , 0 , 0 } , { 1 , 0 , 0 } } ; if ( check ( a , b ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int FindIndexKthBit ( int n , int k ) { int cnt = 0 ; int ind = 0 ; while ( n > 0 ) { if ( ( n & 1 ) != 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; } public static void Main ( ) { int n = 15 , k = 3 ; int ans = FindIndexKthBit ( n , k ) ; if ( ans != - 1 ) Console . WriteLine ( ans ) ; else Console . WriteLine ( " No ▁ k - th ▁ set ▁ bit " ) ; } }
using System ; class GFG { static int minDistance ( int n1 , int n2 ) { int bitCount1 = ( int ) Math . Floor ( ( Math . Log ( n1 ) / Math . Log ( 2 ) ) ) + 1 ; int bitCount2 = ( int ) Math . Floor ( ( Math . Log ( n2 ) / Math . Log ( 2 ) ) ) + 1 ; int bitDiff = Math . Abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . Max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . Pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . Pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = ( int ) Math . Floor ( ( Math . Log ( xorValue ) / Math . Log ( 2 ) ) ) + 1 ; } int disSimilarBitPosition = maxBitCount - bitCountXorValue ; int result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; } public static void Main ( String [ ] args ) { int n1 = 12 , n2 = 5 ; Console . WriteLine ( minDistance ( n1 , n2 ) ) ; } }
using System ; class GFG { static int printMaxAfterRemoval ( String s ) { bool flag = false ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '0' && flag == false ) { flag = true ; continue ; } else Console . Write ( s [ i ] ) ; } return 0 ; } static void Main ( ) { String s = "1001" ; printMaxAfterRemoval ( s ) ; } }
using System ; class GFG { static int bitPos ( int n1 , int n2 ) { if ( n1 == n2 ) return 0 ; int bitCount1 = ( int ) Math . Floor ( Math . Log ( n1 ) / Math . Log ( 2 ) ) + 1 ; int bitCount2 = ( int ) Math . Floor ( Math . Log ( n2 ) / Math . Log ( 2 ) ) + 1 ; int bitDiff = Math . Abs ( bitCount1 - bitCount2 ) ; int maxBitCount = Math . Max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * ( int ) Math . Pow ( 2 , bitDiff ) ; } else { n1 = n1 * ( int ) Math . Pow ( 2 , bitDiff ) ; } int xorValue = n1 ^ n2 ; int bitCountXorValue = ( int ) Math . Floor ( Math . Log ( xorValue ) / Math . Log ( 2 ) ) + 1 ; int disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; } public static void Main ( ) { int n1 = 53 , n2 = 55 ; Console . Write ( bitPos ( n1 , n2 ) ) ; } }
using System ; public class GFG { static int countOddPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 != 1 ) ) { count ++ ; } } int evenPairCount = count * ( count - 1 ) / 2 ; int totPairs = N * ( N - 1 ) / 2 ; return totPairs - evenPairCount ; } public static void Main ( ) { int [ ] A = { 5 , 6 , 2 , 8 } ; int N = A . Length ; Console . WriteLine ( countOddPair ( A , N ) ) ; } }
using System ; class GFG { static void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 } ; int n = arr . Length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int OR ( int [ ] a , int n ) { int ans = a [ 0 ] ; int i ; for ( i = 1 ; i < n ; i ++ ) { ans |= a [ i ] ; } return ans ; } public static void Main ( ) { int [ ] a = { 1 , 4 , 6 } ; int n = a . Length ; Console . Write ( OR ( a , n ) ) ; } }
using System ; class GFG { static int bit ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; } static int maxSumOfBits ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } int incl = arr [ 0 ] ; int excl = 0 ; int excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 } ; int n = arr . Length ; Console . WriteLine ( maxSumOfBits ( arr , n ) ) ; } }
class GFG { static char increment ( char i ) { int i1 = - ( ~ ( int ) ( i ) ) ; return ( char ) ( i1 ) ; } static void Main ( ) { char n = ' a ' ; System . Console . WriteLine ( increment ( n ) ) ; } }
using System ; class GFG { static int findOddPair ( int [ ] A , int N ) { int i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; } public static void Main ( ) { int [ ] a = { 5 , 4 , 7 , 2 , 1 } ; int n = a . Length ; Console . Write ( findOddPair ( a , n ) ) ; } }
using System ; class GFG { static int MSBPosition ( long N ) { int msb_p = - 1 ; while ( N > 0 ) { N = N >> 1 ; msb_p ++ ; } return msb_p ; } static long findBitwiseOR ( long L , long R ) { long res = 0 ; int msb_p1 = MSBPosition ( L ) ; int msb_p2 = MSBPosition ( R ) ; while ( msb_p1 == msb_p2 ) { long res_val = ( 1 << msb_p1 ) ; res += res_val ; L -= res_val ; R -= res_val ; msb_p1 = MSBPosition ( L ) ; msb_p2 = MSBPosition ( R ) ; } msb_p1 = Math . Max ( msb_p1 , msb_p2 ) ; for ( int i = msb_p1 ; i >= 0 ; i -- ) { long res_val = ( 1 << i ) ; res += res_val ; } return res ; } public static void Main ( ) { int L = 12 , R = 18 ; Console . WriteLine ( findBitwiseOR ( L , R ) ) ; } }
using System ; class GFG { public static long maxOR ( long [ ] arr , int n , int k , int x ) { long [ ] preSum = new long [ n + 1 ] ; long [ ] suffSum = new long [ n + 1 ] ; long res = 0 , pow = 1 ; for ( int i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; } public static void Main ( ) { long [ ] arr = { 1 , 2 , 4 , 8 } ; int n = 4 ; int k = 2 , x = 3 ; long ans = maxOR ( arr , n , k , x ) ; Console . Write ( ans ) ; } }
using System ; class GFG { static int turnOnK ( int n , int k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; } public static void Main ( ) { int n = 4 ; int k = 2 ; Console . Write ( turnOnK ( n , k ) ) ; } }
using System ; public class GFG { static int minSum ( int [ ] a , int n ) { Array . Sort ( a ) ; int num1 = 0 ; int num2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; } static public void Main ( ) { int [ ] arr = { 5 , 3 , 0 , 7 , 4 } ; int n = arr . Length ; Console . WriteLine ( " The ▁ required ▁ sum ▁ is ▁ " + minSum ( arr , n ) ) ; } }
using System ; class GFG { static void printKthBit ( long n , long k ) { Console . WriteLine ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; } public static void Main ( ) { long n = 13 , k = 2 ; printKthBit ( n , k ) ; } }
using System ; class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } static int countOfOddsPascal ( int n ) { int c = countSetBits ( n ) ; return ( int ) Math . Pow ( 2 , c ) ; } public static void Main ( ) { int n = 20 ; Console . WriteLine ( countOfOddsPascal ( n ) ) ; } }
using System ; class GFG { static void ansQueries ( int [ ] prefeven , int [ ] prefodd , int l , int r ) { if ( ( r - l + 1 ) % 2 == 0 ) Console . WriteLine ( "0" ) ; else { if ( l % 2 == 0 ) Console . WriteLine ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ; else Console . WriteLine ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; } } static void wrapper ( int [ ] arr , int n , int [ ] l , int [ ] r , int q ) { int [ ] prefodd = new int [ 100 ] ; int [ ] prefeven = new int [ 100 ] ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } int j = 0 ; while ( j != q ) { ansQueries ( prefeven , prefodd , l [ j ] , r [ j ] ) ; j ++ ; } } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . Length ; int [ ] l = { 1 , 1 , 2 } ; int [ ] r = { 2 , 3 , 4 } ; int q = l . Length ; wrapper ( arr , n , l , r , q ) ; } }
using System ; class GFG { static int solve ( int [ ] p , int n ) { int G = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; G ^= ( p [ i ] - 1 ) ; } return G ; } public static void Main ( ) { int n = 3 ; int [ ] p = { 32 , 49 , 58 } ; int res = solve ( p , n ) ; Console . WriteLine ( " Player ▁ 2 ▁ wins " ) ; Console . WriteLine ( " Player ▁ 1 ▁ wins " ) ; } }
using System ; public class GfG { static int checkBit ( int pattern , int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; } static int maxAND ( int [ ] arr , int n ) { int res = 0 , count ; for ( int bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } return res ; } public static void Main ( ) { int [ ] arr = { 4 , 8 , 6 , 2 } ; int n = arr . Length ; Console . WriteLine ( " Maximum ▁ AND ▁ Value ▁ = ▁ " + maxAND ( arr , n ) ) ; } }
using System ; class GFG { static bool checkPowerof8 ( int n ) { double i = Math . Log ( n ) / Math . Log ( 8 ) ; return ( i - Math . Floor ( i ) < 0.000001 ) ; } static public void Main ( ) { int n = 65 ; if ( checkPowerof8 ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static byte longSize = 8 ; static int ULL_SIZE = 8 * longSize ; static bool bit_anagram_check ( long a ) { return ( BitCount ( ( int ) a ) == ( ULL_SIZE >> 1 ) ) ; } static int BitCount ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; } public static void Main ( String [ ] args ) { long a = 4294967295L ; Console . WriteLine ( bit_anagram_check ( a ) ) ; } }
using System ; public class main { static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; 1 << i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { int num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; } public static void Main ( String [ ] args ) { int n = 10 ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; class GFG { static int posOfRightMostDiffBit ( int m , int n ) { return ( int ) Math . Floor ( Math . Log10 ( Math . Pow ( m ^ n , 2 ) ) ) + 2 ; } public static void Main ( String [ ] args ) { int m = 52 , n = 4 ; Console . Write ( " Position ▁ = ▁ " + posOfRightMostDiffBit ( m , n ) ) ; } }
using System ; class GFG { static int setKthBit ( int n , int k ) { return ( ( 1 << k ) n ) ; } public static void Main ( ) { int n = 10 , k = 2 ; Console . Write ( " Kth ▁ bit ▁ set ▁ number ▁ = ▁ " + setKthBit ( n , k ) ) ; } }
using System ; class GFG { static void reverseArray ( int [ ] arr , int n ) { int x = ( int . MinValue / int . MaxValue ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) swap ( arr , i , n + ( x * i ) + x ) ; } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void Main ( ) { int [ ] arr = { 5 , 3 , 7 , 2 , 1 , 6 } ; int n = arr . Length ; reverseArray ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class GFG { static void reverseArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n / 2 ; i ++ ) { swap ( arr , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) ; } } static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 3 , 7 , 2 , 1 , 6 } ; int n = arr . Length ; reverseArray ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } } }
using System ; class Xor { static int maxXORInRange ( int L , int R ) { int LXR = L ^ R ; int msbPos = 0 ; while ( LXR > 0 ) { msbPos ++ ; LXR >>= 1 ; } int maxXOR = 0 ; int two = 1 ; while ( msbPos -- > 0 ) { maxXOR += two ; two <<= 1 ; } return maxXOR ; } public static void Main ( ) { int L = 8 ; int R = 20 ; Console . WriteLine ( maxXORInRange ( L , R ) ) ; } }
using System ; class GFG { static int CountZeroBit ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 2 != 0 ) count ++ ; n >>= 1 ; } return count ; } static int CountORandSumEqual ( int N ) { int count = CountZeroBit ( N ) ; return ( 1 << count ) ; } public static void Main ( ) { int N = 10 ; Console . Write ( CountORandSumEqual ( N ) ) ; } }
using System ; class GFG { static int countNumbers ( int n ) { int k = 0 ; int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( int ) ( Math . Pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; } public static void Main ( ) { int n = 11 ; Console . WriteLine ( countNumbers ( n ) ) ; } }
using System ; class GFG { static bool isMultipleOf4 ( int n ) { if ( n == 1 ) return false ; int XOR = 0 ; for ( int i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; } public static void Main ( ) { for ( int n = 0 ; n <= 42 ; n ++ ) { if ( isMultipleOf4 ( n ) ) Console . Write ( n + " ▁ " ) ; } } }
using System ; class GFG { static bool isMultipleOf4 ( int n ) { if ( n == 0 ) return true ; return ( ( ( n >> 2 ) << 2 ) == n ) ; } static void Main ( ) { for ( int n = 0 ; n <= 42 ; n ++ ) if ( isMultipleOf4 ( n ) ) Console . Write ( n + " ▁ " ) ; } }
using System ; class GFG { static int countSetBits ( int x ) { int count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; } static int ceilLog2 ( int x ) { int count = 0 ; x -- ; while ( x > 0 ) { x = x >> 1 ; count ++ ; } return count ; } static bool isBleak ( int n ) { for ( int x = n - ceilLog2 ( n ) ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; } public static void Main ( ) { if ( isBleak ( 3 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; if ( isBleak ( 4 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int countStrings ( int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; } public static void Main ( ) { Console . WriteLine ( countStrings ( 5 ) ) ; } }
using System ; class GFG { static int N = 3 ; static int M = 4 ; static void printDistance ( int [ , ] mat ) { int [ , ] ans = new int [ N , M ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) ans [ i , j ] = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) { for ( int k = 0 ; k < N ; k ++ ) for ( int l = 0 ; l < M ; l ++ ) { if ( mat [ k , l ] == 1 ) ans [ i , j ] = Math . Min ( ans [ i , j ] , Math . Abs ( i - k ) + Math . Abs ( j - l ) ) ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) Console . Write ( ans [ i , j ] + " ▁ " ) ; Console . WriteLine ( ) ; } } public static void Main ( ) { int [ , ] mat = { { 0 , 0 , 0 , 1 } , { 0 , 0 , 1 , 1 } , { 0 , 1 , 1 , 0 } } ; printDistance ( mat ) ; } }
using System ; class GFG { public static bool isMinHeap ( int [ ] level ) { int n = level . Length - 1 ; for ( int i = ( n / 2 - 1 ) ; i >= 0 ; i -- ) { if ( level [ i ] > level [ 2 * i + 1 ] ) { return false ; } if ( 2 * i + 2 < n ) { if ( level [ i ] > level [ 2 * i + 2 ] ) { return false ; } } } return true ; } public static void Main ( string [ ] args ) { int [ ] level = new int [ ] { 10 , 15 , 14 , 25 , 30 } ; if ( isMinHeap ( level ) ) { Console . WriteLine ( " True " ) ; } else { Console . WriteLine ( " False " ) ; } } }
using System ; class GFG { static int mostFrequent ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int max_count = 1 , res = arr [ 0 ] ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } public static void Main ( ) { int [ ] arr = { 1 , 5 , 2 , 1 , 3 , 2 , 1 } ; int n = arr . Length ; Console . WriteLine ( mostFrequent ( arr , n ) ) ; } }
using System ; class GFG { public virtual bool aredisjoint ( int [ ] set1 , int [ ] set2 ) { for ( int i = 0 ; i < set1 . Length ; i ++ ) { for ( int j = 0 ; j < set2 . Length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) { return false ; } } } return true ; } public static void Main ( string [ ] args ) { GFG dis = new GFG ( ) ; int [ ] set1 = new int [ ] { 12 , 34 , 11 , 9 , 3 } ; int [ ] set2 = new int [ ] { 7 , 2 , 1 , 5 } ; bool result = dis . aredisjoint ( set1 , set2 ) ; if ( result ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static void findMissing ( int [ ] a , int [ ] b , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) Console . Write ( a [ i ] + " ▁ " ) ; } } public static void Main ( ) { int [ ] a = { 1 , 2 , 6 , 3 , 4 , 5 } ; int [ ] b = { 2 , 4 , 3 , 1 , 0 } ; int n = a . Length ; int m = b . Length ; findMissing ( a , b , n , m ) ; } }
using System ; class GFG { public static bool areEqual ( int [ ] arr1 , int [ ] arr2 ) { int n = arr1 . Length ; int m = arr2 . Length ; if ( n != m ) return false ; Array . Sort ( arr1 ) ; Array . Sort ( arr2 ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } public static void Main ( ) { int [ ] arr1 = { 3 , 5 , 2 , 5 , 2 } ; int [ ] arr2 = { 2 , 3 , 5 , 5 , 2 } ; if ( areEqual ( arr1 , arr2 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool isProduct ( int [ ] arr , int n , int x ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; } static void Main ( ) { int [ ] arr = { 10 , 20 , 9 , 40 } ; int x = 400 ; int n = arr . Length ; if ( isProduct ( arr , n , x ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; x = 190 ; if ( isProduct ( arr , n , x ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int findGreatest ( int [ ] arr , int n ) { int result = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . Max ( result , arr [ i ] ) ; return result ; } static public void Main ( ) { int [ ] arr = { 30 , 10 , 9 , 3 , 35 } ; int n = arr . Length ; Console . WriteLine ( findGreatest ( arr , n ) ) ; } }
using System ; class GFG { public static void getPairsCount ( int [ ] arr , int sum ) { int count = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) for ( int j = i + 1 ; j < arr . Length ; j ++ ) if ( ( arr [ i ] + arr [ j ] ) == sum ) count ++ ; Console . WriteLine ( " Count ▁ of ▁ pairs ▁ is ▁ " + count ) ; } static public void Main ( ) { int [ ] arr = { 1 , 5 , 7 , - 1 , 5 } ; int sum = 6 ; getPairsCount ( arr , sum ) ; } }
using System ; class GFG { static int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; } public static void Main ( ) { int [ ] arr1 = { 1 , 3 , 5 , 7 } ; int [ ] arr2 = { 2 , 3 , 5 , 8 } ; int m = arr1 . Length ; int n = arr2 . Length ; int x = 10 ; Console . WriteLine ( " Count ▁ = ▁ " + countPairs ( arr1 , arr2 , m , n , x ) ) ; } }
using System ; class GFG { static bool isPresent ( int [ ] arr , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; } static int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int value = x - arr1 [ i ] ; if ( isPresent ( arr2 , 0 , n - 1 , value ) ) count ++ ; } return count ; } public static void Main ( ) { int [ ] arr1 = { 1 , 3 , 5 , 7 } ; int [ ] arr2 = { 2 , 3 , 5 , 8 } ; int m = arr1 . Length ; int n = arr2 . Length ; int x = 10 ; Console . WriteLine ( " Count ▁ = ▁ " + countPairs ( arr1 , arr2 , m , n , x ) ) ; } }
using System ; class GFG { static int countPairs ( int [ ] arr1 , int [ ] arr2 , int m , int n , int x ) { int count = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; } public static void Main ( ) { int [ ] arr1 = { 1 , 3 , 5 , 7 } ; int [ ] arr2 = { 2 , 3 , 5 , 8 } ; int m = arr1 . Length ; int n = arr2 . Length ; int x = 10 ; Console . WriteLine ( " Count ▁ = ▁ " + countPairs ( arr1 , arr2 , m , n , x ) ) ; } }
using System ; class GFG { static bool isPresent ( int [ ] arr , int low , int high , int value ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; } static int countQuadruples ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 , int [ ] arr4 , int n , int x ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) { int T = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; if ( isPresent ( arr4 , 0 , n - 1 , x - T ) ) count ++ ; } return count ; } public static void Main ( String [ ] args ) { int [ ] arr1 = { 1 , 4 , 5 , 6 } ; int [ ] arr2 = { 2 , 3 , 7 , 8 } ; int [ ] arr3 = { 1 , 4 , 6 , 10 } ; int [ ] arr4 = { 2 , 4 , 7 , 8 } ; int n = 4 ; int x = 30 ; Console . WriteLine ( " Count ▁ = ▁ " + countQuadruples ( arr1 , arr2 , arr3 , arr4 , n , x ) ) ; } }
using System ; class GFG { public static int countPairs ( int [ ] arr , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int product = arr [ i ] * arr [ j ] ; for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; } public static void Main ( string [ ] args ) { int [ ] arr = new int [ ] { 6 , 2 , 4 , 12 , 5 , 3 } ; int n = arr . Length ; Console . WriteLine ( countPairs ( arr , n ) ) ; } }
using System ; class GFG { static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } public static void Main ( String [ ] args ) { int n = 9 ; Console . WriteLine ( fib ( n ) ) ; } }
using System ; class GFG { static int factTR ( int n , int a ) { if ( n == 0 ) return a ; return factTR ( n - 1 , n * a ) ; } static int fact ( int n ) { return factTR ( n , 1 ) ; } static public void Main ( ) { Console . WriteLine ( fact ( 5 ) ) ; } }
using System ; class GFG { static void findPairs ( int [ ] arr1 , int [ ] arr2 , int n , int m , int x ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) Console . WriteLine ( arr1 [ i ] + " ▁ " + arr2 [ j ] ) ; } static void Main ( ) { int [ ] arr1 = { 1 , 2 , 3 , 7 , 5 , 4 } ; int [ ] arr2 = { 0 , 7 , 4 , 3 , 2 , 1 } ; int x = 8 ; findPairs ( arr1 , arr2 , arr1 . Length , arr2 . Length , x ) ; } }
using System ; public class GFG { static void findPair ( int [ ] arr , int n ) { bool found = false ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { Console . WriteLine ( arr [ i ] + " ▁ " + arr [ j ] ) ; found = true ; } } } } if ( found == false ) Console . WriteLine ( " Not ▁ exist " ) ; } static public void Main ( String [ ] args ) { int [ ] arr = { 10 , 4 , 8 , 13 , 5 } ; int n = arr . Length ; findPair ( arr , n ) ; } }
using System ; public class GFG { static bool printPairs ( int [ ] arr , int n , int k ) { bool isPairFound = true ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { Console . Write ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " ▁ " ) ; isPairFound = true ; } } } return isPairFound ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 5 , 4 , 7 } ; int k = 3 ; if ( printPairs ( arr , arr . Length , k ) == false ) Console . WriteLine ( " No ▁ such ▁ pair ▁ exists " ) ; } }
using System ; class GFG { static int ASCII_SIZE = 256 ; static char getMaxOccuringChar ( String str ) { int [ ] count = new int [ ASCII_SIZE ] ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) count [ str [ i ] ] ++ ; int max = - 1 ; char result = ' ▁ ' ; for ( int i = 0 ; i < len ; i ++ ) { if ( max < count [ str [ i ] ] ) { max = count [ str [ i ] ] ; result = str [ i ] ; } } return result ; } public static void Main ( ) { String str = " sample ▁ string " ; Console . Write ( " Max ▁ occurring ▁ character ▁ is ▁ " + getMaxOccuringChar ( str ) ) ; } }
using System ; class GFG { static int firstNonRepeating ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && arr [ i ] == arr [ j ] ) break ; if ( j == n ) return arr [ i ] ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 9 , 4 , 9 , 6 , 7 , 4 } ; int n = arr . Length ; Console . Write ( firstNonRepeating ( arr , n ) ) ; } }
using System ; using System . Collections ; class GFG { static void subarrayDivisibleByK ( int [ ] arr , int n , int k ) { int [ ] mp = new int [ 1000 ] ; int s = 0 , e = 0 , maxs = 0 , maxe = 0 ; mp [ arr [ 0 ] % k ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { int mod = arr [ i ] % k ; while ( mp [ k - mod ] != 0 || ( mod == 0 && mp [ mod ] != 0 ) ) { mp [ arr [ s ] % k ] -- ; s ++ ; } mp [ mod ] ++ ; e ++ ; if ( ( e - s ) > ( maxe - maxs ) ) { maxe = e ; maxs = s ; } } Console . Write ( " The ▁ maximum ▁ size ▁ is ▁ " + ( maxe - maxs + 1 ) + " ▁ and ▁ the ▁ subarray ▁ is ▁ as ▁ follows STRNEWLINE " ) ; for ( int i = maxs ; i <= maxe ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int k = 3 ; int [ ] arr = { 5 , 10 , 15 , 20 , 25 } ; int n = arr . Length ; subarrayDivisibleByK ( arr , n , k ) ; } }
using System ; public class GFG { static bool findTriplet ( int [ ] a1 , int [ ] a2 , int [ ] a3 , int n1 , int n2 , int n3 , int sum ) { for ( int i = 0 ; i < n1 ; i ++ ) for ( int j = 0 ; j < n2 ; j ++ ) for ( int k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; } static public void Main ( ) { int [ ] a1 = { 1 , 2 , 3 , 4 , 5 } ; int [ ] a2 = { 2 , 3 , 6 , 1 , 2 } ; int [ ] a3 = { 3 , 2 , 4 , 5 , 6 } ; int sum = 9 ; int n1 = a1 . Length ; int n2 = a2 . Length ; int n3 = a3 . Length ; if ( findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class GFG { static int minInsertion ( String str ) { int n = str . Length ; int res = 0 ; int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; } public static void Main ( ) { string str = " geeksforgeeks " ; Console . WriteLine ( minInsertion ( str ) ) ; } }
using System ; class GFG { static int findDiff ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 0 , max_count = 0 , min_count = n ; for ( int i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . Max ( max_count , count ) ; min_count = Math . Min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; } public static void Main ( ) { int [ ] arr = { 7 , 8 , 4 , 5 , 4 , 1 , 1 , 7 , 7 , 2 , 5 } ; int n = arr . Length ; Console . WriteLine ( findDiff ( arr , n ) ) ; } }
using System ; public class GFG { static int maxDiff ( int [ ] arr , int n ) { int SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { bool isSingleOccurance = true ; for ( int j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . Abs ( SubsetSum_1 - SubsetSum_2 ) ; } static public void Main ( ) { int [ ] arr = { 4 , 2 , - 3 , 3 , - 2 , - 2 , 8 } ; int n = arr . Length ; Console . WriteLine ( " Maximum ▁ Difference ▁ = ▁ " + maxDiff ( arr , n ) ) ; } }
using System ; public class GFG { static int maxDiff ( int [ ] arr , int n ) { int result = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . Abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . Abs ( arr [ n - 1 ] ) ; return result ; } static public void Main ( ) { int [ ] arr = { 4 , 2 , - 3 , 3 , - 2 , - 2 , 8 } ; int n = arr . Length ; Console . WriteLine ( " Maximum ▁ Difference ▁ = ▁ " + maxDiff ( arr , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void printAllAPTriplets ( int [ ] arr , int n ) { List < int > s = new List < int > ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int diff = arr [ j ] - arr [ i ] ; bool exists = s . Exists ( element => element == ( arr [ i ] - diff ) ) ; if ( exists ) Console . WriteLine ( arr [ i ] - diff + " ▁ " + arr [ i ] + " ▁ " + arr [ j ] ) ; } s . Add ( arr [ i ] ) ; } } static void Main ( ) { int [ ] arr = new int [ ] { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = arr . Length ; printAllAPTriplets ( arr , n ) ; } }
using System ; class GFG { static void findAllTriplets ( int [ ] arr , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { for ( int j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { Console . WriteLine ( arr [ j ] + " ▁ " + arr [ i ] + " ▁ " + arr [ k ] ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } } public static void Main ( ) { int [ ] arr = { 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 } ; int n = arr . Length ; findAllTriplets ( arr , n ) ; } }
using System ; public class GFG { static int countTriplets ( int [ ] arr , int n , int m ) { int count = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] * arr [ j ] * arr [ k ] == m ) count ++ ; return count ; } public static void Main ( ) { int [ ] arr = { 1 , 4 , 6 , 2 , 3 , 8 } ; int m = 24 ; Console . WriteLine ( countTriplets ( arr , arr . Length , m ) ) ; } }
using System ; class GFG { static int countPairs ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 1 , 2 } ; int n = arr . Length ; Console . WriteLine ( countPairs ( arr , n ) ) ; } }
using System ; class GFG { public class pair { public int first , second ; public pair ( int a , int b ) { first = a ; second = b ; } } static void preCalculate ( int [ ] binary , int n , pair [ ] left ) { int count1 = 0 , count0 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] . first = count1 ; left [ i ] . second = count0 ; if ( binary [ i ] != 0 ) count1 ++ ; else count0 ++ ; } } public static void Main ( String [ ] args ) { int [ ] binary = { 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 } ; int n = binary . Length ; pair [ ] left = new pair [ n ] ; for ( int i = 0 ; i < n ; i ++ ) left [ i ] = new pair ( 0 , 0 ) ; preCalculate ( binary , n , left ) ; int [ ] queries = { 0 , 1 , 2 , 4 } ; int q = queries . Length ; for ( int i = 0 ; i < q ; i ++ ) Console . WriteLine ( left [ queries [ i ] ] . first + " ▁ ones ▁ " + left [ queries [ i ] ] . second + " ▁ zeros STRNEWLINE " ) ; } }
using System ; class GFG { public static int pos1 = - 1 ; public static int pos2 = - 1 ; public static bool equiSumUtil ( int [ ] arr ) { int n = arr . Length ; int [ ] pre = new int [ n ] ; int sum = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; pre [ i ] = sum ; } int [ ] suf = new int [ n ] ; sum = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; suf [ i ] = sum ; } int total_sum = sum ; int j = n - 1 ; i = 0 ; while ( i < j - 1 ) { if ( pre [ i ] == total_sum / 3 ) { pos1 = i ; } if ( suf [ j ] == total_sum / 3 ) { pos2 = j ; } if ( pos1 != - 1 && pos2 != - 1 ) { if ( suf [ pos1 + 1 ] - suf [ pos2 ] == total_sum / 3 ) { return true ; } else { return false ; } } if ( pre [ i ] < suf [ j ] ) { i ++ ; } else { j -- ; } } return false ; } public static void equiSum ( int [ ] arr ) { bool ans = equiSumUtil ( arr ) ; if ( ans ) { Console . Write ( " First ▁ Segment ▁ : ▁ " ) ; for ( int i = 0 ; i <= pos1 ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } Console . WriteLine ( ) ; Console . Write ( " Second ▁ Segment ▁ : ▁ " ) ; for ( int i = pos1 + 1 ; i < pos2 ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } Console . WriteLine ( ) ; Console . Write ( " Third ▁ Segment ▁ : ▁ " ) ; for ( int i = pos2 ; i < arr . Length ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } Console . WriteLine ( ) ; } else { Console . WriteLine ( " Array ▁ cannot ▁ be ▁ " + " divided ▁ into ▁ three ▁ equal ▁ sum ▁ segments " ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 6 , 2 , 7 , 1 , 2 , 8 } ; equiSum ( arr ) ; } }
using System ; public class GFG { public static int getRightMin ( int [ ] arr , int n ) { int min = arr [ 0 ] ; int rightMin = 0 ; int i = 1 ; while ( i < n ) { if ( arr [ i ] == min ) rightMin = i ; i *= 2 ; } i = rightMin + 1 ; while ( i < n && arr [ i ] == min ) { rightMin = i ; i ++ ; } return rightMin ; } public static int getLeftMax ( int [ ] arr , int n ) { int max = arr [ n - 1 ] ; int leftMax = n - 1 ; int i = n - 2 ; while ( i > 0 ) { if ( arr [ i ] == max ) leftMax = i ; i /= 2 ; } i = leftMax - 1 ; while ( i >= 0 && arr [ i ] == max ) { leftMax = i ; i -- ; } return leftMax ; } public static void Main ( ) { int [ ] arr = { 0 , 0 , 1 , 2 , 5 , 5 , 6 , 8 , 8 } ; int n = arr . Length ; Console . WriteLine ( " Minimum ▁ left ▁ : ▁ " + 0 ) ; Console . WriteLine ( " Minimum ▁ right ▁ : ▁ " + getRightMin ( arr , n ) ) ; Console . WriteLine ( " Maximum ▁ left ▁ : ▁ " + getLeftMax ( arr , n ) ) ; Console . WriteLine ( " Maximum ▁ right ▁ : ▁ " + ( n - 1 ) ) ; } }
using System ; public class GFG { static int countNum ( int [ ] arr , int n ) { int count = 0 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; } static public void Main ( ) { int [ ] arr = { 3 , 5 , 8 , 6 } ; int n = arr . Length ; Console . WriteLine ( countNum ( arr , n ) ) ; } }
using System ; class GFG { static int countSubarrays ( int [ ] arr , int n ) { int difference = 0 ; int ans = 0 ; int [ ] hash_positive = new int [ n + 1 ] ; int [ ] hash_negative = new int [ n + 1 ] ; Array . Clear ( hash_positive , 0 , n + 1 ) ; Array . Clear ( hash_negative , 0 , n + 1 ) ; hash_positive [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) difference ++ ; else difference -- ; if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; } static void Main ( ) { int [ ] arr = new int [ ] { 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 } ; int n = arr . Length ; Console . Write ( " Total ▁ Number ▁ of ▁ Even - Odd " + " ▁ subarrays ▁ are ▁ " + countSubarrays ( arr , n ) ) ; } }
using System ; class GFG { static bool search ( int [ , ] mat , int m , int n , int x ) { int i = m - 1 , j = 0 ; while ( i >= 0 && j < n ) { if ( mat [ i , j ] == x ) return true ; if ( mat [ i , j ] > x ) i -- ; else j ++ ; } return false ; } public static void Main ( ) { int [ , ] mat = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , { 50 , 60 , 70 , 80 } } ; if ( search ( mat , 5 , 4 , 29 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class GFG { static void printGreaterCount ( String str ) { int len = str . Length ; int [ ] right = new int [ len ] ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] < str [ j ] ) { right [ i ] ++ ; } } } for ( int i = 0 ; i < len ; i ++ ) { Console . Write ( right [ i ] + " ▁ " ) ; } } public static void Main ( ) { String str = " abcd " ; printGreaterCount ( str ) ; } }
using System ; public class GFG { static int appearsNBy3 ( int [ ] arr , int n ) { int count1 = 0 , count2 = 0 ; int first = int . MaxValue ; int second = int . MaxValue ; for ( int i = 1 ; i < n ; i ++ ) { if ( first == arr [ i ] ) count1 ++ ; else if ( second == arr [ i ] ) count2 ++ ; else if ( count1 == 0 ) { count1 ++ ; first = arr [ i ] ; } else if ( count2 == 0 ) { count2 ++ ; second = arr [ i ] ; } else { count1 -- ; count2 -- ; } } count1 = 0 ; count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == first ) count1 ++ ; else if ( arr [ i ] == second ) count2 ++ ; } if ( count1 > n / 3 ) return first ; if ( count2 > n / 3 ) return second ; return - 1 ; } static public void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 1 , 1 } ; int n = arr . Length ; Console . WriteLine ( appearsNBy3 ( arr , n ) ) ; } }
using System ; class Count { public static int count4Divisibiles ( int [ ] arr , int n ) { int [ ] freq = { 0 , 0 , 0 , 0 } ; int i = 0 ; int ans ; for ( i = 0 ; i < n ; i ++ ) ++ freq [ arr [ i ] % 4 ] ; ans = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 ; ans += freq [ 2 ] * ( freq [ 2 ] - 1 ) / 2 ; ans += freq [ 1 ] * freq [ 3 ] ; return ( ans ) ; } public static void Main ( ) { int [ ] arr = { 2 , 2 , 1 , 7 , 5 } ; int n = 5 ; Console . WriteLine ( count4Divisibiles ( arr , n ) ) ; } }
using System ; class gfg { static int countMaxSetBits ( int left , int right ) { int max_count = - 1 , num = 0 ; for ( int i = left ; i <= right ; ++ i ) { int temp = i , cnt = 0 ; while ( temp > 0 ) { if ( temp % 2 == 1 ) ++ cnt ; temp >>= 1 ; } if ( cnt > max_count ) { max_count = cnt ; num = i ; } } return num ; } public static void Main ( String [ ] args ) { int l = 1 , r = 5 ; Console . WriteLine ( countMaxSetBits ( l , r ) ) ; l = 1 ; r = 10 ; Console . Write ( countMaxSetBits ( l , r ) ) ; } }
using System ; class GFG { static void recaman ( int n ) { int [ ] arr = new int [ n ] ; arr [ 0 ] = 0 ; Console . Write ( arr [ 0 ] + " ▁ , " ) ; for ( int i = 1 ; i < n ; i ++ ) { int curr = arr [ i - 1 ] - i ; int j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; Console . Write ( arr [ i ] + " , ▁ " ) ; } } public static void Main ( ) { int n = 17 ; recaman ( n ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void recaman ( int n ) { if ( n <= 0 ) return ; Console . Write ( " { 0 } , ▁ " , 0 ) ; HashSet < int > s = new HashSet < int > ( ) ; s . Add ( 0 ) ; int prev = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int curr = prev - i ; if ( curr < 0 || s . Contains ( curr ) ) curr = prev + i ; s . Add ( curr ) ; Console . Write ( " { 0 } , ▁ " , curr ) ; prev = curr ; } } public static void Main ( String [ ] args ) { int n = 17 ; recaman ( n ) ; } }
using System ; using System . Collections ; class GFG { static int findArea ( int [ ] arr , int n ) { Array . Sort ( arr ) ; Array . Reverse ( arr ) ; int [ ] dimension = { 0 , 0 } ; for ( int i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 2 , 1 , 4 , 6 , 6 , 2 , 5 } ; int n = arr . Length ; Console . Write ( findArea ( arr , n ) ) ; } }
using System ; class PairInSortedRotated { static bool pairInSortedRotated ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; } public static void Main ( ) { int [ ] arr = { 11 , 15 , 6 , 8 , 9 , 10 } ; int sum = 16 ; int n = arr . Length ; if ( pairInSortedRotated ( arr , n , sum ) ) Console . WriteLine ( " Array ▁ has ▁ two ▁ elements " + " ▁ with ▁ sum ▁ 16" ) ; else Console . WriteLine ( " Array ▁ doesn ' t ▁ have ▁ two " + " ▁ elements ▁ with ▁ sum ▁ 16 ▁ " ) ; } }
using System ; class GFG { static int pairsInSortedRotated ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; int l = ( i + 1 ) % n ; int r = i ; int cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; } static public void Main ( ) { int [ ] arr = { 11 , 15 , 6 , 7 , 9 , 10 } ; int sum = 16 ; int n = arr . Length ; Console . WriteLine ( pairsInSortedRotated ( arr , n , sum ) ) ; } }
using System ; class Test { static int [ ] arr = new int [ ] { 10 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; static int maxSum ( ) { int arrSum = 0 ; int currVal = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { arrSum = arrSum + arr [ i ] ; currVal = currVal + ( i * arr [ i ] ) ; } int maxVal = currVal ; for ( int j = 1 ; j < arr . Length ; j ++ ) { currVal = currVal + arrSum - arr . Length * arr [ arr . Length - j ] ; if ( currVal > maxVal ) maxVal = currVal ; } return maxVal ; } public static void Main ( ) { Console . WriteLine ( " Max ▁ sum ▁ is ▁ " + maxSum ( ) ) ; } }
using System ; class GFG { static int maxSum ( int [ ] arr , int n ) { int res = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int curr_sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . Max ( res , curr_sum ) ; } return res ; } public static void Main ( ) { int [ ] arr = { 8 , 3 , 1 , 2 } ; int n = arr . Length ; Console . WriteLine ( maxSum ( arr , n ) ) ; } }
using System ; class GFG { static int maxSum ( int [ ] arr , int n ) { int cum_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; int curr_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; int res = curr_val ; for ( int i = 1 ; i < n ; i ++ ) { int next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . Max ( res , next_val ) ; } return res ; } public static void Main ( ) { int [ ] arr = { 8 , 3 , 1 , 2 } ; int n = arr . Length ; Console . Write ( maxSum ( arr , n ) ) ; } }
using System ; class LinearSearch { static int countRotations ( int [ ] arr , int n ) { int min = arr [ 0 ] , min_index = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; } public static void Main ( ) { int [ ] arr = { 15 , 18 , 2 , 3 , 6 , 12 } ; int n = arr . Length ; Console . WriteLine ( countRotations ( arr , n ) ) ; } }
using System ; class BinarySearch { static int countRotations ( int [ ] arr , int low , int high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; int mid = low + ( high - low ) / 2 ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; } public static void Main ( ) { int [ ] arr = { 15 , 18 , 2 , 3 , 6 , 12 } ; int n = arr . Length ; Console . WriteLine ( countRotations ( arr , 0 , n - 1 ) ) ; } }
using System ; class LeftRotate { static void preprocess ( int [ ] arr , int n , int [ ] temp ) { for ( int i = 0 ; i < n ; i ++ ) temp [ i ] = temp [ i + n ] = arr [ i ] ; } static void leftRotate ( int [ ] arr , int n , int k , int [ ] temp ) { int start = k % n ; for ( int i = start ; i < start + n ; i ++ ) Console . Write ( temp [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 7 , 9 } ; int n = arr . Length ; int [ ] temp = new int [ 2 * n ] ; preprocess ( arr , n , temp ) ; int k = 2 ; leftRotate ( arr , n , k , temp ) ; k = 3 ; leftRotate ( arr , n , k , temp ) ; k = 4 ; leftRotate ( arr , n , k , temp ) ; } }
using System ; class GFG { static void leftRotate ( int [ ] arr , int n , int k ) { for ( int i = k ; i < k + n ; i ++ ) Console . Write ( arr [ i % n ] + " ▁ " ) ; } static public void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 7 , 9 } ; int n = arr . Length ; int k = 2 ; leftRotate ( arr , n , k ) ; Console . WriteLine ( ) ; k = 3 ; leftRotate ( arr , n , k ) ; Console . WriteLine ( ) ; k = 4 ; leftRotate ( arr , n , k ) ; Console . WriteLine ( ) ; } }
using System ; class GFG { static void reverseArray ( int [ ] arr , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } } static void rightRotate ( int [ ] arr , int d , int n ) { reverseArray ( arr , 0 , n - 1 ) ; reverseArray ( arr , 0 , d - 1 ) ; reverseArray ( arr , d , n - 1 ) ; } static void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = arr . Length ; int k = 3 ; rightRotate ( arr , k , n ) ; printArray ( arr , n ) ; } }
using System ; class GFG { static int maxHamming ( int [ ] arr , int n ) { int [ ] brr = new int [ 2 * n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; int maxHam = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int currHam = 0 ; for ( int j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = Math . Max ( maxHam , currHam ) ; } return maxHam ; } public static void Main ( ) { int [ ] arr = { 2 , 4 , 6 , 8 } ; int n = arr . Length ; Console . Write ( maxHamming ( arr , n ) ) ; } }
using System ; class GFG { static void leftRotate ( int [ ] arr , int n , int k ) { int mod = k % n ; for ( int i = 0 ; i < n ; ++ i ) Console . Write ( arr [ ( i + mod ) % n ] + " ▁ " ) ; Console . WriteLine ( ) ; } static public void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 7 , 9 } ; int n = arr . Length ; int k = 2 ; leftRotate ( arr , n , k ) ; k = 3 ; leftRotate ( arr , n , k ) ; k = 4 ; leftRotate ( arr , n , k ) ; } }
using System ; class GFG { static int findElement ( int [ ] arr , int [ , ] ranges , int rotations , int index ) { for ( int i = rotations - 1 ; i >= 0 ; i -- ) { int left = ranges [ i , 0 ] ; int right = ranges [ i , 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } } return arr [ index ] ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int rotations = 2 ; int [ , ] ranges = { { 0 , 2 } , { 0 , 3 } } ; int index = 1 ; Console . Write ( findElement ( arr , ranges , rotations , index ) ) ; } }
using System ; class GFG { public static void splitArr ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < k ; i ++ ) { int x = arr [ 0 ] ; for ( int j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } } public static void Main ( ) { int [ ] arr = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = arr . Length ; int position = 2 ; splitArr ( arr , 6 , position ) ; for ( int i = 0 ; i < n ; ++ i ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } static void sort_shell_metzner ( int [ ] arr , int n ) { int i , j , k , l , m , temp ; m = n ; while ( m > 0 ) { m /= 2 ; k = n - m ; j = 0 ; do { i = j ; do { l = i + m ; if ( l < n && arr [ i ] > arr [ l ] ) { swap ( arr , i , l ) ; i -= m ; } else { break ; } } while ( i >= 0 ) ; j ++ ; } while ( j <= k ) ; } } static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 0 , - 2 , 8 , 5 , 1 } ; int n = arr . Length ; sort_shell_metzner ( arr , n ) ; printArray ( arr , n ) ; } }
using System ; public class GfG { public static void rearrangeArr ( int [ ] arr , int n ) { int evenPos = n / 2 ; int oddPos = n - evenPos ; int [ ] tempArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; Array . Sort ( tempArr ) ; int j = oddPos - 1 ; for ( int i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( int i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int size = 7 ; rearrangeArr ( arr , size ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int MaxSumDifference ( int [ ] a , int n ) { List < int > finalSequence = new List < int > ( ) ; Array . Sort ( a ) ; for ( int i = 0 ; i < n / 2 ; ++ i ) { finalSequence . Add ( a [ i ] ) ; finalSequence . Add ( a [ n - i - 1 ] ) ; } if ( n % 2 != 0 ) finalSequence . Add ( a [ n / 2 ] ) ; int MaximumSum = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . Abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ; } MaximumSum = MaximumSum + Math . Abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ; return MaximumSum ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 4 , 8 } ; int n = a . Length ; Console . WriteLine ( MaxSumDifference ( a , n ) ) ; } }
using System ; class GFG { static int minSwap ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] <= k ) ++ count ; int bad = 0 ; for ( int i = 0 ; i < count ; ++ i ) if ( arr [ i ] > k ) ++ bad ; int ans = bad ; for ( int i = 0 , j = count ; j < n ; ++ i , ++ j ) { if ( arr [ i ] > k ) -- bad ; if ( arr [ j ] > k ) ++ bad ; ans = Math . Min ( ans , bad ) ; } return ans ; } public static void Main ( ) { int [ ] arr = { 2 , 1 , 5 , 6 , 3 } ; int n = arr . Length ; int k = 3 ; Console . WriteLine ( minSwap ( arr , n , k ) ) ; int [ ] arr1 = { 2 , 7 , 9 , 5 , 8 , 7 , 4 } ; n = arr1 . Length ; k = 5 ; Console . WriteLine ( minSwap ( arr1 , n , k ) ) ; } }
using System ; class GFG { static int maxProductSubarrayOfSizeK ( int [ ] A , int n , int k ) { Array . Sort ( A ) ; int product = 1 ; int i ; if ( A [ n - 1 ] == 0 && k % 2 != 0 ) return 0 ; if ( A [ n - 1 ] <= 0 && k % 2 != 0 ) { for ( i = n - 1 ; i >= n - k ; i -- ) product *= A [ i ] ; return product ; } i = 0 ; int j = n - 1 ; if ( k % 2 != 0 ) { product *= A [ j ] ; j -- ; k -- ; } k >>= 1 ; for ( int itr = 0 ; itr < k ; itr ++ ) { int left_product = A [ i ] * A [ i + 1 ] ; int right_product = A [ j ] * A [ j - 1 ] ; if ( left_product > right_product ) { product *= left_product ; i += 2 ; } else { product *= right_product ; j -= 2 ; } } return product ; } public static void Main ( ) { int [ ] A = { 1 , 2 , - 1 , - 3 , - 6 , 4 } ; int n = A . Length ; int k = 4 ; Console . WriteLine ( maxProductSubarrayOfSizeK ( A , n , k ) ) ; } }
using System ; public class Test { static int [ ] arr = new int [ ] { 50 , 40 , 70 , 60 , 90 } ; static int [ ] index = new int [ ] { 3 , 0 , 4 , 1 , 2 } ; static void reorder ( ) { int [ ] temp = new int [ arr . Length ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } } public static void Main ( ) { reorder ( ) ; Console . WriteLine ( " Reordered ▁ array ▁ is : ▁ " ) ; Console . WriteLine ( string . Join ( " , " , arr ) ) ; Console . WriteLine ( " Modified ▁ Index ▁ array ▁ is : " ) ; Console . WriteLine ( string . Join ( " , " , index ) ) ; } }
using System ; class GFG { static int numofsubset ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; } return count ; } public static void Main ( ) { int [ ] arr = { 100 , 56 , 5 , 6 , 102 , 58 , 101 , 57 , 7 , 103 , 59 } ; int n = arr . Length ; Console . WriteLine ( numofsubset ( arr , n ) ) ; } }
using System ; class GFG { static void gnomeSort ( int [ ] arr , int n ) { int index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { int temp = 0 ; temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } return ; } public static void Main ( ) { int [ ] arr = { 34 , 2 , 10 , - 9 } ; gnomeSort ( arr , arr . Length ) ; Console . Write ( " Sorted ▁ sequence ▁ after ▁ applying ▁ Gnome ▁ sort : ▁ " ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class GFG { static void findMaxGuests ( int [ ] arrl , int [ ] exit , int n ) { Array . Sort ( arrl ) ; Array . Sort ( exit ) ; int guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; int i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } Console . Write ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = ▁ " + max_guests + " ▁ at ▁ time ▁ " + time ) ; } public static void Main ( ) { int [ ] arrl = { 1 , 2 , 10 , 5 , 5 } ; int [ ] exit = { 4 , 5 , 12 , 9 , 12 } ; int n = arrl . Length ; findMaxGuests ( arrl , exit , n ) ; } }
using System ; using System . Linq ; class GFG { public static void maxOverlap ( int [ ] start , int [ ] end , int n ) { int maxa = start . Max ( ) ; int maxb = end . Max ( ) ; int maxc = Math . Max ( maxa , maxb ) ; int [ ] x = new int [ maxc + 2 ] ; int cur = 0 , idx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } int maxy = int . MinValue ; for ( int i = 0 ; i <= maxc ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) { maxy = cur ; idx = i ; } } Console . WriteLine ( " Maximum ▁ value ▁ is ▁ " + maxy + " ▁ at ▁ position : ▁ " + idx + " " ) ; } public static void Main ( ) { int [ ] start = { 13 , 28 , 29 , 14 , 40 , 17 , 3 } ; int [ ] end = { 107 , 95 , 111 , 105 , 70 , 127 , 74 } ; int n = start . Length ; maxOverlap ( start , end , n ) ; } }
using System ; class GFG { static void rearrage ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; int small = 0 , large = n - 1 ; bool flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 } ; Console . WriteLine ( " Original ▁ Array " ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; rearrage ( arr , arr . Length ) ; Console . WriteLine ( " STRNEWLINE Modified ▁ Array " ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class main { public static void rearrange ( int [ ] arr , int n ) { int max_idx = n - 1 , min_idx = 0 ; int max_elem = arr [ n - 1 ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] / max_elem ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . Length ; Console . WriteLine ( " Original ▁ Array " ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; rearrange ( arr , n ) ; Console . WriteLine ( " Modified ▁ Array " ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class GFG { static void rearrange ( int [ ] arr , int n ) { int j = 0 , temp ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; j ++ ; } } } static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 } ; int n = arr . Length ; rearrange ( arr , n ) ; printArray ( arr , n ) ; } }
using System ; class GFG { static void segregateElements ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } public static void Main ( ) { int [ ] arr = { 1 , - 1 , - 3 , - 2 , 7 , 5 , 11 , 6 } ; int n = arr . Length ; segregateElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class GFG { static void rearrange ( int [ ] arr , int n ) { int temp ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && arr [ i ] > arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } if ( i % 2 != 0 && arr [ i ] < arr [ i + 1 ] ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } } } static void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] arr = { 6 , 4 , 2 , 1 , 8 , 3 } ; int n = arr . Length ; Console . WriteLine ( " Before ▁ rearranging : ▁ " ) ; printArray ( arr , n ) ; rearrange ( arr , n ) ; Console . WriteLine ( " After ▁ rearranging : ▁ " ) ; printArray ( arr , n ) ; } }
using System ; class GFG { static void rearrange ( int [ ] a , int size ) { int positive = 0 , negative = 1 , temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , - 3 , 5 , 6 , - 3 , 6 , 7 , - 4 , 9 , 10 } ; int n = arr . Length ; rearrange ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class GFG { static void arrayEvenAndOdd ( int [ ] arr , int n ) { int i = - 1 , j = 0 ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( int k = 0 ; k < n ; k ++ ) Console . Write ( arr [ k ] + " ▁ " ) ; } static void Main ( ) { int [ ] arr = { 1 , 3 , 2 , 4 , 7 , 6 , 9 , 10 } ; int n = arr . Length ; arrayEvenAndOdd ( arr , n ) ; } }
using System ; class GFG { static int [ ] arr = { 10 , 324 , 45 , 90 , 9808 } ; static int largest ( ) { int i ; int max = arr [ 0 ] ; for ( i = 1 ; i < arr . Length ; i ++ ) if ( arr [ i ] > max ) max = arr [ i ] ; return max ; } public static void Main ( ) { Console . WriteLine ( " Largest ▁ in ▁ given ▁ " + " array ▁ is ▁ " + largest ( ) ) ; } }
using System ; using System . Linq ; public class GFG { static int largest ( int [ ] arr , int n ) { return arr . Max ( ) ; } static public void Main ( ) { int [ ] arr = { 10 , 324 , 45 , 90 , 9808 } ; int n = arr . Length ; Console . WriteLine ( largest ( arr , n ) ) ; } }
using System ; class GFG { public static double findMean ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; } public static double findMedian ( int [ ] a , int n ) { Array . Sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } public static void Main ( ) { int [ ] a = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = a . Length ; Console . Write ( " Mean ▁ = ▁ " + findMean ( a , n ) + " STRNEWLINE " ) ; Console . Write ( " Median ▁ = ▁ " + findMedian ( a , n ) + " STRNEWLINE " ) ; } }
using System ; public class GfG { public static void printSmall ( int [ ] arr , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = 10 ; int k = 5 ; printSmall ( arr , n , k ) ; } }
using System ; class GFG { public static void print2largest ( int [ ] arr , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { Console . WriteLine ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } first = second = int . MinValue ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) second = arr [ i ] ; } if ( second == int . MinValue ) Console . Write ( " There ▁ is ▁ no ▁ second ▁ largest " + " ▁ element STRNEWLINE " ) ; else Console . Write ( " The ▁ second ▁ largest ▁ element " + " ▁ is ▁ " + second ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 12 , 35 , 1 , 10 , 34 , 1 } ; int n = arr . Length ; print2largest ( arr , n ) ; } }
using System ; using System . Collections . Generic ; class GFG { static double sumNodes ( int l ) { double leafNodeCount = Math . Pow ( 2 , l - 1 ) ; double sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; double sum = sumLastLevel * l ; return sum ; } public static void Main ( ) { int l = 3 ; Console . Write ( sumNodes ( l ) ) ; } }
using System ; class GFG { static void add ( int [ ] arr , int N , int lo , int hi , int val ) { arr [ lo ] += val ; if ( hi != N - 1 ) arr [ hi + 1 ] -= val ; } static void updateArray ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) arr [ i ] += arr [ i - 1 ] ; } static void printArr ( int [ ] arr , int N ) { updateArray ( arr , N ) ; for ( int i = 0 ; i < N ; i ++ ) Console . Write ( " " + arr [ i ] + " ▁ " ) ; Console . Write ( " STRNEWLINE " ) ; } public static void Main ( ) { int N = 6 ; int [ ] arr = new int [ N ] ; add ( arr , N , 0 , 2 , 100 ) ; add ( arr , N , 1 , 5 , 100 ) ; add ( arr , N , 2 , 3 , 100 ) ; printArr ( arr , N ) ; } }
using System ; class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static void FillPrefixSuffix ( int [ ] prefix , int [ ] arr , int [ ] suffix , int n ) { prefix [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix [ i ] = GCD ( prefix [ i - 1 ] , arr [ i ] ) ; suffix [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) suffix [ i ] = GCD ( suffix [ i + 1 ] , arr [ i ] ) ; } static int GCDoutsideRange ( int l , int r , int [ ] prefix , int [ ] suffix , int n ) { if ( l == 0 ) return suffix [ r + 1 ] ; if ( r == n - 1 ) return prefix [ l - 1 ] ; return GCD ( prefix [ l - 1 ] , suffix [ r + 1 ] ) ; } public static void Main ( ) { int [ ] arr = { 2 , 6 , 9 } ; int n = arr . Length ; int [ ] prefix = new int [ n ] ; int [ ] suffix = new int [ n ] ; FillPrefixSuffix ( prefix , arr , suffix , n ) ; int l = 0 , r = 0 ; Console . WriteLine ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) ; l = 1 ; r = 1 ; Console . WriteLine ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) ; l = 1 ; r = 2 ; Console . Write ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) ; } }
using System ; class GFG { static int countInRange ( int [ ] arr , int n , int x , int y ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 4 , 9 , 10 , 3 } ; int n = arr . Length ; int i = 1 , j = 4 ; Console . WriteLine ( countInRange ( arr , n , i , j ) ) ; i = 9 ; j = 12 ; Console . WriteLine ( countInRange ( arr , n , i , j ) ) ; } }
using System ; class GFG { static int lowerIndex ( int [ ] arr , int n , int x ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; } static int upperIndex ( int [ ] arr , int n , int y ) { int l = 0 , h = n - 1 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; } static int countInRange ( int [ ] arr , int n , int x , int y ) { int count = 0 ; count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; return count ; } public static void Main ( ) { int [ ] arr = { 1 , 4 , 4 , 9 , 10 , 3 } ; int n = arr . Length ; Array . Sort ( arr ) ; int i = 1 , j = 4 ; Console . WriteLine ( countInRange ( arr , n , i , j ) ) ; ; i = 9 ; j = 12 ; Console . WriteLine ( countInRange ( arr , n , i , j ) ) ; } }
using System ; class GFG { static void precompute ( int [ ] arr , int n , int [ ] pre ) { for ( int i = 0 ; i < n ; i ++ ) pre [ i ] = 0 ; pre [ n - 1 ] = arr [ n - 1 ] * ( int ) ( Math . Pow ( 2 , 0 ) ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) pre [ i ] = pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ; } static int decimalOfSubarr ( int [ ] arr , int l , int r , int n , int [ ] pre ) { if ( r != n - 1 ) return ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ; return pre [ l ] / ( 1 << ( n - 1 - r ) ) ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 1 } ; int n = arr . Length ; int [ ] pre = new int [ n ] ; precompute ( arr , n , pre ) ; Console . WriteLine ( decimalOfSubarr ( arr , 2 , 4 , n , pre ) ) ; Console . WriteLine ( decimalOfSubarr ( arr , 4 , 5 , n , pre ) ) ; } }
using System ; class GFG { static int answerQuery ( int [ ] a , int n , int l , int r ) { int count = 0 ; l = l - 1 ; for ( int i = l ; i < r ; i ++ ) { int divisors = 0 ; for ( int j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 3 , 5 } ; int n = a . Length ; int l = 1 , r = 4 ; Console . WriteLine ( answerQuery ( a , n , l , r ) ) ; l = 2 ; r = 4 ; Console . WriteLine ( answerQuery ( a , n , l , r ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int MAX = 2147483647 ; static int [ , ] one = new int [ 100001 , 32 ] ; static void make_prefix ( int [ ] A , int n ) { for ( int j = 0 ; j < 32 ; j ++ ) one [ 0 , j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int a = A [ i - 1 ] ; for ( int j = 0 ; j < 32 ; j ++ ) { int x = ( int ) Math . Pow ( 2 , j ) ; if ( ( a & x ) != 0 ) one [ i , j ] = 1 + one [ i - 1 , j ] ; else one [ i , j ] = one [ i - 1 , j ] ; } } } static int Solve ( int L , int R ) { int l = L , r = R ; int tot_bits = r - l + 1 ; int X = MAX ; for ( int i = 0 ; i < 31 ; i ++ ) { int x = one [ r , i ] - one [ l - 1 , i ] ; if ( x >= tot_bits - x ) { int ith_bit = ( int ) Math . Pow ( 2 , i ) ; X = X ^ ith_bit ; } } return X ; } public static void Main ( ) { int n = 5 , q = 3 ; int [ ] A = { 210 , 11 , 48 , 22 , 133 } ; int [ ] L = { 1 , 4 , 2 } ; int [ ] R = { 3 , 14 , 4 } ; make_prefix ( A , n ) ; for ( int j = 0 ; j < q ; j ++ ) Console . WriteLine ( Solve ( L [ j ] , R [ j ] ) ) ; } }
using System ; class GFG { static int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; for ( int i = 1 ; i <= a ; i ++ ) { ans += b / n ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; } static public void Main ( ) { int a = 5 , b = 13 , n = 3 ; Console . WriteLine ( findCountOfPairs ( a , b , n ) ) ; } }
using System ; class GFG { static int minItems ( int k , int r ) { for ( int i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; } public static void Main ( ) { int k = 15 ; int r = 2 ; Console . WriteLine ( minItems ( k , r ) ) ; } }
using System ; class GFG { static int answer_query ( int [ ] a , int n , int l , int r ) { int count = 0 ; for ( int i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 } ; int n = a . Length ; int L , R ; L = 1 ; R = 8 ; Console . WriteLine ( answer_query ( a , n , L , R ) ) ; L = 0 ; R = 4 ; Console . WriteLine ( answer_query ( a , n , L , R ) ) ; } }
using System ; class GFG { static int N = 1000 ; static int [ ] prefixans = new int [ N ] ; static void countIndex ( int [ ] a , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] == a [ i + 1 ] ) prefixans [ i ] = 1 ; if ( i != 0 ) prefixans [ i ] += prefixans [ i - 1 ] ; } } static int answer_query ( int l , int r ) { if ( l == 0 ) return prefixans [ r - 1 ] ; else return prefixans [ r - 1 ] - prefixans [ l - 1 ] ; } static void Main ( ) { int [ ] a = new int [ ] { 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 } ; int n = a . Length ; countIndex ( a , n ) ; int L , R ; L = 1 ; R = 8 ; Console . WriteLine ( answer_query ( L , R ) ) ; L = 0 ; R = 4 ; Console . WriteLine ( answer_query ( L , R ) ) ; } }
class Solution { static int primeSubarrays ( int [ ] A , int n ) { int max_val = ( int ) ( System . Math . Pow ( 10 , 7 ) ) ; bool [ ] prime = new bool [ max_val + 1 ] ; for ( int p = 0 ; p < max_val + 1 ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { int val = A [ i ] ; for ( int j = i + 1 ; j < n ; ++ j ) { val += A [ j ] ; if ( prime [ val ] ) ++ cnt ; } } return cnt ; } static void Main ( ) { int [ ] A = { 1 , 2 , 3 , 4 , 5 } ; int n = A . Length ; System . Console . WriteLine ( primeSubarrays ( A , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int repeated_digit ( int n ) { var s = new HashSet < int > ( ) ; while ( n != 0 ) { int d = n % 10 ; if ( s . Contains ( d ) ) { return 0 ; } s . Add ( d ) ; n = n / 10 ; } return 1 ; } static int calculate ( int L , int R ) { int answer = 0 ; for ( int i = L ; i < R + 1 ; ++ i ) { answer = answer + repeated_digit ( i ) ; } return answer ; } public static void Main ( String [ ] args ) { int L = 1 , R = 100 ; Console . WriteLine ( calculate ( L , R ) ) ; } }
using System ; public class GFG { public static int countMinSwaps ( string st ) { int min_swaps = 0 ; int odd_0 = 0 , even_0 = 0 ; int odd_1 = 0 , even_1 = 0 ; int n = st . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( st [ i ] == '1' ) { even_1 ++ ; } else { even_0 ++ ; } } else { if ( st [ i ] == '1' ) { odd_1 ++ ; } else { odd_0 ++ ; } } } int cnt_swaps_1 = Math . Min ( even_0 , odd_1 ) ; int cnt_swaps_2 = Math . Min ( even_1 , odd_0 ) ; return Math . Min ( cnt_swaps_1 , cnt_swaps_2 ) ; } public static void Main ( string [ ] args ) { string st = "000111" ; Console . WriteLine ( countMinSwaps ( st ) ) ; } }
using System ; class GFG { static long modpow ( long base1 , long exp , long modulus ) { base1 %= modulus ; long result = 1 ; while ( exp > 0 ) { if ( ( exp & 1 ) > 0 ) result = ( result * base1 ) % modulus ; base1 = ( base1 * base1 ) % modulus ; exp >>= 1 ; } return result ; } public static void Main ( ) { long n = 654654 ; long mod = 971 ; Console . WriteLine ( ( ( modpow ( n , 6 , mod ) + modpow ( n , 2 , mod ) ) % mod + 355 ) % mod ) ; } }
using System ; class GFG { static int maxSubArraySum ( int [ ] a ) { int size = a . Length ; int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } public static void Main ( ) { int [ ] a = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; Console . Write ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + maxSubArraySum ( a ) ) ; } }
static int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = a [ 0 ] , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; else if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; }
using System ; class GFG { static int findMinRooms ( string [ ] slots , int n , int m ) { int [ ] counts = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == '1' ) counts [ j ] ++ ; int max = - 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; } public static void Main ( ) { int n = 3 , m = 7 ; String [ ] slots = { "0101011" , "0011001" , "0110111" } ; Console . Write ( findMinRooms ( slots , n , m ) ) ; } }
using System ; class GFG { static int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . Max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . Max ( max_so_far , curr_max ) ; } return max_so_far ; } public static void Main ( ) { int [ ] a = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = a . Length ; Console . Write ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + maxSubArraySum ( a , n ) ) ; } }
using System ; class GFG { static void maxSubArraySum ( int [ ] a , int size ) { int max_so_far = int . MinValue , max_ending_here = 0 , start = 0 , end = 0 , s = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here += a [ i ] ; if ( max_so_far < max_ending_here ) { max_so_far = max_ending_here ; start = s ; end = i ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; s = i + 1 ; } } Console . WriteLine ( " Maximum ▁ contiguous ▁ " + " sum ▁ is ▁ " + max_so_far ) ; Console . WriteLine ( " Starting ▁ index ▁ " + start ) ; Console . WriteLine ( " Ending ▁ index ▁ " + end ) ; } public static void Main ( ) { int [ ] a = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = a . Length ; maxSubArraySum ( a , n ) ; } }
using System ; public class GfG { public static void countCurrency ( int amount ) { int [ ] notes = new int [ ] { 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 } ; int [ ] noteCounter = new int [ 9 ] ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = amount / notes [ i ] ; amount = amount - noteCounter [ i ] * notes [ i ] ; } } Console . WriteLine ( " Currency ▁ Count ▁ - > " ) ; for ( int i = 0 ; i < 9 ; i ++ ) { if ( noteCounter [ i ] != 0 ) { Console . WriteLine ( notes [ i ] + " ▁ : ▁ " + noteCounter [ i ] ) ; } } } public static void Main ( ) { int amount = 868 ; countCurrency ( amount ) ; } }
using System ; using System . Linq ; public class GFG { static int minSum ( int [ ] A , int n ) { int min_val = A . Min ( ) ; return ( min_val * ( n - 1 ) ) ; } static public void Main ( ) { int [ ] A = { 3 , 6 , 2 , 8 , 7 , 5 } ; int n = A . Length ; Console . WriteLine ( minSum ( A , n ) ) ; } }
using System ; using System . Linq ; public class GFG { static void NextFit ( int [ ] blockSize , int m , int [ ] processSize , int n ) { int [ ] allocation = new int [ n ] ; int j = 0 ; Enumerable . Repeat ( - 1 , n ) . ToArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } j = ( j + 1 ) % m ; } } Console . Write ( " STRNEWLINE Process ▁ No . TABSYMBOL Process ▁ Size TABSYMBOL Block ▁ no . STRNEWLINE " ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( i + 1 + " TABSYMBOL TABSYMBOL " + processSize [ i ] + " TABSYMBOL TABSYMBOL " ) ; if ( allocation [ i ] != - 1 ) { Console . Write ( allocation [ i ] + 1 ) ; } else { Console . Write ( " Not ▁ Allocated " ) ; } Console . WriteLine ( " " ) ; } } static public void Main ( ) { int [ ] blockSize = { 5 , 10 , 20 } ; int [ ] processSize = { 10 , 20 , 5 } ; int m = blockSize . Length ; int n = processSize . Length ; NextFit ( blockSize , m , processSize , n ) ; } }
using System ; class Test { static int [ ] arr = new int [ ] { 3 , 7 , 90 , 20 , 10 , 50 , 40 } ; static void findMinAvgSubarray ( int n , int k ) { if ( n < k ) return ; int res_index = 0 ; int curr_sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; int min_sum = curr_sum ; for ( int i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } Console . Write ( " Subarray ▁ between ▁ [ " + res_index + " , ▁ " + ( res_index + k - 1 ) + " ] ▁ has ▁ minimum ▁ average " ) ; } public static void Main ( ) { int k = 3 ; findMinAvgSubarray ( arr . Length , k ) ; } }
using System ; class GFG { static int [ ] seg = new int [ 10 ] { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 } ; static int computeSegment ( int x ) { if ( x == 0 ) return seg [ 0 ] ; int count = 0 ; while ( x > 0 ) { count += seg [ x % 10 ] ; x /= 10 ; } return count ; } static int elementMinSegment ( int [ ] arr , int n ) { int minseg = computeSegment ( arr [ 0 ] ) ; int minindex = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int temp = computeSegment ( arr [ i ] ) ; if ( temp < minseg ) { minseg = temp ; minindex = i ; } } return arr [ minindex ] ; } static public void Main ( ) { int [ ] arr = { 489 , 206 , 745 , 123 , 756 } ; int n = arr . Length ; Console . WriteLine ( elementMinSegment ( arr , n ) ) ; } }
using System ; class GFG { static void findLargest ( int m , int s ) { if ( s == 0 ) { Console . Write ( m == 1 ? " Largest ▁ number ▁ is ▁ 0" : " Not ▁ possible " ) ; return ; } if ( s > 9 * m ) { Console . WriteLine ( " Not ▁ possible " ) ; return ; } int [ ] res = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { if ( s >= 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } Console . Write ( " Largest ▁ number ▁ is ▁ " ) ; for ( int i = 0 ; i < m ; i ++ ) Console . Write ( res [ i ] ) ; } static public void Main ( ) { int s = 9 , m = 2 ; findLargest ( m , s ) ; } }
using System ; class GFG { static int minJumps ( int [ ] arr , int l , int h ) { if ( h == l ) return 0 ; if ( arr [ l ] == 0 ) return int . MaxValue ; int min = int . MaxValue ; for ( int i = l + 1 ; i <= h && i <= l + arr [ l ] ; i ++ ) { int jumps = minJumps ( arr , i , h ) ; if ( jumps != int . MaxValue && jumps + 1 < min ) min = jumps + 1 ; } return min ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 } ; int n = arr . Length ; Console . Write ( " Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ▁ end ▁ is ▁ " + minJumps ( arr , 0 , n - 1 ) ) ; } }
using System ; class GFG { public static int minJumps ( int [ ] arr , int n ) { int [ ] jumps = new int [ n ] ; int min ; jumps [ n - 1 ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) { jumps [ i ] = int . MaxValue ; } else if ( arr [ i ] >= n - i - 1 ) { jumps [ i ] = 1 ; } else { min = int . MaxValue ; for ( int j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) { min = jumps [ j ] ; } } if ( min != int . MaxValue ) { jumps [ i ] = min + 1 ; } else { jumps [ i ] = min ; } } } return jumps [ 0 ] ; } public static void Main ( string [ ] args ) { int [ ] arr = new int [ ] { 1 , 3 , 6 , 1 , 0 , 9 } ; int size = arr . Length ; Console . WriteLine ( " Minimum ▁ number ▁ of " + " ▁ jumps ▁ to ▁ reach ▁ end ▁ is ▁ " + minJumps ( arr , size ) ) ; } }
using System ; class GFG { static int smallestSubWithSum ( int [ ] arr , int n , int x ) { int min_len = n + 1 ; for ( int start = 0 ; start < n ; start ++ ) { int curr_sum = arr [ start ] ; if ( curr_sum > x ) return 1 ; for ( int end = start + 1 ; end < n ; end ++ ) { curr_sum += arr [ end ] ; if ( curr_sum > x && ( end - start + 1 ) < min_len ) min_len = ( end - start + 1 ) ; } } return min_len ; } static public void Main ( ) { int [ ] arr1 = { 1 , 4 , 45 , 6 , 10 , 19 } ; int x = 51 ; int n1 = arr1 . Length ; int res1 = smallestSubWithSum ( arr1 , n1 , x ) ; if ( res1 == n1 + 1 ) Console . WriteLine ( " Not ▁ Possible " ) ; else Console . WriteLine ( res1 ) ; int [ ] arr2 = { 1 , 10 , 5 , 2 , 7 } ; int n2 = arr2 . Length ; x = 9 ; int res2 = smallestSubWithSum ( arr2 , n2 , x ) ; if ( res2 == n2 + 1 ) Console . WriteLine ( " Not ▁ Possible " ) ; else Console . WriteLine ( res2 ) ; int [ ] arr3 = { 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 } ; int n3 = arr3 . Length ; x = 280 ; int res3 = smallestSubWithSum ( arr3 , n3 , x ) ; if ( res3 == n3 + 1 ) Console . WriteLine ( " Not ▁ Possible " ) ; else Console . WriteLine ( res3 ) ; } }
using System ; class GFG { static int smallestSubWithSum ( int [ ] arr , int n , int x ) { int curr_sum = 0 , min_len = n + 1 ; int start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; } static public void Main ( ) { int [ ] arr1 = { 1 , 4 , 45 , 6 , 10 , 19 } ; int x = 51 ; int n1 = arr1 . Length ; int res1 = smallestSubWithSum ( arr1 , n1 , x ) ; if ( res1 == n1 + 1 ) Console . WriteLine ( " Not ▁ Possible " ) ; else Console . WriteLine ( res1 ) ; int [ ] arr2 = { 1 , 10 , 5 , 2 , 7 } ; int n2 = arr2 . Length ; x = 9 ; int res2 = smallestSubWithSum ( arr2 , n2 , x ) ; if ( res2 == n2 + 1 ) Console . WriteLine ( " Not ▁ Possible " ) ; else Console . WriteLine ( res2 ) ; int [ ] arr3 = { 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 } ; int n3 = arr3 . Length ; x = 280 ; int res3 = smallestSubWithSum ( arr3 , n3 , x ) ; if ( res3 == n3 + 1 ) Console . WriteLine ( " Not ▁ Possible " ) ; else Console . WriteLine ( res3 ) ; } }
using System ; class GFG { static int [ ] arr = new int [ ] { 16 , 16 , 16 } ; static int countMinOperations ( int n ) { int result = 0 ; while ( true ) { int zero_count = 0 ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) break ; else if ( arr [ i ] == 0 ) zero_count ++ ; } if ( zero_count == n ) return result ; if ( i == n ) { for ( int j = 0 ; j < n ; j ++ ) arr [ j ] = arr [ j ] / 2 ; result ++ ; } for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] % 2 == 1 ) { arr [ j ] -- ; result ++ ; } } } } public static void Main ( ) { Console . Write ( " Minimum ▁ number ▁ of ▁ steps ▁ required ▁ to ▁ STRNEWLINE " + " get ▁ the ▁ given ▁ target ▁ array ▁ is ▁ " + countMinOperations ( arr . Length ) ) ; } }
using System ; class GFG { static int findMinOps ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 , j = n - 1 ; i <= j ; ) { if ( arr [ i ] == arr [ j ] ) { i ++ ; j -- ; } else if ( arr [ i ] > arr [ j ] ) { j -- ; arr [ j ] += arr [ j + 1 ] ; ans ++ ; } else { i ++ ; arr [ i ] += arr [ i - 1 ] ; ans ++ ; } } return ans ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 4 , 5 , 9 , 1 } ; Console . Write ( " Count ▁ of ▁ minimum ▁ operations ▁ is ▁ " + findMinOps ( arr , arr . Length ) ) ; } }
using System ; class GFG { static int findSmallest ( int [ ] arr , int n ) { int res = 1 ; for ( int i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; } public static void Main ( ) { int [ ] arr1 = { 1 , 3 , 4 , 5 } ; int n1 = arr1 . Length ; Console . WriteLine ( findSmallest ( arr1 , n1 ) ) ; int [ ] arr2 = { 1 , 2 , 6 , 10 , 11 , 15 } ; int n2 = arr2 . Length ; Console . WriteLine ( findSmallest ( arr2 , n2 ) ) ; int [ ] arr3 = { 1 , 1 , 1 , 1 } ; int n3 = arr3 . Length ; Console . WriteLine ( findSmallest ( arr3 , n3 ) ) ; int [ ] arr4 = { 1 , 1 , 3 , 4 } ; int n4 = arr4 . Length ; Console . WriteLine ( findSmallest ( arr4 , n4 ) ) ; } }
using System ; class GFG { static int findMinDiff ( int [ ] arr , int n ) { int diff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . Abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 5 , 3 , 19 , 18 , 25 } ; Console . Write ( " Minimum ▁ difference ▁ is ▁ " + findMinDiff ( arr , arr . Length ) ) ; } }
using System ; class GFG { static int findMinDiff ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int diff = int . MaxValue ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 5 , 3 , 19 , 18 , 25 } ; Console . WriteLine ( " Minimum ▁ difference ▁ is ▁ " + findMinDiff ( arr , arr . Length ) ) ; } }
using System ; class GFG { static public void Main ( ) { int a = 2 , b = 10 ; int size = Math . Abs ( b - a ) + 1 ; int [ ] array = new int [ size ] ; for ( int i = a ; i <= b ; i ++ ) if ( i % 2 == 0 i % 5 == 0 ) array [ i - a ] = 1 ; Console . WriteLine ( " MULTIPLES ▁ of ▁ 2" + " ▁ and ▁ 5 : " ) ; for ( int i = a ; i <= b ; i ++ ) if ( array [ i - a ] == 1 ) Console . Write ( i + " ▁ " ) ; } }
using System ; class GFG { static int [ ] arr1 = new int [ ] { 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; static int [ ] arr2 = new int [ ] { 1 , 1 , 1 , 1 , 1 , 0 , 1 } ; static int longestCommonSum ( int n ) { int maxLen = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int sum1 = 0 , sum2 = 0 ; for ( int j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { int len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; } public static void Main ( ) { Console . Write ( " Length ▁ of ▁ the ▁ longest ▁ " + " common ▁ span ▁ with ▁ same ▁ sum ▁ is ▁ " ) ; Console . Write ( longestCommonSum ( arr1 . Length ) ) ; } }
using System ; class GFG { public virtual void moveToEnd ( int [ ] mPlusN , int size ) { int i , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) { if ( mPlusN [ i ] != - 1 ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } } public virtual void merge ( int [ ] mPlusN , int [ ] N , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( j == n ) ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } } public virtual void printArray ( int [ ] arr , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } Console . WriteLine ( " " ) ; } public static void Main ( string [ ] args ) { GFG mergearray = new GFG ( ) ; int [ ] mPlusN = new int [ ] { 2 , 8 , - 1 , - 1 , - 1 , 13 , - 1 , 15 , 20 } ; int [ ] N = new int [ ] { 5 , 7 , 9 , 25 } ; int n = N . Length ; int m = mPlusN . Length - n ; mergearray . moveToEnd ( mPlusN , m + n ) ; mergearray . merge ( mPlusN , N , m , n ) ; mergearray . printArray ( mPlusN , m + n ) ; } }
using System ; class GFG { static bool sortedAfterSwap ( int [ ] A , bool [ ] B , int n ) { int i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } Array . Sort ( A , i , 1 + j ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; } public static void Main ( ) { int [ ] A = { 1 , 2 , 5 , 3 , 4 , 6 } ; bool [ ] B = { false , true , true , true , false } ; int n = A . Length ; if ( sortedAfterSwap ( A , B , n ) ) { Console . WriteLine ( " A ▁ can ▁ be ▁ sorted " ) ; } else { Console . WriteLine ( " A ▁ can ▁ not ▁ be ▁ sorted " ) ; } } }
using System ; class GFG { static int sortedAfterSwap ( int [ ] A , int [ ] B , int n ) { int t = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; } public static void Main ( ) { int [ ] A = { 1 , 2 , 5 , 3 , 4 , 6 } ; int [ ] B = { 0 , 1 , 1 , 1 , 0 } ; int n = A . Length ; if ( sortedAfterSwap ( A , B , n ) == 0 ) Console . WriteLine ( " A ▁ can ▁ be ▁ sorted " ) ; else Console . WriteLine ( " A ▁ can ▁ not ▁ be ▁ sorted " ) ; } }
using System ; class GFG { static void segregate0and1 ( int [ ] arr , int n ) { int type0 = 0 ; int type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } } public static void Main ( ) { int [ ] arr = { 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 } ; segregate0and1 ( arr , arr . Length ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int [ ] arr = new int [ ] { 1 , 20 , 6 , 4 , 5 } ; static int getInvCount ( int n ) { int inv_count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) inv_count ++ ; return inv_count ; } public static void Main ( ) { Console . WriteLine ( " Number ▁ of ▁ " + " inversions ▁ are ▁ " + getInvCount ( arr . Length ) ) ; } }
using System ; class GFG { static void minAbsSumPair ( int [ ] arr , int arr_size ) { int l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { Console . Write ( " Invalid ▁ Input " ) ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( Math . Abs ( min_sum ) > Math . Abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } Console . Write ( " ▁ The ▁ two ▁ elements ▁ whose ▁ " + " sum ▁ is ▁ minimum ▁ are ▁ " + arr [ min_l ] + " ▁ and ▁ " + arr [ min_r ] ) ; } public static void Main ( ) { int [ ] arr = { 1 , 60 , - 10 , 70 , - 80 , 85 } ; minAbsSumPair ( arr , 6 ) ; } }
using System ; class GFG { public static bool increasing ( int [ ] a , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] >= a [ i + 1 ] ) return false ; return true ; } public static bool decreasing ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] < arr [ i + 1 ] ) return false ; return true ; } public static int shortestUnsorted ( int [ ] a , int n ) { if ( increasing ( a , n ) == true || decreasing ( a , n ) == true ) return 0 ; else return 3 ; } public static void Main ( ) { int [ ] ar = new int [ ] { 7 , 9 , 10 , 8 , 11 } ; int n = ar . Length ; Console . WriteLine ( shortestUnsorted ( ar , n ) ) ; } }
using System ; class GFG { static int printUnion ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) Console . Write ( arr1 [ i ++ ] + " ▁ " ) ; else if ( arr2 [ j ] < arr1 [ i ] ) Console . Write ( arr2 [ j ++ ] + " ▁ " ) ; else { Console . Write ( arr2 [ j ++ ] + " ▁ " ) ; i ++ ; } } while ( i < m ) Console . Write ( arr1 [ i ++ ] + " ▁ " ) ; while ( j < n ) Console . Write ( arr2 [ j ++ ] + " ▁ " ) ; return 0 ; } public static void Main ( ) { int [ ] arr1 = { 1 , 2 , 4 , 5 , 6 } ; int [ ] arr2 = { 2 , 3 , 5 , 7 } ; int m = arr1 . Length ; int n = arr2 . Length ; printUnion ( arr1 , arr2 , m , n ) ; } }
using System ; class GFG { static void printIntersection ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) i ++ ; else if ( arr2 [ j ] < arr1 [ i ] ) j ++ ; else { Console . Write ( arr2 [ j ++ ] + " ▁ " ) ; i ++ ; } } } public static void Main ( ) { int [ ] arr1 = { 1 , 2 , 4 , 5 , 6 } ; int [ ] arr2 = { 2 , 3 , 5 , 7 } ; int m = arr1 . Length ; int n = arr2 . Length ; printIntersection ( arr1 , arr2 , m , n ) ; } }
using System ; class GFG { static void printUnion ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { if ( m > n ) { int [ ] tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } Array . Sort ( arr1 ) ; for ( int i = 0 ; i < m ; i ++ ) Console . Write ( arr1 [ i ] + " ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == - 1 ) Console . Write ( arr2 [ i ] + " ▁ " ) ; } } static void printIntersection ( int [ ] arr1 , int [ ] arr2 , int m , int n ) { if ( m > n ) { int [ ] tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; int temp = m ; m = n ; n = temp ; } Array . Sort ( arr1 ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != - 1 ) Console . Write ( arr2 [ i ] + " ▁ " ) ; } } static int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } static public void Main ( ) { int [ ] arr1 = { 7 , 1 , 5 , 2 , 3 , 6 } ; int [ ] arr2 = { 3 , 8 , 6 , 20 , 7 } ; int m = arr1 . Length ; int n = arr2 . Length ; Console . WriteLine ( " Union ▁ of ▁ two ▁ arrays ▁ is ▁ " ) ; printUnion ( arr1 , arr2 , m , n ) ; Console . WriteLine ( " " ) ; Console . WriteLine ( " Intersection ▁ of ▁ two ▁ arrays ▁ is ▁ " ) ; printIntersection ( arr1 , arr2 , m , n ) ; } }
using System ; class GFG { static void intersection ( int [ ] a , int [ ] b , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) { j ++ ; } else if ( b [ j ] > a [ i ] ) { i ++ ; } else { Console . Write ( a [ i ] + " ▁ " ) ; i ++ ; j ++ ; } } } public static void Main ( ) { int [ ] a = { 1 , 3 , 2 , 3 , 4 , 5 , 5 , 6 } ; int [ ] b = { 3 , 3 , 5 } ; int n = a . Length ; int m = b . Length ; Array . Sort ( a ) ; Array . Sort ( b ) ; intersection ( a , b , n , m ) ; } }
using System ; class GFG { static void sort012 ( int [ ] a , int arr_size ) { int lo = 0 ; int hi = arr_size - 1 ; int mid = 0 , temp = 0 ; while ( mid <= hi ) { switch ( a [ mid ] ) { case 0 : { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; break ; } case 1 : mid ++ ; break ; case 2 : { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; break ; } } } } static void printArray ( int [ ] arr , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( " " ) ; } public static void Main ( ) { int [ ] arr = { 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 } ; int arr_size = arr . Length ; sort012 ( arr , arr_size ) ; Console . Write ( " Array ▁ after ▁ seggregation ▁ " ) ; printArray ( arr , arr_size ) ; } }
using System ; class GFG { static void printUnsorted ( int [ ] arr , int n ) { int s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { Console . Write ( " The ▁ complete ▁ " + " array ▁ is ▁ sorted " ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } Console . Write ( " ▁ The ▁ unsorted ▁ subarray ▁ which " + " ▁ makes ▁ the ▁ given ▁ array ▁ sorted ▁ lies ▁ STRNEWLINE " + " ▁ between ▁ the ▁ indices ▁ " + s + " ▁ and ▁ " + e ) ; return ; } public static void Main ( ) { int [ ] arr = { 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 } ; int arr_size = arr . Length ; printUnsorted ( arr , arr_size ) ; } }
using System ; class GFG { static int findNumberOfTriangles ( int [ ] arr ) { int n = arr . Length ; Array . Sort ( arr ) ; int count = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { int k = i + 2 ; for ( int j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; } public static void Main ( ) { int [ ] arr = { 10 , 21 , 22 , 100 , 101 , 200 , 300 } ; Console . WriteLine ( " Total ▁ number ▁ of ▁ triangles ▁ is ▁ " + findNumberOfTriangles ( arr ) ) ; } }
using System ; class GFG { static int countPairsWithDiffK ( int [ ] arr , int n , int k ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; } public static void Main ( ) { int [ ] arr = { 1 , 5 , 3 , 4 , 2 } ; int n = arr . Length ; int k = 3 ; Console . WriteLine ( " Count ▁ of ▁ pairs ▁ with ▁ " + " ▁ given ▁ diff ▁ is ▁ " + countPairsWithDiffK ( arr , n , k ) ) ; } }
using System ; class GFG { static int binarySearch ( int [ ] arr , int low , int high , int x ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( x == arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; } static int countPairsWithDiffK ( int [ ] arr , int n , int k ) { int count = 0 , i ; Array . Sort ( arr ) ; / * remove duplicates from arr [ ] for ( i = 0 ; i < n - 1 ; i ++ ) if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != - 1 ) count ++ ; return count ; } public static void Main ( ) { int [ ] arr = { 1 , 5 , 3 , 4 , 2 } ; int n = arr . Length ; int k = 3 ; Console . WriteLine ( " Count ▁ of ▁ pairs ▁ with " + " ▁ given ▁ diff ▁ is ▁ " + countPairsWithDiffK ( arr , n , k ) ) ; } }
using System ; class GFG { static int countPairsWithDiffK ( int [ ] arr , int n , int k ) { int count = 0 ; Array . Sort ( arr ) ; int l = 0 ; int r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; } public static void Main ( ) { int [ ] arr = { 1 , 5 , 3 , 4 , 2 } ; int n = arr . Length ; int k = 3 ; Console . Write ( " Count ▁ of ▁ pairs ▁ with ▁ " + " given ▁ diff ▁ is ▁ " + countPairsWithDiffK ( arr , n , k ) ) ; } }
using System ; class PairSum { static void constructArr ( int [ ] arr , int [ ] pair , int n ) { arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ; for ( int i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; } public static void Main ( ) { int [ ] pair = { 15 , 13 , 11 , 10 , 12 , 10 , 9 , 8 , 7 , 5 } ; int n = 5 ; int [ ] arr = new int [ n ] ; constructArr ( arr , pair , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; public class Test { static int [ ] arr1 = new int [ ] { 1 , 5 , 9 , 10 , 15 , 20 } ; static int [ ] arr2 = new int [ ] { 2 , 3 , 8 , 13 } ; static void merge ( int m , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } } public static void Main ( ) { merge ( arr1 . Length , arr2 . Length ) ; Console . Write ( " After ▁ Merging ▁ STRNEWLINE First ▁ Array : ▁ " ) ; for ( int i = 0 ; i < arr1 . Length ; i ++ ) { Console . Write ( arr1 [ i ] + " ▁ " ) ; } Console . Write ( " STRNEWLINE Second ▁ Array : ▁ " ) ; for ( int i = 0 ; i < arr2 . Length ; i ++ ) { Console . Write ( arr2 [ i ] + " ▁ " ) ; } } }
using System ; class GFG { static void gouldSequence ( int n ) { for ( int row_num = 1 ; row_num <= n ; row_num ++ ) { int count = 1 ; int c = 1 ; for ( int i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } Console . Write ( count + " ▁ " ) ; } } public static void Main ( ) { int n = 16 ; gouldSequence ( n ) ; } }
using System ; class GfG { public static int minMaxProduct ( int [ ] arr1 , int [ ] arr2 , int n1 , int n2 ) { Array . Sort ( arr1 ) ; Array . Sort ( arr2 ) ; return arr1 [ n1 - 1 ] * arr2 [ 0 ] ; } public static void Main ( ) { int [ ] arr1 = new int [ ] { 10 , 2 , 3 , 6 , 4 , 1 } ; int [ ] arr2 = new int [ ] { 5 , 1 , 4 , 2 , 6 , 9 } ; int n1 = 6 ; int n2 = 6 ; Console . WriteLine ( minMaxProduct ( arr1 , arr2 , n1 , n2 ) ) ; } }
using System ; public class GFG { public static int M = 100 ; public static int N = 100 ; static int find_min_odd_cost ( int [ , ] given , int m , int n ) { int [ , ] floor = new int [ M , N ] ; int min_odd_cost = 0 ; int i , j , temp ; for ( j = 0 ; j < n ; j ++ ) floor [ 0 , j ] = given [ 0 , j ] ; for ( i = 1 ; i < m ; i ++ ) for ( j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { floor [ i , j ] = given [ i , j ] ; floor [ i , j ] += Math . Min ( floor [ i - 1 , j ] , floor [ i - 1 , j + 1 ] ) ; } else if ( j == n - 1 ) { floor [ i , j ] = given [ i , j ] ; floor [ i , j ] += Math . Min ( floor [ i - 1 , j ] , floor [ i - 1 , j - 1 ] ) ; } else { temp = Math . Min ( floor [ i - 1 , j ] , floor [ i - 1 , j - 1 ] ) ; temp = Math . Min ( temp , floor [ i - 1 , j + 1 ] ) ; floor [ i , j ] = given [ i , j ] + temp ; } } min_odd_cost = int . MaxValue ; for ( j = 0 ; j < n ; j ++ ) { if ( floor [ n - 1 , j ] % 2 == 1 ) { if ( min_odd_cost > floor [ n - 1 , j ] ) min_odd_cost = floor [ n - 1 , j ] ; } } if ( min_odd_cost == int . MinValue ) return - 1 ; return min_odd_cost ; } public static void Main ( ) { int m = 5 , n = 5 ; int [ , ] given = { { 1 , 2 , 3 , 4 , 6 } , { 1 , 2 , 3 , 4 , 5 } , { 1 , 2 , 3 , 4 , 5 } , { 1 , 2 , 3 , 4 , 5 } , { 100 , 2 , 3 , 4 , 5 } } ; Console . Write ( " Minimum ▁ odd ▁ cost ▁ is ▁ " + find_min_odd_cost ( given , m , n ) ) ; } }
using System ; class GfG { public static int minMaxProduct ( int [ ] arr1 , int [ ] arr2 , int n1 , int n2 ) { int max = arr1 [ 0 ] ; int min = arr2 [ 0 ] ; int i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; } public static void Main ( ) { int [ ] arr1 = new int [ ] { 10 , 2 , 3 , 6 , 4 , 1 } ; int [ ] arr2 = new int [ ] { 5 , 1 , 4 , 2 , 6 , 9 } ; int n1 = 6 ; int n2 = 6 ; Console . WriteLine ( minMaxProduct ( arr1 , arr2 , n1 , n2 ) ) ; } }
using System ; class main { static int findElement ( int [ ] arr , int n , int key ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } public static void Main ( ) { int [ ] arr = { 12 , 34 , 10 , 6 , 40 } ; int n = arr . Length ; int key = 40 ; int position = findElement ( arr , n , key ) ; if ( position == - 1 ) Console . WriteLine ( " Element ▁ not ▁ found " ) ; else Console . WriteLine ( " Element ▁ Found ▁ at ▁ Position : ▁ " + ( position + 1 ) ) ; } }
using System ; class main { static int insertSorted ( int [ ] arr , int n , int key , int capacity ) { if ( n >= capacity ) return n ; arr [ n ] = key ; return ( n + 1 ) ; } public static void Main ( ) { int [ ] arr = new int [ 20 ] ; arr [ 0 ] = 12 ; arr [ 1 ] = 16 ; arr [ 2 ] = 20 ; arr [ 3 ] = 40 ; arr [ 4 ] = 50 ; arr [ 5 ] = 70 ; int capacity = 20 ; int n = 6 ; int i , key = 26 ; Console . Write ( " Before ▁ Insertion : ▁ " ) ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; n = insertSorted ( arr , n , key , capacity ) ; Console . Write ( " After ▁ Insertion : ▁ " ) ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class main { static int findElement ( int [ ] arr , int n , int key ) { int i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } static int deleteElement ( int [ ] arr , int n , int key ) { int pos = findElement ( arr , n , key ) ; if ( pos == - 1 ) { Console . WriteLine ( " Element ▁ not ▁ found " ) ; return n ; } int i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; } public static void Main ( ) { int i ; int [ ] arr = { 10 , 50 , 30 , 40 , 20 } ; int n = arr . Length ; int key = 30 ; Console . Write ( " Array ▁ before ▁ deletion ▁ " ) ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; n = deleteElement ( arr , n , key ) ; Console . Write ( " Array ▁ after ▁ deletion ▁ " ) ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; public class GFG { public static int binarySearch ( int [ ] arr , int low , int high , int key ) { if ( high < low ) { return - 1 ; } int mid = ( low + high ) / 2 ; if ( key == arr [ mid ] ) { return mid ; } if ( key > arr [ mid ] ) { return binarySearch ( arr , ( mid + 1 ) , high , key ) ; } return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } public static void Main ( string [ ] args ) { int [ ] arr = new int [ ] { 5 , 6 , 7 , 8 , 9 , 10 } ; int n , key ; n = arr . Length ; key = 10 ; Console . WriteLine ( " Index : ▁ " + binarySearch ( arr , 0 , n - 1 , key ) ) ; } }
using System ; class GFG { static int findSDSFunc ( int n ) { int [ ] DP = new int [ n + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; } static public void Main ( ) { int n = 15 ; Console . WriteLine ( findSDSFunc ( n ) ) ; } }
using System ; class GFG { static void findCommon ( int [ ] ar1 , int [ ] ar2 , int [ ] ar3 ) { int i = 0 , j = 0 , k = 0 ; while ( i < ar1 . Length && j < ar2 . Length && k < ar3 . Length ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { Console . Write ( ar1 [ i ] + " ▁ " ) ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } } public static void Main ( ) { int [ ] ar1 = { 1 , 5 , 10 , 20 , 40 , 80 } ; int [ ] ar2 = { 6 , 7 , 20 , 80 , 100 } ; int [ ] ar3 = { 3 , 4 , 15 , 20 , 30 , 70 , 80 , 120 } ; Console . Write ( " Common ▁ elements ▁ are ▁ " ) ; findCommon ( ar1 , ar2 , ar3 ) ; } }
using System ; public class GfG { public static int Jacobsthal ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; } public static int Jacobsthal_Lucas ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 2 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( " Jacobsthal ▁ number : ▁ " + Jacobsthal ( n ) ) ; Console . WriteLine ( " Jacobsthal - Lucas ▁ number : ▁ " + Jacobsthal_Lucas ( n ) ) ; } }
using System ; class GFG { static int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } static int findPos ( int [ ] arr , int key ) { int l = 0 , h = 1 ; int val = arr [ 0 ] ; while ( val < key ) { l = h ; h = 2 * h ; val = arr [ h ] ; } return binarySearch ( arr , l , h , key ) ; } public static void Main ( ) { int [ ] arr = new int [ ] { 3 , 5 , 7 , 9 , 10 , 90 , 100 , 130 , 140 , 160 , 170 } ; int ans = findPos ( arr , 10 ) ; if ( ans == - 1 ) Console . Write ( " Element ▁ not ▁ found " ) ; else Console . Write ( " Element ▁ found ▁ at ▁ " + " index ▁ " + ans ) ; } }
using System ; class GFG { static long answer ( int n ) { int [ , ] dp = new int [ n + 1 , 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ 1 , j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i , j ] = dp [ i - 1 , j + 1 ] ; else if ( j == 9 ) dp [ i , j ] = dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = dp [ i - 1 , j - 1 ] + dp [ i - 1 , j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ n , j ] ; return sum ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( answer ( n ) ) ; } }
using System ; class GFG { static int findSingle ( int [ ] ar , int ar_size ) { int res = ar [ 0 ] ; for ( int i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; } public static void Main ( ) { int [ ] ar = { 2 , 3 , 5 , 4 , 5 , 3 , 4 } ; int n = ar . Length ; Console . Write ( " Element ▁ occurring ▁ once ▁ is ▁ " + findSingle ( ar , n ) + " ▁ " ) ; } }
using System ; class GFG { public static int [ , ] dp ; public static void computeDpArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 1 ; j <= 15000 ; ++ j ) { if ( i == 0 && j == arr [ i ] ) dp [ i , j ] = 1 ; else if ( i == 0 ) dp [ i , j ] = 0 ; else if ( arr [ i ] == j ) dp [ i , j ] = dp [ i - 1 , j ] + 1 ; else dp [ i , j ] = dp [ i - 1 , j ] ; } } } public static int countTripletSum ( int [ ] arr , int n ) { computeDpArray ( arr , n ) ; int ans = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { for ( int j = i + 1 ; j < n - 1 ; ++ j ) { for ( int k = 1 ; k <= 24 ; ++ k ) { int cube = k * k * k ; int rem = cube - ( arr [ i ] + arr [ j ] ) ; if ( rem > 0 ) ans += dp [ n - 1 , rem ] - dp [ j , rem ] ; } } } return ans ; } public static void Main ( ) { int [ ] arr = { 2 , 5 , 1 , 20 , 6 } ; int n = arr . Length ; dp = new int [ 1001 , 15001 ] ; Console . Write ( countTripletSum ( arr , n ) ) ; } }
using System ; class GFG { static bool isPresent ( int [ ] B , int m , int x ) { for ( int i = 0 ; i < m ; i ++ ) if ( B [ i ] == x ) return true ; return false ; } static int findMaxSubarraySumUtil ( int [ ] A , int [ ] B , int n , int m ) { int max_so_far = - 2147483648 , curr_max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPresent ( B , m , A [ i ] ) ) { curr_max = 0 ; continue ; } curr_max = Math . Max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = Math . Max ( max_so_far , curr_max ) ; } return max_so_far ; } static void findMaxSubarraySum ( int [ ] A , int [ ] B , int n , int m ) { int maxSubarraySum = findMaxSubarraySumUtil ( A , B , n , m ) ; if ( maxSubarraySum == - 2147483648 ) { Console . Write ( " Maximum ▁ Subarray ▁ Sum " + " ▁ " + " can ' t ▁ be ▁ found " ) ; } else { Console . Write ( " The ▁ Maximum ▁ Subarray ▁ Sum ▁ = ▁ " + maxSubarraySum ) ; } } static public void Main ( ) { int [ ] A = { 3 , 4 , 5 , - 4 , 6 } ; int [ ] B = { 1 , 8 , 5 } ; int n = A . Length ; int m = B . Length ; findMaxSubarraySum ( A , B , n , m ) ; } }
using System ; class GFG { static int nonDecNums ( int n ) { int [ , ] a = new int [ n + 1 , 10 ] ; for ( int i = 0 ; i <= 9 ; i ++ ) a [ 0 , i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) a [ i , 9 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 8 ; j >= 0 ; j -- ) a [ i , j ] = a [ i - 1 , j ] + a [ i , j + 1 ] ; return a [ n , 0 ] ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( " Non - decreasing ▁ digits ▁ = ▁ " + nonDecNums ( n ) ) ; } }
using System ; class GFG { static int MOD = 1000000007 ; public static long countBT ( int h ) { long [ ] dp = new long [ h + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; } static void Main ( ) { int h = 3 ; Console . WriteLine ( " No . ▁ of ▁ balanced ▁ binary ▁ trees ▁ of ▁ height ▁ " + h + " ▁ is : ▁ " + countBT ( h ) ) ; } }
using System ; class GFG { static int equilibrium ( int [ ] arr , int n ) { int i , j ; int leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; int arr_size = arr . Length ; Console . Write ( equilibrium ( arr , arr_size ) ) ; } }
using System ; public class GFG { static int countEndless ( bool [ , ] input , int n ) { bool [ , ] row = new bool [ n , n ] ; bool [ , ] col = new bool [ n , n ] ; for ( int j = 0 ; j < n ; j ++ ) { bool isEndless = true ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i , j ] == false ) isEndless = false ; col [ i , j ] = isEndless ; } } for ( int i = 0 ; i < n ; i ++ ) { bool isEndless = true ; for ( int j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i , j ] == false ) isEndless = false ; row [ i , j ] = isEndless ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( row [ i , j ] && col [ i , j ] ) ans ++ ; return ans ; } public static void Main ( ) { bool [ , ] input = { { true , false , true , true } , { false , true , true , true } , { true , true , true , true } , { false , true , true , false } } ; int n = 4 ; Console . Write ( countEndless ( input , n ) ) ; } }
using System ; class GFG { static int equilibrium ( int [ ] arr , int n ) { int sum = 0 ; int leftsum = 0 ; for ( int i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { - 7 , 1 , 5 , 2 , - 4 , 3 , 0 } ; int arr_size = arr . Length ; Console . Write ( " First ▁ equilibrium ▁ index ▁ is ▁ " + equilibrium ( arr , arr_size ) ) ; } }
using System ; class GFG { public static int sumOfSubstrings ( String num ) { int n = num . Length ; int [ ] sumofdigit = new int [ n ] ; sumofdigit [ 0 ] = num [ 0 ] - '0' ; int res = sumofdigit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int numi = num [ i ] - '0' ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; } public static void Main ( ) { String num = "1234" ; Console . Write ( sumOfSubstrings ( num ) ) ; } }
using System ; class GFG { void printLeaders ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) { int j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) Console . Write ( arr [ i ] + " ▁ " ) ; } } public static void Main ( ) { GFG lead = new GFG ( ) ; int [ ] arr = new int [ ] { 16 , 17 , 4 , 3 , 5 , 2 } ; int n = arr . Length ; lead . printLeaders ( arr , n ) ; } }
using System ; class LeadersInArray { void printLeaders ( int [ ] arr , int size ) { int max_from_right = arr [ size - 1 ] ; Console . Write ( max_from_right + " ▁ " ) ; for ( int i = size - 2 ; i >= 0 ; i -- ) { if ( max_from_right < arr [ i ] ) { max_from_right = arr [ i ] ; Console . Write ( max_from_right + " ▁ " ) ; } } } public static void Main ( String [ ] args ) { LeadersInArray lead = new LeadersInArray ( ) ; int [ ] arr = new int [ ] { 16 , 17 , 4 , 3 , 5 , 2 } ; int n = arr . Length ; lead . printLeaders ( arr , n ) ; } }
using System ; class UboundedKnapsack { private static int max ( int i , int j ) { return ( i > j ) ? i : j ; } private static int unboundedKnapsack ( int W , int n , int [ ] val , int [ ] wt ) { int [ ] dp = new int [ W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = Math . Max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ W ] ; } public static void Main ( ) { int W = 100 ; int [ ] val = { 10 , 30 , 20 } ; int [ ] wt = { 5 , 10 , 15 } ; int n = val . Length ; Console . WriteLine ( unboundedKnapsack ( W , n , val , wt ) ) ; } }
using System ; class GFG { static int ceilSearch ( int [ ] arr , int low , int high , int x ) { int i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = arr . Length ; int x = 3 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) Console . Write ( " Ceiling ▁ of ▁ " + x + " ▁ doesn ' t ▁ exist ▁ in ▁ array " ) ; else Console . Write ( " ceiling ▁ of ▁ " + x + " ▁ is ▁ " + arr [ index ] ) ; } }
using System ; class GFG { static int maxSumSubarrayRemovingOneEle ( int [ ] arr , int n ) { int [ ] fw = new int [ n ] ; int [ ] bw = new int [ n ] ; int cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ; fw [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { cur_max = Math . Max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . Max ( max_so_far , cur_max ) ; fw [ i ] = cur_max ; } cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { cur_max = Math . Max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . Max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } int fans = max_so_far ; for ( int i = 1 ; i < n - 1 ; i ++ ) fans = Math . Max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ; return fans ; } public static void Main ( ) { int [ ] arr = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = arr . Length ; Console . WriteLine ( maxSumSubarrayRemovingOneEle ( arr , n ) ) ; } }
using System ; class GFG { static int ceilSearch ( int [ ] arr , int low , int high , int x ) { int mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 2 , 8 , 10 , 10 , 12 , 19 } ; int n = arr . Length ; int x = 8 ; int index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) Console . Write ( " Ceiling ▁ of ▁ " + x + " ▁ doesn ' t ▁ exist ▁ in ▁ array " ) ; else Console . Write ( " ceiling ▁ of ▁ " + x + " ▁ is ▁ " + arr [ index ] ) ; } }
using System ; class GFG { public static double maxAverageOfPath ( int [ , ] cost , int N ) { int [ , ] dp = new int [ N + 1 , N + 1 ] ; dp [ 0 , 0 ] = cost [ 0 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i , 0 ] = dp [ i - 1 , 0 ] + cost [ i , 0 ] ; for ( int j = 1 ; j < N ; j ++ ) dp [ 0 , j ] = dp [ 0 , j - 1 ] + cost [ 0 , j ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) + cost [ i , j ] ; return ( double ) dp [ N - 1 , N - 1 ] / ( 2 * N - 1 ) ; } public static void Main ( ) { int [ , ] cost = { { 1 , 2 , 3 } , { 6 , 5 , 4 } , { 7 , 3 , 9 } } ; Console . Write ( maxAverageOfPath ( cost , 3 ) ) ; } }
using System ; class GFG { public static int maxCost ( int [ , ] mat , int N ) { int [ , ] dp = new int [ N , N ] ; dp [ 0 , 0 ] = mat [ 0 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) dp [ i , 0 ] = mat [ i , 0 ] + dp [ i - 1 , 0 ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i , j ] = mat [ i , j ] + Math . Max ( dp [ i - 1 , j - 1 ] , dp [ i - 1 , j ] ) ; int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 , i ] ) result = dp [ N - 1 , i ] ; return result ; } public static void Main ( ) { int [ , ] mat = { { 4 , 1 , 5 , 6 , 1 } , { 2 , 9 , 2 , 11 , 10 } , { 15 , 1 , 3 , 15 , 2 } , { 16 , 92 , 41 , 4 , 3 } , { 8 , 142 , 6 , 4 , 8 } } ; int N = 5 ; Console . Write ( " Maximum ▁ Path ▁ Sum ▁ : ▁ " + maxCost ( mat , N ) ) ; } }
using System ; class GFG { static int maxProfit ( int [ ] price , int n , int k ) { int [ , ] profit = new int [ k + 1 , n + 1 ] ; for ( int i = 0 ; i <= k ; i ++ ) profit [ i , 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) profit [ 0 , j ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { int prevDiff = int . MinValue ; for ( int j = 1 ; j < n ; j ++ ) { prevDiff = Math . Max ( prevDiff , profit [ i - 1 , j - 1 ] - price [ j - 1 ] ) ; profit [ i , j ] = Math . Max ( profit [ i , j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k , n - 1 ] ; } public static void Main ( ) { int k = 3 ; int [ ] price = { 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 } ; int n = price . Length ; Console . Write ( " Maximum ▁ profit ▁ is : ▁ " + maxProfit ( price , n , k ) ) ; } }
using System ; class GFG { static int [ , ] lookup = new int [ 1000 , 1000 ] ; static int countSeqUtil ( int n , int dif ) { if ( Math . Abs ( dif ) > n ) return 0 ; if ( n == 1 && dif == 0 ) return 2 ; if ( n == 1 && Math . Abs ( dif ) == 1 ) return 1 ; if ( lookup [ n , n + dif ] != - 1 ) return lookup [ n , n + dif ] ; countSeqUtil ( n - 1 , dif + 1 ) + 2 * countSeqUtil ( n - 1 , dif ) + countSeqUtil ( n - 1 , dif - 1 ) ; return lookup [ n , n + dif ] = res ; } static int countSeq ( int n ) { for ( int k = 0 ; k < lookup . GetLength ( 0 ) ; k ++ ) { for ( int j = 0 ; j < lookup . GetLength ( 1 ) ; j ++ ) { lookup [ k , j ] = - 1 ; } } return countSeqUtil ( n , 0 ) ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( " Count ▁ of ▁ sequences ▁ is ▁ " + countSeq ( n ) ) ; } }
using System ; class GFG { static int min ( int a , int b ) { return ( a < b ) ? a : b ; } static int min ( int [ ] arr , int l , int h ) { int mn = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mn > arr [ i ] ) mn = arr [ i ] ; return mn ; } static int max ( int [ ] arr , int l , int h ) { int mx = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) if ( mx < arr [ i ] ) mx = arr [ i ] ; return mx ; } static int minRemovals ( int [ ] arr , int l , int h ) { if ( l >= h ) return 0 ; int mn = min ( arr , l , h ) ; int mx = max ( arr , l , h ) ; if ( 2 * mn > mx ) return 0 ; return min ( minRemovals ( arr , l + 1 , h ) , minRemovals ( arr , l , h - 1 ) ) + 1 ; } public static void Main ( ) { int [ ] arr = { 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 } ; int n = arr . Length ; Console . Write ( minRemovals ( arr , 0 , n - 1 ) ) ; } }
using System ; public class GFG { static int numberOfPaths ( int m , int n ) { int [ , ] count = new int [ m , n ] ; for ( int i = 0 ; i < m ; i ++ ) count [ i , 0 ] = 1 ; for ( int j = 0 ; j < n ; j ++ ) count [ 0 , j ] = 1 ; for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) } return count [ m - 1 , n - 1 ] ; } static public void Main ( ) { Console . WriteLine ( numberOfPaths ( 3 , 3 ) ) ; } }
using System ; class GFG { static int NUM_STATION = 4 ; static int min ( int a , int b ) { return a < b ? a : b ; } static int carAssembly ( int [ , ] a , int [ , ] t , int [ ] e , int [ ] x ) { int [ ] T1 = new int [ NUM_STATION ] ; int [ ] T2 = new int [ NUM_STATION ] ; int i ; T1 [ 0 ] = e [ 0 ] + a [ 0 , 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 , 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 , i ] , T2 [ i - 1 ] + t [ 1 , i ] + a [ 0 , i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 , i ] , T1 [ i - 1 ] + t [ 0 , i ] + a [ 1 , i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; } public static void Main ( ) { int [ , ] a = { { 4 , 5 , 3 , 2 } , { 2 , 10 , 1 , 4 } } ; int [ , ] t = { { 0 , 7 , 4 , 5 } , { 0 , 9 , 2 , 8 } } ; int [ ] e = { 10 , 12 } ; int [ ] x = { 18 , 7 } ; Console . Write ( carAssembly ( a , t , e , x ) ) ; } }
using System ; class GFG { static int LCSubStr ( string X , string Y , int m , int n ) { int [ , ] LCStuff = new int [ m + 1 , n + 1 ] ; int result = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i , j ] = LCStuff [ i - 1 , j - 1 ] + 1 ; result = Math . Max ( result , LCStuff [ i , j ] ) ; } else LCStuff [ i , j ] = 0 ; } } return result ; } public static void Main ( ) { String X = " OldSite : GeeksforGeeks . org " ; String Y = " NewSite : GeeksQuiz . com " ; int m = X . Length ; int n = Y . Length ; Console . Write ( " Length ▁ of ▁ Longest ▁ Common " + " ▁ Substring ▁ is ▁ " + LCSubStr ( X , Y , m , n ) ) ; } }
using System ; class GFG { static int maxCrossingSum ( int [ ] arr , int l , int m , int h ) { int sum = 0 ; int left_sum = int . MinValue ; for ( int i = m ; i >= l ; i -- ) { sum = sum + arr [ i ] ; if ( sum > left_sum ) left_sum = sum ; } sum = 0 ; int right_sum = int . MinValue ; ; for ( int i = m + 1 ; i <= h ; i ++ ) { sum = sum + arr [ i ] ; if ( sum > right_sum ) right_sum = sum ; } return Math . Max ( left_sum + right_sum , Math . Max ( left_sum , right_sum ) ) ; } static int maxSubArraySum ( int [ ] arr , int l , int h ) { if ( l == h ) return arr [ l ] ; int m = ( l + h ) / 2 ; return Math . Max ( Math . Max ( maxSubArraySum ( arr , l , m ) , maxSubArraySum ( arr , m + 1 , h ) ) , maxCrossingSum ( arr , l , m , h ) ) ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 5 , 7 } ; int n = arr . Length ; int max_sum = maxSubArraySum ( arr , 0 , n - 1 ) ; Console . Write ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + max_sum ) ; } }
using System ; class GFG { static float findWater ( int i , int j , float X ) { if ( j > i ) { Console . WriteLine ( " Incorrect ▁ Input " ) ; Environment . Exit ( 0 ) ; } int ll = ( int ) Math . Round ( ( double ) ( i * ( i + 1 ) ) ) ; float [ ] glass = new float [ ll + 2 ] ; int index = 0 ; glass [ index ] = X ; for ( int row = 1 ; row <= i ; ++ row ) { for ( int col = 1 ; col <= row ; ++ col , ++ index ) { X = glass [ index ] ; glass [ index ] = ( X >= 1.0f ) ? 1.0f : X ; X = ( X >= 1.0f ) ? ( X - 1 ) : 0.0f ; glass [ index + row ] += X / 2 ; glass [ index + row + 1 ] += X / 2 ; } } return glass [ ( int ) ( i * ( i - 1 ) / 2 + j - 1 ) ] ; } static void Main ( ) { int i = 2 , j = 2 ; float X = 2.0f ; Console . WriteLine ( " Amount ▁ of ▁ water ▁ in ▁ jth ▁ " + " glass ▁ of ▁ ith ▁ row ▁ is : ▁ " + findWater ( i , j , X ) ) ; } }
using System ; class GFG { static int minPalPartion ( String str ) { int n = str . Length ; int [ , ] C = new int [ n , n ] ; bool [ , ] P = new bool [ n , n ] ; int i , j , k , L ; for ( i = 0 ; i < n ; i ++ ) { P [ i , i ] = true ; C [ i , i ] = 0 ; } for ( L = 2 ; L <= n ; L ++ ) { for ( i = 0 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( L == 2 ) P [ i , j ] = ( str [ i ] == str [ j ] ) ; else P [ i , j ] = ( str [ i ] == str [ j ] ) && P [ i + 1 , j - 1 ] ; if ( P [ i , j ] == true ) C [ i , j ] = 0 ; else { C [ i , j ] = int . MaxValue ; for ( k = i ; k <= j - 1 ; k ++ ) C [ i , j ] = Math . Min ( C [ i , j ] , C [ i , k ] + C [ k + 1 , j ] + 1 ) ; } } } return C [ 0 , n - 1 ] ; } public static void Main ( ) { String str = " ababbbabbababa " ; Console . Write ( " Min ▁ cuts ▁ needed ▁ for ▁ " + " Palindrome ▁ Partitioning ▁ is ▁ " + minPalPartion ( str ) ) ; } }
using System ; class GfG { public static int doMatch ( String A , String B ) { for ( int i = 0 ; i < A . Length ; i ++ ) { if ( A [ i ] != ' * ' && B [ i ] != ' * ' ) if ( A [ i ] != B [ i ] ) return 0 ; } return 1 ; } public static void Main ( String [ ] args ) { String A = " gee * sforgeeks " ; String B = " geeksforgeeks " ; Console . WriteLine ( doMatch ( A , B ) ) ; } }
using System ; class gfg { public int nthTerm ( int N ) { int n = ( ( N + N * ( N - 1 ) ) / 2 ) ; return n ; } static void Main ( string [ ] args ) { gfg p = new gfg ( ) ; int a = p . nthTerm ( 5 ) ; Console . WriteLine ( a ) ; Console . Read ( ) ; } }
using System ; class GFG { static int countSubstrs ( String s1 , String s2 ) { int ans = 0 ; for ( int i = 0 ; i < s1 . Length ; i ++ ) { String s3 = " " ; char [ ] s4 = s1 . ToCharArray ( ) ; for ( int j = i ; j < s1 . Length ; j ++ ) { s3 += s4 [ j ] ; if ( s2 . IndexOf ( s3 ) != - 1 ) ans ++ ; } } return ans ; } public static void Main ( String [ ] args ) { String s1 = " aab " , s2 = " aaaab " ; Console . WriteLine ( countSubstrs ( s1 , s2 ) ) ; } }
using System ; class GFG { static int factorial ( int N ) { int fact = 1 ; for ( int i = 1 ; i <= N ; i ++ ) fact = fact * i ; return fact ; } static int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; } public static void Main ( ) { int N = 6 ; Console . Write ( nthTerm ( N ) ) ; } }
using System ; class GFG { public static bool regexMatch ( String text , String pat ) { int lenText = text . Length ; int lenPat = pat . Length ; char [ ] Text = text . ToCharArray ( ) ; char [ ] Pat = pat . ToCharArray ( ) ; int i = 0 , j = 0 ; while ( i < lenPat ) { if ( Pat [ i ] != ' # ' ) { if ( Pat [ i ] != Text [ j ] ) return false ; i ++ ; j ++ ; } else { j ++ ; while ( Text [ j ] != Pat [ i + 1 ] ) j ++ ; i ++ ; } } return ( j == lenText ) ; } public static void Main ( ) { String str = " ABABABA " ; String pat = " A # B # A " ; if ( regexMatch ( str , pat ) ) Console . Write ( " yes " ) ; else Console . Write ( " no " ) ; } }
using System ; class GfG { static void update ( int [ ] arr , int l , int r , int val ) { arr [ l ] += val ; if ( r + 1 < arr . Length ) arr [ r + 1 ] -= val ; } static int getElement ( int [ ] arr , int i ) { int res = 0 ; for ( int j = 0 ; j <= i ; j ++ ) res += arr [ j ] ; return res ; } public static void Main ( String [ ] args ) { int [ ] arr = { 0 , 0 , 0 , 0 , 0 } ; int n = arr . Length ; int l = 2 , r = 4 , val = 2 ; update ( arr , l , r , val ) ; int index = 4 ; Console . WriteLine ( " Element ▁ at ▁ index ▁ " + index + " ▁ is ▁ " + getElement ( arr , index ) ) ; l = 0 ; r = 3 ; val = 4 ; update ( arr , l , r , val ) ; index = 3 ; Console . WriteLine ( " Element ▁ at ▁ index ▁ " + index + " ▁ is ▁ " + getElement ( arr , index ) ) ; } }
using System ; class GFG { static int factorial ( int n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; } static int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ; } static int NumberOfWays ( int n , int x , int y ) { return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ; } public static void Main ( String [ ] args ) { int n = 5 , x = 4 , y = 2 ; Console . WriteLine ( NumberOfWays ( n , x , y ) ) ; } }
using System ; class GFG { static int count_pairs ( int [ ] a , int [ ] b , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } int pairs = Math . Min ( odd1 , odd2 ) + Math . Min ( even1 , even2 ) ; return pairs ; } public static void Main ( ) { int [ ] a = { 9 , 14 , 6 , 2 , 11 } ; int [ ] b = { 8 , 4 , 7 , 20 } ; int n = a . Length ; int m = b . Length ; Console . WriteLine ( count_pairs ( a , b , n , m ) ) ; } }
using System ; class GFG { static int getValueOfF ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; int cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n /= 2 ; } return 2 * cnt ; } static public void Main ( ) { int n = 20 ; Console . WriteLine ( getValueOfF ( n ) ) ; } }
using System ; class GFG { static int A_mod_B ( string N , int a ) { int len = N . Length ; int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) ans = ( ans * 10 + ( int ) N [ i ] - '0' ) % a ; return ans % a ; } static int findMod ( string N ) { int mod = A_mod_B ( N , 4 ) ; int ans = ( 1 + ( int ) Math . Pow ( 2 , mod ) + ( int ) Math . Pow ( 3 , mod ) + ( int ) Math . Pow ( 4 , mod ) ) ; return ( ans % 5 ) ; } public static void Main ( ) { string N = "4" ; Console . WriteLine ( findMod ( N ) ) ; } }
using System ; public class GfG { public static void printElements ( int [ ] arr , int n ) { for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) { Console . Write ( arr [ i ] + " ▁ " ) ; } } } public static void Main ( string [ ] args ) { int [ ] arr = new int [ ] { 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 } ; int n = arr . Length ; printElements ( arr , n ) ; } }
using System ; class GFG { static int exponent ( int A , int B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; int y ; if ( B % 2 == 0 ) { y = exponent ( A , B / 2 ) ; y = ( y * y ) ; } else { y = A ; y = ( y * exponent ( A , B - 1 ) ) ; } return y ; } static int sum ( int k , int n ) { int sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; return sum ; } public static void Main ( ) { int n = 3 ; int K = 3 ; Console . WriteLine ( sum ( K , n ) ) ; } }
using System ; public class GFG { static bool isPrime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; } static int minimumCost ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 1 && isPrime ( n - 2 ) ) return 2 ; if ( n % 2 == 0 ) return 2 ; return 3 ; } public static void Main ( String [ ] args ) { int n = 6 ; Console . WriteLine ( minimumCost ( n ) ) ; } }
using System ; class GFG { static double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; } public static void Main ( ) { double V , M , N ; V = 700 ; M = 10 ; N = 3 ; Console . WriteLine ( wastedWater ( V , M , N ) ) ; V = 1000 ; M = 100 ; N = 50 ; Console . WriteLine ( wastedWater ( V , M , N ) ) ; } }
using System ; class GFG { static void nDigitPerfectCubes ( int n ) { int smallest = ( int ) Math . Pow ( Math . Ceiling ( MathF . Cbrt ( ( float ) Math . Pow ( 10 , ( n - 1 ) ) ) ) , 3 ) ; Console . Write ( smallest + " ▁ " ) ; int largest = ( int ) Math . Pow ( Math . Ceiling ( MathF . Cbrt ( ( float ) Math . Pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ; Console . Write ( largest ) ; } static void Main ( ) { int n = 3 ; nDigitPerfectCubes ( n ) ; } }
using System ; class GFG { static int countNumbers ( int n ) { return ( n / 2520 ) ; } public static void Main ( String [ ] args ) { int n = 3000 ; Console . WriteLine ( countNumbers ( n ) ) ; } }
using System ; class GFG { public static int MAX = 100001 ; public static int [ ] prefix = new int [ MAX ] ; public static void sieve_modified ( ) { for ( int i = 1 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) { prefix [ j ] += i ; } } for ( int i = 1 ; i < MAX ; i ++ ) { prefix [ i ] += prefix [ i - 1 ] ; } } public static int sumOddFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; } public static void Main ( string [ ] args ) { sieve_modified ( ) ; int l = 6 , r = 10 ; Console . WriteLine ( sumOddFactors ( l , r ) ) ; } }
using System ; class GfG { static int n = 3 ; static void preComputeXor ( int [ , ] arr , int [ , ] prefix_xor ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( j == 0 ) prefix_xor [ i , j ] = arr [ i , j ] ; else prefix_xor [ i , j ] = ( prefix_xor [ i , j - 1 ] ^ arr [ i , j ] ) ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) prefix_xor [ j , i ] = ( prefix_xor [ j - 1 , i ] ^ prefix_xor [ j , i ] ) ; } static int ansQuerie ( int [ , ] prefix_xor , int x1 , int y1 , int x2 , int y2 ) { int xor_1 = 0 , xor_2 = 0 , xor_3 = 0 ; if ( x1 != 0 ) xor_1 = prefix_xor [ x1 - 1 , y2 ] ; if ( y1 != 0 ) xor_2 = prefix_xor [ x2 , y1 - 1 ] ; if ( x1 != 0 && y1 != 0 ) xor_3 = prefix_xor [ x1 - 1 , y1 - 1 ] ; return ( ( prefix_xor [ x2 , y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) ; } public static void Main ( ) { int [ , ] arr = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int [ , ] prefix_xor = new int [ n , n ] ; preComputeXor ( arr , prefix_xor ) ; Console . WriteLine ( ansQuerie ( prefix_xor , 1 , 1 , 2 , 2 ) ) ; Console . WriteLine ( ansQuerie ( prefix_xor , 1 , 2 , 2 , 2 ) ) ; } }
using System ; class GFG { static bool isDigitSumOne ( int nm ) { if ( nm % 9 == 1 ) return true ; else return false ; } static void printValidNums ( int n ) { int cbrt_n = ( int ) Math . Ceiling ( Math . Pow ( n , ( double ) 1 / 3 ) ) ; for ( int i = 1 ; i <= cbrt_n ; i ++ ) { int cube = ( int ) Math . Pow ( i , 3 ) ; if ( cube >= 1 && cube <= n && isDigitSumOne ( cube ) ) Console . Write ( cube + " ▁ " ) ; } } static public void Main ( ) { int n = 1000 ; printValidNums ( n ) ; } }
using System ; class GFG { static int countRhombi ( int h , int w ) { int ct = 0 ; for ( int i = 2 ; i <= h ; i += 2 ) for ( int j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; } public static void Main ( ) { int h = 2 , w = 2 ; Console . WriteLine ( countRhombi ( h , w ) ) ; } }
using System ; class GFG { static double calculateArea ( int x , int y ) { double pi = 3.1415926536 ; double arx = pi * x * x ; double ary = pi * y * y ; return arx - ary ; } public static void Main ( ) { int x = 2 ; int y = 1 ; Console . WriteLine ( calculateArea ( x , y ) ) ; } }
using System ; class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static char getWinner ( int [ ] arr , int n ) { int gcd = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { gcd = __gcd ( gcd , arr [ i ] ) ; maxEle = Math . Max ( maxEle , arr [ i ] ) ; } int totalMoves = ( maxEle / gcd ) - n ; if ( totalMoves % 2 == 1 ) return ' A ' ; return ' B ' ; } public static void Main ( ) { int [ ] arr = { 5 , 6 , 7 } ; int n = arr . Length ; Console . Write ( getWinner ( arr , n ) ) ; } }
using System ; class GFG { static int countPairs ( int n ) { int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( countPairs ( n ) ) ; } }
using System ; class GFG { static String isDivisible ( int n ) { int temp = n ; while ( n > 0 ) { int k = n % 10 ; if ( temp % k == 0 ) { return " YES " ; } n /= 10 ; } return " NO " ; } public static void Main ( String [ ] args ) { int n = 9876543 ; Console . WriteLine ( isDivisible ( n ) ) ; } }
using System ; class GFG { static float sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return ( float ) s ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( " Sum ▁ is ▁ " + sum ( n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static readonly int N = 100005 ; static HashSet < int > ABUNDANT ( ) { HashSet < int > v = new HashSet < int > ( ) ; for ( int i = 1 ; i < N ; i ++ ) { int sum = 1 ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { sum += j ; if ( i / j != j ) { sum += i / j ; } } } if ( sum > i ) { v . Add ( i ) ; } } return v ; } static void SumOfAbundant ( int n ) { HashSet < int > v = ABUNDANT ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { if ( v . Contains ( i ) & v . Contains ( n - i ) ) { Console . Write ( i + " ▁ " + ( n - i ) ) ; return ; } } Console . Write ( - 1 ) ; } public static void Main ( ) { int n = 24 ; SumOfAbundant ( n ) ; } }
using System ; class GFG { static long nthTermOfTheSeries ( int n ) { long nthTerm ; if ( n % 2 == 0 ) nthTerm = ( long ) Math . Pow ( n - 1 , 2 ) + n ; else nthTerm = ( long ) Math . Pow ( n + 1 , 2 ) + n ; return nthTerm ; } public static void Main ( ) { int n ; n = 8 ; Console . WriteLine ( nthTermOfTheSeries ( n ) ) ; n = 12 ; Console . WriteLine ( nthTermOfTheSeries ( n ) ) ; n = 102 ; Console . WriteLine ( nthTermOfTheSeries ( n ) ) ; n = 999 ; Console . WriteLine ( nthTermOfTheSeries ( n ) ) ; n = 9999 ; Console . WriteLine ( nthTermOfTheSeries ( n ) ) ; } }
using System ; class solution { static float CPwithProfit ( int sellingPrice , int profit ) { float costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 + profit ) ; return costPrice ; } static float CPwithLoss ( int sellingPrice , int loss ) { float costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 - loss ) ; return costPrice ; } public static void Main ( ) { int SP , profit , loss ; SP = 1020 ; profit = 20 ; Console . WriteLine ( " Cost ▁ Price ▁ = ▁ " + CPwithProfit ( SP , profit ) ) ; SP = 900 ; loss = 10 ; Console . WriteLine ( " Cost ▁ Price ▁ = ▁ " + CPwithLoss ( SP , loss ) ) ; SP = 42039 ; profit = 8 ; Console . WriteLine ( " Cost ▁ Price ▁ = ▁ " + CPwithProfit ( SP , profit ) ) ; }
using System ; class GFG { static bool isNonHypotenuse ( int n ) { while ( n % 2 == 0 ) { n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { if ( ( i - 1 ) % 4 == 0 ) return false ; while ( n % i == 0 ) { n = n / i ; } } } if ( n > 2 && ( n - 1 ) % 4 == 0 ) return false ; else return true ; } public static void test ( int n ) { Console . WriteLine ( " Testing ▁ for ▁ " + n + " ▁ : ▁ " ) ; if ( isNonHypotenuse ( n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } public static void Main ( ) { int n = 11 ; test ( n ) ; n = 10 ; test ( n ) ; } }
using System ; using System . Text ; class GFG { static String obtain_str ( int n ) { int len = ( int ) Math . Floor ( ( Math . Log ( n + 1 ) / Math . Log ( 2 ) ) ) ; int rel_ind = n + 1 - ( int ) Math . Pow ( 2 , len ) ; int i = 0 ; StringBuilder str = new StringBuilder ( ) ; for ( i = 0 ; i < len ; i ++ ) { str . Append ( ' a ' ) ; } i = 0 ; while ( rel_ind > 0 ) { if ( rel_ind % 2 == 1 ) str [ i ] = ' b ' ; rel_ind /= 2 ; i ++ ; } return reverse ( str . ToString ( ) ) ; } static String reverse ( String input ) { char [ ] a = input . ToCharArray ( ) ; int l , r = a . Length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . Join ( " " , a ) ; } public static void Main ( String [ ] args ) { int n = 11 ; Console . Write ( obtain_str ( n ) ) ; } }
using System ; public class GFG { static void NthTerm ( int n ) { int numerator = ( ( int ) Math . Pow ( n , 2 ) ) - 1 ; int denomeanator = 2 * n - 3 ; Console . WriteLine ( numerator + " / " + denomeanator ) ; } public static void Main ( ) { int n = 3 ; NthTerm ( n ) ; } }
using System ; public class GFG { public static int getSum ( int [ ] arr , int p ) { return arr . Length ; } static public void Main ( ) { int [ ] arr = { 5 , 6 , 8 } ; int p = 7 ; Console . WriteLine ( getSum ( arr , p ) ) ; } }
using System ; public class GFG { static int SquareCube ( long N ) { int cnt = 0 , i = 1 ; while ( ( int ) ( Math . Pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; } public static void Main ( ) { long N = 100000 ; Console . WriteLine ( SquareCube ( N ) ) ; } }
using System ; class GFG { static long getSum ( int n , int d ) { long sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; } public static void Main ( ) { int n = 30 , d = 3 ; Console . Write ( getSum ( n , d ) ) ; } }
using System ; class GFG { static int MOD = 1000000007 ; static long sum ( long N ) { long val = N * ( N + 1 ) ; val = val % MOD ; return val ; } static int sumX ( int N , int M , int K ) { for ( int i = 0 ; i < M ; i ++ ) { N = ( int ) sum ( K + N ) ; } N = N % MOD ; return N ; } public static void Main ( ) { int N = 1 , M = 2 , K = 3 ; Console . WriteLine ( sumX ( N , M , K ) ) ; } }
using System ; class GFG { static int Log2n ( int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; } public static void Main ( ) { int n = 32 ; Console . Write ( Log2n ( n ) ) ; } }
using System ; using System . Collections ; class GFG { static bool checkIsHP ( double [ ] arr ) { int n = arr . Length ; if ( n == 1 ) return true ; ArrayList rec = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) rec . Add ( ( int ) ( 1 / arr [ i ] ) ) ; rec . Sort ( ) ; int d = ( int ) rec [ 1 ] - ( int ) rec [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( ( int ) rec [ i ] - ( int ) rec [ i - 1 ] != d ) return false ; return true ; } public static void Main ( ) { double [ ] arr = { 1 / 5 , 1 / 10 , 1 / 15 , 1 / 20 , 1 / 25 } ; if ( checkIsHP ( arr ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class GFG { static void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( ( A + i * d ) + " ▁ " ) ; } public static void Main ( ) { int A = 20 , B = 32 , N = 5 ; printAMeans ( A , B , N ) ; } }
using System ; namespace prime { public class GFG { public static void primeFactors ( int n ) { while ( n % 2 == 0 ) { Console . Write ( 2 + " ▁ " ) ; n /= 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { Console . Write ( i + " ▁ " ) ; n /= i ; } } if ( n > 2 ) Console . Write ( n ) ; } public static void Main ( ) { int n = 315 ; primeFactors ( n ) ; } } }
using System ; public class GFG { static int startingPoint ( int Length , int Speed1 , int Speed2 ) { int result1 = 0 , result2 = 0 ; int time1 = Length / Speed1 ; int time2 = Length / Speed2 ; result1 = __gcd ( time1 , time2 ) ; result2 = time1 * time2 / ( result1 ) ; return result2 ; } static int __gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return __gcd ( b , a % b ) ; } static float firstTime ( int Length , int Speed1 , int Speed2 ) { float result = 0 ; int relativeSpeed = Math . Abs ( Speed1 - Speed2 ) ; result = ( ( float ) Length / relativeSpeed ) ; return result ; } public static void Main ( ) { int L = 30 , S1 = 5 , S2 = 2 ; float first_Time = firstTime ( L , S1 , S2 ) ; int starting_Point = startingPoint ( L , S1 , S2 ) ; Console . WriteLine ( " Met ▁ first ▁ time ▁ after ▁ " + first_Time + " ▁ hrs " ) ; Console . WriteLine ( " Met ▁ at ▁ starting ▁ point ▁ after ▁ " + starting_Point + " ▁ hrs " ) ; } }
class GFG { static bool CheckArray ( int [ ] arr , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( int i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 2 , 12 , 3 , 2 } ; int n = arr . Length ; if ( CheckArray ( arr , n ) ) System . Console . WriteLine ( " YES " ) ; else System . Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static int sum ( int a , int b ) { int sum = 0 ; for ( int i = 1 ; i <= Math . Min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; } public static void Main ( ) { int A = 10 , B = 15 ; Console . WriteLine ( " Sum ▁ = ▁ " + sum ( A , B ) ) ; } }
using System ; class GFG { static int findgcd ( int a , int b ) { if ( b == 0 ) return a ; return findgcd ( b , a % b ) ; } static int minimumCuts ( int [ ] a , int n ) { Array . Sort ( a ) ; int gcd = a [ 1 ] - a [ 0 ] ; int s = gcd ; for ( int i = 2 ; i < n ; i ++ ) { gcd = findgcd ( gcd , a [ i ] - a [ i - 1 ] ) ; s += a [ i ] - a [ i - 1 ] ; } if ( 360 - s > 0 ) gcd = findgcd ( gcd , 360 - s ) ; return ( 360 / gcd ) - n ; } static void Main ( ) { int [ ] arr = new int [ ] { 30 , 60 , 180 } ; int n = arr . Length ; Console . WriteLine ( minimumCuts ( arr , n ) ) ; } }
using System ; class GFG { static float SellingPrice ( float CP , float PP ) { float P_decimal = 1 + ( PP / 100 ) ; float res = P_decimal * CP ; return res ; } public static void Main ( ) { float C = 720 , P = 13 ; Console . Write ( SellingPrice ( C , P ) ) ; } }
using System ; using System . Linq ; public class GFG { static int compositeProduct ( int [ ] arr , int n ) { int max_val = arr . Max ( ) ; bool [ ] prime = new bool [ max_val + 1 ] ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) prime [ i ] = true ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) { prime [ i ] = false ; } } } int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { product *= arr [ i ] ; } } return product ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . Length ; Console . WriteLine ( compositeProduct ( arr , n ) ) ; } }
using System ; public class GFG { static int sum_odd ( int n ) { int sum = 0 , pos = 1 ; while ( n > 0 ) { if ( pos % 2 == 1 ) sum += n % 10 ; n = n / 10 ; pos ++ ; } return sum ; } static bool check_prime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static public void Main ( ) { int n = 223 ; int sum = sum_odd ( n ) ; if ( check_prime ( sum ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { public static double findAmount ( double X , double W , double Y ) { return ( X * ( Y - W ) ) / ( 100 - Y ) ; } public static void Main ( ) { double X = 100 , W = 50 , Y = 60 ; Console . WriteLine ( " Water ▁ to ▁ be ▁ added ▁ = ▁ { 0 } " , findAmount ( X , W , Y ) ) ; } }
using System ; class GFG { static int reverseNum ( int x ) { string s = x . ToString ( ) ; string str = " " ; for ( int i = s . Length - 1 ; i >= 0 ; i -- ) { str = str + s [ i ] ; } int rev = Int32 . Parse ( str ) ; return rev ; } static bool isMysteryNumber ( int n ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) { int j = reverseNum ( i ) ; if ( i + j == n ) { Console . WriteLine ( i + " ▁ " + j ) ; return true ; } } Console . WriteLine ( " Not ▁ a ▁ Mystery ▁ Number " ) ; return false ; } public static void Main ( ) { int n = 121 ; isMysteryNumber ( n ) ; } }
using System ; class GFG { static void ReplaceElements ( int [ ] arr , int n ) { int prod = 1 ; for ( int i = 0 ; i < n ; ++ i ) { prod *= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = prod / arr [ i ] ; } } static public void Main ( ) { int [ ] arr = { 2 , 3 , 3 , 5 , 7 } ; int n = arr . Length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) { Console . Write ( arr [ i ] + " ▁ " ) ; } Console . WriteLine ( " " ) ; } }
using System ; class GFG { public bool Check_is_possible ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) count ++ ; } return ( count > 1 ) ; } public static void Main ( ) { GFG g = new GFG ( ) ; int l = 4 , r = 12 ; int k = 5 ; if ( g . Check_is_possible ( l , r , k ) ) Console . WriteLine ( " YES STRNEWLINE " ) ; else Console . WriteLine ( " NO STRNEWLINE " ) ; } }
using System ; class GFG { public static int sum ( int N ) { int S1 , S2 , S3 ; S1 = ( ( N / 2 ) ) * ( 2 * 2 + ( N / 2 - 1 ) * 2 ) / 2 ; S2 = ( ( N / 7 ) ) * ( 2 * 7 + ( N / 7 - 1 ) * 7 ) / 2 ; S3 = ( ( N / 14 ) ) * ( 2 * 14 + ( N / 14 - 1 ) * 14 ) / 2 ; return S1 + S2 - S3 ; } public static int Main ( ) { int N = 20 ; Console . WriteLine ( sum ( N ) ) ; return 0 ; } }
using System ; class GFG { static int fastPow ( int N , int K ) { if ( K == 0 ) return 1 ; int temp = fastPow ( N , K / 2 ) ; if ( K % 2 == 0 ) return temp * temp ; else return N * temp * temp ; } static int countWays ( int N , int K ) { return K * fastPow ( K - 1 , N - 1 ) ; } public static void Main ( ) { int N = 3 , K = 3 ; Console . WriteLine ( countWays ( N , K ) ) ; } }
using System ; class GFG { static int sumNth ( int [ ] A , int [ ] B , int m , int n ) { int res = 0 ; if ( n == 1 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; } else if ( n == 2 ) { for ( int i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else { int [ ] f = new int [ n ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( int i = 0 ; i < m ; i ++ ) { res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; } public static void Main ( String [ ] args ) { int [ ] A = { 1 , 2 , 3 } ; int [ ] B = { 4 , 5 , 6 } ; int n = 3 ; int m = A . Length ; Console . WriteLine ( sumNth ( A , B , m , n ) ) ; } }
using System ; class GFG { public static void Main ( ) { int a = 5 ; int AC = a ; int CE = 2 * a ; double shortestDistace = Math . Sqrt ( AC * AC + CE * CE ) ; Console . Write ( shortestDistace ) ; } }
using System ; class GFG { static int sum_of_series ( int n ) { int result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( sum_of_series ( n ) ) ; n = 10 ; Console . WriteLine ( sum_of_series ( n ) ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isCousinPrime ( int n1 , int n2 ) { if ( Math . Abs ( n1 - n2 ) != 4 ) { return false ; } else { return ( isPrime ( n1 ) && isPrime ( n2 ) ) ; } } public static void Main ( ) { int n1 = 7 , n2 = 11 ; if ( isCousinPrime ( n1 , n2 ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static bool isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static bool isThabitNumber ( int n ) { n = n + 1 ; if ( n % 3 == 0 ) n = n / 3 ; else return false ; if ( isPowerOfTwo ( n ) ) return true ; else return false ; } public static void Main ( ) { int n = 47 ; if ( isThabitNumber ( n ) ) { Console . WriteLine ( " YES " ) ; } else { Console . WriteLine ( " NO " ) ; } } }
using System ; class GFG { static int findMinEqualSums ( int [ ] a , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } int sum1 = 0 , sum2 = 0 ; int min = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( Math . Abs ( sum1 - sum2 ) < min ) { min = Math . Abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; } public static void Main ( ) { int [ ] a = { 3 , 2 , 1 , 5 , 7 , 8 } ; int N = a . Length ; Console . WriteLine ( findMinEqualSums ( a , N ) ) ; } }
using System ; class GFG { public double CountDigits ( int n ) { if ( n == 1 ) return 1 ; double sum = 0 ; for ( int i = 2 ; i <= n ; ++ i ) { sum += ( ( double ) Math . Log ( i ) / ( double ) Math . Log ( 10 ) ) ; } sum *= n ; return Math . Ceiling ( sum ) ; } public static void Main ( ) { GFG g = new GFG ( ) ; int N = 5 ; Console . WriteLine ( g . CountDigits ( N ) ) ; } }
using System ; class GFG { static int CONS = 32766 ; static void calc ( int [ ] a , int [ ] b , int [ ] lr , int q , int n ) { int M , m , i , l , r , suma , sumb , cc ; cc = 0 ; for ( i = 0 ; i < n - 1 ; ++ i ) { a [ i + 1 ] += a [ i ] ; b [ i + 1 ] += b [ i ] ; } while ( q != 0 ) { l = lr [ cc ++ ] ; r = lr [ cc ++ ] ; l -= 2 ; r -= 1 ; suma = a [ r ] ; sumb = b [ r ] ; if ( l >= 0 ) { suma -= a [ l ] ; sumb -= b [ l ] ; } M = Math . Max ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) ; M = Math . Max ( M , Math . Max ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) ; m = Math . Min ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) ; m = Math . Min ( m , Math . Min ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) ; Console . WriteLine ( ( M - m ) ) ; q -- ; } } public static void Main ( ) { int n = 5 , q = 2 ; int [ ] a = { 0 , 7 , 3 , 4 , 5 } ; int [ ] b = { 0 , 3 , 1 , 2 , 3 } ; int [ ] lr = new int [ q * 2 ] ; lr [ 0 ] = 1 ; lr [ 1 ] = 1 ; lr [ 2 ] = 1 ; lr [ 3 ] = 3 ; calc ( a , b , lr , q , n ) ; } }
using System ; class GFG { static long NthTerm ( long n ) { long x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; } public static void Main ( ) { long N = 4 ; Console . Write ( NthTerm ( N ) ) ; } }
using System ; class GFG { static int [ ] power = new int [ 31 ] ; static int [ ] pre = new int [ 31 ] ; static void PowerOfTwo ( ) { int x = 1 ; for ( int i = 0 ; i < 31 ; i ++ ) { power [ i ] = x ; x *= 2 ; } pre [ 0 ] = 1 ; for ( int i = 1 ; i < 31 ; i ++ ) pre [ i ] = pre [ i - 1 ] + power [ i ] ; } static int Sum ( int n ) { int ans = n * ( n + 1 ) / 2 ; for ( int i = 0 ; i < 31 ; i ++ ) { if ( power [ i ] > n ) { ans -= 2 * pre [ i - 1 ] ; break ; } } return ans ; } public static void Main ( ) { PowerOfTwo ( ) ; int n = 4 ; Console . WriteLine ( Sum ( n ) ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } public static void Main ( ) { int n = 17 ; if ( isPrime ( n ) && ( n % 16 == 1 ) ) { Console . WriteLine ( " YES " ) ; } else { Console . WriteLine ( " NO " ) ; } } }
using System ; class GFG { static int findNumber ( int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int [ ] count = new int [ 10 ] ; / * int x = i ; int count1 = 0 , count2 = 0 ; while ( x > 0 ) { count [ x % 10 ] ++ ; x /= 10 ; count1 ++ ; } for ( int j = 0 ; j < 10 ; j ++ ) { if ( count [ j ] == 1 ) count2 ++ ; } if ( count1 == count2 ) return i ; } return - 1 ; } static public void Main ( ) { int n = 8490 ; Console . WriteLine ( findNumber ( n ) ) ; } }
using System ; class GFG { static void SieveOfEratosthenes ( int n , bool [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } static void findPrimePair ( int n ) { int flag = 0 ; bool [ ] isPrime = new bool [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 2 ; i < n ; i ++ ) { int x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && x != i && x * i == n ) { Console . Write ( i + " ▁ " + x ) ; flag = 1 ; return ; } } if ( flag == 0 ) Console . Write ( " No ▁ such ▁ pair ▁ found " ) ; } public static void Main ( ) { int n = 39 ; findPrimePair ( n ) ; } }
using System ; class GFG { static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static void solveProportion ( int a , int b1 , int b2 , int c ) { int A = a * b2 ; int B = b1 * b2 ; int C = b1 * c ; int gcd = __gcd ( __gcd ( A , B ) , C ) ; Console . Write ( A / gcd + " : " + B / gcd + " : " + C / gcd ) ; } public static void Main ( ) { int a , b1 , b2 , c ; a = 3 ; b1 = 4 ; b2 = 8 ; c = 9 ; solveProportion ( a , b1 , b2 , c ) ; } }
using System ; class GFG { static int countDivisors ( int n , int k ) { int count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; } public static void Main ( ) { int n = 12 , k = 3 ; Console . WriteLine ( countDivisors ( n , k ) ) ; } }
using System ; class GFG { static float pi = 3.14159f ; public static float volume ( float r , float h ) { return ( float ) 1 / 3 * pi * h * r * r ; } public static float surface_area ( float r , float s ) { return pi * r * s + pi * r * r ; } public static void Main ( ) { float radius = 5 ; float slant_height = 13 ; float height = 12 ; Console . Write ( " Volume ▁ Of ▁ Cone ▁ : ▁ " ) ; Console . WriteLine ( volume ( radius , height ) ) ; Console . Write ( " Surface ▁ Area ▁ Of ▁ Cone ▁ : ▁ " ) ; Console . WriteLine ( surface_area ( radius , slant_height ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return 6 * ( int ) Math . Pow ( n , 2 ) - 4 * n - 2 ; } public static void Main ( ) { int N = 4 ; Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return ( int ) Math . Pow ( n , 2 ) + 2 * n + 2 ; } public static void Main ( ) { int N = 4 ; Console . Write ( nthTerm ( N ) ) ; } }
using System ; class GFG { static int sum ( int n ) { int ans = ( n * ( n - 1 ) ) / 2 ; return ans ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( sum ( n ) ) ; } }
using System ; class GFG { static long getNthTerm ( long N ) { return 4 * ( long ) Math . Pow ( N , 2 ) - 3 * N + 2 ; } static public void Main ( ) { long N = 10 ; Console . Write ( getNthTerm ( N ) ) ; } }
using System ; class GFG { static long MOD = 1000000007 ; static long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long sumProd ( long n , long t ) { long dino = power ( t + 1 , MOD - 2 , MOD ) ; long ans = 1 ; for ( long i = n + t + 1 ; i > n ; -- i ) ans = ( ans % MOD * i % MOD ) % MOD ; long tfact = 1 ; for ( int i = 1 ; i <= t ; ++ i ) tfact = ( tfact * i ) % MOD ; ans = ans * dino - tfact + MOD ; return ans % MOD ; } public static void Main ( ) { long n = 3 , t = 2 ; Console . WriteLine ( sumProd ( n , t ) ) ; } }
using System ; class GFG { static int calculateSum ( int n ) { return ( n * ( ( int ) Math . Pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ; } public static void Main ( ) { int n = 25 ; Console . WriteLine ( calculateSum ( n ) ) ; } }
using System ; class GFG { static long mod = 1000000007 ; static long power ( long a , long b ) { long res = 1 ; while ( b != 0 ) { if ( ( b & 1 ) != 0 ) { res *= a ; res %= mod ; } b /= 2 ; a *= a ; a %= mod ; } return res ; } static long minPlayer ( long n , long k ) { long num = ( ( power ( k , n ) - 1 ) + mod ) % mod ; long den = ( power ( k - 1 , mod - 2 ) + mod ) % mod ; long ans = ( ( ( num * den ) % mod ) * k ) % mod ; return ans ; } public static void Main ( ) { long n = 3 , k = 3 ; Console . WriteLine ( minPlayer ( n , k ) ) ; } }
using System ; class GFG { static void sieveOfEratosthenes ( int N , int [ ] s ) { bool [ ] prime = new bool [ N + 1 ] ; for ( int i = 0 ; i < N + 1 ; i ++ ) prime [ i ] = false ; for ( int i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( int i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( int j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } static int findSum ( int N ) { int [ ] s = new int [ N + 1 ] ; int ans = 1 ; sieveOfEratosthenes ( N , s ) ; int currFactor = s [ N ] ; int power = 1 ; while ( N > 1 ) { N /= s [ N ] ; if ( currFactor == s [ N ] ) { power ++ ; continue ; } int sum = 0 ; for ( int i = 0 ; i <= power ; i ++ ) sum += ( int ) Math . Pow ( currFactor , i ) ; ans *= sum ; currFactor = s [ N ] ; power = 1 ; } return ans ; } public static void Main ( ) { int n = 12 ; Console . Write ( " Sum ▁ of ▁ the ▁ factors ▁ is ▁ : ▁ " ) ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; public class GFG { static int count_setbits ( int N ) { int cnt = 0 ; while ( N > 0 ) { cnt += ( N & 1 ) ; N = N >> 1 ; } return cnt ; } static int countMultiples ( int n ) { int [ ] multiple = { 2 , 3 , 5 } ; int count = 0 , mask = ( int ) Math . Pow ( 2 , 3 ) ; for ( int i = 1 ; i < mask ; i ++ ) { int prod = 1 ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( ( i & 1 << j ) > 0 ) prod = prod * multiple [ j ] ; } if ( count_setbits ( i ) % 2 == 1 ) count = count + n / prod ; else count = count - n / prod ; } return count ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( countMultiples ( n ) ) ; } }
using System ; class GFG { static int findN ( int k ) { int ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; } public static void Main ( ) { int k = 7 ; int res = findN ( k ) ; if ( res == - 1 ) Console . WriteLine ( " Not ▁ possible " ) ; else Console . WriteLine ( res ) ; } }
using System ; public class GFG { static int Circular ( int n ) { int Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; } public static void Main ( ) { int n = 4 ; Console . Write ( Circular ( n - 1 ) ) ; } }
using System ; class GFG { static double calTime ( double [ ] arr , int n ) { double work = 0 ; for ( int i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return Math . Round ( 1 / work , 5 ) ; } public static void Main ( ) { double [ ] arr = { 6.0 , 3.0 , 4.0 } ; int n = arr . Length ; Console . Write ( calTime ( arr , n ) + " ▁ Hours " ) ; } }
class GFG { static void printTwins ( int low , int high ) { bool [ ] prime = new bool [ high + 1 ] ; bool twin = false ; for ( int i = 0 ; i < high + 1 ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p <= System . Math . Floor ( System . Math . Sqrt ( high ) ) + 1 ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= high ; i += p ) prime [ i ] = false ; } } for ( int i = high ; i >= low ; i -- ) { if ( prime [ i ] && ( i - 2 >= low && prime [ i - 2 ] == true ) ) { System . Console . WriteLine ( " Largest ▁ twins ▁ in ▁ given ▁ range : ▁ ( " + ( i - 2 ) + " , ▁ " + ( i ) + " ) " ) ; twin = true ; break ; } } if ( twin == false ) System . Console . WriteLine ( " No ▁ such ▁ pair ▁ exists " ) ; } public static void Main ( ) { printTwins ( 10 , 100 ) ; } }
class GFG { static int prevComplement ( int n , int b ) { int maxDigit , maxNum = 0 , digits = 0 , num = n ; while ( n != 0 ) { digits ++ ; n = n / 10 ; } maxDigit = b - 1 ; while ( ( digits -- ) > 0 ) { maxNum = maxNum * 10 + maxDigit ; } return maxNum - num ; } static int complement ( int n , int b ) { return prevComplement ( n , b ) + 1 ; } public static void Main ( ) { System . Console . WriteLine ( prevComplement ( 25 , 7 ) ) ; System . Console . WriteLine ( complement ( 25 , 7 ) ) ; } }
using System ; class GFG { public static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static public void Main ( ) { int a = 2 ; int b = 4 ; Console . WriteLine ( gcd ( a , b ) ) ; } }
using System ; class GFG { static int MaximumDivisors ( int X , int Y ) { int [ ] arr = new int [ Y - X + 1 ] ; for ( int i = 0 ; i < arr . Length ; i ++ ) arr [ i ] = 0 ; int mx = 0 ; int cnt = 0 ; for ( int i = 1 ; i * i <= Y ; i ++ ) { int sq = i * i ; int first_divisible ; if ( ( X / i ) * i >= X ) first_divisible = ( X / i ) * i ; else first_divisible = ( X / i + 1 ) * i ; for ( int j = first_divisible ; j <= Y ; j += i ) { if ( j < sq ) continue ; else if ( j == sq ) arr [ j - X ] ++ ; else arr [ j - X ] += 2 ; } } for ( int i = X ; i <= Y ; i ++ ) { if ( arr [ i - X ] > mx ) { cnt = 1 ; mx = arr [ i - X ] ; } else if ( arr [ i - X ] == mx ) cnt ++ ; } return cnt ; } public static void Main ( ) { int X = 1 , Y = 10 ; Console . Write ( MaximumDivisors ( X , Y ) ) ; } }
using System ; class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static int NearestElement ( int A , int D , int P ) { if ( A == 0 ) return 0 ; else if ( D == 0 ) return - 1 ; else { int X = power ( D , P - 2 , P ) ; return ( X * ( P - A ) ) % P ; } } public static void Main ( ) { int A = 4 , D = 9 , P = 11 ; A %= P ; D %= P ; Console . WriteLine ( NearestElement ( A , D , P ) ) ; } }
using System ; class GFG { static void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( true ) { flag = 1 ; x = ( int ) ( Math . Pow ( 2 , i ) ) ; p1 = x * p0 + ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; Console . Write ( " ▁ " + p1 ) ; i ++ ; } } public static void Main ( ) { int p0 = 2 ; print ( p0 ) ; } }
using System ; class GFG { static int findOddPair ( int [ ] A , int N ) { int i , j ; int oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; } public static void Main ( ) { int [ ] a = { 5 , 1 , 3 , 2 } ; int n = a . Length ; Console . WriteLine ( findOddPair ( a , n ) ) ; } }
using System ; public class GFG { static long calculateSum ( int n ) { long sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( " Sum ▁ of ▁ all ▁ elements : " + calculateSum ( n ) ) ; } }
using System ; class GFG { static void Divide ( int a , int b ) { long dividend = ( long ) a ; long divisor = ( long ) b ; long sign = ( dividend < 0 ) ^ ( divisor < 0 ) ? - 1 : 1 ; dividend = Math . Abs ( dividend ) ; divisor = Math . Abs ( divisor ) ; if ( divisor == 0 ) { Console . WriteLine ( " Cannot ▁ Divide ▁ by ▁ 0" ) ; return ; } if ( dividend == 0 ) { Console . WriteLine ( a + " ▁ / ▁ " + b + " ▁ is ▁ equal ▁ to ▁ : ▁ " + 0 ) ; return ; } if ( divisor == 1 ) { Console . WriteLine ( a + " ▁ / ▁ " + b + " ▁ is ▁ equal ▁ to ▁ : ▁ " + sign * dividend ) ; return ; } Console . WriteLine ( a + " ▁ / ▁ " + b + " ▁ is ▁ equal ▁ to ▁ : ▁ " + Math . Floor ( sign * ( Math . Exp ( Math . Log ( dividend ) - Math . Log ( divisor ) ) ) ) ) ; } public static void Main ( ) { int a = 10 , b = 5 ; Divide ( a , b ) ; a = 49 ; b = - 7 ; Divide ( a , b ) ; } }
class GFG { static bool findNature ( int a , int b , int n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } } static void Main ( ) { int a = 2 , b = 4 ; int n = 3 ; if ( findNature ( a , b , n ) ) System . Console . WriteLine ( " Odd " ) ; else System . Console . WriteLine ( " Even " ) ; } }
using System ; class GFG { static string checkEqual ( string S ) { for ( int i = 0 ; i < S . Length ; i ++ ) { if ( S [ i ] != '1' && S [ i ] != '0' && S [ i ] != '8' ) { return " No " ; } } int start = 0 , end = S . Length - 1 ; while ( start < end ) { if ( S [ start ] != S [ end ] ) { return " No " ; } start ++ ; end -- ; } return " Yes " ; } public static void Main ( ) { string S = "101" ; Console . WriteLine ( checkEqual ( S ) ) ; } }
using System ; class GFG { static int Log2n ( int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; } static bool isPowerOfd ( int n , int d ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % ( Log2n ( d ) ) == 0 ) ; } return false ; } static void Main ( ) { int n = 64 , d = 8 ; if ( isPowerOfd ( n , d ) ) Console . WriteLine ( " { 0 } ▁ is ▁ a ▁ " + " power ▁ of ▁ { 1 } " , n , d ) ; else Console . WriteLine ( " { 0 } ▁ is ▁ not ▁ a " + " ▁ power ▁ of ▁ { 1 } " , n , d ) ; } }
using System ; class GFG { static int octahedral_num ( int n ) { return n * ( 2 * n * n + 1 ) / 3 ; } static public void Main ( ) { int n = 5 ; Console . Write ( n + " th ▁ Octahedral " + " ▁ number : ▁ " ) ; Console . WriteLine ( octahedral_num ( n ) ) ; } }
using System ; class GFG { static int centeredTetrahedralNumber ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; } public static void Main ( ) { int n = 6 ; Console . WriteLine ( centeredTetrahedralNumber ( n ) ) ; } }
using System ; class GFG { static void swap ( int a , int b , int c , int d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; Console . WriteLine ( " values ▁ after ▁ " + " swapping ▁ are ▁ : ▁ " ) ; Console . WriteLine ( " a ▁ = ▁ " + a ) ; Console . WriteLine ( " b ▁ = ▁ " + b ) ; Console . WriteLine ( " c ▁ = ▁ " + c ) ; Console . WriteLine ( " d ▁ = ▁ " + d ) ; } public static void Main ( ) { int a = 1 ; int b = 2 ; int c = 3 ; int d = 4 ; Console . WriteLine ( " values ▁ before ▁ " + " swapping ▁ are ▁ : ▁ " ) ; Console . WriteLine ( " a ▁ = ▁ " + a ) ; Console . WriteLine ( " b ▁ = ▁ " + b ) ; Console . WriteLine ( " c ▁ = ▁ " + c ) ; Console . WriteLine ( " d ▁ = ▁ " + d ) ; Console . WriteLine ( " " ) ; swap ( a , b , c , d ) ; } }
using System ; class GFG { static int seriesSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += i * ( i + 1 ) / 2 ; return sum ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( seriesSum ( n ) ) ; } }
using System ; class GFG { static bool checkCentrosymmetricted ( int n , int [ , ] m ) { int mid_row ; if ( ( n & 1 ) > 0 ) mid_row = n / 2 + 1 ; else mid_row = n / 2 ; for ( int i = 0 ; i < mid_row ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i , j ] != m [ n - i - 1 , n - j - 1 ] ) return false ; } } return true ; } public static void Main ( ) { int n = 3 ; int [ , ] m = { { 1 , 3 , 5 } , { 6 , 8 , 6 } , { 5 , 3 , 1 } } ; if ( checkCentrosymmetricted ( n , m ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int Centered_Triangular_num ( int n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( Centered_Triangular_num ( n ) ) ; n = 12 ; Console . WriteLine ( Centered_Triangular_num ( n ) ) ; } }
using System ; class GFG { static int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; } static int k_Leaves ( int n , int k ) { int ans = ( binomialCoeff ( n , k ) * binomialCoeff ( n , k - 1 ) ) / n ; Console . WriteLine ( " Number ▁ of ▁ trees ▁ " + " having ▁ 4 ▁ edges ▁ and ▁ exactly ▁ 2 ▁ " + " leaves ▁ : ▁ " + ans ) ; return 0 ; } static int numberOfNodes ( int n , int d ) { int ans = binomialCoeff ( 2 * n - 1 - d , n - 1 ) ; Console . WriteLine ( " Number ▁ of ▁ nodes ▁ " + " of ▁ degree ▁ 1 ▁ in ▁ a ▁ tree ▁ having ▁ 4 ▁ " + " edges ▁ : ▁ " + ans ) ; return 0 ; } static int rootDegreeR ( int n , int r ) { int ans = r * binomialCoeff ( 2 * n - 1 - r , n - 1 ) ; ans = ans / n ; Console . WriteLine ( " Number ▁ of ▁ trees ▁ " + " having ▁ 4 ▁ edges ▁ where ▁ root ▁ has " + " ▁ degree ▁ 2 ▁ : ▁ " + ans ) ; return 0 ; } public static void Main ( ) { k_Leaves ( 3 , 2 ) ; numberOfNodes ( 3 , 1 ) ; rootDegreeR ( 3 , 2 ) ; } }
using System ; public class GFG { public static int repUnitValue ( int n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; int rem = 1 ; int power = 1 ; int k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; } public static void Main ( ) { int n = 13 ; Console . Write ( repUnitValue ( n ) ) ; } }
using System ; class GFG { static int GCD ( int a , int b ) { return b == 0 ? a : GCD ( b , a % b ) ; } static bool isSplittable ( int n , int m ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int sum_s1 = ( total_sum + m ) / 2 ; int sum_s2 = total_sum - sum_s1 ; if ( total_sum < m ) return false ; if ( sum_s1 + sum_s2 == total_sum && sum_s1 - sum_s2 == m ) return ( GCD ( sum_s1 , sum_s2 ) == 1 ) ; return false ; } public static void Main ( ) { int n = 5 , m = 7 ; if ( isSplittable ( n , m ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static bool isPossibleToZero ( int [ ] a , int n ) { int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; } public static void Main ( ) { int [ ] arr = { 0 , 1 , 1 , 0 } ; int n = arr . Length ; if ( isPossibleToZero ( arr , n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { public static bool isBlumInteger ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) { if ( ( n % i == 0 ) && ( ( i - 3 ) % 4 ) == 0 ) { int q = n / i ; return ( q != i && prime [ q ] && ( q - 3 ) % 4 == 0 ) ; } } } return false ; } static public void Main ( ) { int n = 249 ; if ( isBlumInteger ( n ) == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } public static void Main ( ) { int n = 5 , r = 3 ; Console . Write ( nCr ( n , r ) ) ; } }
using System ; class GFG { static int summingSeries ( long n ) { return ( int ) Math . Pow ( n , 2 ) ; } public static void Main ( ) { int n = 100 ; Console . Write ( " The ▁ sum ▁ of ▁ n ▁ term ▁ is : ▁ " + summingSeries ( n ) ) ; } }
using System ; class GFG { static void find_sum_of_two_squares ( int a , int b ) { int ab = a * b ; for ( int i = 0 ; i * i <= ab ; i ++ ) { for ( int j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) Console . Write ( i + " ^ 2 ▁ + ▁ " + j + " ^ 2 ▁ = ▁ " + ab + " STRNEWLINE " ) ; } } } public static void Main ( ) { int a = 1 * 1 + 2 * 2 ; int b = 3 * 3 + 4 * 4 ; Console . Write ( " Representation ▁ of ▁ a ▁ * ▁ b ▁ " + " as ▁ sum ▁ of ▁ 2 ▁ squares : STRNEWLINE " ) ; find_sum_of_two_squares ( a , b ) ; } }
using System ; public class GFG { static int tetrahedralNumber ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( tetrahedralNumber ( n ) ) ; } }
using System ; class GFG { static void check_euler_four_square_identity ( int a , int b , int ab ) { int s = 0 ; for ( int i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( int j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( int k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( int l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { Console . Write ( " i ▁ = ▁ " + i + " STRNEWLINE " ) ; Console . Write ( " j ▁ = ▁ " + j + " STRNEWLINE " ) ; Console . Write ( " k ▁ = ▁ " + k + " STRNEWLINE " ) ; Console . Write ( " l ▁ = ▁ " + l + " STRNEWLINE " ) ; Console . Write ( " Product ▁ of ▁ " + a + " ▁ and ▁ " + b ) ; Console . Write ( " ▁ can ▁ be ▁ written " + " ▁ as ▁ sum ▁ of ▁ squares ▁ of ▁ i , ▁ " + " j , ▁ k , ▁ l STRNEWLINE " ) ; Console . Write ( ab + " ▁ = ▁ " ) ; Console . Write ( i + " * " + i + " ▁ + ▁ " ) ; Console . Write ( j + " * " + j + " ▁ + ▁ " ) ; Console . Write ( k + " * " + k + " ▁ + ▁ " ) ; Console . Write ( l + " * " + l + " STRNEWLINE " ) ; Console . Write ( " STRNEWLINE " ) ; } } } } } } static void Main ( ) { int ab = a * b ; check_euler_four_square_identity ( a , b , ab ) ; } }
using System ; class GFG { static int calculateDivisors ( int A , int B ) { int N = ( A - B ) ; int noOfDivisors = 0 ; double a = Math . Sqrt ( N ) ; for ( int i = 1 ; i <= ( int ) ( a ) ; i ++ ) { if ( ( N % i ) == 0 ) { if ( i > B ) noOfDivisors ++ ; if ( ( N / i ) != i && ( N / i ) > B ) noOfDivisors ++ ; } } return noOfDivisors ; } static int numberOfPossibleWaysUtil ( int A , int B ) { if ( A == B ) return - 1 ; if ( A < B ) return 0 ; int noOfDivisors = 0 ; noOfDivisors = calculateDivisors ( A , B ) ; return noOfDivisors ; } public static void numberOfPossibleWays ( int A , int B ) { int noOfSolutions = numberOfPossibleWaysUtil ( A , B ) ; if ( noOfSolutions == - 1 ) { Console . Write ( " For ▁ A ▁ = ▁ " + A + " ▁ and ▁ B ▁ = ▁ " + B + " , ▁ X ▁ can ▁ take ▁ Infinitely ▁ many ▁ values " + " ▁ greater ▁ than ▁ " + A + " STRNEWLINE " ) ; } else { Console . Write ( " For ▁ A ▁ = ▁ " + A + " ▁ and ▁ B ▁ = ▁ " + B + " , ▁ X ▁ can ▁ take ▁ " + noOfSolutions + " ▁ values STRNEWLINE " ) ; } } public static void Main ( ) { int A = 26 , B = 2 ; numberOfPossibleWays ( A , B ) ; A = 21 ; B = 5 ; numberOfPossibleWays ( A , B ) ; } }
using System ; using System . Collections . Generic ; class GFG { static long powerNumbers ( int n ) { HashSet < long > v = new HashSet < long > ( ) ; for ( long i = 2 ; i * i * i <= n ; i ++ ) { long j = i * i ; while ( j * i <= n ) { j *= i ; long s = ( long ) Math . Sqrt ( j ) ; if ( s * s != j ) v . Add ( j ) ; } } return v . Count + ( long ) Math . Sqrt ( n ) ; } static void Main ( ) { Console . Write ( powerNumbers ( 50 ) ) ; } }
using System ; class GFG { static int mean ( int [ , ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i , j ] ; return sum / ( n * n ) ; } static int variance ( int [ , ] a , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { a [ i , j ] -= m ; a [ i , j ] *= a [ i , j ] ; } } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += a [ i , j ] ; return sum / ( n * n ) ; } static public void Main ( ) { int [ , ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int m = mean ( mat , 3 ) ; int var = variance ( mat , 3 , m ) ; double dev = ( int ) Math . Sqrt ( var ) ; Console . WriteLine ( " Mean : ▁ " + m ) ; Console . WriteLine ( " Variance : ▁ " + var ) ; Console . WriteLine ( " Deviation : ▁ " + dev ) ; } }
using System ; public class GFG { static void printAMeans ( int A , int B , int N ) { float d = ( float ) ( B - A ) / ( N + 1 ) ; for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( ( A + i * d ) + " ▁ " ) ; } public static void Main ( ) { int A = 20 , B = 32 , N = 5 ; printAMeans ( A , B , N ) ; } }
using System ; class GFG { static int sumofseries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; } public static void Main ( ) { Console . WriteLine ( sumofseries ( 3 ) ) ; } }
using System ; class GFG { static bool isValid ( long i , long m ) { long sq_i = ( long ) Math . Sqrt ( i ) ; long sq = Math . Min ( m , sq_i ) ; for ( long j = 2 ; j <= sq ; j ++ ) if ( i % j == 0 ) return false ; return true ; } static void findLargestNum ( long n , long m ) { for ( long i = n ; i > m ; i -- ) { if ( isValid ( i , m ) ) { Console . WriteLine ( i ) ; return ; } } Console . WriteLine ( " Number ▁ Doesn ' t ▁ Exists " ) ; } public static void Main ( ) { long n = 55 , m = 25 ; findLargestNum ( n , m ) ; } }
using System ; class GFG { static bool isOrthogonal ( int [ , ] a , int m , int n ) { if ( m != n ) return false ; int [ , ] trans = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) trans [ i , j ] = a [ j , i ] ; int [ , ] prod = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int sum = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sum = sum + ( a [ i , k ] * a [ j , k ] ) ; } prod [ i , j ] = sum ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i != j && prod [ i , j ] != 0 ) return false ; if ( i == j && prod [ i , j ] != 1 ) return false ; } } return true ; } static public void Main ( ) { int [ , ] a = { { 1 , 0 , 0 } , { 0 , 1 , 0 } , { 0 , 0 , 1 } } ; if ( isOrthogonal ( a , 3 , 3 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool isPerfectSquare ( double x ) { if ( x >= 0 ) { double sr = Math . Sqrt ( x ) ; return ( sr * sr == x ) ; } return false ; } public static void Main ( ) { double x = 2502 ; if ( isPerfectSquare ( x ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static void printGP ( int a , int r , int n ) { int curr_term ; for ( int i = 0 ; i < n ; i ++ ) { curr_term = a * ( int ) Math . Pow ( r , i ) ; Console . Write ( curr_term + " ▁ " ) ; } } public static void Main ( ) { int a = 2 ; int r = 3 ; int n = 5 ; printGP ( a , r , n ) ; } }
using System ; class GFG { static int getMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 2 ) ; } static void multiply ( int [ , ] F , int [ , ] M ) { int x = F [ 0 , 0 ] * M [ 0 , 0 ] + F [ 0 , 1 ] * M [ 1 , 0 ] ; int y = F [ 0 , 0 ] * M [ 0 , 1 ] + F [ 0 , 1 ] * M [ 1 , 1 ] ; int z = F [ 1 , 0 ] * M [ 0 , 0 ] + F [ 1 , 1 ] * M [ 1 , 0 ] ; int w = F [ 1 , 0 ] * M [ 0 , 1 ] + F [ 1 , 1 ] * M [ 1 , 1 ] ; F [ 0 , 0 ] = x ; F [ 0 , 1 ] = y ; F [ 1 , 0 ] = z ; F [ 1 , 1 ] = w ; } static void power ( int [ , ] F , int n ) { if ( n == 0 n == 1 ) return ; int [ , ] M = { { 1 , 1 } , { 1 , 0 } } ; for ( int m = getMSB ( n ) ; m > 0 ; m = m >> 1 ) { multiply ( F , F ) ; if ( ( n & m ) > 0 ) { multiply ( F , M ) ; } } } static int fib ( int n ) { int [ , ] F = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) return 0 ; power ( F , n - 1 ) ; return F [ 0 , 0 ] ; } static public void Main ( ) { int n = 6 ; Console . WriteLine ( fib ( n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void SternSequenceFunc ( List < int > BrocotSequence , int n ) { for ( int i = 1 ; BrocotSequence . Count < n ; i ++ ) { int considered_element = BrocotSequence [ i ] ; int precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . Add ( considered_element + precedent ) ; BrocotSequence . Add ( considered_element ) ; } for ( int i = 0 ; i < 15 ; ++ i ) Console . Write ( BrocotSequence [ i ] + " ▁ " ) ; } static void Main ( ) { int n = 15 ; List < int > BrocotSequence = new List < int > ( ) ; BrocotSequence . Add ( 1 ) ; BrocotSequence . Add ( 1 ) ; SternSequenceFunc ( BrocotSequence , n ) ; } }
using System ; class GFG { static bool isRevDiffDivisible ( int x , int k ) { int n = x ; int m = 0 ; while ( x > 0 ) { m = m * 10 + x % 10 ; x /= 10 ; } return ( Math . Abs ( n - m ) % k == 0 ) ; } static int countNumbers ( int l , int r , int k ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( isRevDiffDivisible ( i , k ) ) ++ count ; return count ; } public static void Main ( ) { int l = 35 , r = 45 , k = 5 ; Console . WriteLine ( countNumbers ( l , r , k ) ) ; } }
using System ; class GFG { static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + 1 ) ; } static bool areAmicable ( int x , int y ) { if ( divSum ( x ) != y ) return false ; return ( divSum ( y ) == x ) ; } public static void Main ( ) { int x = 220 , y = 284 ; if ( areAmicable ( x , y ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool isPerfectSquare ( int n ) { if ( n < 0 ) return false ; double root = Math . Round ( ( double ) ( Math . Sqrt ( n ) ) ) ; return n == root * root ; } static void printnonsquare ( int n ) { int count = 0 ; for ( int i = 1 ; count < n ; ++ i ) { if ( ! isPerfectSquare ( i ) ) { Console . Write ( i + " ▁ " ) ; count ++ ; } } } static public void Main ( ) { int n = 10 ; printnonsquare ( n ) ; } }
using System ; class GFG { static int nonsquare ( int n ) { return n + ( int ) ( 0.5 + ( Math . Sqrt ( n ) ) ) ; } static void printNonSquare ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( nonsquare ( i ) + " ▁ " ) ; } public static void Main ( ) { int n = 10 ; printNonSquare ( n ) ; } }
using System ; class Fraction { int num , den ; Fraction ( int n , int d ) { num = n ; den = d ; } static Fraction maxFraction ( Fraction first , Fraction sec ) { int a = first . num ; int b = first . den ; int c = sec . num ; int d = sec . den ; int Y = a * d - b * c ; return ( Y > 0 ) ? first : sec ; } public static void Main ( ) { Fraction first = new Fraction ( 3 , 2 ) ; Fraction sec = new Fraction ( 3 , 4 ) ; Fraction res = maxFraction ( first , sec ) ; Console . WriteLine ( res . num + " / " + res . den ) ; } }
using System ; class GFG { static bool isPentagonal ( int N ) { int i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; } public static void Main ( ) { int N = 12 ; if ( isPentagonal ( N ) ) Console . Write ( N + " ▁ is ▁ pentagonal ▁ " ) ; else Console . Write ( N + " ▁ is ▁ not ▁ pentagonal " ) ; } }
using System ; class GFG { static long fourthPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; } public static void Main ( ) { int n = 6 ; Console . WriteLine ( fourthPowerSum ( n ) ) ; } }
using System ; class GFG { static long fourthPowerSum ( int n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; } public static void Main ( ) { int n = 6 ; Console . Write ( fourthPowerSum ( n ) ) ; } }
using System ; class GFG { static int unitnumber ( int x , int y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( ( int ) ( Math . Pow ( x , y ) ) ) % 10 ) ; } public static void Main ( ) { int x = 133 , y = 5 ; Console . WriteLine ( unitnumber ( x , y ) ) ; } }
using System ; class GFG { static int aliquotSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; } public static void Main ( ) { int n = 12 ; Console . WriteLine ( aliquotSum ( n ) ) ; } }
using System ; using System . Text . RegularExpressions ; class GfG { public static String complexNumberMultiply ( String a , String b ) { String [ ] x = Regex . Split ( a , @"\+ i" ) ; String [ ] y = Regex . Split ( b , @"\+ i" ) ; int a_real = Int32 . Parse ( x [ 0 ] ) ; int a_img = Int32 . Parse ( x [ 1 ] ) ; int b_real = Int32 . Parse ( y [ 0 ] ) ; int b_img = Int32 . Parse ( y [ 1 ] ) ; return ( a_real * b_real - a_img * b_img ) + " + " + ( a_real * b_img + a_img * b_real ) + " i " ; } public static void Main ( String [ ] argc ) { String str1 = "1 + 1i " ; String str2 = "1 + 1i " ; Console . WriteLine ( complexNumberMultiply ( str1 , str2 ) ) ; } }
using System ; public class GFG { static float AvgofSquareN ( int n ) { return ( float ) ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } static public void Main ( String [ ] args ) { int n = 2 ; Console . WriteLine ( AvgofSquareN ( n ) ) ; } }
using System ; class GFG { static float func ( float x ) { return ( 1 / ( 1 + x * x ) ) ; } static float calculate ( float lower_limit , float upper_limit , int interval_limit ) { float interval_size = ( upper_limit - lower_limit ) / interval_limit ; float sum = func ( lower_limit ) + func ( upper_limit ) ; for ( int i = 1 ; i < interval_limit ; i ++ ) { if ( i % 3 == 0 ) sum = sum + 2 * func ( lower_limit + i * interval_size ) ; else sum = sum + 3 * func ( lower_limit + i * interval_size ) ; } return ( 3 * interval_size / 8 ) * sum ; } public static void Main ( ) { int interval_limit = 10 ; float lower_limit = 1 ; float upper_limit = 10 ; float integral_res = calculate ( lower_limit , upper_limit , interval_limit ) ; Console . WriteLine ( integral_res ) ; } }
using System ; class GFG { static float focal_length ( float image_distance , float object_distance ) { return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) ; } public static void Main ( ) { float image_distance = 2 ; float object_distance = 50 ; Console . WriteLine ( " Focal ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ " + focal_length ( image_distance , object_distance ) + " ▁ units . " ) ; } }
using System ; class GFG { static bool check ( int n ) { int m = n ; while ( n != 0 ) { int r = n % 10 ; if ( r > 0 ) if ( ( m % r ) != 0 ) return false ; n /= 10 ; } return true ; } static int count ( int l , int r ) { int ans = 0 ; for ( int i = l ; i <= r ; i ++ ) if ( check ( i ) ) ans += 1 ; return ans ; } public static void Main ( ) { int l = 10 , r = 20 ; Console . WriteLine ( count ( l , r ) ) ; } }
using System ; class demo { public static double sumOfTheSeries ( int n ) { double sum = 0.0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; } public static void Main ( ) { int n = 10 ; Console . Write ( sumOfTheSeries ( n ) ) ; } }
using System ; class GFG { static long sum ( long n ) { long root = ( long ) Math . Sqrt ( n ) ; long ans = 0 ; for ( int i = 1 ; i <= root ; i ++ ) ans += n / i ; ans = 2 * ans - ( root * root ) ; return ans ; } public static void Main ( ) { long n = 35 ; Console . Write ( sum ( n ) ) ; } }
using System ; class GFG { static int sumOfTheSeries ( int n ) { int sum_n = ( n * ( n + 1 ) / 2 ) ; int sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; } public static void Main ( ) { int n = 5 ; Console . Write ( " Sum ▁ = ▁ " + sumOfTheSeries ( n ) ) ; } }
using System ; class GFG { static int sumofsquare ( int n ) { int [ , ] C = new int [ n + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n , i ] * C [ n , i ] ) ; return sum ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( sumofsquare ( n ) ) ; } }
using System ; public class GfG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; } public static void Main ( ) { int n = 10 ; Console . Write ( sumOfSeries ( n ) ) ; } }
using System ; class GFG { static int evenSum ( int n ) { int [ , ] C = new int [ n + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } int sum = 0 ; for ( i = 0 ; i <= n ; i += 2 ) sum += C [ n , i ] ; return sum ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( evenSum ( n ) ) ; } }
using System ; class GFG { static void triangular_series ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( i * ( i + 1 ) / 2 + " ▁ " ) ; } public static void Main ( ) { int n = 5 ; triangular_series ( n ) ; } }
using System ; class GFG { static void checksum ( int n ) { if ( n % 3 == 0 ) Console . WriteLine ( n / 3 - 1 + " ▁ " + n / 3 + " ▁ " + ( n / 3 + 1 ) ) ; else Console . WriteLine ( " - 1" ) ; } public static void Main ( ) { int n = 6 ; checksum ( n ) ; } }
using System ; class GFG { static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( divisorSum ( n ) ) ; n = 5 ; Console . WriteLine ( divisorSum ( n ) ) ; } }
using System ; class GFG { static double polite ( double n ) { n += 1 ; double base1 = 2 ; return n + ( Math . Log ( ( n + ( Math . Log ( n ) / Math . Log ( base1 ) ) ) ) ) / Math . Log ( base1 ) ; } public static void Main ( String [ ] args ) { double n = 7 ; Console . Write ( ( int ) polite ( n ) ) ; } }
using System ; public class GfG { public static int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; } public static void Main ( ) { int T = 15 ; int ans = solve ( 1 , T , 2 * T ) ; if ( ans != - 1 ) ans -- ; Console . WriteLine ( " Number ▁ of ▁ stair ▁ steps ▁ = ▁ " + ans ) ; } }
using System ; public class GfG { static bool isOverflow ( long a , long b ) { if ( a == 0 b == 0 ) return false ; long result = a * b ; if ( a == result / b ) return false ; else return true ; } public static void Main ( ) { long a = 10000000000 ; long b = - 10000000000 ; if ( isOverflow ( a , b ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { public static int oddSum ( int n ) { int sum = 0 , curr = 1 ; for ( int i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; } public static void Main ( ) { int n = 20 ; Console . WriteLine ( " ▁ Sum ▁ of ▁ first ▁ " + n + " ▁ Odd ▁ Numbers ▁ is : ▁ " + oddSum ( n ) ) ; } }
using System ; class GFG { public static int oddSum ( int n ) { return ( n * n ) ; } public static void Main ( ) { int n = 20 ; Console . WriteLine ( " ▁ Sum ▁ of ▁ first ▁ " + n + " ▁ Odd ▁ Numbers ▁ is : ▁ " + oddSum ( n ) ) ; } }
using System ; class GFG { static void printKPFNums ( int A , int B , int K ) { bool [ ] prime = new bool [ B + 1 ] ; for ( int i = 0 ; i < B + 1 ; i ++ ) prime [ i ] = true ; int [ ] p_factors = new int [ B + 1 ] ; for ( int i = 0 ; i < B + 1 ; i ++ ) p_factors [ i ] = 0 ; for ( int p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( int i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( int i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) Console . Write ( i + " ▁ " ) ; } public static void Main ( ) { int A = 14 , B = 18 , K = 2 ; printKPFNums ( A , B , K ) ; } }
using System ; public class GFG { static readonly int MAX = 100005 ; static void precompute ( int [ ] prefix , int [ ] suffix ) { bool [ ] prime = new bool [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { prime [ i ] = true ; } for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j < MAX ; j += i ) { prime [ j ] = false ; } } } prefix [ 1 ] = 1 ; suffix [ MAX - 1 ] = ( int ) 1e9 + 7 ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) { prefix [ i ] = i ; } else { prefix [ i ] = prefix [ i - 1 ] ; } } for ( int i = MAX - 2 ; i > 1 ; i -- ) { if ( prime [ i ] ) { suffix [ i ] = i ; } else { suffix [ i ] = suffix [ i + 1 ] ; } } } static int query ( int [ ] prefix , int [ ] suffix , int L , int R ) { if ( prefix [ R ] < L suffix [ L ] > R ) { return 0 ; } else { return prefix [ R ] - suffix [ L ] ; } } public static void Main ( ) { int q = 3 ; int [ ] L = { 2 , 2 , 24 } ; int [ ] R = { 5 , 2 , 28 } ; int [ ] prefix = new int [ MAX ] ; int [ ] suffix = new int [ MAX ] ; precompute ( prefix , suffix ) ; for ( int i = 0 ; i < q ; i ++ ) { Console . WriteLine ( query ( prefix , suffix , L [ i ] , R [ i ] ) ) ; } } }
using System ; class GFG { static float sum ( int x , int n ) { double i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) total = total + ( Math . Pow ( x , i ) / i ) ; return ( float ) total ; } public static void Main ( ) { int x = 2 ; int n = 5 ; Console . WriteLine ( sum ( x , n ) ) ; } }
using System ; class GFG { static bool isMember ( int a , int d , int x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; } public static void Main ( ) { int a = 1 , x = 7 , d = 3 ; if ( isMember ( a , d , x ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool sumSquare ( int n ) { for ( long i = 1 ; i * i <= n ; i ++ ) for ( long j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { Console . Write ( i + " ^ 2 ▁ + ▁ " + j + " ^ 2" ) ; return true ; } return false ; } public static void Main ( String [ ] args ) { int n = 25 ; if ( sumSquare ( n ) ) Console . Write ( " STRNEWLINE Yes " ) ; else Console . Write ( " STRNEWLINE No " ) ; } }
using System ; public class GFG { static bool check ( long a , long b ) { long c = 0 ; while ( a != 0 ) { c = c + a % 10 ; a = a / 10 ; } return ( c == b ) ; } static long root ( long n ) { bool found = false ; long mx = ( long ) 1E18 ; for ( long i = 0 ; i <= 90 ; i ++ ) { long s = i * i + 4 * n ; long sq = ( long ) Math . Sqrt ( s ) ; if ( sq * sq == s && check ( ( sq - i ) / 2 , i ) ) { found = true ; mx = Math . Min ( mx , ( sq - i ) / 2 ) ; } } if ( found ) return mx ; else return - 1 ; } public static void Main ( ) { long n = 110 ; Console . Write ( root ( n ) ) ; } }
using System ; public class base_power { static int calculate ( int n , int power ) { int sum = 0 ; int bp = ( int ) Math . Pow ( n , power ) ; while ( bp != 0 ) { int d = bp % 10 ; sum += d ; bp /= 10 ; } return sum ; } public static void Main ( ) { int n = 5 ; int power = 4 ; Console . WriteLine ( calculate ( n , power ) ) ; } }
using System ; class GFG { static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static bool coprime ( int a , int b ) { return ( __gcd ( a , b ) == 1 ) ; } static void pairSum ( int n ) { int mid = n / 2 ; for ( int i = mid ; i >= 1 ; i -- ) { if ( coprime ( i , n - i ) == true ) { Console . Write ( i + " ▁ " + ( n - i ) ) ; break ; } } } public static void Main ( ) { int n = 11 ; pairSum ( n ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void modBigNumber ( string num , long m ) { List < int > vec = new List < int > ( ) ; long mod = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) { int digit = num [ i ] - '0' ; mod = mod * 10 + digit ; int quo = ( int ) ( mod / m ) ; vec . Add ( quo ) ; mod = mod % m ; } Console . Write ( " Remainder ▁ : ▁ " + mod + " STRNEWLINE " ) ; Console . Write ( " Quotient ▁ : ▁ " ) ; bool zeroflag = false ; for ( int i = 0 ; i < vec . Count ; i ++ ) { if ( vec [ i ] == 0 && zeroflag == false ) { continue ; } zeroflag = true ; Console . Write ( vec [ i ] ) ; } return ; } public static void Main ( ) { string num = "14598499948265358486" ; long m = 487 ; modBigNumber ( num , m ) ; } }
using System ; using System . Collections ; class GFG { static int N = ( int ) 1E6 ; static bool [ ] fourDiv = new bool [ N + 1 ] ; static void fourDistinctFactors ( ) { bool [ ] primeAll = new bool [ N + 1 ] ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( primeAll [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) primeAll [ i ] = true ; } } ArrayList prime = new ArrayList ( ) ; for ( int p = 2 ; p <= N ; p ++ ) if ( ! primeAll [ p ] ) prime . Add ( p ) ; for ( int i = 0 ; i < prime . Count ; ++ i ) { int p = ( int ) prime [ i ] ; if ( 1L * p * p * p <= N ) fourDiv [ p * p * p ] = true ; for ( int j = i + 1 ; j < prime . Count ; ++ j ) { int q = ( int ) prime [ j ] ; if ( 1L * p * q > N ) break ; fourDiv [ p * q ] = true ; } } } public static void Main ( ) { fourDistinctFactors ( ) ; int num = 10 ; if ( fourDiv [ num ] ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; num = 12 ; if ( fourDiv [ num ] ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int leonardo ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + 1 ; return dp [ n ] ; } public static void Main ( ) { Console . WriteLine ( leonardo ( 3 ) ) ; } }
using System ; class GFG { static void Cholesky_Decomposition ( int [ , ] matrix , int n ) { int [ , ] lower = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { int sum = 0 ; if ( j == i ) { for ( int k = 0 ; k < j ; k ++ ) sum += ( int ) Math . Pow ( lower [ j , k ] , 2 ) ; lower [ j , j ] = ( int ) Math . Sqrt ( matrix [ j , j ] - sum ) ; } else { for ( int k = 0 ; k < j ; k ++ ) sum += ( lower [ i , k ] * lower [ j , k ] ) ; lower [ i , j ] = ( matrix [ i , j ] - sum ) / lower [ j , j ] ; } } } Console . WriteLine ( " ▁ Lower ▁ Triangular TABSYMBOL ▁ Transpose " ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) Console . Write ( lower [ i , j ] + " TABSYMBOL " ) ; Console . Write ( " " ) ; for ( int j = 0 ; j < n ; j ++ ) Console . Write ( lower [ j , i ] + " TABSYMBOL " ) ; Console . WriteLine ( ) ; } } static int Main ( ) { int n = 3 ; int [ , ] matrix = { { 4 , 12 , - 16 } , { 12 , 37 , - 43 } , { - 16 , - 43 , 98 } } ; Cholesky_Decomposition ( matrix , n ) ; return 0 ; } }
using System ; class GFG { static float sumOfAP ( float a , float d , float n ) { float sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; } static public void Main ( ) { float n = 20 ; float a = 2.5f , d = 1.5f ; Console . WriteLine ( sumOfAP ( a , d , n ) ) ; } }
using System ; class GFG { public static int sumOfSeries ( int n ) { int x ; if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) ; else x = ( ( n + 1 ) / 2 ) * n ; return x * x ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( sumOfSeries ( n ) ) ; } }
using System ; class GFG { static int findValue ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) ans = Math . Max ( ans , Math . Abs ( arr [ i ] - arr [ j ] ) + Math . Abs ( i - j ) ) ; return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 1 } ; int n = arr . Length ; Console . Write ( findValue ( arr , n ) ) ; } }
using System ; class GFG { static int findValue ( int [ ] arr , int n ) { int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( arr [ i ] + i ) ; b [ i ] = ( arr [ i ] - i ) ; } int x = a [ 0 ] , y = a [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) x = a [ i ] ; if ( a [ i ] < y ) y = a [ i ] ; } int ans1 = ( x - y ) ; x = b [ 0 ] ; y = b [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( b [ i ] > x ) x = b [ i ] ; if ( b [ i ] < y ) y = b [ i ] ; } int ans2 = ( x - y ) ; return Math . Max ( ans1 , ans2 ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 1 } ; int n = arr . Length ; Console . WriteLine ( findValue ( arr , n ) ) ; } }
using System ; public class GFG { static int countsubarray ( int [ ] array , int n , int k ) { int count = 0 ; int i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; } static public void Main ( ) { int [ ] array = { 1 , 2 , 3 , 4 } ; int k = 10 ; int size = array . Length ; int count = countsubarray ( array , size , k ) ; Console . WriteLine ( count ) ; } }
using System ; class GFG { static int MAX = 1000001 ; static int [ ] factor ; static void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } static int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; } public static void Main ( ) { factor = new int [ MAX ] ; factor [ 0 ] = 0 ; generatePrimeFactors ( ) ; int [ ] a = { 10 , 30 , 100 , 450 , 987 } ; int q = a . Length ; for ( int i = 0 ; i < q ; i ++ ) Console . Write ( calculateNoOFactors ( a [ i ] ) + " ▁ " ) ; } }
using System ; class GFG { public static void digit_product_Sum ( int N ) { int [ ] a = new int [ N + 1 ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; } public static void Main ( ) { int N = 10 ; digit_product_Sum ( N ) ; } }
using System ; class GFG { static float geometricMean ( int [ ] arr , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; float gm = ( float ) Math . Pow ( product , ( float ) 1 / n ) ; return gm ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = arr . Length ; Console . WriteLine ( geometricMean ( arr , n ) ) ; } }
using System ; class GFG { static int SIZE = 4 ; static bool productOfSingelDgt ( int n ) { if ( n >= 0 && n <= 9 ) return true ; int [ ] prime = { 2 , 3 , 5 , 7 } ; for ( int i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; } public static void Main ( ) { int n = 24 ; if ( productOfSingelDgt ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int findSum ( int n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) ; else return ( ( n + 1 ) / 2 ) * n ; } public static void Main ( ) { int n = 5 ; Console . Write ( findSum ( n ) ) ; } }
using System ; class GFG { static int maxPrimefactorNum ( int N ) { if ( N < 2 ) return 0 ; bool [ ] arr = new bool [ N + 1 ] ; int prod = 1 , res = 0 ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( int i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; } public static void Main ( ) { int N = 500 ; Console . WriteLine ( maxPrimefactorNum ( N ) ) ; } }
using System ; class GFG { public static void Main ( ) { int n = 8 ; int range = 12 ; for ( int i = 1 ; i <= range ; ++ i ) Console . Write ( n + " ▁ * ▁ " + i + " ▁ = ▁ " + n * i + " STRNEWLINE " ) ; } }
using System ; class GFG { static bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } static public void Main ( ) { if ( isPalindrome ( 1001 ) ) Console . WriteLine ( " Yes , ▁ it ▁ " + " is ▁ Palindrome " ) ; else Console . WriteLine ( " No , ▁ not ▁ " + " Palindrome " ) ; } }
using System ; public class GFG { static bool check ( int n ) { if ( n <= 0 ) return false ; return 1162261467 % n == 0 ; } public static void Main ( ) { int n = 9 ; if ( check ( n ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; public class GFG { static String printDemlo ( String str ) { int len = str . Length ; String res = " " ; for ( int i = 1 ; i <= len ; i ++ ) res += i . ToString ( ) ; for ( int i = len - 1 ; i >= 1 ; i -- ) res += i . ToString ( ) ; return res ; } public static void Main ( ) { String str = "111111" ; Console . WriteLine ( printDemlo ( str ) ) ; } }
using System ; class GFG { static int NumberofTimes ( String str ) { int temporary_sum = 0 , count = 0 ; while ( str . Length > 1 ) { temporary_sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) temporary_sum += ( str [ i ] - '0' ) ; str = temporary_sum + " " ; count ++ ; } return count ; } public static void Main ( ) { String s = "991" ; Console . Write ( NumberofTimes ( s ) ) ; } }
using System ; class GFG { static int calculateLeaps ( int n ) { if ( n == 0 n == 1 ) { return 1 ; } else { int leaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } } public static void Main ( ) { Console . WriteLine ( calculateLeaps ( 4 ) ) ; } }
using System ; class GFG { static int power ( long x , long y , long p ) { long res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return ( int ) res ; } static void printLastKDigits ( int a , int b , int k ) { Console . Write ( " Last ▁ " + k + " ▁ digits ▁ of ▁ " + a + " ^ " + b + " ▁ = ▁ " ) ; int temp = 1 ; for ( int i = 1 ; i <= k ; i ++ ) temp *= 10 ; temp = power ( a , b , temp ) ; for ( int i = 0 ; i < k - temp . ToString ( ) . Length ; i ++ ) Console . WriteLine ( 0 ) ; if ( temp != 0 ) Console . Write ( temp ) ; } public static void Main ( ) { int a = 11 ; int b = 3 ; int k = 2 ; printLastKDigits ( a , b , k ) ; } }
using System ; public class main { static int reverseDigits ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num /= 10 ; } return rev ; } static int square ( int num ) { return ( num * num ) ; } static bool checkAdamNumber ( int num ) { int a = square ( num ) ; int b = square ( reverseDigits ( num ) ) ; if ( a == reverseDigits ( b ) ) return true ; return false ; } public static void Main ( String [ ] args ) { int num = 12 ; if ( checkAdamNumber ( num ) ) Console . WriteLine ( " Adam ▁ Number " ) ; else Console . WriteLine ( " Not ▁ a ▁ Adam ▁ Number " ) ; } }
using System ; public class GFG { static int totalDigits ( int n ) { int number_of_digits = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; } public static void Main ( ) { int n = 13 ; Console . WriteLine ( totalDigits ( n ) ) ; } }
class GFG { static void numbersWith3Divisors ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; prime [ 0 ] = prime [ 1 ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } System . Console . WriteLine ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : ▁ " ) ; for ( int i = 0 ; i * i <= n ; i ++ ) if ( ! prime [ i ] ) System . Console . Write ( i * i + " ▁ " ) ; } public static void Main ( ) { int n = 96 ; numbersWith3Divisors ( n ) ; } }
using System ; class GFG { static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) Console . Write ( hexaDeciNum [ j ] ) ; } public static void Main ( String [ ] args ) { int n = 2545 ; decToHexa ( n ) ; } }
using System ; public class GFG { static void decToBinary ( int n ) { int [ ] binaryNum = new int [ 32 ] ; int i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = n / 2 ; i ++ ; } for ( int j = i - 1 ; j >= 0 ; j -- ) Console . Write ( binaryNum [ j ] ) ; } public static void Main ( ) { int n = 17 ; decToBinary ( n ) ; } }
using System ; class GFG { static long count_of_ways ( long n ) { long count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; } public static void Main ( ) { long n = 3 ; Console . WriteLine ( count_of_ways ( n ) ) ; } }
using System ; class GFG { static int flipSign ( int a ) { int neg = 0 ; int tmp = a < 0 ? 1 : - 1 ; while ( a != 0 ) { neg += tmp ; a += tmp ; } return neg ; } static bool areDifferentSign ( int a , int b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; } static int sub ( int a , int b ) { return a + flipSign ( b ) ; } static int mul ( int a , int b ) { if ( a < b ) return mul ( b , a ) ; int sum = 0 ; for ( int i = Math . Abs ( b ) ; i > 0 ; i -- ) sum += a ; if ( b < 0 ) sum = flipSign ( sum ) ; return sum ; } static int division ( int a , int b ) { if ( b == 0 ) throw new ArithmeticException ( ) ; int quotient = 0 , dividend ; int divisor = flipSign ( Math . Abs ( b ) ) ; for ( dividend = Math . Abs ( a ) ; dividend >= Math . Abs ( divisor ) ; dividend += divisor ) quotient ++ ; if ( areDifferentSign ( a , b ) ) quotient = flipSign ( quotient ) ; return quotient ; } public static void Main ( ) { Console . WriteLine ( " Subtraction ▁ is ▁ " + sub ( 4 , - 2 ) ) ; Console . WriteLine ( " Product ▁ is ▁ " + mul ( - 9 , 6 ) ) ; try { Console . WriteLine ( " Division ▁ is ▁ " + division ( 8 , 2 ) ) ; } catch ( Exception ) { Console . WriteLine ( " Exception ▁ : - ▁ Divide ▁ by ▁ 0" ) ; } } }
using System ; class GFG { static int numOfCombinations ( int [ ] arr , int N ) { int [ ] C = { 0 , 0 , 0 } ; for ( int i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; } public static void Main ( ) { int [ ] arr1 = { 1 , 5 , 7 , 2 , 9 , 14 } ; Console . WriteLine ( numOfCombinations ( arr1 , 6 ) ) ; int [ ] arr2 = { 3 , 6 , 9 , 12 } ; Console . WriteLine ( numOfCombinations ( arr2 , 4 ) ) ; } }
using System ; class GFG { static bool isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; } static bool isSumOfKprimes ( int N , int K ) { if ( N < 2 * K ) return false ; if ( K == 1 ) return isprime ( N ) ; if ( K == 2 ) { if ( N % 2 == 0 ) return true ; return isprime ( N - 2 ) ; } return true ; } public static void Main ( ) { int n = 10 , k = 2 ; if ( isSumOfKprimes ( n , k ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int GCD ( int num1 , int num2 ) { int Remainder ; while ( num2 != 0 ) { Remainder = num1 % num2 ; num1 = num2 ; num2 = Remainder ; } return num1 ; } static int FindLCM ( int a , int b ) { return ( a * b ) / GCD ( a , b ) ; } static int rangeDivisor ( int m , int n , int a , int b ) { int lcm = FindLCM ( a , b ) ; int a_divisor = n / a - ( m - 1 ) / a ; int b_divisor = n / b - ( m - 1 ) / b ; int common_divisor = n / lcm - ( m - 1 ) / lcm ; int ans = a_divisor + b_divisor - common_divisor ; return ans ; } public static void Main ( ) { int m = 3 , n = 11 , a = 2 , b = 3 ; Console . WriteLine ( rangeDivisor ( m , n , a , b ) ) ; m = 11 ; n = 1000000 ; a = 6 ; b = 35 ; Console . WriteLine ( rangeDivisor ( m , n , a , b ) ) ; } }
using System ; public class GFG { static void printUnique ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { int num = i ; bool [ ] visited = new bool [ 10 ] ; while ( num != 0 ) { if ( visited [ num % 10 ] ) break ; visited [ num % 10 ] = true ; num = num / 10 ; } if ( num == 0 ) Console . Write ( i + " ▁ " ) ; } } public static void Main ( ) { int l = 1 , r = 20 ; printUnique ( l , r ) ; } }
using System ; class GFG { static int findMinZero ( int p ) { int first = 1 , second = 1 ; int number = 2 , next = 1 ; while ( next > 0 ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; } public static void Main ( ) { int p = 7 ; Console . WriteLine ( " Minimal ▁ zero ▁ " + " is ▁ : " + findMinZero ( p ) ) ; } }
using System ; class GFG { static void printCubes ( int a , int b ) { for ( int i = a ; i <= b ; i ++ ) { for ( int j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { Console . Write ( j * j * j + " ▁ " ) ; break ; } } } } public static void Main ( ) { int a = 1 , b = 100 ; Console . WriteLine ( " Perfect ▁ cubes ▁ in " + " ▁ given ▁ range : " ) ; printCubes ( a , b ) ; } }
using System ; class BinaryToString { static string printBinary ( double num ) { if ( num >= 1 num <= 0 ) return " ERROR " ; string binary = " " ; double frac = 0.5 ; binary += " . " ; while ( num > 0 ) { if ( binary . Length >= 32 ) return " ERROR " ; if ( num >= frac ) { binary += "1" ; num -= frac ; } else binary += "0" ; frac /= 2 ; } return binary ; } public static void Main ( ) { String output = printBinary ( num1 ) ; Console . WriteLine ( " ( 0" + output + " ) ▁ in ▁ base ▁ 2" ) ; double num2 = 0.72 ; output = printBinary ( num2 ) ; Console . WriteLine ( " ( " + output + " ) ▁ " ) ; } }
using System ; class Digits { static long firstkdigits ( int n , int k ) { long product = 1 ; for ( int i = 0 ; i < n ; i ++ ) product *= n ; while ( ( int ) ( product / Math . Pow ( 10 , k ) ) != 0 ) product = product / 10 ; return product ; } public static void Main ( ) { int n = 15 ; int k = 4 ; Console . Write ( firstkdigits ( n , k ) ) ; } }
using System ; class GFG { static bool check ( String str ) { int n = str . Length ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 9 == 0 ) ; } public static void Main ( ) { String str = "99333" ; if ( check ( str ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = i ; j < N ; j ++ ) for ( int k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; } static void Main ( ) { int [ ] arr = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . Length ; Console . Write ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
using System ; class GFG { static int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { int res = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; } public static void Main ( ) { int [ ] arr = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . Length ; Console . Write ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
using System ; public class GCD { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findGCD ( int [ ] arr , int n ) { int result = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { result = gcd ( arr [ i ] , result ) ; if ( result == 1 ) { return 1 ; } } return result ; } public static void Main ( ) { int [ ] arr = { 2 , 4 , 6 , 8 , 16 } ; int n = arr . Length ; Console . Write ( findGCD ( arr , n ) ) ; } }
using System ; class Divisors { static int divSum ( int num ) { int result = 0 ; for ( int i = 1 ; i * i <= num ; ++ i ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return result ; } static bool isSuperPerfect ( int n ) { int n1 = divSum ( n ) ; return ( 2 * n == divSum ( n1 ) ) ; } public static void Main ( ) { int n = 16 ; Console . WriteLine ( ( isSuperPerfect ( n ) ? " Yes " : " No " ) ) ; n = 6 ; Console . WriteLine ( ( isSuperPerfect ( n ) ? " Yes " : " No " ) ) ; } }
using System ; class GFG { static bool isRefactorableNumber ( int n ) { int divCount = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; } public static void Main ( ) { int n = 8 ; if ( isRefactorableNumber ( n ) ) Console . WriteLine ( " yes " ) ; else Console . Write ( " no " ) ; n = 14 ; if ( isRefactorableNumber ( n ) ) Console . Write ( " yes " ) ; else Console . Write ( " no " ) ; } }
using System ; class GFG { static bool isPerfectSquare ( int n ) { int sq = ( int ) Math . Sqrt ( n ) ; return ( n == sq * sq ) ; } static int countPerfectDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { if ( isPerfectSquare ( i ) ) ++ count ; if ( n / i != i && isPerfectSquare ( n / i ) ) ++ count ; } } return count ; } static public void Main ( ) { int n = 16 ; Console . Write ( " Total ▁ perfect ▁ " + " divisors ▁ of ▁ " + n ) ; Console . WriteLine ( " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; n = 12 ; Console . Write ( " Total ▁ perfect ▁ " + " divisors ▁ of ▁ " + n ) ; Console . WriteLine ( " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; } }
using System ; class GFG { static void nearestGcd ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; ++ i ) { int closest = - 1 ; for ( int j = i - 1 , k = i + 1 ; j > 0 k <= n ; -- j , ++ k ) { if ( j >= 0 && __gcd ( arr [ i ] , arr [ j ] ) > 1 ) { closest = j + 1 ; break ; } if ( k < n && __gcd ( arr [ i ] , arr [ k ] ) > 1 ) { closest = k + 1 ; break ; } } Console . Write ( closest + " ▁ " ) ; } } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void Main ( ) { int [ ] arr = { 2 , 9 , 4 , 3 , 13 } ; int n = arr . Length ; nearestGcd ( arr , n ) ; } }
using System ; class GFG { static int MAX = 100001 ; static int [ ] prime = new int [ MAX + 1 ] ; static int [ ] countdiv = new int [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 2 ; i * i <= MAX ; ++ i ) { if ( prime [ i ] == 0 ) for ( int j = i * 2 ; j <= MAX ; j += i ) prime [ j ] = i ; } for ( int i = 1 ; i < MAX ; ++ i ) if ( prime [ i ] == 0 ) prime [ i ] = i ; } static int largestGCDSubsequence ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { int element = arr [ i ] ; while ( element > 1 ) { int div = prime [ element ] ; ++ countdiv [ div ] ; ans = Math . Max ( ans , countdiv [ div ] ) ; while ( element % div == 0 ) element /= div ; } } return ans ; } public static void Main ( ) { SieveOfEratosthenes ( ) ; int [ ] arr = { 10 , 15 , 7 , 25 , 9 , 35 } ; int size = arr . Length ; Console . WriteLine ( largestGCDSubsequence ( arr , size ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int countOfBinaryNumberLessThanN ( int N ) { Queue < int > q = new Queue < int > ( ) ; q . Enqueue ( 1 ) ; int cnt = 0 ; int t ; while ( q . Count > 0 ) { t = q . Peek ( ) ; q . Dequeue ( ) ; if ( t <= N ) { cnt ++ ; q . Enqueue ( t * 10 ) ; q . Enqueue ( t * 10 + 1 ) ; } } return cnt ; } static void Main ( ) { int N = 200 ; Console . WriteLine ( countOfBinaryNumberLessThanN ( N ) ) ; } }
using System ; class GFG { static int sumofproduct ( int n ) { int ans = 0 ; for ( int x = 1 ; x <= n ; x ++ ) { int y = n / x ; ans += ( y * x ) ; } return ans ; } static public void Main ( String [ ] args ) { int n = 10 ; Console . WriteLine ( sumofproduct ( n ) ) ; } }
using System ; class GFG { static int per ( int n ) { int a = 3 , b = 0 , c = 2 ; int m = 0 ; if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return c ; while ( n > 2 ) { m = a + b ; a = b ; b = c ; c = m ; n -- ; } return m ; } public static void Main ( ) { int n = 9 ; Console . WriteLine ( per ( n ) ) ; } }
using System ; public class GFG { static int fact ( int n ) { int num = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { num = num * i ; } return num ; } static int Special_Factorial_Number ( int k ) { for ( int i = 1 ; i <= k ; i ++ ) { if ( fact ( i ) % k == 0 ) { return i ; } } return 0 ; } public static void Main ( ) { int k = 16 ; Console . WriteLine ( Special_Factorial_Number ( k ) ) ; } }
using System ; class GFG { static int countMaxChoco ( int money , int price , int wrap ) { if ( money < price ) return 0 ; int choc = money / price ; choc = choc + ( choc - 1 ) / ( wrap - 1 ) ; return choc ; } public static void Main ( ) { int money = 15 ; int price = 1 ; int wrap = 3 ; Console . WriteLine ( countMaxChoco ( money , price , wrap ) ) ; } }
using System ; class GFG { static int gcd ( int i , int j ) { if ( i == j ) return i ; if ( i > j ) return gcd ( i - j , j ) ; return gcd ( i , j - i ) ; } static bool ispossible ( int x , int y , int a , int b ) { x = Math . Abs ( x ) ; y = Math . Abs ( y ) ; a = Math . Abs ( a ) ; b = Math . Abs ( b ) ; return ( gcd ( x , y ) == gcd ( a , b ) ) ; } public static void Main ( ) { int x = 35 , y = 15 ; int a = 20 , b = 25 ; if ( ispossible ( x , y , a , b ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; using System . Collections ; public class GFG { static int MAX = 10000 ; static ArrayList primes = new ArrayList ( MAX + 1 ) ; static void sieveSundaram ( ) { bool [ ] marked = new bool [ MAX / 2 + 1 ] ; for ( int i = 1 ; i <= ( Math . Sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . Add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . Add ( 2 * i + 1 ) ; } static bool isEquidigital ( int n ) { if ( n == 1 ) return true ; int original_no = n ; int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits ++ ; original_no = original_no / 10 ; } int pDigit = 0 , count_exp = 0 , p = 0 ; for ( int i = 0 ; ( int ) primes [ i ] <= n / 2 ; i ++ ) { while ( n % ( int ) primes [ i ] == 0 ) { p = ( int ) primes [ i ] ; n = n / p ; count_exp ++ ; } while ( p > 0 ) { pDigit ++ ; p = p / 10 ; } while ( count_exp > 1 ) { pDigit ++ ; count_exp = count_exp / 10 ; } } if ( n != 1 ) { while ( n > 0 ) { pDigit ++ ; n = n / 10 ; } } return ( pDigit == sumDigits ) ; } public static void Main ( ) { sieveSundaram ( ) ; Console . WriteLine ( " Printing ▁ first ▁ few ▁ Equidigital ▁ Numbers ▁ using ▁ isEquidigital ( ) " ) ; for ( int i = 1 ; i < 20 ; i ++ ) if ( isEquidigital ( i ) ) Console . Write ( i + " ▁ " ) ; } }
using System ; class GFG { static int getMaximumSumWithLCMN ( int N ) { int sum = 0 ; int LIM = ( int ) Math . Sqrt ( N ) ; for ( int i = 1 ; i <= LIM ; i ++ ) { if ( N % i == 0 ) { if ( i == ( N / i ) ) sum += i ; else sum += ( i + N / i ) ; } } return sum ; } public static void Main ( ) { int N = 12 ; Console . Write ( getMaximumSumWithLCMN ( N ) ) ; } }
using System ; public class GFG { static long gcd ( long a , long b ) { if ( a % b != 0 ) return gcd ( b , a % b ) ; else return b ; } static long lcm ( long n ) { long ans = 1 ; for ( long i = 1 ; i <= n ; i ++ ) ans = ( ans * i ) / ( gcd ( ans , i ) ) ; return ans ; } static public void Main ( ) { long n = 20 ; Console . WriteLine ( lcm ( n ) ) ; } }
using System ; class GFG { static float y ( float x ) { return 1 / ( 1 + x * x ) ; } static float trapezoidal ( float a , float b , float n ) { float h = ( b - a ) / n ; float s = y ( a ) + y ( b ) ; for ( int i = 1 ; i < n ; i ++ ) s += 2 * y ( a + i * h ) ; return ( h / 2 ) * s ; } public static void Main ( ) { float x0 = 0 ; float xn = 1 ; int n = 6 ; Console . Write ( " Value ▁ of ▁ integral ▁ is ▁ " + Math . Round ( trapezoidal ( x0 , xn , n ) * 10000.0 ) / 10000.0 ) ; } }
using System ; class GFG { static double numberOfDigits ( double n ) { if ( n == 1 ) return 1 ; double d = ( n * Math . Log10 ( 1.6180339887498948 ) ) - ( ( Math . Log10 ( 5 ) ) / 2 ) ; return Math . Ceiling ( d ) ; } public static void Main ( ) { double i ; for ( i = 1 ; i <= 10 ; i ++ ) Console . WriteLine ( " Number ▁ of ▁ Digits ▁ in ▁ F ( " + i + " ) ▁ - ▁ " + numberOfDigits ( i ) ) ; } }
using System ; class GFG { public static int countOddSquares ( int n , int m ) { return ( int ) Math . Pow ( ( double ) m , 0.5 ) - ( int ) Math . Pow ( ( double ) n - 1 , 0.5 ) ; } public static void Main ( ) { int n = 5 , m = 100 ; Console . Write ( " Count ▁ is ▁ " + countOddSquares ( n , m ) ) ; } }
using System ; class GFG { public static bool isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; } public static void Main ( ) { Console . WriteLine ( isPower ( 10 , 1 ) ? 1 : 0 ) ; Console . WriteLine ( isPower ( 1 , 20 ) ? 1 : 0 ) ; Console . WriteLine ( isPower ( 2 , 128 ) ? 1 : 0 ) ; Console . WriteLine ( isPower ( 2 , 30 ) ? 1 : 0 ) ; } }
using System ; class GFG { static double countSquares ( int a , int b ) { return ( Math . Floor ( Math . Sqrt ( b ) ) - Math . Ceiling ( Math . Sqrt ( a ) ) + 1 ) ; } public static void Main ( ) { int a = 9 , b = 25 ; Console . Write ( " Count ▁ of ▁ squares ▁ is ▁ " + ( int ) countSquares ( a , b ) ) ; } }
using System ; class GFG { static int findCountUpto ( int d ) { int GP1_Sum = 9 * ( ( int ) ( ( Math . Pow ( 10 , d ) ) - 1 ) / 9 ) ; int GP2_Sum = 9 * ( ( int ) ( ( Math . Pow ( 9 , d ) ) - 1 ) / 8 ) ; return GP1_Sum - GP2_Sum ; } public static void Main ( ) { int d = 1 ; Console . WriteLine ( findCountUpto ( d ) ) ; d = 2 ; Console . WriteLine ( findCountUpto ( d ) ) ; d = 4 ; Console . WriteLine ( findCountUpto ( d ) ) ; } }
using System ; class GFG { static void countDivisors ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( n / i == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) Console . Write ( " Even " ) ; else Console . Write ( " Odd " ) ; } public static void Main ( ) { Console . Write ( " The ▁ count ▁ of ▁ divisor : ▁ " ) ; countDivisors ( 10 ) ; } }
using System ; public class GFG { static int largestPower ( int n , int p ) { int x = 0 ; while ( n > 0 ) { n /= p ; x += n ; } return x ; } static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } static int modFact ( int n , int p ) { if ( n >= p ) { return 0 ; } int res = 1 ; bool [ ] isPrime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) isPrime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j <= n ; j += i ) { isPrime [ j ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime [ i ] ) { int k = largestPower ( n , i ) ; res = ( res * power ( i , k , p ) ) % p ; } } return res ; } static public void Main ( ) { int n = 25 , p = 29 ; Console . WriteLine ( modFact ( n , p ) ) ; } }
using System ; class GFG { static int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; } public static void Main ( ) { int m = 4 , n = 3 ; Console . WriteLine ( " Count ▁ of ▁ squares ▁ is ▁ " + countSquares ( m , n ) ) ; } }
using System ; public class GFG { static int add ( int x , int y ) { while ( y > 0 && y != 0 ) { x ++ ; y -- ; } while ( y < 0 && y != 0 ) { x -- ; y ++ ; } return x ; } public static void Main ( ) { Console . WriteLine ( add ( 43 , 23 ) ) ; Console . WriteLine ( add ( 43 , - 23 ) ) ; } }
using System ; public class GFG { static int countFact ( int low , int high ) { int fact = 1 , x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } int res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; } public static void Main ( ) { Console . Write ( " Count ▁ is ▁ " + countFact ( 2 , 720 ) ) ; } }
using System ; class GFG { static int getPeriod ( int n ) { int rem = 1 ; for ( int i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; int d = rem ; int count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; } public static void Main ( ) { Console . Write ( getPeriod ( 3 ) + " STRNEWLINE " ) ; Console . Write ( getPeriod ( 7 ) ) ; } }
using System ; class GFG { static int getRemainder ( int num , int divisor ) { return ( num - divisor * ( num / divisor ) ) ; } public static void Main ( ) { Console . Write ( getRemainder ( 100 , 7 ) ) ; } }
using System ; class GFG { static double sum ( int n ) { double sum = 0 ; int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( sum ( n ) ) ; } }
using System ; class GFG { static void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { Console . Write ( ( 10 * rem ) / n ) ; rem = ( 10 * rem ) % n ; } } public static void Main ( ) { int n = 7 , k = 3 ; print ( n , k ) ; Console . WriteLine ( ) ; n = 21 ; k = 4 ; print ( n , k ) ; } }
using System ; class GFG { static float sum ( int n ) { double i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return ( float ) s ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( " Sum ▁ is ▁ " + sum ( n ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } public static void Main ( ) { int a = 98 , b = 56 ; Console . WriteLine ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
using System ; class Rearrange { void rearrange ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] += ( arr [ arr [ i ] ] % n ) * n ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] /= n ; } void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( " " ) ; } public static void Main ( ) { Rearrange rearrange = new Rearrange ( ) ; int [ ] arr = { 3 , 2 , 0 , 1 } ; int n = arr . Length ; Console . Write ( " Given ▁ Array ▁ is ▁ : " ) ; rearrange . printArr ( arr , n ) ; rearrange . rearrange ( arr , n ) ; Console . Write ( " Modified ▁ Array ▁ is ▁ : " ) ; rearrange . printArr ( arr , n ) ; } }
using System ; class GFG { static void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; return ; } static void printSequencesRecur ( int [ ] arr , int n , int k , int index ) { int i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } } static void printSequences ( int n , int k ) { int [ ] arr = new int [ k ] ; printSequencesRecur ( arr , n , k , 0 ) ; return ; } public static void Main ( ) { int n = 3 ; int k = 2 ; printSequences ( n , k ) ; } }
using System ; class GFG { static bool isMultipleof5 ( int n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; } public static void Main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) Console . Write ( n + " ▁ is ▁ multiple ▁ of ▁ 5 STRNEWLINE " ) ; else Console . Write ( n + " ▁ is ▁ not ▁ a ▁ multiple ▁ of ▁ 5 STRNEWLINE " ) ; } }
using System ; class GFG { static void CalculatePairs ( int [ ] a , int n ) { int cnt_zero = 0 ; int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } int total_XOR_pairs = cnt_zero * cnt_one ; int total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; int total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; Console . WriteLine ( " cntXOR ▁ = ▁ " + total_XOR_pairs ) ; Console . WriteLine ( " cntAND ▁ = ▁ " + total_AND_pairs ) ; Console . WriteLine ( " cntOR ▁ = ▁ " + total_OR_pairs ) ; } public static void Main ( ) { int [ ] a = { 1 , 3 , 4 , 2 } ; int n = a . Length ; CalculatePairs ( a , n ) ; } }
using System ; class gfg { public void alternate ( ref int a , ref int b , ref int x ) { x = a + b - x ; } } class geek { public static int Main ( ) { gfg g = new gfg ( ) ; int a = - 10 ; int b = 15 ; int x = a ; Console . WriteLine ( " x ▁ is ▁ : ▁ { 0 } " , x ) ; g . alternate ( ref a , ref b , ref x ) ; Console . WriteLine ( " After ▁ change ▁ " ) ; Console . WriteLine ( " x ▁ is ▁ : ▁ { 0 } " , x ) ; return 0 ; } }
using System ; class GFG { static int highestPowerOf2 ( int n ) { return ( n & ( ~ ( n - 1 ) ) ) ; } public static void Main ( ) { int n = 48 ; Console . Write ( highestPowerOf2 ( n ) ) ; } }
using System ; class GFG { static void isSubsetAndZero ( int [ ] array , int length , int N ) { int arrAnd = array [ 0 ] ; for ( int i = 1 ; i < length ; i ++ ) { arrAnd = arrAnd & array [ i ] ; } if ( ( arrAnd & N ) == 0 ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } public static void Main ( ) { int [ ] array = { 1 , 2 , 4 } ; int length = array . Length ; int N = 3 ; isSubsetAndZero ( array , length , N ) ; } }
using System ; class GFG { static bool findParity ( int x ) { int y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( ( y & 1 ) > 0 ) return true ; return false ; } public static void Main ( ) { if ( ( findParity ( 9 ) == false ) ) Console . WriteLine ( " Even ▁ Parity " ) ; else Console . WriteLine ( " Odd ▁ Parity " ) ; if ( findParity ( 13 ) == false ) Console . WriteLine ( " Even ▁ Parity " ) ; else Console . WriteLine ( " Odd ▁ Parity " ) ; } }
using System ; class GFG { static bool allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return true ; return false ; } static bool bitsAreComplement ( int a , int b , int l , int r ) { int xor_value = a ^ b ; return allBitsSetInTheGivenRange ( xor_value , l , r ) ; } static public void Main ( ) { int a = 10 , b = 5 ; int l = 1 , r = 3 ; if ( bitsAreComplement ( a , b , l , r ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int calculateSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( " Sum ▁ of ▁ the ▁ series ▁ : ▁ " + calculateSum ( n ) ) ; } }
using System ; class GFG { static void printCombinations ( int [ ] a , int n , int m ) { for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int sum = 0 ; int num = 1 << ( n - 1 ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & num ) > 0 ) sum += a [ j ] ; else sum += ( - 1 * a [ j ] ) ; num = num >> 1 ; } if ( sum % m == 0 ) { num = 1 << ( n - 1 ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & num ) > 0 ) Console . Write ( " + " + a [ j ] + " ▁ " ) ; else Console . Write ( " - " + a [ j ] + " ▁ " ) ; num = num >> 1 ; } Console . Write ( " STRNEWLINE " ) ; } } } public static void Main ( ) { int [ ] a = { 3 , 5 , 6 , 8 } ; int n = a . Length ; int m = 5 ; printCombinations ( a , n , m ) ; } }
using System ; class GFG { static int __builtin_popcount ( int n ) { int d , t = 0 ; while ( n > 0 ) { d = n % 2 ; n = n / 2 ; if ( d == 1 ) t ++ ; } return t ; } static int smallerNumsWithSameSetBits ( int n ) { int temp = __builtin_popcount ( n ) ; int count = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( temp == __builtin_popcount ( i ) ) count ++ ; } return count ; } static public void Main ( String [ ] args ) { int n = 4 ; Console . WriteLine ( smallerNumsWithSameSetBits ( n ) ) ; } }
using System ; class GFG { static int multiplyWith4 ( int n ) { return ( n << 2 ) ; } public static void Main ( String [ ] args ) { int n = 4 ; Console . Write ( multiplyWith4 ( n ) ) ; } }
using System ; class GFG { static int evenbitsetnumber ( int n ) { int count = 0 , res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( evenbitsetnumber ( n ) ) ; } }
using System ; class GFG { static int getmsb ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; } static int getevenbits ( int n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 1 ) n = n >> 1 ; return n ; } static int setallevenbits ( int n ) { return n | getevenbits ( n ) ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( setallevenbits ( n ) ) ; } }
using System ; class GFG { static int oddbitsetnumber ( int n ) { int count = 0 ; int res = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( oddbitsetnumber ( n ) ) ; } }
using System ; class GFG { static int getmsb ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; } static int getevenbits ( int n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 0 ) n = n >> 1 ; return n ; } static int setalloddbits ( int n ) { return n | getevenbits ( n ) ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( setalloddbits ( n ) ) ; } }
using System ; class GFG { public static void printNumHavingAltBitPatrn ( int n ) { int curr_num = 1 , i = 1 ; Console . Write ( curr_num + " ▁ " ) ; while ( i != 0 ) { curr_num <<= 1 ; if ( n < curr_num ) break ; Console . Write ( curr_num + " ▁ " ) ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; Console . Write ( curr_num + " ▁ " ) ; } } public static void Main ( ) { int n = 50 ; printNumHavingAltBitPatrn ( n ) ; } }
using System ; class GFG { static int perfectPowerOf2 ( int n ) { int per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; } public static void Main ( ) { int n = 128 ; Console . WriteLine ( " Perfect ▁ power ▁ of ▁ 2 ▁ greater ▁ than ▁ " + n + " : ▁ " + perfectPowerOf2 ( n ) ) ; } }
using System ; class GFG { static void findUniquePair ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } Console . WriteLine ( " The ▁ unique ▁ pair ▁ is ▁ ( " + x + " , ▁ " + y + " ) " ) ; } public static void Main ( ) { int [ ] a = { 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 } ; int n = a . Length ; findUniquePair ( a , n ) ; } }
using System ; class GFG { static int countUnsetBits ( int n ) { int x = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return BitCount ( x ^ n ) ; } static int BitCount ( long x ) { int setBits = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; setBits ++ ; } return setBits ; } public static void Main ( String [ ] args ) { int n = 17 ; Console . WriteLine ( countUnsetBits ( n ) ) ; } }
using System ; class GFG { static int countBits ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n >>= 1 ; } return count ; } static public void Main ( ) { int i = 65 ; Console . Write ( countBits ( i ) ) ; } }
using System ; class GFG { static int toggle ( int n ) { int temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; } public static void Main ( ) { int n = 10 ; n = toggle ( n ) ; Console . Write ( n ) ; } }
using System ; class GFG { static int INT_MAX = 2147483647 ; static int isKthBitSet ( int x , int k ) { return ( ( x & ( 1 << ( k - 1 ) ) ) > 0 ) ? 1 : 0 ; } static int leftmostSetBit ( int x ) { int count = 0 ; while ( x > 0 ) { count ++ ; x = x >> 1 ; } return count ; } static int isBinPalindrome ( int x ) { int l = leftmostSetBit ( x ) ; int r = 1 ; while ( l > r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; } static int findNthPalindrome ( int n ) { int pal_count = 0 ; int i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) > 0 ) { pal_count ++ ; } if ( pal_count == n ) break ; } return i ; } static public void Main ( ) { int n = 9 ; Console . WriteLine ( findNthPalindrome ( n ) ) ; } }
using System ; class GFG { static bool LSB ( int num , int K ) { bool x = ( num & ( 1 << ( K - 1 ) ) ) != 0 ; return ( x ) ; } static void Main ( ) { int num = 10 , K = 4 ; if ( LSB ( num , K ) ) Console . Write ( "1" ) ; else Console . Write ( "0" ) ; } }
using System ; class GFG { static void areSame ( int a , int b ) { if ( ( a - b ) == 0 ) Console . Write ( " Same " ) ; else Console . Write ( " Not ▁ Same " ) ; } public static void Main ( ) { areSame ( 10 , 20 ) ; } }
using System ; namespace Toggle { public class GFG { static int toggleBitsFromLToR ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( n ^ num ) ; } public static void Main ( ) { int n = 50 ; int l = 2 , r = 5 ; Console . Write ( toggleBitsFromLToR ( n , l , r ) ) ; } } }
using System ; class GFG { static int getRightMostSetBit ( int n ) { if ( n == 0 ) return 0 ; return ( int ) ( ( Math . Log10 ( n & - n ) ) / Math . Log10 ( 2 ) ) + 1 ; } static int posOfRightMostDiffBit ( int m , int n ) { return getRightMostSetBit ( m ^ n ) ; } public static void Main ( ) { int m = 52 , n = 4 ; Console . Write ( " Position ▁ = ▁ " + posOfRightMostDiffBit ( m , n ) ) ; } }
using System ; class GFG { static int getNext ( int n ) { int c = n ; int c0 = 0 ; int c1 = 0 ; while ( ( ( c & 1 ) == 0 ) && ( c != 0 ) ) { c0 ++ ; c >>= 1 ; } while ( ( c & 1 ) == 1 ) { c1 ++ ; c >>= 1 ; } if ( c0 + c1 == 31 c0 + c1 == 0 ) return - 1 ; return n + ( 1 << c0 ) + ( 1 << ( c1 - 1 ) ) - 1 ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( getNext ( n ) ) ; n = 8 ; Console . WriteLine ( getNext ( n ) ) ; } }
using System ; class GFG { static int totalFlips ( string A , string B , string C , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == '1' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == '0' ) ++ count ; } return count ; } public static void Main ( ) { int N = 5 ; string a = "10100" ; string b = "00010" ; string c = "10011" ; Console . Write ( totalFlips ( a , b , c , N ) ) ; } }
using System ; class GFG { static void swapThree ( ref int a , ref int b , ref int c ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; } static void Main ( String [ ] args ) { int a = 10 , b = 20 , c = 30 ; Console . WriteLine ( " Before ▁ swapping ▁ a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b + " , c ▁ = ▁ " + c ) ; swapThree ( ref a , ref b , ref c ) ; Console . Write ( " After ▁ swapping ▁ a ▁ = ▁ " + a + " , ▁ b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } }
using System ; class GFG { static void findTwoMissingNumbers ( int [ ] arr , int n ) { int XOR = arr [ 0 ] ; for ( int i = 1 ; i < n - 2 ; i ++ ) XOR ^= arr [ i ] ; for ( int i = 1 ; i <= n ; i ++ ) XOR ^= i ; int set_bit_no = XOR & ~ ( XOR - 1 ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( int i = 1 ; i <= n ; i ++ ) { if ( ( i & set_bit_no ) > 0 ) x = x ^ i ; else y = y ^ i ; } Console . WriteLine ( " Two ▁ Missing ▁ Numbers ▁ are ▁ " ) ; Console . WriteLine ( x + " ▁ " + y ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 6 } ; int n = 2 + arr . Length ; findTwoMissingNumbers ( arr , n ) ; } }
using System ; public class GFG { public static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } public static char findProffesion ( int level , int pos ) { int c = countSetBits ( pos - 1 ) ; return ( c % 2 != 0 ) ? ' d ' : ' e ' ; } public static void Main ( string [ ] args ) { int level = 3 , pos = 4 ; string prof = ( findProffesion ( level , pos ) == ' e ' ) ? " Engineer " : " Doctor " ; Console . Write ( prof ) ; } }
using System ; class GFG { static int rand2 ( ) { Random rand = new Random ( ) ; return ( rand . Next ( ) & 1 ) ; } static int rand3 ( ) { int r = 2 * rand2 ( ) + rand2 ( ) ; if ( r < 3 ) return r ; return rand3 ( ) ; } static void Main ( ) { for ( int i = 0 ; i < 100 ; i ++ ) Console . Write ( rand3 ( ) ) ; } }
using System ; class GFG { static void findpair ( int l , int r ) { int ans1 = l ; int ans2 = 2 * l ; Console . WriteLine ( ans1 + " , ▁ " + ans2 ) ; } public static void Main ( ) { int l = 1 , r = 10 ; findpair ( l , r ) ; } }
using System ; class GFG { static bool ElementsCalculationFunc ( int [ ] pre , int [ ] maxx , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; } static void MaxNumberOfElements ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; for ( int i = 0 ; i <= n ; ++ i ) { pre [ i ] = 0 ; maxx [ i ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] ; maxx [ i ] = Math . Max ( maxx [ i - 1 ] , a [ i - 1 ] ) ; } int l = 1 , r = n , ans = 0 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( ElementsCalculationFunc ( pre , maxx , mid - 1 , k , n ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } Console . Write ( ( int ) ans + " STRNEWLINE " ) ; } public static void Main ( ) { int [ ] arr = { 2 , 4 , 9 } ; int n = arr . Length ; int k = 3 ; MaxNumberOfElements ( arr , n , k ) ; } }
using System ; class GFG { static int MAX_STR_LEN = 1000 ; static bool [ , ] P = new bool [ MAX_STR_LEN , MAX_STR_LEN ] ; static int [ ] Kpal = new int [ MAX_STR_LEN ] ; static void checkSubStrPal ( string str , int n ) { for ( int i = 0 ; i < MAX_STR_LEN ; i ++ ) { for ( int j = 0 ; j < MAX_STR_LEN ; j ++ ) P [ i , j ] = false ; Kpal [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) P [ i , i ] = true ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( str [ i ] == str [ i + 1 ] ) P [ i , i + 1 ] = true ; for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 , j - 1 ] ) P [ i , j ] = true ; } } } static void countKPalindromes ( int i , int j , int k ) { if ( i == j ) { Kpal [ k ] ++ ; return ; } if ( P [ i , j ] == false ) return ; Kpal [ k ] ++ ; int mid = ( i + j ) / 2 ; if ( ( j - i + 1 ) % 2 == 1 ) mid -- ; countKPalindromes ( i , mid , k + 1 ) ; } static void printKPalindromes ( string s ) { int n = s . Length ; checkSubStrPal ( s , n ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n - i ; j ++ ) countKPalindromes ( j , j + i , 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( Kpal [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } static void Main ( ) { string s = " abacaba " ; printKPalindromes ( s ) ; } }
using System ; class Country { public static void countCountries ( int [ ] ans , int N ) { int total_countries = 0 , i = 0 ; while ( i < N ) { int curr_size = ans [ i ] ; int num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { Console . Write ( " Invalid ▁ Answer STRNEWLINE " ) ; return ; } else num -- ; i ++ ; } total_countries ++ ; } Console . Write ( " There ▁ are ▁ " + total_countries + " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . STRNEWLINE " ) ; } public static void Main ( ) { int [ ] ans = { 1 , 1 , 2 , 2 , 4 , 4 , 4 , 4 } ; int n = 8 ; countCountries ( ans , n ) ; } }
using System ; class GFG { public static bool check_elements ( int [ ] arr , int n , int A , int B ) { int range = B - A ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . Abs ( arr [ i ] ) >= A && Math . Abs ( arr [ i ] ) <= B ) { int z = Math . Abs ( arr [ i ] ) - A ; if ( arr [ z ] > 0 ) { arr [ z ] = arr [ z ] * - 1 ; } } } int count = 0 ; for ( int i = 0 ; i <= range && i < n ; i ++ ) { if ( arr [ i ] > 0 ) return false ; else count ++ ; } if ( count != ( range + 1 ) ) return false ; return true ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 4 , 5 , 2 , 7 , 8 , 3 } ; int n = arr . Length ; int A = 2 , B = 5 ; if ( check_elements ( arr , n , A , B ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { public static int findMinRec ( int [ ] A , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . Min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; } static public void Main ( ) { int [ ] A = { 1 , 4 , 45 , 6 , - 50 , 10 , 2 } ; int n = A . Length ; Console . WriteLine ( findMinRec ( A , n ) ) ; } }
using System ; class GFG { static bool isPossible ( int [ ] arr , int n , int m , int curr_min ) { int studentsRequired = 1 ; int curr_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > curr_min ) return false ; if ( curr_sum + arr [ i ] > curr_min ) { studentsRequired ++ ; curr_sum = arr [ i ] ; if ( studentsRequired > m ) return false ; } else curr_sum += arr [ i ] ; } return true ; } static int findPages ( int [ ] arr , int n , int m ) { long sum = 0 ; if ( n < m ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; int start = 0 , end = ( int ) sum ; int result = int . MaxValue ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( isPossible ( arr , n , m , mid ) ) { result = mid ; end = mid - 1 ; } else start = mid + 1 ; } return result ; } static public void Main ( ) { int [ ] arr = { 12 , 34 , 67 , 90 } ; int n = arr . Length ; Console . WriteLine ( " Minimum ▁ number ▁ of ▁ pages ▁ = ▁ " + findPages ( arr , n , m ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { public static int countDistinct ( int [ ] arr , int n ) { HashSet < int > hs = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { hs . Add ( arr [ i ] ) ; } return hs . Count ; } public static void Main ( ) { int [ ] arr = new int [ ] { 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 } ; Console . WriteLine ( countDistinct ( arr , arr . Length ) ) ; } }
using System ; public class GFG { static int findOptimalSolution ( int [ ] a , int N ) { Array . Sort ( a ) ; int points = 0 ; for ( int i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; } static public void Main ( ) { int [ ] a = { 1 , 4 , 2 , 3 , 9 } ; int N = a . Length ; Console . WriteLine ( findOptimalSolution ( a , N ) ) ; } }
using System ; public class Improve { static int number_of_tower ( int [ ] house , int range , int n ) { Array . Sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; } public static void Main ( ) { int [ ] house = { 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 } ; int range = 2 ; int n = house . Length ; Console . WriteLine ( number_of_tower ( house , range , n ) ) ; } }
using System ; public class GFG { static bool isAlphabaticOrder ( String s ) { int n = s . Length ; char [ ] c = new char [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; } Array . Sort ( c ) ; for ( int i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; } static public void Main ( ) { String s = " aabbbcc " ; if ( isAlphabaticOrder ( s ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class SortExample { static void printOrder ( int [ ] arr , int k ) { int n = arr . Length ; Array . Sort ( arr , 0 , k ) ; Array . Sort ( arr , k , n - k ) ; Array . Reverse ( arr , k , n - k ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 } ; int k = 4 ; printOrder ( arr , k ) ; Console . Write ( " { 0 } " , String . Join ( " ▁ " , arr ) ) ; } }
using System ; class GFG { static void descOrder ( char [ ] s ) { Array . Sort ( s ) ; reverse ( s ) ; } static void reverse ( char [ ] a ) { int i , n = a . Length ; char t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } } public static void Main ( String [ ] args ) { char [ ] s = " geeksforgeeks " . ToCharArray ( ) ; Console . WriteLine ( String . Join ( " " , s ) ) ; } }
using System ; public class GFG { static int MAX = 1000 ; static int findDuplicate ( int [ ] arr , int n , int k ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { Console . WriteLine ( " Out ▁ of ▁ range " ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = arr . Length ; Console . WriteLine ( findDuplicate ( arr , n , k ) ) ; } }
using System ; class Test { static void pendulumArrangement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int [ ] op = new int [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; Console . Write ( " Pendulum ▁ arrangement : " ) ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( op [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] arr = { 14 , 6 , 19 , 21 , 12 } ; pendulumArrangement ( arr , arr . Length ) ; } }
using System ; class GFG { static long minValue ( int [ ] a , int [ ] b , int n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; long result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += ( a [ i ] * b [ n - i - 1 ] ) ; return result ; } public static void Main ( ) { int [ ] a = { 3 , 1 , 1 } ; int [ ] b = { 6 , 5 , 4 } ; int n = a . Length ; Console . Write ( minValue ( a , b , n ) ) ; } }
using System ; class GFG { public static void printMaxNumber ( int n ) { if ( n % 2 != 0 ) { Console . Write ( "7" ) ; for ( int i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) Console . Write ( "1" ) ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) Console . Write ( "1" ) ; } } public static void Main ( String [ ] args ) { int n = 5 ; printMaxNumber ( n ) ; } }
using System ; class GFG { static int sorted_partitions ( int [ ] arr ) { int n = arr . Length ; int [ ] right_min = new int [ n + 1 ] ; right_min [ n ] = int . MaxValue ; for ( int i = n - 1 ; i >= 0 ; i -- ) { right_min [ i ] = Math . Min ( right_min [ i + 1 ] , arr [ i ] ) ; } int partitions = 0 ; for ( int current_max = arr [ 0 ] , i = 0 ; i < n ; i ++ ) { current_max = Math . Max ( current_max , arr [ i ] ) ; if ( current_max <= right_min [ i + 1 ] ) partitions ++ ; } return partitions ; } public static void Main ( ) { int [ ] arr = { 3 , 1 , 2 , 4 , 100 , 7 , 9 } ; int ans = sorted_partitions ( arr ) ; Console . WriteLine ( ans ) ; } }
using System ; using System . Linq ; class GfG { public static int getMinCost ( int [ ] arr , int n ) { int min_ele = arr . Min ( ) ; return min_ele * ( n - 1 ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 2 , 5 } ; int n = arr . Length ; Console . WriteLine ( getMinCost ( arr , n ) ) ; } }
using System ; class GFG { public static void Main ( ) { string st = " NNNWEWESSS " ; int len = st . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( st [ i ] == ' N ' ) n += 1 ; if ( st [ i ] == ' S ' ) s += 1 ; if ( st [ i ] == ' W ' ) w += 1 ; if ( st [ i ] == ' E ' ) e += 1 ; } if ( n == s && w == e ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; using System . Linq ; public class GFG { static int cost ( int [ ] a , int n ) { return ( n - 1 ) * a . Min ( ) ; } static public void Main ( ) { int [ ] a = { 4 , 3 , 2 } ; int n = a . Length ; Console . WriteLine ( cost ( a , n ) ) ; } }
using System ; class GFG { static int minCost ( int [ ] coin , int n , int k ) { Array . Sort ( coin ) ; int coins_needed = ( int ) Math . Ceiling ( 1.0 * n / ( k + 1 ) ) ; int ans = 0 ; for ( int i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; } public static void Main ( ) { int [ ] coin = { 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 } ; int n = coin . Length ; int k = 3 ; Console . Write ( minCost ( coin , n , k ) ) ; } }
using System ; class GFG { static int countOddNumber ( int row_num ) { int count = 0 ; while ( row_num > 0 ) { count += row_num & 1 ; row_num >>= 1 ; } return ( 1 << count ) ; } static void gouldSequence ( int n ) { for ( int row_num = 0 ; row_num < n ; row_num ++ ) { Console . Write ( countOddNumber ( row_num ) + " ▁ " ) ; } } public static void Main ( ) { int n = 16 ; gouldSequence ( n ) ; } }
using System ; class GFG { static int countWays ( int n ) { int [ ] A = new int [ n + 1 ] ; int [ ] B = new int [ n + 1 ] ; A [ 0 ] = 1 ; A [ 1 ] = 0 ; B [ 0 ] = 0 ; B [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] ; B [ i ] = A [ i - 1 ] + B [ i - 2 ] ; } return A [ n ] ; } public static void Main ( ) { int n = 8 ; Console . WriteLine ( countWays ( n ) ) ; } }
using System ; class GFG { static int sequence ( int n ) { if ( n == 1 n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; } public static void Main ( ) { int n = 10 ; Console . Write ( sequence ( n ) ) ; } }
using System ; class GFG { static int numberOfWays ( int x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; } public static void Main ( ) { int x = 3 ; Console . WriteLine ( numberOfWays ( x ) ) ; } }
using System ; class GFG { static int numberOfWays ( int x ) { int [ ] dp = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; } public static void Main ( ) { int x = 3 ; Console . WriteLine ( numberOfWays ( x ) ) ; } }
static int findLongestRepeatingSubSeq ( String str ) { int n = str . Length ; int [ , ] dp = new int [ n + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i , j ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = Math . Max ( dp [ i , j - 1 ] , dp [ i - 1 , j ] ) ; } } return dp [ n , n ] ; }
using System ; class GFG { static int waysToArrange ( int N , int K , int [ ] k ) { int [ , ] C = new int [ N + 1 , N + 1 ] ; int i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = ( C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ) ; } } int [ ] dp = new int [ K + 1 ] ; int count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 , k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; } static void Main ( ) { int N = 4 ; int [ ] k = new int [ ] { 2 , 2 } ; int K = k . Length ; Console . Write ( waysToArrange ( N , K , k ) ) ; } }
using System ; class GFG { static int minCells ( int [ , ] mat , int m , int n ) { int [ , ] dp = new int [ m , n ] ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i , j ] = int . MaxValue ; dp [ 0 , 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i , j ] != int . MaxValue && ( j + mat [ i , j ] ) < n && ( dp [ i , j ] + 1 ) < dp [ i , j + mat [ i , j ] ] ) dp [ i , j + mat [ i , j ] ] = dp [ i , j ] + 1 ; if ( dp [ i , j ] != int . MaxValue && ( i + mat [ i , j ] ) < m && ( dp [ i , j ] + 1 ) < dp [ i + mat [ i , j ] , j ] ) dp [ i + mat [ i , j ] , j ] = dp [ i , j ] + 1 ; } } if ( dp [ m - 1 , n - 1 ] != int . MaxValue ) return dp [ m - 1 , n - 1 ] ; return - 1 ; } public static void Main ( ) { int [ , ] mat = { { 2 , 3 , 2 , 1 , 4 } , { 3 , 2 , 5 , 8 , 2 } , { 1 , 1 , 2 , 2 , 1 } } ; int m = 3 , n = 5 ; Console . WriteLine ( " Minimum ▁ number ▁ of ▁ " + " cells ▁ = ▁ " + minCells ( mat , m , n ) ) ; } }
using System ; public class GFG { static readonly int R = 3 ; static readonly int C = 3 ; static int cal ( int [ , ] ones , int x , int y , int k ) { return ones [ x + k - 1 , y + k - 1 ] - ones [ x - 1 , y + k - 1 ] - ones [ x + k - 1 , y - 1 ] + ones [ x - 1 , y - 1 ] ; } static int sol ( int [ , ] mat ) { int ans = 0 ; int val = 0 ; int [ , ] ones = new int [ R + 1 , C + 1 ] ; for ( int i = 1 ; i <= R ; i ++ ) for ( int j = 1 ; j <= C ; j ++ ) { if ( mat [ i - 1 , j - 1 ] == 1 ) val = 1 ; ones [ i , j ] = ones [ i - 1 , j ] + ones [ i , j - 1 ] - ones [ i - 1 , j - 1 ] + ( val ) ; } for ( int k = 1 ; k <= Math . Min ( R , C ) ; k ++ ) for ( int i = 1 ; i + k - 1 <= R ; i ++ ) for ( int j = 1 ; j + k - 1 <= C ; j ++ ) ans = Math . Max ( ans , ( ones [ R , C ] + k * k - 2 * cal ( ones , i , j , k ) ) ) ; return ans ; } static public void Main ( ) { int [ , ] mat = { { 0 , 0 , 1 } , { 0 , 0 , 1 } , { 1 , 0 , 1 } } ; Console . WriteLine ( sol ( mat ) ) ; } }
using System ; class GFG { static int getMinSteps ( int n ) { int [ ] table = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . Min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . Min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( getMinSteps ( n ) ) ; } }
using System ; class GFG { static int longestSubseqWithDiffOne ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . Max ( dp [ i ] , dp [ j ] + 1 ) ; } } int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 3 , 2 } ; int n = arr . Length ; Console . Write ( longestSubseqWithDiffOne ( arr , n ) ) ; } }
using System ; class GFG { static int catalanDP ( int n ) { int [ ] catalan = new int [ n + 1 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( int j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; } static int countWays ( int n ) { if ( n < 1 ) { Console . WriteLine ( " Invalid " ) ; return 0 ; } return catalanDP ( n / 2 ) ; } static public void Main ( ) { Console . WriteLine ( countWays ( 6 ) + " ▁ " ) ; } }
using System ; class GFG { static int MAX = 101 ; static int [ , , , ] dp = new int [ MAX , MAX , MAX , 4 ] ; static int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( dp [ p , q , r , last ] != - 1 ) return dp [ p , q , r , last ] ; if ( last == 0 ) dp [ p , q , r , last ] = countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; else if ( last == 1 ) dp [ p , q , r , last ] = countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; else dp [ p , q , r , last ] = countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return dp [ p , q , r , last ] ; } static int countUtil ( int p , int q , int r ) { for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) for ( int k = 0 ; k < MAX ; k ++ ) for ( int l = 0 ; l < 4 ; l ++ ) dp [ i , j , k , l ] = - 1 ; } static void Main ( ) { int p = 1 , q = 1 , r = 1 ; Console . WriteLine ( countUtil ( p , q , r ) ) ; } }
using System ; class GFG { static int countDer ( int n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; } public static void Main ( ) { int n = 4 ; Console . Write ( " Count ▁ of ▁ Derangements ▁ is ▁ " + countDer ( n ) ) ; } }
using System ; class GFG { static int countDer ( int n ) { int [ ] der = new int [ n + 1 ] ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; } public static void Main ( ) { int n = 4 ; Console . Write ( " Count ▁ of ▁ Derangements ▁ is ▁ " + countDer ( n ) ) ; } }
using System ; class GFG { static int countSol ( int [ ] coeff , int n , int rhs ) { int [ ] dp = new int [ rhs + 1 ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; } public static void Main ( ) { int [ ] coeff = { 2 , 2 , 5 } ; int rhs = 4 ; int n = coeff . Length ; Console . Write ( countSol ( coeff , n , rhs ) ) ; } }
using System ; class GFG { static int findWays ( int m , int n , int x ) { int [ , ] table = new int [ n + 1 , x + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= x ; j ++ ) table [ i , j ] = 0 ; for ( int j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 , j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 1 ; j <= x ; j ++ ) for ( int k = 1 ; k <= m && k < j ; k ++ ) table [ i , j ] += table [ i - 1 , j - k ] ; return table [ n , x ] ; } public static void Main ( ) { Console . WriteLine ( findWays ( 4 , 2 , 1 ) ) ; Console . WriteLine ( findWays ( 2 , 2 , 3 ) ) ; Console . WriteLine ( findWays ( 6 , 3 , 8 ) ) ; Console . WriteLine ( findWays ( 4 , 2 , 5 ) ) ; Console . WriteLine ( findWays ( 4 , 3 , 5 ) ) ; } }
using System ; public class GFG { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( char [ ] seq , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } public static void Main ( ) { String seq = " GEEKSFORGEEKS " ; int n = seq . Length ; Console . Write ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " + lps ( seq . ToCharArray ( ) , 0 , n - 1 ) ) ; } }
using System ; class GFG { static int findCount ( string str1 , string str2 ) { int len = str1 . Length ; int len2 = str2 . Length ; int ans = Int32 . MaxValue ; int [ ] hash1 = new int [ 26 ] ; int [ ] hash2 = new int [ 26 ] ; for ( int i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] != 0 ) ans = Math . Min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; } public static void Main ( ) { string str1 = " geeksclassesatnoida " ; string str2 = " sea " ; Console . WriteLine ( findCount ( str1 , str2 ) ) ; } }
using System ; class GFG { public static bool isVowel ( char c ) { string vowel = " aeiou " ; for ( int i = 0 ; i < vowel . Length ; ++ i ) { if ( vowel [ i ] == c ) { return true ; } } return false ; } public static bool printRLE ( string str , string typed ) { int n = str . Length , m = typed . Length ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != typed [ j ] ) { return false ; } if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) { return false ; } } return true ; } public static void Main ( string [ ] args ) { string name = " alex " , typed = " aaalaeex " ; if ( printRLE ( name , typed ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; using System . Collections . Generic ; class GFG { static String censor ( String text , String word ) { String [ ] word_list = text . Split ( ' ▁ ' ) ; String result = " " ; String stars = " " ; for ( int i = 0 ; i < word . Length ; i ++ ) stars += ' * ' ; int index = 0 ; foreach ( String i in word_list ) { if ( i . CompareTo ( word ) == 0 ) word_list [ index ] = stars ; index ++ ; } foreach ( String i in word_list ) result += i + " ▁ " ; return result ; } public static void Main ( String [ ] args ) { String extract = " GeeksforGeeks ▁ is ▁ a ▁ computer ▁ science ▁ " + " portal ▁ for ▁ geeks . ▁ I ▁ am ▁ pursuing ▁ my ▁ " + " major ▁ in ▁ computer ▁ science . ▁ " ; String cen = " computer " ; Console . WriteLine ( censor ( extract , cen ) ) ; } }
using System ; class GFG { static int CountSubstring ( char [ ] str , int n ) { int ans = ( n * ( n + 1 ) ) / 2 ; int a_index = 0 ; int b_index = 0 ; int c_index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' a ' ) { a_index = i + 1 ; ans -= Math . Min ( b_index , c_index ) ; } else if ( str [ i ] == ' b ' ) { b_index = i + 1 ; ans -= Math . Min ( a_index , c_index ) ; } else { c_index = i + 1 ; ans -= Math . Min ( a_index , b_index ) ; } } return ans ; } public static void Main ( ) { char [ ] str = " babac " . ToCharArray ( ) ; int n = str . Length ; Console . WriteLine ( CountSubstring ( str , n ) ) ; } }
using System ; class gfg { static bool isValid ( string str , int len ) { for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; } public static void Main ( ) { string str = "0110" ; int len = str . Length ; if ( isValid ( str , len ) ) Console . Write ( " Valid " ) ; else Console . Write ( " Invalid " ) ; } }
using System ; class GFG { static int check ( String s , int K ) { for ( int ch = 0 ; ch < 26 ; ch ++ ) { char c = ( char ) ( ' a ' + ch ) ; int last = - 1 ; bool found = true ; for ( int i = 0 ; i < K ; i ++ ) if ( s [ i ] == c ) last = i ; if ( last == - 1 ) continue ; for ( int i = K ; i < s . Length ; i ++ ) { if ( s [ i ] == c ) last = i ; if ( last <= ( i - K ) ) { found = false ; break ; } } if ( found ) return 1 ; } return 0 ; } static int binarySearch ( String s ) { int low = 1 , high = s . Length ; int ans = 0 ; while ( low <= high ) { int mid = ( high + low ) >> 1 ; if ( check ( s , mid ) == 1 ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; } public static void Main ( ) { String s = " abcde " ; Console . WriteLine ( binarySearch ( s ) ) ; s = " aaaa " ; Console . WriteLine ( binarySearch ( s ) ) ; } }
using System ; public class Gfg { static int vowel_calc ( string s ) { int n = s . Length ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) arr [ i ] = n ; else arr [ i ] = ( n - i ) + arr [ i - 1 ] - i ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char ch = s [ i ] ; if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) sum += arr [ i ] ; } return sum ; } public static void Main ( ) { string s = " daceh " ; Console . Write ( vowel_calc ( s ) ) ; } }
using System ; class GFG { static bool ispalindrome ( int x ) { int ans = 0 ; int temp = x ; while ( temp > 0 ) { ans = 10 * ans + temp % 10 ; temp = temp / 10 ; } return ans == x ; } static string Reverse ( string s ) { char [ ] charArray = s . ToCharArray ( ) ; Array . Reverse ( charArray ) ; return new string ( charArray ) ; } static int SuperPalindromes ( int L , int R ) { int LIMIT = 100000 ; int ans = 0 ; for ( int i = 0 ; i < LIMIT ; i ++ ) { string s = i . ToString ( ) ; string rs = s . Substring ( 0 , Math . Max ( 1 , s . Length - 1 ) ) ; rs = Reverse ( rs ) ; string p = s + rs ; int p_sq = ( int ) ( Math . Pow ( Int32 . Parse ( p ) , 2 ) ) ; if ( p_sq > R ) { break ; } if ( p_sq >= L && ispalindrome ( p_sq ) ) { ans = ans + 1 ; } } for ( int i = 0 ; i < LIMIT ; i ++ ) { string s = i . ToString ( ) ; string rs = Reverse ( s ) ; string p = s + rs ; int p_sq = ( int ) ( Math . Pow ( Int32 . Parse ( p ) , 2 ) ) ; if ( p_sq > R ) { break ; } if ( p_sq >= L && ispalindrome ( p_sq ) ) { ans = ans + 1 ; } } return ans ; } public static void Main ( ) { string L = "4" ; String R = "1000" ; Console . WriteLine ( SuperPalindromes ( Int32 . Parse ( L ) , Int32 . Parse ( R ) ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void solve ( string s , int k ) { int count = 0 , length = 0 , pos = 0 ; Dictionary < char , int > m = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( m . ContainsKey ( s [ i ] ) ) m [ s [ i ] ] ++ ; else m [ s [ i ] ] = 1 ; length ++ ; if ( length > k ) { m [ s [ pos ] ] -- ; pos ++ ; length -- ; } if ( length == k && m [ s [ i ] ] == length ) count ++ ; } Console . WriteLine ( count ) ; } public static void Main ( ) { string s = " aaaabbbccdddd " ; int k = 4 ; solve ( s , k ) ; } }
using System ; using System . Collections . Generic ; class GFG { public static bool solve ( String n , int l ) { if ( l < 3 ) { if ( int . Parse ( n ) % 8 == 0 ) return true ; n = reverse ( n ) ; if ( int . Parse ( n ) % 8 == 0 ) return true ; return false ; } int [ ] hash = new int [ 10 ] ; for ( int i = 0 ; i < l ; i ++ ) hash [ n [ i ] - '0' ] ++ ; for ( int i = 104 ; i < 1000 ; i += 8 ) { int dup = i ; int [ ] freq = new int [ 10 ] ; freq [ dup % 10 ] ++ ; dup = dup / 10 ; freq [ dup % 10 ] ++ ; dup = dup / 10 ; freq [ dup % 10 ] ++ ; dup = i ; if ( freq [ dup % 10 ] > hash [ dup % 10 ] ) continue ; dup = dup / 10 ; if ( freq [ dup % 10 ] > hash [ dup % 10 ] ) continue ; dup = dup / 10 ; if ( freq [ dup % 10 ] > hash [ dup % 10 ] ) continue ; return true ; } return false ; } static String reverse ( String input ) { char [ ] a = input . ToCharArray ( ) ; int l , r = 0 ; r = a . Length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . Join ( " " , a ) ; } public static void Main ( String [ ] args ) { String number = "31462708" ; int l = number . Length ; if ( solve ( number , l ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static String newString ( String s , int k ) { String X = " " ; while ( s . Length > 0 ) { char temp = s [ 0 ] ; for ( int i = 1 ; i < k && i < s . Length ; i ++ ) { if ( s [ i ] < temp ) { temp = s [ i ] ; } } X = X + temp ; for ( int i = 0 ; i < k ; i ++ ) { if ( s [ i ] == temp ) { s = s . Substring ( 0 , i ) + s . Substring ( i + 1 ) ; break ; } } } return X ; } public static void Main ( String [ ] args ) { String s = " gaurang " ; int k = 3 ; Console . Write ( newString ( s , k ) ) ; } }
using System ; public class Node { static void strToBinary ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { int val = s [ i ] ; String bin = " " ; while ( val > 0 ) { if ( val % 2 == 1 ) { bin += '1' ; } else bin += '0' ; val /= 2 ; } bin = reverse ( bin ) ; Console . Write ( bin + " ▁ " ) ; } } static String reverse ( String input ) { char [ ] a = input . ToCharArray ( ) ; int l , r = 0 ; r = a . Length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . Join ( " " , a ) ; } public static void Main ( String [ ] args ) { String s = " geeks " ; strToBinary ( s ) ; } }
using System ; class GFG { static String printSequence ( string [ ] arr , string input ) { string output = " " ; int n = input . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( input [ i ] == ' ▁ ' ) output = output + "0" ; else { int position = input [ i ] - ' A ' ; output = output + arr [ position ] ; } } return output ; } public static void Main ( ) { string [ ] str = { "2" , "22" , "222" , "3" , "33" , "333" , "4" , "44" , "444" , "5" , "55" , "555" , "6" , "66" , "666" , "7" , "77" , "777" , "7777" , "8" , "88" , "888" , "9" , "99" , "999" , "9999" } ; string input = " GEEKSFORGEEKS " ; Console . WriteLine ( printSequence ( str , input ) ) ; } }
using System ; public class GfG { public static bool isEven ( string s1 ) { int l = s1 . Length ; bool dotSeen = false ; for ( int i = l - 1 ; i >= 0 ; i -- ) { if ( s1 [ i ] == '0' && dotSeen == false ) continue ; if ( s1 [ i ] == ' . ' ) { dotSeen = true ; continue ; } if ( ( s1 [ i ] - '0' ) % 2 == 0 ) return true ; return false ; } return false ; } public static void Main ( ) { string s1 = "100.70" ; if ( isEven ( s1 ) ) Console . WriteLine ( " Even " ) ; else Console . WriteLine ( " Odd " ) ; } }
using System ; class GFG { static int NO_OF_CHARS = 256 ; static int max_distinct_char ( String str , int n ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str [ i ] ] ++ ; } int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; } static int smallesteSubstr_maxDistictChar ( String str ) { int n = str . Length ; int max_distinct = max_distinct_char ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { String subs = null ; if ( i < j ) subs = str . Substring ( i , str . Length - j ) ; else subs = str . Substring ( j , str . Length - i ) ; int subs_lenght = subs . Length ; int sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; } static public void Main ( String [ ] args ) { String str = " AABBBCBB " ; int len = smallesteSubstr_maxDistictChar ( str ) ; Console . WriteLine ( " ▁ The ▁ length ▁ of ▁ the ▁ smallest ▁ substring " + " ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ " + " characters ▁ : ▁ " + len ) ; } }
using System ; using System . Text ; class GFG { public static int evaluateBoolExpr ( StringBuilder s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i += 2 ) { if ( i + 1 < n && i + 2 < n ) { if ( s [ i + 1 ] == ' A ' ) { if ( s [ i + 2 ] == '0' s [ i ] == 0 ) { s [ i + 2 ] = '0' ; } else { s [ i + 2 ] = '1' ; } } else if ( ( i + 1 ) < n && s [ i + 1 ] == ' B ' ) { if ( s [ i + 2 ] == '1' s [ i ] == '1' ) { s [ i + 2 ] = '1' ; } else { s [ i + 2 ] = '0' ; } } else { if ( s [ i + 2 ] == s [ i ] ) { s [ i + 2 ] = '0' ; } else { s [ i + 2 ] = '1' ; } } } } return s [ n - 1 ] - '0' ; } public static void Main ( string [ ] args ) { string s = "1C1B1B0A0" ; StringBuilder sb = new StringBuilder ( s ) ; Console . WriteLine ( evaluateBoolExpr ( sb ) ) ; } }
using System ; public class First_Repeated_char { static int FirstRepeated ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; } public static void Main ( ) { string s = " abcfdeacf " ; int i = FirstRepeated ( s ) ; if ( i != - 1 ) Console . WriteLine ( " Char ▁ = ▁ " + s [ i ] + " ▁ and ▁ Index ▁ = ▁ " + i ) ; else Console . WriteLine ( " No ▁ repeated ▁ Char " ) ; } }
using System ; public class GFG { static int evenNumSubstring ( string str ) { int len = str . Length ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; } public static void Main ( ) { string str = "1234" ; Console . Write ( evenNumSubstring ( str ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static bool isSubSequence ( String str1 , String str2 ) { int m = str1 . Length , n = str2 . Length ; for ( int i = 0 ; i < n && j < m ; i ++ ) { if ( str1 [ j ] == str2 [ i ] ) { j ++ ; } } return ( j == m ) ; } static String findLongestString ( List < String > dict , String str ) { String result = " " ; int length = 0 ; foreach ( String word in dict ) { if ( length < word . Length && isSubSequence ( word , str ) ) { result = word ; length = word . Length ; } } return result ; } public static void Main ( String [ ] args ) { String [ ] arr = { " ale " , " apple " , " monkey " , " plea " } ; List < String > dict = new List < String > ( arr ) ; String str = " abpcplea " ; Console . WriteLine ( findLongestString ( dict , str ) ) ; } }
using System ; class GFG { static bool isEditDistanceOne ( String s1 , String s2 ) { int m = s1 . Length , n = s2 . Length ; if ( Math . Abs ( m - n ) > 1 ) return false ; int count = 0 ; int i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; else { i ++ ; j ++ ; } count ++ ; } else { i ++ ; j ++ ; } } if ( i < m < n ) count ++ ; return count == 1 ; } public static void Main ( ) { String s1 = " gfg " ; String s2 = " gf " ; if ( isEditDistanceOne ( s1 , s2 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { public virtual int countSubStr ( char [ ] str , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == '1' ) { res ++ ; } } } } return res ; } public static void Main ( string [ ] args ) { GFG count = new GFG ( ) ; string s = "00100101" ; char [ ] str = s . ToCharArray ( ) ; int n = str . Length ; Console . WriteLine ( count . countSubStr ( str , n ) ) ; } }
class GFG { static int exponentMod ( int A , int B , int C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; long y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return ( int ) ( ( y + C ) % C ) ; } public static void Main ( ) { int A = 2 , B = 5 , C = 13 ; System . Console . WriteLine ( " Power ▁ is ▁ " + exponentMod ( A , B , C ) ) ; } }
using System ; public class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; y = y / 2 x = ( x * x ) % p ; } return res ; } static public void Main ( ) { int x = 2 ; int y = 5 ; int p = 13 ; Console . Write ( " Power ▁ is ▁ " + power ( x , y , p ) ) ; } }
using System ; class GFG { static double trianglearea ( double a ) { if ( a < 0 ) return - 1 ; double area = ( 3 * Math . Sqrt ( 3 ) * Math . Pow ( a , 2 ) ) / 4 ; return Math . Round ( area , 4 ) ; } public static void Main ( ) { double a = 6 ; Console . WriteLine ( trianglearea ( a ) ) ; } }
class solution { static void equation_ellipse ( float x1 , float y1 , float a , float b , float c , float e ) { float t = a * a + b * b ; float a1 = t - e * ( a * a ) ; float b1 = t - e * ( b * b ) ; float c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; float d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; float e1 = - 2 * e * a * b ; float f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; System . Console . WriteLine ( " Equation ▁ of ▁ ellipse ▁ is ▁ " ) ; System . Console . WriteLine ( a1 + " ▁ x ^ 2 ▁ + ▁ " + b1 + " ▁ y ^ 2 ▁ + ▁ " + c1 + " ▁ x ▁ + ▁ " + d1 + " ▁ y ▁ + ▁ " + e1 + " ▁ xy ▁ + ▁ " + f1 + " ▁ = ▁ 0" ) ; } public static void Main ( ) { float x1 = 1 , y1 = 1 , a = 1 , b = - 1 , c = 3 , e = ( float ) 0.5 * ( float ) 0.5 ; equation_ellipse ( x1 , y1 , a , b , c , e ) ; } }
using System ; class GFG { static double PI = 3.14 ; static double circle_inscribed ( int a ) { return PI * ( a * a ) / 12 ; } public static void Main ( ) { int a = 4 ; Console . WriteLine ( circle_inscribed ( a ) ) ; } }
using System ; class GFG { static void findVolume ( double u , double v , double w , double U , double V , double W , double b ) { double uPow = Math . Pow ( u , 2 ) ; double vPow = Math . Pow ( v , 2 ) ; double wPow = Math . Pow ( w , 2 ) ; double UPow = Math . Pow ( U , 2 ) ; double VPow = Math . Pow ( V , 2 ) ; double WPow = Math . Pow ( W , 2 ) ; double a = 4 * ( uPow * vPow * wPow ) - uPow * Math . Pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * Math . Pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * Math . Pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; double vol = Math . Sqrt ( a ) ; vol /= b ; Console . Write ( System . Math . Round ( vol , 4 ) ) ; } public static void Main ( ) { double u = 1000 , v = 1000 , w = 1000 ; double U = 3 , V = 4 , W = 5 ; double b = 12 ; findVolume ( u , v , w , U , V , W , b ) ; } }
using System ; class GFG { static void makePolygon ( double a ) { double n = 360 / ( 180 - a ) ; if ( n == ( int ) n ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } static void Main ( ) { double a = 90 ; makePolygon ( a ) ; } }
using System ; class GFG { static int getQuadrant ( int X , int Y , int R , int PX , int PY ) { if ( PX == X && PY == Y ) return 0 ; int val = ( int ) Math . Pow ( ( PX - X ) , 2 ) + ( int ) Math . Pow ( ( PY - Y ) , 2 ) ; if ( val > Math . Pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; return 0 ; } public static void Main ( ) { int X = 0 , Y = 3 ; int R = 2 ; int PX = 1 , PY = 4 ; int ans = getQuadrant ( X , Y , R , PX , PY ) ; if ( ans == - 1 ) Console . WriteLine ( " Lies ▁ Outside " + " ▁ the ▁ circle " ) ; else if ( ans == 0 ) Console . WriteLine ( " Coincides ▁ " + " with ▁ centre " ) ; else Console . WriteLine ( ans + " ▁ Quadrant " ) ; } }
using System ; class GFG { static long hexadecagonalNum ( long n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; } public static void Main ( ) { long n = 5 ; Console . WriteLine ( n + " th ▁ " + " Hexadecagonal ▁ number ▁ : ▁ " + hexadecagonalNum ( n ) ) ; n = 9 ; Console . WriteLine ( n + " th ▁ " + " Hexadecagonal ▁ number ▁ : ▁ " + hexadecagonalNum ( n ) ) ; } }
using System ; class GFG { static int perimeter ( int diameter , int height ) { return 2 * ( diameter + height ) ; } public static void Main ( String [ ] args ) { int diameter = 5 ; int height = 10 ; Console . Write ( " Perimeter ▁ = ▁ " + perimeter ( diameter , height ) + " ▁ units STRNEWLINE " ) ; } }
using System ; public class ParallelogramPoints { public static void Main ( ) { int ax = 5 , ay = 0 ; int bx = 1 , by = 1 ; int cx = 2 , cy = 5 ; Console . WriteLine ( ax + bx - cx + " , ▁ " + ( ay + by - cy ) ) ; Console . WriteLine ( ax + cx - bx + " , ▁ " + ( ay + cy - by ) ) ; Console . WriteLine ( cx + bx - ax + " , ▁ " + ( cy + by - ax ) ) ; } }
using System ; class GFG { static float area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return ( float ) Math . Abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } static bool check ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 , int x , int y ) { float A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ; float A1 = area ( x , y , x1 , y1 , x2 , y2 ) ; float A2 = area ( x , y , x2 , y2 , x3 , y3 ) ; float A3 = area ( x , y , x3 , y3 , x4 , y4 ) ; float A4 = area ( x , y , x1 , y1 , x4 , y4 ) ; return ( A == A1 + A2 + A3 + A4 ) ; } public static void Main ( ) { if ( check ( 0 , 10 , 10 , 0 , 0 , - 10 , - 10 , 0 , 10 , 15 ) ) Console . Write ( " yes " ) ; else Console . Write ( " no " ) ; } }
using System ; class GFG { static int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; } public static void Main ( ) { Console . Write ( findMaximumPieces ( 3 ) ) ; } }
using System ; class GFG { static int KnapSack ( int [ ] val , int [ ] wt , int n , int W ) { int [ , ] mat = new int [ 2 , W + 1 ] ; int i = 0 ; while ( i < n ) { int j = 0 ; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 1 , j ] = Math . Max ( val [ i ] + mat [ 0 , j - wt [ i ] ] , mat [ 0 , j ] ) ; } else { mat [ 1 , j ] = mat [ 0 , j ] ; } } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 0 , j ] = Math . Max ( val [ i ] + mat [ 1 , j - wt [ i ] ] , mat [ 1 , j ] ) ; } else { mat [ 0 , j ] = mat [ 1 , j ] ; } } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 , W ] : mat [ 1 , W ] ; } public static void Main ( String [ ] args ) { int [ ] val = { 7 , 8 , 4 } ; int [ ] wt = { 3 , 8 , 6 } ; int W = 10 , n = 3 ; Console . WriteLine ( KnapSack ( val , wt , n , W ) ) ; } }
using System ; class GFG { static void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } } static void findNumbers ( int [ ] arr , int n ) { Array . Sort ( arr ) ; reverse ( arr ) ; int [ ] freq = new int [ arr [ 0 ] + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } int size = ( int ) Math . Sqrt ( n ) ; int [ ] brr = new int [ size ] ; int x , l = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] ] > 0 && l < size ) { brr [ l ] = arr [ i ] ; freq [ brr [ l ] ] -- ; l ++ ; for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { x = __gcd ( arr [ i ] , brr [ j ] ) ; freq [ x ] -= 2 ; } } } } printArr ( brr , size ) ; } public static void reverse ( int [ ] input ) { int last = input . Length - 1 ; int middle = input . Length / 2 ; for ( int i = 0 ; i <= middle ; i ++ ) { int temp = input [ i ] ; input [ i ] = input [ last - i ] ; input [ last - i ] = temp ; } } static int __gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5 , 5 , 5 , 7 , 10 , 12 , 2 , 2 } ; int n = arr . Length ; findNumbers ( arr , n ) ; } }
using System ; using System . Collections ; class GFG { static void AlternateRearrange ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int j = 0 ; j < n ; j ++ ) if ( arr [ j ] % 2 == 0 ) v1 . Add ( arr [ j ] ) ; else v2 . Add ( arr [ j ] ) ; int index = 0 , i = 0 , k = 0 ; bool flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ] = ( int ) v1 [ i ] ; i += 1 ; index += 1 ; flag = ! flag ; } else { arr [ index ] = ( int ) v2 [ k ] ; k += 1 ; index += 1 ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } static void Main ( ) { int [ ] arr = { 9 , 8 , 13 , 2 , 19 , 14 } ; int n = arr . Length ; AlternateRearrange ( arr , n ) ; } }
using System ; public class GFG { static int getNumToAdd ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; int numToAdd = - 1 ; bool numAdded = false ; for ( int i = 2 ; i < n ; i ++ ) { int diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 7 , 11 , 13 , 15 } ; int n = arr . Length ; Console . WriteLine ( getNumToAdd ( arr , n ) ) ; } }
using System ; class GFG { static int items ( int n , int [ ] a ) { Array . Sort ( a ) ; int z = a [ n - 1 ] ; int x = 1 ; int s = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; } static public void Main ( ) { int n = 5 ; int [ ] a = { 5 , 3 , 1 , 5 , 6 } ; Console . WriteLine ( items ( n , a ) ) ; } }
using System ; class GFG { static int numBoxes ( int [ ] A , int n , int K ) { Array . Sort ( A ) ; int i = 0 , j = ( n - 1 ) ; int ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; } static public void Main ( ) { int [ ] A = { 3 , 2 , 2 , 1 } ; int K = 3 ; int n = A . Length ; Console . WriteLine ( numBoxes ( A , n , K ) ) ; } }
using System ; class GFG { static int solve ( int N , int M , int [ ] cp , int [ ] sp ) { int [ ] profit = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; Array . Sort ( profit ) ; Array . Reverse ( profit ) ; int sum = 0 ; for ( int i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; } public static void Main ( ) { int N = 5 , M = 3 ; int [ ] CP = { 5 , 10 , 35 , 7 , 23 } ; int [ ] SP = { 11 , 10 , 0 , 9 , 19 } ; Console . Write ( solve ( N , M , CP , SP ) ) ; } }
using System ; public class GFG { static int findMaxNum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int num = arr [ 0 ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { num = num * 10 + arr [ i ] ; } return num ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 0 } ; int n = arr . Length ; Console . WriteLine ( findMaxNum ( arr , n ) ) ; } }
using System ; class GFG { static int minimumSets ( int [ ] arr , int n , int key ) { int i , j ; Array . Sort ( arr ) ; for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; } public static void Main ( ) { int [ ] arr = { 3 , 5 , 3 , 4 } ; int n = arr . Length ; int key = 5 ; Console . WriteLine ( minimumSets ( arr , n , key ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int minimumBox ( int [ ] arr , int n ) { Queue < int > q = new Queue < int > ( ) ; Array . Sort ( arr ) ; q . Enqueue ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int now = q . Peek ( ) ; if ( arr [ i ] >= 2 * now ) q . Dequeue ( ) ; q . Enqueue ( arr [ i ] ) ; } return q . Count ; } public static void Main ( ) { int [ ] arr = { 4 , 1 , 2 , 8 } ; int n = arr . Length ; Console . WriteLine ( minimumBox ( arr , n ) ) ; } }
using System ; class GFG { static void sortBinaryArray ( int [ ] a , int n ) { int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; int temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } } public static void Main ( ) { int [ ] a = { 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 } ; int n = a . Length ; sortBinaryArray ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; } }
using System ; public class GFG { static int MAX = 1000 ; static int findDuplicate ( int [ ] arr , int n , int k ) { int res = MAX + 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { int count = 1 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) count += 1 ; if ( count == k ) res = Math . Min ( res , arr [ i ] ) ; } } return res ; } public static void Main ( ) { int [ ] arr = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = arr . Length ; Console . WriteLine ( findDuplicate ( arr , n , k ) ) ; } }
using System ; public class GFG { static int findDuplicate ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 ; while ( i < n ) { int j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = arr . Length ; Console . WriteLine ( findDuplicate ( arr , n , k ) ) ; } }
using System ; class GFG { static bool checkForSorting ( int [ ] arr , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { else return false ; } } return true ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 3 , 2 } ; int n = arr . Length ; if ( checkForSorting ( arr , n ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int ksmallest ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; } static public void Main ( ) { int k = 1 ; int [ ] arr = { 1 } ; int n = arr . Length ; Console . WriteLine ( ksmallest ( arr , n , k ) ) ; } }
using System ; class GFG { public static bool isEven ( int n ) { if ( ( n & 1 ) == 0 ) return true ; else return false ; } public static void Main ( ) { int n = 101 ; if ( isEven ( n ) == true ) Console . WriteLine ( " Even " ) ; else Console . WriteLine ( " Odd " ) ; } }
using System ; class GFG { static int findSubsequenceCount ( string S , string T ) { int m = T . Length ; int n = S . Length ; if ( m > n ) return 0 ; int [ , ] mat = new int [ m + 1 , n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) mat [ i , 0 ] = 0 ; for ( int j = 0 ; j <= n ; j ++ ) mat [ 0 , j ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i , j ] = mat [ i , j - 1 ] ; else mat [ i , j ] = mat [ i , j - 1 ] + mat [ i - 1 , j - 1 ] ; } } return mat [ m , n ] ; } public static void Main ( ) { string T = " ge " ; string S = " geeksforgeeks " ; Console . WriteLine ( findSubsequenceCount ( S , T ) ) ; } }
using System ; using System . Collections ; class GfG { static string Check ( int [ , ] a , int [ , ] b , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( a [ i , j ] > b [ i , j ] ) { int tmp = a [ i , j ] ; a [ i , j ] = b [ i , j ] ; b [ i , j ] = tmp ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m - 1 ; j ++ ) if ( a [ i , j ] >= a [ i , j + 1 ] b [ i , j ] >= b [ i , j + 1 ] ) return " No " ; for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( a [ i , j ] >= a [ i + 1 , j ] b [ i , j ] >= b [ i + 1 , j ] ) return " No " ; return " Yes " ; } public static void Main ( string [ ] arg ) { int n = 2 , m = 2 ; int [ , ] a = { { 2 , 10 } , { 11 , 5 } } ; int [ , ] b = { { 9 , 4 } , { 3 , 12 } } ; Console . Write ( Check ( a , b , n , m ) ) ; } }
using System ; class GFG { static string smallestString ( int N , int [ ] A ) { char ch = ' a ' ; string S = " " ; if ( N < 1 A [ 0 ] != 1 ) { S = " - 1" ; return S ; } S += ch ; ch ++ ; for ( int i = 1 ; i < N ; i ++ ) { int diff = A [ i ] - A [ i - 1 ] ; if ( diff > 1 diff < 0 A [ i ] > 26 ) { S = " - 1" ; return S ; } else if ( diff == 0 ) S += ' a ' ; else { S += ch ; ch ++ ; } } return S ; } static void Main ( ) { int [ ] arr = { 1 , 1 , 2 , 3 , 3 } ; int n = arr . Length ; Console . WriteLine ( smallestString ( n , arr ) ) ; } }
using System ; class GFG { static bool canBePicked ( int [ ] digits , int num ) { int [ ] copyDigits = ( int [ ] ) digits . Clone ( ) ; while ( num > 0 ) { int digit = num % 10 ; if ( copyDigits [ digit ] == 0 ) return false ; else copyDigits [ digit ] -- ; num /= 10 ; } return true ; } static int countAlphabets ( int n ) { int i , count = 0 ; int [ ] digits = new int [ 10 ] ; while ( n > 0 ) { int digit = n % 10 ; digits [ digit ] ++ ; n /= 10 ; } for ( i = ' a ' ; i <= ' z ' ; i ++ ) if ( canBePicked ( digits , i ) ) count ++ ; for ( i = ' A ' ; i <= ' Z ' ; i ++ ) if ( canBePicked ( digits , i ) ) count ++ ; return count ; } public static void Main ( ) { int n = 1623455078 ; Console . WriteLine ( countAlphabets ( n ) ) ; } }
using System ; class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static void findTwoNumbers ( int sum , int gcd ) { if ( __gcd ( gcd , sum - gcd ) == gcd && sum != gcd ) Console . WriteLine ( " a ▁ = ▁ " + Math . Min ( gcd , sum - gcd ) + " , ▁ b ▁ = ▁ " + ( int ) ( sum - Math . Min ( gcd , sum - gcd ) ) ) ; else Console . WriteLine ( - 1 ) ; } public static void Main ( ) { int sum = 8 ; int gcd = 2 ; findTwoNumbers ( sum , gcd ) ; } }
using System ; class GFG { static int findMaxDistance ( int numOfCities , int [ ] station , int n ) { bool [ ] hasStation = new bool [ numOfCities + 1 ] ; for ( int city = 0 ; city < n ; city ++ ) { hasStation [ station [ city ] ] = true ; } int dist = 0 ; int maxDist = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { maxDist = Math . Min ( station [ i ] , maxDist ) ; } for ( int city = 0 ; city < numOfCities ; city ++ ) { if ( hasStation [ city ] == true ) { maxDist = Math . Max ( ( dist + 1 ) / 2 , maxDist ) ; dist = 0 ; } else dist += 1 ; } return Math . Max ( maxDist , dist ) ; } public static void Main ( String [ ] args ) { int numOfCities = 6 ; int [ ] station = { 3 , 1 } ; int n = station . Length ; Console . WriteLine ( " Max ▁ Distance : " + findMaxDistance ( numOfCities , station , n ) ) ; } }
using System ; public class GFG { static void split ( int x , int n ) { if ( x < n ) Console . WriteLine ( " - 1 ▁ " ) ; else if ( x % n == 0 ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ( x / n ) + " ▁ " ) ; } else { int zp = n - ( x % n ) ; int pp = x / n ; for ( int i = 0 ; i < n ; i ++ ) { if ( i >= zp ) Console . Write ( ( pp + 1 ) + " ▁ " ) ; else Console . Write ( pp + " ▁ " ) ; } } } static public void Main ( ) { int x = 5 ; int n = 3 ; split ( x , n ) ; } }
using System ; public class GFG { static long cal_minimum_time ( long X ) { long t = 0 ; long sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; } static public void Main ( ) { long n = 6 ; long ans = cal_minimum_time ( n ) ; Console . WriteLine ( " The ▁ minimum ▁ time ▁ required ▁ is ▁ : ▁ " + ans ) ; } }
using System ; class GFG { static int solve ( int [ , ] v , int n ) { int ans , ul , ll ; int first = 0 ; int second = 1 ; ll = v [ 0 , first ] ; ul = v [ 0 , second ] ; ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( v [ i , first ] <= ul && v [ i , first ] >= ll ) || ( v [ i , second ] >= ll && v [ i , second ] <= ul ) ) { if ( v [ i , first ] > ll ) { ll = v [ i , first ] ; } if ( v [ i , second ] < ul ) { ul = v [ i , second ] ; } } else if ( v [ i , first ] > ul ) { ans += Math . Abs ( ul - v [ i , first ] ) ; ul = v [ i , first ] ; ll = v [ i , first ] ; } else if ( v [ i , second ] < ll ) { ans += Math . Abs ( ll - v [ i , second ] ) ; ul = v [ i , second ] ; ll = v [ i , second ] ; } } return ans ; } static void Main ( ) { int [ , ] v = new int [ 5 , 2 ] { { 1 , 3 } , { 2 , 5 } , { 6 , 8 } , { 1 , 2 } , { 2 , 3 } } ; int n = 5 ; Console . WriteLine ( solve ( v , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static List < String > preProcess ( int n ) { List < String > preProcessedCubes = new List < String > ( ) ; for ( int i = 1 ; i * i * i <= n ; i ++ ) { int iThCube = i * i * i ; String cubeString = String . Join ( " " , iThCube ) ; preProcessedCubes . Add ( cubeString ) ; } return preProcessedCubes ; } static String findLargestCubeUtil ( String num , List < String > preProcessedCubes ) { preProcessedCubes . Reverse ( ) ; int totalCubes = preProcessedCubes . Count ; for ( int i = 0 ; i < totalCubes ; i ++ ) { String currCube = preProcessedCubes [ i ] ; int digitsInCube = currCube . Length ; int index = 0 ; int digitsInNumber = num . Length ; for ( int j = 0 ; j < digitsInNumber ; j ++ ) { if ( num [ j ] == currCube [ index ] ) { index ++ ; } if ( digitsInCube == index ) { return currCube ; } } } return " Not ▁ Possible " ; } static void findLargestCube ( int n ) { List < String > preProcessedCubes = preProcess ( n ) ; String num = String . Join ( " " , n ) ; String ans = findLargestCubeUtil ( num , preProcessedCubes ) ; Console . WriteLine ( " Largest ▁ Cube ▁ that ▁ can ▁ be ▁ formed ▁ from ▁ " + n + " ▁ is ▁ " + ans ) ; } public static void Main ( String [ ] args ) { int n ; n = 4125 ; findLargestCube ( n ) ; n = 876 ; findLargestCube ( n ) ; } }
using System ; class GfG { public static String noAdjacentDup ( String s1 ) { int n = s1 . Length ; char [ ] s = s1 . ToCharArray ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' a ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( new String ( s ) ) ; } public static void Main ( String [ ] argc ) { String s = " geeksforgeeks " ; Console . Write ( noAdjacentDup ( s ) ) ; } }
using System ; class GFG { static int winner ( int [ ] a , int n , int k ) { if ( k >= n - 1 ) return n ; int best = 0 , times = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i == 1 ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; } public static void Main ( ) { int [ ] a = { 2 , 1 , 3 , 4 , 5 } ; int n = a . Length ; int k = 2 ; Console . WriteLine ( winner ( a , n , k ) ) ; } }
using System ; class GFG { static int MAX = 100000 ; static int bitscount = 32 ; static int [ , ] prefix_count = new int [ bitscount , MAX ] ; static void findPrefixCount ( int [ ] arr , int n ) { for ( int i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i , 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { prefix_count [ i , j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i , j ] += prefix_count [ i , j - 1 ] ; } } } static int rangeOr ( int l , int r ) { int ans = 0 ; for ( int i = 0 ; i < bitscount ; i ++ ) { int x ; if ( l == 0 ) x = prefix_count [ i , r ] ; else x = prefix_count [ i , r ] - prefix_count [ i , l - 1 ] ; if ( x != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 7 , 5 , 3 , 5 , 2 , 3 } ; int n = arr . Length ; findPrefixCount ( arr , n ) ; int [ , ] queries = { { 1 , 3 } , { 4 , 5 } } ; int q = queries . GetLength ( 0 ) ; for ( int i = 0 ; i < q ; i ++ ) Console . WriteLine ( rangeOr ( queries [ i , 0 ] , queries [ i , 1 ] ) ) ; } }
using System ; class GFG { static void BellmanFord ( int [ , ] graph , int V , int E , int src ) { int [ ] dis = new int [ V ] ; for ( int i = 0 ; i < V ; i ++ ) dis [ i ] = int . MaxValue ; dis [ src ] = 0 ; for ( int i = 0 ; i < V - 1 ; i ++ ) { for ( int j = 0 ; j < E ; j ++ ) { if ( dis [ graph [ j , 0 ] ] = int . MaxValue && dis [ graph [ j , 0 ] ] + graph [ j , 2 ] < dis [ graph [ j , 1 ] ] ) dis [ graph [ j , 1 ] ] = dis [ graph [ j , 0 ] ] + graph [ j , 2 ] ; } } for ( int i = 0 ; i < E ; i ++ ) { int x = graph [ i , 0 ] ; int y = graph [ i , 1 ] ; int weight = graph [ i , 2 ] ; if ( dis [ x ] != int . MaxValue && dis [ x ] + weight < dis [ y ] ) Console . WriteLine ( " Graph ▁ contains ▁ negative " + " ▁ weight ▁ cycle " ) ; } Console . WriteLine ( " Vertex ▁ Distance ▁ from ▁ Source " ) ; for ( int i = 0 ; i < V ; i ++ ) Console . WriteLine ( i + " TABSYMBOL TABSYMBOL " + dis [ i ] ) ; } public static void Main ( String [ ] args ) { int [ , ] graph = { { 0 , 1 , - 1 } , { 0 , 2 , 4 } , { 1 , 2 , 3 } , { 1 , 3 , 2 } , { 1 , 4 , 2 } , { 3 , 2 , 5 } , { 3 , 1 , 1 } , { 4 , 3 , - 3 } } ; BellmanFord ( graph , V , E , 0 ) ; } }
using System ; using System . Collections ; class GFG { static int maxn = 16 ; static int [ ] dp = new int [ maxn + 1 ] ; static void precompute ( ) { for ( int i = 0 ; i <= maxn ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; int [ ] vec = { 4 , 6 , 9 } ; for ( int i = 1 ; i < maxn ; ++ i ) { foreach ( int j in vec ) { if ( i >= j && dp [ i - j ] != - 1 ) { dp [ i ] = Math . Max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } } } static int Maximum_Summands ( int n ) { if ( n < maxn ) return dp [ n ] ; else { int t = ( n - maxn ) / 4 + 1 ; return t + dp [ n - 4 * t ] ; } } static void Main ( ) { int n = 12 ; precompute ( ) ; Console . WriteLine ( Maximum_Summands ( n ) ) ; } }
using System ; class GfG { static int N = 4 ; static int getSum ( int r1 , int r2 , int c1 , int c2 , int [ , ] dp ) { return dp [ r2 , c2 ] - dp [ r2 , c1 ] - dp [ r1 , c2 ] + dp [ r1 , c1 ] ; } static bool sumFound ( int K , int S , int [ , ] grid ) { int [ , ] dp = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i + 1 , j + 1 ] = dp [ i + 1 , j ] + dp [ i , j + 1 ] - dp [ i , j ] + grid [ i , j ] ; } } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int sum = getSum ( i , i + K , j , j + K , dp ) ; if ( sum == S ) { return true ; } } } return false ; } public static void Main ( String [ ] args ) { int [ , ] grid = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int K = 2 ; int S = 14 ; if ( sumFound ( K , S , grid ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static int findMinOperations ( String S ) { S = reverse ( S ) ; int n = S . Length ; int [ , ] dp = new int [ n + 1 , 2 ] ; if ( S [ 0 ] == '0' ) { dp [ 0 , 0 ] = 0 ; } else { dp [ 0 , 0 ] = 1 ; } dp [ 0 , 1 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( S [ i ] == '0' ) { dp [ i , 0 ] = dp [ i - 1 , 0 ] ; dp [ i , 1 ] = 1 + Math . Min ( dp [ i - 1 , 1 ] , dp [ i - 1 , 0 ] ) ; } else { dp [ i , 1 ] = dp [ i - 1 , 1 ] ; dp [ i , 0 ] = 1 + Math . Min ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) ; } } return dp [ n - 1 , 0 ] ; } static String reverse ( String input ) { char [ ] temparray = input . ToCharArray ( ) ; int left , right = 0 ; right = temparray . Length - 1 ; for ( left = 0 ; left < right ; left ++ , right -- ) { char temp = temparray [ left ] ; temparray [ left ] = temparray [ right ] ; temparray [ right ] = temp ; } return String . Join ( " " , temparray ) ; } public static void Main ( ) { String S = "100" ; Console . WriteLine ( findMinOperations ( S ) ) ; S = "111" ; Console . WriteLine ( findMinOperations ( S ) ) ; } }
using System ; class GFG { public static void solve ( int N , int K ) { int [ ] Array = new int [ N + 1 ] ; if ( N <= K ) { Console . WriteLine ( "1" ) ; return ; } int i = 0 ; int sum = K ; for ( i = 1 ; i <= K ; ++ i ) { Array [ i ] = 1 ; } Array [ i ] = sum ; for ( i = K + 2 ; i <= N ; ++ i ) { Array [ i ] = sum - Array [ i - K - 1 ] + Array [ i - 1 ] ; sum = Array [ i ] ; } Console . WriteLine ( Array [ N ] ) ; } public static void Main ( string [ ] args ) { int N = 4 , K = 2 ; solve ( N , K ) ; } }
using System ; class GFG { public static int MAX_VAL = 10000000 ; public static int [ , ] dp = new int [ 100 , 100 ] ; public static int find ( int index , int openbrk , int n , int [ , ] adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index , openbrk ] != - 1 ) return dp [ index , openbrk ] ; dp [ index , openbrk ] = Math . Min ( adj [ index , 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index , 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index , openbrk ] ; } static void Main ( ) { int n = 4 ; int [ , ] adj = new int [ , ] { { 5000 , 3000 } , { 6000 , 2000 } , { 8000 , 1000 } , { 9000 , 6000 } } ; for ( int i = 0 ; i < 100 ; i ++ ) for ( int j = 0 ; j < 100 ; j ++ ) dp [ i , j ] = - 1 ; Console . Write ( find ( 1 , 1 , n , adj ) + adj [ 0 , 1 ] + " STRNEWLINE " ) ; } }
using System ; class GFG { public static int find ( int start , string adj , int n , int [ ] dp ) { if ( start == n ) return 0 ; if ( dp [ start ] != - 1 ) return dp [ start ] ; dp [ start ] = 0 ; int one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj [ k ] == '1' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = Math . Max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = Math . Max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; } static void Main ( ) { string adj = "100110001010001" ; int n = adj . Length ; int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = - 1 ; Console . Write ( find ( 0 , adj , n , dp ) + " STRNEWLINE " ) ; } }
using System ; class GFG { static int isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return 1 ; return 0 ; } static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int lcs ( String X , String Y , int m , int n ) { int [ , ] L = new int [ m + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( ( X [ i - 1 ] == Y [ j - 1 ] ) && isVowel ( X [ i - 1 ] ) == 1 ) L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; else L [ i , j ] = max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } return L [ m , n ] ; } static public void Main ( String [ ] args ) { String X = " aieef " ; String Y = " klaief " ; int m = X . Length ; int n = Y . Length ; Console . WriteLine ( " Length ▁ of ▁ LCS ▁ = ▁ " + lcs ( X , Y , m , n ) ) ; } }
using System ; class GFG { static Boolean check ( int i , int val ) { if ( i - val < 0 ) return false ; else return true ; } static double MinimumPrimes ( int n ) { double [ ] dp ; dp = new double [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 1e9 ; dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( check ( i , 2 ) ) dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - 2 ] ) ; if ( check ( i , 3 ) ) dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - 3 ] ) ; if ( check ( i , 5 ) ) dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - 5 ] ) ; if ( check ( i , 7 ) ) dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - 7 ] ) ; } if ( dp [ n ] == ( 1e9 ) ) return - 1 ; else return dp [ n ] ; } public static void Main ( String [ ] args ) { int n = 12 ; int minimal = ( int ) MinimumPrimes ( n ) ; if ( minimal != - 1 ) Console . WriteLine ( " Minimum ▁ number ▁ of ▁ single ▁ " + " digit ▁ primes ▁ required : ▁ " + minimal ) ; else Console . WriteLine ( " Not ▁ Possible " ) ; } }
using System ; class GFG { static int numberOfBST ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) ; } } return dp [ n ] ; } public static void Main ( ) { int n = 3 ; Console . Write ( " Number ▁ of ▁ structurally ▁ " + " Unique ▁ BST ▁ with ▁ " + n + " ▁ keys ▁ are ▁ : ▁ " + numberOfBST ( n ) ) ; } }
using System ; class GFG { static int summation ( int n ) { return n << ( n - 1 ) ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( summation ( n ) ) ; } }
using System ; class GFG { static int findMaxProduct ( int [ ] arr , int n ) { int i ; int ans = Int32 . MinValue ; until current . ' ' ' int minval = 1 ; int prevMax ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; minval = Math . Min ( 1 , minval * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { minval = 1 ; maxval = 0 ; } else if ( arr [ i ] < 0 ) { prevMax = maxval ; maxval = minval * arr [ i ] ; minval = prevMax * arr [ i ] ; } ans = Math . Max ( ans , maxval ) ; if ( maxval <= 0 ) { maxval = 1 ; } } return ans ; } public static void Main ( ) { int [ ] arr = { 0 , - 4 , 0 , - 2 } ; int n = arr . Length ; Console . WriteLine ( findMaxProduct ( arr , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static double INF = 1e9 ; static int MAX = 50 ; static void minMaxValues ( int [ ] arr , int n , int m ) { int sum = 0 ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } bool [ , ] dp = new bool [ MAX + 1 , MAX * MAX + 1 ] ; dp [ 0 , 0 ] = true ; for ( int i = 0 ; i < ( n + m ) ; i ++ ) { for ( int k = Math . Min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( int j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 , j ] ) dp [ k , j + arr [ i ] ] = true ; } } } double max_value = - 1 * INF , min_value = INF ; for ( int i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n , i ] ) { int temp = i - 50 * n ; max_value = Math . Max ( max_value , temp * ( sum - temp ) ) ; min_value = Math . Min ( min_value , temp * ( sum - temp ) ) ; } } Console . WriteLine ( " Maximum ▁ Value : ▁ " + max_value + " STRNEWLINE " + " Minimum ▁ Value : ▁ " + min_value + " STRNEWLINE " ) ; } public static void Main ( ) { int n = 2 , m = 2 ; int [ ] arr = { 1 , 2 , 3 , 4 } ; minMaxValues ( arr , n , m ) ; } }
using System ; class GFG { static int findGolomb ( int n ) { if ( n == 1 ) return 1 ; return 1 + findGolomb ( n - findGolomb ( findGolomb ( n - 1 ) ) ) ; } static void printGolomb ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( findGolomb ( i ) + " ▁ " ) ; } public static void Main ( ) { int n = 9 ; printGolomb ( n ) ; } }
using System ; class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static void printknapSack ( int W , int [ ] wt , int [ ] val , int n ) { int i , w ; int [ , ] K = new int [ n + 1 , W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i , w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i , w ] = Math . Max ( val [ i - 1 ] + K [ i - 1 , w - wt [ i - 1 ] ] , K [ i - 1 , w ] ) ; else K [ i , w ] = K [ i - 1 , w ] ; } } int res = K [ n , W ] ; Console . WriteLine ( res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 , w ] ) continue ; else { Console . Write ( wt [ i - 1 ] + " ▁ " ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } } public static void Main ( ) { int [ ] val = { 60 , 100 , 120 } ; int [ ] wt = { 10 , 20 , 30 } ; int W = 50 ; int n = val . Length ; printknapSack ( W , wt , val , n ) ; } }
using System ; class GFG { static int maximumSegments ( int n , int a , int b , int c ) { int [ ] dp = new int [ n + 10 ] ; for ( int i = 0 ; i < n + 10 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . Max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . Max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . Max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; } public static void Main ( ) { int n = 7 , a = 5 , b = 2 , c = 5 ; Console . Write ( maximumSegments ( n , a , b , c ) ) ; } }
using System ; class GFG { public static void sequence ( int n ) { int [ ] f = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; Console . Write ( f [ 1 ] + " ▁ " + f [ 2 ] + " ▁ " ) ; for ( int i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; Console . Write ( f [ i ] + " ▁ " ) ; } } public static void Main ( ) { int n = 13 ; sequence ( n ) ; } }
using System ; class GFG { static int zigzag ( int n , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; dp [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i , 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= Math . Min ( i , k ) ; j ++ ) dp [ i , j ] = dp [ i , j - 1 ] + dp [ i - 1 , i - j ] ; } return dp [ n , k ] ; } public static void Main ( ) { int n = 4 , k = 3 ; Console . WriteLine ( zigzag ( n , k ) ) ; } }
using System ; class GFG { static int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; } static int lobb ( int n , int m ) { return ( ( 2 * m + 1 ) * binomialCoeff ( 2 * n , m + n ) ) / ( m + n + 1 ) ; } public static void Main ( ) { int n = 5 , m = 3 ; Console . WriteLine ( lobb ( n , m ) ) ; } }
using System ; class GFG { public static int countarray ( int n , int k , int x ) { int [ ] dp = new int [ 109 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; } public static void Main ( ) { int n = 4 , k = 3 , x = 2 ; Console . WriteLine ( countarray ( n , k , x ) ) ; } }
using System ; class GFG { static int MAX = 100 ; static int MAX_CHAR = 26 ; static void precompute ( string s , int n , int [ , ] l , int [ , ] r ) { l [ s [ 0 ] - ' a ' , 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) l [ j , i ] += l [ j , i - 1 ] ; l [ s [ i ] - ' a ' , i ] ++ ; } r [ s [ n - 1 ] - ' a ' , n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < MAX_CHAR ; j ++ ) r [ j , i ] += r [ j , i + 1 ] ; r [ s [ i ] - ' a ' , i ] ++ ; } } static int countPalindromes ( int k , int n , int [ , ] l , int [ , ] r ) { int ans = 0 ; if ( k == 1 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += l [ i , n - 1 ] ; return ans ; } if ( k == 2 ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) ans += ( ( l [ i , n - 1 ] * ( l [ i , n - 1 ] - 1 ) ) / 2 ) ; return ans ; } for ( int i = 1 ; i < n - 1 ; i ++ ) for ( int j = 0 ; j < MAX_CHAR ; j ++ ) ans += l [ j , i - 1 ] * r [ j , i + 1 ] ; return ans ; } public static void Main ( ) { string s = " aabab " ; int k = 2 ; int n = s . Length ; int [ , ] l = new int [ MAX_CHAR , MAX ] ; int [ , ] r = new int [ MAX_CHAR , MAX ] ; precompute ( s , n , l , r ) ; Console . Write ( countPalindromes ( k , n , l , r ) ) ; } }
using System ; class MaxSumPath { static int maxSum ( int [ , ] mat , int n ) { if ( n == 1 ) return mat [ 0 , 0 ] ; int [ , ] dp = new int [ n , n ] ; int maxSum = int . MinValue , max ; for ( int j = 0 ; j < n ; j ++ ) dp [ n - 1 , j ] = mat [ n - 1 , j ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < n ; j ++ ) { max = int . MinValue ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 , j - 1 ] ) ) max = dp [ i + 1 , j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 , j + 1 ] ) ) max = dp [ i + 1 , j + 1 ] ; dp [ i , j ] = mat [ i , j ] + max ; } } for ( int j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 , j ] ) maxSum = dp [ 0 , j ] ; return maxSum ; } public static void Main ( ) { int [ , ] mat = { { 5 , 6 , 1 , 7 } , { - 2 , 10 , 8 , - 1 } , { 3 , - 7 , - 9 , 11 } , { 12 , - 4 , 2 , 6 } } ; int n = 4 ; Console . WriteLine ( " Maximum ▁ Sum ▁ = ▁ " + maxSum ( mat , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static String longestRepeatedSubSeq ( String str ) { int n = str . Length , i , j ; int [ , ] dp = new int [ n + 1 , n + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) for ( j = 0 ; j <= n ; j ++ ) dp [ i , j ] = 0 ; for ( i = 1 ; i <= n ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = Math . Max ( dp [ i , j - 1 ] , dp [ i - 1 , j ] ) ; String res = " " ; i = n ; j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i , j ] == dp [ i - 1 , j - 1 ] + 1 ) { res = res + str [ i - 1 ] ; i -- ; j -- ; } else if ( dp [ i , j ] == dp [ i - 1 , j ] ) i -- ; else j -- ; } String reverse = " " ; for ( int k = res . Length - 1 ; k >= 0 ; k -- ) { reverse = reverse + res [ k ] ; } return reverse ; } public static void Main ( String [ ] args ) { String str = " AABEBCDD " ; Console . WriteLine ( longestRepeatedSubSeq ( str ) ) ; } }
using System ; class GFG { static bool ElementsCalculationFunc ( int [ ] pre , int [ ] maxx , int x , int k , int n ) { for ( int i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; } static void MaxNumberOfElements ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; for ( int i = 0 ; i <= n ; ++ i ) { pre [ i ] = 0 ; maxx [ i ] = 0 ; } for ( int i = 1 ; i <= n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] ; maxx [ i ] = Math . Max ( maxx [ i - 1 ] , a [ i - 1 ] ) ; } int l = 1 , r = n , ans = 0 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( ElementsCalculationFunc ( pre , maxx , mid - 1 , k , n ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } Console . Write ( ( int ) ans + " STRNEWLINE " ) ; } public static void Main ( ) { int [ ] arr = { 2 , 4 , 9 } ; int n = arr . Length ; int k = 3 ; MaxNumberOfElements ( arr , n , k ) ; } }
using System ; class GFG { static int MAX = 50 ; static int solve ( int [ , ] dp , int [ ] a , int low , int high , int turn ) { if ( low == high ) return a [ low ] * turn ; if ( dp [ low , high ] != 0 ) return dp [ low , high ] ; dp [ low , high ] = Math . Max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low , high ] ; } static void Main ( ) { int [ ] arr = new int [ ] { 1 , 3 , 1 , 5 , 2 } ; int n = arr . Length ; int [ , ] dp = new int [ MAX , MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < MAX ; j ++ ) dp [ i , j ] = 0 ; Console . Write ( solve ( dp , arr , 0 , n - 1 , 1 ) ) ; } }
using System ; class GFG { static int maxSumBitonicSubArr ( int [ ] arr , int n ) { int [ ] msis = new int [ n ] ; int [ ] msds = new int [ n ] ; int max_sum = int . MinValue ; msis [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; } public static void Main ( ) { int [ ] arr = { 5 , 3 , 9 , 2 , 7 , 6 , 4 } ; int n = arr . Length ; Console . Write ( " Maximum ▁ Sum ▁ = ▁ " + maxSumBitonicSubArr ( arr , n ) ) ; } }
using System ; class GFG { static int countWays ( int n , int m ) { int [ ] count = new int [ n + 1 ] ; count [ 0 ] = 0 ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; } public static void Main ( ) { int n = 7 ; int m = 4 ; Console . Write ( " Number ▁ of ▁ ways ▁ = ▁ " + countWays ( n , m ) ) ; } }
using System ; class GFG { static int largestZigZagSumRec ( int [ , ] mat , int i , int j , int n ) { if ( i == n - 1 ) return mat [ i , j ] ; int zzs = 0 ; for ( int k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = Math . Max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return zzs + mat [ i , j ] ; } static int largestZigZag ( int [ , ] mat , int n ) { int res = 0 ; for ( int j = 0 ; j < n ; j ++ ) res = Math . Max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; } public static void Main ( ) { int n = 3 ; int [ , ] mat = { { 4 , 2 , 1 } , { 3 , 9 , 6 } , { 11 , 3 , 15 } } ; Console . WriteLine ( " Largest ▁ zigzag ▁ sum : ▁ " + largestZigZag ( mat , n ) ) ; } }
using System ; class GFG { static int countStr ( int n , int bCount , int cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; int res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( countStr ( n , 1 , 2 ) ) ; } }
using System ; class GFG { static int N = 4 ; static int MaximumPath ( int [ , ] Mat ) { int result = 0 ; int [ , ] dp = new int [ N , N + 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ 0 , i + 1 ] = Mat [ 0 , i ] ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 1 ; j <= N ; j ++ ) dp [ i , j ] = Math . Max ( dp [ i - 1 , j - 1 ] , Math . Max ( dp [ i - 1 , j ] , dp [ i - 1 , j + 1 ] ) ) + Mat [ i , j - 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) result = Math . Max ( result , dp [ N - 1 , i ] ) ; return result ; } public static void Main ( ) { int [ , ] Mat = { { 4 , 2 , 3 , 4 } , { 2 , 9 , 1 , 10 } , { 15 , 1 , 3 , 0 } , { 16 , 92 , 41 , 44 } } ; Console . WriteLine ( MaximumPath ( Mat ) ) ; } }
using System ; class GFG { static int MAX = 100001 ; static double [ ] dp = new double [ MAX ] ; static double probability ( int k , int n ) { double ans = 0.0 ; for ( int i = k ; i <= n ; ++ i ) { double res = dp [ n ] - dp [ i ] - dp [ n - i ] - n ; ans += Math . Pow ( 2.0 , res ) ; } return ans ; } static void precompute ( ) { for ( int i = 2 ; i < MAX ; ++ i ) dp [ i ] = ( Math . Log ( i ) / Math . Log ( 2 ) ) + dp [ i - 1 ] ; } public static void Main ( ) { precompute ( ) ; Console . WriteLine ( probability ( 2 , 3 ) ) ; Console . WriteLine ( probability ( 3 , 6 ) ) ; Console . WriteLine ( Math . Round ( probability ( 500 , 1000 ) , 6 ) ) ; } }
using System ; class GFG { static void printMaxSum ( int [ ] arr , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; int maxi = 0 ; for ( int j = 1 ; j <= Math . Sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ ( i + 1 ) / j - 1 ] > maxi && j != 1 ) maxi = dp [ ( i + 1 ) / j - 1 ] ; } } dp [ i ] += maxi ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( dp [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 1 , 4 , 6 , 5 } ; int n = arr . Length ; printMaxSum ( arr , n ) ; } }
using System ; class GFG { static int maxAlternateSum ( int [ ] arr , int n ) { if ( n == 1 ) return arr [ 0 ] ; int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( min > arr [ i ] ) min = arr [ i ] ; } if ( min == arr [ 0 ] ) { return arr [ 0 ] ; } int [ ] dec = new int [ n ] ; int [ ] inc = new int [ n ] ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . Max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . Max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } int result = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; } public static void Main ( ) { int [ ] arr = { 8 , 2 , 3 , 5 , 7 , 9 , 10 } ; Console . Write ( " Maximum ▁ sum ▁ = ▁ " + maxAlternateSum ( arr , arr . Length ) ) ; } }
using System ; class GFG { static int pad ( int n ) { int pPrevPrev = 1 , pPrev = 1 , pCurr = 1 , pNext = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; } public static void Main ( ) { int n = 12 ; Console . WriteLine ( pad ( n ) ) ; } }
using System ; class GFG { static int lucas ( int n ) { int a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; } public static void Main ( ) { int n = 9 ; Console . WriteLine ( lucas ( n ) ) ; } }
using System ; class GFG { static int breakSum ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . Max ( dp [ i / 2 ] + dp [ i / 3 ] + dp [ i / 4 ] , i ) ; return dp [ n ] ; } public static void Main ( ) { int n = 24 ; Console . WriteLine ( breakSum ( n ) ) ; } }
using System ; class GFG { static int minTime ( int [ ] arr , int n ) { if ( n <= 0 ) return 0 ; int incl = arr [ 0 ] ; int excl = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int incl_new = arr [ i ] + Math . Min ( excl , incl ) ; int excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . Min ( incl , excl ) ; } public static void Main ( ) { int [ ] arr1 = { 10 , 5 , 2 , 7 , 10 } ; int n1 = arr1 . Length ; Console . WriteLine ( minTime ( arr1 , n1 ) ) ; int [ ] arr2 = { 10 , 5 , 7 , 10 } ; int n2 = arr2 . Length ; Console . WriteLine ( minTime ( arr2 , n2 ) ) ; int [ ] arr3 = { 10 , 5 , 2 , 4 , 8 , 6 , 7 , 10 } ; int n3 = arr3 . Length ; Console . WriteLine ( minTime ( arr3 , n3 ) ) ; } }
using System ; class GFG { static void multiply ( int [ , ] a , int [ , ] b ) { int [ , ] mul = new int [ 3 , 3 ] ; for ( int i = 0 ; i < 3 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { mul [ i , j ] = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) mul [ i , j ] += a [ i , k ] * b [ k , j ] ; } } for ( int i = 0 ; i < 3 ; i ++ ) for ( int j = 0 ; j < 3 ; j ++ ) a [ i , j ] = mul [ i , j ] ; } static int power ( int [ , ] F , int n ) { int [ , ] M = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 1 ) return F [ 0 , 0 ] + F [ 0 , 1 ] ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; return F [ 0 , 0 ] + F [ 0 , 1 ] ; } static int findNthTerm ( int n ) { int [ , ] F = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; return power ( F , n - 2 ) ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( " F ( 5 ) ▁ is ▁ " + findNthTerm ( n ) ) ; } }
using System ; class GFG { static int count ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( " Count ▁ of ▁ ways ▁ is : ▁ " + count ( n ) ) ; } }
using System ; class GFG { static int nCrModp ( int n , int r , int p ) { if ( r > n - r ) r = n - r ; int [ ] C = new int [ r + 1 ] ; for ( int i = 0 ; i < r + 1 ; i ++ ) C [ i ] = 0 ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; } public static void Main ( ) { int n = 10 , r = 2 , p = 13 ; Console . Write ( " Value ▁ of ▁ nCr ▁ % ▁ p ▁ is ▁ " + nCrModp ( n , r , p ) ) ; } }
using System ; class GFG { static int bellNumber ( int n ) { int [ , ] bell = new int [ n + 1 , n + 1 ] ; bell [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { bell [ i , 0 ] = bell [ i - 1 , i - 1 ] ; for ( int j = 1 ; j <= i ; j ++ ) bell [ i , j ] = bell [ i - 1 , j - 1 ] + bell [ i , j - 1 ] ; } return bell [ n , 0 ] ; } public static void Main ( ) { for ( int n = 0 ; n <= 5 ; n ++ ) Console . WriteLine ( " Bell ▁ Number ▁ " + n + " ▁ is ▁ " + bellNumber ( n ) ) ; } }
using System ; class GFG { static int printCountDP ( int dist ) { int [ ] count = new int [ dist + 1 ] ; count [ 0 ] = 1 ; count [ 1 ] = 1 ; count [ 2 ] = 2 ; for ( int i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; } public static void Main ( ) { int dist = 4 ; Console . WriteLine ( printCountDP ( dist ) ) ; } }
using System ; class GFG { static int countSeq ( int n ) { int nCr = 1 , res = 1 ; for ( int r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; } public static void Main ( ) { int n = 2 ; Console . Write ( " Count ▁ of ▁ sequences ▁ is ▁ " ) ; Console . Write ( countSeq ( n ) ) ; } }
using System ; public class GFG { static int min ( int a , int b ) { return ( a < b ) ? a : b ; } static int min ( int [ ] arr , int l , int h ) { int mn = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) { if ( mn > arr [ i ] ) { mn = arr [ i ] ; } } return mn ; } static int max ( int [ ] arr , int l , int h ) { int mx = arr [ l ] ; for ( int i = l + 1 ; i <= h ; i ++ ) { if ( mx < arr [ i ] ) { mx = arr [ i ] ; } } return mx ; } static int minRemovalsDP ( int [ ] arr , int n ) { int [ , ] table = new int [ n , n ] ; int gap , i , j , mn , mx ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { mn = min ( arr , i , j ) ; mx = max ( arr , i , j ) ; table [ i , j ] = ( 2 * mn > mx ) ? 0 : min ( table [ i , j - 1 ] + 1 , table [ i + 1 , j ] + 1 ) ; } } return table [ 0 , n - 1 ] ; } public static void Main ( ) { int [ ] arr = { 20 , 4 , 1 , 3 } ; int n = arr . Length ; Console . WriteLine ( minRemovalsDP ( arr , n ) ) ; } }
using System ; public class GFG { static int numberOfPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; } static public void Main ( ) { Console . WriteLine ( numberOfPaths ( 3 , 3 ) ) ; } }
using System ; class GFG { static int numberOfPaths ( int m , int n ) { int path = 1 ; for ( int i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path /= ( i - n + 1 ) ; } return path ; } public static void Main ( ) { Console . WriteLine ( numberOfPaths ( 3 , 3 ) ) ; } }
using System ; class GFG { static int lenghtOfLongestAP ( int [ ] set , int n ) { if ( n <= 2 ) return n ; int [ , ] L = new int [ n , n ] ; int llap = 2 ; for ( int i = 0 ; i < n ; i ++ ) L [ i , n - 1 ] = 2 ; for ( int j = n - 2 ; j >= 1 ; j -- ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i , j ] = 2 ; i -- ; } else { L [ i , j ] = L [ j , k ] + 1 ; llap = Math . Max ( llap , L [ i , j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i , j ] = 2 ; i -- ; } } return llap ; } static public void Main ( ) { int [ ] set1 = { 1 , 7 , 10 , 13 , 14 , 19 } ; int n1 = set1 . Length ; Console . WriteLine ( lenghtOfLongestAP ( set1 , n1 ) ) ; int [ ] set2 = { 1 , 7 , 10 , 15 , 27 , 29 } ; int n2 = set2 . Length ; Console . WriteLine ( lenghtOfLongestAP ( set2 , n2 ) ) ; int [ ] set3 = { 2 , 4 , 6 , 8 , 10 } ; int n3 = set3 . Length ; Console . WriteLine ( lenghtOfLongestAP ( set3 , n3 ) ) ; } }
using System ; class LBS { static int lbs ( int [ ] arr , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; } public static void Main ( ) { int [ ] arr = { 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 } ; int n = arr . Length ; Console . WriteLine ( " Length ▁ of ▁ LBS ▁ is ▁ " + lbs ( arr , n ) ) ; } }
using System ; class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int eggDrop ( int n , int k ) { int [ , ] eggFloor = new int [ n + 1 , k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i , 1 ] = 1 ; eggFloor [ i , 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 , j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i , j ] = int . MaxValue ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 , x - 1 ] , eggFloor [ i , j - x ] ) ; if ( res < eggFloor [ i , j ] ) eggFloor [ i , j ] = res ; } } } return eggFloor [ n , k ] ; } public static void Main ( ) { int n = 2 , k = 36 ; Console . WriteLine ( " Minimum ▁ number ▁ of ▁ trials ▁ " + " in ▁ worst ▁ case ▁ with ▁ " + n + " ▁ eggs ▁ and ▁ " + k + " floors ▁ is ▁ " + eggDrop ( n , k ) ) ; } }
using System ; class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } public static void Main ( ) { int [ ] val = new int [ ] { 60 , 100 , 120 } ; int [ ] wt = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . Length ; Console . WriteLine ( knapSack ( W , wt , val , n ) ) ; } }
using System ; class GFG { static int factorial ( int n ) { int res = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { res *= i ; } return res ; } static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static int catalan ( int n ) { int c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } static int countBST ( int n ) { int count = catalan ( n ) ; return count ; } static int countBT ( int n ) { int count = catalan ( n ) ; return count * factorial ( n ) ; } static public void Main ( ) { int count1 , count2 , n = 5 ; count1 = countBST ( n ) ; count2 = countBT ( n ) ; Console . WriteLine ( " Count ▁ of ▁ BST ▁ with ▁ " + n + " ▁ nodes ▁ is ▁ " + count1 ) ; Console . WriteLine ( " Count ▁ of ▁ binary ▁ " + " trees ▁ with ▁ " + n + " ▁ nodes ▁ is ▁ " + count2 ) ; } }
using System ; using System . Collections ; class GFG { static void printPermutation ( int N , int K ) { ArrayList res = new ArrayList ( ) ; int l = 1 , r = N , flag = 0 ; for ( int i = 0 ; i < K ; i ++ ) { if ( flag == 0 ) { res . Add ( l ) ; l ++ ; } else { res . Add ( r ) ; r -- ; } flag ^= 1 ; } if ( flag != 1 ) { for ( int i = r ; i >= l ; i -- ) { res . Add ( i ) ; } } else { for ( int i = l ; i <= r ; i ++ ) { res . Add ( i ) ; } } foreach ( int i in res ) { Console . Write ( i + " ▁ " ) ; } } public static void Main ( ) { int N = 10 , K = 4 ; printPermutation ( N , K ) ; } }
using System ; class GFG { public static int fact ( int N ) { int i , product = 1 ; for ( i = 1 ; i <= N ; i ++ ) product = product * i ; return product ; } public static int nthTerm ( int N ) { return ( N * N ) * fact ( N ) ; } public static void Main ( String [ ] args ) { Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; public class GFG { public readonly static int d = 256 ; static void search ( String pat , String txt , int q ) { int M = pat . Length ; int N = txt . Length ; int i , j ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; } if ( j == M ) Console . WriteLine ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } public static void Main ( ) { String txt = " GEEKS ▁ FOR ▁ GEEKS " ; String pat = " GEEK " ; int q = 101 ; search ( pat , txt , q ) ; } }
using System ; public class Improve { static int number_of_tower ( int [ ] house , int range , int n ) { Array . Sort ( house ) ; int numOfTower = 0 ; int i = 0 ; while ( i < n ) { numOfTower ++ ; int loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; } public static void Main ( ) { int [ ] house = { 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 } ; int range = 2 ; int n = house . Length ; Console . WriteLine ( number_of_tower ( house , range , n ) ) ; } }
using System ; public class GFG { static int MAX = 1000 ; static int findDuplicate ( int [ ] arr , int n , int k ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { Console . WriteLine ( " Out ▁ of ▁ range " ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; int n = arr . Length ; Console . WriteLine ( findDuplicate ( arr , n , k ) ) ; } }
using System ; class Test { static void pendulumArrangement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int [ ] op = new int [ n ] ; int mid = ( n - 1 ) / 2 ; int j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; Console . Write ( " Pendulum ▁ arrangement : " ) ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( op [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] arr = { 14 , 6 , 19 , 21 , 12 } ; pendulumArrangement ( arr , arr . Length ) ; } }
using System ; class GFG { static int MAX = 256 ; static int [ , ] freq ; static void preCalculate ( string str , int n ) { freq [ ( int ) str [ 0 ] , 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { char ch = str [ i ] ; for ( int j = 0 ; j < MAX ; j ++ ) { char charToUpdate = ( char ) j ; if ( charToUpdate == ch ) freq [ j , i ] = freq [ j , i - 1 ] + 1 ; else freq [ j , i ] = freq [ j , i - 1 ] ; } } } static int getFrequency ( char ch , int l , int r ) { if ( l == 0 ) return freq [ ( int ) ch , r ] ; else return ( freq [ ( int ) ch , r ] - freq [ ( int ) ch , l - 1 ] ) ; } static String lastNonRepeating ( string str , int n , int l , int r ) { for ( int i = r ; i >= l ; i -- ) { char ch = str [ i ] ; if ( getFrequency ( ch , l , r ) == 1 ) return ( " " + ch ) ; } return " - 1" ; } public static void Main ( ) { string str = " GeeksForGeeks " ; int n = str . Length ; int [ , ] queries = { { 2 , 9 } , { 2 , 3 } , { 0 , 12 } } ; int q = queries . Length ; freq = new int [ MAX , n ] ; preCalculate ( str , n ) ; for ( int i = 0 ; i < q ; i ++ ) { Console . WriteLine ( lastNonRepeating ( str , n , queries [ i , 0 ] , queries [ i , 1 ] ) ) ; } } }
using System ; class GFG { static int minCost ( String str , int K ) { int n = str . Length ; int res = 999999999 , count = 0 , a , b ; int [ ] cnt = new int [ 27 ] ; for ( int i = 0 ; i < n ; i ++ ) cnt [ str [ i ] - ' a ' + 1 ] ++ ; for ( int i = 1 ; i < ( 26 - K + 1 ) ; i ++ ) { a = i ; b = i + K ; count = 0 ; for ( int j = 1 ; j <= 26 ; j ++ ) { if ( cnt [ j ] > 0 ) { if ( j >= a && j >= b ) count = count + ( Math . Min ( j - b , 25 - j + a + 1 ) ) * cnt [ j ] ; else if ( j <= a && j <= b ) count = count + ( Math . Min ( a - j , 25 + j - b + 1 ) ) * cnt [ j ] ; } } res = Math . Min ( res , count ) ; } for ( int i = 26 - K + 1 ; i <= 26 ; i ++ ) { a = i ; b = ( i + K ) % 26 ; count = 0 ; for ( int j = 1 ; j <= 26 ; j ++ ) { if ( cnt [ j ] > 0 ) { if ( j >= b && j <= a ) count = count + ( Math . Min ( j - b , a - j ) ) * cnt [ j ] ; } } res = Math . Min ( res , count ) ; } return res ; } public static void Main ( String [ ] args ) { String str = " abcdefghi " ; int K = 2 ; Console . WriteLine ( minCost ( str , K ) ) ; } }
using System ; class GFG { static void printLastChar ( string str ) { str = str + " ▁ " ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( str [ i ] == ' ▁ ' ) Console . Write ( str [ i - 1 ] + " ▁ " ) ; } } public static void Main ( ) { string str = " Geeks ▁ for ▁ Geeks " ; printLastChar ( str ) ; } }
using System ; class GFG { static int maxBalancedStr ( string s ) { int open1 = 0 , close1 = 0 ; int open2 = 0 , close2 = 0 ; int open3 = 0 , close3 = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { switch ( s [ i ] ) { case ' ( ' : open1 ++ ; break ; case ' ) ' : close1 ++ ; break ; case ' { ' : open2 ++ ; break ; case ' } ' : close2 ++ ; break ; case ' [ ' : open3 ++ ; break ; case ' ] ' : close3 ++ ; break ; } } int maxLen = 2 * Math . Min ( open1 , close1 ) + 2 * Math . Min ( open2 , close2 ) + 2 * Math . Min ( open3 , close3 ) ; return maxLen ; } public static void Main ( ) { string s = " ) ) [ ] ] ( ( " ; Console . WriteLine ( maxBalancedStr ( s ) ) ; } }
using System ; class GFG { static string extractSecretMessage ( string Str , string Sub ) { Str = Str . Replace ( Sub , " ▁ " ) ; Str = Str . Trim ( ) ; return Str ; } public static void Main ( ) { string Str = " LIELIEILIEAMLIECOOL " ; string Sub = " LIE " ; Console . WriteLine ( extractSecretMessage ( Str , Sub ) ) ; } }
using System ; class GFG { static int binarySearch ( String [ ] arr , String x ) { int l = 0 , r = arr . Length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; int res = x . CompareTo ( arr [ m ] ) ; if ( res == 0 ) return m ; if ( res > 0 ) l = m + 1 ; else r = m - 1 ; } return - 1 ; } public static void Main ( String [ ] args ) { String [ ] arr = { " contribute " , " geeks " , " ide " , " practice " } ; String x = " ide " ; int result = binarySearch ( arr , x ) ; if ( result == - 1 ) Console . WriteLine ( " Element ▁ not ▁ present " ) ; else Console . WriteLine ( " Element ▁ found ▁ at ▁ " + " index ▁ " + result ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void getStudentsList ( string [ ] file ) { int avgScore ; int maxAvgScore = Int32 . MinValue ; List < string > names = new List < string > ( ) ; for ( int i = 0 ; i < file . Length ; i += 4 ) { avgScore = ( Int32 . Parse ( file [ i + 1 ] ) + Int32 . Parse ( file [ i + 2 ] ) + Int32 . Parse ( file [ i + 3 ] ) ) / 3 ; if ( avgScore > maxAvgScore ) { maxAvgScore = avgScore ; names . Clear ( ) ; names . Add ( file [ i ] ) ; } else if ( avgScore == maxAvgScore ) names . Add ( file [ i ] ) ; } for ( int i = 0 ; i < names . Count ; i ++ ) { Console . Write ( names [ i ] + " ▁ " ) ; } Console . WriteLine ( maxAvgScore ) ; } public static void Main ( ) { string [ ] file = { " Shrikanth " , "20" , "30" , "10" , " Ram " , "100" , "50" , "10" } ; getStudentsList ( file ) ; } }
using System ; class GFG { static int strScore ( String [ ] str , String s , int n ) { int score = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( int j = 0 ; j < s . Length ; j ++ ) score += s [ j ] - ' a ' + 1 ; index = i + 1 ; break ; } } score = score * index ; return score ; } public static void Main ( String [ ] args ) { String [ ] str = { " sahil " , " shashanak " , " sanjit " , " abhinav " , " mohit " } ; String s = " abhinav " ; int n = str . Length ; int score = strScore ( str , s , n ) ; Console . Write ( score ) ; } }
using System ; class GFG { static int minParentheses ( string p ) { int bal = 0 ; int ans = 0 ; for ( int i = 0 ; i < p . Length ; ++ i ) { bal += p [ i ] == ' ( ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; } public static void Main ( ) { string p = " ( ) ) " ; Console . WriteLine ( minParentheses ( p ) ) ; } }
using System ; class GFG { static String reverse ( String input ) { char [ ] a = input . ToCharArray ( ) ; int l , r = 0 ; r = a . Length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . Join ( " " , a ) ; } static Boolean isPalindrome ( String r ) { String p = r ; p = reverse ( p ) ; return ( r . Equals ( p ) ) ; } static Boolean CheckStr ( String s ) { int l = s . Length ; int i ; for ( i = 2 ; i <= l ; i ++ ) { if ( isPalindrome ( s . Substring ( 0 , i ) ) ) { break ; } } if ( i == ( l + 1 ) ) { return false ; } i = 2 ; for ( i = 2 ; i <= l ; i ++ ) { if ( isPalindrome ( s . Substring ( l - i , i ) ) ) { return true ; } } return false ; } public static void Main ( String [ ] args ) { String s = " abccbarfgdbd " ; if ( CheckStr ( s ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static int oddEquivalent ( String s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) count ++ ; } return count ; } public static void Main ( ) { String s = "1011011" ; int n = s . Length ; Console . WriteLine ( oddEquivalent ( s , n ) ) ; } }
using System ; class GFG { static int findNumberOfTimes ( String str1 , String str2 ) { int [ ] freq = new int [ 26 ] ; int l1 = str1 . Length ; int [ ] freq2 = new int [ 26 ] ; int l2 = str2 . Length ; for ( int i = 0 ; i < l1 ; i ++ ) { freq [ str1 [ i ] - ' a ' ] += 1 ; } for ( int i = 0 ; i < l2 ; i ++ ) { freq2 [ str2 [ i ] - ' a ' ] += 1 ; } int count = int . MaxValue ; for ( int i = 0 ; i < l2 ; i ++ ) { if ( freq2 [ str2 [ i ] - ' a ' ] != 0 ) count = Math . Min ( count , freq [ str2 [ i ] - ' a ' ] / freq2 [ str2 [ i ] - ' a ' ] ) ; } return count ; } public static void Main ( ) { String str1 = " foreeksgekseg " ; String str2 = " geeks " ; Console . Write ( findNumberOfTimes ( str1 , str2 ) ) ; } }
using System ; class GFG { static bool solve ( String s1 , String s2 ) { bool flag1 = false , flag2 = false ; if ( s1 . Length != s2 . Length ) return false ; int l = s1 . Length ; for ( int i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == '1' ) flag1 = true ; if ( s2 [ i ] == '1' ) flag2 = true ; if ( flag1 == true && flag2 == true ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; } public static void Main ( ) { String s1 = "100101" ; String s2 = "100000" ; if ( solve ( s1 , s2 ) == true ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { public static int subzero ( String s , int k ) { int ans = 0 , curr = 0 ; int len = s . Length ; char [ ] str = s . ToCharArray ( ) ; for ( int i = 0 ; i < len ; ++ i ) { if ( str [ i ] == '0' ) curr ++ ; else curr = 0 ; ans = Math . Max ( ans , curr ) ; } if ( ans == len ) return len * k ; else { int pre = 0 , suff = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) pre ++ ; else break ; } for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) suff ++ ; else break ; } if ( k > 1 ) ans = Math . Max ( ans , pre + suff ) ; return ans ; } } public static void Main ( ) { String str = "00100110" ; int k = 5 ; Console . Write ( subzero ( str , k ) ) ; } }
using System ; class GFG { static String Dragon_Curve_Sequence ( int n ) { String s = "1" ; for ( int i = 2 ; i <= n ; i ++ ) { String temp = "1" ; char prev = '1' , zero = '0' , one = '1' ; for ( int j = 0 ; j < s . Length ; j ++ ) { temp += s [ j ] ; if ( prev == '0' ) { temp += one ; prev = one ; } else { temp += zero ; prev = zero ; } } s = temp ; } return s ; } public static void Main ( ) { int n = 4 ; String s = Dragon_Curve_Sequence ( n ) ; Console . WriteLine ( s ) ; } }
using System ; class GFG { static int countNonEmptySubstr ( string str ) { int n = str . Length ; return n * ( n + 1 ) / 2 ; } public static void Main ( ) { string s = " abcde " ; Console . Write ( countNonEmptySubstr ( s ) ) ; } }
using System ; class GFG { static int MAX = 26 ; static bool targetstring ( string str1 , string str2 ) { int l1 = str1 . Length ; int l2 = str2 . Length ; if ( l1 != l2 ) return false ; int [ ] map = new int [ MAX ] ; Array . Clear ( map , 0 , 26 ) ; for ( int i = 0 ; i < l1 ; i ++ ) map [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) { map [ str2 [ i ] - ' a ' ] -- ; if ( map [ str2 [ i ] - ' a ' ] < 0 ) return false ; } return true ; } static void Main ( ) { string str1 = " geeksforgeeks " ; string str2 = " geegeeksksfor " ; if ( targetstring ( str1 , str2 ) ) Console . Write ( " YES " ) ; else Console . Write ( " NO " ) ; } }
using System ; class GFG { static bool isDigitPresent ( int x , int d ) { while ( x > 0 ) { if ( x % 10 == d ) break ; x = x / 10 ; } return ( x > 0 ) ; } static void printNumbers ( int n , int d ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i == d || isDigitPresent ( i , d ) ) Console . Write ( i + " ▁ " ) ; } public static void Main ( ) { int n = 47 , d = 7 ; printNumbers ( n , d ) ; } }
using System ; class GFG { static char findExtraCharcter ( string strA , string strB ) { int res = 0 , i ; for ( i = 0 ; i < strA . Length ; i ++ ) { res ^= strA [ i ] ; } for ( i = 0 ; i < strB . Length ; i ++ ) { res ^= strB [ i ] ; } return ( ( char ) ( res ) ) ; } public static void Main ( ) { string strA = " abcd " ; string strB = " cbdad " ; Console . WriteLine ( findExtraCharcter ( strA , strB ) ) ; } }
using System ; class GFG { public static int calculateSum ( string [ ] arr , int n ) { if ( n == 0 ) return 0 ; string s = arr [ 0 ] ; int value = int . Parse ( s ) ; int sum = value ; for ( int i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = int . Parse ( s ) ; char operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' + ' ) sum += value ; else sum -= value ; } return sum ; } public static void Main ( ) { string [ ] arr = { "3" , " + " , "4" , " - " , "7" , " + " , "13" } ; int n = arr . Length ; Console . Write ( calculateSum ( arr , n ) ) ; } }
using System ; class GFG { public static void LargestString ( string [ ] na ) { int N = na . Length ; int [ ] c = new int [ N ] ; int m = 0 ; for ( int j = 0 ; j < N ; j ++ ) { bool [ ] character = new bool [ 26 ] ; for ( int k = 0 ; k < na [ j ] . Length ; k ++ ) { int x = na [ j ] [ k ] - ' A ' ; if ( ( na [ j ] [ k ] != ' ▁ ' ) && ( character [ x ] == false ) ) { c [ j ] ++ ; character [ x ] = true ; } } if ( c [ j ] > c [ m ] ) m = j ; } Console . Write ( na [ m ] ) ; } public static void Main ( ) { string [ ] na = { " BOB " , " A ▁ AB ▁ C ▁ JOHNSON " , " ANJALI " , " ASKRIT " , " ARMAN ▁ MALLIK " } ; LargestString ( na ) ; } }
using System ; class GFG { static string morseEncode ( char x ) { switch ( x ) { case ' a ' : return " . - " ; case ' b ' : return " - . . . " ; case ' c ' : return " - . - . " ; case ' d ' : return " - . . " ; case ' e ' : return " . " ; case ' f ' : return " . . - . " ; case ' g ' : return " - - . " ; case ' h ' : return " . . . . " ; case ' i ' : return " . . " ; case ' j ' : return " . - - - " ; case ' k ' : return " - . - " ; case ' l ' : return " . - . . " ; case ' m ' : return " - - " ; case ' n ' : return " - . " ; case ' o ' : return " - - - " ; case ' p ' : return " . - - . " ; case ' q ' : return " - - . - " ; case ' r ' : return " . - . " ; case ' s ' : return " . . . " ; case ' t ' : return " - " ; case ' u ' : return " . . - " ; case ' v ' : return " . . . - " ; case ' w ' : return " . - - " ; case ' x ' : return " - . . - " ; case ' y ' : return " - . - - " ; case ' z ' : return " - - . . " ; case '1' : return " . - - - - " ; case '2' : return " . . - - - " ; case '3' : return " . . . - - " ; case '4' : return " . . . . - " ; case '5' : return " . . . . . " ; case '6' : return " - . . . . " ; case '7' : return " - - . . . " ; case '8' : return " - - - . . " ; case '9' : return " - - - - . " ; case '0' : return " - - - - - " ; } return " " ; } static void morseCode ( string s ) { for ( int i = 0 ; i < s . Length ; i ++ ) Console . Write ( morseEncode ( s [ i ] ) ) ; Console . WriteLine ( ) ; } public static void Main ( ) { string s = " geeksforgeeks " ; morseCode ( s ) ; } }
using System ; class GFG { static void polybiusCipher ( string s ) { int row , col ; for ( int i = 0 ; i < s . Length ; i ++ ) { row = ( int ) Math . Floor ( ( s [ i ] - ' a ' ) / 5.0 ) + 1 ; col = ( ( s [ i ] - ' a ' ) % 5 ) + 1 ; if ( s [ i ] == ' k ' ) { row = row - 1 ; col = 5 - col + 1 ; } else if ( s [ i ] >= ' j ' ) { if ( col == 1 ) { col = 6 ; row = row - 1 ; } col = col - 1 ; } Console . Write ( row + " " + col ) ; } Console . WriteLine ( ) ; } static void Main ( ) { string s = " geeksforgeeks " ; polybiusCipher ( s ) ; } }
using System ; class GFG { static int MAX_CHAR = 26 ; static int minRemoval ( string str ) { int [ ] hash = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) hash [ i ] = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) hash [ str [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( hash [ i ] % 2 == 1 ) count ++ ; return ( count == 0 ) ? 0 : count - 1 ; } public static void Main ( ) { string str = " geeksforgeeks " ; Console . Write ( minRemoval ( str ) ) ; } }
using System ; class GfG { static int findLUSlength ( String a , String b ) { if ( a . Equals ( b ) == true ) return 0 ; return Math . Max ( a . Length , b . Length ) ; } public static void Main ( ) { String a = " abcdabcd " , b = " abcabc " ; Console . Write ( findLUSlength ( a , b ) ) ; } }
using System ; class GFG { static void swapTwoHalves ( string a , string b ) { int la = a . Length ; int lb = b . Length ; string c = a . Substring ( 0 , la / 2 ) + b . Substring ( lb / 2 , lb / 2 + 1 ) ; string d = b . Substring ( 0 , lb / 2 ) + a . Substring ( la / 2 , la / 2 ) ; Console . Write ( c + " STRNEWLINE " + d + " STRNEWLINE " ) ; } static void Main ( ) { string a = " remuneration " ; string b = " day " ; swapTwoHalves ( a , b ) ; } }
using System ; class GfG { public static int SIZE = 26 ; public static int longSubstring ( String str1 , int k ) { int [ ] freq = new int [ SIZE ] ; char [ ] str = str1 . ToCharArray ( ) ; int start = 0 ; int maxLen = 0 ; char ch ; int n = str1 . Length ; for ( int i = 0 ; i < n ; i ++ ) { ch = str [ i ] ; freq [ ch - ' a ' ] ++ ; if ( freq [ ch - ' a ' ] > k ) { if ( maxLen < ( i - start ) ) maxLen = i - start ; while ( freq [ ch - ' a ' ] > k ) { freq [ str [ start ] - ' a ' ] -- ; start ++ ; } } } if ( maxLen < ( n - start ) ) maxLen = n - start ; return maxLen ; } public static void Main ( ) { String str = " babcaag " ; int k = 1 ; Console . Write ( " Length ▁ = ▁ " + longSubstring ( str , k ) ) ; } }
using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static int solve ( int [ ] A , int n ) { int i , cnt = 0 , j ; int [ ] parent = new int [ n + 1 ] ; int [ ] vis = new int [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { parent [ i ] = - 1 ; vis [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; } public static void Main ( ) { int [ ] A = { 0 , 0 , 0 , 2 } ; int n = A . Length ; Console . WriteLine ( solve ( A , n ) ) ; } }
using System ; class GFG { public int min_diff ; void TOWUtil ( int [ ] arr , int n , Boolean [ ] curr_elements , int no_of_selected_elements , Boolean [ ] soln , int sum , int curr_sum , int curr_position ) { if ( curr_position == n ) return ; if ( ( n / 2 - no_of_selected_elements ) > ( n - curr_position ) ) return ; TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , sum , curr_sum , curr_position + 1 ) ; no_of_selected_elements ++ ; curr_sum = curr_sum + arr [ curr_position ] ; curr_elements [ curr_position ] = true ; if ( no_of_selected_elements == n / 2 ) { if ( Math . Abs ( sum / 2 - curr_sum ) < min_diff ) { min_diff = Math . Abs ( sum / 2 - curr_sum ) ; for ( int i = 0 ; i < n ; i ++ ) soln [ i ] = curr_elements [ i ] ; } } else { TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , sum , curr_sum , curr_position + 1 ) ; } curr_elements [ curr_position ] = false ; } void tugOfWar ( int [ ] arr ) { int n = arr . Length ; Boolean [ ] curr_elements = new Boolean [ n ] ; Boolean [ ] soln = new Boolean [ n ] ; min_diff = int . MaxValue ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; curr_elements [ i ] = soln [ i ] = false ; } TOWUtil ( arr , n , curr_elements , 0 , soln , sum , 0 , 0 ) ; Console . Write ( " The ▁ first ▁ subset ▁ is : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( soln [ i ] == true ) Console . Write ( arr [ i ] + " ▁ " ) ; } Console . Write ( " STRNEWLINE The ▁ second ▁ subset ▁ is : ▁ " ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( soln [ i ] == false ) Console . Write ( arr [ i ] + " ▁ " ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 23 , 45 , - 34 , 12 , 0 , 98 , - 99 , 4 , 189 , - 1 , 4 } ; GFG a = new GFG ( ) ; a . tugOfWar ( arr ) ; } }
using System ; class GFG { static int NO_OF_CHARS = 256 ; static int max_distinct_char ( String str , int n ) { int [ ] count = new int [ NO_OF_CHARS ] ; for ( int i = 0 ; i < n ; i ++ ) { count [ str [ i ] ] ++ ; } int max_distinct = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; } static int smallesteSubstr_maxDistictChar ( String str ) { int n = str . Length ; int max_distinct = max_distinct_char ( str , n ) ; int minl = n ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { String subs = null ; if ( i < j ) subs = str . Substring ( i , str . Length - j ) ; else subs = str . Substring ( j , str . Length - i ) ; int subs_lenght = subs . Length ; int sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; } static public void Main ( String [ ] args ) { String str = " AABBBCBB " ; int len = smallesteSubstr_maxDistictChar ( str ) ; Console . WriteLine ( " ▁ The ▁ length ▁ of ▁ the ▁ smallest ▁ substring " + " ▁ consisting ▁ of ▁ maximum ▁ distinct ▁ " + " characters ▁ : ▁ " + len ) ; } }
using System ; public class GFG { static int evenNumSubstring ( string str ) { int len = str . Length ; int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int temp = str [ i ] - '0' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; } public static void Main ( ) { string str = "1234" ; Console . Write ( evenNumSubstring ( str ) ) ; } }
using System ; class GFG { static int findIndex ( int [ ] a , int n ) { int res = 0 ; long min_diff = Int64 . MaxValue ; long [ ] prod = new long [ n ] ; prod [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { long curr_diff = Math . Abs ( ( prod [ n - 1 ] / prod [ i ] ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; } static void Main ( ) { int [ ] arr = { 3 , 2 , 5 , 7 , 2 , 9 } ; int N = arr . Length ; Console . WriteLine ( findIndex ( arr , N ) ) ; } }
using System ; class GFG { static void printNumbers ( int [ ] a , int n , int x ) { bool flag = false ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; int g = __gcd ( num , x ) ; while ( g != 1 ) { num /= g ; g = __gcd ( num , x ) ; } if ( num == 1 ) { flag = true ; Console . Write ( a [ i ] + " ▁ " ) ; } } if ( ! flag ) Console . WriteLine ( " There ▁ are ▁ no ▁ such ▁ numbers " ) ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int x = 60 ; int [ ] a = { 2 , 5 , 10 , 7 , 17 } ; int n = a . Length ; printNumbers ( a , n , x ) ; } }
using System ; class GFG { static void print ( int [ ] rStation , int n ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( rStation [ i ] + " ▁ " ) ; Console . WriteLine ( " " ) ; } static void radiated_Station ( int [ ] station , int n ) { int [ ] rStation = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { int li = i - 1 , ri = i + 1 ; int lRad = station [ i ] - 1 , rRad = station [ i ] - 1 ; rStation [ i ] += station [ i ] ; while ( li >= 1 && lRad >= 1 ) { rStation [ li -- ] += lRad -- ; } while ( ri <= n && rRad >= 1 ) { rStation [ ri ++ ] += rRad -- ; } } print ( rStation , n ) ; } public static void Main ( String [ ] args ) { int [ ] station = { 0 , 7 , 9 , 12 , 2 , 5 } ; int n = station . Length - 1 ; radiated_Station ( station , n ) ; } }
using System ; class GFG { static int findMaximumDiff ( int [ ] a , int n ) { int ind1 = 0 ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( a [ 0 ] != a [ i ] ) { ind1 = i ; break ; } } int ind2 = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ n - 1 ] != a [ i ] ) { ind2 = ( n - 1 - i ) ; break ; } } return Math . Max ( ind1 , ind2 ) ; } static void Main ( ) { int [ ] a = { 1 , 2 , 3 , 2 , 3 } ; int n = a . Length ; Console . WriteLine ( findMaximumDiff ( a , n ) ) ; } }
using System ; class GFG { static int sum ( int k , int n ) { int sum = ( int ) ( Math . Pow ( k , n + 1 ) - Math . Pow ( k - 1 , n + 1 ) ) ; return sum ; } public static void Main ( ) { int n = 3 ; int K = 3 ; Console . Write ( sum ( K , n ) ) ; } }
class GfG { static bool is_prime ( int num ) { int count = 0 ; for ( int i = 1 ; i * i <= ( num ) ; i ++ ) { if ( ( num ) % i == 0 ) { if ( i * i != ( num ) ) count += 2 ; else count ++ ; } } if ( count == 2 ) return true ; else return false ; } static string is_divisible ( int n ) { if ( n == 1 ) { return " YES " ; } else { if ( is_prime ( n + 1 ) ) return " NO " ; else return " YES " ; } } static void Main ( ) { int n ; n = 3 ; System . Console . WriteLine ( is_divisible ( n ) ) ; n = 4 ; System . Console . WriteLine ( is_divisible ( n ) ) ; } }
using System ; using System . Collections ; class GFG { static int mod = ( int ) ( 1e9 + 7 ) ; static int BitOperations ( string a , int n , string b , int m ) { char [ ] ch1 = a . ToCharArray ( ) ; Array . Reverse ( ch1 ) ; a = new string ( ch1 ) ; char [ ] ch2 = b . ToCharArray ( ) ; Array . Reverse ( ch2 ) ; b = new string ( ch2 ) ; int c = 0 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] == '1' ) c ++ ; int [ ] power = new int [ n ] ; power [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) power [ i ] = ( power [ i - 1 ] * 2 ) % mod ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == '1' ) { ans += c * power [ i ] ; if ( ans >= mod ) ans %= mod ; } if ( b [ i ] == '1' ) c -- ; if ( c == 0 ) break ; } return ans ; } static void Main ( ) { string a = "1001" , b = "10101" ; int n = a . Length , m = b . Length ; Console . WriteLine ( BitOperations ( a , n , b , m ) ) ; } }
using System . Linq ; using System ; class GFG { static void sieve ( int maxEle , int [ ] prime ) { prime [ 0 ] = prime [ 1 ] = 1 ; for ( int i = 2 ; i * i <= maxEle ; i ++ ) { if ( prime [ i ] == 0 ) { for ( int j = 2 * i ; j <= maxEle ; j += i ) prime [ j ] = 1 ; } } } static int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += n % 10 ; n = n / 10 ; } return sum ; } static void printAdditivePrime ( int [ ] arr , int n ) { int maxEle = arr . Max ( ) ; int [ ] prime = new int [ maxEle + 1 ] ; sieve ( maxEle , prime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 0 ) { int sum = digitSum ( arr [ i ] ) ; if ( prime [ sum ] == 0 ) Console . Write ( arr [ i ] + " ▁ " ) ; } } } static void Main ( ) { int [ ] a = { 2 , 4 , 6 , 11 , 12 , 18 , 7 } ; int n = a . Length ; printAdditivePrime ( a , n ) ; } }
using System ; class GFG { static long nthTerm ( long n ) { long nth ; if ( n % 2 == 0 ) nth = 2 * ( ( n * n ) - n ) ; else nth = ( 2 * n * n ) - n ; return nth ; } public static void Main ( ) { long n ; n = 5 ; Console . WriteLine ( nthTerm ( n ) ) ; n = 25 ; Console . WriteLine ( nthTerm ( n ) ) ; n = 25000000 ; Console . WriteLine ( nthTerm ( n ) ) ; n = 250000007 ; Console . WriteLine ( nthTerm ( n ) ) ; } }
using System ; public class GFG { static int nthTerm ( int n ) { int An = ( ( int ) Math . Pow ( 1 , n ) + ( int ) Math . Pow ( 2 , n ) ) * ( int ) Math . Pow ( 3 , n ) ; return An ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( nthTerm ( n ) ) ; } }
using System ; public class GFG { static int countDivisors ( int n ) { int x = 0 , ans = 1 ; while ( n % 2 == 0 ) { x ++ ; n = n / 2 ; } ans = ans * ( x + 1 ) ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { x = 0 ; while ( n % i == 0 ) { x ++ ; n = n / i ; } ans = ans * ( x + 1 ) ; } if ( n > 2 ) ans = ans * 2 ; return ans ; } static int getTotalCount ( int n , int k ) { int k_count = countDivisors ( k ) ; int count = 0 ; for ( int i = 1 ; i < n ; i ++ ) if ( k_count == countDivisors ( i ) ) count ++ ; if ( k < n ) count = count - 1 ; return count ; } public static void Main ( ) { int n = 500 , k = 6 ; Console . WriteLine ( getTotalCount ( n , k ) ) ; } }
using System ; public class GFG { static int nthTerm ( int n ) { int d = 2 ; int a1 = 0 ; int An = a1 + ( n - 1 ) * d ; return ( int ) Math . Pow ( An , 3 ) ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( nthTerm ( n ) ) ; } }
using System ; class GFG { static int MAX_VAL = 200000 ; static int countIntervals ( int [ , ] arr , int V , int N ) { int min = int . MaxValue , max = int . MinValue ; int li , ri ; int [ ] freq = new int [ MAX_VAL ] ; for ( int i = 0 ; i < N ; i ++ ) { li = arr [ i , 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i , 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( int i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; } public static void Main ( ) { int [ , ] arr = new int [ , ] { { 1 , 10 } , { 5 , 10 } , { 15 , 25 } , { 7 , 12 } , { 20 , 25 } } ; int V = 7 ; int N = arr . Length / arr . Rank ; Console . WriteLine ( countIntervals ( arr , V , N ) ) ; } }
using System ; class GFG { static void printGroups ( int n ) { int x = 1 ; int y = n * n ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n / 2 ; j ++ ) { Console . Write ( " { ▁ " + x + " , ▁ " + y + " } ▁ " ) ; x ++ ; y -- ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 4 ; printGroups ( n ) ; } }
using System ; class GFG { public static int breakEvenPoint ( int exp1 , int S , int M ) { double earn = S - M ; double exp = exp1 ; double res = Math . Ceiling ( exp / earn ) ; int res1 = ( int ) res ; return res1 ; } public static void Main ( ) { int exp = 3550 , S = 90 , M = 65 ; Console . WriteLine ( breakEvenPoint ( exp , S , M ) ) ; } }
class GFG { static int minimum ( int n ) { int product = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; } static void Main ( ) { int n = 20 ; System . Console . WriteLine ( minimum ( n ) ) ; } }
using System ; public class GFG { static int numbers ( int n , int [ ] arr , int m ) { int isZero = 0 , isFive = 0 ; int result = 0 ; if ( m < n ) { return - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { if ( arr [ i ] == 0 ) { isZero = 1 ; } if ( arr [ i ] == 5 ) { isFive = 1 ; } } if ( isZero == 1 && isFive == 1 ) { result = 2 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else if ( isZero == 1 isFive == 1 ) { result = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else { result = - 1 ; } return result ; } public static void Main ( ) { int n = 3 , m = 6 ; int [ ] arr = { 2 , 3 , 5 , 6 , 7 , 9 } ; Console . WriteLine ( numbers ( n , arr , m ) ) ; } }
using System ; class GFG { static public void Main ( ) { int a = 5 , b = 7 , c = 10 ; if ( a <= b && a <= c ) Console . WriteLine ( a + " ▁ is ▁ the ▁ smallest " ) ; else if ( b <= a && b <= c ) Console . WriteLine ( b + " ▁ is ▁ the ▁ smallest " ) ; else Console . WriteLine ( c + " ▁ is ▁ the ▁ smallest " ) ; } }
using System ; using System . Linq ; public class GFG { static void maxSum ( int [ ] a , int n ) { int maxAnd = a . Max ( ) ; int maxOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } Console . Write ( ( maxAnd + maxOR ) ) ; } public static void Main ( ) { int n = 4 ; int [ ] a = { 3 , 5 , 6 , 1 } ; maxSum ( a , n ) ; } }
using System ; class GFG { static int getMin ( int [ ] arr , int n , int k ) { int res = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { res = Math . Min ( res , arr [ i ] ) ; } } return res ; } static int getMax ( int [ ] arr , int n , int k ) { int res = int . MinValue ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) { res = Math . Max ( res , arr [ i ] ) ; } } return res ; } static public void Main ( ) { int [ ] arr = { 10 , 1230 , 45 , 67 , 1 } ; int k = 10 ; int n = arr . Length ; Console . WriteLine ( " Minimum ▁ element ▁ of ▁ array ▁ " + " which ▁ is ▁ divisible ▁ by ▁ k : ▁ " + getMin ( arr , n , k ) ) ; Console . WriteLine ( " Maximum ▁ element ▁ of ▁ array ▁ " + " which ▁ is ▁ divisible ▁ by ▁ k : ▁ " + getMax ( arr , n , k ) ) ; } }
using System ; class GFG { static void printNumberWithDR ( int k , int d ) { if ( d == 0 && k != 1 ) Console . Write ( " - 1" ) ; else { Console . Write ( d ) ; k -- ; while ( k -- > 0 ) Console . Write ( "0" ) ; } } static public void Main ( ) { int k = 4 , d = 4 ; printNumberWithDR ( k , d ) ; } }
using System ; public class GFG { static int countNumbers ( int n ) { int c = 0 ; int limit = ( int ) Math . Sqrt ( n ) ; int [ ] prime = new int [ limit + 1 ] ; for ( int i = 1 ; i <= limit ; i ++ ) { prime [ i ] = i ; } for ( int i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) { for ( int j = i * i ; j <= limit ; j += i ) { if ( prime [ j ] == j ) { prime [ j ] = i ; } } } } for ( int i = 2 ; i <= limit ; i ++ ) { int p = prime [ i ] ; int q = prime [ i / prime [ i ] ] ; if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) { if ( Math . Pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; } public static void Main ( ) { int n = 1000 ; Console . WriteLine ( countNumbers ( n ) ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } static bool isInterprime ( int n ) { if ( n < 4 ) return false ; int prev_prime = n ; int next_prime = n ; while ( ! isPrime ( prev_prime ) ) { prev_prime -- ; } while ( ! isPrime ( next_prime ) ) { next_prime ++ ; } if ( ( prev_prime + next_prime ) == 2 * n ) return true ; else return false ; } public static void Main ( ) { int n = 9 ; if ( isInterprime ( n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static int get_unit_digit ( int N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; } static public void Main ( ) { int N = 1 ; for ( N = 0 ; N <= 10 ; N ++ ) Console . WriteLine ( " For ▁ N ▁ = ▁ " + N + " ▁ : ▁ " + get_unit_digit ( N ) ) ; } }
using System ; class gfg { int [ ] f = new int [ 1000 ] ; public int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] > 0 ) return f [ n ] ; int k = ( ( n & 1 ) > 0 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( ( n & 1 ) > 0 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } public int calculateSumOfSquares ( int n ) { return fib ( n ) * fib ( n + 1 ) ; } } class geek { public static int Main ( ) { gfg g = new gfg ( ) ; int n = 6 ; Console . WriteLine ( " Sum ▁ of ▁ Squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ { 0 } " , g . calculateSumOfSquares ( n ) ) ; return 0 ; } }
using System ; public class GFG { static int NumberOfSolutions ( int x , int y , int z , int n ) { int ans = 0 ; for ( int i = 0 ; i <= x ; i ++ ) { for ( int j = 0 ; j <= y ; j ++ ) { int temp = n - i - j ; if ( temp >= 0 ) { temp = Math . Min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; } static public void Main ( ) { int x = 1 , y = 2 , z = 3 , n = 4 ; Console . WriteLine ( NumberOfSolutions ( x , y , z , n ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return ( int ) Math . Pow ( n , 2 ) + 4 * n ; } public static void Main ( ) { int N = 4 ; Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; } static bool isProduct ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; } static void findNumbers ( int N ) { List < int > vec = new List < int > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( isProduct ( i ) && ! isPerfectSquare ( i ) ) { vec . Add ( i ) ; } } foreach ( var a in vec ) Console . Write ( a + " ▁ " ) ; } public static void Main ( String [ ] args ) { int N = 30 ; findNumbers ( N ) ; } }
using System ; class solution { static int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 3 ) + ( int ) Math . Pow ( n , 2 ) ; } public static void Main ( ) { int N = 3 ; Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; class GFG { static long NthTerm ( long n ) { long x = ( 2 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; } public static void Main ( ) { long N = 4 ; Console . WriteLine ( NthTerm ( N ) ) ; } }
using System ; class GFG { static int findSum ( int N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; } static public void Main ( ) { int N = 3 ; Console . Write ( findSum ( N ) ) ; } }
using System ; class GFG { static int nthTerm ( int N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; } public static void Main ( ) { int N = 3 ; Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; public class GFG { private static int MAX = 16 ; static long [ , ] nCr = new long [ MAX , MAX ] ; static void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i , j ] = 1 ; else nCr [ i , j ] = nCr [ i - 1 , j ] + nCr [ i - 1 , j - 1 ] ; } } } static double findTanNTheta ( double tanTheta , int n ) { double ans = 0 , numerator = 0 , denominator = 0 ; long toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n , i ] * Math . Pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } denominator = 1 ; toggle = - 1 ; for ( int i = 2 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n , i ] * Math . Pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } ans = numerator / denominator ; return ans ; } public static void Main ( ) { binomial ( ) ; double tanTheta = 0.3 ; int n = 10 ; Console . Write ( findTanNTheta ( tanTheta , n ) ) ; } }
using System ; class GFG { static int findMaximumPieces ( int n ) { return 1 + n * ( n + 1 ) / 2 ; } public static void Main ( ) { Console . Write ( findMaximumPieces ( 3 ) ) ; } }
using System ; class GFG { static bool isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n += d * 2 ; } return ( n % 19 == 0 ) ; } public static void Main ( ) { long n = 101156 ; if ( isDivisible ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int calculateSum ( int n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; } static public void Main ( ) { int n = 4 ; Console . WriteLine ( " Sum ▁ = ▁ " + calculateSum ( n ) ) ; } }
class GFG { static void printCombination ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( int j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( int k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { System . Console . WriteLine ( i + " ▁ " + j + " ▁ " + k ) ; return ; } } } } } } } static void Main ( ) { int n = 233 ; printCombination ( n ) ; } }
class GFG { static int percent ( int a , int b ) { float result = 0 ; result = ( ( b - a ) * 100 ) / a ; return ( int ) result ; } static void Main ( ) { int a = 20 , b = 25 ; System . Console . WriteLine ( percent ( a , b ) + " % " ) ; } }
using System ; class GFG { public static int calculate ( int [ ] ar , int size ) { int count = 0 ; for ( int i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; } static public void Main ( String [ ] args ) { int [ ] a = { 1 , 3 , 4 , 6 } ; int size = a . Length ; Console . WriteLine ( calculate ( a , size ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } public static void Main ( ) { int a = 98 , b = 56 ; Console . WriteLine ( " GCD ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + gcd ( a , b ) ) ; } }
using System ; class GFG { static long dig ( long a ) { long count = 0 ; while ( a > 0 ) { a /= 10 ; count ++ ; } return count ; } static void required_number ( long num , long n , long d ) { long i , j , power = 1 , a , flag = 0 ; for ( i = num ; i >= 1 ; i -- ) { power = ( long ) Math . Pow ( 10 , i ) ; a = n % power ; if ( d > a ) { flag = 1 ; break ; } } if ( flag > 0 ) { long t = 0 ; for ( j = 0 ; j < i ; j ++ ) { t += ( long ) ( 9 * Math . Pow ( 10 , j ) ) ; } if ( n % power == t ) Console . Write ( n ) ; else { Console . Write ( n - ( n % power ) - 1 ) ; } } else Console . Write ( n ) ; } public static void Main ( ) { long n = 1029 , d = 102 ; long num = dig ( n ) ; required_number ( num , n , d ) ; } }
class GFG { static int twoEggDrop ( int k ) { return ( int ) System . Math . Ceiling ( ( - 1.0 + System . Math . Sqrt ( 1 + 8 * k ) ) / 2.0 ) ; } public static void Main ( ) { int k = 100 ; System . Console . WriteLine ( twoEggDrop ( k ) ) ; } }
using System ; public class GFG { static float findArea ( float a ) { float area ; area = ( float ) ( 5 * Math . Sqrt ( 3 ) * a * a ) ; return area ; } static float findVolume ( float a ) { float volume ; volume = ( float ) ( ( ( float ) 5 / 12 ) * ( 3 + Math . Sqrt ( 5 ) ) * a * a * a ) ; return volume ; } static public void Main ( ) { float a = 5 ; Console . WriteLine ( " Area : ▁ " + findArea ( a ) ) ; Console . WriteLine ( " Volume : ▁ " + findVolume ( a ) ) ; } }
using System ; class GFG { static int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; } static public void Main ( ) { int n = 7 ; Console . WriteLine ( " Total ▁ ways ▁ are : ▁ " + ways ( n ) ) ; } }
using System ; class GFG { static int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += Math . Log10 ( i ) ; ans = ans * n ; return 1 + ( int ) Math . Floor ( ans ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( countDigits ( n ) + " STRNEWLINE " ) ; } }
using System ; class GFG { static public void Main ( ) { double cm , meter , kilometer ; cm = 1000 ; meter = cm / 100.0 ; kilometer = cm / 100000.0 ; Console . WriteLine ( " Length ▁ in ▁ " + " meter ▁ = ▁ " + meter + " m " ) ; Console . WriteLine ( " Length ▁ in ▁ " + " Kilometer ▁ = ▁ " + kilometer + " km " ) ; } }
using System ; public class GFG { static bool everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) { return false ; } if ( x1 > x2 && v1 >= v2 ) { return false ; } if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } return ( ( x1 - x2 ) % ( v1 - v2 ) == 0 ) ; } static void swap ( int a , int b ) { int t = a ; a = b ; b = t ; } public static void Main ( ) { int x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { public static void Main ( ) { int a = 4 ; int b = 3 ; int val = ( a + b - 1 ) / b ; Console . WriteLine ( " The ▁ ceiling " + " ▁ value ▁ of ▁ 4/3 ▁ is ▁ " + val ) ; a = 6 ; b = 3 ; val = ( a + b - 1 ) / b ; Console . WriteLine ( " The ▁ ceiling " + " ▁ value ▁ of ▁ 6/3 ▁ is ▁ " + val ) ; } }
using System ; public class GFG { static double sumTillX ( double x , double n ) { double odd = Math . Ceiling ( n / 2.0 ) ; if ( x <= odd ) return x * x ; double even = x - odd ; return ( ( odd * odd ) + ( even * even ) + even ) ; } static double rangeSum ( double N , double L , double R ) { return sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ; } public static void Main ( ) { long N = 10 , L = 1 , R = 6 ; Console . Write ( rangeSum ( N , L , R ) ) ; } }
using System ; public class GFG { public static void printtwinprime ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n - 2 ; i ++ ) { if ( prime [ i ] == true && prime [ i + 2 ] == true ) Console . Write ( " ▁ ( " + i + " , ▁ " + ( i + 2 ) + " ) " ) ; } } public static void Main ( ) { int n = 25 ; printtwinprime ( n ) ; } }
using System ; class GFG { static bool isCubeFree ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i * i <= n ; i ++ ) if ( n % ( i * i * i ) == 0 ) return false ; return true ; } static void printCubeFree ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) { if ( isCubeFree ( i ) ) { Console . Write ( i + " ▁ " ) ; } } } public static void Main ( ) { int n = 20 ; printCubeFree ( n ) ; } }
using System ; class GFG { static int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n != 0 ; n = n >> 1 ) inv ^= n ; return inv ; } public static void Main ( ) { int n = 15 ; Console . Write ( inversegrayCode ( n ) ) ; } }
using System ; public class GFG { public static long productPrimeFactors ( int n ) { long product = 1 ; if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) product = product * n ; return product ; } public static void Main ( String [ ] args ) { int n = 44 ; Console . Write ( productPrimeFactors ( n ) ) ; } }
using System ; class GFG { static double calculateProbability ( int N ) { double probability = ( double ) N / ( N + 1 ) ; return probability ; } public static void Main ( ) { int N ; double probabilityMax ; N = 1 ; probabilityMax = calculateProbability ( N ) ; Console . WriteLine ( " Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ " + N + " ▁ is , ▁ " + Math . Round ( probabilityMax * 10000.0 ) / 10000.0 ) ; N = 2 ; probabilityMax = calculateProbability ( N ) ; Console . WriteLine ( " Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ " + N + " ▁ is , ▁ " + Math . Round ( probabilityMax * 10000.0 ) / 10000.0 ) ; N = 10 ; probabilityMax = calculateProbability ( N ) ; Console . WriteLine ( " Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ " + N + " ▁ is , ▁ " + Math . Round ( probabilityMax * 10000.0 ) / 10000.0 ) ; } }
using System ; class GFG { static float mean ( float [ ] mid , int [ ] freq , int n ) { float sum = 0 , freqSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; } static float groupedSD ( float [ ] lower_limit , float [ ] upper_limit , int [ ] freq , int n ) { float [ ] mid = new float [ n ] ; float sum = 0 , freqSum = 0 , sd ; for ( int i = 0 ; i < n ; i ++ ) { mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 ; sum = sum + freq [ i ] * mid [ i ] * mid [ i ] ; freqSum = freqSum + freq [ i ] ; } sd = ( float ) Math . Sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) ; return sd ; } public static void Main ( ) { float [ ] lower_limit = { 50 , 61 , 71 , 86 , 96 } ; float [ ] upper_limit = { 60 , 70 , 85 , 95 , 100 } ; int [ ] freq = { 9 , 7 , 9 , 12 , 8 } ; int n = lower_limit . Length ; Console . WriteLine ( groupedSD ( lower_limit , upper_limit , freq , n ) ) ; } }
using System ; class GFG { static int avg_of_even_num ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return ( sum / n ) ; } public static void Main ( ) { int n = 9 ; Console . Write ( avg_of_even_num ( n ) ) ; } }
using System ; class GFG { static int avg_of_even_num ( int n ) { return n + 1 ; } public static void Main ( ) { int n = 8 ; Console . Write ( avg_of_even_num ( n ) ) ; } }
using System ; class GFG { static int squareSum ( int n ) { return n * ( 4 * n * n - 1 ) / 3 ; } public static void Main ( ) { Console . Write ( squareSum ( 8 ) ) ; } }
using System ; class GFG { public static bool isPrime ( int n ) { if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i * i <= n ; i += 2 ) if ( n % i == 0 ) return false ; return true ; } public static int nextPrime ( int start ) { int next = start + 1 ; while ( ! isPrime ( next ) ) next ++ ; return next ; } public static bool areAdjacentPrimes ( int a , int b , int c ) { if ( ! isPrime ( a ) || ! isPrime ( b ) || ! isPrime ( c ) ) return false ; int next = nextPrime ( a ) ; if ( next != b ) return false ; if ( nextPrime ( b ) != c ) return false ; return true ; } public static void Main ( ) { if ( areAdjacentPrimes ( 11 , 13 , 19 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) while ( num % i == 0 ) { num /= i ; ++ cnt ; } if ( num > 1 ) ++ cnt ; return cnt == 2 ? 1 : 0 ; } static void semiprime ( int n ) { if ( checkSemiprime ( n ) != 0 ) Console . WriteLine ( " True " ) ; else Console . WriteLine ( " False " ) ; } public static void Main ( ) { int n = 6 ; semiprime ( n ) ; n = 8 ; semiprime ( n ) ; } }
using System ; class GfG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( sumOfSeries ( n ) ) ; } }
using System ; public class GfG { static int sumOfSeries ( int n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( sumOfSeries ( n ) ) ; } }
using System ; public class GFG { static int binomialCoeff ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; } static int maxcoefficientvalue ( int n ) { if ( n % 2 == 0 ) return binomialCoeff ( n , n / 2 ) ; else return binomialCoeff ( n , ( n + 1 ) / 2 ) ; } static public void Main ( ) { int n = 4 ; Console . WriteLine ( maxcoefficientvalue ( n ) ) ; } }
using System ; public class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) { return a ; } else { return __gcd ( b , a % b ) ; } } static int LCM ( int x , int y , int z ) { int ans = ( ( x * y ) / ( __gcd ( x , y ) ) ) ; return ( ( z * ans ) / ( __gcd ( ans , z ) ) ) ; } static int findDivisible ( int n , int x , int y , int z ) { int lcm = LCM ( x , y , z ) ; int ndigitnumber = ( int ) Math . Pow ( 10 , n - 1 ) ; int reminder = ndigitnumber % lcm ; if ( reminder == 0 ) return ndigitnumber ; ndigitnumber += lcm - reminder ; if ( ndigitnumber < Math . Pow ( 10 , n ) ) return ndigitnumber ; else return 0 ; } static public void Main ( ) { int n = 4 , x = 2 , y = 3 , z = 5 ; int res = findDivisible ( n , x , y , z ) ; if ( res != 0 ) Console . WriteLine ( res ) ; else Console . WriteLine ( " Not ▁ possible " ) ; } }
using System ; class GFG { public static int squaresum ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( squaresum ( n ) ) ; } }
using System ; class GFG { static double distance ( int x1 , int y1 , int x2 , int y2 ) { return Math . Sqrt ( Math . Pow ( x2 - x1 , 2 ) + Math . Pow ( y2 - y1 , 2 ) * 1.0 ) ; } public static void Main ( ) { Console . WriteLine ( Math . Round ( distance ( 3 , 4 , 4 , 3 ) * 100000.0 ) / 100000.0 ) ; } }
using System ; class GFG { public static bool isDivisible ( String S ) { int n = S . Length ; if ( S [ n - 1 ] != '5' && S [ n - 1 ] != '0' ) return false ; int sum = 0 ; for ( int i = 0 ; i < S . Length ; i ++ ) sum += ( int ) S [ i ] ; if ( sum % 3 == 0 ) return true ; else return false ; } public static void Main ( ) { String S = "15645746327462384723984023940239" ; if ( isDivisible ( S ) == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; String S1 = "15645746327462384723984023940235" ; if ( isDivisible ( S1 ) == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool checkPerfectSquare ( double n ) { double d = Math . Sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } static int largestPerfectSquareNumber ( int [ ] a , double n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectSquare ( a [ i ] ) ) maxi = Math . Max ( a [ i ] , maxi ) ; } return maxi ; } public static void Main ( ) { int [ ] a = { 16 , 20 , 25 , 2 , 3 , 10 } ; double n = a . Length ; Console . WriteLine ( largestPerfectSquareNumber ( a , n ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } static int find_LCM ( int x , int y ) { return ( x * y ) / gcd ( x , y ) ; } static int CountPairs ( int n , int m , int A , int B ) { int cnt = 0 ; int lcm = find_LCM ( A , B ) ; for ( int i = 1 ; i <= n ; i ++ ) cnt += ( m + ( i % lcm ) ) / lcm ; return cnt ; } public static void Main ( ) { int n = 60 , m = 90 , A = 5 , B = 10 ; Console . WriteLine ( CountPairs ( n , m , A , B ) ) ; } }
using System ; class GFG { static int MAX = 1001 ; static int [ , ] prefix = new int [ MAX , MAX ] ; static int [ ] ar = new int [ MAX ] ; static void cal_prefix ( int n , int [ ] arr ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) ar [ i + 1 ] = arr [ i ] ; for ( i = 1 ; i <= 1000 ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) prefix [ i , j ] = 0 ; for ( j = 1 ; j <= n ; j ++ ) { prefix [ i , j ] = prefix [ i , j - 1 ] + ( int ) ( ar [ j ] <= i ? 1 : 0 ) ; } } } static int ksub ( int l , int r , int n , int k ) { int lo , hi , mid ; lo = 1 ; hi = 1000 ; while ( lo + 1 < hi ) { mid = ( lo + hi ) / 2 ; if ( prefix [ mid , r ] - prefix [ mid , l - 1 ] >= k ) hi = mid ; else lo = mid + 1 ; } if ( prefix [ lo , r ] - prefix [ lo , l - 1 ] >= k ) hi = lo ; return hi ; } static void Main ( ) { int [ ] arr = { 1 , 4 , 2 , 3 , 5 , 7 , 6 } ; int n = arr . Length ; cal_prefix ( n , arr ) ; int [ , ] queries = { { 1 , n , 1 } , { 2 , n - 2 , 2 } , { 3 , n - 1 , 3 } } ; int q = queries . Length / queries . Rank - 1 ; for ( int i = 0 ; i < q ; i ++ ) Console . WriteLine ( ksub ( queries [ i , 0 ] , queries [ i , 1 ] , n , queries [ i , 2 ] ) ) ; } }
using System ; class GFG { static int max_min ( int [ ] a , int n ) { if ( n <= 1 ) return Int32 . MaxValue ; int f_min = a [ 0 ] , s_min = Int32 . MaxValue ; int f_max = a [ 0 ] , s_max = Int32 . MinValue ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= f_min ) { s_min = f_min ; f_min = a [ i ] ; } else if ( a [ i ] < s_min ) { s_min = a [ i ] ; } if ( a [ i ] >= f_max ) { s_max = f_max ; f_max = a [ i ] ; } else if ( a [ i ] > s_max ) { s_max = a [ i ] ; } } return Math . Min ( ( f_max - s_min ) , ( s_max - f_min ) ) ; } public static void Main ( ) { int [ ] a = { 1 , 3 , 3 , 7 } ; int n = a . Length ; Console . WriteLine ( max_min ( a , n ) ) ; } }
using System ; class Solution { static int minimal ( int [ ] a , int n ) { int lo = 0 , hi = n - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; } public static void Main ( ) { int [ ] a = { 8 , 5 , 4 , 3 , 4 , 10 } ; int n = a . Length ; int ind = minimal ( a , n ) ; Console . WriteLine ( a [ ind ] ) ; } }
using System ; class GFG { static void findIndices ( int [ ] arr , int n ) { int leftMin = 0 , rightMin = 0 ; int leftMax = 0 , rightMax = 0 ; int min = arr [ 0 ] , max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) { leftMin = rightMin = i ; min = arr [ i ] ; } else if ( arr [ i ] == min ) rightMin = i ; if ( arr [ i ] > max ) { leftMax = rightMax = i ; max = arr [ i ] ; } else if ( arr [ i ] == max ) rightMax = i ; } Console . WriteLine ( " Minimum ▁ left ▁ : ▁ " + leftMin ) ; Console . WriteLine ( " Minimum ▁ right ▁ : ▁ " + rightMin ) ; Console . WriteLine ( " Maximum ▁ left ▁ : ▁ " + leftMax ) ; Console . WriteLine ( " Maximum ▁ right ▁ : ▁ " + rightMax ) ; } public static void Main ( ) { int [ ] arr = { 2 , 1 , 1 , 2 , 1 , 5 , 6 , 5 } ; int n = arr . Length ; findIndices ( arr , n ) ; } }
using System ; public class GFG { static void diagonalsMinMax ( int [ , ] mat ) { int n = mat . GetLength ( 0 ) ; if ( n == 0 ) return ; int principalMin = mat [ 0 , 0 ] , principalMax = mat [ 0 , 0 ] ; int secondaryMin = mat [ n - 1 , 0 ] , secondaryMax = mat [ n - 1 , 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { if ( i == j ) { if ( mat [ i , j ] < principalMin ) { principalMin = mat [ i , j ] ; } if ( mat [ i , j ] > principalMax ) { principalMax = mat [ i , j ] ; } } if ( ( i + j ) == ( n - 1 ) ) { if ( mat [ i , j ] < secondaryMin ) { secondaryMin = mat [ i , j ] ; } if ( mat [ i , j ] > secondaryMax ) { secondaryMax = mat [ i , j ] ; } } } } Console . WriteLine ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + principalMin ) ; Console . WriteLine ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; Console . WriteLine ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; Console . WriteLine ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; } static void Main ( ) { int [ , ] matrix = { { 1 , 2 , 3 , 4 , - 10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , - 5 } } ; diagonalsMinMax ( matrix ) ; } }
using System ; class GFG { static void indexedSequentialSearch ( int [ ] arr , int n , int k ) { int [ ] elements = new int [ 20 ] ; int [ ] indices = new int [ 20 ] ; int i ; int j = 0 , ind = 0 , start = 0 , end = 0 , set = 0 ; for ( i = 0 ; i < n ; i += 3 ) { elements [ ind ] = arr [ i ] ; indices [ ind ] = i ; ind ++ ; } if ( k < elements [ 0 ] ) { Console . Write ( " Not ▁ found " ) ; return ; } else { for ( i = 1 ; i <= ind ; i ++ ) if ( k <= elements [ i ] ) { start = indices [ i - 1 ] ; set = 1 ; end = indices [ i ] ; break ; } } if ( set == 0 ) { start = indices [ i - 1 ] ; end = n - 1 ; } for ( i = start ; i <= end ; i ++ ) { if ( k == arr [ i ] ) { j = 1 ; break ; } } if ( j == 1 ) Console . WriteLine ( " Found ▁ at ▁ index ▁ " + i ) ; else Console . WriteLine ( " Not ▁ found " ) ; } public static void Main ( ) { int [ ] arr = { 6 , 7 , 8 , 9 , 10 } ; int n = arr . Length ; int k = 8 ; indexedSequentialSearch ( arr , n , k ) ; } }
using System ; public class GFG { static int countSegments ( int [ ] a , int n , int x ) { bool flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; } static public void Main ( ) { int [ ] a = { 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 } ; int n = a . Length ; int x = 13 ; Console . WriteLine ( countSegments ( a , n , x ) ) ; } }
using System ; class GFG { static long count_triples ( int n , int k ) { int i = 0 , j = 0 , l = 0 ; int count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { for ( l = 1 ; l <= n ; l ++ ) { if ( ( i + j ) % k == 0 && ( i + l ) % k == 0 && ( j + l ) % k == 0 ) count ++ ; } } } return count ; } public static void Main ( ) { int n = 3 ; int k = 2 ; long ans = count_triples ( n , k ) ; Console . WriteLine ( ans ) ; } }
using System ; using System . Linq ; class GFG { static int maxs = 1000001 ; static int kthSmallestLargest ( int [ ] arr , int n , int k ) { int max_val = arr . Max ( ) ; int [ ] hash = new int [ max_val + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } int count = 0 ; for ( int i = 0 ; i <= max_val ; i ++ ) { while ( hash [ i ] > 0 ) { count ++ ; if ( count == k ) { return i ; } hash [ i ] -- ; } } return - 1 ; } public static void Main ( ) { int [ ] arr = { 11 , 6 , 2 , 9 , 4 , 3 , 16 } ; int n = arr . Length , k = 3 ; Console . WriteLine ( " kth ▁ smallest ▁ number ▁ is : ▁ " + kthSmallestLargest ( arr , n , k ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int bsearch ( List < int > A , int key_to_search ) { int n = ( int ) A . Count ; int lg = ( int ) Math . Log ( n - 1 , 2.0 ) + 1 ; int pos = 0 ; for ( int i = lg - 1 ; i >= 0 ; i -- ) { if ( A [ pos ] == key_to_search ) { return pos ; } int new_pos = pos | ( 1 << i ) ; if ( ( new_pos < n ) && ( A [ new_pos ] <= key_to_search ) ) { pos = new_pos ; } } return ( ( A [ pos ] == key_to_search ) ? pos : - 1 ) ; } static public void Main ( ) { List < int > A = new List < int > ( ) ; int [ ] arr = { - 2 , 10 , 100 , 250 , 32315 } ; for ( int i = 0 ; i < arr . Length ; i ++ ) { A . Add ( arr [ i ] ) ; } Console . WriteLine ( bsearch ( A , 10 ) ) ; } }
using System ; class GFG { static float findmedian ( int [ ] a , int n1 , int [ ] b , int n2 ) { int i = 0 ; int j = 0 ; int k ; int m1 = - 1 , m2 = - 1 ; for ( k = 0 ; k <= ( n1 + n2 ) / 2 ; k ++ ) { if ( i < n1 && j < n2 ) { if ( a [ i ] < b [ j ] ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } else { m2 = m1 ; m1 = b [ j ] ; j ++ ; } } else if ( i == n1 ) { m2 = m1 ; m1 = b [ j ] ; j ++ ; } else if ( j == n2 ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } } if ( ( n1 + n2 ) % 2 == 0 ) { return ( m1 + m2 ) * ( float ) 1.0 / 2 ; } return m1 ; } public static void Main ( ) { int [ ] a = { 1 , 12 , 15 , 26 , 38 } ; int [ ] b = { 2 , 13 , 24 } ; int n1 = a . Length ; int n2 = b . Length ; Console . WriteLine ( findmedian ( a , n1 , b , n2 ) ) ; } }
using System ; class GFG { static void printNSE ( int [ ] arr , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } Console . WriteLine ( arr [ i ] + " ▁ - - ▁ " + next ) ; } } public static void Main ( ) { int [ ] arr = { 11 , 13 , 21 , 3 } ; int n = arr . Length ; printNSE ( arr , n ) ; } }
using System ; class GFG { public static int longestSubarray ( int [ ] input ) { int prev = - 1 ; int current , next ; int prevCount = 0 , currentCount = 1 ; int longest = 1 ; current = input [ 0 ] ; for ( int i = 1 ; i < input . Length ; i ++ ) { next = input [ i ] ; if ( next == current ) { currentCount ++ ; } else if ( next == prev ) { prevCount += currentCount ; prev = current ; current = next ; currentCount = 1 ; } else { longest = Math . Max ( longest , currentCount + prevCount ) ; prev = current ; prevCount = currentCount ; current = next ; currentCount = 1 ; } } return Math . Max ( longest , currentCount + prevCount ) ; } public static void Main ( String [ ] args ) { int [ ] input = { 5 , 5 , 6 , 7 , 6 } ; Console . WriteLine ( longestSubarray ( input ) ) ; } }
using System ; class GFG { static int binarySearch ( int [ ] searchSpace , int s , int e , int num ) { int ans = 0 ; while ( s <= e ) { int mid = ( s + e ) / 2 ; if ( searchSpace [ mid ] >= num ) { ans = mid ; e = mid - 1 ; } else s = mid + 1 ; } return ans ; } static int longestSubArr ( int [ ] arr , int n ) { int [ ] searchSpace = new int [ n ] ; int [ ] index = new int [ n ] ; int j = 0 ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( j == 0 searchSpace [ j - 1 ] < arr [ i ] ) { searchSpace [ j ] = arr [ i ] ; index [ j ] = i ; j ++ ; } int idx = binarySearch ( searchSpace , 0 , j - 1 , arr [ i ] ) ; ans = Math . Max ( ans , i - index [ idx ] + 1 ) ; } return ans ; } public static void Main ( ) { int [ ] arr = { - 5 , - 1 , 7 , 5 , 1 , - 2 } ; int n = arr . Length ; Console . Write ( longestSubArr ( arr , n ) ) ; } }
using System ; class GFG { static bool isSuffix ( string s1 , string s2 ) { int n1 = s1 . Length , n2 = s2 . Length ; if ( n1 > n2 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; } public static void Main ( ) { string s1 = " geeks " , s2 = " geeksforgeeks " ; bool result = isSuffix ( s1 , s2 ) ; if ( result ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class GFG { static bool checkIfAllTogether ( string s , char c ) { static bool checkIfAllTogether ( string s , char c ) { bool oneSeen = false ; int i = 0 , n = s . Length ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; } public static void Main ( ) { string s = "110029" ; if ( checkIfAllTogether ( s , '1' ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; public class GFG { static bool search ( int [ ] arr , int n , int x ) { int front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; } static public void Main ( ) { int [ ] arr = { 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 } ; int x = 130 ; int n = arr . Length ; if ( search ( arr , n , x ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { public static int findValue ( int X , int Y , int P ) { if ( P % 2 == 0 ) return ( Math . Max ( X , Y ) / Math . Min ( X , Y ) ) ; else return ( Math . Max ( 2 * X , Y ) / Math . Min ( 2 * X , Y ) ) ; } public static void Main ( ) { int X = 1 , Y = 2 , P = 1 ; Console . WriteLine ( findValue ( X , Y , P ) ) ; X = 3 ; Y = 7 ; P = 2 ; Console . WriteLine ( findValue ( X , Y , P ) ) ; } }
using System ; class GFG { static int sum ( int [ ] arr , int from , int to ) { int total = 0 ; for ( int i = from ; i <= to ; i ++ ) total += arr [ i ] ; return total ; } static int findMax ( int [ ] arr , int n , int k ) { int [ , ] dp = new int [ k + 1 , n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ 1 , i ] = sum ( arr , 0 , i - 1 ) ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i , 1 ] = arr [ 0 ] ; for ( int j = 2 ; j <= n ; j ++ ) { int best = int . MaxValue ; for ( int p = 1 ; p <= j ; p ++ ) best = Math . Min ( best , Math . Max ( dp [ i - 1 , p ] , sum ( arr , p , j - 1 ) ) ) ; dp [ i , j ] = best ; } } return dp [ k , n ] ; } public static void ( ) { int [ ] arr = { 10 , 20 , 60 , 50 , 30 , 40 } ; int n = arr . Length ; int k = 3 ; Console . WriteLine ( findMax ( arr , n , k ) ) ; } }
using System ; class GFG { static int countCrossLine ( int [ ] arr , int n ) { int count_crossline = 0 ; int i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; } public static void Main ( ) { int [ ] arr = new int [ ] { 4 , 3 , 1 , 2 } ; int n = arr . Length ; Console . Write ( countCrossLine ( arr , n ) ) ; } }
using System ; class GFG { public static int findMaxRec ( int [ ] A , int n ) { if ( n == 1 ) return A [ 0 ] ; return Math . Max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; } static public void Main ( ) { int [ ] A = { 1 , 4 , 45 , 6 , - 50 , 10 , 2 } ; int n = A . Length ; Console . WriteLine ( findMaxRec ( A , n ) ) ; } }
using System ; class GFG { static int mod ( int x ) { if ( x >= 0 ) return x ; return - x ; } static void findSquare ( int n ) { int [ , ] points = new int [ 4 , 2 ] { { 1 , 2 } , { - 3 , 4 } , { 1 , 78 } , { - 3 , - 7 } } ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int x , y ; x = points [ i , 0 ] ; y = points [ i , 1 ] ; a [ i ] = Math . Max ( mod ( x ) , mod ( y ) ) ; } Array . Sort ( a ) ; int index = ( int ) ( n / 2 - 1 ) ; Console . WriteLine ( " Minimum ▁ M ▁ required ▁ is : ▁ " + a [ index ] ) ; } public static void Main ( String [ ] args ) { int N ; N = 4 ; findSquare ( N ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void odd_even ( int [ ] arr , int n ) { List < int > odd_indexes = new List < int > ( ) ; List < int > even_indexes = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . Add ( arr [ i ] ) ; else even_indexes . Add ( arr [ i ] ) ; } odd_indexes . Sort ( ) ; even_indexes . Sort ( ) ; for ( int i = 0 ; i < odd_indexes . Count ; i ++ ) Console . Write ( odd_indexes [ i ] + " ▁ " ) ; for ( int i = 0 ; i < even_indexes . Count ; i ++ ) Console . Write ( even_indexes [ i ] + " ▁ " ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 7 , 6 , 8 } ; int n = arr . Length ; odd_even ( arr , n ) ; } }
using System ; class GFG { static int minimumIncrease ( int a , int b , int c ) { int [ ] arr = { a , b , c } ; Array . Sort ( arr ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; } public static void Main ( ) { int a = 3 , b = 5 , c = 10 ; Console . Write ( minimumIncrease ( a , b , c ) ) ; } }
using System ; class GFG { static int absSumDidd ( int [ ] a ) { Array . Sort ( a ) ; int midValue = a [ a . Length / 2 ] ; int sum = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { sum = sum + Math . Abs ( a [ i ] - midValue ) ; } return sum ; } public static void Main ( ) { int [ ] arr = { 5 , 11 , 14 , 10 , 17 , 15 } ; Console . Write ( absSumDidd ( arr ) ) ; }
using System ; class GfG { public static int SIZE = 26 ; public static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static int countSubsequences ( String str , String str3 ) { int [ ] freq1 = new int [ SIZE ] ; int [ ] freq2 = new int [ SIZE ] ; char [ ] str1 = str . ToCharArray ( ) ; char [ ] str2 = str3 . ToCharArray ( ) ; int n1 = str . Length ; int n2 = str3 . Length ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; int count = 1 ; for ( int i = 0 ; i < SIZE ; i ++ ) if ( freq2 [ i ] != 0 ) { if ( freq2 [ i ] <= freq1 [ i ] ) count = count * binomialCoeff ( freq1 [ i ] , freq2 [ i ] ) ; else return 0 ; } return count ; } public static void Main ( String [ ] argc ) { String str1 = " abacd " ; String str2 = " abc " ; Console . Write ( " Count ▁ = ▁ " + countSubsequences ( str1 , str2 ) ) ; } }
using System ; public class GfG { public static int findOccurrences ( string str1 , string substr1 ) { int counter = 0 ; for ( int i = 0 ; i < str1 . Length ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) { for ( int j = i + 1 ; j < str1 . Length ; j ++ ) { if ( str1 [ j ] == substr1 [ 1 ] ) { for ( int k = j + 1 ; k < str1 . Length ; k ++ ) { if ( str1 [ k ] == substr1 [ 2 ] ) counter ++ ; } } } } } return counter ; } public static void Main ( ) { string str1 = " GFGFGYSYIOIWIN " ; string substr1 = " GFG " ; Console . WriteLine ( findOccurrences ( str1 , substr1 ) ) ; } }
using System ; public class GfG { public static int findOccurrences ( string str1 , string substr1 ) { int n = str1 . Length ; int [ ] preLeft = new int [ n ] ; int [ ] preRight = new int [ n ] ; if ( str1 [ 0 ] == substr1 [ 0 ] ) preLeft [ 0 ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) preLeft [ i ] = preLeft [ i - 1 ] + 1 ; else preLeft [ i ] = preLeft [ i - 1 ] ; } if ( str1 [ n - 1 ] == substr1 [ 2 ] ) preRight [ n - 1 ] ++ ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( str1 [ i ] == substr1 [ 2 ] ) preRight [ i ] = preRight [ i + 1 ] + 1 ; else preRight [ i ] = preRight [ i + 1 ] ; } int counter = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( str1 [ i ] == str1 [ 1 ] ) { int total = preLeft [ i - 1 ] * preRight [ i + 1 ] ; counter += total ; } } return counter ; } public static void Main ( ) { string str1 = " GFGFGYSYIOIWIN " ; string substr1 = " GFG " ; Console . WriteLine ( findOccurrences ( str1 , substr1 ) ) ; } }
using System ; class GFG { static void findString ( String str , int n , int k ) { if ( k == 0 ) { Console . Write ( str ) ; ; return ; } String str2 = str ; int p = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str2 [ i ] != ' a ' ) { str2 = str2 . Substring ( 0 , i ) + ' a ' + str2 . Substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } if ( p < k ) { for ( int i = n - 1 ; i >= 0 ; i -- ) if ( str [ i ] == ' a ' ) { str2 = str2 . Substring ( 0 , i ) + ' b ' + str2 . Substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } Console . Write ( str2 ) ; } public static void Main ( ) { String str = " pqrs " ; int n = str . Length ; int k = 2 ; findString ( str , n , k ) ; } }
using System ; class GFG { static void printSubsequences ( String s ) { char [ ] str = s . ToCharArray ( ) ; int n = str . Length ; int opsize = ( int ) ( Math . Pow ( 2 , n - 1 ) ) ; for ( int counter = 0 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) Console . Write ( " ▁ " ) ; } Console . WriteLine ( ) ; } } public static void Main ( ) { String str = " ABC " ; printSubsequences ( str ) ; } }
using System ; class GFG { static string evenlength ( string n ) { string res = n ; for ( int j = n . Length - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; } public static void Main ( ) { string n = "10" ; Console . WriteLine ( evenlength ( n ) ) ; } }
using System ; public class GFG { static bool uniqueCharacters ( String str ) { for ( int i = 0 ; i < str . Length ; i ++ ) for ( int j = i + 1 ; j < str . Length ; j ++ ) if ( str [ i ] == str [ j ] ) return false ; return true ; } public static void Main ( ) { string input = " GeeksforGeeks " ; if ( uniqueCharacters ( input ) == true ) Console . WriteLine ( " The ▁ String ▁ " + input + " ▁ has ▁ all ▁ unique ▁ characters " ) ; else Console . WriteLine ( " The ▁ String ▁ " + input + " ▁ has ▁ duplicate ▁ characters " ) ; } }
using System ; class GFG { static int findIndex ( string str ) { int len = str . Length ; int [ ] open = new int [ len + 1 ] ; int [ ] close = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str [ 0 ] == ' ( ' ) open [ 1 ] = 1 ; if ( str [ len - 1 ] == ' ) ' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] == ' ( ' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ) ' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; } public static void Main ( ) { string str = " ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) " ; Console . Write ( findIndex ( str ) ) ; } }
using System ; class GFG { static String decimalToBinary ( double num , int k_prec ) { String binary = " " ; int Integral = ( int ) num ; double fractional = num - Integral ; while ( Integral > 0 ) { int rem = Integral % 2 ; binary += ( ( char ) ( rem + '0' ) ) ; Integral /= 2 ; } binary = reverse ( binary ) ; binary += ( ' . ' ) ; while ( k_prec -- > 0 ) { fractional *= 2 ; int fract_bit = ( int ) fractional ; if ( fract_bit == 1 ) { fractional -= fract_bit ; binary += ( char ) ( 1 + '0' ) ; } else { binary += ( char ) ( 0 + '0' ) ; } } return binary ; } static String reverse ( String input ) { char [ ] temparray = input . ToCharArray ( ) ; int left , right = 0 ; right = temparray . Length - 1 ; for ( left = 0 ; left < right ; left ++ , right -- ) { char temp = temparray [ left ] ; temparray [ left ] = temparray [ right ] ; temparray [ right ] = temp ; } return String . Join ( " " , temparray ) ; } public static void Main ( String [ ] args ) { double n = 4.47 ; int k = 3 ; Console . WriteLine ( decimalToBinary ( n , k ) ) ; n = 6.986 ; k = 5 ; Console . WriteLine ( decimalToBinary ( n , k ) ) ; } }
using System ; class GFG { static bool isSmaller ( string str1 , string str2 ) { int n1 = str1 . Length , n2 = str2 . Length ; if ( n1 < n2 ) return true ; if ( n2 < n1 ) return false ; for ( int i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] < str2 [ i ] ) return true ; else if ( str1 [ i ] > str2 [ i ] ) return false ; } return false ; } static string findDiff ( string str1 , string str2 ) { if ( isSmaller ( str1 , str2 ) ) { string t = str1 ; str1 = str2 ; str2 = t ; } String str = " " ; int n1 = str1 . Length , n2 = str2 . Length ; int diff = n1 - n2 ; int carry = 0 ; for ( int i = n2 - 1 ; i >= 0 ; i -- ) { int sub = ( ( ( int ) str1 [ i + diff ] - ( int ) '0' ) - ( ( int ) str2 [ i ] - ( int ) '0' ) - carry ) ; if ( sub < 0 ) { sub = sub + 10 ; carry = 1 ; } else carry = 0 ; str += sub . ToString ( ) ; } for ( int i = n1 - n2 - 1 ; i >= 0 ; i -- ) { if ( str1 [ i ] == '0' && carry > 0 ) { str += "9" ; continue ; } int sub = ( ( ( int ) str1 [ i ] - ( int ) '0' ) - carry ) ; str += sub . ToString ( ) ; carry = 0 ; } char [ ] aa = str . ToCharArray ( ) ; Array . Reverse ( aa ) ; return new string ( aa ) ; } public static void Main ( ) { String str1 = "88" ; String str2 = "1079" ; Console . WriteLine ( findDiff ( str1 , str2 ) ) ; } }
using System ; class GFG { static int MAX_CHAR = 26 ; static bool areKAnagrams ( String str1 , String str2 , int k ) { int n = str1 . Length ; if ( str2 . Length != n ) return false ; int [ ] hash_str1 = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) hash_str1 [ str1 [ i ] - ' a ' ] ++ ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 [ i ] - ' a ' ] > 0 ) hash_str1 [ str2 [ i ] - ' a ' ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; } static void Main ( ) { String str1 = " fodr " ; String str2 = " gork " ; int k = 2 ; if ( areKAnagrams ( str1 , str2 , k ) == true ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static char getDigit ( int N , int d ) { string str = Convert . ToString ( N ) ; return str [ d - 1 ] ; } static char getNthChar ( int N ) { int sum = 0 , nine = 9 ; int dist = 0 , len ; for ( len = 1 ; ; len ++ ) { sum += nine * len ; dist += nine ; if ( sum >= N ) { sum -= nine * len ; dist -= nine ; N -= sum ; break ; } nine *= 10 ; } int diff = ( int ) ( Math . Ceiling ( ( double ) ( N ) / ( double ) ( len ) ) ) ; int d = N % len ; if ( d == 0 ) d = len ; return getDigit ( dist + diff , d ) ; } static void Main ( ) { int N = 251 ; Console . WriteLine ( getNthChar ( N ) ) ; } }
using System ; class GFG { static int findCount ( string str ) { int result = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( i == ( str [ i ] - ' a ' ) || i == ( str [ i ] - ' A ' ) ) result ++ ; return result ; } public static void Main ( ) { string str = " AbgdeF " ; Console . Write ( findCount ( str ) ) ; } }
using System ; class GFG { public static void print ( char [ ] str , int index ) { if ( index == str . Length ) { Console . WriteLine ( str ) ; return ; } if ( str [ index ] == ' ? ' ) { str [ index ] = '0' ; print ( str , index + 1 ) ; str [ index ] = '1' ; print ( str , index + 1 ) ; str [ index ] = ' ? ' ; } else print ( str , index + 1 ) ; } public static void Main ( ) { string input = "1 ? ? 0?101" ; char [ ] str = input . ToCharArray ( ) ; print ( str , 0 ) ; } }
class GFG { static int countOccurrences ( int x , int d ) { int count = 0 ; while ( x > 0 ) { if ( x % 10 == d ) count ++ ; x = x / 10 ; } return count ; } static int maxOccurring ( int x ) { if ( x < 0 ) x = - x ; int result = 0 ; int max_count = 1 ; for ( int d = 0 ; d <= 9 ; d ++ ) { int count = countOccurrences ( x , d ) ; if ( count >= max_count ) { max_count = count ; result = d ; } } return result ; } static void Main ( ) { int x = 1223355 ; System . Console . WriteLine ( " Max ▁ occurring ▁ digit ▁ is ▁ " + maxOccurring ( x ) ) ; } }
using System ; class GFG { static int maxSubarrayXOR ( int [ ] arr , int n ) { int ans = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int curr_xor = 0 ; for ( int j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . Max ( ans , curr_xor ) ; } } return ans ; } public static void Main ( ) { int [ ] arr = { 8 , 1 , 2 , 12 } ; int n = arr . Length ; Console . WriteLine ( " Max ▁ subarray ▁ XOR ▁ is ▁ " + maxSubarrayXOR ( arr , n ) ) ; } }
using System ; using System . Globalization ; class GFG { static int NO_OF_CHARS = 256 ; static char [ ] count = new char [ NO_OF_CHARS ] ; static void getCharCountArray ( string str ) { for ( int i = 0 ; i < str . Length ; i ++ ) count [ str [ i ] ] ++ ; } static int firstNonRepeating ( string str ) { getCharCountArray ( str ) ; int index = - 1 , i ; for ( i = 0 ; i < str . Length ; i ++ ) { if ( count [ str [ i ] ] == 1 ) { index = i ; break ; } } return index ; } public static void Main ( ) { string str = " geeksforgeeks " ; int index = firstNonRepeating ( str ) ; Console . WriteLine ( index == - 1 ? " Either ▁ " + " all ▁ characters ▁ are ▁ repeating ▁ or ▁ string ▁ " + " is ▁ empty " : " First ▁ non - repeating ▁ character " + " ▁ is ▁ " + str [ index ] ) ; } }
using System ; class GFG { static void divideString ( String str , int n ) { int str_size = str . Length ; int part_size ; if ( str_size % n != 0 ) { Console . Write ( " Invalid ▁ Input : ▁ String ▁ size " + " is ▁ not ▁ divisible ▁ by ▁ n " ) ; return ; } part_size = str_size / n ; for ( int i = 0 ; i < str_size ; i ++ ) { if ( i % part_size == 0 ) Console . WriteLine ( ) ; Console . Write ( str [ i ] ) ; } } static void Main ( ) { String str = " a _ simple _ divide _ string _ quest " ; divideString ( str , 4 ) ; } }
using System ; public class GFG { static bool isFeasible ( int mid , int [ ] arr , int n , int k ) { int pos = arr [ 0 ] ; int elements = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - pos >= mid ) { pos = arr [ i ] ; elements ++ ; if ( elements == k ) return true ; } } return false ; } static int largestMinDist ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int res = - 1 ; int left = 1 , right = arr [ n - 1 ] ; while ( left < right ) { int mid = ( left + right ) / 2 ; if ( isFeasible ( mid , arr , n , k ) ) { res = Math . Max ( res , mid ) ; left = mid + 1 ; } else right = mid ; } return res ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 8 , 4 , 9 } ; int n = arr . Length ; int k = 3 ; Console . WriteLine ( largestMinDist ( arr , n , k ) ) ; } }
using System ; class GFG { public static int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; int start = 1 , end = x , ans = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) return mid ; if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else end = mid - 1 ; } return ans ; } static public void Main ( ) { int x = 11 ; Console . WriteLine ( floorSqrt ( x ) ) ; } }
using System ; class GFG { static int countOdd ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; } static int countEven ( int n ) { int coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = ( ( n - 1 ) - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } else { m = ( n - i ) / 2 ; j = ( i * ( i + 1 ) ) / 2 ; coun += j * m ; } } return coun ; } static public void Main ( ) { int n = 5 ; if ( n >= 1 ) Console . Write ( countOdd ( n ) ) ; else Console . Write ( countEven ( n ) ) ; } }
using System ; class GFG { static float ellipse ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float x = ( float ) ( 3.14 * l * b ) / 4 ; return x ; } public static void Main ( ) { float a = 5 , b = 3 ; Console . WriteLine ( ellipse ( a , b ) ) ; } }
using System ; class GFG { static void noOfSquares ( int x1 , int y1 , int x2 , int y2 ) { int dx = Math . Abs ( x2 - x1 ) ; int dy = Math . Abs ( y2 - y1 ) ; int ans = dx + dy - __gcd ( dx , dy ) ; Console . WriteLine ( ans ) ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static void Main ( ) { int x1 = 1 , y1 = 1 , x2 = 4 , y2 = 3 ; noOfSquares ( x1 , y1 , x2 , y2 ) ; } }
using System ; class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long countPaths ( int x1 , int y1 , int x2 , int y2 ) { int m = Math . Abs ( x1 - x2 ) ; int n = Math . Abs ( y1 - y2 ) ; return ( binomialCoeff ( m + n , n ) ) ; } public static void Main ( ) { int x1 = 2 , y1 = 3 , x2 = 4 , y2 = 5 ; Console . Write ( countPaths ( x1 , y1 , x2 , y2 ) ) ; } }
using System ; class GFG { static double areaCircle ( double b ) { double area = ( double ) 3.1415926 * b * b ; return area ; } public static void Main ( ) { float b = 8 ; Console . WriteLine ( areaCircle ( b ) ) ; } }
using System ; class GFG { static void section ( double x1 , double x2 , double y1 , double y2 , double z1 , double z2 , double m , double n ) { double x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; double y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; double z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; Console . Write ( " ( " + x + " , ▁ " ) ; Console . Write ( y + " , ▁ " ) ; Console . WriteLine ( z + " ) " ) ; } static public void Main ( ) { double x1 = 2 , x2 = 4 , y1 = - 1 , y2 = 3 , z1 = 4 , z2 = 2 , m = 2 , n = 3 ; section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) ; } }
using System ; class GFG { static float findRadiusOfcircumcircle ( float n , float a ) { if ( n < 0 a < 0 ) return - 1 ; float radius = ( float ) ( a / Math . Sqrt ( 2 - ( 2 * Math . Cos ( 360 / n ) ) ) ) ; return radius ; } public static void Main ( ) { float n = 5 , a = 6 ; Console . WriteLine ( findRadiusOfcircumcircle ( n , a ) ) ; } }
using System ; class GFG { public static float findRadiusOfIncircle ( float a , float b , float c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; float p = ( a + b + c ) / 2 ; float area = ( float ) Math . Sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; float radius = area / p ; return ( float ) ( radius ) ; } public static void Main ( ) { float a = 2 , b = 2 , c = 3 ; Console . WriteLine ( findRadiusOfIncircle ( a , b , c ) ) ; } }
using System ; class GFG { static float area ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { double a = Math . Pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . Pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . Pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ; float area = ( float ) Math . Sqrt ( a ) ; area = area / 2 ; return area ; } public static void Main ( ) { int x1 = - 2 ; int y1 = 0 ; int z1 = - 5 ; int x2 = 1 ; int y2 = - 2 ; int z2 = - 1 ; float a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) ; Console . WriteLine ( " Area ▁ = ▁ " + a ) ; } }
using System ; class GFG { static float trapezoidarea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 3 * ( float ) Math . Sqrt ( 3 ) * ( float ) Math . Pow ( r , 2 ) ) / 4 ; return a ; } public static void Main ( ) { float r = 5 ; Console . WriteLine ( " " + trapezoidarea ( r ) ) ; } }
using System ; class GFG { static float rectanglearea ( float r ) { if ( r < 0 ) return - 1 ; float a = r * r ; return a ; } public static void Main ( ) { float r = 5 ; Console . Write ( ( int ) rectanglearea ( r ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int maxLines ( int n , int [ ] x1 , int [ ] y1 , int [ ] x2 , int [ ] y2 ) { HashSet < Double > s = new HashSet < Double > ( ) ; double slope ; for ( int i = 0 ; i < n ; ++ i ) { if ( x1 [ i ] == x2 [ i ] ) slope = int . MaxValue ; else slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; s . Add ( slope ) ; } return s . Count ; } public static void Main ( ) { int n = 2 ; int [ ] x1 = { 1 , 2 } ; int [ ] y1 = { 1 , 2 } ; int [ ] x2 = { 2 , 4 } ; int [ ] y2 = { 2 , 10 } ; Console . Write ( maxLines ( n , x1 , y1 , x2 , y2 ) ) ; } }
using System ; class GFG { static float area ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { float area = ( float ) Math . Sqrt ( Math . Pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . Pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . Pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; return area ; } public static void Main ( ) { float x1 = 3 ; float y1 = 1 ; float z1 = - 2 ; float x2 = 1 ; float y2 = - 3 ; float z2 = 4 ; float a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) ; Console . Write ( " Area ▁ = ▁ " + a ) ; } }
using System ; class GFG { static int max_intersection ( int [ ] center , int length , int k ) { Array . Sort ( center ) ; if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) { return 0 ; } else if ( center [ 2 ] - center [ 0 ] >= 2 * k ) { return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; } else return length ; } public static void Main ( ) { int [ ] center = { 1 , 2 , 3 } ; int L = 1 ; int K = 1 ; Console . WriteLine ( max_intersection ( center , L , K ) ) ; } }
using System ; class GFG { static double haversine ( double lat1 , double lon1 , double lat2 , double lon2 ) { double dLat = ( Math . PI / 180 ) * ( lat2 - lat1 ) ; double dLon = ( Math . PI / 180 ) * ( lon2 - lon1 ) ; lat1 = ( Math . PI / 180 ) * ( lat1 ) ; lat2 = ( Math . PI / 180 ) * ( lat2 ) ; double a = Math . Pow ( Math . Sin ( dLat / 2 ) , 2 ) + Math . Pow ( Math . Sin ( dLon / 2 ) , 2 ) * Math . Cos ( lat1 ) * Math . Cos ( lat2 ) ; double rad = 6371 ; double c = 2 * Math . Asin ( Math . Sqrt ( a ) ) ; return rad * c ; } public static void Main ( ) { double lat1 = 51.5007 ; double lon1 = 0.1246 ; double lat2 = 40.6892 ; double lon2 = 74.0445 ; Console . WriteLine ( haversine ( lat1 , lon1 , lat2 , lon2 ) + " ▁ K . M . " ) ; } }
using System ; class GFG { static int pentatopeNum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) ) / 24 ; } static public void Main ( String [ ] args ) { int n = 5 ; Console . WriteLine ( pentatopeNum ( n ) ) ; n = 11 ; Console . WriteLine ( pentatopeNum ( n ) ) ; } }
using System ; class GFG { static int heptagonalNumber ( int n ) { return ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( heptagonalNumber ( n ) ) ; n = 15 ; Console . WriteLine ( heptagonalNumber ( n ) ) ; } }
using System ; class GFG { static int icosidigonal_num ( int n ) { return ( 20 * n * n - 18 * n ) / 2 ; } static public void Main ( ) { int n = 4 ; Console . Write ( n + " th ▁ Icosidigonal ▁ " + " number ▁ : " ) ; Console . WriteLine ( icosidigonal_num ( n ) ) ; n = 8 ; Console . Write ( n + " th ▁ Icosidigonal ▁ " + " number ▁ : " ) ; Console . WriteLine ( icosidigonal_num ( n ) ) ; } }
using System ; class GfG { static int power ( int n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( power ( n ) ) ; } }
using System ; public class GFG { static void findPoint ( int x1 , int y1 , int x2 , int y2 ) { Console . WriteLine ( " ( " + ( int ) ( 2 * x2 - x1 ) + " , " + ( int ) ( 2 * y2 - y1 ) + " ▁ ) " ) ; } static public void Main ( String [ ] args ) { int x1 = 0 , y1 = 0 , x2 = 1 , y2 = 1 ; findPoint ( x1 , y1 , x2 , y2 ) ; } }
class GFG { static void parallel ( int [ , ] a ) { bool x = true , y = true ; for ( int i = 0 ; i < a . Rank - 1 ; i ++ ) { if ( a [ i , 0 ] != a [ i + 1 , 0 ] ) x = false ; if ( a [ i , 1 ] != a [ i + 1 , 1 ] ) y = false ; } if ( x ) System . Console . WriteLine ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; else if ( y ) System . Console . WriteLine ( " Parallel ▁ to ▁ X ▁ Axis " ) ; else System . Console . WriteLine ( " Not ▁ parallel ▁ to ▁ X " + " ▁ and ▁ Y ▁ axis " ) ; } public static void Main ( ) { int [ , ] a = { { 1 , 2 } , { 1 , 4 } , { 1 , 6 } , { 1 , 0 } } ; parallel ( a ) ; } }
using System ; class GFG { static int numberOfSticks ( int x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; } public static void Main ( ) { Console . Write ( numberOfSticks ( 7 ) ) ; } }
using System ; class GFG { static int find_Area ( int r ) { return ( 2 * r * r ) ; } public static void Main ( ) { int r = 3 ; Console . WriteLine ( " ▁ Area ▁ of ▁ square ▁ = ▁ " + find_Area ( r ) ) ; } }
using System ; class GFG { public static int checkValidity ( int a , int b , int c ) { if ( a + b <= c a + c <= b b + c <= a ) return 0 ; else return 1 ; } public static void Main ( ) { int a = 7 , b = 10 , c = 5 ; if ( ( checkValidity ( a , b , c ) ) == 1 ) Console . Write ( " Valid " ) ; else Console . Write ( " Invalid " ) ; } }
using System ; class GFG { static int M = 3 ; static int N = 3 ; static int contribution_height ( int current , int previous ) { return Math . Abs ( current - previous ) ; } static int surfaceArea ( int [ , ] A ) { int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { int up = 0 ; int left = 0 ; if ( i > 0 ) up = A [ i - 1 , j ] ; if ( j > 0 ) left = A [ i , j - 1 ] ; ans += contribution_height ( A [ i , j ] , up ) + contribution_height ( A [ i , j ] , left ) ; if ( i == N - 1 ) ans += A [ i , j ] ; if ( j == M - 1 ) ans += A [ i , j ] ; } } ans += N * M * 2 ; return ans ; } public static void Main ( ) { int [ , ] A = { { 1 , 3 , 4 } , { 2 , 2 , 3 } , { 1 , 2 , 4 } } ; Console . WriteLine ( surfaceArea ( A ) ) ; } }
using System ; class GFG { public static double area_of_tetrahedron ( int side ) { return ( Math . Sqrt ( 3 ) * ( side * side ) ) ; } static public void Main ( ) { int side = 3 ; Console . WriteLine ( " Area ▁ of ▁ Tetrahedron ▁ = ▁ " + area_of_tetrahedron ( side ) ) ; } }
using System ; class Tetrahedron { static double vol_tetra ( int side ) { double volume = ( Math . Pow ( side , 3 ) / ( 6 * Math . Sqrt ( 2 ) ) ) ; return volume ; } public static void Main ( ) { int side = 3 ; double vol = vol_tetra ( side ) ; vol = ( double ) Math . Round ( vol * 100 ) / 100 ; Console . WriteLine ( vol ) ; } }
using System ; class GFG { static int numberOfWays ( int x ) { int [ ] dp = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; } public static void Main ( ) { int x = 3 ; Console . WriteLine ( numberOfWays ( x ) ) ; } }
using System ; class GFG { static float area_equi_triangle ( float side ) { return ( float ) ( ( ( Math . Sqrt ( 3 ) ) / 4 ) * side * side ) ; } static float peri_equi_triangle ( float side ) { return 3 * side ; } public static void Main ( ) { float side = 4 ; Console . Write ( " Area ▁ of ▁ Equilateral ▁ Triangle : " ) ; Console . WriteLine ( area_equi_triangle ( side ) ) ; Console . Write ( " Perimeter ▁ of ▁ Equilateral ▁ Triangle : " ) ; Console . WriteLine ( peri_equi_triangle ( side ) ) ; } }
using System ; class GFG { static double areaCuboid ( double l , double h , double w ) { return ( l * h * w ) ; } static double surfaceAreaCuboid ( double l , double h , double w ) { return ( 2 * l * w + 2 * w * h + 2 * l * h ) ; } public static void Main ( ) { double l = 1 ; double h = 5 ; double w = 7 ; Console . WriteLine ( " Area ▁ = ▁ " + areaCuboid ( l , h , w ) ) ; Console . WriteLine ( " Total ▁ Surface ▁ Area ▁ = ▁ " + surfaceAreaCuboid ( l , h , w ) ) ; } }
using System ; class GFG { static double circumference ( double r ) { double PI = 3.1415 ; double cir = 2 * PI * r ; return cir ; } public static void Main ( ) { double r = 5 ; double result = Math . Round ( circumference ( r ) * 1000 ) / 1000.0 ; Console . WriteLine ( " Circumference ▁ = ▁ " + result ) ; } }
using System ; class GFG { static void cool_line ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { if ( ( y3 - y2 ) * ( x2 - x1 ) == ( y2 - y1 ) * ( x3 - x2 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } static public void Main ( ) { int a1 = 1 , a2 = 1 , a3 = 0 , b1 = 1 , b2 = 6 , b3 = 9 ; cool_line ( a1 , b1 , a2 , b2 , a3 , b3 ) ; } }
using System ; class GFG { public static long rectCount ( int n , int m ) { return ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 ; } public static void Main ( ) { int n = 5 , m = 4 ; Console . WriteLine ( rectCount ( n , m ) ) ; } }
using System ; class GFG { static int countRect ( int n ) { int ans = 0 ; for ( int length = 1 ; length <= Math . Sqrt ( n ) ; ++ length ) for ( int height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; } public static void Main ( ) { int n = 5 ; Console . Write ( countRect ( n ) ) ; } }
using System ; class GFG { static public void Main ( ) { int ax = 5 , ay = 0 ; int bx = 1 , by = 1 ; int cx = 2 , cy = 5 ; Console . WriteLine ( ax + ( cx - bx ) + " , ▁ " + ay + ( cy - by ) ) ; } }
using System ; class GFG { static void bestApproximate ( int [ ] x , int [ ] y ) { int n = x . Length ; double m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += Math . Pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - Math . Pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; Console . WriteLine ( " m ▁ = ▁ " + m ) ; Console . WriteLine ( " c ▁ = ▁ " + c ) ; } public static void Main ( ) { int [ ] x = { 1 , 2 , 3 , 4 , 5 } ; int [ ] y = { 14 , 27 , 40 , 55 , 68 } ; bestApproximate ( x , y ) ; } }
using System ; class GFG { static int size = 4 ; static bool checkStar ( int [ , ] mat ) { int vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 , 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 , 0 ] == 0 && mat [ 0 , 1 ] == 1 && mat [ 1 , 0 ] == 1 && mat [ 1 , 1 ] == 0 ) ; for ( int i = 0 ; i < size ; i ++ ) { int degreeI = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( mat [ i , j ] == 1 ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; } static void Main ( ) { int [ , ] mat = new int [ 4 , 4 ] { { 0 , 1 , 1 , 1 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } } ; if ( checkStar ( mat ) ) Console . Write ( " Star ▁ Graph " ) ; else Console . Write ( " Not ▁ a ▁ Star ▁ Graph " ) ; } }
using System ; class GFG { static int getMinSteps ( int n ) { int [ ] table = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) table [ i ] = n - i ; for ( int i = n ; i >= 1 ; i -- ) { if ( ! ( i % 2 > 0 ) ) table [ i / 2 ] = Math . Min ( table [ i ] + 1 , table [ i / 2 ] ) ; if ( ! ( i % 3 > 0 ) ) table [ i / 3 ] = Math . Min ( table [ i ] + 1 , table [ i / 3 ] ) ; } return table [ 1 ] ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( getMinSteps ( n ) ) ; } }
using System ; class GFG { public static bool isVowel ( char c ) { string vowel = " aeiou " ; for ( int i = 0 ; i < vowel . Length ; ++ i ) { if ( vowel [ i ] == c ) { return true ; } } return false ; } public static bool printRLE ( string str , string typed ) { int n = str . Length , m = typed . Length ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != typed [ j ] ) { return false ; } if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) { return false ; } } return true ; } public static void Main ( string [ ] args ) { string name = " alex " , typed = " aaalaeex " ; if ( printRLE ( name , typed ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static bool check ( int [ ] degree , int n ) { int deg_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { deg_sum += degree [ i ] ; } return ( 2 * ( n - 1 ) == deg_sum ) ; } public static void Main ( ) { int n = 5 ; int [ ] degree = { 2 , 3 , 1 , 1 , 1 } ; if ( check ( degree , n ) ) { Console . WriteLine ( " Tree " ) ; } else { Console . WriteLine ( " Graph " ) ; } } }
using System ; class GFG { static bool isInorder ( int [ ] arr , int n ) { if ( n == 0 n == 1 ) { return true ; } for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; } public static void Main ( ) { int [ ] arr = { 19 , 23 , 25 , 30 , 45 } ; int n = arr . Length ; if ( isInorder ( arr , n ) ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " Non " ) ; } } }
using System ; class GFG { static private void printSorted ( int [ ] arr , int start , int end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; Console . Write ( arr [ start ] + " ▁ " ) ; printSorted ( arr , start * 2 + 2 , end ) ; } static public void Main ( String [ ] args ) { int [ ] arr = { 4 , 2 , 5 , 1 , 3 } ; printSorted ( arr , 0 , arr . Length - 1 ) ; } }
using System ; class GFG { static int i = 0 ; static bool isLeaf ( int [ ] pre , int n , int min , int max ) { if ( i >= n ) { return false ; } if ( pre [ i ] > min && pre [ i ] < max ) { i ++ ; bool left = isLeaf ( pre , n , min , pre [ i - 1 ] ) ; bool right = isLeaf ( pre , n , pre [ i - 1 ] , max ) ; if ( ! left && ! right ) { Console . Write ( pre [ i - 1 ] + " ▁ " ) ; } return true ; } return false ; } static void printLeaves ( int [ ] preorder , int n ) { isLeaf ( preorder , n , int . MinValue , int . MaxValue ) ; } public static void Main ( String [ ] args ) { int [ ] preorder = { 890 , 325 , 290 , 530 , 965 } ; int n = preorder . Length ; printLeaves ( preorder , n ) ; } }
using System ; class GFG { static void pairs ( int [ ] arr , int n , int k ) { int smallest = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { if ( Math . Abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . Abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . Abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } Console . WriteLine ( " Minimal ▁ Value ▁ = ▁ " + smallest ) ; Console . WriteLine ( " Total ▁ Pairs ▁ = ▁ " + count ) ; } public static void Main ( ) { int [ ] arr = { 3 , 5 , 7 , 5 , 1 , 9 , 9 } ; int k = 12 ; int n = arr . Length ; pairs ( arr , n , k ) ; } }
using System ; class GFG { public static void Main ( ) { int [ ] a = { 5 , 1 , 14 , 4 , 15 , 9 , 7 , 20 , 11 } ; int key = 20 ; int arraySize = a . Length ; int count = 0 ; for ( int i = 0 ; i < arraySize ; i ++ ) { if ( a [ i ] <= key ) { count += 1 ; } } Console . WriteLine ( " Rank ▁ of ▁ " + key + " ▁ in ▁ stream ▁ is : ▁ " + ( count - 1 ) ) ; } }
using System ; class GFG { static int MAX = 100 ; static void middlesum ( int [ , ] mat , int n ) { int row_sum = 0 , col_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) row_sum += mat [ n / 2 , i ] ; Console . WriteLine ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " + row_sum ) ; for ( int i = 0 ; i < n ; i ++ ) col_sum += mat [ i , n / 2 ] ; Console . WriteLine ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " + col_sum ) ; } public static void Main ( ) { int [ , ] mat = { { 2 , 5 , 7 } , { 3 , 7 , 2 } , { 5 , 6 , 9 } } ; middlesum ( mat , 3 ) ; } }
using System ; class GFG { static int M = 3 ; static int N = 3 ; static void rotateMatrix ( int [ , ] matrix , int k ) { int [ ] temp = new int [ M ] ; k = k % M ; for ( int i = 0 ; i < N ; i ++ ) { for ( int t = 0 ; t < M - k ; t ++ ) temp [ t ] = matrix [ i , t ] ; for ( int j = M - k ; j < M ; j ++ ) matrix [ i , j - M + k ] = matrix [ i , j ] ; for ( int j = k ; j < M ; j ++ ) matrix [ i , j ] = temp [ j - k ] ; } } static void displayMatrix ( int [ , ] matrix ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) Console . Write ( matrix [ i , j ] + " ▁ " ) ; Console . WriteLine ( ) ; } } public static void Main ( ) { int [ , ] matrix = { { 12 , 23 , 34 } , { 45 , 56 , 67 } , { 78 , 89 , 91 } } ; int k = 2 ; rotateMatrix ( matrix , k ) ; displayMatrix ( matrix ) ; } }
using System ; class GFG { static int N = 3 ; static void multiply ( int [ , ] mat , int [ , ] res ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { res [ i , j ] = 0 ; for ( int k = 0 ; k < N ; k ++ ) res [ i , j ] += mat [ i , k ] * mat [ k , j ] ; } } } static bool InvolutoryMatrix ( int [ , ] mat ) { int [ , ] res = new int [ N , N ] ; multiply ( mat , res ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( i == j && res [ i , j ] != 1 ) return false ; if ( i != j && res [ i , j ] != 0 ) return false ; } } return true ; } public static void Main ( ) { int [ , ] mat = { { 1 , 0 , 0 } , { 0 , - 1 , 0 } , { 0 , 0 , - 1 } } ; if ( InvolutoryMatrix ( mat ) ) Console . WriteLine ( " Involutory ▁ Matrix " ) ; else Console . WriteLine ( " Not ▁ Involutory ▁ Matrix " ) ; } }
using System ; class GFG { public static void interchangeFirstLast ( int [ ] [ ] m ) { int rows = m . Length ; for ( int i = 0 ; i < m [ 0 ] . Length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } public static void Main ( string [ ] args ) { int [ ] [ ] m = new int [ ] [ ] { new int [ ] { 8 , 9 , 7 , 6 } , new int [ ] { 4 , 7 , 6 , 5 } , new int [ ] { 3 , 2 , 1 , 8 } , new int [ ] { 9 , 9 , 7 , 7 } } ; interchangeFirstLast ( m ) ; for ( int i = 0 ; i < m . Length ; i ++ ) { for ( int j = 0 ; j < m [ 0 ] . Length ; j ++ ) { Console . Write ( m [ i ] [ j ] + " ▁ " ) ; } Console . WriteLine ( ) ; } } }
using System ; class GFG { static bool checkMarkov ( double [ , ] m ) { for ( int i = 0 ; i < m . GetLength ( 0 ) ; i ++ ) { double sum = 0 ; for ( int j = 0 ; j < m . GetLength ( 1 ) ; j ++ ) sum = sum + m [ i , j ] ; if ( sum != 1 ) return false ; } return true ; } static void Main ( ) { double [ , ] m = new double [ , ] { { 0 , 0 , 1 } , { 0.5 , 0 , 0.5 } , { 1 , 0 , 0 } } ; if ( checkMarkov ( m ) ) Console . WriteLine ( " ▁ yes ▁ " ) ; else Console . WriteLine ( " ▁ no ▁ " ) ; } }
using System ; class GFG { static int N = 4 ; static bool isDiagonalMatrix ( int [ , ] mat ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i , j ] != 0 ) ) return false ; return true ; } public static void Main ( ) { int [ , ] mat = { { 4 , 0 , 0 , 0 } , { 0 , 7 , 0 , 0 } , { 0 , 0 , 5 , 0 } , { 0 , 0 , 0 , 1 } } ; if ( isDiagonalMatrix ( mat ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int N = 4 ; static bool isScalarMatrix ( int [ , ] mat ) { for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i , j ] != 0 ) ) return false ; for ( int i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i , i ] != mat [ i + 1 , i + 1 ] ) return false ; return true ; } public static void Main ( ) { int [ , ] mat = { { 2 , 0 , 0 , 0 } , { 0 , 2 , 0 , 0 } , { 0 , 0 , 2 , 0 } , { 0 , 0 , 0 , 2 } } ; if ( isScalarMatrix ( mat ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int N = 3 ; static bool isMagicSquare ( int [ , ] mat ) { int sum = 0 , sum2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum = sum + mat [ i , i ] ; for ( int i = 0 ; i < N ; i ++ ) sum2 = sum2 + mat [ i , N - 1 - i ] ; if ( sum != sum2 ) return false ; for ( int i = 0 ; i < N ; i ++ ) { int rowSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) rowSum += mat [ i , j ] ; if ( rowSum != sum ) return false ; } for ( int i = 0 ; i < N ; i ++ ) { int colSum = 0 ; for ( int j = 0 ; j < N ; j ++ ) colSum += mat [ j , i ] ; if ( sum != colSum ) return false ; } return true ; } public static void Main ( ) { int [ , ] mat = new int [ , ] { { 2 , 7 , 6 } , { 9 , 5 , 1 } , { 4 , 3 , 8 } } ; if ( isMagicSquare ( mat ) ) Console . WriteLine ( " Magic ▁ Square " ) ; else Console . WriteLine ( " Not ▁ a ▁ magic " + " ▁ Square " ) ; } }
using System ; class GFG { static int subCount ( int [ ] arr , int n , int k ) { int [ ] mod = new int [ k ] ; int cumSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { cumSum += arr [ i ] ; mod [ ( ( cumSum % k ) + k ) % k ] ++ ; } int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) if ( mod [ i ] > 1 ) result += ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ; result += mod [ 0 ] ; return result ; } static int countSubmatrix ( int [ , ] mat , int n , int k ) { int tot_count = 0 ; int left , right , i ; int [ ] temp = new int [ n ] ; for ( left = 0 ; left < n ; left ++ ) { for ( right = left ; right < n ; right ++ ) { for ( i = 0 ; i < n ; ++ i ) temp [ i ] += mat [ i , right ] ; tot_count += subCount ( temp , n , k ) ; } } return tot_count - 3 ; } static void Main ( ) { int [ , ] mat = new int [ , ] { { 5 , - 1 , 6 } , { - 2 , 3 , 8 } , { 7 , 4 , - 9 } } ; int n = 3 , k = 4 ; Console . Write ( " Count = " countSubmatrix ( mat , n , k ) ) ; } }
using System ; public class GfG { public static int find ( int n , int k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; } public static void Main ( ) { int n = 4 , k = 7 ; int freq = find ( n , k ) ; if ( freq < 0 ) Console . WriteLine ( " ▁ element " + " ▁ not ▁ exist ▁ " ) ; else Console . WriteLine ( " ▁ Frequency " + " ▁ of ▁ " + k + " ▁ is ▁ " + freq ) ; } }
using System ; public class GfG { public static void ZigZag ( int rows , int columns , int [ ] numbers ) { int k = 0 ; int [ , ] arr = new int [ rows , columns ] ; for ( int i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( int j = 0 ; j < columns && numbers [ k ] > 0 ; j ++ ) { arr [ i , j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } else { for ( int j = columns - 1 ; j >= 0 && numbers [ k ] > 0 ; j -- ) { arr [ i , j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } } for ( int i = 0 ; i < rows ; i ++ ) { for ( int j = 0 ; j < columns ; j ++ ) Console . Write ( arr [ i , j ] + " ▁ " ) ; Console . WriteLine ( ) ; } } public static void Main ( ) { int rows = 4 ; int columns = 5 ; int [ ] Numbers = new int [ ] { 3 , 4 , 2 , 2 , 3 , 1 , 5 } ; ZigZag ( rows , columns , Numbers ) ; } }
using System ; class GFG { static int numberofPosition ( int n , int k , int x , int y , int [ ] obstPosx , int [ ] obstPosy ) { int d11 , d12 , d21 , d22 , r1 , r2 , c1 , c2 ; d11 = Math . Min ( x - 1 , y - 1 ) ; d12 = Math . Min ( n - x , n - y ) ; d21 = Math . Min ( n - x , y - 1 ) ; d22 = Math . Min ( x - 1 , n - y ) ; r1 = y - 1 ; r2 = n - y ; c1 = x - 1 ; c2 = n - x ; for ( int i = 0 ; i < k ; i ++ ) { if ( x > obstPosx [ i ] && y > obstPosy [ i ] && x - obstPosx [ i ] == y - obstPosy [ i ] ) d11 = Math . Min ( d11 , x - obstPosx [ i ] - 1 ) ; if ( obstPosx [ i ] > x && obstPosy [ i ] > y && obstPosx [ i ] - x == obstPosy [ i ] - y ) d12 = Math . Min ( d12 , obstPosx [ i ] - x - 1 ) ; if ( obstPosx [ i ] > x && y > obstPosy [ i ] && obstPosx [ i ] - x == y - obstPosy [ i ] ) d21 = Math . Min ( d21 , obstPosx [ i ] - x - 1 ) ; if ( x > obstPosx [ i ] && obstPosy [ i ] > y && x - obstPosx [ i ] == obstPosy [ i ] - y ) d22 = Math . Min ( d22 , x - obstPosx [ i ] - 1 ) ; if ( x == obstPosx [ i ] && obstPosy [ i ] < y ) r1 = Math . Min ( r1 , y - obstPosy [ i ] - 1 ) ; if ( x == obstPosx [ i ] && obstPosy [ i ] > y ) r2 = Math . Min ( r2 , obstPosy [ i ] - y - 1 ) ; if ( y == obstPosy [ i ] && obstPosx [ i ] < x ) c1 = Math . Min ( c1 , x - obstPosx [ i ] - 1 ) ; if ( y == obstPosy [ i ] && obstPosx [ i ] > x ) c2 = Math . Min ( c2 , obstPosx [ i ] - x - 1 ) ; } return d11 + d12 + d21 + d22 + r1 + r2 + c1 + c2 ; } public static void Main ( ) { int n = 8 ; int k = 1 ; int Qposx = 4 ; int Qposy = 4 ; int [ ] obstPosx = { 3 } ; int [ ] obstPosy = { 5 } ; Console . WriteLine ( numberofPosition ( n , k , Qposx , Qposy , obstPosx , obstPosy ) ) ; } }
using System ; public class GFG { static int n = 5 ; static int FindMaxProduct ( int [ , ] arr , int n ) { int max = 0 , result ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i , j ] * arr [ i , j - 1 ] * arr [ i , j - 2 ] * arr [ i , j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i , j ] * arr [ i - 1 , j ] * arr [ i - 2 , j ] * arr [ i - 3 , j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i , j ] * arr [ i - 1 , j - 1 ] * arr [ i - 2 , j - 2 ] * arr [ i - 3 , j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) { result = arr [ i , j ] * arr [ i - 1 , j + 1 ] * arr [ i - 2 , j + 2 ] * arr [ i - 3 , j + 3 ] ; if ( max < result ) max = result ; } } } return max ; } static public void Main ( ) { int [ , ] arr = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 1 } , { 2 , 3 , 4 , 5 , 6 } , { 7 , 8 , 9 , 1 , 0 } , { 9 , 6 , 4 , 2 , 3 } } ; Console . Write ( FindMaxProduct ( arr , n ) ) ; } }
using System ; class GFG { static int minimumflip ( int [ , ] mat , int n ) { int [ , ] transpose = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) transpose [ i , j ] = mat [ j , i ] ; int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( transpose [ i , j ] != mat [ i , j ] ) flip ++ ; return flip / 2 ; } public static void Main ( ) { int n = 3 ; int [ , ] mat = { { 0 , 0 , 1 } , { 1 , 1 , 1 } , { 1 , 0 , 0 } } ; Console . WriteLine ( minimumflip ( mat , n ) ) ; } }
using System ; class GFG { static int minimumflip ( int [ , ] mat , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( mat [ i , j ] != mat [ j , i ] ) flip ++ ; return flip ; } public static void Main ( ) { int n = 3 ; int [ , ] mat = { { 0 , 0 , 1 } , { 1 , 1 , 1 } , { 1 , 0 , 0 } } ; Console . WriteLine ( minimumflip ( mat , n ) ) ; } }
using System ; class GFG { static int MAX = 100 ; static void freq ( int [ , ] ar , int m , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < m ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( ( ar [ i , j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } Console . WriteLine ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " + odd ) ; Console . WriteLine ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = ▁ " + even ) ; } public static void Main ( ) { int m = 3 , n = 3 ; int [ , ] array = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; freq ( array , m , n ) ; } }
using System ; class GFG { static bool HalfDiagonalSums ( int [ , ] mat , int n ) { int diag1_left = 0 , diag1_right = 0 ; int diag2_left = 0 , diag2_right = 0 ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < n / 2 ) { diag1_left += mat [ i , i ] ; diag2_left += mat [ j , i ] ; } else if ( i > n / 2 ) { diag1_right += mat [ i , i ] ; diag2_right += mat [ j , i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ n / 2 , n / 2 ] ) ; } static public void Main ( ) { int [ , ] a = { { 2 , 9 , 1 , 4 , - 2 } , { 6 , 7 , 2 , 11 , 4 } , { 4 , 2 , 9 , 2 , 4 } , { 1 , 9 , 2 , 4 , 4 } , { 0 , 2 , 4 , 2 , 5 } } ; Console . WriteLine ( HalfDiagonalSums ( a , 5 ) ? " Yes " : " No " ) ; } }
using System ; class GFG { static int identity ( int num ) { int row , col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) Console . Write ( 1 + " ▁ " ) ; else Console . Write ( 0 + " ▁ " ) ; } Console . WriteLine ( ) ; } return 0 ; } public static void Main ( ) { int size = 5 ; identity ( size ) ; } }
using System ; class GFG { int MAX = 100 ; static bool isIdentity ( int [ , ] mat , int N ) { for ( int row = 0 ; row < N ; row ++ ) { for ( int col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row , col ] != 1 ) return false ; else if ( row != col && mat [ row , col ] != 0 ) return false ; } } return true ; } public static void Main ( ) { int N = 4 ; int [ , ] mat = { { 1 , 0 , 0 , 0 } , { 0 , 1 , 0 , 0 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 1 } } ; if ( isIdentity ( mat , N ) ) Console . WriteLine ( " Yes ▁ " ) ; else Console . WriteLine ( " No ▁ " ) ; } }
using System ; class Example { static long mod = 100000007 ; static long modPower ( long a , long t , long mod ) { long now = a , ret = 1 ; while ( t > 0 ) { if ( t % 2 == 1 ) ret = now * ( ret % mod ) ; now = now * ( now % mod ) ; t >>= 1 ; } return ret ; } static long countWays ( int n , int m , int k ) { if ( n == 1 m == 1 ) return 1 ; else if ( ( n + m ) % 2 == 1 && k == - 1 ) return 0 ; return ( modPower ( modPower ( ( long ) 2 , n - 1 , mod ) , m - 1 , mod ) % mod ) ; } public static void Main ( ) { int n = 2 , m = 7 , k = 1 ; Console . WriteLine ( countWays ( n , m , k ) ) ; } }
using System ; class GFG { static int MAX = 100 ; static void imageSwap ( int [ , ] mat , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j <= i ; j ++ ) mat [ i , j ] = mat [ i , j ] + mat [ j , i ] - ( mat [ j , i ] = mat [ i , j ] ) ; } static void printMatrix ( int [ , ] mat , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) Console . Write ( mat [ i , j ] + " ▁ " ) ; Console . WriteLine ( ) ; } } public static void Main ( ) { int [ , ] mat = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 9 , 10 , 11 , 12 } , { 13 , 14 , 15 , 16 } } ; int n = 4 ; imageSwap ( mat , n ) ; printMatrix ( mat , n ) ; } }
using System ; class GFG { private static void search ( int [ , ] mat , int n , int x ) { int i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i , j ] == x ) { Console . Write ( " n ▁ Found ▁ at ▁ " + i + " , ▁ " + j ) ; return ; } if ( mat [ i , j ] > x ) j -- ; else i ++ ; } Console . Write ( " n ▁ Element ▁ not ▁ found " ) ; return ; } public static void Main ( ) { int [ , ] mat = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } } ; search ( mat , 4 , 29 ) ; } }
using System ; class GFG { static void fill0X ( int m , int n ) { int i , k = 0 , l = 0 ; int r = m , c = n ; char [ , ] a = new char [ m , n ] ; char x = ' X ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) a [ k , i ] = x ; k ++ ; for ( i = k ; i < m ; ++ i ) a [ i , n - 1 ] = x ; n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 , i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) a [ i , l ] = x ; l ++ ; } x = ( x == '0' ) ? ' X ' : '0' ; } for ( i = 0 ; i < r ; i ++ ) { for ( int j = 0 ; j < c ; j ++ ) Console . Write ( a [ i , j ] + " ▁ " ) ; Console . WriteLine ( ) ; } } public static void Main ( ) { Console . WriteLine ( " Output ▁ for " + " ▁ m ▁ = ▁ 5 , ▁ n ▁ = ▁ 6" ) ; fill0X ( 5 , 6 ) ; Console . WriteLine ( " Output ▁ for " + " ▁ m ▁ = ▁ 4 , ▁ n ▁ = ▁ 4" ) ; fill0X ( 4 , 4 ) ; Console . WriteLine ( " Output ▁ for " + " ▁ m ▁ = ▁ 3 , ▁ n ▁ = ▁ 4" ) ; fill0X ( 3 , 4 ) ; } }
using System ; class GFG { public static int calculateEnergy ( int [ , ] mat , int n ) { int i_des , j_des , q ; int tot_energy = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { q = mat [ i , j ] / n ; i_des = q ; j_des = mat [ i , j ] - ( n * q ) ; tot_energy += Math . Abs ( i_des - i ) + Math . Abs ( j_des - j ) ; } } return tot_energy ; } public static void Main ( ) { int [ , ] mat = new int [ , ] { { 4 , 7 , 0 , 3 } , { 8 , 5 , 6 , 1 } , { 9 , 11 , 10 , 2 } , { 15 , 13 , 14 , 12 } } ; int n = 4 ; Console . Write ( " Total ▁ energy ▁ required ▁ = ▁ " + calculateEnergy ( mat , n ) + " ▁ units " ) ; } }
using System ; public class GFG { static readonly int MAX = 100 ; static bool isUnique ( int [ , ] mat , int i , int j , int n , int m ) { int sumrow = 0 ; for ( int k = 0 ; k < m ; k ++ ) { sumrow += mat [ i , k ] ; if ( sumrow > 1 ) return false ; } int sumcol = 0 ; for ( int k = 0 ; k < n ; k ++ ) { sumcol += mat [ k , j ] ; if ( sumcol > 1 ) return false ; } return true ; } static int countUnique ( int [ , ] mat , int n , int m ) { int uniquecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) if ( mat [ i , j ] != 0 && isUnique ( mat , i , j , n , m ) ) uniquecount ++ ; return uniquecount ; } static public void Main ( ) { int [ , ] mat = { { 0 , 1 , 0 , 0 } , { 0 , 0 , 1 , 0 } , { 1 , 0 , 0 , 1 } } ; Console . Write ( countUnique ( mat , 3 , 4 ) ) ; } }
using System ; class GFG { static bool isSparse ( int [ , ] array , int m , int n ) { int counter = 0 ; for ( int i = 0 ; i < m ; ++ i ) for ( int j = 0 ; j < n ; ++ j ) if ( array [ i , j ] == 0 ) ++ counter ; return ( counter > ( ( m * n ) / 2 ) ) ; } public static void Main ( ) { int [ , ] array = { { 1 , 0 , 3 } , { 0 , 0 , 4 } , { 6 , 0 , 0 } } ; int m = 3 , n = 3 ; if ( isSparse ( array , m , n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int countCommon ( int [ , ] mat , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( mat [ i , i ] == mat [ i , n - i - 1 ] ) res ++ ; return res ; } public static void Main ( ) { int [ , ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; Console . WriteLine ( countCommon ( mat , 3 ) ) ; } }
using System ; class GFG { static bool areSumSame ( int [ , ] a , int n , int m ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { sum1 += a [ i , j ] ; sum2 += a [ j , i ] ; } if ( sum1 == sum2 ) return true ; } return false ; } public static void Main ( ) { int n = 4 ; int m = 4 ; int [ , ] M = { { 1 , 2 , 3 , 4 } , { 9 , 5 , 3 , 1 } , { 0 , 3 , 5 , 6 } , { 0 , 4 , 5 , 6 } } ; if ( areSumSame ( M , n , m ) == true ) Console . Write ( "1 STRNEWLINE " ) ; else Console . Write ( "0 STRNEWLINE " ) ; } }
using System ; class GFG { static int N = 4 ; static void findMax ( int [ , ] arr ) { int row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i , j ] == 1 && j >= 0 ) { row = i ; j -- ; } } Console . Write ( " Row ▁ number ▁ = ▁ " + ( row + 1 ) ) ; Console . Write ( " , ▁ MaxCount ▁ = ▁ " + ( N - 1 - j ) ) ; } public static void Main ( ) { int [ , ] arr = { { 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 0 } , { 0 , 1 , 1 , 1 } } ; findMax ( arr ) ; } }
using System ; class GFG { static int n = 4 ; static int m = 4 ; static int findPossibleMoves ( int [ , ] mat , int p , int q ) { int [ ] X = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; int [ ] Y = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; int count = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) { int x = p + X [ i ] ; int y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x , y ] == 0 ) count ++ ; } return count ; } static public void Main ( ) { int [ , ] mat = { { 1 , 0 , 1 , 0 } , { 0 , 1 , 1 , 1 } , { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 1 } } ; int p = 2 , q = 2 ; Console . WriteLine ( findPossibleMoves ( mat , p , q ) ) ; } }
using System ; public class GFG { static void printDiagonalSums ( int [ , ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i , j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i , j ] ; } } Console . WriteLine ( " Principal ▁ Diagonal : " + principal ) ; Console . WriteLine ( " Secondary ▁ Diagonal : " + secondary ) ; } static public void Main ( ) { int [ , ] a = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printDiagonalSums ( a , 4 ) ; } }
using System ; public class GFG { static void printDiagonalSums ( int [ , ] mat , int n ) { int principal = 0 , secondary = 0 ; for ( int i = 0 ; i < n ; i ++ ) { principal += mat [ i , i ] ; secondary += mat [ i , n - i - 1 ] ; } Console . WriteLine ( " Principal ▁ Diagonal : " + principal ) ; Console . WriteLine ( " Secondary ▁ Diagonal : " + secondary ) ; } static public void Main ( ) { int [ , ] a = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printDiagonalSums ( a , 4 ) ; } }
using System ; class GFG { public static void printBoundary ( int [ , ] a , int m , int n ) { for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) Console . Write ( a [ i , j ] + " ▁ " ) ; else if ( i == m - 1 ) Console . Write ( a [ i , j ] + " ▁ " ) ; else if ( j == 0 ) Console . Write ( a [ i , j ] + " ▁ " ) ; else if ( j == n - 1 ) Console . Write ( a [ i , j ] + " ▁ " ) ; else Console . Write ( " ▁ " ) ; } Console . WriteLine ( " ▁ " ) ; } } static public void Main ( ) { int [ , ] a = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; printBoundary ( a , 4 , 4 ) ; } }
using System ; class GFG { public static long getBoundarySum ( int [ , ] a , int m , int n ) { long sum = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i , j ] ; else if ( i == m - 1 ) sum += a [ i , j ] ; else if ( j == 0 ) sum += a [ i , j ] ; else if ( j == n - 1 ) sum += a [ i , j ] ; } } return sum ; } static public void Main ( ) { int [ , ] a = { { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } , { 1 , 2 , 3 , 4 } , { 5 , 6 , 7 , 8 } } ; long sum = getBoundarySum ( a , 4 , 4 ) ; Console . WriteLine ( " Sum ▁ of ▁ boundary " + " ▁ elements ▁ is ▁ " + sum ) ; } }
using System ; class GFG { static void printSpiral ( int [ , ] mat , int r , int c ) { int i , a = 0 , b = 2 ; int low_row = ( 0 > a ) ? 0 : a ; int low_column = ( 0 > b ) ? 0 : b - 1 ; int high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; int high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) Console . Write ( mat [ low_row , i ] + " ▁ " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) Console . Write ( mat [ i , high_column ] + " ▁ " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) Console . Write ( mat [ high_row , i ] + " ▁ " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) Console . Write ( mat [ i , low_column ] + " ▁ " ) ; low_column -= 1 ; } Console . WriteLine ( ) ; } static public void Main ( ) { int [ , ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int r = 3 , c = 3 ; printSpiral ( mat , r , c ) ; } }
using System ; public class GFG { public static int difference ( int [ , ] arr , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i , j ] ; if ( i == n - j - 1 ) d2 += arr [ i , j ] ; } } return Math . Abs ( d1 - d2 ) ; } public static void Main ( ) { int n = 3 ; int [ , ] arr = { { 11 , 2 , 4 } , { 4 , 5 , 6 } , { 10 , 8 , - 12 } } ; Console . Write ( difference ( arr , n ) ) ; } }
using System ; public class GFG { public static int difference ( int [ , ] arr , int n ) { int d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += arr [ i , i ] ; d2 += arr [ i , n - i - 1 ] ; } return Math . Abs ( d1 - d2 ) ; } public static void Main ( ) { int n = 3 ; int [ , ] arr = { { 11 , 2 , 4 } , { 4 , 5 , 6 } , { 10 , 8 , - 12 } } ; Console . Write ( difference ( arr , n ) ) ; } }
using System ; class GFG { static int MAX = 100 ; static void spiralFill ( int m , int n , int [ , ] a ) { int val = 1 ; int k = 0 , l = 0 ; while ( k < m && l < n ) { for ( int i = l ; i < n ; ++ i ) { a [ k , i ] = val ++ ; } k ++ ; for ( int i = k ; i < m ; ++ i ) { a [ i , n - 1 ] = val ++ ; } n -- ; if ( k < m ) { for ( int i = n - 1 ; i >= l ; -- i ) { a [ m - 1 , i ] = val ++ ; } m -- ; } if ( l < n ) { for ( int i = m - 1 ; i >= k ; -- i ) { a [ i , l ] = val ++ ; } l ++ ; } } } public static void Main ( ) { int m = 4 , n = 4 ; int [ , ] a = new int [ MAX , MAX ] ; spiralFill ( m , n , a ) ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( a [ i , j ] + " ▁ " ) ; } Console . Write ( " STRNEWLINE " ) ; } } }
using System ; public class GFG { static void maxMin ( int [ , ] arr , int n ) { int min = + 2147483647 ; int max = - 2147483648 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i , j ] > arr [ i , n - j - 1 ] ) { if ( min > arr [ i , n - j - 1 ] ) min = arr [ i , n - j - 1 ] ; if ( max < arr [ i , j ] ) max = arr [ i , j ] ; } else { if ( min > arr [ i , j ] ) min = arr [ i , j ] ; if ( max < arr [ i , n - j - 1 ] ) max = arr [ i , n - j - 1 ] ; } } } Console . Write ( " Maximum ▁ = ▁ " + max + " , ▁ Minimum ▁ = ▁ " + min ) ; } static public void Main ( ) { int [ , ] arr = { { 5 , 9 , 11 } , { 25 , 0 , 14 } , { 21 , 6 , 4 } } ; maxMin ( arr , 3 ) ; } }
using System ; public class GFG { public const int N = 5 ; public const int M = 5 ; public static int minOperation ( bool [ ] [ ] arr ) { int ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { for ( int j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( int k = 0 ; k <= i ; k ++ ) { for ( int h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; } public static void Main ( string [ ] args ) { bool [ ] [ ] mat = new bool [ ] [ ] { new bool [ ] { false , false , true , true , true } , new bool [ ] { false , false , false , true , true } , new bool [ ] { false , false , false , true , true } , new bool [ ] { true , true , true , true , true } , new bool [ ] { true , true , true , true , true } } ; Console . WriteLine ( minOperation ( mat ) ) ; } }
using System ; class GFG { static int findSum ( int n ) { int ans = 0 , temp = 0 , num ; for ( int i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; } public static void Main ( ) { int N = 2 ; Console . WriteLine ( findSum ( N ) ) ; } }
using System ; class GFG { static int countOps ( int [ , ] A , int [ , ] B , int m , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) A [ i , j ] -= B [ i , j ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 1 ; j < m ; j ++ ) if ( A [ i , j ] - A [ i , 0 ] - A [ 0 , j ] + A [ 0 , 0 ] != 0 ) return - 1 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) result += Math . Abs ( A [ i , 0 ] ) ; for ( int j = 0 ; j < m ; j ++ ) result += Math . Abs ( A [ 0 , j ] - A [ 0 , 0 ] ) ; return ( result ) ; } public static void Main ( ) { int [ , ] A = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int [ , ] B = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; Console . Write ( countOps ( A , B , 3 , 3 ) ) ; } }
using System ; class GFG { static void printCoils ( int n ) { int m = 8 * n * n ; int [ ] coil1 = new int [ m ] ; coil1 [ 0 ] = 8 * n * n + 2 * n ; int curr = coil1 [ 0 ] ; int nflg = 1 , step = 2 ; int index = 1 ; while ( index < m ) { for ( int i = 0 ; i < step ; i ++ ) { curr = coil1 [ index ++ ] = ( curr - 4 * n * nflg ) ; if ( index >= m ) break ; } if ( index >= m ) break ; for ( int i = 0 ; i < step ; i ++ ) { curr = coil1 [ index ++ ] = curr + nflg ; if ( index >= m ) break ; } nflg = nflg * ( - 1 ) ; step += 2 ; } int [ ] coil2 = new int [ m ] ; for ( int i = 0 ; i < 8 * n * n ; i ++ ) coil2 [ i ] = 16 * n * n + 1 - coil1 [ i ] ; Console . Write ( " Coil ▁ 1 ▁ : ▁ " ) ; for ( int i = 0 ; i < 8 * n * n ; i ++ ) Console . Write ( coil1 [ i ] + " ▁ " ) ; Console . Write ( " STRNEWLINE Coil ▁ 2 ▁ : ▁ " ) ; for ( int i = 0 ; i < 8 * n * n ; i ++ ) Console . Write ( coil2 [ i ] + " ▁ " ) ; } public static void Main ( ) { int n = 1 ; printCoils ( n ) ; } }
using System ; public class GFG { static int findSum ( int n ) { int [ , ] arr = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) arr [ i , j ] = Math . Abs ( i - j ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) sum += arr [ i , j ] ; return sum ; } static public void Main ( String [ ] args ) { int n = 3 ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; } static public void Main ( String [ ] args ) { int n = 3 ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; public class GFG { static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; } static public void Main ( String [ ] args ) { int n = 3 ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; class GFG { static int spiralDiaSum ( int n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; } public static void Main ( String [ ] args ) { int n = 7 ; Console . Write ( spiralDiaSum ( n ) ) ; } }
public class GFG { public const int R = 3 ; public const int C = 5 ; public static int numofneighbour ( int [ ] [ ] mat , int i , int j ) { int count = 0 ; if ( i > 0 && mat [ i - 1 ] [ j ] == 1 ) { count ++ ; } if ( j > 0 && mat [ i ] [ j - 1 ] == 1 ) { count ++ ; } if ( i < R - 1 && mat [ i + 1 ] [ j ] == 1 ) { count ++ ; } if ( j < C - 1 && mat [ i ] [ j + 1 ] == 1 ) { count ++ ; } return count ; } public static int findperimeter ( int [ ] [ ] mat ) { int perimeter = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; } } } return perimeter ; } public static void Main ( string [ ] args ) { int [ ] [ ] mat = new int [ ] [ ] { new int [ ] { 0 , 1 , 0 , 0 , 0 } , new int [ ] { 1 , 1 , 1 , 0 , 0 } , new int [ ] { 1 , 0 , 0 , 0 , 0 } } ; Console . WriteLine ( findperimeter ( mat ) ) ; } }
using System ; class GFG { static int MAX = 100 ; static void printMatrixDiagonal ( int [ , ] mat , int n ) { int i = 0 , j = 0 ; bool isUp = true ; for ( int k = 0 ; k < n * n ; ) { if ( isUp ) { for ( ; i >= 0 && j < n ; j ++ , i -- ) { Console . Write ( mat [ i , j ] + " ▁ " ) ; k ++ ; } if ( i < 0 && j <= n - 1 ) i = 0 ; if ( j == n ) { i = i + 2 ; j -- ; } } else { for ( ; j >= 0 && i < n ; i ++ , j -- ) { Console . Write ( mat [ i , j ] + " ▁ " ) ; k ++ ; } if ( j < 0 && i <= n - 1 ) j = 0 ; if ( i == n ) { j = j + 2 ; i -- ; } } isUp = ! isUp ; } } public static void Main ( ) { int [ , ] mat = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int n = 3 ; printMatrixDiagonal ( mat , n ) ; } }
using System ; class GFG { static int maxRowDiff ( int [ , ] mat , int m , int n ) { int [ ] rowSum = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) { int sum = 0 ; for ( int j = 0 ; j < n ; j ++ ) sum += mat [ i , j ] ; rowSum [ i ] = sum ; } int max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; int min_element = rowSum [ 0 ] ; for ( int i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; } public static void Main ( ) { int m = 5 , n = 4 ; int [ , ] mat = { { - 1 , 2 , 3 , 4 } , { 5 , 3 , - 2 , 1 } , { 6 , 7 , 2 , - 3 } , { 2 , 9 , 1 , 4 } , { 2 , 1 , - 2 , 0 } } ; Console . Write ( maxRowDiff ( mat , m , n ) ) ; } }
using System ; class GFG { static int sortedCount ( int [ , ] mat , int r , int c ) { int result = 0 ; for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i , j + 1 ] <= mat [ i , j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( int i = 0 ; i < r ; i ++ ) { int j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i , j - 1 ] <= mat [ i , j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; } public static void Main ( ) { int m = 4 , n = 5 ; int [ , ] mat = { { 1 , 2 , 3 , 4 , 5 } , { 4 , 3 , 1 , 2 , 6 } , { 8 , 7 , 6 , 5 , 4 } , { 5 , 7 , 8 , 9 , 10 } } ; Console . WriteLine ( sortedCount ( mat , m , n ) ) ; } }
using System ; class GFG { static int maxXOR ( int [ , ] mat , int N ) { int r_xor , c_xor ; int max_xor = 0 ; for ( int i = 0 ; i < N ; i ++ ) { r_xor = 0 ; c_xor = 0 ; for ( int j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i , j ] ; c_xor = c_xor ^ mat [ j , i ] ; } if ( max_xor < Math . Max ( r_xor , c_xor ) ) max_xor = Math . Max ( r_xor , c_xor ) ; } return max_xor ; } public static void Main ( ) { int N = 3 ; int [ , ] mat = { { 1 , 5 , 4 } , { 3 , 7 , 2 } , { 5 , 9 , 10 } } ; Console . Write ( " maximum ▁ XOR ▁ value ▁ : ▁ " + maxXOR ( mat , N ) ) ; } }
using System ; class GFG { static void direction ( int R , int C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { Console . WriteLine ( " Left " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { Console . WriteLine ( " Up " ) ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { Console . WriteLine ( " Right " ) ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { Console . WriteLine ( " Left " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { Console . WriteLine ( " Right " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { Console . WriteLine ( " Down " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { Console . WriteLine ( " Left " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { Console . WriteLine ( " Up " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { Console . WriteLine ( " Down " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { Console . WriteLine ( " Right " ) ; return ; } } static public void Main ( ) { int R = 3 , C = 1 ; direction ( R , C ) ; } }
using System ; class GFG { public static int N = 5 ; public static int M = 4 ; static bool checkDiagonal ( int [ , ] mat , int i , int j ) { int res = mat [ i , j ] ; while ( ++ i < N && ++ j < M ) { if ( mat [ i , j ] != res ) return false ; } return true ; } static bool isToepliz ( int [ , ] mat ) { for ( int i = 0 ; i < M ; i ++ ) { if ( ! checkDiagonal ( mat , 0 , i ) ) return false ; } for ( int i = 1 ; i < N ; i ++ ) { if ( ! checkDiagonal ( mat , i , 0 ) ) return false ; } return true ; } public static void Main ( ) { int [ , ] mat = { { 6 , 7 , 8 , 9 } , { 4 , 6 , 7 , 8 } , { 1 , 4 , 6 , 7 } , { 0 , 1 , 4 , 6 } , { 2 , 0 , 1 , 4 } } ; if ( isToepliz ( mat ) ) Console . WriteLine ( " Matrix ▁ is ▁ a ▁ Toepliz ▁ " ) ; else Console . WriteLine ( " Matrix ▁ is ▁ not ▁ a ▁ Toepliz ▁ " ) ; } }
using System ; class GFG { public static int N = 5 ; static int countZeroes ( int [ , ] mat ) { int row = N - 1 , col = 0 ; int count = 0 ; while ( col < N ) { while ( mat [ row , col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; } public static void Main ( ) { int [ , ] mat = { { 0 , 0 , 0 , 0 , 1 } , { 0 , 0 , 0 , 1 , 1 } , { 0 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 } } ; Console . WriteLine ( countZeroes ( mat ) ) ; } }
using System ; class GFG { static int N = 10 ; static int findLargestPlus ( int [ , ] mat ) { int [ , ] left = new int [ N , N ] ; int [ , ] right = new int [ N , N ] ; int [ , ] top = new int [ N , N ] ; int [ , ] bottom = new int [ N , N ] ; for ( int i = 0 ; i < N ; i ++ ) { top [ 0 , i ] = mat [ 0 , i ] ; bottom [ N - 1 , i ] = mat [ N - 1 , i ] ; left [ i , 0 ] = mat [ i , 0 ] ; right [ i , N - 1 ] = mat [ i , N - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < N ; j ++ ) { if ( mat [ i , j ] == 1 ) left [ i , j ] = left [ i , j - 1 ] + 1 ; else left [ i , j ] = 0 ; if ( mat [ j , i ] == 1 ) top [ j , i ] = top [ j - 1 , i ] + 1 ; else top [ j , i ] = 0 ; j = N - 1 - j ; if ( mat [ j , i ] == 1 ) bottom [ j , i ] = bottom [ j + 1 , i ] + 1 ; else bottom [ j , i ] = 0 ; if ( mat [ i , j ] == 1 ) right [ i , j ] = right [ i , j + 1 ] + 1 ; else right [ i , j ] = 0 ; j = N - 1 - j ; } } int n = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int len = Math . Min ( Math . Min ( top [ i , j ] , bottom [ i , j ] ) , Math . Min ( left [ i , j ] , right [ i , j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; } public static void Main ( ) { int [ , ] mat = { { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 } , { 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 } , { 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 } , { 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 } , { 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 } , { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 } } ; Console . Write ( findLargestPlus ( mat ) ) ; } }
using System ; using System . Text ; public class GFG { public static StringBuilder findLeft ( StringBuilder str ) { int n = str . Length ; while ( n > 0 ) { n -- ; if ( str [ n ] == ' d ' ) { str [ n ] = ' c ' ; break ; } if ( str [ n ] == ' b ' ) { str [ n ] = ' a ' ; break ; } if ( str [ n ] == ' a ' ) { str [ n ] = ' b ' ; } else if ( str [ n ] == ' c ' ) { str [ n ] = ' d ' ; } } return str ; } public static void Main ( string [ ] args ) { StringBuilder str = new StringBuilder ( " aacbddc " ) ; Console . Write ( " Left ▁ of ▁ " + str + " ▁ is ▁ " + findLeft ( str ) ) ; } }
using System ; class GFG { static void printSpiral ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x ; x = Math . Min ( Math . Min ( i , j ) , Math . Min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) Console . Write ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) + " TABSYMBOL " ) ; else Console . Write ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) + " TABSYMBOL " ) ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 5 ; printSpiral ( n ) ; } }
using System ; class GFG { public static void modifyMatrix ( int [ , ] mat , int R , int C ) { int [ ] row = new int [ R ] ; int [ ] col = new int [ C ] ; int i , j ; for ( i = 0 ; i < R ; i ++ ) { row [ i ] = 0 ; } for ( i = 0 ; i < C ; i ++ ) { col [ i ] = 0 ; } for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( mat [ i , j ] == 1 ) { row [ i ] = 1 ; col [ j ] = 1 ; } } } for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( row [ i ] == 1 col [ j ] == 1 ) { mat [ i , j ] = 1 ; } } } } public static void printMatrix ( int [ , ] mat , int R , int C ) { int i , j ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { Console . Write ( mat [ i , j ] + " ▁ " ) ; } Console . WriteLine ( ) ; } } static public void Main ( ) { int [ , ] mat = { { 1 , 0 , 0 , 1 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } } ; Console . WriteLine ( " Matrix ▁ Intially " ) ; printMatrix ( mat , 3 , 4 ) ; modifyMatrix ( mat , 3 , 4 ) ; Console . WriteLine ( " Matrix ▁ after ▁ " + " modification ▁ n " ) ; printMatrix ( mat , 3 , 4 ) ; } }
using System ; class GFG { public static void modifyMatrix ( int [ , ] mat ) { bool row_flag = false ; bool col_flag = false ; for ( int i = 0 ; i < mat . GetLength ( 0 ) ; i ++ ) { for ( int j = 0 ; j < mat . GetLength ( 1 ) ; j ++ ) { if ( i == 0 && mat [ i , j ] == 1 ) row_flag = true ; if ( j == 0 && mat [ i , j ] == 1 ) col_flag = true ; if ( mat [ i , j ] == 1 ) { mat [ 0 , j ] = 1 ; mat [ i , 0 ] = 1 ; } } } for ( int i = 1 ; i < mat . GetLength ( 0 ) ; i ++ ) { for ( int j = 1 ; j < mat . GetLength ( 1 ) ; j ++ ) { if ( mat [ 0 , j ] == 1 mat [ i , 0 ] == 1 ) { mat [ i , j ] = 1 ; } } } if ( row_flag == true ) { for ( int i = 0 ; i < mat . GetLength ( 1 ) ; i ++ ) { mat [ 0 , i ] = 1 ; } } if ( col_flag == true ) { for ( int i = 0 ; i < mat . GetLength ( 0 ) ; i ++ ) { mat [ i , 0 ] = 1 ; } } } public static void printMatrix ( int [ , ] mat ) { for ( int i = 0 ; i < mat . GetLength ( 0 ) ; i ++ ) { for ( int j = 0 ; j < mat . GetLength ( 1 ) ; j ++ ) { Console . Write ( mat [ i , j ] + " ▁ " ) ; } Console . Write ( " STRNEWLINE " ) ; } } public static void Main ( ) { int [ , ] mat = { { 1 , 0 , 0 , 1 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } } ; Console . Write ( " Input ▁ Matrix ▁ : STRNEWLINE " ) ; printMatrix ( mat ) ; modifyMatrix ( mat ) ; Console . Write ( " Matrix ▁ After ▁ " + " Modification ▁ : STRNEWLINE " ) ; printMatrix ( mat ) ; } }
using System ; public class GFG { static int n = 5 ; static int find ( bool [ , ] arr ) { int i = 0 , j = n - 1 ; int res = - 1 ; while ( i < n && j >= 0 ) { if ( arr [ i , j ] == false ) { while ( j >= 0 && ( arr [ i , j ] == false i == j ) ) { j -- ; } if ( j == - 1 ) { res = i ; break ; } else { i ++ ; } } else { while ( i < n && ( arr [ i , j ] == true i == j ) ) { i ++ ; } if ( i == n ) { res = j ; break ; } else { j -- ; } } } if ( res == - 1 ) { return res ; } for ( int k = 0 ; k < n ; k ++ ) { if ( res != k && arr [ k , res ] != true ) { return - 1 ; } } for ( int l = 0 ; l < n ; l ++ ) { if ( res != l && arr [ res , l ] != false ) { return - 1 ; } } return res ; } public static void Main ( ) { bool [ , ] mat = { { false , false , true , true , false } , { false , false , false , true , false } , { true , true , true , true , false } , { false , false , false , false , false } , { true , true , true , true , true } } ; Console . WriteLine ( find ( mat ) ) ; } }
using System ; class GFG { static int M = 4 ; static int N = 5 ; static int preProcess ( int [ , ] mat , int [ , ] aux ) { for ( int i = 0 ; i < N ; i ++ ) aux [ 0 , i ] = mat [ 0 , i ] ; for ( int i = 1 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) aux [ i , j ] = mat [ i , j ] + aux [ i - 1 , j ] ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 1 ; j < N ; j ++ ) aux [ i , j ] += aux [ i , j - 1 ] ; return 0 ; } static int sumQuery ( int [ , ] aux , int tli , int tlj , int rbi , int rbj ) { int res = aux [ rbi , rbj ] ; if ( tli > 0 ) res = res - aux [ tli - 1 , rbj ] ; if ( tlj > 0 ) res = res - aux [ rbi , tlj - 1 ] ; if ( tli > 0 && tlj > 0 ) res = res + aux [ tli - 1 , tlj - 1 ] ; return res ; } public static void Main ( ) { int [ , ] mat = { { 1 , 2 , 3 , 4 , 6 } , { 5 , 3 , 8 , 1 , 2 } , { 4 , 6 , 7 , 5 , 5 } , { 2 , 4 , 8 , 9 , 4 } } ; int [ , ] aux = new int [ M , N ] ; preProcess ( mat , aux ) ; int tli = 2 , tlj = 2 , rbi = 3 , rbj = 4 ; Console . Write ( " Query1 : " sumQuery ( aux , tli , tlj , rbi , rbj ) ) ; tli = 0 ; tlj = 0 ; rbi = 1 ; rbj = 1 ; Console . Write ( " Query2 : " sumQuery ( aux , tli , tlj , rbi , rbj ) ) ; tli = 1 ; tlj = 2 ; rbi = 3 ; rbj = 3 ; Console . Write ( " Query3 : " sumQuery ( aux , tli , tlj , rbi , rbj ) ) ; } }
using System ; class GFG { static int R = 3 ; static int C = 3 ; static void swap ( int [ , ] mat , int row1 , int row2 , int col ) { for ( int i = 0 ; i < col ; i ++ ) { int temp = mat [ row1 , i ] ; mat [ row1 , i ] = mat [ row2 , i ] ; mat [ row2 , i ] = temp ; } } static int rankOfMatrix ( int [ , ] mat ) { int rank = C ; for ( int row = 0 ; row < rank ; row ++ ) { if ( mat [ row , row ] != 0 ) { for ( int col = 0 ; col < R ; col ++ ) { if ( col != row ) { double mult = ( double ) mat [ col , row ] / mat [ row , row ] ; for ( int i = 0 ; i < rank ; i ++ ) mat [ col , i ] -= ( int ) mult * mat [ row , i ] ; } } } else { bool reduce = true ; for ( int i = row + 1 ; i < R ; i ++ ) { if ( mat [ i , row ] != 0 ) { swap ( mat , row , i , rank ) ; reduce = false ; break ; } } if ( reduce ) { rank -- ; for ( int i = 0 ; i < R ; i ++ ) mat [ i , row ] = mat [ i , rank ] ; } row -- ; } } return rank ; } static void display ( int [ , ] mat , int row , int col ) { for ( int i = 0 ; i < row ; i ++ ) { for ( int j = 0 ; j < col ; j ++ ) Console . Write ( " ▁ " + mat [ i , j ] ) ; Console . Write ( " STRNEWLINE " ) ; } } public static void Main ( ) { int [ , ] mat = { { 10 , 20 , 10 } , { - 20 , - 30 , 10 } , { 30 , 50 , 0 } } ; Console . Write ( " Rank ▁ of ▁ the ▁ matrix ▁ is ▁ : ▁ " + rankOfMatrix ( mat ) ) ; } }
using System ; class GFG { static int countIslands ( int [ , ] mat , int m , int n ) { int count = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( mat [ i , j ] == ' X ' ) { if ( ( i == 0 mat [ i - 1 , j ] == ' O ' ) && ( j == 0 mat [ i , j - 1 ] == ' O ' ) ) count ++ ; } } } return count ; } public static void Main ( ) { int m = 6 ; int n = 3 ; int [ , ] mat = { { ' O ' , ' O ' , ' O ' } , { ' X ' , ' X ' , ' O ' } , { ' X ' , ' X ' , ' O ' } , { ' O ' , ' O ' , ' X ' } , { ' O ' , ' O ' , ' X ' } , { ' X ' , ' X ' , ' O ' } } ; Console . WriteLine ( " Number ▁ of ▁ rectangular ▁ " + " islands ▁ is : ▁ " + countIslands ( mat , m , n ) ) ; } }
using System ; class GFG { static int M = 6 ; static int N = 6 ; static void floodFillUtil ( char [ , ] mat , int x , int y , char prevV , char newV ) { if ( x < 0 x >= M y < 0 y >= N ) return ; if ( mat [ x , y ] != prevV ) return ; mat [ x , y ] = newV ; floodFillUtil ( mat , x + 1 , y , prevV , newV ) ; floodFillUtil ( mat , x - 1 , y , prevV , newV ) ; floodFillUtil ( mat , x , y + 1 , prevV , newV ) ; floodFillUtil ( mat , x , y - 1 , prevV , newV ) ; } static void replaceSurrounded ( char [ , ] mat ) { for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i , j ] == ' O ' ) mat [ i , j ] = ' - ' ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i , 0 ] == ' - ' ) floodFillUtil ( mat , i , 0 , ' - ' , ' O ' ) ; for ( int i = 0 ; i < M ; i ++ ) if ( mat [ i , N - 1 ] == ' - ' ) floodFillUtil ( mat , i , N - 1 , ' - ' , ' O ' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ 0 , i ] == ' - ' ) floodFillUtil ( mat , 0 , i , ' - ' , ' O ' ) ; for ( int i = 0 ; i < N ; i ++ ) if ( mat [ M - 1 , i ] == ' - ' ) floodFillUtil ( mat , M - 1 , i , ' - ' , ' O ' ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) if ( mat [ i , j ] == ' - ' ) mat [ i , j ] = ' X ' ; } public static void Main ( ) { char [ , ] mat = new char [ , ] { { ' X ' , ' O ' , ' X ' , ' O ' , ' X ' , ' X ' } , { ' X ' , ' O ' , ' X ' , ' X ' , ' O ' , ' X ' } , { ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' X ' } , { ' O ' , ' X ' , ' X ' , ' X ' , ' X ' , ' X ' } , { ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' O ' } , { ' O ' , ' O ' , ' X ' , ' O ' , ' O ' , ' O ' } } ; replaceSurrounded ( mat ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) Console . Write ( mat [ i , j ] + " ▁ " ) ; Console . WriteLine ( " " ) ; } } }
using System ; class GFG { static int [ ] x = { 0 , 1 , 1 , - 1 , 1 , 0 , - 1 , - 1 } ; static int [ ] y = { 1 , 0 , 1 , 1 , - 1 , - 1 , 0 , - 1 } ; static int R = 3 ; static int C = 3 ; static int [ , ] dp = new int [ R , C ] ; static bool isvalid ( int i , int j ) { if ( i < 0 j < 0 i >= R j >= C ) return false ; return true ; } static bool isadjacent ( char prev , char curr ) { return ( ( curr - prev ) == 1 ) ; } static int getLenUtil ( char [ , ] mat , int i , int j , char prev ) { if ( ! isvalid ( i , j ) || ! isadjacent ( prev , mat [ i , j ] ) ) return 0 ; if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; int ans = 0 ; for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . Max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i , j ] ) ) ; return dp [ i , j ] = ans ; } static int getLen ( char [ , ] mat , char s ) { for ( int i = 0 ; i < R ; ++ i ) for ( int j = 0 ; j < C ; ++ j ) dp [ i , j ] = - 1 ; int ans = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i , j ] == s ) { for ( int k = 0 ; k < 8 ; k ++ ) ans = Math . Max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; } public static void Main ( ) { char [ , ] mat = { { ' a ' , ' c ' , ' d ' } , { ' h ' , ' b ' , ' a ' } , { ' i ' , ' g ' , ' f ' } } ; Console . WriteLine ( getLen ( mat , ' a ' ) ) ; Console . WriteLine ( getLen ( mat , ' e ' ) ) ; Console . WriteLine ( getLen ( mat , ' b ' ) ) ; Console . WriteLine ( getLen ( mat , ' f ' ) ) ; } }
using System ; class GFG { static int minInitialPoints ( int [ , ] points , int R , int C ) { int [ , ] dp = new int [ R , C ] ; int m = R , n = C ; dp [ m - 1 , n - 1 ] = points [ m - 1 , n - 1 ] > 0 ? 1 : Math . Abs ( points [ m - 1 , n - 1 ] ) + 1 ; for ( int i = m - 2 ; i >= 0 ; i -- ) dp [ i , n - 1 ] = Math . Max ( dp [ i + 1 , n - 1 ] - points [ i , n - 1 ] , 1 ) ; for ( int j = n - 2 ; j >= 0 ; j -- ) dp [ m - 1 , j ] = Math . Max ( dp [ m - 1 , j + 1 ] - points [ m - 1 , j ] , 1 ) ; for ( int i = m - 2 ; i >= 0 ; i -- ) { for ( int j = n - 2 ; j >= 0 ; j -- ) { int min_points_on_exit = Math . Min ( dp [ i + 1 , j ] , dp [ i , j + 1 ] ) ; dp [ i , j ] = Math . Max ( min_points_on_exit - points [ i , j ] , 1 ) ; } } return dp [ 0 , 0 ] ; } public static void Main ( ) { int [ , ] points = { { - 2 , - 3 , 3 } , { - 5 , - 10 , 1 } , { 10 , 30 , - 5 } } ; int R = 3 , C = 3 ; Console . Write ( " Minimum ▁ Initial ▁ Points ▁ Required : ▁ " + minInitialPoints ( points , R , C ) ) ; } }
using System ; class GFG { static int findPeakUtil ( int [ ] arr , int low , int high , int n ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; } static int findPeak ( int [ ] arr , int n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; } static public void Main ( ) { int [ ] arr = { 1 , 3 , 20 , 4 , 1 , 0 } ; int n = arr . Length ; Console . WriteLine ( " Index ▁ of ▁ a ▁ peak ▁ " + " point ▁ is ▁ " + findPeak ( arr , n ) ) ; } }
using System ; class GFG { static void printRepeating ( int [ ] arr , int size ) { int i , j ; Console . Write ( " Repeated ▁ Elements ▁ are ▁ : " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) Console . Write ( arr [ i ] + " ▁ " ) ; } } } public static void Main ( ) { int [ ] arr = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . Length ; printRepeating ( arr , arr_size ) ; } }
using System ; class GFG { static void printRepeating ( int [ ] arr , int size ) { int [ ] count = new int [ size ] ; int i ; Console . Write ( " Repeated ▁ elements ▁ are : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) Console . Write ( arr [ i ] + " ▁ " ) ; else count [ arr [ i ] ] ++ ; } } public static void Main ( ) { int [ ] arr = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . Length ; printRepeating ( arr , arr_size ) ; } }
using System ; class GFG { static void printRepeating ( int [ ] arr , int size ) { int S = 0 ; int P = 1 ; int x , y ; int D ; int n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * ( n + 1 ) / 2 ; P = P / fact ( n ) ; D = ( int ) Math . Sqrt ( S * S - 4 * P ) ; x = ( D + S ) / 2 ; y = ( S - D ) / 2 ; Console . WriteLine ( " The ▁ two " + " ▁ repeating ▁ elements ▁ are ▁ : " ) ; Console . Write ( x + " ▁ " + y ) ; } static int fact ( int n ) { return ( n == 0 ) ? 1 : n * fact ( n - 1 ) ; } public static void Main ( ) { int [ ] arr = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . Length ; printRepeating ( arr , arr_size ) ; } }
using System ; class GFG { static void printRepeating ( int [ ] arr , int size ) { int xor = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor ^= i ; set_bit_no = ( xor & ~ ( xor - 1 ) ) ; for ( i = 0 ; i < size ; i ++ ) { int a = arr [ i ] & set_bit_no ; if ( a != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { int a = i & set_bit_no ; if ( a != 0 ) x = x ^ i ; else y = y ^ i ; } Console . WriteLine ( " The ▁ two " + " ▁ reppeated ▁ elements ▁ are ▁ : " ) ; Console . Write ( x + " ▁ " + y ) ; } public static void Main ( ) { int [ ] arr = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . Length ; printRepeating ( arr , arr_size ) ; } }
using System ; class GFG { static void printRepeating ( int [ ] arr , int size ) { int i ; Console . Write ( " The ▁ repeating ▁ elements ▁ are ▁ : ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . Abs ( arr [ i ] ) ] > 0 ) arr [ Math . Abs ( arr [ i ] ) ] = - arr [ Math . Abs ( arr [ i ] ) ] ; else Console . Write ( Math . Abs ( arr [ i ] ) + " ▁ " ) ; } } public static void Main ( ) { int [ ] arr = { 4 , 2 , 4 , 5 , 2 , 3 , 1 } ; int arr_size = arr . Length ; printRepeating ( arr , arr_size ) ; } }
using System ; class GFG { int subArraySum ( int [ ] arr , int n , int sum ) { int curr_sum , i , j ; for ( i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { int p = j - 1 ; Console . Write ( " Sum ▁ found ▁ between ▁ " + " indexes ▁ " + i + " ▁ and ▁ " + p ) ; return 1 ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } Console . Write ( " No ▁ subarray ▁ found " ) ; return 0 ; } public static void Main ( ) { GFG arraysum = new GFG ( ) ; int [ ] arr = { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = arr . Length ; int sum = 23 ; arraysum . subArraySum ( arr , n , sum ) ; } }
using System ; class GFG { int subArraySum ( int [ ] arr , int n , int sum ) { int curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { int p = i - 1 ; Console . WriteLine ( " Sum ▁ found ▁ between ▁ " + " indexes ▁ " + start + " ▁ and ▁ " + p ) ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } Console . WriteLine ( " No ▁ subarray ▁ found " ) ; return 0 ; } public static void Main ( ) { GFG arraysum = new GFG ( ) ; int [ ] arr = new int [ ] { 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 } ; int n = arr . Length ; int sum = 23 ; arraysum . subArraySum ( arr , n , sum ) ; } }
using System ; class GFG { static int maximum ( int a , int b , int c ) { return Math . Max ( Math . Max ( a , b ) , c ) ; } static int minimum ( int a , int b , int c ) { return Math . Min ( Math . Min ( a , b ) , c ) ; } static void smallestDifferenceTriplet ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 , int n ) { Array . Sort ( arr1 ) ; Array . Sort ( arr2 ) ; Array . Sort ( arr3 ) ; int res_min = 0 , res_max = 0 , res_mid = 0 ; int i = 0 , j = 0 , k = 0 ; int diff = 2147483647 ; while ( i < n && j < n && k < n ) { int sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; int max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; int min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; if ( min == arr1 [ i ] ) i ++ ; else if ( min == arr2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_max = max ; res_mid = sum - ( max + min ) ; res_min = min ; } } Console . WriteLine ( res_max + " , ▁ " + res_mid + " , ▁ " + res_min ) ; } static public void Main ( ) { int [ ] arr1 = { 5 , 2 , 8 } ; int [ ] arr2 = { 10 , 7 , 12 } ; int [ ] arr3 = { 9 , 14 , 6 } ; int n = arr1 . Length ; smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) ; } }
using System ; class GFG { static bool find3Numbers ( int [ ] A , int arr_size , int sum ) { for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { for ( int j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { Console . WriteLine ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ j ] + " , ▁ " + A [ k ] ) ; return true ; } } } } return false ; } static public void Main ( ) { int [ ] A = { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = A . Length ; find3Numbers ( A , arr_size , sum ) ; } }
using System ; class GFG { bool find3Numbers ( int [ ] A , int arr_size , int sum ) { int l , r ; quickSort ( A , 0 , arr_size - 1 ) ; for ( int i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { Console . Write ( " Triplet ▁ is ▁ " + A [ i ] + " , ▁ " + A [ l ] + " , ▁ " + A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; } int partition ( int [ ] A , int si , int ei ) { int x = A [ ei ] ; int i = ( si - 1 ) ; int j ; for ( j = si ; j <= ei - 1 ; j ++ ) { if ( A [ j ] <= x ) { i ++ ; int temp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = temp ; } } int temp1 = A [ i + 1 ] ; A [ i + 1 ] = A [ ei ] ; A [ ei ] = temp1 ; return ( i + 1 ) ; } if ( si < ei ) { pi = partition ( A , si , ei ) ; quickSort ( A , si , pi - 1 ) ; quickSort ( A , pi + 1 , ei ) ; } } static void ( ) { = new ( ) ; int [ ] = new int [ ] { 1 , 4 , 45 , 6 , 10 , 8 } ; int sum = 22 ; int arr_size = A . Length ; triplet . find3Numbers ( A , arr_size , sum ) ; } }
using System ; class GFG { static int [ ] arr = new int [ ] { 1 , 2 , 3 , 4 } ; static void subArray ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) Console . Write ( arr [ k ] + " ▁ " ) ; Console . WriteLine ( " " ) ; } } } public static void Main ( ) { Console . WriteLine ( " All ▁ Non - empty ▁ Subarrays " ) ; subArray ( arr . Length ) ; } }
using System ; class GFG { static void printSubsequences ( int [ ] arr , int n ) { int opsize = ( int ) Math . Pow ( 2 , n ) ; for ( int counter = 1 ; counter < opsize ; counter ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) Console . Write ( arr [ j ] + " ▁ " ) ; } Console . WriteLine ( ) ; } } static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . Length ; Console . WriteLine ( " All ▁ Non - empty ▁ Subsequences " ) ; printSubsequences ( arr , n ) ; } }
using System ; class GFG { static void productArray ( int [ ] arr , int n ) { if ( n == 1 ) { Console . Write ( 0 ) ; return ; } int i , temp = 1 ; int [ ] prod = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) prod [ j ] = 1 ; for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } temp = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) Console . Write ( prod [ i ] + " ▁ " ) ; return ; } public static void Main ( ) { int [ ] arr = { 10 , 3 , 5 , 6 , 2 } ; int n = arr . Length ; Console . WriteLine ( " The ▁ product ▁ array ▁ is ▁ : ▁ " ) ; productArray ( arr , n ) ; } }
using System ; class GFG { static bool areConsecutive ( int [ ] arr , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { bool [ ] visited = new bool [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) return false ; visited [ arr [ i ] - min ] = true ; } return true ; } return false ; } static int getMin ( int [ ] arr , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; } static int getMax ( int [ ] arr , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } public static void Main ( ) { int [ ] arr = { 5 , 4 , 2 , 3 , 1 , 6 } ; int n = arr . Length ; if ( areConsecutive ( arr , n ) == true ) Console . Write ( " Array ▁ elements ▁ are " + " ▁ consecutive " ) ; else Console . Write ( " Array ▁ elements ▁ are " + " ▁ not ▁ consecutive " ) ; } }
using System ; class GFG { static bool areConsecutive ( int [ ] arr , int n ) { if ( n < 1 ) return false ; int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { int j ; if ( arr [ i ] < 0 ) j = - arr [ i ] - min ; else j = arr [ i ] - min ; if ( arr [ j ] > 0 ) arr [ j ] = - arr [ j ] ; else return false ; } return true ; } return false ; } static int getMin ( int [ ] arr , int n ) { int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; } static int getMax ( int [ ] arr , int n ) { int max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } public static void Main ( ) { int [ ] arr = { 5 , 4 , 2 , 3 , 1 , 6 } ; int n = arr . Length ; if ( areConsecutive ( arr , n ) == true ) Console . Write ( " Array ▁ elements ▁ " + " are ▁ consecutive " ) ; else Console . Write ( " Array ▁ elements ▁ " + " are ▁ not ▁ consecutive " ) ; } }
using System ; namespace Complement { public class GFG { static void relativeComplement ( int [ ] arr1 , int [ ] arr2 , int n , int m ) { int i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { Console . Write ( arr1 [ i ] + " ▁ " ) ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) Console . Write ( arr1 [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr1 = { 3 , 6 , 10 , 12 , 15 } ; int [ ] arr2 = { 1 , 3 , 5 , 10 , 16 } ; int n = arr1 . Length ; int m = arr2 . Length ; relativeComplement ( arr1 , arr2 , n , m ) ; } } }
using System ; class GFG { static int minOps ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int max = arr [ arr . Length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; } public static void Main ( ) { int [ ] arr = { 21 , 33 , 9 , 45 , 63 } ; int n = arr . Length ; int k = 6 ; Console . Write ( minOps ( arr , n , k ) ) ; } }
using System ; class GFG { static int solve ( int [ ] A , int [ ] B , int [ ] C ) { int i , j , k ; i = A . Length - 1 ; j = B . Length - 1 ; k = C . Length - 1 ; int min_diff , current_diff , max_term ; min_diff = Math . Abs ( Math . Max ( A [ i ] , Math . Max ( B [ j ] , C [ k ] ) ) - Math . Min ( A [ i ] , Math . Min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . Abs ( Math . Max ( A [ i ] , Math . Max ( B [ j ] , C [ k ] ) ) - Math . Min ( A [ i ] , Math . Min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . Max ( A [ i ] , Math . Max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; } public static void Main ( ) { int [ ] D = { 5 , 8 , 10 , 15 } ; int [ ] E = { 6 , 9 , 15 , 78 , 89 } ; int [ ] F = { 2 , 3 , 6 , 6 , 8 , 8 , 10 } ; Console . WriteLine ( solve ( D , E , F ) ) ; } }
using System ; public class GFG { static int search ( int [ ] arr , int n , int x ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { return i ; } } return - 1 ; } public static void Main ( ) { int [ ] arr = { 1 , 10 , 30 , 15 } ; int x = 30 ; int n = arr . Length ; Console . WriteLine ( x + " ▁ is ▁ present ▁ at ▁ index ▁ " + search ( arr , n , x ) ) ; } }
using System ; class GFG { static int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 10 , 40 } ; int n = arr . Length ; int x = 10 ; int result = binarySearch ( arr , 0 , n - 1 , x ) ; if ( result == - 1 ) Console . WriteLine ( " Element ▁ not ▁ present " ) ; else Console . WriteLine ( " Element ▁ found ▁ at ▁ index ▁ " + result ) ; } }
using System ; class GFG { static int binarySearch ( int [ ] arr , int x ) { int l = 0 , r = arr . Length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] == x ) return m ; if ( arr [ m ] < x ) l = m + 1 ; else r = m - 1 ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 10 , 40 } ; int n = arr . Length ; int x = 10 ; int result = binarySearch ( arr , x ) ; if ( result == - 1 ) Console . WriteLine ( " Element ▁ not ▁ present " ) ; else Console . WriteLine ( " Element ▁ found ▁ at ▁ " + " index ▁ " + result ) ; } }
using System ; public class JumpSearch { public static int jumpSearch ( int [ ] arr , int x ) { int n = arr . Length ; int step = ( int ) Math . Floor ( Math . Sqrt ( n ) ) ; int prev = 0 ; while ( arr [ Math . Min ( step , n ) - 1 ] < x ) { prev = step ; step += ( int ) Math . Floor ( Math . Sqrt ( n ) ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == Math . Min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; } public static void Main ( ) { int [ ] arr = { 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 } ; int x = 55 ; int index = jumpSearch ( arr , x ) ; Console . Write ( " Number ▁ " + x + " ▁ is ▁ at ▁ index ▁ " + index ) ; } }
using System ; class GFG { static int exponentialSearch ( int [ ] arr , int n , int x ) { if ( arr [ 0 ] == x ) return 0 ; int i = 1 ; while ( i < n && arr [ i ] <= x ) i = i * 2 ; return binarySearch ( arr , i / 2 , Math . Min ( i , n - 1 ) , x ) ; } static int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 10 , 40 } ; int n = arr . Length ; int x = 10 ; int result = exponentialSearch ( arr , n , x ) ; if ( result == - 1 ) Console . Write ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; else Console . Write ( " Element ▁ is ▁ present ▁ at ▁ index ▁ " + result ) ; } }
using System ; class GFG { public static int getMax ( int [ ] arr , int n ) { int mx = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > mx ) mx = arr [ i ] ; return mx ; } public static void countSort ( int [ ] arr , int n , int exp ) { int [ ] output = new int [ n ] ; int i ; int [ ] count = new int [ 10 ] ; for ( i = 0 ; i < 10 ; i ++ ) count [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) count [ ( arr [ i ] / exp ) % 10 ] ++ ; for ( i = 1 ; i < 10 ; i ++ ) count [ i ] += count [ i - 1 ] ; for ( i = n - 1 ; i >= 0 ; i -- ) { output [ count [ ( arr [ i ] / exp ) % 10 ] - 1 ] = arr [ i ] ; count [ ( arr [ i ] / exp ) % 10 ] -- ; } for ( i = 0 ; i < n ; i ++ ) arr [ i ] = output [ i ] ; } public static void radixsort ( int [ ] arr , int n ) { int m = getMax ( arr , n ) ; for ( int exp = 1 ; m / exp > 0 ; exp *= 10 ) countSort ( arr , n , exp ) ; } public static void print ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 170 , 45 , 75 , 90 , 802 , 24 , 2 , 66 } ; int n = arr . Length ; radixsort ( arr , n ) ; print ( arr , n ) ; } }
using System ; class GFG { static int partition ( int [ ] arr , int low , int high ) { int temp ; int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j <= high - 1 ; j ++ ) { if ( arr [ j ] <= pivot ) { i ++ ; temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } temp = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ high ] ; arr [ high ] = temp ; return i + 1 ; } static void qSort ( int [ ] arr , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; qSort ( arr , low , pi - 1 ) ; qSort ( arr , pi + 1 , high ) ; } } public static void Main ( ) { int n = 5 ; int [ ] arr = { 4 , 2 , 6 , 9 , 2 } ; qSort ( arr , 0 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int partition ( int [ ] arr , int low , int high ) { int temp ; int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j <= high - 1 ; j ++ ) { if ( arr [ j ] <= pivot ) { i ++ ; temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } temp = arr [ i + 1 ] ; arr [ i + 1 ] = arr [ high ] ; arr [ high ] = temp ; return i + 1 ; } static void quickSortIterative ( int [ ] arr , int l , int h ) { int [ ] stack = new int [ h - l + 1 ] ; int top = - 1 ; stack [ ++ top ] = l ; stack [ ++ top ] = h ; while ( top >= 0 ) { h = stack [ top -- ] ; l = stack [ top -- ] ; int p = partition ( arr , l , h ) ; if ( p - 1 > l ) { stack [ ++ top ] = l ; stack [ ++ top ] = p - 1 ; } if ( p + 1 < h ) { stack [ ++ top ] = p + 1 ; stack [ ++ top ] = h ; } } } public static void Main ( ) { int [ ] arr = { 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 } ; int n = 8 ; quickSortIterative ( arr , 0 , n - 1 ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class GFG { int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r >= l ) { int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( mid > l && arr [ mid - 1 ] == x ) return ( mid - 1 ) ; if ( mid < r && arr [ mid + 1 ] == x ) return ( mid + 1 ) ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 2 , x ) ; return binarySearch ( arr , mid + 2 , r , x ) ; } return - 1 ; } public static void Main ( ) { GFG ob = new GFG ( ) ; int [ ] arr = { 3 , 2 , 10 , 4 , 40 } ; int n = arr . Length ; int x = 4 ; int result = ob . binarySearch ( arr , 0 , n - 1 , x ) ; if ( result == - 1 ) Console . Write ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) ; else Console . Write ( " Element ▁ is ▁ present ▁ at ▁ index ▁ " + result ) ; } }
using System ; class GFG { static void printClosest ( int [ ] ar1 , int [ ] ar2 , int m , int n , int x ) { int diff = int . MaxValue ; int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . Abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . Abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } Console . Write ( " The ▁ closest ▁ pair ▁ is ▁ [ " + ar1 [ res_l ] + " , ▁ " + ar2 [ res_r ] + " ] " ) ; } public static void Main ( ) { int [ ] ar1 = { 1 , 4 , 5 , 7 } ; int [ ] ar2 = { 10 , 20 , 30 , 40 } ; int m = ar1 . Length ; int n = ar2 . Length ; int x = 38 ; printClosest ( ar1 , ar2 , m , n , x ) ; } }
using System ; class GFG { static void printClosest ( int [ ] arr , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = int . MaxValue ; while ( r > l ) { if ( Math . Abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . Abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } Console . Write ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; } public static void Main ( ) { int [ ] arr = { 10 , 22 , 28 , 29 , 30 , 40 } ; int x = 54 ; int n = arr . Length ; printClosest ( arr , n , x ) ; } }
using System ; class GFG { static int countOnes ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; } public static void Main ( ) { int [ ] arr = { 1 , 1 , 1 , 1 , 0 , 0 , 0 } ; int n = arr . Length ; Console . WriteLine ( " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ " + " array ▁ is ▁ " + countOnes ( arr , 0 , n - 1 ) ) ; } }
using System ; class GFG { public static void minimumSwaps ( int [ ] a , int n ) { int maxx = - 1 , l = 0 , minn = a [ 0 ] , r = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxx ) { maxx = a [ i ] ; l = i ; } if ( a [ i ] <= minn ) { minn = a [ i ] ; r = i ; } } if ( r < l ) Console . WriteLine ( l + ( n - r - 2 ) ) ; else Console . WriteLine ( l + ( n - r - 1 ) ) ; } public static void Main ( ) { int [ ] a = { 5 , 6 , 1 , 3 } ; int n = a . Length ; minimumSwaps ( a , n ) ; } }
using System ; class GFG { public static void printMaxActivities ( int [ ] s , int [ ] f , int n ) { int i , j ; Console . Write ( " Following ▁ activities ▁ are ▁ selected ▁ : ▁ " ) ; i = 0 ; Console . Write ( i + " ▁ " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { Console . Write ( j + " ▁ " ) ; i = j ; } } } public static void Main ( ) { int [ ] s = { 1 , 3 , 0 , 5 , 8 , 5 } ; int [ ] f = { 2 , 4 , 6 , 7 , 9 , 9 } ; int n = s . Length ; printMaxActivities ( s , f , n ) ; } }
using System ; class GFG { static int lcs ( char [ ] X , char [ ] Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } static int max ( int a , int b ) { return ( a > b ) ? a : b ; } public static void Main ( ) { String s1 = " AGGTAB " ; String s2 = " GXTXAYB " ; char [ ] X = s1 . ToCharArray ( ) ; char [ ] Y = s2 . ToCharArray ( ) ; int m = X . Length ; int n = Y . Length ; Console . Write ( " Length ▁ of ▁ LCS ▁ is " + " ▁ " + lcs ( X , Y , m , n ) ) ; } }
using System ; class GFG { static int lcs ( char [ ] X , char [ ] Y , int m , int n ) { int [ , ] L = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; else L [ i , j ] = max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } return L [ m , n ] ; } static int max ( int a , int b ) { return ( a > b ) ? a : b ; } public static void Main ( ) { String s1 = " AGGTAB " ; String s2 = " GXTXAYB " ; char [ ] X = s1 . ToCharArray ( ) ; char [ ] Y = s2 . ToCharArray ( ) ; int m = X . Length ; int n = Y . Length ; Console . Write ( " Length ▁ of ▁ LCS ▁ is " + " ▁ " + lcs ( X , Y , m , n ) ) ; } }
using System ; class GFG { static int min ( int x , int y , int z ) { if ( x < y ) return ( ( x < z ) ? x : z ) ; else return ( ( y < z ) ? y : z ) ; } static int minCost ( int [ , ] cost , int m , int n ) { if ( n < 0 m < 0 ) return int . MaxValue ; else if ( m == 0 && n == 0 ) return cost [ m , n ] ; else return cost [ m , n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } public static void Main ( ) { int [ , ] cost = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; Console . Write ( minCost ( cost , 2 , 2 ) ) ; } }
using System ; class GFG { private static int minCost ( int [ , ] cost , int m , int n ) { int i , j ; int [ , ] tc = new int [ m + 1 , n + 1 ] ; tc [ 0 , 0 ] = cost [ 0 , 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i , 0 ] = tc [ i - 1 , 0 ] + cost [ i , 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 , j ] = tc [ 0 , j - 1 ] + cost [ 0 , j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i , j ] = min ( tc [ i - 1 , j - 1 ] , tc [ i - 1 , j ] , tc [ i , j - 1 ] ) + cost [ i , j ] ; return tc [ m , n ] ; } private static int min ( int x , int y , int z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } public static void Main ( ) { int [ , ] cost = { { 1 , 2 , 3 } , { 4 , 8 , 2 } , { 1 , 5 , 3 } } ; Console . Write ( minCost ( cost , 2 , 2 ) ) ; } }
using System ; class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } public static void Main ( ) { int [ ] val = new int [ ] { 60 , 100 , 120 } ; int [ ] wt = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . Length ; Console . WriteLine ( knapSack ( W , wt , val , n ) ) ; } }
using System ; class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int knapSack ( int W , int [ ] wt , int [ ] val , int n ) { int i , w ; int [ , ] K = new int [ n + 1 , W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i , w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i , w ] = Math . Max ( val [ i - 1 ] + K [ i - 1 , w - wt [ i - 1 ] ] , K [ i - 1 , w ] ) ; else K [ i , w ] = K [ i - 1 , w ] ; } } return K [ n , W ] ; } static void Main ( ) { int [ ] val = new int [ ] { 60 , 100 , 120 } ; int [ ] wt = new int [ ] { 10 , 20 , 30 } ; int W = 50 ; int n = val . Length ; Console . WriteLine ( knapSack ( W , wt , val , n ) ) ; } }
using System ; class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int eggDrop ( int n , int k ) { int [ , ] eggFloor = new int [ n + 1 , k + 1 ] ; int res ; int i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i , 1 ] = 1 ; eggFloor [ i , 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 , j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i , j ] = int . MaxValue ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 , x - 1 ] , eggFloor [ i , j - x ] ) ; if ( res < eggFloor [ i , j ] ) eggFloor [ i , j ] = res ; } } } return eggFloor [ n , k ] ; } public static void Main ( ) { int n = 2 , k = 36 ; Console . WriteLine ( " Minimum ▁ number ▁ of ▁ trials ▁ " + " in ▁ worst ▁ case ▁ with ▁ " + n + " ▁ eggs ▁ and ▁ " + k + " floors ▁ is ▁ " + eggDrop ( n , k ) ) ; } }
using System ; public class GFG { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( char [ ] seq , int i , int j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } public static void Main ( ) { String seq = " GEEKSFORGEEKS " ; int n = seq . Length ; Console . Write ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " + lps ( seq . ToCharArray ( ) , 0 , n - 1 ) ) ; } }
using System ; class GFG { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( string seq ) { int n = seq . Length ; int i , j , cl ; int [ , ] L = new int [ n , n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i , i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( seq [ i ] == seq [ j ] && cl == 2 ) L [ i , j ] = 2 ; else if ( seq [ i ] == seq [ j ] ) L [ i , j ] = L [ i + 1 , j - 1 ] + 2 ; else L [ i , j ] = max ( L [ i , j - 1 ] , L [ i + 1 , j ] ) ; } } return L [ 0 , n - 1 ] ; } public static void Main ( ) { string seq = " GEEKS ▁ FOR ▁ GEEKS " ; int n = seq . Length ; Console . Write ( " The ▁ length ▁ of ▁ the ▁ " + " lps ▁ is ▁ " + lps ( seq ) ) ; } }
using System ; class LBS { static int lbs ( int [ ] arr , int n ) { int i , j ; int [ ] lis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int [ ] lds = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; int max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; } public static void Main ( ) { int [ ] arr = { 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 } ; int n = arr . Length ; Console . WriteLine ( " Length ▁ of ▁ LBS ▁ is ▁ " + lbs ( arr , n ) ) ; } }
using System ; class GFG { static int maxDivide ( int a , int b ) { while ( a % b == 0 ) a = a / b ; return a ; } static int isUgly ( int no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ? 1 : 0 ; } static int getNthUglyNo ( int n ) { int i = 1 ; int count = 1 ; while ( n > count ) { i ++ ; if ( isUgly ( i ) == 1 ) count ++ ; } return i ; } public static void Main ( ) { int no = getNthUglyNo ( 150 ) ; Console . WriteLine ( "150th ▁ ugly " + " ▁ no . ▁ is ▁ " + no ) ; } }
using System ; class GFG { static int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( sum == 0 ) return 1 ; int ans = 0 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } static int finalCount ( int n , int sum ) { int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } public static void Main ( ) { int n = 2 , sum = 5 ; Console . Write ( finalCount ( n , sum ) ) ; } }
using System ; class sum_dig { static int [ , ] lookup = new int [ 101 , 501 ] ; static int countRec ( int n , int sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( lookup [ n , sum ] != - 1 ) return lookup [ n , sum ] ; int ans = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return lookup [ n , sum ] = ans ; } static int finalCount ( int n , int sum ) { for ( int i = 0 ; i <= 100 ; ++ i ) { for ( int j = 0 ; j <= 500 ; ++ j ) { lookup [ i , j ] = - 1 ; } } int ans = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } public static void Main ( ) { int n = 3 , sum = 5 ; Console . Write ( finalCount ( n , sum ) ) ; } }
using System ; class GFG { private static void findCount ( int n , int sum ) { int start = ( int ) Math . Pow ( 10 , n - 1 ) ; int end = ( int ) Math . Pow ( 10 , n ) - 1 ; int count = 0 ; int i = start ; while ( i < end ) { int cur = 0 ; int temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = temp / 10 ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } Console . WriteLine ( count ) ; } public static void Main ( ) { int n = 3 ; int sum = 5 ; findCount ( n , sum ) ; } }
using System ; class GFG { static int countNonDecreasing ( int n ) { int [ , ] dp = new int [ 10 , n + 1 ] ; for ( int i = 0 ; i < 10 ; i ++ ) dp [ i , 1 ] = 1 ; for ( int digit = 0 ; digit <= 9 ; digit ++ ) { for ( int len = 2 ; len <= n ; len ++ ) { for ( int x = 0 ; x <= digit ; x ++ ) dp [ digit , len ] += dp [ x , len - 1 ] ; } } int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) count += dp [ i , n ] ; return count ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( countNonDecreasing ( n ) ) ; } }
using System ; class GFG { static long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( countNonDecreasing ( n ) ) ; } }
using System ; class GFG { static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int res = n ; for ( int x = 1 ; x <= n ; x ++ ) { int temp = x * x ; if ( temp > n ) break ; else res = Math . Min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; } public static void Main ( ) { Console . Write ( getMinSquares ( 6 ) ) ; } }
using System ; class squares { static int getMinSquares ( int n ) { if ( n <= 3 ) return n ; int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( int i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( int x = 1 ; x <= Math . Ceiling ( Math . Sqrt ( i ) ) ; x ++ ) { int temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . Min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } int res = dp [ n ] ; return res ; } public static void Main ( String [ ] args ) { Console . Write ( getMinSquares ( 6 ) ) ; } }
using System ; class coin { static int minCoins ( int [ ] coins , int m , int V ) { if ( V == 0 ) return 0 ; int res = int . MaxValue ; for ( int i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { int sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != int . MaxValue && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; } public static void Main ( ) { int [ ] coins = { 9 , 6 , 5 , 1 } ; int m = coins . Length ; int V = 11 ; Console . Write ( " Minimum ▁ coins ▁ required ▁ is ▁ " + minCoins ( coins , m , V ) ) ; } }
using System ; class GFG { static int minCoins ( int [ ] coins , int m , int V ) { int [ ] table = new int [ V + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i <= V ; i ++ ) table [ i ] = int . MaxValue ; for ( int i = 1 ; i <= V ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { int sub_res = table [ i - coins [ j ] ] ; if ( sub_res != int . MaxValue && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } return table [ V ] ; } static public void Main ( ) { int [ ] coins = { 9 , 6 , 5 , 1 } ; int m = coins . Length ; int V = 11 ; Console . WriteLine ( " Minimum ▁ coins ▁ required ▁ is ▁ " + minCoins ( coins , m , V ) ) ; } }
using System ; class GFG { static int superSeq ( String X , String Y , int m , int n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . Min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; } public static void Main ( ) { String X = " AGGTAB " ; String Y = " GXTXAYB " ; Console . WriteLine ( " Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is : ▁ " + superSeq ( X , Y , X . Length , Y . Length ) ) ; } }
using System ; class GFG { static int superSeq ( String X , String Y , int m , int n ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i , j ] = j ; else if ( j == 0 ) dp [ i , j ] = i ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = 1 + Math . Min ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) ; } } return dp [ m , n ] ; } public static void Main ( ) { String X = " AGGTAB " ; String Y = " GXTXAYB " ; Console . WriteLine ( " Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is ▁ " + superSeq ( X , Y , X . Length , Y . Length ) ) ; } }
using System ; public class GFG { static int sumOfDigitsFrom1ToN ( int n ) { int result = 0 ; for ( int x = 1 ; x <= n ; x ++ ) result += sumOfDigits ( x ) ; return result ; } static int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; } public static void Main ( ) { int n = 328 ; Console . WriteLine ( " Sum ▁ of ▁ digits " + " ▁ in ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + n + " ▁ is ▁ " + sumOfDigitsFrom1ToN ( n ) ) ; } }
using System ; public class GFG { static int sumOfDigitsFrom1ToN ( int n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; int d = ( int ) ( Math . Log ( n ) / Math . Log ( 10 ) ) ; int [ ] a = new int [ d + 1 ] ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( Math . Ceiling ( Math . Pow ( 10 , i - 1 ) ) ) ; int p = ( int ) ( Math . Ceiling ( Math . Pow ( 10 , d ) ) ) ; int msd = n / p ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; } public static void Main ( ) { int n = 328 ; Console . WriteLine ( " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ " + " from ▁ 1 ▁ to ▁ " + n + " ▁ is ▁ " + sumOfDigitsFrom1ToN ( n ) ) ; } }
using System ; class GFG { static int countWays ( int N ) { if ( N == 1 ) return 4 ; int countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( int i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } int result = countS + countB ; return ( result * result ) ; } public static void Main ( ) { int N = 3 ; Console . Write ( countWays ( N ) ) ; } }
using System ; class GFG { static int count ( int n ) { int [ ] table = new int [ n + 1 ] ; for ( int j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( int i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( int i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; } public static void Main ( ) { int n = 20 ; Console . WriteLine ( " Count ▁ for ▁ " + n + " ▁ is ▁ " + count ( n ) ) ; n = 13 ; Console . Write ( " Count ▁ for ▁ " + n + " ▁ is ▁ " + count ( n ) ) ; } }
using System ; class GFG { public static void search ( String txt , String pat ) { int M = pat . Length ; int N = txt . Length ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) Console . WriteLine ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } } public static void Main ( ) { String txt = " AABAACAADAABAAABAA " ; String pat = " AABA " ; search ( txt , pat ) ; } }
using System ; public class GFG { public readonly static int d = 256 ; static void search ( String pat , String txt , int q ) { int M = pat . Length ; int N = txt . Length ; int i , j ; int p = 0 ; int t = 0 ; int h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] ) % q ; t = ( d * t + txt [ i ] ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; } if ( j == M ) Console . WriteLine ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; } if ( i < N - M ) { t = ( d * ( t - txt [ i ] * h ) + txt [ i + M ] ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } public static void Main ( ) { String txt = " GEEKS ▁ FOR ▁ GEEKS " ; String pat = " GEEK " ; int q = 101 ; search ( pat , txt , q ) ; } }
using System ; class GFG { static void search ( string pat , string txt ) { int M = pat . Length ; int N = txt . Length ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { Console . WriteLine ( " Pattern ▁ found ▁ at ▁ index ▁ " + i ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } static void Main ( ) { string txt = " ABCEABCDABCEABCD " ; string pat = " ABCD " ; search ( pat , txt ) ; } }
using System ; class GFG { static void printPatternUtil ( string str , char [ ] buf , int i , int j , int n ) { if ( i == n ) { buf [ j ] = ' \0' ; Console . WriteLine ( buf ) ; return ; } buf [ j ] = str [ i ] ; printPatternUtil ( str , buf , i + 1 , j + 1 , n ) ; buf [ j ] = ' ▁ ' ; buf [ j + 1 ] = str [ i ] ; printPatternUtil ( str , buf , i + 1 , j + 2 , n ) ; } static void printPattern ( string str ) { int len = str . Length ; char [ ] buf = new char [ 2 * len ] ; buf [ 0 ] = str [ 0 ] ; printPatternUtil ( str , buf , 1 , 1 , len ) ; } public static void Main ( ) { string str = " ABCD " ; printPattern ( str ) ; } }
using System ; class GFG { static int getMedian ( int [ ] ar1 , int [ ] ar2 , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } public static void Main ( ) { int [ ] ar1 = { 1 , 12 , 15 , 26 , 38 } ; int [ ] ar2 = { 2 , 13 , 17 , 30 , 45 } ; int n1 = ar1 . Length ; int n2 = ar2 . Length ; if ( n1 == n2 ) Console . Write ( " Median ▁ is ▁ " + getMedian ( ar1 , ar2 , n1 ) ) ; else Console . Write ( " arrays ▁ are ▁ of ▁ unequal ▁ size " ) ; } }
using System ; class GFG { static double area ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 ) { return Math . Abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } static bool isInside ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x , int y ) { double A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; double A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; double A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; double A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; } public static void Main ( ) { if ( isInside ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) Console . WriteLine ( " Inside " ) ; else Console . WriteLine ( " Not ▁ Inside " ) ; } }
using System ; class GFG { public static int counter = 2 ; static bool isLucky ( int n ) { int next_position = n ; if ( counter > n ) return true ; if ( n % counter == 0 ) return false ; next_position -= next_position / counter ; counter ++ ; return isLucky ( next_position ) ; } public static void Main ( ) { int x = 5 ; if ( isLucky ( x ) ) Console . Write ( x + " ▁ is ▁ a ▁ " + " lucky ▁ no . " ) ; else Console . Write ( x + " ▁ is ▁ not " + " ▁ a ▁ lucky ▁ no . " ) ; } }
using System ; class GFG { static int pow ( int a , int b ) { if ( b == 0 ) return 1 ; int answer = a ; int increment = a ; int i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; } public static void Main ( ) { Console . Write ( pow ( 5 , 3 ) ) ; } }
using System ; class GFG { static int multiply ( int x , int y ) { if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; } static int pow ( int a , int b ) { if ( b > 0 ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; } public static void Main ( ) { Console . Write ( pow ( 5 , 3 ) ) ; } }
using System ; class GFG { static int count ( int n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; int po = 1 ; while ( n / po > 9 ) po = po * 10 ; int msd = n / po ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; } public static void Main ( ) { int n = 578 ; Console . Write ( count ( n ) ) ; } }
using System ; class GFG { static int maximumNumberDistinctPrimeRange ( int m , int n ) { long [ ] factorCount = new long [ n + 1 ] ; bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = ( int ) factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = ( int ) factorCount [ i ] ; num = i ; } } return num ; } public static void Main ( ) { int m = 4 , n = 6 ; Console . WriteLine ( maximumNumberDistinctPrimeRange ( m , n ) ) ; } }
using System ; class GFG { static int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } static int findSmallerInRight ( string str , int low , int high ) { int countRight = 0 , i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; } static int findRank ( string str ) { int len = str . Length ; int mul = fact ( len ) ; int rank = 1 ; int countRight ; for ( int i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; } public static void Main ( ) { string str = " string " ; Console . Write ( findRank ( str ) ) ; } }
using System ; class GFG { static int MAX_CHAR = 256 ; int [ ] count = new int [ MAX_CHAR ] ; static int fact ( int n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } static void populateAndIncreaseCount ( int [ ] count , char [ ] str ) { int i ; for ( i = 0 ; i < str . Length ; ++ i ) ++ count [ str [ i ] ] ; for ( i = 1 ; i < MAX_CHAR ; ++ i ) count [ i ] += count [ i - 1 ] ; } static void updatecount ( int [ ] count , char ch ) { int i ; for ( i = ch ; i < MAX_CHAR ; ++ i ) -- count [ i ] ; } static int findRank ( char [ ] str ) { int len = str . Length ; int mul = fact ( len ) ; int rank = 1 , i ; populateAndIncreaseCount ( count , str ) ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; rank += count [ str [ i ] - 1 ] * mul ; updatecount ( count , str [ i ] ) ; } return rank ; } public static void Main ( String [ ] args ) { char [ ] str = " string " . ToCharArray ( ) ; Console . WriteLine ( findRank ( str ) ) ; } }
using System ; class GFG { static float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; } public static void Main ( ) { int n = 10 ; float x = 1 ; Console . Write ( " e ^ x ▁ = ▁ " + exponential ( n , x ) ) ; } }
using System ; class GFG { static bool isPerfectSquare ( int x ) { int s = ( int ) Math . Sqrt ( x ) ; return ( s * s == x ) ; } static bool isFibonacci ( int n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; } public static void Main ( ) { for ( int i = 1 ; i <= 10 ; i ++ ) Console . WriteLine ( isFibonacci ( i ) ? i + " ▁ is ▁ a ▁ Fibonacci ▁ Number " : i + " ▁ is ▁ a ▁ not ▁ Fibonacci ▁ Number " ) ; } }
using System ; class GFG { static int findTrailingZeros ( int n ) { int count = 0 ; for ( int i = 5 ; n / i >= 1 ; i *= 5 ) count += n / i ; return count ; } public static void Main ( ) { int n = 100 ; Console . WriteLine ( " Count ▁ of ▁ trailing ▁ 0s ▁ in ▁ " + n + " ! ▁ is ▁ " + findTrailingZeros ( n ) ) ; } }
using System ; class GFG { static int catalan ( int n ) { if ( n <= 1 ) { return 1 ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += catalan ( i ) * catalan ( n - i - 1 ) ; } return res ; } public static void Main ( ) { for ( int i = 0 ; i < 10 ; i ++ ) Console . Write ( catalan ( i ) + " ▁ " ) ; } }
using System ; class GFG { static uint catalanDP ( uint n ) { uint [ ] catalan = new uint [ n + 2 ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( uint i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( uint j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; } static void Main ( ) { for ( uint i = 0 ; i < 10 ; i ++ ) Console . Write ( catalanDP ( i ) + " ▁ " ) ; } }
using System ; class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) { k = n - k ; } for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void Main ( ) { for ( int i = 0 ; i < 10 ; i ++ ) { Console . Write ( catalan ( i ) + " ▁ " ) ; } } }
using System ; class GFG { static int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) Console . Write ( " Wrong ▁ input " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . Abs ( hour_angle - minute_angle ) ; angle = Math . Min ( 360 - angle , angle ) ; return angle ; } public static void Main ( ) { Console . WriteLine ( calcAngle ( 9 , 60 ) ) ; Console . Write ( calcAngle ( 3 , 30 ) ) ; } }
using System ; class GFG { static int getInvCount ( int [ , ] arr ) { int inv_count = 0 ; for ( int i = 0 ; i < 3 - 1 ; i ++ ) for ( int j = i + 1 ; j < 3 ; j ++ ) if ( arr [ j , i ] > 0 && arr [ j , i ] > arr [ i , j ] ) inv_count ++ ; return inv_count ; } static bool isSolvable ( int [ , ] puzzle ) { int invCount = getInvCount ( puzzle ) ; return ( invCount % 2 == 0 ) ; } static void Main ( ) { int [ , ] puzzle = new int [ 3 , 3 ] { { 1 , 8 , 2 } , { 0 , 4 , 3 } , { 7 , 6 , 5 } } ; if ( isSolvable ( puzzle ) ) Console . WriteLine ( " Solvable " ) ; else Console . WriteLine ( " Not ▁ Solvable " ) ; } }
using System ; class GFG { static double find ( double p ) { return Math . Ceiling ( Math . Sqrt ( 2 * 365 * Math . Log ( 1 / ( 1 - p ) ) ) ) ; } public static void Main ( ) { Console . Write ( find ( 0.70 ) ) ; } }
using System ; class GFG { static int countSolutions ( int n ) { int res = 0 ; for ( int x = 0 ; x * x < n ; x ++ ) for ( int y = 0 ; x * x + y * y < n ; y ++ ) res ++ ; return res ; } public static void Main ( ) { Console . WriteLine ( " Total ▁ Number ▁ of ▁ " + " distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " + countSolutions ( 6 ) ) ; } }
using System ; class GFG { static int countSolutions ( int n ) { int x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; } public static void Main ( ) { Console . WriteLine ( " Total ▁ Number ▁ of ▁ " + " distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " + countSolutions ( 6 ) ) ; } }
using System ; class GFG { static double EPSILON = 0.001 ; static double func ( double x ) { return x * x * x - x * x + 2 ; } static double derivFunc ( double x ) { return 3 * x * x - 2 * x ; } static void newtonRaphson ( double x ) { double h = func ( x ) / derivFunc ( x ) ; while ( Math . Abs ( h ) >= EPSILON ) { h = func ( x ) / derivFunc ( x ) ; x = x - h ; } Console . Write ( " The ▁ value ▁ of ▁ the " + " ▁ root ▁ is ▁ : ▁ " + Math . Round ( x * 100.0 ) / 100.0 ) ; } public static void Main ( ) { double x0 = - 20 ; newtonRaphson ( x0 ) ; } }
using System ; class GFG { static int getSingle ( int [ ] arr , int n ) { int ones = 0 , twos = 0 ; int common_bit_mask ; for ( int i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; } public static void Main ( ) { int [ ] arr = { 3 , 3 , 2 , 3 } ; int n = arr . Length ; Console . WriteLine ( " The ▁ element ▁ with ▁ single " + " occurrence ▁ is ▁ " + getSingle ( arr , n ) ) ; } }
using System ; class GFG { static int INT_SIZE = 32 ; static int getSingle ( int [ ] arr , int n ) { int result = 0 ; int x , sum ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & x ) == 0 ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; } public static void Main ( ) { int [ ] arr = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = arr . Length ; Console . WriteLine ( " The ▁ element ▁ with ▁ single ▁ " + " occurrence ▁ is ▁ " + getSingle ( arr , n ) ) ; } }
using System ; class GFG { static bool oppositeSigns ( int x , int y ) { return ( ( x ^ y ) < 0 ) ; } public static void Main ( ) { int x = 100 , y = - 100 ; if ( oppositeSigns ( x , y ) == true ) Console . Write ( " Signs ▁ are ▁ opposite " ) ; else Console . Write ( " Signs ▁ are ▁ not ▁ opposite " ) ; } }
using System ; class GFG { static int countSetBits ( int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; } static int countSetBitsUtil ( int x ) { if ( x <= 0 ) return 0 ; return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ; } public static void Main ( ) { int n = 4 ; Console . Write ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ " ) ; Console . Write ( countSetBits ( n ) ) ; } }
using System ; class GFG { static int countSetBits ( int n ) { int i = 0 ; int ans = 0 ; while ( ( 1 << i ) <= n ) { bool k = false ; int change = 1 << i ; for ( int j = 0 ; j <= n ; j ++ ) { if ( k == true ) ans += 1 ; else ans += 0 ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; } static void Main ( ) { int n = 17 ; Console . Write ( countSetBits ( n ) ) ; } }
using System ; class GFG { static int swapBits ( int x , int p1 , int p2 , int n ) { int set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; int set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; int xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; int result = x ^ xor ; return result ; } public static void Main ( ) { int res = swapBits ( 28 , 0 , 3 , 2 ) ; Console . WriteLine ( " Result ▁ = ▁ " + res ) ; } }
using System ; class GFG { static int smallest ( int x , int y , int z ) { int c = 0 ; while ( x != 0 && y != 0 && z != 0 ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } public static void Main ( ) { int x = 12 , y = 15 , z = 5 ; Console . Write ( " Minimum ▁ of ▁ 3" + " ▁ numbers ▁ is ▁ " + smallest ( x , y , z ) ) ; } }
using System ; class GFG { static int snoob ( int x ) { int rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; } static void Main ( ) { int x = 156 ; Console . WriteLine ( " Next ▁ higher ▁ number ▁ with ▁ same " + " number ▁ of ▁ set ▁ bits ▁ is ▁ " + snoob ( x ) ) ; } }
using System ; class GFG { static int addOne ( int x ) { int m = 1 ; while ( ( int ) ( x & m ) == 1 ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } public static void Main ( ) { Console . WriteLine ( addOne ( 13 ) ) ; } }
using System ; class GFG { static int addOne ( int x ) { return ( - ( ~ x ) ) ; } public static void Main ( ) { Console . WriteLine ( addOne ( 13 ) ) ; } }
using System ; class GFG { static int multiplyWith3Point5 ( int x ) { return ( x << 1 ) + x + ( x >> 1 ) ; } public static void Main ( ) { int x = 2 ; Console . Write ( multiplyWith3Point5 ( x ) ) ; } }
using System ; class GFG { static int fun ( int n ) { return n & ( n - 1 ) ; } public static void Main ( ) { int n = 7 ; Console . Write ( " The ▁ number ▁ after ▁ unsetting ▁ " + " the ▁ rightmost ▁ set ▁ bit ▁ " + fun ( n ) ) ; } }
using System ; class GFG { static int isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } public static void Main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) == 1 ) Console . Write ( test_no + " ▁ is ▁ a ▁ power ▁ of ▁ 4" ) ; else Console . Write ( test_no + " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4" ) ; } }
using System ; class GFG { static int isPowerOfFour ( int n ) { int count = 0 ; int x = n & ( n - 1 ) ; if ( n > 0 && x == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } static void Main ( ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) > 0 ) Console . WriteLine ( " { 0 } ▁ is ▁ a ▁ power ▁ of ▁ 4" , test_no ) ; else Console . WriteLine ( " { 0 } ▁ is ▁ not ▁ a ▁ power ▁ of ▁ 4" , test_no ) ; } }
using System ; public class AWS { public static int min ( int x , int y ) { return y ^ ( ( x ^ y ) & - ( x << y ) ) ; } public static int max ( int x , int y ) { return x ^ ( ( x ^ y ) & - ( x << y ) ) ; } public static void Main ( string [ ] args ) { int x = 15 ; int y = 6 ; Console . Write ( " Minimum ▁ of ▁ " + x + " ▁ and ▁ " + y + " ▁ is ▁ " ) ; Console . WriteLine ( min ( x , y ) ) ; Console . Write ( " Maximum ▁ of ▁ " + x + " ▁ and ▁ " + y + " ▁ is ▁ " ) ; Console . WriteLine ( max ( x , y ) ) ; } }
using System ; class GFG { static int getOddOccurrence ( int [ ] arr , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; int n = arr . Length ; Console . Write ( getOddOccurrence ( arr , n ) ) ; } }
using System ; class Count { public static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; } public static int FlippedCount ( int a , int b ) { return countSetBits ( a ^ b ) ; } public static void Main ( ) { int a = 10 ; int b = 20 ; Console . WriteLine ( FlippedCount ( a , b ) ) ; } }
using System ; class GFG { public static int getFirstSetBitPos ( int n ) { return ( int ) ( ( Math . Log10 ( n & - n ) ) / Math . Log10 ( 2 ) ) + 1 ; } public static void Main ( ) { int n = 12 ; Console . WriteLine ( getFirstSetBitPos ( n ) ) ; } }
using System ; class GFG { static int PositionRightmostSetbit ( int n ) { int position = 1 ; int m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; } static public void Main ( ) { int n = 16 ; Console . WriteLine ( PositionRightmostSetbit ( n ) ) ; } }
using System ; class GFG { static int INT_SIZE = 32 ; static int Right_most_setbit ( int num ) { int pos = 1 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; } static public void Main ( ) { int num = 18 ; int pos = Right_most_setbit ( num ) ; Console . WriteLine ( pos ) ; } }
using System ; public class GFG { static void bin ( int n ) { if ( n > 1 ) bin ( n >> 1 ) ; Console . Write ( n & 1 ) ; } public static void Main ( ) { bin ( 131 ) ; Console . WriteLine ( ) ; bin ( 3 ) ; } }
using System ; class GFG { static long swapBits ( int x ) { long even_bits = x & 0xAAAAAAAA ; long odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; } public static void Main ( ) { int x = 23 ; Console . Write ( swapBits ( x ) ) ; } }
using System ; class GFG { static bool isPowerOfTwo ( int n ) { return ( n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ) ? true : false ; } static int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int i = 1 , pos = 1 ; while ( ( i & n ) == 0 ) { i = i << 1 ; ++ pos ; } return pos ; } static void Main ( ) { int n = 16 ; int pos = findPosition ( n ) ; if ( pos == - 1 ) Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 12 ; pos = findPosition ( n ) ; if ( pos == - 1 ) Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 128 ; pos = findPosition ( n ) ; if ( pos == - 1 ) Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; } }
using System ; class GFG { static bool isPowerOfTwo ( int n ) { return n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static int findPosition ( int n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 ; int count = 0 ; while ( n > 0 ) { n = n >> 1 ; ++ count ; } return count ; } static void Main ( ) { int n = 0 ; int pos = findPosition ( n ) ; if ( pos == - 1 ) Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 12 ; pos = findPosition ( n ) ; if ( pos == - 1 ) Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; n = 128 ; pos = findPosition ( n ) ; if ( pos == - 1 ) Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Invalid ▁ number " ) ; else Console . WriteLine ( " n ▁ = ▁ " + n + " , ▁ Position ▁ " + pos ) ; } }
using System ; class GFG { static public void Main ( ) { int x = 10 ; int y = 5 ; x = x * y ; y = x / y ; x = x / y ; Console . WriteLine ( " After ▁ swaping : " + " ▁ x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; } }
using System ; class GFG { public static void Main ( ) { int x = 10 ; int y = 5 ; x = x ^ y ; y = x ^ y ; x = x ^ y ; Console . WriteLine ( " After ▁ swap : ▁ x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; } }
using System ; class GFG { static void swap ( int [ ] xp , int [ ] yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; } static void Main ( ) { int [ ] x = { 10 } ; swap ( x , x ) ; Console . WriteLine ( " After ▁ swap ( & x , " + " & x ) : ▁ x ▁ = ▁ " + x [ 0 ] ) ; } }
using System ; class GFG { static int maxOnesIndex ( int [ ] arr , int n ) { int max_count = 0 ; int max_index = 0 ; int prev_zero = - 1 ; int prev_prev_zero = - 1 ; for ( int curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; } public static void Main ( ) { int [ ] arr = { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 } ; int n = arr . Length ; Console . Write ( " Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ " + maxOnesIndex ( arr , n ) ) ; } }
using System ; class GFG { static int findLength ( int [ ] arr , int n ) { int max_len = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int mn = arr [ i ] , mx = arr [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { mn = Math . Min ( mn , arr [ j ] ) ; mx = Math . Max ( mx , arr [ j ] ) ; if ( ( mx - mn ) == j - i ) max_len = Math . Max ( max_len , mx - mn + 1 ) ; } } return max_len ; } public static void Main ( ) { int [ ] arr = { 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 } ; int n = arr . Length ; Console . WriteLine ( " Length ▁ of ▁ the ▁ longest " + " ▁ contiguous ▁ subarray ▁ is ▁ " + findLength ( arr , n ) ) ; } }
using System ; class GFG { static void printArr ( int [ ] arr , int k ) { for ( int i = 0 ; i < k ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } static void printSeqUtil ( int n , int k , int len , int [ ] arr ) { if ( len == k ) { printArr ( arr , k ) ; return ; } int i = ( len == 0 ) ? 1 : arr [ len - 1 ] + 1 ; len ++ ; while ( i <= n ) { arr [ len - 1 ] = i ; printSeqUtil ( n , k , len , arr ) ; i ++ ; } len -- ; } static void printSeq ( int n , int k ) { int [ ] arr = new int [ k ] ; int len = 0 ; printSeqUtil ( n , k , len , arr ) ; } static public void Main ( ) { int k = 3 , n = 7 ; printSeq ( n , k ) ; } }
using System ; class GFG { static bool isSubSequence ( string str1 , string str2 , int m , int n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; } public static void Main ( ) { string str1 = " gksrek " ; string str2 = " geeksforgeeks " ; int m = str1 . Length ; int n = str2 . Length ; bool res = isSubSequence ( str1 , str2 , m , n ) ; if ( res ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static void nextGreatest ( int [ ] arr ) { int size = arr . Length ; int max_from_right = arr [ size - 1 ] ; arr [ size - 1 ] = - 1 ; for ( int i = size - 2 ; i >= 0 ; i -- ) { int temp = arr [ i ] ; arr [ i ] = max_from_right ; if ( max_from_right < temp ) max_from_right = temp ; } } static void printArray ( int [ ] arr ) { for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 16 , 17 , 4 , 3 , 5 , 2 } ; nextGreatest ( arr ) ; Console . WriteLine ( " The ▁ modified ▁ array : " ) ; printArray ( arr ) ; } }
using System ; class GFG { static int GetCeilIndex ( int [ ] arr , int [ ] T , int l , int r , int key ) { while ( r - l > 1 ) { int m = l + ( r - l ) / 2 ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; } static int LongestIncreasingSubsequence ( int [ ] arr , int n ) { int [ ] tailIndices = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) tailIndices [ i ] = 0 ; int [ ] prevIndices = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) prevIndices [ i ] = - 1 ; int len = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) tailIndices [ 0 ] = i ; else if ( arr [ i ] > arr [ tailIndices [ len - 1 ] ] ) { prevIndices [ i ] = tailIndices [ len - 1 ] ; tailIndices [ len ++ ] = i ; } else { int pos = GetCeilIndex ( arr , tailIndices , - 1 , len - 1 , arr [ i ] ) ; prevIndices [ i ] = tailIndices [ pos - 1 ] ; tailIndices [ pos ] = i ; } } Console . Write ( " LIS ▁ of ▁ given ▁ input " ) ; for ( int i = tailIndices [ len - 1 ] ; i >= 0 ; i = prevIndices [ i ] ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; return len ; } public static void Main ( ) { int [ ] arr = { 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 } ; int n = arr . Length ; Console . Write ( " LIS ▁ size STRNEWLINE " + LongestIncreasingSubsequence ( arr , n ) ) ; } }
using System ; class GenerateArrays { public virtual void generateUtil ( int [ ] A , int [ ] B , int [ ] C , int i , int j , int m , int n , int len , bool flag ) { if ( flag ) { if ( len != 0 ) { printArr ( C , len + 1 ) ; } for ( int k = i ; k < m ; k ++ ) { if ( len == 0 ) { C [ len ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len , ! flag ) ; } else if ( A [ k ] > C [ len ] ) { C [ len + 1 ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , ! flag ) ; } } } else { for ( int l = j ; l < n ; l ++ ) { if ( B [ l ] > C [ len ] ) { C [ len + 1 ] = B [ l ] ; generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , ! flag ) ; } } } } public virtual void generate ( int [ ] A , int [ ] B , int m , int n ) { int [ ] C = new int [ m + n ] ; generateUtil ( A , B , C , 0 , 0 , m , n , 0 , true ) ; } public virtual void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } Console . WriteLine ( " " ) ; } public static void Main ( string [ ] args ) { GenerateArrays generate = new GenerateArrays ( ) ; int [ ] A = new int [ ] { 10 , 15 , 25 } ; int [ ] B = new int [ ] { 5 , 20 , 30 } ; int n = A . Length ; int m = B . Length ; generate . generate ( A , B , n , m ) ; } }
using System ; class GFG { static void replace_elements ( int [ ] arr , int n ) { int pos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( int i = 0 ; i < pos ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } static void Main ( ) { int [ ] arr = { 6 , 4 , 3 , 4 , 3 , 3 , 5 } ; int n = arr . Length ; replace_elements ( arr , n ) ; } }
using System ; class GFG { static void arrangeString ( string str , int x , int y ) { int count_0 = 0 ; int count_1 = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '0' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 count_1 > 0 ) { for ( int j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { Console . Write ( "0" ) ; count_0 -- ; } } for ( int j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { Console . Write ( "1" ) ; count_1 -- ; } } } } public static void Main ( ) { string str = "01101101101101101000000" ; int x = 1 ; int y = 2 ; arrangeString ( str , x , y ) ; } }
using System ; class GFG { public static void rearrange ( int [ ] arr ) { if ( arr == null arr . Length % 2 == 1 ) return ; int currIdx = ( arr . Length - 1 ) / 2 ; while ( currIdx > 0 ) { int count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { int temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } } public static void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 2 , 4 , 6 } ; rearrange ( arr ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( " ▁ " + arr [ i ] ) ; } }
using System ; class GFG { static int maxDiff ( int [ ] arr , int arr_size ) { int max_diff = arr [ 1 ] - arr [ 0 ] ; int i , j ; for ( i = 0 ; i < arr_size ; i ++ ) { for ( j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 90 , 10 , 110 } ; Console . Write ( " Maximum ▁ difference ▁ is ▁ " + maxDiff ( arr , 5 ) ) ; } }
using System ; class GFG { static int maxDiff ( int [ ] arr , int n ) { int maxDiff = - 1 ; int maxRight = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { int diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 90 , 10 , 110 } ; int n = arr . Length ; Console . WriteLine ( " Maximum ▁ difference ▁ is ▁ " + maxDiff ( arr , n ) ) ; } }
using System ; class GFG { static int maxDiff ( int [ ] arr , int n ) { int diff = arr [ 1 ] - arr [ 0 ] ; int curr_sum = diff ; int max_sum = curr_sum ; for ( int i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; } public static void Main ( ) { int [ ] arr = { 80 , 2 , 6 , 3 , 100 } ; int n = arr . Length ; Console . WriteLine ( " Maximum ▁ difference ▁ is ▁ " + maxDiff ( arr , n ) ) ; } }
using System ; class GFG { static int findMaximum ( int [ ] arr , int low , int high ) { int max = arr [ low ] ; int i ; for ( i = low ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } public static void Main ( ) { int [ ] arr = { 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 } ; int n = arr . Length ; Console . Write ( " The ▁ maximum ▁ element ▁ is ▁ " + findMaximum ( arr , 0 , n - 1 ) ) ; } }
using System ; class GFG { static int findMaximum ( int [ ] arr , int low , int high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; else return findMaximum ( arr , mid + 1 , high ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 50 , 10 , 9 , 7 , 6 } ; int n = arr . Length ; Console . Write ( " The ▁ maximum ▁ element ▁ is ▁ " + findMaximum ( arr , 0 , n - 1 ) ) ; } }
using System ; class GFG { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int maxPathSum ( int [ ] ar1 , int [ ] ar2 , int m , int n ) { int i = 0 , j = 0 ; int result = 0 , sum1 = 0 , sum2 = 0 ; while ( i < m && j < n ) { if ( ar1 [ i ] < ar2 [ j ] ) sum1 += ar1 [ i ++ ] ; else if ( ar1 [ i ] > ar2 [ j ] ) sum2 += ar2 [ j ++ ] ; else { result += max ( sum1 , sum2 ) + ar1 [ i ] ; sum1 = 0 ; sum2 = 0 ; i ++ ; j ++ ; } } while ( i < m ) sum1 += ar1 [ i ++ ] ; while ( j < n ) sum2 += ar2 [ j ++ ] ; result += max ( sum1 , sum2 ) ; return result ; } public static void Main ( ) { int [ ] ar1 = { 2 , 3 , 7 , 10 , 12 , 15 , 30 , 34 } ; int [ ] ar2 = { 1 , 5 , 7 , 8 , 10 , 15 , 16 , 19 } ; int m = ar1 . Length ; int n = ar2 . Length ; Console . Write ( " Maximum ▁ sum ▁ path ▁ is ▁ : " + maxPathSum ( ar1 , ar2 , m , n ) ) ; } }
using System ; class GFG { static void smallestGreater ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int diff = int . MaxValue ; int closest = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) Console . Write ( " _ ▁ " ) ; else Console . Write ( arr [ closest ] + " ▁ " ) ; } } public static void Main ( ) { int [ ] ar = { 6 , 3 , 9 , 8 , 10 , 2 , 1 , 15 , 7 } ; int n = ar . Length ; smallestGreater ( ar , n ) ; } }
using System ; class Test { static int [ ] arr = new int [ ] { 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 } ; static void findZeroes ( int m ) { int wL = 0 , wR = 0 ; int bestL = 0 , bestWindow = 0 ; int zeroCount = 0 ; while ( wR < arr . Length ) { if ( zeroCount <= m ) { if ( arr [ wR ] == 0 ) zeroCount ++ ; wR ++ ; } if ( zeroCount > m ) { if ( arr [ wL ] == 0 ) zeroCount -- ; wL ++ ; } if ( ( wR - wL > bestWindow ) && ( zeroCount <= m ) ) { bestWindow = wR - wL ; bestL = wL ; } } for ( int i = 0 ; i < bestWindow ; i ++ ) { if ( arr [ bestL + i ] == 0 ) Console . Write ( bestL + i + " ▁ " ) ; } } public static void Main ( String [ ] args ) { int m = 2 ; Console . Write ( " Indexes ▁ of ▁ zeroes ▁ to ▁ be ▁ flipped ▁ are ▁ " ) ; findZeroes ( m ) ; } }
using System ; class Test { static int [ ] arr = new int [ ] { 1 , 2 , 2 , 4 } ; static int countIncreasing ( int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; } public static void Main ( String [ ] args ) { Console . Write ( " Count ▁ of ▁ strictly ▁ increasing " + " subarrays ▁ is ▁ " + countIncreasing ( arr . Length ) ) ; } }
using System ; class GFG { static int [ ] arr = new int [ ] { 1 , 2 , 2 , 4 } ; static int countIncreasing ( int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } public static void Main ( ) { Console . WriteLine ( " Count ▁ of ▁ strictly ▁ " + " increasing ▁ subarrays ▁ is ▁ " + countIncreasing ( arr . Length ) ) ; } }
using System ; public class GFG { static long arraySum ( int [ ] arr , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; } static long maxDiff ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; long arraysum = arraySum ( arr , n ) ; long diff1 = Math . Abs ( arraysum - 2 * arraySum ( arr , k ) ) ; Array . Reverse ( arr ) ; long diff2 = Math . Abs ( arraysum - 2 * arraySum ( arr , k ) ) ; return ( Math . Max ( diff1 , diff2 ) ) ; } static public void Main ( ) { int [ ] arr = { 1 , 7 , 4 , 8 , - 1 , 5 , 2 , 1 } ; int n = arr . Length ; int k = 3 ; Console . WriteLine ( " Maximum ▁ Difference ▁ = ▁ " + maxDiff ( arr , n , k ) ) ; } }
using System ; class GFG { static int minNumber ( int [ ] a , int n , int x ) { Array . Sort ( a ) ; int k ; for ( k = 0 ; a [ ( n ) / 2 ] != x ; k ++ ) { a [ n ++ ] = x ; Array . Sort ( a ) ; } return k ; } public static void Main ( String [ ] args ) { int x = 10 ; int [ ] a = { 10 , 20 , 30 } ; int n = 3 ; Console . WriteLine ( minNumber ( a , n - 1 , x ) ) ; } }
using System ; class GFG { public static int minNumber ( int [ ] a , int n , int x ) { int l = 0 , h = 0 , e = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } int ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; } public static void Main ( ) { int x = 10 ; int [ ] a = { 10 , 20 , 30 } ; int n = a . Length ; Console . WriteLine ( minNumber ( a , n , x ) ) ; } }
using System ; class GFG { static void checkEVENodd ( int [ ] arr , int n , int l , int r ) { if ( arr [ r ] == 1 ) Console . WriteLine ( " odd " ) ; else Console . WriteLine ( " even " ) ; } public static void Main ( ) { int [ ] arr = { 1 , 1 , 0 , 1 } ; int n = arr . Length ; checkEVENodd ( arr , n , 1 , 3 ) ; } }
using System ; public class GFG { static int findMean ( int [ ] arr , int l , int r ) { int sum = 0 , count = 0 ; for ( int i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } int mean = ( int ) Math . Floor ( ( double ) sum / count ) ; return mean ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; Console . WriteLine ( findMean ( arr , 0 , 2 ) ) ; Console . WriteLine ( findMean ( arr , 1 , 3 ) ) ; Console . WriteLine ( findMean ( arr , 0 , 4 ) ) ; } }
using System ; class GFG { static int calculateProduct ( int [ ] A , int L , int R , int P ) { L = L - 1 ; R = R - 1 ; int ans = 1 ; for ( int i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; } static public void Main ( ) { int [ ] A = { 1 , 2 , 3 , 4 , 5 , 6 } ; int P = 229 ; int L = 2 , R = 5 ; Console . WriteLine ( calculateProduct ( A , L , R , P ) ) ; L = 1 ; R = 3 ; Console . WriteLine ( calculateProduct ( A , L , R , P ) ) ; } }
using System ; class GFG { static int MAX = 10000 ; static int [ ] prefix = new int [ MAX + 1 ] ; static void buildPrefix ( ) { bool [ ] prime = new bool [ MAX + 1 ] ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] == false ) prefix [ p ] ++ ; } } static int query ( int L , int R ) { return prefix [ R ] - prefix [ L - 1 ] ; } public static void Main ( ) { buildPrefix ( ) ; int L = 5 , R = 10 ; Console . WriteLine ( query ( L , R ) ) ; L = 1 ; R = 10 ; Console . WriteLine ( query ( L , R ) ) ; } }
using System ; class GFG { static void command ( bool [ ] arr , int a , int b ) { arr [ a ] ^= true ; arr [ b + 1 ] ^= true ; } static void process ( bool [ ] arr , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { arr [ k ] ^= arr [ k - 1 ] ; } } static void result ( bool [ ] arr , int n ) { for ( int k = 1 ; k <= n ; k ++ ) { if ( arr [ k ] == true ) Console . Write ( "1" + " ▁ " ) ; else Console . Write ( "0" + " ▁ " ) ; } } public static void Main ( ) { int n = 5 , m = 3 ; bool [ ] arr = new bool [ n + 2 ] ; command ( arr , 1 , 5 ) ; command ( arr , 2 , 5 ) ; command ( arr , 3 , 5 ) ; process ( arr , n ) ; result ( arr , n ) ; } }
using System ; class GFG { static float probability ( int [ ] a , int [ ] b , int size1 , int size2 ) { int max1 = int . MinValue , count1 = 0 ; for ( int i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max1 ) { max1 = a [ i ] ; count1 = 1 ; } else if ( a [ i ] == max1 ) { count1 ++ ; } } int max2 = int . MinValue , count2 = 0 ; for ( int i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max2 ) { max2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max2 ) { count2 ++ ; } } return ( float ) ( count1 * count2 ) / ( size1 * size2 ) ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 3 } ; int [ ] b = { 1 , 3 , 3 } ; int size1 = a . Length ; int size2 = b . Length ; Console . WriteLine ( probability ( a , b , size1 , size2 ) ) ; } }
using System ; class GFG { public static int countDe ( int [ ] arr , int n ) { int [ ] v = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; Array . Sort ( arr ) ; int count1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; Array . Reverse ( arr ) ; int count2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . Min ( count1 , count2 ) ) ; } public static void Main ( ) { int [ ] arr = new int [ ] { 5 , 9 , 21 , 17 , 13 } ; int n = 5 ; Console . WriteLine ( " Minimum ▁ Dearrangement ▁ = ▁ " + countDe ( arr , n ) ) ; } }
using System ; using System . Linq ; public class GFG { static int maxOfSegmentMins ( int [ ] a , int n , int k ) { if ( k == 1 ) return a . Min ( ) ; if ( k == 2 ) return Math . Max ( a [ 0 ] , a [ n - 1 ] ) ; return a . Max ( ) ; } static public void Main ( ) { int [ ] a = { - 10 , - 9 , - 8 , 2 , 7 , - 6 , - 5 } ; int n = a . Length ; int k = 2 ; Console . WriteLine ( maxOfSegmentMins ( a , n , k ) ) ; } }
using System ; class GFG { static int printMinimumProduct ( int [ ] arr , int n ) { int first_min = Math . Min ( arr [ 0 ] , arr [ 1 ] ) ; int second_min = Math . Max ( arr [ 0 ] , arr [ 1 ] ) ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; } public static void Main ( ) { int [ ] a = { 11 , 8 , 5 , 7 , 5 , 100 } ; int n = a . Length ; Console . WriteLine ( printMinimumProduct ( a , n ) ) ; } }
using System ; class GFG { static long noOfTriples ( long [ ] arr , int n ) { Array . Sort ( arr ) ; long count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; } public static void Main ( ) { long [ ] arr = { 1 , 3 , 3 , 4 } ; int n = arr . Length ; Console . Write ( noOfTriples ( arr , n ) ) ; } }
using System ; class GFG { static bool checkReverse ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } Array . Sort ( temp ) ; int front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } int back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 5 , 4 , 3 } ; int n = arr . Length ; if ( checkReverse ( arr , n ) ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } } }
using System ; public class GFG { static bool checkReverse ( int [ ] arr , int n ) { if ( n == 1 ) { return true ; } int i ; for ( i = 1 ; arr [ i - 1 ] < arr [ i ] && i < n ; i ++ ) ; if ( i == n ) { return true ; } int j = i ; while ( j < n && arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) { return false ; } j ++ ; } if ( j == n ) { return true ; } int k = j ; if ( arr [ k ] < arr [ i - 1 ] ) { return false ; } while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) { return false ; } k ++ ; } return true ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 4 , 10 , 9 , 8 } ; int n = arr . Length ; if ( checkReverse ( arr , n ) ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } } }
using System ; public class GFG { static int MinOperation ( int [ ] a , int [ ] b , int n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . Abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . Abs ( a [ i ] - b [ i ] ) ; } return result ; } public static void Main ( ) { int [ ] a = { 3 , 1 , 1 } ; int [ ] b = { 1 , 2 , 2 } ; int n = a . Length ; Console . WriteLine ( MinOperation ( a , b , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void sortExceptUandL ( int [ ] a , int l , int u , int n ) { int [ ] b = new int [ n - ( u - l + 1 ) ] ; for ( int i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; Array . Sort < int > ( b , 0 , n - ( u - l + 1 ) ) ; for ( int i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( int i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; } public static void Main ( ) { int [ ] a = { 5 , 4 , 3 , 12 , 14 , 9 } ; int n = a . Length ; int l = 2 , u = 4 ; sortExceptUandL ( a , l , u , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; } }
using System ; public class GFG { static int sortExceptK ( int [ ] arr , int k , int n ) { int temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; Array . Sort ( arr , 0 , n - 1 ) ; int last = arr [ n - 1 ] ; for ( int i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; return 0 ; } public static void Main ( ) { int [ ] a = { 10 , 4 , 11 , 7 , 6 , 20 } ; int k = 2 ; int n = a . Length ; sortExceptK ( a , k , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int maxPartitions ( int [ ] arr , int n ) { int ans = 0 , max_so_far = 0 ; for ( int i = 0 ; i < n ; ++ i ) { max_so_far = Math . Max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 2 , 3 , 4 } ; int n = arr . Length ; Console . Write ( maxPartitions ( arr , n ) ) ; } }
using System ; class GFG { public static void cuttringRopes ( int [ ] Ropes , int n ) { Array . Sort ( Ropes ) ; int singleOperation = 0 ; int cuttingLenght = Ropes [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( Ropes [ i ] - cuttingLenght > 0 ) { Console . Write ( n - i + " ▁ " ) ; cuttingLenght = Ropes [ i ] ; singleOperation ++ ; } } if ( singleOperation == 0 ) Console . Write ( "0" ) ; } public static void Main ( ) { int [ ] Ropes = { 5 , 1 , 1 , 2 , 3 , 5 } ; int n = Ropes . Length ; cuttringRopes ( Ropes , n ) ; } }
using System ; public class GfG { public static void rankify ( int [ ] A , int n ) { float [ ] R = new float [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int r = 1 , s = 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != i && A [ j ] < A [ i ] ) r += 1 ; if ( j != i && A [ j ] == A [ i ] ) s += 1 ; } R [ i ] = r + ( float ) ( s - 1 ) / ( float ) 2 ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( R [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] A = { 1 , 2 , 5 , 2 , 1 , 25 , 2 } ; int n = A . Length ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( A [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; rankify ( A , n ) ; } }
using System ; public class GfG { public static int min_noOf_operation ( int [ ] arr , int n , int k ) { int noOfSubtraction ; int res = 0 ; for ( int i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; } public static void Main ( ) { int [ ] arr = { 1 , 1 , 2 , 3 } ; int N = 4 ; int k = 5 ; Console . WriteLine ( min_noOf_operation ( arr , N , k ) ) ; } }
using System ; class GFG { static int maxSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; } static public void Main ( ) { int [ ] arr = { 3 , 5 , 6 , 1 } ; int n = arr . Length ; Console . WriteLine ( maxSum ( arr , n ) ) ; } }
using System ; class GFG { static int countPairs ( int [ ] a , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; } public static void Main ( ) { int [ ] a = { 1 , 10 , 4 , 2 } ; int k = 3 ; int n = a . Length ; Console . WriteLine ( countPairs ( a , n , k ) ) ; } }
using System ; class GFG { static int countPairs ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; } public static void Main ( ) { int [ ] a = { 1 , 10 , 4 , 2 } ; int k = 3 ; int n = a . Length ; Console . WriteLine ( countPairs ( a , n , k ) ) ; } }
using System ; public class GFG { static int sumOfMinAbsDifferences ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int sum = 0 ; sum += Math . Abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . Abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) sum += Math . Min ( Math . Abs ( arr [ i ] - arr [ i - 1 ] ) , Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; } public static void Main ( ) { int [ ] arr = { 5 , 10 , 1 , 4 , 8 , 7 } ; int n = arr . Length ; Console . Write ( " Sum ▁ = ▁ " + sumOfMinAbsDifferences ( arr , n ) ) ; } }
using System ; class GFG { static int findSmallestDifference ( int [ ] A , int [ ] B , int m , int n ) { Array . Sort ( A ) ; Array . Sort ( B ) ; int a = 0 , b = 0 ; int result = int . MaxValue ; while ( a < m && b < n ) { if ( Math . Abs ( A [ a ] - B [ b ] ) < result ) result = Math . Abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; } public static void Main ( ) { int [ ] A = { 1 , 2 , 11 , 5 } ; int [ ] B = { 4 , 12 , 19 , 23 , 127 , 235 } ; int m = A . Length ; int n = B . Length ; Console . Write ( findSmallestDifference ( A , B , m , n ) ) ; } }
using System ; class GFG { static void findLarger ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = n - 1 ; i >= n / 2 ; i -- ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 6 , 1 , 0 , 9 } ; int n = arr . Length ; findLarger ( arr , n ) ; } }
using System ; class GFG { static int getMissingNo ( int [ ] a , int n ) { int total = ( n + 1 ) * ( n + 2 ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 4 , 5 , 6 } ; int miss = getMissingNo ( a , 5 ) ; Console . Write ( miss ) ; } }
using System ; class GFG { static int countOccurrences ( int [ ] arr , int n , int x ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res ++ ; return res ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 } ; int n = arr . Length ; int x = 2 ; Console . Write ( countOccurrences ( arr , n , x ) ) ; } }
using System ; class GFG { static int binarySearch ( int [ ] arr , int l , int r , int x ) { if ( r < l ) return - 1 ; int mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } static int countOccurrences ( int [ ] arr , int n , int x ) { int ind = binarySearch ( arr , 0 , n - 1 , x ) ; if ( ind == - 1 ) return 0 ; int count = 1 ; int left = ind - 1 ; while ( left >= 0 && arr [ left ] == x ) { count ++ ; left -- ; } int right = ind + 1 ; while ( right < n && arr [ right ] == x ) { count ++ ; right ++ ; } return count ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 } ; int n = arr . Length ; int x = 2 ; Console . Write ( countOccurrences ( arr , n , x ) ) ; } }
using System ; class GFG { static void printClosest ( int [ ] arr , int n , int x ) { int res_l = 0 , res_r = 0 ; int l = 0 , r = n - 1 , diff = int . MaxValue ; while ( r > l ) { if ( Math . Abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . Abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } Console . Write ( " ▁ The ▁ closest ▁ pair ▁ is ▁ " + arr [ res_l ] + " ▁ and ▁ " + arr [ res_r ] ) ; } public static void Main ( ) { int [ ] arr = { 10 , 22 , 28 , 29 , 30 , 40 } ; int x = 54 ; int n = arr . Length ; printClosest ( arr , n , x ) ; } }
using System ; class GFG { static int countOnes ( int [ ] arr , int low , int high ) { if ( high >= low ) { int mid = low + ( high - low ) / 2 ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; } public static void Main ( ) { int [ ] arr = { 1 , 1 , 1 , 1 , 0 , 0 , 0 } ; int n = arr . Length ; Console . WriteLine ( " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ " + " array ▁ is ▁ " + countOnes ( arr , 0 , n - 1 ) ) ; } }
using System ; class GFG { static int findMissingUtil ( int [ ] arr1 , int [ ] arr2 , int N ) { if ( N == 1 ) return arr1 [ 0 ] ; if ( arr1 [ 0 ] != arr2 [ 0 ] ) return arr1 [ 0 ] ; int lo = 0 , hi = N - 1 ; while ( lo < hi ) { int mid = ( lo + hi ) / 2 ; if ( arr1 [ mid ] == arr2 [ mid ] ) lo = mid ; else hi = mid ; if ( lo == hi - 1 ) break ; } return arr1 [ hi ] ; } static void findMissing ( int [ ] arr1 , int [ ] arr2 , int M , int N ) { if ( N == M - 1 ) Console . WriteLine ( " Missing ▁ Element ▁ is ▁ " + findMissingUtil ( arr1 , arr2 , M ) + " STRNEWLINE " ) ; else if ( M == N - 1 ) Console . WriteLine ( " Missing ▁ Element ▁ is ▁ " + findMissingUtil ( arr2 , arr1 , N ) + " STRNEWLINE " ) ; else Console . WriteLine ( " Invalid ▁ Input " ) ; } public static void Main ( ) { int [ ] arr1 = { 1 , 4 , 5 , 7 , 9 } ; int [ ] arr2 = { 4 , 5 , 7 , 9 } ; int M = arr1 . Length ; int N = arr2 . Length ; findMissing ( arr1 , arr2 , M , N ) ; } }
using System ; class GFG { static void findMissing ( int [ ] arr1 , int [ ] arr2 , int M , int N ) { if ( M != N - 1 && N != M - 1 ) { Console . WriteLine ( " Invalid ▁ Input " ) ; return ; } int res = 0 ; for ( int i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( int i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; Console . WriteLine ( " Missing ▁ element ▁ is ▁ " + res ) ; } public static void Main ( ) { int [ ] arr1 = { 4 , 1 , 5 , 9 , 7 } ; int [ ] arr2 = { 7 , 5 , 9 , 4 } ; int M = arr1 . Length ; int N = arr2 . Length ; findMissing ( arr1 , arr2 , M , N ) ; } }
using System ; class GFG { static void printTwoElements ( int [ ] arr , int size ) { int i ; Console . Write ( " The ▁ repeating ▁ element ▁ is ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { int abs_val = Math . Abs ( arr [ i ] ) ; if ( arr [ abs_val - 1 ] > 0 ) arr [ abs_val - 1 ] = - arr [ abs_val - 1 ] ; else Console . WriteLine ( abs_val ) ; } Console . Write ( " And ▁ the ▁ missing ▁ element ▁ is ▁ " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) Console . WriteLine ( i + 1 ) ; } } public static void Main ( ) { int [ ] arr = { 7 , 3 , 4 , 5 , 5 , 6 , 2 } ; int n = arr . Length ; printTwoElements ( arr , n ) ; } }
using System ; class GFG { static int x , y ; static void getTwoElements ( int [ ] arr , int n ) { int xor1 ; int set_bit_no ; int i ; x = 0 ; y = 0 ; xor1 = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) xor1 = xor1 ^ arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) xor1 = xor1 ^ i ; set_bit_no = xor1 & ~ ( xor1 - 1 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( ( i & set_bit_no ) != 0 ) x = x ^ i ; else y = y ^ i ; } } public static void Main ( ) { int [ ] arr = { 1 , 3 , 4 , 5 , 1 , 6 , 2 } ; int n = arr . Length ; getTwoElements ( arr , n ) ; Console . Write ( " ▁ The ▁ missing ▁ element ▁ is ▁ " + x + " and ▁ the ▁ " + " repeating ▁ number ▁ is ▁ " + y ) ; } }
using System ; class FindFourElements { void findFourElements ( int [ ] A , int n , int X ) { for ( int i = 0 ; i < n - 3 ; i ++ ) { for ( int j = i + 1 ; j < n - 2 ; j ++ ) { for ( int k = j + 1 ; k < n - 1 ; k ++ ) { for ( int l = k + 1 ; l < n ; l ++ ) { if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) Console . Write ( A [ i ] + " ▁ " + A [ j ] + " ▁ " + A [ k ] + " ▁ " + A [ l ] ) ; } } } } } public static void Main ( ) { FindFourElements findfour = new FindFourElements ( ) ; int [ ] A = { 10 , 20 , 30 , 40 , 1 , 2 } ; int n = A . Length ; int X = 91 ; findfour . findFourElements ( A , n , X ) ; } }
using System ; public class GFG { static int search ( int [ ] arr , int n , int x ) { int i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . Abs ( arr [ i ] - x ) ; } Console . WriteLine ( " number ▁ is ▁ not " + " ▁ present ! " ) ; return - 1 ; } public static void Main ( ) { int [ ] arr = { 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 } ; int n = arr . Length ; int x = 3 ; Console . WriteLine ( " Element ▁ " + x + " ▁ is ▁ present ▁ at ▁ index ▁ " + search ( arr , n , 3 ) ) ; } }
using System ; class GFG { static void thirdLargest ( int [ ] arr , int arr_size ) { if ( arr_size < 3 ) { Console . Write ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] ; for ( int i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; int second = - int . MaxValue ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; int third = - int . MaxValue ; for ( int i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; Console . Write ( " The ▁ third ▁ Largest ▁ " + " element ▁ is ▁ " + third ) ; } public static void Main ( ) { int [ ] arr = { 12 , 13 , 1 , 10 , 34 , 16 } ; int n = arr . Length ; thirdLargest ( arr , n ) ; } }
using System ; class GFG { static void thirdLargest ( int [ ] arr , int arr_size ) { if ( arr_size < 3 ) { Console . Write ( " ▁ Invalid ▁ Input ▁ " ) ; return ; } int first = arr [ 0 ] , second = int . MinValue , third = int . MinValue ; for ( int i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) { third = arr [ i ] ; } } Console . Write ( " The ▁ third ▁ Largest ▁ element ▁ is ▁ " + third ) ; } public static void Main ( ) { int [ ] arr = { 12 , 13 , 1 , 10 , 34 , 16 } ; int n = arr . Length ; thirdLargest ( arr , n ) ; } }
using System ; using System . Collections . Generic ; class GFG { static bool checkPair ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % 2 != 0 ) { return false ; } sum = sum / 2 ; HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = sum - arr [ i ] ; if ( s . Contains ( val ) ) { Console . Write ( " Pair ▁ elements ▁ are ▁ { 0 } ▁ and ▁ { 1 } STRNEWLINE " , arr [ i ] , val ) ; return true ; } s . Add ( arr [ i ] ) ; } return false ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 11 , 5 , 1 , 4 , 7 } ; int n = arr . Length ; if ( checkPair ( arr , n ) == false ) { Console . Write ( " No ▁ pair ▁ found " ) ; } } }
using System ; class GFG { static String search ( int [ ] arr , int n , int x ) { if ( arr [ n - 1 ] == x ) return " Found " ; int backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( int i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " Found " ; return " Not ▁ Found " ; } } } public static void Main ( ) { int [ ] arr = { 4 , 6 , 1 , 5 , 8 } ; int n = arr . Length ; int x = 1 ; Console . WriteLine ( search ( arr , n , x ) ) ; } }
using System ; public class GFG { public static int findMajority ( int [ ] arr , int n ) { return arr [ n / 2 ] ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 2 , 3 } ; int n = arr . Length ; Console . WriteLine ( findMajority ( arr , n ) ) ; } }
using System ; class GFG { static void minAdjDifference ( int [ ] arr , int n ) { if ( n < 2 ) return ; int res = Math . Abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( int i = 2 ; i < n ; i ++ ) res = Math . Min ( res , Math . Abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . Min ( res , Math . Abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; Console . Write ( " Min ▁ Difference ▁ = ▁ " + res ) ; } public static void Main ( ) { int [ ] a = { 10 , 12 , 13 , 15 , 10 } ; int n = a . Length ; minAdjDifference ( a , n ) ; } }
using System ; class GFG { static void Print3Smallest ( int [ ] array , int n ) { int firstmin = int . MaxValue ; int secmin = int . MaxValue ; int thirdmin = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( array [ i ] < firstmin ) { thirdmin = secmin ; secmin = firstmin ; firstmin = array [ i ] ; } else if ( array [ i ] < secmin ) { thirdmin = secmin ; secmin = array [ i ] ; } else if ( array [ i ] < thirdmin ) thirdmin = array [ i ] ; } Console . WriteLine ( " First ▁ min ▁ = ▁ " + firstmin ) ; Console . WriteLine ( " Second ▁ min ▁ = ▁ " + secmin ) ; Console . WriteLine ( " Third ▁ min ▁ = ▁ " + thirdmin ) ; } static void Main ( ) { int [ ] array = new int [ ] { 4 , 9 , 1 , 32 , 12 } ; int n = array . Length ; Print3Smallest ( array , n ) ; } }
using System ; using System . Linq ; class GFG { static int getMin ( int [ ] arr , int n ) { return arr . Min ( ) ; } static int getMax ( int [ ] arr , int n ) { return arr . Max ( ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 12 , 1234 , 45 , 67 , 1 } ; int n = arr . Length ; Console . WriteLine ( " Minimum ▁ element ▁ of ▁ array : ▁ " + getMin ( arr , n ) ) ; Console . WriteLine ( " Maximum ▁ element ▁ of ▁ array : ▁ " + getMax ( arr , n ) ) ; } }
using System ; internal class CountFrequency { internal virtual void printfrequency ( int [ ] arr , int n ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ j ] = arr [ j ] - 1 ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ arr [ i ] % n ] = arr [ arr [ i ] % n ] + n ; } for ( int i = 0 ; i < n ; i ++ ) { Console . WriteLine ( i + 1 + " - > " + arr [ i ] / n ) ; } } public static void Main ( string [ ] args ) { CountFrequency count = new CountFrequency ( ) ; int [ ] arr = new int [ ] { 2 , 3 , 3 , 2 , 5 } ; int n = arr . Length ; count . printfrequency ( arr , n ) ; } }
using System ; public class Inversion { static int getInvCount ( int [ ] arr , int n ) { int invcount = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int small = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; int great = 0 ; for ( int j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; } public static void Main ( ) { int [ ] arr = new int [ ] { 8 , 4 , 2 , 1 } ; int n = arr . Length ; Console . WriteLine ( " Inversion ▁ count ▁ : ▁ " + getInvCount ( arr , n ) ) ; } }
using System ; class Test { static int [ ] arr = new int [ ] { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; static int findWater ( int n ) { int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; int water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) left [ i ] = Math . Max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) right [ i ] = Math . Max ( right [ i + 1 ] , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) water += Math . Min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; } public static void Main ( ) { Console . WriteLine ( " Maximum ▁ water ▁ that ▁ can ▁ be ▁ accumulated ▁ is ▁ " + findWater ( arr . Length ) ) ; } }
using System ; class GFG { static int findWater ( int [ ] arr , int n ) { int result = 0 ; int left_max = 0 , right_max = 0 ; int lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; } public static void Main ( ) { int [ ] arr = { 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 } ; int result = Trap . findWater ( arr , arr . length ) ; System . out . print ( " ▁ Total ▁ trapping ▁ water : ▁ " + result ) ; } }
using System ; class GFG { static int maximum ( int a , int b ) { return a > b ? a : b ; } static int minimum ( int a , int b ) { return a < b ? a : b ; } static double findMedianSortedArrays ( ref int [ ] a , int n , ref int [ ] b , int m ) { int min_index = 0 , max_index = n , i = 0 , j = 0 , median = 0 ; while ( min_index <= max_index ) { i = ( min_index + max_index ) / 2 ; j = ( ( n + m + 1 ) / 2 ) - i ; if ( i < n && j > 0 && b [ j - 1 ] > a [ i ] ) min_index = i + 1 ; else if ( i > 0 && j < m && b [ j ] < a [ i - 1 ] ) max_index = i - 1 ; else { if ( i == 0 ) median = b [ j - 1 ] ; else if ( j == 0 ) median = a [ i - 1 ] ; else median = maximum ( a [ i - 1 ] , b [ j - 1 ] ) ; break ; } } if ( ( n + m ) % 2 == 1 ) return ( double ) median ; if ( i == n ) return ( median + b [ j ] ) / 2.0 ; if ( j == m ) return ( median + a [ i ] ) / 2.0 ; return ( median + minimum ( a [ i ] , b [ j ] ) ) / 2.0 ; } static void Main ( ) { int [ ] a = new int [ ] { 900 } ; int [ ] b = new int [ ] { 10 , 13 , 14 } ; int n = a . Length ; int m = b . Length ; if ( n < m ) Console . Write ( " The ▁ median ▁ is ▁ : ▁ " + findMedianSortedArrays ( ref a , n , ref b , m ) ) ; else Console . Write ( " The ▁ median ▁ is ▁ : ▁ " + findMedianSortedArrays ( ref b , m , ref a , n ) ) ; } }
using System ; class GFG { static void printUncommon ( int [ ] arr1 , int [ ] arr2 , int n1 , int n2 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) { Console . Write ( arr1 [ i ] + " ▁ " ) ; i ++ ; k ++ ; } else if ( arr2 [ j ] < arr1 [ i ] ) { Console . Write ( arr2 [ j ] + " ▁ " ) ; k ++ ; j ++ ; } else { i ++ ; j ++ ; } } while ( i < n1 ) { Console . Write ( arr1 [ i ] + " ▁ " ) ; i ++ ; k ++ ; } while ( j < n2 ) { Console . Write ( arr2 [ j ] + " ▁ " ) ; j ++ ; k ++ ; } } public static void Main ( ) { int [ ] arr1 = { 10 , 20 , 30 } ; int [ ] arr2 = { 20 , 25 , 30 , 40 , 50 } ; int n1 = arr1 . Length ; int n2 = arr2 . Length ; printUncommon ( arr1 , arr2 , n1 , n2 ) ; } }
using System ; class GFG { static int leastFrequent ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int min_count = n + 1 , res = - 1 ; int curr_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } static public void Main ( ) { int [ ] arr = { 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 } ; int n = arr . Length ; Console . Write ( leastFrequent ( arr , n ) ) ; } }
using System ; class GFG { static int M = 4 ; static void sort ( ref int [ , ] a , int row , int n ) { for ( int i = 0 ; i < M - 1 ; i ++ ) { if ( a [ row , i ] > a [ row , i + 1 ] ) { int temp = a [ row , i ] ; a [ row , i ] = a [ row , i + 1 ] ; a [ row , i + 1 ] = temp ; } } } static int maximumSum ( int [ , ] a , int n ) { int i = 0 , j = 0 ; for ( i = 0 ; i < n ; i ++ ) sort ( ref a , i , n ) ; int sum = a [ n - 1 , M - 1 ] ; int prev = a [ n - 1 , M - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { for ( j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i , j ] < prev ) { prev = a [ i , j ] ; sum += prev ; break ; } } if ( j == - 1 ) return 0 ; } return sum ; } static void Main ( ) { int [ , ] arr = new int [ , ] { { 1 , 7 , 3 , 4 } , { 4 , 2 , 5 , 1 } , { 9 , 5 , 1 , 8 } } ; int n = arr . GetLength ( 0 ) ; Console . Write ( maximumSum ( arr , n ) ) ; } }
using System ; class GFG { static int countPairs ( int [ ] A , int n , int k ) { int ans = 0 ; Array . Sort ( A ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int x = 0 ; while ( ( A [ i ] * Math . Pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . Pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; } public static void Main ( ) { int [ ] A = { 3 , 8 , 9 , 12 , 18 , 4 , 24 , 2 , 6 } ; int n = A . Length ; int k = 3 ; Console . WriteLine ( countPairs ( A , n , k ) ) ; } }
using System ; class GFG { static int minDistance ( int [ ] arr , int n ) { int maximum_element = arr [ 0 ] ; int min_dis = n ; int index = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( maximum_element == arr [ i ] ) { min_dis = Math . Min ( min_dis , ( i - index ) ) ; index = i ; } else if ( maximum_element < arr [ i ] ) { maximum_element = arr [ i ] ; min_dis = n ; index = i ; } else continue ; } return min_dis ; } public static void Main ( ) { int [ ] arr = { 6 , 3 , 1 , 3 , 6 , 4 , 6 } ; int n = arr . Length ; Console . WriteLine ( " Minimum ▁ distance ▁ = ▁ " + minDistance ( arr , n ) ) ; } }
using System ; class GFG { static int findValue ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 10 , 8 , 1 } ; int k = 2 ; int n = arr . Length ; Console . WriteLine ( findValue ( arr , n , k ) ) ; } }
using System ; class GFG { static void dupLastIndex ( int [ ] arr , int n ) { if ( arr == null n <= 0 ) return ; for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { Console . WriteLine ( " Last ▁ index : " + i ) ; Console . WriteLine ( " Last ▁ duplicate ▁ item : ▁ " + arr [ i ] ) ; return ; } } Console . WriteLine ( " no ▁ duplicate ▁ found " ) ; } public static void Main ( ) { int [ ] arr = { 1 , 5 , 5 , 6 , 6 , 7 , 9 } ; int n = arr . Length ; dupLastIndex ( arr , n ) ; } }
using System ; class GFG { static int findSmallest ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; } public static void Main ( ) { int [ ] a = { 25 , 20 , 5 , 10 , 100 } ; int n = a . Length ; Console . WriteLine ( findSmallest ( a , n ) ) ; } }
using System ; class GFG { static int min_element ( int [ ] a ) { int min = int . MaxValue ; int i ; for ( i = 0 ; i < a . Length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return min ; } static int findSmallest ( int [ ] a , int n ) { int smallest = min_element ( a ) ; for ( int i = 1 ; i < n ; i ++ ) if ( a [ i ] % smallest >= 1 ) return - 1 ; return smallest ; } public static void Main ( ) { int [ ] a = { 25 , 20 , 5 , 10 , 100 } ; int n = a . Length ; Console . WriteLine ( findSmallest ( a , n ) ) ; } }
using System ; class GfG { public static int findIndex ( int [ ] arr ) { int maxIndex = 0 ; for ( int i = 0 ; i < arr . Length ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( int i = 0 ; i < arr . Length ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return - 1 ; return maxIndex ; } public static void Main ( ) { int [ ] arr = new int [ ] { 3 , 6 , 1 , 0 } ; Console . WriteLine ( findIndex ( arr ) ) ; } }
using System ; class GFG { static int find_consecutive_steps ( int [ ] arr , int len ) { int count = 0 ; int maximum = 0 ; for ( int index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . Max ( maximum , count ) ; count = 0 ; } } return Math . Max ( maximum , count ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int len = arr . Length ; Console . WriteLine ( find_consecutive_steps ( arr , len ) ) ; } }
using System ; public class GFG { static int CalculateMax ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int min_sum = arr [ 0 ] + arr [ 1 ] ; int max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . Abs ( max_sum - min_sum ) ) ; } static public void Main ( ) { int [ ] arr = { 6 , 7 , 1 , 11 } ; int n = arr . Length ; Console . WriteLine ( CalculateMax ( arr , n ) ) ; } }
using System ; using System . Linq ; using System . Collections . Generic ; class GFG { static long calculate ( long [ ] a , int n ) { Array . Sort ( a ) ; int i , j ; List < long > s = new List < long > ( ) ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . Add ( ( a [ i ] + a [ j ] ) ) ; long mini = s . Min ( ) ; long maxi = s . Max ( ) ; return Math . Abs ( maxi - mini ) ; } public static void Main ( ) { long [ ] a = { 2 , 6 , 4 , 3 } ; int n = a . Length ; Console . WriteLine ( calculate ( a , n ) ) ; } }
using System ; class GFG { static void printMinDiffPairs ( int [ ] arr , int n ) { if ( n <= 1 ) return ; Array . Sort ( arr ) ; int minDiff = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) minDiff = Math . Min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { Console . Write ( " ▁ ( " + arr [ i - 1 ] + " , ▁ " + arr [ i ] + " ) , ▁ " ) ; } } } public static void Main ( ) { int [ ] arr = { 5 , 3 , 2 , 4 , 1 } ; int n = arr . Length ; printMinDiffPairs ( arr , n ) ; } }
using System ; public class MaximumAbsoluteDifference { private static int calculateDiff ( int i , int j , int [ ] array ) { return Math . Abs ( array [ i ] - array [ j ] ) + Math . Abs ( i - j ) ; } private static int maxDistance ( int [ ] array ) { int result = 0 ; for ( int i = 0 ; i < array . Length ; i ++ ) { for ( int j = i ; j < array . Length ; j ++ ) { result = Math . Max ( result , calculateDiff ( i , j , array ) ) ; } } return result ; } public static void Main ( ) { int [ ] array = { - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 } ; Console . WriteLine ( maxDistance ( array ) ) ; } }
using System ; public class MaximumAbsoluteDifference { private static int maxDistance ( int [ ] array ) { int max1 = int . MinValue ; int min1 = int . MaxValue ; int max2 = int . MinValue ; int min2 = int . MaxValue ; for ( int i = 0 ; i < array . Length ; i ++ ) { max1 = Math . Max ( max1 , array [ i ] + i ) ; min1 = Math . Min ( min1 , array [ i ] + i ) ; max2 = Math . Max ( max2 , array [ i ] - i ) ; min2 = Math . Min ( min2 , array [ i ] - i ) ; } return Math . Max ( max1 - min1 , max2 - min2 ) ; } public static void Main ( ) { int [ ] array = { - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 } ; Console . WriteLine ( maxDistance ( array ) ) ; } }
using System ; class GFG { static int extrema ( int [ ] a , int n ) { int count = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; } public static void Main ( ) { int [ ] a = { 1 , 0 , 2 , 1 } ; int n = a . Length ; Console . WriteLine ( extrema ( a , n ) ) ; } }
using System ; class GFG { public static int findClosest ( int [ ] arr , int target ) { int n = arr . Length ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; int i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } public static int getClosest ( int val1 , int val2 , int target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 } ; int target = 11 ; Console . WriteLine ( findClosest ( arr , target ) ) ; } }
using System ; class GFG { static int sum ( int [ ] a , int n ) { int maxSum = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) maxSum = Math . Max ( maxSum , a [ i ] + a [ j ] ) ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; } public static void Main ( ) { int [ ] array = { 1 , 1 , 1 , 2 , 2 , 2 } ; int n = array . Length ; Console . WriteLine ( sum ( array , n ) ) ; } }
using System ; class GFG { static int sum ( int [ ] a , int n ) { int maxVal = a [ 0 ] , maxCount = 1 ; int secondMax = int . MinValue ; int secondMaxCount = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == maxVal ) maxCount ++ ; else if ( a [ i ] > maxVal ) { secondMax = maxVal ; secondMaxCount = maxCount ; maxVal = a [ i ] ; maxCount = 1 ; } else if ( a [ i ] == secondMax ) { secondMax = a [ i ] ; secondMaxCount ++ ; } else if ( a [ i ] > secondMax ) { secondMax = a [ i ] ; secondMaxCount = 1 ; } } if ( maxCount > 1 ) return maxCount * ( maxCount - 1 ) / 2 ; return secondMaxCount ; } public static void Main ( ) { int [ ] array = { 1 , 1 , 1 , 2 , 2 , 2 , 3 } ; int n = array . Length ; Console . WriteLine ( sum ( array , n ) ) ; } }
using System ; class GFG { static void printKMissing ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; int count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { Console . Write ( curr + " ▁ " ) ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { Console . Write ( curr + " ▁ " ) ; curr ++ ; count ++ ; } } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 } ; int n = arr . Length ; int k = 3 ; printKMissing ( arr , n , k ) ; } }
using System ; class GFG { public static int nobleInteger ( int [ ] arr ) { int size = arr . Length ; for ( int i = 0 ; i < size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 10 , 3 , 20 , 40 , 2 } ; int res = nobleInteger ( arr ) ; if ( res != - 1 ) Console . Write ( " The ▁ noble ▁ integer " + " ▁ is ▁ " + res ) ; else Console . Write ( " No ▁ Noble ▁ Integer " + " ▁ Found " ) ; } }
using System ; public class GFG { public static int nobleInteger ( int [ ] arr ) { Array . Sort ( arr ) ; int n = arr . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; } static public void Main ( ) { int [ ] arr = { 10 , 3 , 20 , 40 , 2 } ; int res = nobleInteger ( arr ) ; if ( res != - 1 ) Console . Write ( " The ▁ noble ▁ integer ▁ is ▁ " + res ) ; else Console . Write ( " No ▁ Noble ▁ Integer ▁ " + " Found " ) ; } }
using System ; class MinSum { static long findMinSum ( long [ ] a , long [ ] b , long n ) { Array . Sort ( a ) ; Array . Sort ( b ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + Math . Abs ( a [ i ] - b [ i ] ) ; return sum ; } public static void Main ( String [ ] args ) { long [ ] a = { 4 , 1 , 8 , 7 } ; long [ ] b = { 2 , 3 , 6 , 5 } ; int n = a . Length ; Console . Write ( findMinSum ( a , b , n ) ) ; } }
using System ; public class GFG { static int minProductSubset ( int [ ] a , int n ) { if ( n == 1 ) return a [ 0 ] ; int negmax = int . MinValue ; int posmin = int . MinValue ; int count_neg = 0 , count_zero = 0 ; int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; negmax = Math . Max ( negmax , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < posmin ) { posmin = a [ i ] ; } product *= a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return posmin ; if ( count_neg % 2 == 0 && count_neg != 0 ) { product = product / negmax ; } return product ; } public static void Main ( ) { int [ ] a = new int [ ] { - 1 , - 1 , - 2 , 4 , 3 } ; int n = 5 ; Console . WriteLine ( minProductSubset ( a , n ) ) ; } }
using System ; public class GFG { static int findElement ( int [ ] a , int n , int b ) { Array . Sort ( a ) ; int max = a [ n - 1 ] ; while ( b < max ) { if ( Array . BinarySearch ( a , b ) > - 1 ) b *= 2 ; else return b ; } return b ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 3 } ; int n = a . Length ; int b = 1 ; Console . WriteLine ( findElement ( a , n , b ) ) ; } }
using System ; class GFG { static int Mod = 1000000007 ; static long findSum ( int [ ] arr , int n ) { long sum = 0 ; Array . Sort ( arr ) ; int i = 0 ; while ( i < n && arr [ i ] < 0 ) { if ( i != n - 1 && arr [ i + 1 ] <= 0 ) { sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod ; i += 2 ; } else break ; } int j = n - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { if ( j != 0 && arr [ j - 1 ] > 0 ) { sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod ; j -= 2 ; } else break ; } if ( j > i ) sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod ; else if ( i == j ) sum = ( sum + arr [ i ] ) % Mod ; return sum ; } public static void Main ( ) { int [ ] arr = { - 1 , 9 , 4 , 5 , - 4 , 7 } ; int n = arr . Length ; Console . WriteLine ( findSum ( arr , n ) ) ; } }
using System ; class Solution { static void countOddRotations ( int n ) { int odd_count = 0 , even_count = 0 ; do { int digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = n / 10 ; } while ( n != 0 ) ; Console . WriteLine ( " Odd ▁ = ▁ " + odd_count ) ; Console . WriteLine ( " Even ▁ = ▁ " + even_count ) ; } public static void Main ( ) { int n = 1234 ; countOddRotations ( n ) ; } }
using System ; public class GFG { static int numberOfDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } static void cal ( int num ) { int digits = numberOfDigits ( num ) ; int powTen = ( int ) Math . Pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int firstDigit = num / powTen ; int left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; Console . Write ( left + " ▁ " ) ; num = left ; } } static public void Main ( ) { int num = 1445 ; cal ( num ) ; } }
using System ; class GFG { static void CheckKCycles ( int n , String s ) { bool ff = true ; int x = 0 ; for ( int i = 1 ; i < n ; i ++ ) { x = ( s . Substring ( i ) + s . Substring ( 0 , i ) ) . Length ; if ( x >= s . Length ) { continue ; } ff = false ; break ; } if ( ff ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } public static void Main ( String [ ] args ) { int n = 3 ; String s = "123" ; CheckKCycles ( n , s ) ; } }
using System ; public class GFG { static bool rightRotationDivisor ( int N ) { int lastDigit = N % 10 ; int rightRotation = ( int ) ( lastDigit * Math . Pow ( 10 , ( int ) ( Math . Log10 ( N ) ) ) + Math . Floor ( ( double ) N / 10 ) ) ; return ( rightRotation % N == 0 ) ; } static void generateNumbers ( int m ) { for ( int i = ( int ) Math . Pow ( 10 , ( m - 1 ) ) ; i < Math . Pow ( 10 , m ) ; i ++ ) if ( rightRotationDivisor ( i ) ) Console . WriteLine ( i ) ; } public static void Main ( ) { int m = 3 ; generateNumbers ( m ) ; } }
using System ; class GFG { static void checkIfSortRotated ( int [ ] arr , int n ) { int minEle = int . MaxValue ; int maxEle = int . MinValue ; int minIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } bool flag1 = true ; for ( int i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = false ; break ; } } bool flag2 = true ; for ( int i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = false ; break ; } } if ( flag1 && flag2 && ( arr [ n - 1 ] < arr [ 0 ] ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } public static void Main ( ) { int [ ] arr = { 3 , 4 , 5 , 1 , 2 } ; int n = arr . Length ; checkIfSortRotated ( arr , n ) ; } }
using System ; class GFG { static void occurredOnce ( int [ ] arr , int n ) { Array . Sort ( arr ) ; if ( arr [ 0 ] != arr [ 1 ] ) Console . Write ( arr [ 0 ] + " ▁ " ) ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) Console . Write ( arr [ i ] + " ▁ " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) Console . Write ( arr [ n - 1 ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 } ; int n = arr . Length ; occurredOnce ( arr , n ) ; } }
using System ; class GFG { static void occurredOnce ( int [ ] arr , int n ) { int i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else Console . Write ( arr [ i - 1 ] + " ▁ " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) Console . Write ( arr [ n - 1 ] ) ; } public static void Main ( ) { int [ ] arr = { 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 } ; int n = arr . Length ; occurredOnce ( arr , n ) ; } }
using System ; class GFG { static void rvereseArray ( int [ ] arr , int start , int end ) { while ( start < end ) { int temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } } static void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } static void splitArr ( int [ ] arr , int k , int n ) { rvereseArray ( arr , 0 , n - 1 ) ; rvereseArray ( arr , 0 , n - k - 1 ) ; rvereseArray ( arr , n - k , n - 1 ) ; } public static void Main ( ) { int [ ] arr = { 12 , 10 , 5 , 6 , 52 , 36 } ; int n = arr . Length ; int k = 2 ; splitArr ( arr , k , n ) ; printArray ( arr , n ) ; } }
using System ; class GFG { static int countRotationsDivBy8 ( String n ) { int len = n . Length ; int count = 0 ; if ( len == 1 ) { int oneDigit = n [ 0 ] - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; int second = ( n [ 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n [ i ] - '0' ) * 100 + ( n [ i + 1 ] - '0' ) * 10 + ( n [ i + 2 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n [ len - 1 ] - '0' ) * 100 + ( n [ 0 ] - '0' ) * 10 + ( n [ 1 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n [ len - 2 ] - '0' ) * 100 + ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; } public static void Main ( ) { String n = "43262488612" ; Console . Write ( " Rotations : ▁ " + countRotationsDivBy8 ( n ) ) ; } }
using System ; class GFG { static bool isRotation ( long x , long y ) { long x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; } public static void Main ( ) { long x = 122 ; long y = 2147483678L ; if ( isRotation ( x , y ) == false ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } } }
using System ; class GFG { static int countRotations ( String n ) { int len = n . Length ; if ( len == 1 ) { int oneDigit = n [ 0 ] - '0' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } int twoDigit , count = 0 ; for ( int i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n [ i ] - '0' ) * 10 + ( n [ i + 1 ] - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n [ len - 1 ] - '0' ) * 10 + ( n [ 0 ] - '0' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; } public static void Main ( ) { String n = "4834" ; Console . Write ( " Rotations : ▁ " + countRotations ( n ) ) ; } }
using System ; class GFG { static int maxLength ( int [ ] a , int n ) { int sum = 0 , len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } { return n ; } for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { len = Math . Max ( len , Math . Max ( n - i - 1 , i ) ) ; } } return len ; } static public void Main ( ) { int [ ] a = { 1 , 2 , 3 , 2 } ; int n = a . Length ; Console . WriteLine ( maxLength ( a , n ) ) ; } }
using System ; class GFG { static void solve ( long n ) { long [ , ] initial_array = new long [ ( int ) n - 1 , ( int ) n - 1 ] ; long [ , ] final_array = new long [ ( int ) n , ( int ) n ] ; for ( long i = 0 ; i < n - 1 ; ++ i ) initial_array [ 0 , ( int ) i ] = i + 1 ; for ( long i = 1 ; i < n - 1 ; ++ i ) for ( long j = 0 ; j < n - 1 ; ++ j ) initial_array [ ( int ) i , ( int ) j ] = initial_array [ ( int ) i - 1 , ( int ) ( ( int ) j + 1 ) % ( ( int ) n - 1 ) ] ; for ( long i = 0 ; i < n - 1 ; ++ i ) for ( long j = 0 ; j < n - 1 ; ++ j ) final_array [ ( int ) i , ( int ) j ] = initial_array [ ( int ) i , ( int ) j ] ; for ( long i = 0 ; i < n ; ++ i ) final_array [ ( int ) i , ( int ) n - 1 ] = final_array [ ( int ) n - 1 , ( int ) i ] = 0 ; for ( long i = 0 ; i < n ; ++ i ) { long t0 = final_array [ ( int ) i , ( int ) i ] ; long t1 = final_array [ ( int ) i , ( int ) n - 1 ] ; long s = final_array [ ( int ) i , ( int ) i ] ; final_array [ ( int ) i , ( int ) i ] = final_array [ ( int ) i , ( int ) n - 1 ] ; final_array [ ( int ) i , ( int ) n - 1 ] = s ; final_array [ ( int ) n - 1 , ( int ) i ] = t0 ; } for ( long i = 0 ; i < n ; ++ i ) { for ( long j = 0 ; j < n ; ++ j ) Console . Write ( final_array [ ( int ) i , ( int ) j ] + " ▁ " ) ; Console . WriteLine ( ) ; } } public static void Main ( String [ ] args ) { long n = 5 ; solve ( n ) ; } }
using System ; class GFG { static int getMinVal ( int p , int q ) { if ( q % p == 0 ) return p ; return - 1 ; } public static void Main ( ) { int p = 24 , q = 48 ; Console . WriteLine ( getMinVal ( p , q ) ) ; } }
using System ; class GfG { static bool isPalindrome ( string str , int i , int j ) { while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; } static int countPrimePalindrome ( string str , int len ) { bool [ ] prime = new bool [ len + 1 ] ; Array . Fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= len ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i <= len ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int j = 2 ; j <= len ; j ++ ) { if ( prime [ j ] ) { for ( int i = 0 ; i + j - 1 < len ; i ++ ) { if ( isPalindrome ( str , i , i + j - 1 ) ) count ++ ; } } } return count ; } public static void Main ( ) { string s = " geeksforgeeks " ; int len = s . Length ; Console . WriteLine ( countPrimePalindrome ( s , len ) ) ; } }
using System ; class GFG { static int minOperations ( int N ) { double x = Math . Log ( N , 2 ) ; int ans = ( int ) ( Math . Ceiling ( x ) ) ; return ans ; } static void Main ( ) { int N = 10 ; Console . WriteLine ( minOperations ( N ) ) ; } }
using System ; class GFG { static int find_greatest_divisor ( int l , int r ) { if ( l == r ) { return l ; } return 1 ; } public static void Main ( ) { int l = 2 , r = 12 ; Console . WriteLine ( find_greatest_divisor ( l , r ) ) ; } }
using System ; class GFG { static double getProbability ( double p , double q ) { p /= 100 ; q /= 100 ; double probability = ( p * p + q * q ) / ( p + q ) ; return probability ; } public static void Main ( ) { double p , q ; p = 80 ; q = 40 ; Console . WriteLine ( getProbability ( p , q ) ) ; } }
using System ; class GFG { static bool check ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) { return true ; } } return false ; } public static void Main ( ) { int [ ] arr = { 3 , 9 , 12 , 13 , 15 } ; int n = arr . Length ; if ( check ( arr , n ) ) { Console . WriteLine ( " Odd ▁ Bit - wise ▁ OR " ) ; } else { Console . WriteLine ( " Even ▁ Bit - wise ▁ OR " ) ; } } }
using System ; public class GFG { static int _log ( double x , double baset ) { return ( int ) ( Math . Log ( x ) / Math . Log ( baset ) ) ; } static double recursiveLogStar ( double n , double b ) { if ( n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) ; else return 0 ; } static public void Main ( ) { int n = 100 , baset = 5 ; Console . WriteLine ( " Log * ( " + n + " ) ▁ = ▁ " + recursiveLogStar ( n , baset ) ) ; } }
using System ; class GFG { static bool isPossible ( int [ ] box , int [ ] truck , int n , int m , int min_time ) { int temp = 0 ; int count = 0 ; while ( count < m ) { for ( int j = 0 ; j < min_time && temp < n && truck [ count ] >= box [ temp ] ; j += 2 ) temp ++ ; count ++ ; } if ( temp == n ) return true ; return false ; } static int minTime ( int [ ] box , int [ ] truck , int n , int m ) { Array . Sort ( box ) ; Array . Sort ( truck ) ; int l = 0 ; int h = 2 * n ; int min_time = 0 ; while ( l <= h ) { int mid = ( l + h ) / 2 ; if ( isPossible ( box , truck , n , m , mid ) ) { min_time = mid ; h = mid - 1 ; } else l = mid + 1 ; } return min_time ; } public static void Main ( String [ ] args ) { int [ ] box = { 10 , 2 , 16 , 19 } ; int [ ] truck = { 29 , 25 } ; int n = box . Length ; int m = truck . Length ; Console . WriteLine ( " { 0 } " , minTime ( box , truck , n , m ) ) ; } }
using System ; class GFG { static bool isPossible ( int [ ] arr , int n , int dist , int k ) { int req = 0 ; int curr = 0 ; int prev = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) { curr ++ ; } req ++ ; if ( curr == n ) { break ; } prev = curr - 1 ; } if ( curr != n ) { return false ; } if ( req <= k ) { return true ; } return false ; } static int minDistance ( int [ ] arr , int n , int k ) { int l = 0 ; int h = arr [ n - 1 ] ; int ans = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( isPossible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else { l = m + 1 ; } } return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 15 , 36 , 43 } ; int n = arr . Length ; int k = 2 ; Console . WriteLine ( minDistance ( arr , n , k ) ) ; } }
using System ; class GFG { static int getKthElement ( int n , int k , int [ ] L , int [ ] R ) { int l = 1 ; int h = n ; int [ ] total = new int [ n + 1 ] ; total [ 0 ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 ; } int index = - 1 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( total [ m ] > k ) { index = m ; h = m - 1 ; } else if ( total [ m ] < k ) l = m + 1 ; else { index = m ; break ; } } l = L [ index - 1 ] ; h = R [ index - 1 ] ; int x = k - total [ index - 1 ] ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( m - L [ index - 1 ] ) + 1 == x ) { return m ; } else if ( ( m - L [ index - 1 ] ) + 1 > x ) h = m - 1 ; else l = m + 1 ; } return k ; } public static void Main ( ) { int [ ] L = { 1 , 8 , 21 } ; int [ ] R = { 4 , 10 , 23 } ; int n = L . Length ; int k = 6 ; Console . WriteLine ( getKthElement ( n , k , L , R ) ) ; } }
using System ; class GFG { static int MinimumX ( int a , int b , int c , int k ) { int x = int . MaxValue ; if ( k <= c ) return 0 ; int h = k - c ; int l = 0 ; while ( l <= h ) { int m = ( l + h ) / 2 ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . Min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; } public static void Main ( ) { int a = 3 , b = 2 , c = 4 , k = 15 ; Console . Write ( MinimumX ( a , b , c , k ) ) ; } }
using System ; class GFG { static void IfExists ( int [ ] arr , int n ) { int [ ] sum = new int [ n ] ; Array . Sort ( arr ) ; sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ i ] ; int max = arr [ n - 1 ] ; bool flag = false ; for ( int i = 1 ; i <= max ; i ++ ) { int findex = 0 ; int lindex = 0 ; int l = 0 ; int r = n - 1 ; while ( l <= r ) { int m = ( l + r ) / 2 ; if ( arr [ m ] < i ) { findex = m ; l = m + 1 ; } else r = m - 1 ; } l = 1 ; r = n ; flag = false ; while ( l <= r ) { int m = ( r + l ) / 2 ; if ( arr [ m ] > i ) { lindex = m ; r = m - 1 ; } else l = m + 1 ; } if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) { flag = true ; break ; } } if ( flag ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 2 , 5 } ; int n = arr . Length ; IfExists ( arr , n ) ; } }
using System ; class GFG { public static int findMissing ( int [ ] arr , int n ) { int l = 0 , h = n - 1 ; int mid ; while ( h > l ) { mid = l + ( h - l ) / 2 ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; } public static void Main ( ) { int [ ] arr = { - 9 , - 8 , - 7 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 } ; int n = arr . Length ; Console . WriteLine ( findMissing ( arr , n ) ) ; } }
using System ; class GFG { static int maxSum ( int [ ] arr , int n , int K ) { int maximum = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { int sumk = 0 ; for ( int j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . Max ( maximum , sumk ) ; } return maximum ; } public static void Main ( ) { int [ ] arr = { 3 , 6 , 4 , 7 , 2 } ; int n = arr . Length ; int K = 2 ; Console . WriteLine ( maxSum ( arr , n , K ) ) ; } }
using System ; class GFG { static int countGreater ( int [ ] arr , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; } public static void Main ( ) { int [ ] arr = { 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 } ; int n = arr . Length ; int k = 7 ; Console . WriteLine ( countGreater ( arr , n , k ) ) ; } }
using System ; class GFG { static int operations ( int [ ] op , int n , int k ) { int i , count = 0 ; int nVal = 0 ; int min = int . MaxValue ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; min = Math . Min ( min , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return - 1 ; int times = ( k - Math . Abs ( min ) ) / Math . Abs ( nVal ) ; k = ( k - ( times * Math . Abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; } static void Main ( ) { int [ ] op = { - 60 , 65 , - 1 , 14 , - 25 } ; int n = op . Length ; int k = 100000 ; Console . WriteLine ( operations ( op , n , k ) ) ; } }
class GFG { static int countFactor ( int P , int X ) { if ( X < P ) return 0 ; return ( X / P + countFactor ( P , X / P ) ) ; } static int findSmallestX ( int Y ) { int low = 0 , high = 5 * Y ; int N = 0 ; while ( low <= high ) { int mid = ( high + low ) / 2 ; if ( countFactor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; } static void Main ( ) { int Y = 10 ; System . Console . WriteLine ( findSmallestX ( Y ) ) ; } }
using System ; class GFG { static long squareSum ( long N ) { long sum = ( long ) ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ; return sum ; } static long findMaxN ( long X ) { long low = 1 , high = 100000 ; int N = 0 ; while ( low <= high ) { long mid = ( high + low ) / 2 ; if ( squareSum ( mid ) <= X ) { N = ( int ) mid ; low = mid + 1 ; } else high = mid - 1 ; } return N ; } static public void Main ( ) { long X = 25 ; Console . WriteLine ( findMaxN ( X ) ) ; } }
using System ; class GFG { static int n = 4 ; static int findRing ( int [ , ] arr , int x ) { if ( arr [ 0 , 0 ] > x ) return - 1 ; int l = 0 , r = ( n + 1 ) / 2 - 1 ; if ( n % 2 == 1 && arr [ r , r ] < x ) return - 1 ; if ( n % 2 == 0 && arr [ r + 1 , r ] < x ) return - 1 ; while ( l < r ) { int mid = ( l + r ) / 2 ; if ( arr [ mid , mid ] <= x ) if ( mid == ( n + 1 ) / 2 - 1 arr [ mid + 1 , mid + 1 ] > x ) return mid ; else l = mid + 1 ; else r = mid - 1 ; } return r ; } static int binarySearchRowInc ( int [ , ] arr , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row , mid ] == x ) return mid ; if ( arr [ row , mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; } static int binarySearchColumnInc ( int [ , ] arr , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid , col ] == x ) return mid ; if ( arr [ mid , col ] < x ) t = mid + 1 ; else b = mid - 1 ; } return - 1 ; } static int binarySearchRowDec ( int [ , ] arr , int row , int l , int r , int x ) { while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( arr [ row , mid ] == x ) return mid ; if ( arr [ row , mid ] < x ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } static int binarySearchColumnDec ( int [ , ] arr , int col , int t , int b , int x ) { while ( t <= b ) { int mid = ( t + b ) / 2 ; if ( arr [ mid , col ] == x ) return mid ; if ( arr [ mid , col ] < x ) b = mid - 1 ; else t = mid + 1 ; } return - 1 ; } static void spiralBinary ( int [ , ] arr , int x ) { int f1 = findRing ( arr , x ) ; int r , c ; if ( f1 == - 1 ) { Console . Write ( " - 1" ) ; return ; } if ( n % 2 == 1 && f1 == ( n + 1 ) / 2 - 1 ) { Console . WriteLine ( f1 + " ▁ " + f1 ) ; return ; } if ( x < arr [ f1 , n - f1 - 1 ] ) { c = binarySearchRowInc ( arr , f1 , f1 , n - f1 - 2 , x ) ; r = f1 ; } else if ( x < arr [ n - f1 - 1 , n - f1 - 1 ] ) { c = n - f1 - 1 ; r = binarySearchColumnInc ( arr , n - f1 - 1 , f1 , n - f1 - 2 , x ) ; } else if ( x < arr [ n - f1 - 1 , f1 ] ) { c = binarySearchRowDec ( arr , n - f1 - 1 , f1 + 1 , n - f1 - 1 , x ) ; r = n - f1 - 1 ; } else { r = binarySearchColumnDec ( arr , f1 , f1 + 1 , n - f1 - 1 , x ) ; c = f1 ; } if ( c == - 1 r == - 1 ) Console . Write ( " - 1" ) ; else Console . Write ( r + " ▁ " + c ) ; return ; } public static void Main ( String [ ] args ) { int [ , ] arr = { { 1 , 2 , 3 , 4 } , { 12 , 13 , 14 , 5 } , { 11 , 16 , 15 , 6 } , { 10 , 9 , 8 , 7 } } ; spiralBinary ( arr , 7 ) ; } }
using System ; class GFG { static int countSubArrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int bitwise_or = 0 ; for ( int k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; } public static void Main ( ) { int [ ] arr = { 3 , 4 , 5 } ; int n = arr . Length ; int k = 6 ; Console . WriteLine ( countSubArrays ( arr , n , k ) ) ; } }
using System ; class GFG { static int countPattern ( int n , string pat ) { int pattern_int = 0 ; int power_two = 1 ; int all_ones = 0 ; for ( int i = pat . Length - 1 ; i >= 0 ; i -- ) { int current_bit = pat [ i ] - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n != 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; } public static void Main ( ) { int n = 500 ; string pat = "10" ; Console . WriteLine ( countPattern ( n , pat ) ) ; } }
using System ; class GFG { static int max_min ( int [ ] a , int n ) { Array . Sort ( a ) ; return Math . Min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; } public static void Main ( ) { int [ ] a = { 1 , 3 , 3 , 7 } ; int n = a . Length ; Console . WriteLine ( max_min ( a , n ) ) ; } }
using System ; public class GFG { static int MAX = 1000001 ; static int [ ] primeUpto = new int [ MAX ] ; static void SieveOfEratosthenes ( ) { int [ ] isPrime = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = 1 ; isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] == 1 ) { for ( int j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] == 1 ) primeUpto [ i ] ++ ; } } static int countOfNumbers ( int N , int K ) { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } ans = ans != 0 ? N - ans + 1 : 0 ; return ans ; } public static void Main ( ) { int N = 10 , K = 3 ; Console . WriteLine ( countOfNumbers ( N , K ) ) ; } }
using System ; class GFG { static int minIndex ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , - 5 , 3 , 4 } ; int n = arr . Length ; Console . Write ( minIndex ( arr , n ) ) ; } }
using System ; class GFG { static int N = 4 ; static int M = 4 ; static void printIntersection ( int [ , ] A , int [ , ] B ) { for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( A [ i , j ] == B [ i , j ] ) Console . Write ( A [ i , j ] + " ▁ " ) ; else Console . Write ( " * ▁ " ) ; } Console . WriteLine ( " ▁ " ) ; } } public static void Main ( ) { int [ , ] A = { { 2 , 4 , 6 , 8 } , { 1 , 3 , 5 , 7 } , { 8 , 6 , 4 , 2 } , { 7 , 5 , 3 , 1 } } ; int [ , ] B = { { 2 , 3 , 6 , 8 } , { 1 , 3 , 5 , 2 } , { 8 , 1 , 4 , 2 } , { 3 , 5 , 4 , 1 } } ; printIntersection ( A , B ) ; } }
using System ; class GFG { static int countWays ( int [ ] arr , int n ) { int max_val = 0 ; for ( int i = 0 ; i < n ; i ++ ) max_val = Math . Max ( max_val , arr [ i ] ) ; int [ ] freq = new int [ max_val + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ; for ( int i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ; for ( int i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ; for ( int i = 1 ; i <= max_val ; i ++ ) { for ( int j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . Length ; Console . WriteLine ( countWays ( arr , n ) ) ; } }
using System ; class GFG { static int LongestSubarray ( int [ ] arr , int n , int k ) { int count = 1 ; int max_length = 1 ; int prev_mod = arr [ 0 ] % k ; for ( int i = 1 ; i < n ; i ++ ) { int curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . Max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . Max ( max_length , count ) ; } public static void Main ( ) { int [ ] arr = { 4 , 9 , 7 , 18 , 29 , 11 } ; int n = arr . Length ; int k = 11 ; Console . Write ( LongestSubarray ( arr , n , k ) ) ; } }
using System ; class GFG { static int M = 3 ; static int N = 4 ; static bool binarySearch1D ( int [ ] arr , int K ) { int low = 0 ; int high = N - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( arr [ mid ] == K ) { return true ; } if ( arr [ mid ] < K ) { low = mid + 1 ; } else { high = mid - 1 ; } } return false ; } static bool searchMatrix ( int [ , ] matrix , int K ) { int low = 0 ; int high = M - 1 ; while ( low <= high ) { int mid = low + ( high - low ) / 2 ; if ( K >= matrix [ mid , 0 ] && K <= matrix [ mid , N - 1 ] ) { return binarySearch1D ( GetRow ( matrix , mid ) , K ) ; } if ( K < matrix [ mid , 0 ] ) { high = mid - 1 ; } else { low = mid + 1 ; } } return false ; } public static int [ ] GetRow ( int [ , ] matrix , int row ) { var rowLength = matrix . GetLength ( 1 ) ; var rowVector = new int [ rowLength ] ; for ( var i = 0 ; i < rowLength ; i ++ ) rowVector [ i ] = matrix [ row , i ] ; return rowVector ; } public static void Main ( String [ ] args ) { int [ , ] matrix = { { 1 , 3 , 5 , 7 } , { 10 , 11 , 16 , 20 } , { 23 , 30 , 34 , 50 } } ; int K = 3 ; if ( searchMatrix ( matrix , K ) ) { Console . WriteLine ( " Found " ) ; } else { Console . WriteLine ( " Not ▁ found " ) ; } } }
using System ; class GFG { public static int numberOfElements ( int [ ] height , int n ) { int max_so_far = 0 ; int coun = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; } public static void Main ( ) { int n = 6 ; int [ ] height = { 4 , 8 , 2 , 0 , 0 , 5 } ; Console . WriteLine ( numberOfElements ( height , n ) ) ; } }
using System ; class GFG { static void solve ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; if ( k == 1 && arr [ n - 2 ] != arr [ n - 1 ] ) { Console . WriteLine ( arr [ n - 1 ] ) ; return ; } int count = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) count ++ ; else count = 1 ; if ( count == k && ( i == 0 || ( arr [ i - 1 ] != arr [ i ] ) ) ) { Console . WriteLine ( arr [ i ] ) ; return ; } } Console . WriteLine ( " No ▁ such ▁ element " ) ; } static public void Main ( ) { int [ ] arr = { 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 } ; int k = 2 ; int n = arr . Length ; solve ( arr , n , k ) ; } }
using System ; class GFG { static int getMin ( int [ ] arr , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . Min ( res , arr [ i ] ) ; return res ; } static int getMax ( int [ ] arr , int n ) { int res = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) res = Math . Max ( res , arr [ i ] ) ; return res ; } static int findSum ( int [ ] arr , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min + max ; } static int findProduct ( int [ ] arr , int n ) { int min = getMin ( arr , n ) ; int max = getMax ( arr , n ) ; return min * max ; } public static void Main ( ) { int [ ] arr = { 12 , 1234 , 45 , 67 , 1 } ; int n = arr . Length ; Console . WriteLine ( " Sum ▁ = ▁ " + findSum ( arr , n ) ) ; Console . WriteLine ( " Product ▁ = ▁ " + findProduct ( arr , n ) ) ; } }
using System ; class GFG { static int countChar ( String str ) { int n = str . Length ; if ( n <= 2 ) return n ; int count = 2 ; for ( int i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; } public static void Main ( ) { String str = " egeeksk " ; Console . WriteLine ( countChar ( str ) ) ; } }
using System ; class GfG { private static int next ( int [ ] arr , int target ) { int start = 0 , end = arr . Length - 1 ; if ( end == 0 ) return - 1 ; if ( target > arr [ end ] ) return end ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] >= target ) { end = mid - 1 ; } else { ans = mid ; start = mid + 1 ; } } return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 5 , 8 , 12 } ; Console . WriteLine ( next ( arr , 5 ) ) ; } }
using System ; class GfG { private static int next ( int [ ] arr , int target ) { int start = 0 , end = arr . Length - 1 ; int ans = - 1 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 5 , 8 , 12 } ; Console . WriteLine ( next ( arr , 8 ) ) ; } }
using System ; class GFG { static bool search ( int [ ] arr , int n , int x ) { int res = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; int temp = arr [ res ] ; for ( int i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; } public static void Main ( ) { int [ ] arr = { 12 , 25 , 36 , 85 , 98 , 75 , 89 , 15 , 63 , 66 , 64 , 74 , 27 , 83 , 97 } ; int [ ] q = { 63 , 63 , 86 , 63 , 78 } ; int n = arr . Length ; int m = q . Length ; for ( int i = 0 ; i < m ; i ++ ) { if ( search ( arr , n , q [ i ] ) == true ) Console . Write ( " Yes ▁ " ) ; else Console . Write ( " No ▁ " ) ; } } }
using System ; class GFG { static float kPresentProbability ( int [ ] a , int n , int k ) { float count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count ++ ; return count / n ; } public static void Main ( ) { int [ ] A = { 4 , 7 , 2 , 0 , 8 , 7 , 5 } ; int K = 2 ; int N = A . Length ; double n = kPresentProbability ( A , N , K ) ; double p = ( double ) Math . Round ( n * 100 ) / 100 ; Console . Write ( p ) ; } }
class GFG { static int slopeOfNum ( string num , int n ) { int slope = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ; else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; } return slope ; } public static void Main ( ) { string num = "1213321" ; int n = num . Length ; System . Console . WriteLine ( " Slope ▁ = ▁ " + slopeOfNum ( num , n ) ) ; } }
using System ; class GFG { static void prevGreater ( int [ ] arr , int n ) { Console . Write ( " - 1 , ▁ " ) ; for ( int i = 1 ; i < n ; i ++ ) { int j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { Console . Write ( arr [ j ] + " , ▁ " ) ; break ; } } if ( j == - 1 ) Console . Write ( " - 1 , ▁ " ) ; } } public static void Main ( ) { int [ ] arr = { 10 , 4 , 2 , 20 , 40 , 12 , 30 } ; int n = arr . Length ; prevGreater ( arr , n ) ; } }
using System ; class GFG { static void printDuplicates ( int [ ] arr , int n ) { int i ; int fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { Console . Write ( arr [ i ] % n + " ▁ " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! ( fl > 0 ) ) Console . Write ( " - 1" ) ; } public static void Main ( ) { int [ ] arr = { 1 , 6 , 3 , 1 , 3 , 6 , 6 } ; int arr_size = arr . Length ; printDuplicates ( arr , arr_size ) ; } }
using System ; class GFG { static int findMissingNo ( int [ ] arr , int n ) { int val ; int nextval ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= 0 arr [ i ] > n ) continue ; val = arr [ i ] ; while ( arr [ val - 1 ] != val ) { nextval = arr [ val - 1 ] ; arr [ val - 1 ] = val ; val = nextval ; if ( val <= 0 val > n ) break ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } } return n + 1 ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 7 , 6 , 8 , - 1 , - 10 , 15 } ; int arr_size = arr . Length ; int missing = findMissingNo ( arr , arr_size ) ; Console . Write ( " The ▁ smallest ▁ positive " + " ▁ missing ▁ number ▁ is ▁ " + missing ) ; } }
using System ; class GFG { static void findTriplets ( int [ ] arr , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { Console . WriteLine ( arr [ i ] + " ▁ " + arr [ j ] + " ▁ " + arr [ k ] ) ; } } } } } static public void Main ( ) { int [ ] arr = { 0 , - 1 , 2 , - 3 , 1 } ; int n = arr . Length ; findTriplets ( arr , n , - 2 ) ; } }
using System ; class GFG { static int maxProduct ( int [ ] arr , int n ) { if ( n < 4 ) return - 1 ; int max_product = int . MinValue ; for ( int i = 0 ; i < n - 3 ; i ++ ) for ( int j = i + 1 ; j < n - 2 ; j ++ ) for ( int k = j + 1 ; k < n - 1 ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) max_product = Math . Max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; } public static void Main ( ) { int [ ] arr = { 10 , 3 , 5 , 6 , 20 } ; int n = arr . Length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) Console . WriteLine ( " No ▁ Quadruple ▁ Exists " ) ; else Console . WriteLine ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
using System ; class GFG { static int maxProduct ( int [ ] arr , int n ) { if ( n < 4 ) return - 1 ; Array . Sort ( arr ) ; int x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; int y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; int z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . Max ( x , Math . Max ( y , z ) ) ; } public static void Main ( ) { int [ ] arr = { - 10 , - 3 , 5 , 6 , - 20 } ; int n = arr . Length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) Console . WriteLine ( " No ▁ Quadruple ▁ Exists " ) ; else Console . WriteLine ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
using System ; class GFG { static int maxSum ( int [ ] arr , int n ) { if ( n < 2 ) return - 1 ; int ans = arr [ 0 ] + arr [ 1 ] ; for ( int i = 1 ; i + 1 < n ; i ++ ) ans = Math . Min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 12 , 2 , 2 } ; int n = arr . Length ; Console . WriteLine ( maxSum ( arr , n ) ) ; } }
using System ; class GFG { static int N = 3 ; static int getGreatestSum ( int [ , ] a ) { int prev_max = 0 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 , j ] ) prev_max = a [ N - 1 , j ] ; int sum = prev_max ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int curr_max = - 2147483648 ; for ( int j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i , j ] && a [ i , j ] > curr_max ) curr_max = a [ i , j ] ; if ( curr_max == - 2147483648 ) return - 1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; } public static void Main ( ) { int [ , ] a = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; Console . WriteLine ( getGreatestSum ( a ) ) ; int [ , ] b = { { 4 , 5 , 6 } , { 4 , 5 , 6 } , { 4 , 5 , 6 } } ; Console . WriteLine ( getGreatestSum ( b ) ) ; } }
using System ; class GFG { static void findElement ( int n , int k ) { int ans = n ; int left = 1 ; int right = ( int ) ( Math . Pow ( 2 , n ) - 1 ) ; while ( true ) { int mid = ( left + right ) / 2 ; if ( k == mid ) { Console . WriteLine ( ans ) ; break ; } ans -- ; if ( k < mid ) { right = mid - 1 ; } else { left = mid + 1 ; } } } public static void Main ( ) { int n = 4 , k = 8 ; findElement ( n , k ) ; } }
using System ; class GFG { static int checkBit ( int pattern , int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; } static int maxAND ( int [ ] arr , int n ) { int res = 0 , count ; for ( int bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } if ( res == 0 ) Console . Write ( " Not ▁ Possible " ) ; else { Console . Write ( " Pair ▁ = ▁ " ) ; count = 0 ; for ( int i = 0 ; i < n && count < 2 ; i ++ ) { if ( ( arr [ i ] & res ) == res ) { count ++ ; Console . Write ( arr [ i ] + " ▁ " ) ; } } Console . WriteLine ( ) ; } return res ; } public static void Main ( ) { int [ ] arr = { 4 , 8 , 6 , 2 } ; int n = arr . Length ; Console . WriteLine ( " Maximum ▁ AND ▁ Value ▁ = ▁ " + maxAND ( arr , n ) ) ; } }
using System ; public class GFG { static int countMaxSumPairs ( int [ ] a , int n ) { int first = int . MinValue , second = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } int cnt1 = 0 , cnt2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == first ) cnt1 ++ ; if ( a [ i ] == second ) cnt2 ++ ; } if ( cnt1 == 1 ) return cnt2 ; if ( cnt1 > 1 ) return cnt1 * ( cnt1 - 1 ) / 2 ; return 0 ; } static float findMaxSumProbability ( int [ ] a , int n ) { int total = n * ( n - 1 ) / 2 ; int max_sum_pairs = countMaxSumPairs ( a , n ) ; return ( float ) max_sum_pairs / ( float ) total ; } static public void Main ( ) { int [ ] a = { 1 , 2 , 2 , 3 } ; int n = a . Length ; ; Console . WriteLine ( findMaxSumProbability ( a , n ) ) ; } }
using System ; class GFG { static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; } public static void Main ( ) { int s = 15 ; int n = findS ( s ) ; if ( n == - 1 ) Console . WriteLine ( " - 1" ) ; else Console . WriteLine ( n ) ; } }
using System ; class GFG { static int calcSafe ( int pos ) { int j = pos % 10 ; int i = pos / 10 ; int dis_11 = Math . Min ( Math . Abs ( 1 - i ) , Math . Abs ( 1 - j ) ) ; int dis_18 = Math . Min ( Math . Abs ( 1 - i ) , Math . Abs ( 8 - j ) ) ; int dis_81 = Math . Min ( Math . Abs ( 8 - i ) , Math . Abs ( 1 - j ) ) ; int dis_88 = Math . Min ( Math . Abs ( 8 - i ) , Math . Abs ( 8 - j ) ) ; int sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; } public static void Main ( ) { int pos = 34 ; Console . WriteLine ( " Safe ▁ Positions ▁ = ▁ " + calcSafe ( pos ) ) ; } }
using System ; class GFG { static int getCount ( int [ ] arr , int n , int num1 , int num2 ) { int i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; int j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; } public static void Main ( ) { int [ ] arr = { 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 } ; int n = arr . Length ; int num1 = 5 , num2 = 4 ; Console . WriteLine ( getCount ( arr , n , num1 , num2 ) ) ; } }
using System ; class Test { static int sumOfDigit ( int K ) { int sod = 0 ; while ( K != 0 ) { sod += K % 10 ; K /= 10 ; } return sod ; } static int totalNumbersWithSpecificDifference ( int N , int diff ) { int low = 1 , high = N ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ; else high = mid - 1 ; } return ( N - high ) ; } public static void Main ( ) { int N = 13 ; int diff = 2 ; Console . Write ( totalNumbersWithSpecificDifference ( N , diff ) ) ; } }
using System ; class GFG { static int countBuildings ( int [ ] arr , int n ) { int count = 1 ; int curr_max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; } public static void Main ( ) { int [ ] arr = { 7 , 4 , 8 , 2 , 9 } ; Console . Write ( countBuildings ( arr , arr . Length ) ) ; } }
using System ; class GfG { static int findExtra ( int [ ] arr1 , int [ ] arr2 , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; } public static void Main ( ) { int [ ] arr1 = { 2 , 4 , 6 , 8 , 10 , 12 , 13 } ; int [ ] arr2 = { 2 , 4 , 6 , 8 , 10 , 12 } ; int n = arr2 . Length ; Console . Write ( findExtra ( arr1 , arr2 , n ) ) ; } }
using System ; class GFG { static int findExtra ( int [ ] arr1 , int [ ] arr2 , int n ) { int index = n ; int left = 0 , right = n - 1 ; while ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; } public static void Main ( ) { int [ ] arr1 = { 2 , 4 , 6 , 8 , 10 , 12 , 13 } ; int [ ] arr2 = { 2 , 4 , 6 , 8 , 10 , 12 } ; int n = arr2 . Length ; Console . Write ( findExtra ( arr1 , arr2 , n ) ) ; } }
using System ; class GFG { public static int computeCost ( int [ ] arr , int N , int X ) { int cost = 0 ; for ( int i = 0 ; i < N ; i ++ ) cost += Math . Abs ( arr [ i ] - X ) ; return cost ; } public static int minCostToMakeElementEqual ( int [ ] arr , int N ) { int low , high ; low = high = arr [ 0 ] ; for ( int i = 0 ; i < N ; i ++ ) { if ( low > arr [ i ] ) low = arr [ i ] ; if ( high < arr [ i ] ) high = arr [ i ] ; } while ( ( high - low ) > 2 ) { int mid1 = low + ( high - low ) / 3 ; int mid2 = high - ( high - low ) / 3 ; int cost1 = computeCost ( arr , N , mid1 ) ; int cost2 = computeCost ( arr , N , mid2 ) ; if ( cost1 < cost2 ) high = mid2 ; else low = mid1 ; } return computeCost ( arr , N , ( low + high ) / 2 ) ; } public static void Main ( ) { int [ ] arr = { 1 , 100 , 101 } ; int N = arr . Length ; Console . Write ( minCostToMakeElementEqual ( arr , N ) ) ; } }
using System ; class GFG { static int Next_greater ( int [ ] a , int n , int x ) { Array . Sort ( a ) ; int low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 5 , 10 , 4 , 7 } ; int x = 4 ; int n = a . Length ; Console . WriteLine ( Next_greater ( a , n , x ) ) ; } }
using System ; class GFG { static long mod = 1000000007 ; static int fact ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } static long powmod ( long a , long n ) { if ( n == 0 ) return 1 ; long pt = powmod ( a , n / 2 ) ; pt = ( pt * pt ) % mod ; if ( n % 2 == 1 ) return ( pt * a ) % mod ; else return pt ; } static long CountSubset ( int [ ] arr , int n ) { long ans = powmod ( 2 , n - 1 ) ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; ++ i ) { int j = i + 1 ; while ( j < n && arr [ j ] == arr [ i ] ) { int r = n - 1 - j ; int l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 2 } ; int n = arr . Length ; Console . WriteLine ( CountSubset ( arr , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void reArrange ( String [ ] words , int n ) { Dictionary < String , int > freq = new Dictionary < String , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { freq . Add ( words [ i ] , ( i + 1 ) ) ; } Array . Sort ( words ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( freq [ words [ i ] ] + " ▁ " ) ; } public static void Main ( String [ ] args ) { String [ ] words = { " live " , " place " , " travel " , " word " , " sky " } ; int n = words . Length ; reArrange ( words , n ) ; } }
using System ; class GFG { static int MAX = 100000 ; static int findSumofEle ( int [ ] arr1 , int m , int [ ] arr2 , int n ) { int [ ] hash = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr2 [ i ] ] ++ ; } for ( int i = 1 ; i < MAX ; i ++ ) { hash [ i ] = hash [ i ] + hash [ i - 1 ] ; } int maximumFreq = 0 ; for ( int i = 0 ; i < m ; i ++ ) { maximumFreq = Math . Max ( maximumFreq , hash [ arr1 [ i ] ] ) ; } int sumOfElements = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sumOfElements += ( maximumFreq == hash [ arr1 [ i ] ] ) ? arr1 [ i ] : 0 ; } return sumOfElements ; } public static void Main ( ) { int [ ] arr1 = { 2 , 5 , 6 , 8 } ; int [ ] arr2 = { 4 , 10 } ; int m = arr1 . Length ; int n = arr2 . Length ; Console . WriteLine ( findSumofEle ( arr1 , m , arr2 , n ) ) ; } }
using System . Collections ; using System ; class GfG { static void printNumbers ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int A = arr [ n - 1 ] , B = - 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( A % arr [ i ] != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } Console . WriteLine ( " A ▁ = ▁ " + A + " , ▁ B ▁ = ▁ " + B ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 } ; int n = arr . Length ; printNumbers ( arr , n ) ; } }
using System ; class GFG { static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } static void removeMin ( int [ ] arr , int n ) { int i , minVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minVal = Math . Min ( minVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; } static void removeFromMax ( int [ ] arr , int n ) { int i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = Math . Max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; } static void modifyArray ( int [ ] arr , int n , int k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 8 , 12 , 16 } ; int n = arr . Length ; int k = 2 ; modifyArray ( arr , n , k ) ; } }
using System ; class GFG { static int findAnswer ( int n , int [ ] arr ) { Array . Sort ( arr ) ; int sum = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; } static void Main ( ) { int [ ] arr = { 53 , 28 , 143 , 5 } ; int n = arr . Length ; Console . WriteLine ( findAnswer ( n , arr ) ) ; } }
using System ; class GFG { static int n = 4 ; static void merge ( int l , int r , int [ ] output ) { int l_in = l * n , r_in = ( ( l + r ) / 2 + 1 ) * n ; int l_c = ( ( l + r ) / 2 - l + 1 ) * n ; int r_c = ( r - ( l + r ) / 2 ) * n ; int [ ] l_arr = new int [ l_c ] ; int [ ] r_arr = new int [ r_c ] ; for ( int i = 0 ; i < l_c ; i ++ ) l_arr [ i ] = output [ l_in + i ] ; for ( int i = 0 ; i < r_c ; i ++ ) r_arr [ i ] = output [ r_in + i ] ; int l_curr = 0 , r_curr = 0 ; int index = l_in ; while ( l_curr + r_curr < l_c + r_c ) { if ( r_curr == r_c || ( l_curr != l_c && l_arr [ l_curr ] < r_arr [ r_curr ] ) ) { output [ index ] = l_arr [ l_curr ] ; l_curr ++ ; index ++ ; } else { output [ index ] = r_arr [ r_curr ] ; r_curr ++ ; index ++ ; } } } static void divide ( int l , int r , int [ ] output , int [ , ] arr ) { if ( l == r ) { for ( int i = 0 ; i < n ; i ++ ) output [ l * n + i ] = arr [ l , i ] ; return ; } divide ( l , ( l + r ) / 2 , output , arr ) ; divide ( ( l + r ) / 2 + 1 , r , output , arr ) ; merge ( l , r , output ) ; } public static void Main ( String [ ] args ) { int [ , ] arr = { { 5 , 7 , 15 , 18 } , { 1 , 8 , 9 , 17 } , { 1 , 4 , 7 , 7 } } ; int k = arr . GetLength ( 0 ) ; int [ ] output = new int [ n * k ] ; divide ( 0 , k - 1 , output , arr ) ; for ( int i = 0 ; i < n * k ; i ++ ) Console . Write ( output [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int countDistinct ( int [ ] arr , int n ) { int res = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] == arr [ j ] ) break ; if ( i == j ) res ++ ; } return res ; } public static void Main ( ) { int [ ] arr = { 12 , 10 , 9 , 45 , 2 , 10 , 10 , 45 } ; int n = arr . Length ; Console . WriteLine ( countDistinct ( arr , n ) ) ; } }
using System ; class GFG { static int countDistinct ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; } public static void Main ( ) { int [ ] arr = { 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 } ; int n = arr . Length ; Console . WriteLine ( countDistinct ( arr , n ) ) ; } }
using System ; class GfG { static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } static void printMaxMean ( int [ ] arr , int n ) { int [ ] newArr = new int [ n ] ; Array . Sort ( arr , 0 , 2 * n ) ; for ( int i = 0 ; i < n ; i ++ ) newArr [ i ] = arr [ i + n ] ; printArray ( newArr , n ) ; } public static void Main ( ) { int [ ] arr = { 4 , 8 , 3 , 1 , 3 , 7 , 0 , 4 } ; int n = arr . Length ; printMaxMean ( arr , n / 2 ) ; } }
using System ; public class GFG { static double average ( int [ ] arr , int n , int k ) { double total = 0 ; if ( 2 * k >= n ) return 0 ; Array . Sort ( arr ) ; int start = k , end = n - k - 1 ; for ( int i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 4 , 4 , 5 , 6 } ; int n = arr . Length ; int k = 2 ; Console . WriteLine ( average ( arr , n , k ) ) ; } }
using System ; class GFG { static int min_sum ( int n , int k , int [ ] a ) { Array . Sort ( a ) ; if ( a [ 0 ] < 0 ) return - 1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return - 1 ; } else { int f = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f > 0 ) return - 1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } } public static void Main ( ) { int [ ] arr = new int [ ] { 2 , 3 , 4 , 5 } ; int K = 1 ; int N = arr . Length ; Console . WriteLine ( min_sum ( N , K , arr ) ) ; } }
using System ; class GFG { static int minCost ( int [ ] A , int n ) { int cost = 0 ; Array . Sort ( A ) ; int K = A [ n / 2 ] ; for ( int i = 0 ; i < n ; ++ i ) cost += Math . Abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { int tempCost = 0 ; K = A [ ( n / 2 ) - 1 ] ; for ( int i = 0 ; i < n ; ++ i ) tempCost += Math . Abs ( A [ i ] - K ) ; cost = Math . Min ( cost , tempCost ) ; } return cost ; } public static void Main ( String [ ] args ) { int [ ] A = new int [ ] { 1 , 6 , 7 , 10 } ; int n = A . Length ; Console . WriteLine ( minCost ( A , n ) ) ; } }
using System ; class GFG { static void printArray ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int l = 0 , r = n - 1 , flag = 0 , i ; int k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) Console . Write ( arr [ i ] + " ▁ " ) ; flag = 0 ; r = i ; } k ++ ; } } static public void Main ( ) { int n = 6 ; int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 } ; printArray ( arr , n ) ; } }
using System ; public class GFG { static bool isAlphabaticOrder ( string s ) { int n = s . Length ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; } static public void Main ( ) { string s = " aabbbcc " ; if ( isAlphabaticOrder ( s ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int rotateRec ( int n , int [ ] L , int [ ] B ) { int m = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( Math . Max ( L [ i ] , B [ i ] ) <= m ) m = Math . Max ( L [ i ] , B [ i ] ) ; else if ( Math . Min ( L [ i ] , B [ i ] ) <= m ) m = Math . Min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; } public static void Main ( ) { int n = 3 ; int [ ] L = { 5 , 5 , 6 } ; int [ ] B = { 6 , 7 , 8 } ; if ( rotateRec ( n , L , B ) == 1 ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static void minDistance ( int n , int k , int [ ] [ ] point ) { for ( int i = 0 ; i < k ; i ++ ) Array . Sort ( point [ i ] ) ; for ( int i = 0 ; i < k ; i ++ ) System . Console . Write ( point [ i ] [ ( int ) Math . Ceiling ( ( double ) ( n / 2 ) - 1 ) ] + " ▁ " ) ; } public static void Main ( ) { int n = 4 ; int k = 4 ; int [ ] [ ] point = new int [ ] [ ] { new int [ ] { 1 , 5 , 2 , 4 } , new int [ ] { 6 , 2 , 0 , 6 } , new int [ ] { 9 , 5 , 1 , 3 } , new int [ ] { 6 , 7 , 5 , 9 } } ; minDistance ( n , k , point ) ; } }
using System ; class GFG { static void printOrder ( int [ ] arr , int n , int k ) { int len2 = n - k ; int [ ] arr1 = new int [ k ] ; int [ ] arr2 = new int [ n - k ] ; for ( int i = 0 ; i < k ; i ++ ) arr1 [ i ] = arr [ i ] ; for ( int i = k ; i < n ; i ++ ) arr2 [ i - k ] = arr [ i ] ; Array . Sort ( arr1 , 0 , k ) ; Array . Sort ( arr2 , 0 , n - k ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < k ) arr [ i ] = arr1 [ i ] ; else { arr [ i ] = arr2 [ len2 - 1 ] ; len2 -- ; } } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } } public static void Main ( ) { int [ ] arr = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 } ; int k = 4 ; int n = arr . Length ; printOrder ( arr , n , k ) ; } }
using System ; class GFG { static void findMaxNum ( int [ ] arr , int n ) { int [ ] hash = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( int i = 9 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < hash [ i ] ; j ++ ) Console . Write ( i ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 0 } ; int n = arr . Length ; findMaxNum ( arr , n ) ; } }
using System ; class GFG { static int distribution ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int count = 1 ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . Min ( count , n / 2 ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 2 , 1 , 3 , 4 } ; int n = arr . Length ; Console . WriteLine ( distribution ( arr , n ) ) ; } }
using System ; class GFG { public static void Main ( ) { int [ ] a = { 10 , 12 , 5 } ; Array . Sort ( a ) ; for ( int i = 0 ; i < 3 ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int printTriplets ( int [ ] arr , int n , int sum ) { for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) Console . WriteLine ( arr [ i ] + " , ▁ " + arr [ j ] + " , ▁ " + arr [ k ] ) ; } } return 0 ; } public static void Main ( ) { int [ ] arr = { 5 , 1 , 3 , 4 , 7 } ; int n = arr . Length ; int sum = 12 ; printTriplets ( arr , n , sum ) ; } }
using System ; class GFG { public static int countTriplets ( int [ ] arr , int n , int a , int b ) { int ans = 0 ; for ( int i = 0 ; i < n - 2 ; i ++ ) { for ( int j = i + 1 ; j < n - 1 ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) { ans ++ ; } } } } return ans ; } public static void Main ( ) { int [ ] arr = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = arr . Length ; int a = 8 , b = 16 ; Console . WriteLine ( " " + countTriplets ( arr , n , a , b ) ) ; } }
using System ; class GFG { public static int countTripletsLessThan ( int [ ] arr , int n , int val ) { Array . Sort ( arr ) ; int ans = 0 ; int j , k ; int sum ; for ( int i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += ( k - j ) ; j ++ ; } } } return ans ; } public static int countTriplets ( int [ ] arr , int n , int a , int b ) { int res ; res = countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ; return res ; } public static void Main ( ) { int [ ] arr = { 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 } ; int n = arr . Length ; int a = 8 , b = 16 ; Console . WriteLine ( " " + countTriplets ( arr , n , a , b ) ) ; } }
using System ; class GFG { static int MaxTotalRectangleArea ( int [ ] a , int n ) { Array . Sort ( a ) ; Array . Reverse ( a ) ; int sum = 0 ; bool flag = false ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; } static public void Main ( ) { int [ ] a = { 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 } ; int n = a . Length ; Console . WriteLine ( MaxTotalRectangleArea ( a , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void print ( List < int > a , int n ) { for ( int i = 0 ; i <= n ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } static void sort ( List < int > a , int n ) { for ( int i = n ; i >= 0 ; i -- ) for ( int j = n ; j > n - i ; j -- ) if ( a [ j ] > a [ j - 1 ] ) { int tempswap = a [ j ] ; a [ j ] = a [ j - 1 ] ; a [ j - 1 ] = tempswap ; } print ( a , n ) ; } static void Main ( ) { int n = 6 ; List < int > a = new List < int > ( ) ; a . Add ( 2 ) ; a . Add ( 4 ) ; a . Add ( 3 ) ; a . Add ( 2 ) ; a . Add ( 4 ) ; a . Add ( 5 ) ; a . Add ( 3 ) ; sort ( a , n ) ; } }
using System ; class GFG { static int distancesum ( int [ ] x , int [ ] y , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) sum += ( Math . Abs ( x [ i ] - x [ j ] ) + Math . Abs ( y [ i ] - y [ j ] ) ) ; return sum ; } public static void Main ( ) { int [ ] x = { - 1 , 1 , 3 , 2 } ; int [ ] y = { 5 , 6 , 5 , 3 } ; int n = x . Length ; Console . WriteLine ( distancesum ( x , y , n ) ) ; } }
using System ; class GFG { static int distancesum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int res = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += ( arr [ i ] * i - sum ) ; sum += arr [ i ] ; } return res ; } static int totaldistancesum ( int [ ] x , int [ ] y , int n ) { return distancesum ( x , n ) + distancesum ( y , n ) ; } public static void Main ( ) { int [ ] x = { - 1 , 1 , 3 , 2 } ; int [ ] y = { 5 , 6 , 5 , 3 } ; int n = x . Length ; Console . WriteLine ( totaldistancesum ( x , y , n ) ) ; } }
using System ; class GFG { static void printMedian ( int [ ] arr , int n , int K ) { Array . Sort ( arr ) ; Console . Write ( arr [ ( n + K ) / 2 ] ) ; } public static void Main ( ) { int [ ] arr = { 5 , 3 , 2 , 8 } ; int k = 3 ; int n = arr . Length ; printMedian ( arr , n , k ) ; } }
using System ; class GFG { static void arrange ( int [ ] arr , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { int diff = Math . Abs ( arr [ i ] - x ) ; int j = i - 1 ; if ( Math . Abs ( arr [ j ] - x ) > diff ) { int temp = arr [ i ] ; while ( j >= 0 && Math . Abs ( arr [ j ] - x ) > diff ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } } } static void print ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 10 , 5 , 3 , 9 , 2 } ; int n = arr . Length ; int x = 7 ; arrange ( arr , n , x ) ; print ( arr , n ) ; } }
using System ; class GFG { static void printOrder ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; for ( int j = n - 1 ; j >= n / 2 ; j -- ) Console . Write ( arr [ j ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , - 1 } ; int n = arr . Length ; printOrder ( arr , n ) ; } }
using System ; public class GFG { static int findMinimum ( int [ ] arr , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { res += arr [ i ] ; n = n - k ; } return res ; } static int findMaximum ( int [ ] arr , int n , int k ) { int res = 0 , index = 0 ; for ( int i = n - 1 ; i >= index ; i -- ) { res += arr [ i ] ; index += k ; } return res ; } public static void Main ( ) { int [ ] arr = { 3 , 2 , 1 , 4 } ; int n = arr . Length ; int k = 2 ; Array . Sort ( arr ) ; Console . WriteLine ( findMinimum ( arr , n , k ) + " ▁ " + findMaximum ( arr , n , k ) ) ; } }
using System ; public class GFG { static int maxLevel ( int [ ] boxes , int n ) { Array . Sort ( boxes ) ; int prev_width = boxes [ 0 ] ; int prev_count = 1 ; int curr_count = 0 ; int curr_width = 0 ; for ( int i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; } static public void Main ( ) { int [ ] boxes = { 10 , 20 , 30 , 50 , 60 , 70 } ; int n = boxes . Length ; Console . WriteLine ( maxLevel ( boxes , n ) ) ; } }
using System ; public class GFG { static void twoWaySort ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) != 0 ) arr [ i ] *= - 1 ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 2 , 7 , 5 , 4 } ; twoWaySort ( arr , arr . Length ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } }
using System ; class GFG { static bool isPossibleTriangle ( int [ ] arr , int N ) { if ( N < 3 ) return false ; Array . Sort ( arr ) ; for ( int i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; } static public void Main ( ) { int [ ] arr = { 5 , 4 , 3 , 1 , 2 } ; int N = arr . Length ; if ( isPossibleTriangle ( arr , N ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int MAX = 1000000 ; static int ksmallest ( int [ ] arr , int n , int k ) { int [ ] b = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( int j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return int . MaxValue ; } public static void Main ( ) { int k = 1 ; int [ ] arr = { 1 } ; int n = arr . Length ; Console . WriteLine ( ksmallest ( arr , n , k ) ) ; } }
using System ; class GFG { static void mergeTwoHalf ( int [ ] A , int n ) { Array . Sort ( A ) ; } static public void Main ( ) { int [ ] A = { 2 , 3 , 8 , - 1 , 7 , 10 } ; int n = A . Length ; mergeTwoHalf ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( A [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int minDiff ( int [ ] arr , int n , int k ) { int result = int . MaxValue ; Array . Sort ( arr ) ; for ( int i = 0 ; i <= n - k ; i ++ ) result = Math . Min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; } public static void Main ( ) { int [ ] arr = { 10 , 100 , 300 , 200 , 1000 , 20 , 30 } ; int n = arr . Length ; int k = 3 ; Console . WriteLine ( minDiff ( arr , n , k ) ) ; } }
using System ; class GFG { static int merge ( int [ ] arr , int [ ] temp , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; } static int _mergeSort ( int [ ] arr , int [ ] temp , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; } static int countSwaps ( int [ ] arr , int n ) { int [ ] temp = new int [ n ] ; return _mergeSort ( arr , temp , 0 , n - 1 ) ; } public static void Main ( ) { int [ ] arr = { 1 , 20 , 6 , 4 , 5 } ; int n = arr . Length ; Console . Write ( " Number ▁ of ▁ swaps ▁ is ▁ " + countSwaps ( arr , n ) ) ; } }
using System ; class GFG { public static bool isEven ( int n ) { return ( n % 2 == 0 ) ; } public static void Main ( ) { int n = 101 ; if ( isEven ( n ) == true ) Console . WriteLine ( " Even " ) ; else Console . WriteLine ( " Odd " ) ; } }
using System ; class GFG { static void findSurpasser ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; Console . Write ( count + " ▁ " ) ; } } static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] arr = { 2 , 7 , 5 , 3 , 0 , 8 , 1 } ; int n = arr . Length ; Console . WriteLine ( " Given ▁ array ▁ is ▁ " ) ; printArray ( arr , n ) ; Console . WriteLine ( " Surpasser ▁ Count ▁ of " + " ▁ array ▁ is ▁ " ) ; findSurpasser ( arr , n ) ; } }
using System ; class GFG { static int solve ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int a = 0 , b = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; } public static void Main ( ) { int [ ] arr = { 6 , 8 , 4 , 5 , 2 , 3 } ; int n = arr . Length ; Console . WriteLine ( " Sum ▁ is ▁ " + solve ( arr , n ) ) ; } }
using System ; class GFG { static int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int max_product = int . MinValue ; for ( int i = 0 ; i < n - 2 ; i ++ ) for ( int j = i + 1 ; j < n - 1 ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) max_product = Math . Max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; } public static void Main ( ) { int [ ] arr = { 10 , 3 , 5 , 6 , 20 } ; int n = arr . Length ; ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) Console . WriteLine ( " No ▁ Triplet ▁ Exists " ) ; else Console . WriteLine ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
using System ; class GFG { static int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) return - 1 ; int [ ] leftMin = new int [ n ] ; int [ ] rightMin = new int [ n ] ; int [ ] leftMax = new int [ n ] ; int [ ] rightMax = new int [ n ] ; Array . Fill ( leftMin , - 1 ) ; Array . Fill ( leftMax , - 1 ) ; Array . Fill ( rightMax , - 1 ) ; Array . Fill ( rightMin , - 1 ) ; int max_product = int . MinValue ; int max_sum = arr [ 0 ] ; int min_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { leftMax [ i ] = max_sum ; if ( arr [ i ] > max_sum ) max_sum = arr [ i ] ; leftMin [ i ] = min_sum ; if ( arr [ i ] < min_sum ) min_sum = arr [ i ] ; } max_sum = arr [ n - 1 ] ; min_sum = arr [ n - 1 ] ; for ( int j = n - 2 ; j >= 0 ; j -- ) { rightMax [ j ] = max_sum ; if ( arr [ j ] > max_sum ) max_sum = arr [ j ] ; rightMin [ j ] = min_sum ; if ( arr [ j ] < min_sum ) min_sum = arr [ j ] ; } for ( int i = 1 ; i < n - 1 ; i ++ ) { int max1 = Math . Max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) ; int max2 = Math . Max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) ; max_product = Math . Max ( max_product , Math . Max ( max1 , max2 ) ) ; } return max_product ; } static void Main ( ) { int [ ] arr = { 1 , 4 , 3 , - 6 , - 7 , 0 } ; int n = arr . Length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) Console . WriteLine ( " No ▁ Triplet ▁ Exists " ) ; else Console . WriteLine ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
using System ; public class GFG { static int maxProduct ( int [ ] arr , int n ) { if ( n < 3 ) { return - 1 ; } Array . Sort ( arr ) ; return Math . Max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; } public static void Main ( ) { int [ ] arr = { - 10 , - 3 , 5 , 6 , - 20 } ; int n = arr . Length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) { Console . WriteLine ( " No ▁ Triplet ▁ Exists " ) ; } else { Console . WriteLine ( " Maximum ▁ product ▁ is ▁ " + max ) ; } } }
using System ; class GFG { static int Substring ( String s ) { int ans = 1 , temp = 1 ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . Max ( ans , temp ) ; temp = 1 ; } } ans = Math . Max ( ans , temp ) ; return ans ; } public static void Main ( String [ ] args ) { String s = " abcdddddeff " ; Console . WriteLine ( Substring ( s ) ) ; } }
using System ; class GFG { static void solve ( int n , int k ) { int mini = 0 ; int x1 = 1 ; int [ ] a = new int [ k ] ; for ( int i = 1 ; i <= k ; i ++ ) { mini += x1 ; a [ i - 1 ] = x1 ; x1 += 1 ; } if ( n < mini ) { Console . Write ( " - 1" ) ; return ; } int rem = n - mini ; int cnt = rem / k ; rem = rem % k ; for ( int i = 0 ; i < k ; i ++ ) a [ i ] += cnt ; for ( int i = k - 1 ; i > 0 && rem > 0 ; i -- ) { int xx = a [ i - 1 ] * 2 ; int left = xx - a [ i ] ; if ( rem >= left ) { a [ i ] = xx ; rem -= left ; } else { a [ i ] += rem ; rem = 0 ; } } int sum = a [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) { if ( a [ i ] > 2 * a [ i - 1 ] ) { Console . Write ( " - 1" ) ; return ; } sum += a [ i ] ; } if ( sum != n ) { Console . Write ( " - 1" ) ; return ; } for ( int i = 0 ; i < k ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; } public static void Main ( ) { int n = 26 , k = 6 ; solve ( n , k ) ; } }
using System ; class GFG { static int maxCoins ( int X , int Y ) { if ( X < Y ) { swap ( X , Y ) ; } int coins = X ; X -- ; coins += Math . Max ( X , Y ) ; return coins ; } static void swap ( int X , int Y ) { int temp = X ; X = Y ; Y = temp ; } public static void Main ( String [ ] args ) { int X = 7 , Y = 5 ; Console . WriteLine ( maxCoins ( X , Y ) ) ; } }
using System ; class GFG { static int findElementsCrossed ( int [ ] arr , int a , int b , int n ) { int aa = a ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a == 0 && b == 0 ) break ; else if ( a == 0 ) { if ( arr [ i ] == 1 ) { b -= 1 ; a = Math . Min ( aa , a + 1 ) ; } else b -= 1 ; } else if ( b == 0 ) a -- ; else if ( arr [ i ] == 1 && a < aa ) { b -= 1 ; a = Math . Min ( aa , a + 1 ) ; } else a -- ; ans ++ ; } return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 0 , 1 , 0 , 1 } ; int n = arr . Length ; int a = 1 ; int b = 2 ; Console . WriteLine ( findElementsCrossed ( arr , a , b , n ) ) ; } }
using System ; class GFG { static bool isVowel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; default : return false ; } } static int vowelPairs ( string s , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s [ i ] ) && isVowel ( s [ i + 1 ] ) ) cnt ++ ; } return cnt ; } public static void Main ( ) { string s = " abaebio " ; int n = s . Length ; Console . WriteLine ( vowelPairs ( s , n ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int solve ( int [ ] health , int n ) { int currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ; for ( int i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; } public static void Main ( String [ ] args ) { int [ ] health = { 4 , 6 , 8 , 12 } ; int n = health . Length ; Console . WriteLine ( solve ( health , n ) ) ; } }
using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static void Find_Sequence ( int [ ] arr , int n ) { ArrayList inc_arr = new ArrayList ( ) ; ArrayList dec_arr = new ArrayList ( ) ; int flag = 0 ; long inc = - 1 , dec = ( long ) 1e7 ; for ( int i = 0 ; i < n ; i ++ ) { if ( inc < arr [ i ] && arr [ i ] < dec ) { if ( arr [ i ] < arr [ i + 1 ] ) { inc = arr [ i ] ; inc_arr . Add ( arr [ i ] ) ; } else { dec = arr [ i ] ; dec_arr . Add ( arr [ i ] ) ; } } else if ( inc < arr [ i ] ) { inc = arr [ i ] ; inc_arr . Add ( arr [ i ] ) ; } else if ( dec > arr [ i ] ) { dec = arr [ i ] ; dec_arr . Add ( arr [ i ] ) ; } else { Console . Write ( - 1 ) ; flag = 1 ; break ; } } if ( flag == 0 ) { foreach ( int i in inc_arr ) Console . Write ( i + " ▁ " ) ; Console . Write ( ' STRNEWLINE ' ) ; foreach ( int i in dec_arr ) Console . Write ( i + " ▁ " ) ; Console . Write ( ' STRNEWLINE ' ) ; } } public static void Main ( string [ ] args ) { int [ ] arr = { 5 , 1 , 3 , 6 , 8 , 2 , 9 , 0 , 10 } ; int n = arr . Length ; Find_Sequence ( arr , n ) ; } }
using System ; class GFG { static int reverse ( int n ) { int rev = 0 ; while ( n != 0 ) { rev = ( rev * 10 ) + ( n % 10 ) ; n /= 10 ; } return rev ; } static void getSum ( int n ) { n = reverse ( n ) ; int sumOdd = 0 , sumEven = 0 , c = 1 ; while ( n != 0 ) { if ( c % 2 == 0 ) sumEven += n % 10 ; else sumOdd += n % 10 ; n /= 10 ; c ++ ; } Console . WriteLine ( " Sum ▁ odd ▁ = ▁ " + sumOdd ) ; Console . WriteLine ( " Sum ▁ even ▁ = ▁ " + sumEven ) ; } public static void Main ( ) { int n = 457892 ; getSum ( n ) ; } }
using System ; class GFG { static int bankNotes ( int A , int B , int S , int N ) { int numerator = S - ( B * N ) ; int denominator = A - B ; if ( numerator % denominator == 0 ) return ( numerator / denominator ) ; return - 1 ; } public static void Main ( ) { int A = 1 , B = 2 , S = 7 , N = 5 ; Console . Write ( bankNotes ( A , B , S , N ) ) ; } }
using System ; class GfG { static void twoParts ( string str ) { int flag = 0 ; string a = " " ; char [ ] gfg = str . ToCharArray ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( gfg [ i ] == '4' ) { gfg [ i ] = '3' ; a += '1' ; flag = 1 ; } else if ( flag != 0 ) a += '0' ; } str = new String ( gfg ) ; Console . WriteLine ( str + " ▁ " + a ) ; } static void Main ( ) { string str = "9441" ; twoParts ( str ) ; } }
using System ; class GfG { static int longestSubstring ( string s ) { int cnt = 1 , maxi = 1 ; int n = s . Length ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; else { maxi = Math . Max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . Max ( cnt , maxi ) ; return maxi ; } static void Main ( ) { string s = " ccccdeededff " ; Console . WriteLine ( longestSubstring ( s ) ) ; } }
using System ; class GFG { static int Minimum_Operations ( int [ ] a , int n ) { int [ ] np = new int [ n + 1 ] ; np [ n ] = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } int pos = 0 ; int ans = n ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = Math . Min ( ans , pos + np [ i + 1 ] ) ; } return ans ; } static void Main ( ) { int [ ] a = { - 1 , 0 , 1 , 2 } ; int n = a . Length ; Console . WriteLine ( Minimum_Operations ( a , n ) ) ; } }
using System ; class GFG { static int findSumofEle ( int [ ] arr1 , int m , int [ ] arr2 , int n , int k ) { float arraySum = 0 ; for ( int i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; float mean = arraySum / n ; int sumOfElements = 0 ; float difference = 0 ; for ( int i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( - 1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; } static void Main ( ) { int [ ] arr1 = { 1 , 2 , 3 , 4 , 7 , 9 } ; int [ ] arr2 = { 0 , 1 , 2 , 1 , 1 , 4 } ; int k = 2 ; int m = arr1 . Length ; int n = arr2 . Length ; Console . WriteLine ( findSumofEle ( arr1 , m , arr2 , n , k ) ) ; } }
using System ; using System . Collections ; class GFG { static void findIntegers ( int n , int x , int y ) { ArrayList ans = new ArrayList ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) ans . Add ( 1 ) ; if ( y - ( n - 1 ) <= 0 ) { Console . Write ( " - 1" ) ; return ; } ans . Add ( y - ( n - 1 ) ) ; int store = 0 ; for ( int i = 0 ; i < n ; i ++ ) store += ( int ) ans [ i ] * ( int ) ans [ i ] ; if ( store < x ) { Console . Write ( " - 1" ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ( int ) ans [ i ] + " ▁ " ) ; } static void Main ( ) { int n = 3 , x = 254 , y = 18 ; findIntegers ( n , x , y ) ; } }
using System ; class GFG { static int Minsteps ( int n , int m ) { int ans = 0 ; while ( m > n ) { if ( m % 2 != 0 ) { m ++ ; ans ++ ; } m /= 2 ; ans ++ ; } return ans + n - m ; } public static void Main ( ) { int n = 4 , m = 6 ; Console . WriteLine ( Minsteps ( n , m ) ) ; } }
using System ; class GFG { static int getsum ( int x ) { return ( x * ( x + 1 ) ) / 2 ; } static int countJumps ( int n ) { n = Math . Abs ( n ) ; int ans = 0 ; while ( getsum ( ans ) < n || ( ( getsum ( ans ) - n ) & 1 ) > 0 ) ans ++ ; return ans ; } static void Main ( ) { int n = 9 ; Console . WriteLine ( countJumps ( n ) ) ; } }
using System ; class GFG { static int maxCandies ( int [ ] arr , int n ) { int prevBought = arr [ n - 1 ] ; int candies = prevBought ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int x = Math . Min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 1 , 3 , 6 } ; int n = arr . Length ; Console . WriteLine ( maxCandies ( arr , n ) ) ; } }
using System ; class GFG { static int minChanges ( char [ ] str , int n ) { int count = 0 , zeros = 0 , ones = 0 ; if ( str [ 0 ] != '1' ) { count ++ ; ones ++ ; } for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeros ++ ; else ones ++ ; if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; } public static void Main ( String [ ] args ) { char [ ] str = "0000" . ToCharArray ( ) ; int n = str . Length ; Console . Write ( minChanges ( str , n ) ) ; } }
using System ; class GFG { static int steps ( int cur , int x , int n ) { if ( x == 0 ) return int . MaxValue ; if ( x > 0 ) return Math . Abs ( ( n - cur ) / x ) ; else return Math . Abs ( ( cur - 1 ) / x ) ; } static int countSteps ( int curx , int cury , int n , int m , int [ , ] moves ) { int count = 0 ; int k = moves . GetLength ( 0 ) ; for ( int i = 0 ; i < k ; i ++ ) { int x = moves [ i , 0 ] ; int y = moves [ i , 1 ] ; int stepct = Math . Min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return count ; } public static void Main ( String [ ] args ) { int n = 4 , m = 5 , x = 1 , y = 1 ; int [ , ] moves = { { 1 , 1 } , { 1 , 1 } , { 0 , - 2 } } ; Console . Write ( countSteps ( x , y , n , m , moves ) ) ; } }
using System ; class GFG { static int min_elimination ( int n , int [ ] arr ) { int count = 0 ; int prev_val = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { int curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 2 , 3 , 7 , 9 } ; int n = arr . Length ; Console . WriteLine ( min_elimination ( n , arr ) ) ; } }
using System ; class GFG { static string getCount ( int N ) { if ( N % 2 == 1 ) return "0" ; string result = "9" ; for ( int i = 1 ; i <= N / 2 - 1 ; i ++ ) result += "0" ; return result ; } public static void Main ( ) { int N = 4 ; Console . WriteLine ( getCount ( N ) ) ; } }
using System ; class GFG { static bool canFormTeam ( int n , int m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; } static int maxTeams ( int n , int m ) { int count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; } public static void Main ( ) { int n = 4 , m = 5 ; Console . WriteLine ( maxTeams ( n , m ) ) ; } }
using System ; class GFG { static long max ( long a , long b ) { if ( a > b ) return a ; else return b ; } static long smallestSide ( long [ ] a ) { Array . Sort ( a ) ; long side1 , side2 , side3 , side4 , side11 , side12 , sideOfSquare ; side1 = a [ 0 ] + a [ 3 ] ; side2 = a [ 1 ] + a [ 2 ] ; side3 = a [ 0 ] + a [ 1 ] ; side4 = a [ 2 ] + a [ 3 ] ; side11 = max ( side1 , side2 ) ; side12 = max ( side3 , side4 ) ; sideOfSquare = max ( side11 , side12 ) ; return sideOfSquare ; } public static void Main ( String [ ] args ) { long [ ] side = new long [ 4 ] ; Console . WriteLine ( " Test ▁ Case ▁ 1" ) ; side [ 0 ] = 2 ; side [ 1 ] = 2 ; side [ 2 ] = 2 ; side [ 3 ] = 2 ; Console . WriteLine ( smallestSide ( side ) ) ; Console . WriteLine ( " STRNEWLINE Test ▁ Case ▁ 2" ) ; side [ 0 ] = 100000000000000L ; side [ 1 ] = 123450000000000L ; side [ 2 ] = 987650000000000L ; side [ 3 ] = 987654321000000L ; Console . WriteLine ( smallestSide ( side ) ) ; } }
using System ; class GFG { static void find_rectangle ( int area ) { int l = 0 , b = 0 ; int M = ( int ) Math . Sqrt ( area ) ; for ( int i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = ( area / i ) ; b = i ; break ; } } Console . WriteLine ( " l ▁ = ▁ " + l + " , ▁ b ▁ = ▁ " + b ) ; } public static void Main ( ) { int area = 99 ; find_rectangle ( area ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int sizeSubSet ( int [ ] a , int k , int n ) { Array . Sort ( a ) ; Dictionary < int , int > s = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || ! s . ContainsKey ( a [ i ] / k ) ) { if ( s . ContainsKey ( a [ i ] ) ) { var val = s [ a [ i ] ] ; s . Remove ( a [ i ] ) ; s . Add ( a [ i ] , val + 1 ) ; } else { s . Add ( a [ i ] , 1 ) ; } } } return s . Count ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = a . Length ; int k = 2 ; Console . WriteLine ( sizeSubSet ( a , k , n ) ) ; } }
using System ; class solution { static int minimumSets ( string s , int y ) { int cnt = 0 ; int num = 0 ; int l = s . Length ; bool f = false ; for ( int i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - '0' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s [ i ] - '0' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; } public static void Main ( ) { string s = "1234" ; int y = 30 ; Console . WriteLine ( minimumSets ( s , y ) ) ; } }
using System ; public class GFG { static void printArr ( int [ ] b , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( " ▁ " + b [ i ] + " ▁ " ) ; } } static void ModifiedArray ( int [ ] a , int n ) { int l = 0 , r = int . MaxValue ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n / 2 ; i ++ ) { b [ i ] = Math . Max ( l , a [ i ] - r ) ; b [ n - i - 1 ] = a [ i ] - b [ i ] ; l = b [ i ] ; r = b [ n - i - 1 ] ; } printArr ( b , n ) ; } static public void Main ( ) { int [ ] a = { 5 , 6 } ; int n = a . Length ; ModifiedArray ( a , 2 * n ) ; } }
using System ; class GFG { static int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } static int maxSum ( int [ ] a , int n ) { int S = 0 ; int S1 = maxSubArraySum ( a , n ) ; for ( int i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; } public static void Main ( ) { int [ ] a = { - 35 , 32 , - 24 , 0 , 27 , - 10 , 0 , - 19 } ; int n = a . Length ; Console . WriteLine ( maxSum ( a , n ) ) ; } }
using System ; using System . Linq ; class GFG { static int minimizeDiff ( int [ ] arr , int n , int k ) { int max = arr . Max ( ) ; int min = arr . Min ( ) ; if ( ( max - min ) <= k ) { return ( max - min ) ; } int avg = ( max + min ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > avg ) { arr [ i ] -= k ; } else { arr [ i ] += k ; } } max = arr . Max ( ) ; min = arr . Min ( ) ; return ( max - min ) ; } public static void Main ( ) { int [ ] arr = { 3 , 16 , 12 , 9 , 20 } ; int n = 5 ; int k = 3 ; Console . WriteLine ( " Max ▁ height ▁ difference ▁ = ▁ " + minimizeDiff ( arr , n , k ) ) ; } }
using System ; class GFG { static void maxLitres ( int budget , int plastic , int glass , int refund ) { if ( glass - refund < plastic ) { int ans = Math . Max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += budget / plastic ; Console . WriteLine ( ans ) ; } else { Console . WriteLine ( ( budget / plastic ) ) ; } } public static void Main ( String [ ] args ) { int budget = 10 , plastic = 11 , glass = 9 , refund = 8 ; maxLitres ( budget , plastic , glass , refund ) ; } }
using System ; class GFG { static int leastValue ( int P , int A , int N , int [ ] a ) { int ans = - 1 ; float tmp = float . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { float t = ( float ) ( P - a [ i ] * 0.006 ) ; if ( Math . Abs ( t - A ) < tmp ) { tmp = Math . Abs ( t - A ) ; ans = i ; } } return a [ ans ] ; } public static void Main ( String [ ] args ) { int N = 2 , P = 12 , A = 2005 ; int [ ] a = { 1000 , 2000 } ; Console . WriteLine ( leastValue ( P , A , N , a ) ) ; } }
using System ; class GFG { static int findPermutation ( int n ) { int len = ( int ) Math . Ceiling ( Math . Log10 ( n ) ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return n ; } else { n = ( n / 10 ) + ( n % 10 ) * ( int ) Math . Pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; } public static void Main ( ) { int n = 132 ; Console . WriteLine ( findPermutation ( n ) ) ; } }
using System ; class GFG { static bool isSellingPossible ( int n , int [ ] a ) { int i , c25 = 0 , c50 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 25 ) c25 ++ ; else if ( a [ i ] == 50 ) { c50 ++ ; if ( c25 == 0 ) break ; c25 -- ; } else { if ( c50 > 0 && c25 > 0 ) { c50 -- ; c25 -- ; } else if ( c25 >= 3 ) c25 -= 3 ; else break ; } } if ( i == n ) return true ; else return false ; } public static void Main ( ) { int [ ] a = { 25 , 25 , 50 , 100 } ; int n = a . Length ; if ( isSellingPossible ( n , a ) ) { Console . WriteLine ( " YES " ) ; } else { Console . WriteLine ( " NO " ) ; } } }
using System ; class GFG { static bool checkIfOverlap ( String str ) { int len = str . Length ; int [ ] visited = new int [ len + 1 ] ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' . ' ) continue ; for ( int j = Math . Max ( 0 , i - str [ i ] ) ; j <= Math . Min ( len , i + str [ i ] ) ; j ++ ) visited [ j ] ++ ; } for ( int i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; } public static void Main ( ) { String str = " . 2 . . 2 . " ; if ( checkIfOverlap ( str ) ) Console . Write ( " YES " ) ; else Console . Write ( " NO " ) ; } }
using System ; class GFG { static bool isCorrectOrder ( int n ) { bool flag = true ; int prev = - 1 ; int type = - 1 ; while ( n != 0 ) { if ( type == - 1 ) { if ( prev == - 1 ) { prev = n % 10 ; n = n / 10 ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = n / 10 ; continue ; } prev = n % 10 ; n = n / 10 ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = n / 10 ; } } return flag ; } public static void Main ( ) { int n = 123454321 ; if ( isCorrectOrder ( n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static void printCoins ( int [ ] arr , int n ) { int oddSum = 0 ; for ( int i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; int evenSum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; int start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( int i = start ; i < n ; i += 2 ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr1 = { 8 , 15 , 3 , 7 } ; int n = arr1 . Length ; printCoins ( arr1 , n ) ; Console . Write ( " STRNEWLINE " ) ; int [ ] arr2 = { 2 , 2 , 2 , 2 } ; n = arr2 . Length ; printCoins ( arr2 , n ) ; Console . Write ( " STRNEWLINE " ) ; int [ ] arr3 = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = arr3 . Length ; printCoins ( arr3 , n ) ; } }
class GFG { static void finalPos ( string command , int n , int x , int y ) { int cup , cdown , cleft , cright ; int final_x , final_y ; cup = cdown = cleft = cright = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( command [ i ] == ' U ' ) cup ++ ; else if ( command [ i ] == ' D ' ) cdown ++ ; else if ( command [ i ] == ' L ' ) cleft ++ ; else if ( command [ i ] == ' R ' ) cright ++ ; } final_x = x + ( cright - cleft ) ; final_y = y + ( cdown - cup ) ; System . Console . WriteLine ( " Final ▁ Position : ▁ " + " ( " + final_x + " , ▁ " + final_y + " ) " ) ; } public static void Main ( ) { string command = " DDLRULL " ; int n = command . Length ; int x = 3 , y = 4 ; finalPos ( command , n , x , y ) ; } }
using System ; class GFG { static int smallestSumSubarr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; int sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum_here = Math . Max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . Max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; } public static void Main ( ) { int [ ] arr = { 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 } ; int n = arr . Length ; Console . WriteLine ( " Smallest ▁ sum : ▁ " + smallestSumSubarr ( arr , n ) ) ; } }
using System ; class GFG { static void printLargest ( int [ ] a , int n ) { int max = - 1 ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; while ( num > 0 ) { int r = num % 10 ; num = num / 10 ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( int i = ind ; i < n ; i ++ ) Console . Write ( a [ i ] ) ; for ( int i = 0 ; i < ind ; i ++ ) Console . Write ( a [ i ] ) ; } public static void Main ( ) { int [ ] a = { 54 , 546 , 548 , 60 } ; int n = 4 ; printLargest ( a , n ) ; } }
using System ; public class GFG { static int MinOperation ( int [ ] a , int n , int k ) { int result = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . Min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; } static public void Main ( ) { int [ ] arr = { 4 , 5 , 6 } ; int n = arr . Length ; int k = 5 ; Console . WriteLine ( MinOperation ( arr , n , k ) ) ; } }
using System ; class GFG { static int maxProductSubset ( int [ ] a , int n ) { if ( n == 1 ) { return a [ 0 ] ; } int max_neg = int . MinValue ; int count_neg = 0 , count_zero = 0 ; int prod = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . Max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) { return 0 ; } if ( count_neg % 2 == 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) { return 0 ; } prod = prod / max_neg ; } return prod ; } public static void Main ( ) { int [ ] a = { - 1 , - 1 , - 2 , 4 , 3 } ; int n = a . Length ; Console . Write ( maxProductSubset ( a , n ) ) ; } }
using System ; class GFG { static void digitsNum ( int N ) { if ( N == 0 ) Console . Write ( "0" ) ; if ( N % 9 != 0 ) Console . Write ( ( N % 9 ) ) ; for ( int i = 1 ; i <= ( N / 9 ) ; ++ i ) Console . Write ( "9" ) ; for ( int i = 1 ; i <= N ; ++ i ) Console . Write ( "0" ) ; Console . WriteLine ( " " ) ; } public static void Main ( ) { int N = 5 ; Console . Write ( " The ▁ number ▁ is ▁ : ▁ " ) ; digitsNum ( N ) ; } }
using System ; using System . Collections ; class GFG { static void printVector ( ArrayList v ) { Console . WriteLine ( v . Count ) ; for ( int i = 0 ; i < v . Count ; i ++ ) Console . Write ( v [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } static void findTwoGroup ( int n ) { int sum = n * ( n + 1 ) / 2 ; int group1Sum = sum / 2 ; ArrayList group1 = new ArrayList ( ) ; ArrayList group2 = new ArrayList ( ) ; for ( int i = n ; i > 0 ; i -- ) { if ( group1Sum - i >= 0 ) { group1 . Add ( i ) ; group1Sum -= i ; } else { group2 . Add ( i ) ; } } printVector ( group1 ) ; printVector ( group2 ) ; } public static void Main ( ) { int n = 5 ; findTwoGroup ( n ) ; } }
using System ; class GFG { static int maxDifference ( int [ ] arr , int N , int k ) { int M , S = 0 , S1 = 0 , max_difference = 0 ; for ( int i = 0 ; i < N ; i ++ ) S += arr [ i ] ; int temp ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . Max ( k , N - k ) ; for ( int i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; } public static void Main ( ) { int [ ] arr = { 8 , 4 , 5 , 2 , 10 } ; int N = arr . Length ; int k = 2 ; Console . Write ( maxDifference ( arr , N , k ) ) ; } }
using System ; class GFG { static int minproduct ( int [ ] a , int [ ] b , int n , int k ) { int diff = 0 , res = 0 ; int temp = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; int d = Math . Abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; } public static void Main ( ) { int [ ] a = { 2 , 3 , 4 , 5 , 4 } ; int [ ] b = { 3 , 4 , 2 , 3 , 2 } ; int n = 5 , k = 3 ; Console . WriteLine ( minproduct ( a , b , n , k ) ) ; } }
using System ; class GFG { static int count ( int n ) { if ( n < 4 ) return - 1 ; int rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } return 0 ; } public static void Main ( ) { int n = 90 ; Console . WriteLine ( count ( n ) ) ; n = 143 ; Console . WriteLine ( count ( n ) ) ; } }
using System ; class GFG { static int minRotation ( int input , int unlock_code ) { int rotation = 0 ; int input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . Min ( Math . Abs ( input_digit - code_digit ) , 10 - Math . Abs ( input_digit - code_digit ) ) ; input /= 10 ; unlock_code /= 10 ; } return rotation ; } public static void Main ( ) { int input = 28756 ; int unlock_code = 98234 ; Console . Write ( " Minimum ▁ Rotation ▁ = ▁ " + minRotation ( input , unlock_code ) ) ; } }
using System ; public class GFG { static void preprocess ( int [ ] coin , int n ) { Array . Sort ( coin ) ; for ( int i = 1 ; i <= n - 1 ; i ++ ) coin [ i ] += coin [ i - 1 ] ; } static int minCost ( int [ ] coin , int n , int k ) { int coins_needed = ( int ) Math . Ceiling ( 1.0 * n / ( k + 1 ) ) ; return coin [ coins_needed - 1 ] ; } static public void Main ( ) { int [ ] coin = { 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 } ; int n = coin . Length ; preprocess ( coin , n ) ; int k = 3 ; Console . WriteLine ( minCost ( coin , n , k ) ) ; k = 7 ; Console . WriteLine ( minCost ( coin , n , k ) ) ; } }
using System ; class GFG { static int maximumSum ( int [ ] arr , int n , int k ) { for ( int i = 1 ; i <= k ; i ++ ) { int min = + 2147483647 ; int index = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } public static void Main ( ) { int [ ] arr = { - 2 , 0 , 5 , - 1 , 2 } ; int k = 4 ; int n = arr . Length ; Console . Write ( maximumSum ( arr , n , k ) ) ; } }
using System ; class GFG { static int maxLen = 10 ; static int [ ] dp = new int [ maxLen ] ; static bool [ ] v = new bool [ maxLen ] ; static int maxSum ( int [ ] arr , int i , int n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = true ; dp [ i ] = Math . Max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; } public static void Main ( ) { int [ ] arr = { 12 , 9 , 7 , 33 } ; int n = arr . Length ; Console . Write ( maxSum ( arr , 0 , n ) ) ; } }
using System ; class GFG { static int N = 5 ; static int func ( int idx , int cur , int [ ] a , int [ , ] dp , int n , int x ) { if ( idx == n ) { return 0 ; } if ( dp [ idx , cur ] != - 1 ) { return dp [ idx , cur ] ; } int ans = 0 ; if ( cur == 0 ) { ans = Math . Max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) ; ans = Math . Max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) ; } else if ( cur == 1 ) { ans = Math . Max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) ; ans = Math . Max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) ; } { ans = Math . Max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) ; } return dp [ idx , cur ] = ans ; } static int getMaximumSum ( int [ ] a , int n , int x ) { int [ , ] dp = new int [ n , 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { dp [ i , j ] = - 1 ; } } int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { maxi = Math . Max ( maxi , func ( i , 0 , a , dp , n , x ) ) ; } return maxi ; } public static void Main ( String [ ] args ) { int [ ] a = { - 3 , 8 , - 2 , 1 , - 6 } ; int n = a . Length ; int x = - 1 ; Console . WriteLine ( getMaximumSum ( a , n , x ) ) ; } }
using System ; class GFG { static int N = 100 ; static void pre_process ( bool [ , ] dp , char [ ] s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i , j ] = false ; } } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i , i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i , i + j - 1 ] = dp [ i + 1 , i + j - 2 ] ; } } } } static int countPairs ( String s ) { bool [ , ] dp = new bool [ N , N ] ; pre_process ( dp , s . ToCharArray ( ) ) ; int n = s . Length ; int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; left [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( dp [ j , i ] == true ) { left [ i ] ++ ; } } } right [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] ; for ( int j = n - 1 ; j >= i ; j -- ) { if ( dp [ i , j ] == true ) { right [ i ] ++ ; } } } int ans = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { ans += left [ i ] * right [ i + 1 ] ; } return ans ; } public static void Main ( String [ ] args ) { String s = " abacaba " ; Console . Write ( countPairs ( s ) ) ; } }
using System ; class GFG { static int N = 100 ; static void pre_process ( bool [ , ] dp , char [ ] s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i , j ] = false ; } } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i , i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i , i + j - 1 ] = dp [ i + 1 , i + j - 2 ] ; } } } } static void answerQuery ( int l , int r , bool [ , ] dp ) { if ( dp [ l , r ] ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } public static void Main ( ) { string s = " abaaab " ; bool [ , ] dp = new bool [ N , N ] ; pre_process ( dp , s . ToCharArray ( ) ) ; int [ , ] queries = { { 0 , 1 } , { 1 , 5 } } ; int q = queries . Length ; for ( int i = 0 ; i < q ; i ++ ) { answerQuery ( queries [ i , 0 ] , queries [ i , 1 ] , dp ) ; } } }
using System ; class GFG { static int N = 100005 ; static int LIS ( int [ ] a , int n ) { int [ ] dp = new int [ N ] ; int [ ] d = new int [ N ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( int j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . Max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . Max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . Max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 3 , 4 , 5 , 6 } ; int n = a . Length ; Console . WriteLine ( LIS ( a , n ) ) ; } }
class GFG { static int findSum ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 1 ; dp [ 0 ] = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( 4 * ( i * i ) ) - 6 * ( i - 1 ) + dp [ i - 2 ] ; } return dp [ n ] ; } static void Main ( ) { int n = 4 ; System . Console . WriteLine ( findSum ( n ) ) ; } }
using System ; class GFG { static int n = 3 ; static int MAX = 30 ; static int [ , , ] dp = new int [ n , n , MAX ] ; static bool [ , , ] v = new bool [ n , n , MAX ] ; static int findCount ( int [ , ] mat , int i , int j , int m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 , 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i , j , m ] ) return dp [ i , j , m ] ; v [ i , j , m ] = true ; dp [ i , j , m ] = findCount ( mat , i - 1 , j , m - mat [ i , j ] ) + findCount ( mat , i , j - 1 , m - mat [ i , j ] ) ; return dp [ i , j , m ] ; } public static void Main ( ) { int [ , ] mat = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; int m = 5 ; Console . WriteLine ( findCount ( mat , n - 1 , n - 1 , m ) ) ; } }
using System ; class GFG { static int N = 10 ; static int findMinimumDeletion ( int l , int r , int [ , ] dp , String s ) { if ( l > r ) { return 0 ; } if ( l == r ) { return 1 ; } if ( dp [ l , r ] != - 1 ) { return dp [ l , r ] ; } int res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) ; for ( int i = l + 1 ; i <= r ; ++ i ) { if ( s [ l ] == s [ i ] ) { res = Math . Min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) ; } } return dp [ l , r ] = res ; } public static void Main ( String [ ] args ) { String s = " abcddcba " ; int n = s . Length ; int [ , ] dp = new int [ N , N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i , j ] = - 1 ; } } Console . WriteLine ( findMinimumDeletion ( 0 , n - 1 , dp , s ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static readonly int N = 5005 ; static int n , k ; static List < int > [ ] gr = new List < int > [ N ] ; static int [ , ] d = new int [ N , 505 ] ; static int ans = 0 ; static void Add_edge ( int x , int y ) { gr [ x ] . Add ( y ) ; gr [ y ] . Add ( x ) ; } static void dfs ( int v , int par ) { d [ v , 0 ] = 1 ; foreach ( int i in gr [ v ] ) { if ( i != par ) { dfs ( i , v ) ; for ( int j = 1 ; j <= k ; j ++ ) ans += d [ i , j - 1 ] * d [ v , k - j ] ; for ( int j = 1 ; j <= k ; j ++ ) d [ v , j ] += d [ i , j - 1 ] ; } } } public static void Main ( String [ ] args ) { n = 5 ; k = 2 ; for ( int i = 0 ; i < N ; i ++ ) gr [ i ] = new List < int > ( ) ; Add_edge ( 1 , 2 ) ; Add_edge ( 2 , 3 ) ; Add_edge ( 3 , 4 ) ; Add_edge ( 2 , 5 ) ; dfs ( 1 , 0 ) ; Console . Write ( ans ) ; } }
using System ; class GFG { static int findXorSum ( int [ ] arr , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { int c_odd = 0 ; bool odd = false ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) odd = ( ! odd ) ; if ( odd ) c_odd ++ ; } for ( int j = 0 ; j < n ; j ++ ) { sum += ( mul * c_odd ) ; if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) c_odd = ( n - j - c_odd ) ; } mul *= 2 ; } return sum ; } static void Main ( ) { int [ ] arr = { 3 , 8 , 13 } ; int n = arr . Length ; Console . WriteLine ( findXorSum ( arr , n ) ) ; } }
using System ; class GfG { static bool checkCombinations ( int [ ] a , int n ) { int pow_set_size = ( int ) Math . Pow ( 2 , n ) ; int counter , j ; for ( counter = 0 ; counter < pow_set_size ; counter ++ ) { int sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) else } if ( sum % ( 24 * 60 ) == 0 ) return true ; } return false ; } public static void Main ( ) { int [ ] a = { 60 , 60 , 120 } ; int n = a . Length ; if ( checkCombinations ( a , n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static int n = 4 ; static int m = 4 ; static float calcProbability ( int [ , ] M , int k ) { float [ , ] dp = new float [ m , n ] ; float [ ] sum = new float [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { dp [ 0 , j ] = M [ 0 , j ] ; sum [ 0 ] = sum [ 0 ] + dp [ 0 , j ] ; } for ( int i = 1 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i , j ] += dp [ i - 1 , j ] / sum [ i - 1 ] + M [ i , j ] ; sum [ i ] += dp [ i , j ] ; } } return dp [ n - 1 , k - 1 ] / sum [ n - 1 ] ; } public static void Main ( ) { int [ , ] M = { { 1 , 1 , 0 , 3 } , { 2 , 3 , 2 , 3 } , { 9 , 3 , 0 , 2 } , { 2 , 3 , 2 , 2 } } ; int k = 3 ; Console . Write ( calcProbability ( M , k ) ) ; } }
using System ; class GFG { static int MaximumNumbers ( String s ) { int n = s . Length ; int [ ] remIndex = { - 1 , - 1 , - 1 } ; remIndex [ 0 ] = 0 ; int [ ] res = new int [ n + 1 ] ; int r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { r = ( r + s [ i - 1 ] - '0' ) % 3 ; res [ i ] = res [ i - 1 ] ; if ( remIndex [ r ] != - 1 ) res [ i ] = Math . Max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) ; remIndex [ r ] = i + 1 ; } return res [ n ] ; } public static void Main ( String [ ] args ) { String s = "12345" ; Console . WriteLine ( MaximumNumbers ( s ) ) ; } }
using System ; class GFG { static int max = 4 ; static int c = 2 ; static int countPaths ( int sum , int get , int m , int n , int [ , ] dp ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum , get ] != - 1 ) return dp [ sum , get ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum , get ] = res ; return dp [ sum , get ] ; } public static void Main ( ) { int n = 3 , m = 2 , x = 3 ; int [ , ] dp = new int [ max + 1 , 2 ] ; for ( int i = 0 ; i <= max ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) dp [ i , j ] = - 1 ; Console . WriteLine ( countPaths ( x , 0 , m , n , dp ) ) ; } }
using System ; class GFG { static int MAX_K = 15 ; static int [ ] fac = new int [ MAX_K ] ; static void factorial ( int k ) { fac [ 0 ] = 1 ; for ( int i = 1 ; i <= k + 1 ; i ++ ) { fac [ i ] = ( i * fac [ i - 1 ] ) ; } } static int bin ( int a , int b ) { int ans = ( ( fac [ a ] ) / ( fac [ a - b ] * fac [ b ] ) ) ; return ans ; } static int sumofn ( int n , int k ) { int p = 0 ; int num1 , temp ; int [ ] arr = new int [ 1000 ] ; for ( int j = 1 ; j <= k ; j ++ ) { if ( j == 1 ) { num1 = ( n * ( n + 1 ) ) / 2 ; arr [ p ++ ] = num1 ; temp = num1 ; } else { temp = ( ( int ) Math . Pow ( n + 1 , j + 1 ) - 1 - n ) ; for ( int s = 1 ; s < j ; s ++ ) { temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) ; } temp = temp / ( j + 1 ) ; arr [ p ++ ] = temp ; } } temp = arr [ p - 1 ] ; return temp ; } public static void Main ( ) { int n = 5 , k = 2 ; factorial ( k ) ; Console . WriteLine ( sumofn ( n , k ) ) ; } }
using System ; class solution { static int max = 4 ; static int countWays ( int index , int cnt , int [ , ] dp , int n , int m , int k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index , cnt ] != - 1 ) return dp [ index , cnt ] ; int ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index , cnt ] = ans ; } public static void Main ( ) { int n = 3 , m = 3 , k = 2 ; int [ , ] dp = new int [ n + 1 , max ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) for ( int j = 0 ; j < max ; j ++ ) dp [ i , j ] = - 1 ; Console . WriteLine ( m * countWays ( 1 , 0 , dp , n , m , k ) ) ; } }
using System ; class GFG { static int calculateEvenSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ 2 * n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = 0 ; for ( int i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; } static public void Main ( ) { int n = 8 ; Console . WriteLine ( " Even ▁ indexed ▁ Fibonacci ▁ Sum ▁ upto ▁ " + n + " ▁ terms : ▁ " + calculateEvenSum ( n ) ) ; } }
using System ; class GFG { static int MAX = 32768 ; static int [ ] arr = new int [ 2 * MAX ] ; static void gouldSequence ( ) { arr [ 0 ] = 1 ; int i = 1 ; int p = 1 ; while ( i <= MAX ) { int j = 0 ; while ( j < i ) { arr [ i + j ] = 2 * arr [ j ] ; j ++ ; } i = ( 1 << p ) ; p ++ ; } } static void printSequence ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } } public static void Main ( ) { gouldSequence ( ) ; int n = 16 ; printSequence ( n ) ; } }
using System ; class GFG { static int MatrixChainOrder ( int [ ] p , int n ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 1 ; i < n ; i ++ ) dp [ i , i ] = 0 ; for ( int L = 1 ; L < n - 1 ; L ++ ) for ( int i = 1 ; i < n - L ; i ++ ) dp [ i , i + L ] = Math . Min ( dp [ i + 1 , i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i , i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 , n - 1 ] ; } public static void Main ( ) { int [ ] arr = { 10 , 20 , 30 , 40 , 30 } ; int size = arr . Length ; Console . WriteLine ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " + MatrixChainOrder ( arr , size ) ) ; } }
using System ; class GFG { static int CommomSubsequencesCount ( string s , string t ) { int n1 = s . Length ; int n2 = t . Length ; int [ , ] dp = new int [ n1 + 1 , n2 + 1 ] ; for ( int i = 0 ; i <= n1 ; i ++ ) { for ( int j = 0 ; j <= n2 ; j ++ ) { dp [ i , j ] = 0 ; } } for ( int i = 1 ; i <= n1 ; i ++ ) { for ( int j = 1 ; j <= n2 ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) dp [ i , j ] = 1 + dp [ i , j - 1 ] + dp [ i - 1 , j ] ; else dp [ i , j ] = dp [ i , j - 1 ] + dp [ i - 1 , j ] - dp [ i - 1 , j - 1 ] ; } } return dp [ n1 , n2 ] ; } public static void Main ( ) { string s = " ajblqcpdz " ; string t = " aefcnbtdi " ; Console . Write ( CommomSubsequencesCount ( s , t ) ) ; } }
using System ; class GFG { static int [ ] fib = new int [ 43 ] ; public static void fibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( int i = 2 ; i < 43 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } public static int rec ( int x , int y , int last ) { if ( y == 0 ) { if ( x == 0 ) return 1 ; return 0 ; } int sum = 0 ; for ( int i = last ; i >= 0 && fib [ i ] * y >= x ; i -- ) { if ( fib [ i ] > x ) continue ; sum += rec ( x - fib [ i ] , y - 1 , i ) ; } return sum ; } static void Main ( ) { for ( int i = 0 ; i < 43 ; i ++ ) fib [ i ] = 0 ; fibonacci ( ) ; int n = 13 , k = 3 ; Console . Write ( " Possible ▁ ways ▁ are : ▁ " + rec ( n , k , 42 ) ) ; } }
using System ; class GFG { static int minimumCost ( int [ ] cost , int n ) { int [ ] dp = new int [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . Min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . Min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; } public static void Main ( ) { int [ ] a = { 16 , 19 , 10 , 12 , 18 } ; int n = a . Length ; Console . WriteLine ( minimumCost ( a , n ) ) ; } }
using System ; class GFG { static int minimumCost ( int [ ] cost , int n ) { int dp1 = 0 , dp2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int dp0 = cost [ i ] + Math . Min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . Min ( dp1 , dp2 ) ; } public static void Main ( ) { int [ ] a = { 2 , 5 , 3 , 1 , 7 , 3 , 4 } ; int n = a . Length ; Console . Write ( minimumCost ( a , n ) ) ; } }
using System ; class GFG { static int editDistanceWith2Ops ( String X , String Y ) { int m = X . Length , n = Y . Length ; int [ , ] L = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { L [ i , j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; } else { L [ i , j ] = Math . Max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } } int lcs = L [ m , n ] ; return ( m - lcs ) + ( n - lcs ) ; } public static void Main ( ) { String X = " abc " , Y = " acd " ; Console . Write ( editDistanceWith2Ops ( X , Y ) ) ; } }
using System ; class GFG { static int lcs ( String X , String Y , int m , int n ) { if ( m == 0 n == 0 ) { return 0 ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; } else { return Math . Max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } } public static void Main ( ) { String X = " AGGTAB " ; String Y = " GXTXAYB " ; int m = X . Length ; int n = Y . Length ; Console . Write ( " Length ▁ of ▁ LCS : ▁ " + lcs ( X , Y , m , n ) ) ; } }
using System ; class GFG { static int countPaths ( int n ) { int zB = 1 ; int zADC = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int nzB = zADC * 3 ; int nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( countPaths ( n ) ) ; } }
using System ; class GFG { public static void getMinimumPenalty ( string x , string y , int pxy , int pgap ) { int [ , ] dp = new int [ n + m + 1 , n + m + 1 ] ; for ( int q = 0 ; q < n + m + 1 ; q ++ ) for ( int w = 0 ; w < n + m + 1 ; w ++ ) dp [ q , w ] = 0 ; for ( i = 0 ; i <= ( n + m ) ; i ++ ) { dp [ i , 0 ] = i * pgap ; dp [ 0 , i ] = i * pgap ; } for ( i = 1 ; i <= m ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { dp [ i , j ] = dp [ i - 1 , j - 1 ] ; } else { dp [ i , j ] = Math . Min ( Math . Min ( dp [ i - 1 , j - 1 ] + pxy , dp [ i - 1 , j ] + pgap ) , dp [ i , j - 1 ] + pgap ) ; } } } i = m ; j = n ; int xpos = l ; int ypos = l ; int [ ] xans = new int [ l + 1 ] ; int [ ] yans = new int [ l + 1 ] ; while ( ! ( i == 0 j == 0 ) ) { if ( x [ i - 1 ] == y [ j - 1 ] ) { xans [ xpos -- ] = ( int ) x [ i - 1 ] ; yans [ ypos -- ] = ( int ) y [ j - 1 ] ; i -- ; j -- ; } else if ( dp [ i - 1 , j - 1 ] + pxy == dp [ i , j ] ) { xans [ xpos -- ] = ( int ) x [ i - 1 ] ; yans [ ypos -- ] = ( int ) y [ j - 1 ] ; i -- ; j -- ; } else if ( dp [ i - 1 , j ] + pgap == dp [ i , j ] ) { xans [ xpos -- ] = ( int ) x [ i - 1 ] ; yans [ ypos -- ] = ( int ) ' _ ' ; i -- ; } else if ( dp [ i , j - 1 ] + pgap == dp [ i , j ] ) { xans [ xpos -- ] = ( int ) ' _ ' ; yans [ ypos -- ] = ( int ) y [ j - 1 ] ; j -- ; } } while ( xpos > 0 ) { if ( i > 0 ) xans [ xpos -- ] = ( int ) x [ -- i ] ; else xans [ xpos -- ] = ( int ) ' _ ' ; } while ( ypos > 0 ) { if ( j > 0 ) yans [ ypos -- ] = ( int ) y [ -- j ] ; else yans [ ypos -- ] = ( int ) ' _ ' ; } int id = 1 ; for ( i = l ; i >= 1 ; i -- ) { if ( ( char ) yans [ i ] == ' _ ' && ( char ) xans [ i ] == ' _ ' ) { id = i + 1 ; break ; } } Console . Write ( " Minimum ▁ Penalty ▁ in ▁ aligning ▁ the ▁ genes ▁ = ▁ " + dp [ m , n ] + " STRNEWLINE " ) ; Console . Write ( " The ▁ aligned ▁ genes ▁ are ▁ : STRNEWLINE " ) ; for ( i = id ; i <= l ; i ++ ) { Console . Write ( ( char ) xans [ i ] ) ; } Console . Write ( " STRNEWLINE " ) ; for ( i = id ; i <= l ; i ++ ) { Console . Write ( ( char ) yans [ i ] ) ; } return ; } static void Main ( ) { string gene1 = " AGGGCT " ; string gene2 = " AGGCA " ; int misMatchPenalty = 3 ; int gapPenalty = 2 ; getMinimumPenalty ( gene1 , gene2 , misMatchPenalty , gapPenalty ) ; } }
using System ; class GFG { static int lds ( int [ ] arr , int n ) { int [ ] lds = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; } public static void Main ( ) { int [ ] arr = { 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 } ; int n = arr . Length ; Console . Write ( " Length ▁ of ▁ LDS ▁ is ▁ " + lds ( arr , n ) ) ; } }
using System ; class GFG { static int MAX = 100 ; static void binomialCoeff ( int [ ] C , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } } static int sumOfproduct ( int n ) { int sum = 0 ; int [ ] C = new int [ MAX ] ; binomialCoeff ( C , n ) ; for ( int i = 0 ; i <= n ; i ++ ) sum += C [ i ] * C [ i + 1 ] ; return sum ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( sumOfproduct ( n ) ) ; } }
using System ; class GFG { static int MAX = 100 ; static void binomialCoeff ( int n , int [ ] C ) { for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } } static int summation ( int n ) { int [ ] C = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) C [ i ] = 0 ; binomialCoeff ( n , C ) ; int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( i * C [ i ] ) ; return sum ; } public static void Main ( ) { int n = 2 ; Console . Write ( summation ( n ) ) ; } }
using System ; class GFG { static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int countArray ( int N , int K ) { return binomialCoeff ( K - 1 , N - 1 ) ; } static public void Main ( ) { int N = 2 , K = 3 ; Console . WriteLine ( countArray ( N , K ) ) ; } }
using System ; class GFG { static int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) { int ind ; int val ; int [ , ] dp = new int [ n , maxLimit + 1 ] ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val num + arr [ ind ] == val ) { dp [ ind , val ] = 1 ; } else { dp [ ind , val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { if ( dp [ ind - 1 , val - arr [ ind ] ] == 1 dp [ ind - 1 , val + arr [ ind ] ] == 1 ) dp [ ind , val ] = 1 ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind , val ] = dp [ ind - 1 , val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind , val ] = dp [ ind - 1 , val + arr [ ind ] ] ; } else { dp [ ind , val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 , val ] == 1 ) { return val ; } } return - 1 ; } static void Main ( ) { int num = 1 ; int [ ] arr = new int [ ] { 3 , 10 , 6 , 4 , 5 } ; int n = arr . Length ; int maxLimit = 15 ; Console . Write ( findMaxVal ( arr , n , num , maxLimit ) ) ; } }
using System ; class GFG { public static int gen ( int n ) { if ( n == 0 ) return 0 ; else if ( n == 1 ) return 1 ; else if ( n % 2 == 0 ) return 4 * gen ( n / 2 ) ; else if ( n % 2 == 1 ) return 4 * gen ( n / 2 ) + 1 ; return 0 ; } public static void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( gen ( i ) + " ▁ " ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int n = 15 ; Console . WriteLine ( " First ▁ " + n + " ▁ terms ▁ of ▁ " + " Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ " ) ; moserDeBruijn ( n ) ; } }
using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static int minSumPath ( ref List < List < int > > A ) { int [ ] memo = new int [ A . Count ] ; int n = A . Count - 1 ; for ( int i = 0 ; i < A [ n ] . Count ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( int i = A . Count - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j < A [ i + 1 ] . Count - 1 ; j ++ ) memo [ j ] = A [ i ] [ j ] + ( int ) Math . Min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; } public static void Main ( ) { List < List < int > > A = new List < List < int > > ( ) ; A . Add ( new List < int > { 2 } ) ; A . Add ( new List < int > { 3 , 9 } ) ; A . Add ( new List < int > { 1 , 6 , 7 } ) ; Console . WriteLine ( minSumPath ( ref A ) ) ; } }
using System ; class GFG { static int MAX = 100 ; static int [ , ] dp = new int [ MAX , MAX ] ; static int countRemovals ( int [ ] a , int i , int j , int k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i , j ] = 1 + Math . Min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) ; } return dp [ i , j ] ; } static int removals ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) dp [ i , j ] = - 1 ; } if ( n == 1 ) return 0 ; else return countRemovals ( a , 0 , n - 1 , k ) ; } static void Main ( ) { int [ ] a = new int [ ] { 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 } ; int n = a . Length ; int k = 4 ; Console . Write ( removals ( a , n , k ) ) ; } }
using System ; class GFG { static int countPairs ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( a [ i ] & a [ j ] ) == 0 ) count += 2 ; } return count ; } public static void Main ( ) { int [ ] a = { 3 , 4 , 2 } ; int n = a . Length ; Console . Write ( countPairs ( a , n ) ) ; } }
using System ; class GFG { static long [ , ] dp = new long [ 1000 , 1000 ] ; static long sum ( int [ ] a , int i , int j ) { long ans = 0 ; for ( int m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; } static long solve ( int [ ] a , int i , int j ) { if ( i == j ) return 0 ; if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; dp [ i , j ] = 100000000 ; for ( int k = i ; k < j ; k ++ ) { dp [ i , j ] = Math . Min ( dp [ i , j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; } return dp [ i , j ] ; } static void initialize ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i , j ] = - 1 ; } public static void Main ( ) { int [ ] a = { 40 , 60 , 20 } ; int n = a . Length ; initialize ( n ) ; Console . WriteLine ( solve ( a , 0 , n - 1 ) ) ; } }
using System ; class GFG { static void reverseFibonacci ( int n ) { int [ ] a = new int [ n ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { Console . Write ( a [ i ] + " ▁ " ) ; } } public static void Main ( ) { int n = 5 ; reverseFibonacci ( n ) ; } }
using System ; class GFG { static float find_prob ( int N , float P ) { double [ ] dp = new double [ N + 1 ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( int i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( ( float ) ( dp [ N ] ) ) ; } public static void Main ( ) { int n = 5 ; float p = 0.2f ; Console . WriteLine ( find_prob ( n , p ) ) ; } }
using System ; class GFG { static int N = 5 ; static void printHosoya ( int n ) { int [ , ] dp = new int [ N , N ] ; dp [ 0 , 0 ] = dp [ 1 , 0 ] = 1 ; dp [ 1 , 1 ] = 1 ; for ( int i = 2 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 2 , j ] ; else dp [ i , j ] = dp [ i - 1 , j - 1 ] + dp [ i - 2 , j - 2 ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) Console . Write ( dp [ i , j ] + " ▁ " ) ; Console . WriteLine ( " " ) ; } } public static void Main ( ) { int n = 5 ; printHosoya ( n ) ; } }
using System ; class GFG { static int numberofways ( int n , int m ) { int [ , ] dp = new int [ n + 2 , n + 2 ] ; dp [ 0 , n + 1 ] = 1 ; for ( int k = n ; k >= m ; k -- ) { for ( int i = 0 ; i <= n ; i ++ ) { dp [ i , k ] = dp [ i , k + 1 ] ; if ( i - k >= 0 ) dp [ i , k ] = ( dp [ i , k ] + dp [ i - k , k ] ) ; } } return dp [ n , m ] ; } public static void Main ( ) { int n = 3 , m = 1 ; Console . WriteLine ( numberofways ( n , m ) ) ; } }
using System ; class GFG { static int zigzag ( int n , int k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; } public static void Main ( ) { int n = 4 , k = 3 ; Console . WriteLine ( zigzag ( n , k ) ) ; } }
using System ; class Eulerian { public static int eulerian ( int n , int m ) { int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i , j ] = 1 ; else dp [ i , j ] = ( ( i - j ) * dp [ i - 1 , j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 , j ] ) ; } } } return dp [ n , m ] ; } public static void Main ( ) { int n = 3 , m = 1 ; Console . WriteLine ( eulerian ( n , m ) ) ; } }
using System ; public class GfG { public static int dealnnoy ( int n , int m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; } public static void Main ( ) { int n = 3 , m = 4 ; Console . WriteLine ( dealnnoy ( n , m ) ) ; } }
using System ; class GFG { static int dealnnoy ( int n , int m ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) dp [ i , 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) dp [ 0 , i ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 1 , j - 1 ] + dp [ i , j - 1 ] ; return dp [ m , n ] ; } public static void Main ( ) { int n = 3 , m = 4 ; Console . WriteLine ( dealnnoy ( n , m ) ) ; } }
using System ; class Longest { public static void longestAlternating ( int [ ] arr , int n ) { int [ ] count = new int [ n ] ; count [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( count [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] a = { - 5 , - 1 , - 1 , 2 , - 2 , - 3 } ; int n = 6 ; longestAlternating ( a , n ) ; } }
using System ; class GFG { static int maxDP ( int n ) { int [ ] res = new int [ n + 1 ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res [ i ] = Math . Max ( i , ( res [ i / 2 ] + res [ i / 3 ] + res [ i / 4 ] + res [ i / 5 ] ) ) ; return res [ n ] ; } public static void Main ( ) { int n = 60 ; Console . WriteLine ( " MaxSum ▁ = ▁ " + maxDP ( n ) ) ; } }
using System ; class GFG { static bool isSafe ( int x , int y ) { return ( x < 4 && y < 3 ) ; } static int minJump ( int [ , ] height , int x , int y ) { if ( x == 4 - 1 && y == 3 - 1 ) return 0 ; int diag = int . MaxValue ; if ( isSafe ( x + 1 , y + 1 ) ) diag = minJump ( height , x + 1 , y + 1 ) + Math . Abs ( height [ x , y ] - height [ x + 1 , y + 1 ] ) ; int down = int . MaxValue ; if ( isSafe ( x + 1 , y ) ) down = minJump ( height , x + 1 , y ) + Math . Abs ( height [ x , y ] - height [ x + 1 , y ] ) ; int right = int . MaxValue ; if ( isSafe ( x , y + 1 ) ) right = minJump ( height , x , y + 1 ) + Math . Abs ( height [ x , y ] - height [ x , y + 1 ] ) ; return Math . Min ( down , Math . Min ( right , diag ) ) ; } public static void Main ( ) { int [ , ] height = { { 5 , 4 , 2 } , { 9 , 2 , 1 } , { 2 , 5 , 9 } , { 1 , 3 , 11 } } ; Console . Write ( minJump ( height , 0 , 0 ) ) ; } }
using System ; class GFG { static int maxSum ( int [ ] arr , int N , int k ) { int [ ] MS = new int [ N ] ; MS [ N - 1 ] = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( i + k + 1 >= N ) MS [ i ] = Math . Max ( arr [ i ] , MS [ i + 1 ] ) ; else MS [ i ] = Math . Max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) ; } return MS [ 0 ] ; } public static void Main ( ) { int N = 10 , k = 2 ; int [ ] arr = { 50 , 70 , 40 , 50 , 90 , 70 , 60 , 40 , 70 , 50 } ; Console . WriteLine ( maxSum ( arr , N , k ) ) ; } }
using System ; class GFG { static void alternateSubarray ( bool [ ] arr , int n ) { int [ ] len = new int [ n ] ; len [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == true ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( int i = 0 ; i < n ; ++ i ) Console . Write ( len [ i ] + " ▁ " ) ; } public static void Main ( ) { bool [ ] arr = { true , false , true , false , false , true } ; int n = arr . Length ; alternateSubarray ( arr , n ) ; } }
using System ; public class Test { static void alternateSubarray ( bool [ ] arr , int n ) { int count = 1 ; bool prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { Console . Write ( count -- + " ▁ " ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { Console . Write ( count -- + " ▁ " ) ; } } public static void Main ( ) { bool [ ] arr = { true , false , true , false , false , true } ; int n = arr . Length ; alternateSubarray ( arr , n ) ; } }
using System ; public class GFG { static long countWays ( int n ) { long [ , ] dp = new long [ 2 , n + 1 ] ; dp [ 0 , 1 ] = 1 ; dp [ 1 , 1 ] = 2 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ 0 , i ] = dp [ 0 , i - 1 ] + dp [ 1 , i - 1 ] ; dp [ 1 , i ] = dp [ 0 , i - 1 ] * 2 + dp [ 1 , i - 1 ] ; } return dp [ 0 , n ] + dp [ 1 , n ] ; } public static void Main ( ) { int n = 5 ; Console . Write ( " Total ▁ no ▁ of ▁ ways ▁ with ▁ n ▁ = ▁ " + n + " ▁ are : ▁ " + countWays ( n ) ) ; } }
using System ; class GFG { public static int maxLenSub ( int [ ] arr , int n ) { int [ ] mls = new int [ n ] ; int max = 0 ; for ( int i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( Math . Abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; } public static void Main ( ) { int [ ] arr = { 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 } ; int n = arr . Length ; Console . Write ( " Maximum ▁ length ▁ subsequence ▁ = ▁ " + maxLenSub ( arr , n ) ) ; } }
using System ; public class GFG { static bool findWinner ( int x , int y , int n ) { bool [ ] dp = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) dp [ i ] = false ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && dp [ i - 1 ] == false ) dp [ i ] = true ; else if ( i - x >= 0 && dp [ i - x ] == false ) dp [ i ] = true ; else if ( i - y >= 0 && dp [ i - y ] == false ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; } public static void Main ( ) { int x = 3 , y = 4 , n = 5 ; if ( findWinner ( x , y , n ) == true ) Console . WriteLine ( ' A ' ) ; else Console . WriteLine ( ' B ' ) ; } }
using System ; class GFG { static int maxGameByWinner ( int N ) { int [ ] dp = new int [ N ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; int i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; } public static void Main ( ) { int N = 10 ; Console . Write ( maxGameByWinner ( N ) ) ; } }
using System ; class GFG { static int minRemove ( int [ ] arr , int n ) { int [ ] LIS = new int [ n ] ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . Max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . Max ( len , LIS [ i ] ) ; } return n - len ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 6 , 5 , 4 } ; int n = arr . Length ; Console . WriteLine ( minRemove ( arr , n ) ) ; } }
using System ; public class GFG { static int MAX = 1000 ; static int maxSubsequenceSubstring ( string x , string y , int n , int m ) { int [ , ] dp = new int [ MAX , MAX ] ; for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) dp [ i , j ] = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = dp [ i , j - 1 ] ; } } int ans = 0 ; for ( int i = 1 ; i <= m ; i ++ ) ans = Math . Max ( ans , dp [ i , n ] ) ; return ans ; } public static void Main ( ) { string x = " ABCD " ; string y = " BACDBDCD " ; int n = x . Length , m = y . Length ; Console . WriteLine ( maxSubsequenceSubstring ( x , y , n , m ) ) ; } }
using System ; class GFG { public static int maxSum ( int [ , ] grid , int n ) { int incl = Math . Max ( grid [ 0 , 0 ] , grid [ 1 , 0 ] ) ; int excl = 0 , excl_new ; for ( int i = 1 ; i < n ; i ++ ) { excl_new = Math . Max ( excl , incl ) ; incl = excl + Math . Max ( grid [ 0 , i ] , grid [ 1 , i ] ) ; excl = excl_new ; } return Math . Max ( excl , incl ) ; } public static void Main ( String [ ] args ) { int [ , ] grid = { { 1 , 2 , 3 , 4 , 5 } , { 6 , 7 , 8 , 9 , 10 } } ; int n = 5 ; Console . Write ( maxSum ( grid , n ) ) ; } }
using System ; class GfG { static int minInsertionStepToSortArray ( int [ ] arr , int N ) { int [ ] lis = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; int max = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( max < lis [ i ] ) max = lis [ i ] ; return ( N - max ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 5 , 1 , 4 , 7 , 6 } ; int N = arr . Length ; Console . Write ( minInsertionStepToSortArray ( arr , N ) ) ; } }
using System ; class GFG { static readonly int MAX = 1005 ; static int shortestSeq ( char [ ] S , char [ ] T ) { int m = S . Length , n = T . Length ; int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i , 0 ] = 1 ; } for ( int i = 0 ; i <= n ; i ++ ) { dp [ 0 , i ] = MAX ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { char ch = S [ i - 1 ] ; int k ; for ( k = j - 1 ; k >= 0 ; k -- ) { if ( T [ k ] == ch ) { break ; } } if ( k == - 1 ) { dp [ i , j ] = 1 ; } else { dp [ i , j ] = Math . Min ( dp [ i - 1 , j ] , dp [ i - 1 , k ] + 1 ) ; } } } int ans = dp [ m , n ] ; if ( ans >= MAX ) { ans = - 1 ; } return ans ; } public static void Main ( String [ ] args ) { char [ ] S = " babab " . ToCharArray ( ) ; char [ ] T = " babba " . ToCharArray ( ) ; int m = S . Length , n = T . Length ; Console . WriteLine ( " Length ▁ of ▁ shortest " + " subsequence ▁ is ▁ : ▁ " + shortestSeq ( S , T ) ) ; } }
using System ; class GFG { static void countWaysToJump ( int [ ] arr , int n ) { int [ ] count_jump = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) count_jump [ i ] = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( int j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( count_jump [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 } ; int n = arr . Length ; countWaysToJump ( arr , n ) ; } }
using System ; class GFG { static int minStepToDeleteString ( string str ) { int N = str . Length ; int [ , ] dp = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) for ( int j = 0 ; j <= N ; j ++ ) dp [ i , j ] = 0 ; for ( int len = 1 ; len <= N ; len ++ ) { for ( int i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i , j ] = 1 ; else { dp [ i , j ] = 1 + dp [ i + 1 , j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i , j ] = Math . Min ( 1 + dp [ i + 2 , j ] , dp [ i , j ] ) ; for ( int K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i , j ] = Math . Min ( dp [ i + 1 , K - 1 ] + dp [ K + 1 , j ] , dp [ i , j ] ) ; } } } return dp [ 0 , N - 1 ] ; } public static void Main ( ) { string str = "2553432" ; Console . Write ( minStepToDeleteString ( str ) ) ; } }
using System ; class GFG { static int inf = 1000000000 ; static int ans = inf ; static void solve ( int i , int par , int [ ] a , int n , int k , int current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . Min ( ans , current_ans ) ; return ; } for ( int j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; } public static void Main ( ) { int k = 2 ; int [ ] a = { 1 , 5 , 8 , 10 } ; int n = a . Length ; solve ( - 1 , 0 , a , n , k , 0 ) ; Console . Write ( ans ) ; } }
using System ; class GFG { static int getMinSteps ( int n , int [ ] memo ) { if ( n == 1 ) return 0 ; if ( memo [ n ] != - 1 ) return memo [ n ] ; int res = getMinSteps ( n - 1 , memo ) ; if ( n % 2 == 0 ) res = Math . Min ( res , getMinSteps ( n / 2 , memo ) ) ; if ( n % 3 == 0 ) res = Math . Min ( res , getMinSteps ( n / 3 , memo ) ) ; memo [ n ] = 1 + res ; return memo [ n ] ; } static int getMinSteps ( int n ) { int [ ] memo = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) memo [ i ] = - 1 ; return getMinSteps ( n , memo ) ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( getMinSteps ( n ) ) ; } }
using System ; public class GFG { static int stringReduction ( String str ) { int n = str . Length ; int [ ] count = new int [ 3 ] ; for ( int i = 0 ; i < n ; ++ i ) { count [ str [ i ] - ' a ' ] ++ ; } if ( count [ 0 ] == n count [ 1 ] == n count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; } public static void Main ( ) { String str = " abcbbaacb " ; Console . WriteLine ( stringReduction ( str ) ) ; } }
using System ; public class GFG { static int countSubsequences ( String s ) { int aCount = 0 ; int bCount = 0 ; int cCount = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' a ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' b ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' c ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; } public static void Main ( ) { String s = " abbc " ; Console . Write ( countSubsequences ( s ) ) ; } }
using System ; class GFG { static int maxRevenue ( int m , int [ ] x , int [ ] revenue , int n , int t ) { int [ ] maxRev = new int [ m + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; int nxtbb = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . Max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . Max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; } static void Main ( ) { int m = 20 ; int [ ] x = new int [ ] { 6 , 7 , 12 , 13 , 14 } ; int [ ] revenue = new int [ ] { 5 , 6 , 5 , 3 , 1 } ; int n = x . Length ; int t = 5 ; Console . Write ( maxRevenue ( m , x , revenue , n , t ) ) ; } }
using System ; class GFG { static int Row = 6 , Col = 6 ; static int largestKSubmatrix ( int [ , ] a ) { int [ , ] dp = new int [ Row , Col ] ; int result = 0 ; for ( int i = 0 ; i < Row ; i ++ ) { for ( int j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i , j ] = 1 ; else { if ( a [ i , j ] == a [ i - 1 , j ] && a [ i , j ] == a [ i , j - 1 ] && a [ i , j ] == a [ i - 1 , j - 1 ] ) { dp [ i , j ] = ( dp [ i - 1 , j ] > dp [ i , j - 1 ] && dp [ i - 1 , j ] > dp [ i - 1 , j - 1 ] + 1 ) ? dp [ i - 1 , j ] : ( dp [ i , j - 1 ] > dp [ i - 1 , j ] && dp [ i , j - 1 ] > dp [ i - 1 , j - 1 ] + 1 ) ? dp [ i , j - 1 ] : dp [ i - 1 , j - 1 ] + 1 ; } else dp [ i , j ] = 1 ; } result = result > dp [ i , j ] ? result : dp [ i , j ] ; } } return result ; } public static void Main ( ) { int [ , ] a = { { 2 , 2 , 3 , 3 , 4 , 4 } , { 5 , 5 , 7 , 7 , 7 , 4 } , { 1 , 2 , 7 , 7 , 7 , 4 } , { 4 , 4 , 7 , 7 , 7 , 4 } , { 5 , 5 , 5 , 1 , 2 , 7 } , { 8 , 7 , 9 , 4 , 4 , 4 } } ; Console . Write ( largestKSubmatrix ( a ) ) ; } }
using System ; class GFG { public static double [ ] fact ; public static double probability ( int k , int n ) { double ans = 0 ; for ( int i = k ; i <= n ; ++ i ) ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) ; ans = ans / ( 1 << n ) ; return ans ; } public static void precompute ( ) { fact [ 0 ] = fact [ 1 ] = 1 ; for ( int i = 2 ; i < 20 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; } public static void Main ( ) { fact = new double [ 100 ] ; precompute ( ) ; Console . WriteLine ( probability ( 2 , 3 ) ) ; Console . WriteLine ( probability ( 3 , 6 ) ) ; Console . Write ( probability ( 12 , 18 ) ) ; } }
using System ; class GFG { static int countStrings ( int n , int k ) { int [ , , ] dp = new int [ n + 1 , k + 1 , 2 ] ; dp [ 1 , 0 , 0 ] = 1 ; dp [ 1 , 0 , 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i , j , 0 ] = dp [ i - 1 , j , 0 ] + dp [ i - 1 , j , 1 ] ; dp [ i , j , 1 ] = dp [ i - 1 , j , 0 ] ; if ( j - 1 >= 0 ) { dp [ i , j , 1 ] += dp [ i - 1 , j - 1 , 1 ] ; } } } return dp [ n , k , 0 ] + dp [ n , k , 1 ] ; } public static void Main ( String [ ] args ) { int n = 5 , k = 2 ; Console . WriteLine ( countStrings ( n , k ) ) ; } }
using System ; class GFG { static int [ ] dp = new int [ 1000 ] ; static int countFriendsPairings ( int n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; } static void Main ( ) { for ( int i = 0 ; i < 1000 ; i ++ ) dp [ i ] = - 1 ; int n = 4 ; Console . Write ( countFriendsPairings ( n ) ) ; } }
using System ; class GFG { static int maxPathSum ( int [ , ] tri , int m , int n ) { for ( int i = m - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 , j ] > tri [ i + 1 , j + 1 ] ) tri [ i , j ] += tri [ i + 1 , j ] ; else tri [ i , j ] += tri [ i + 1 , j + 1 ] ; } } return tri [ 0 , 0 ] ; } public static void Main ( ) { int [ , ] tri = { { 1 , 0 , 0 } , { 4 , 8 , 0 } , { 1 , 5 , 3 } } ; Console . Write ( maxPathSum ( tri , 2 , 2 ) ) ; } }
using System ; class GFG { static string X = " AGGT12" ; static string Y = "12TXAYB " ; static string Z = "12XBA " ; static int [ , , ] dp = new int [ 100 , 100 , 100 ] ; static int lcsOf3 ( int i , int j , int k ) { if ( i == - 1 j == - 1 k == - 1 ) return 0 ; if ( dp [ i , j , k ] != - 1 ) return dp [ i , j , k ] ; if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) return dp [ i , j , k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; else return dp [ i , j , k ] = Math . Max ( Math . Max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; } static void Main ( ) { for ( int i = 0 ; i < 100 ; i ++ ) for ( int j = 0 ; j < 100 ; j ++ ) for ( int k = 0 ; k < 100 ; k ++ ) dp [ i , j , k ] = - 1 ; int m = X . Length ; int n = Y . Length ; int o = Z . Length ; Console . Write ( " Length ▁ of ▁ LCS ▁ is ▁ " + lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) ; } }
using System ; class GFG { static int R = 4 ; static int C = 4 ; static int countPaths ( int [ , ] maze ) { if ( maze [ 0 , 0 ] == - 1 ) return 0 ; for ( int i = 0 ; i < R ; i ++ ) { if ( maze [ i , 0 ] == 0 ) maze [ i , 0 ] = 1 ; else break ; } for ( int i = 1 ; i < C ; i ++ ) { if ( maze [ 0 , i ] == 0 ) maze [ 0 , i ] = 1 ; else break ; } for ( int i = 1 ; i < R ; i ++ ) { for ( int j = 1 ; j < C ; j ++ ) { if ( maze [ i , j ] == - 1 ) continue ; if ( maze [ i - 1 , j ] > 0 ) maze [ i , j ] = ( maze [ i , j ] + maze [ i - 1 , j ] ) ; if ( maze [ i , j - 1 ] > 0 ) maze [ i , j ] = ( maze [ i , j ] + maze [ i , j - 1 ] ) ; } } return ( maze [ R - 1 , C - 1 ] > 0 ) ? maze [ R - 1 , C - 1 ] : 0 ; } public static void Main ( ) { int [ , ] maze = { { 0 , 0 , 0 , 0 } , { 0 , - 1 , 0 , 0 } , { - 1 , 0 , 0 , 0 } , { 0 , 0 , 0 , 0 } } ; Console . Write ( countPaths ( maze ) ) ; } }
using System ; class GFG { static int N = 4 ; static int maxDecimalValue ( int [ , ] mat , int i , int j , int p ) { if ( i >= N j >= N ) { return 0 ; } int result = Math . Max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i , j ] == 1 ) { return ( int ) ( Math . Pow ( 2 , p ) + result ) ; } else { return result ; } } public static void Main ( ) { int [ , ] mat = { { 1 , 1 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 1 , 1 } , } ; Console . Write ( maxDecimalValue ( mat , 0 , 0 , 0 ) ) ; } }
using System ; class GFG { public static int CountPS ( char [ ] str , int n ) { int [ ] [ ] dp = RectangularArrays . ReturnRectangularIntArray ( n , n ) ; bool [ ] [ ] P = RectangularArrays . ReturnRectangularBoolArray ( n , n ) ; for ( int i = 0 ; i < n ; i ++ ) { P [ i ] [ i ] = true ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( int gap = 2 ; gap < n ; gap ++ ) { for ( int i = 0 ; i < n - gap ; i ++ ) { int j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) { P [ i ] [ j ] = true ; } if ( P [ i ] [ j ] == true ) { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } } return dp [ 0 ] [ n - 1 ] ; } public static class RectangularArrays { public static int [ ] [ ] ReturnRectangularIntArray ( int size1 , int size2 ) { int [ ] [ ] newArray = new int [ size1 ] [ ] ; for ( int array1 = 0 ; array1 < size1 ; array1 ++ ) { newArray [ array1 ] = new int [ size2 ] ; } return newArray ; } public static bool [ ] [ ] ReturnRectangularBoolArray ( int size1 , int size2 ) { bool [ ] [ ] newArray = new bool [ size1 ] [ ] ; for ( int array1 = 0 ; array1 < size1 ; array1 ++ ) { newArray [ array1 ] = new bool [ size2 ] ; } return newArray ; } } public static void Main ( string [ ] args ) { string str = " abaab " ; Console . WriteLine ( CountPS ( str . ToCharArray ( ) , str . Length ) ) ; } }
using System ; class GFG { static int maxSumWO3Consec ( int [ ] arr , int n ) { int [ ] sum = new int [ n ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . Max ( sum [ 1 ] , Math . Max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = Math . Max ( Math . Max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; } public static void Main ( ) { int [ ] arr = { 100 , 1000 , 100 , 1000 , 1 } ; int n = arr . Length ; Console . Write ( maxSumWO3Consec ( arr , n ) ) ; } }
using System ; class GFG { static int maxSumPairWithDifferenceLessThanK ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int [ ] dp = new int [ N ] ; dp [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . Max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . Max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; } public static void Main ( ) { int [ ] arr = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = arr . Length ; int K = 4 ; Console . WriteLine ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) ; } }
using System ; class GFG { public static int lucas ( int n ) { if ( n == 0 ) return 2 ; if ( n == 1 ) return 1 ; return lucas ( n - 1 ) + lucas ( n - 2 ) ; } public static void Main ( ) { int n = 9 ; Console . WriteLine ( lucas ( n ) ) ; } }
using System ; class GFG { static int breakSum ( int n ) { if ( n == 0 n == 1 ) return n ; return Math . Max ( ( breakSum ( n / 2 ) + breakSum ( n / 3 ) + breakSum ( n / 4 ) ) , n ) ; } public static void Main ( ) { int n = 12 ; Console . WriteLine ( breakSum ( n ) ) ; } }
using System ; class GFG { static int countPS ( string str ) { int N = str . Length ; int [ , ] cps = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) cps [ i , i ] = 1 ; for ( int L = 2 ; L <= N ; L ++ ) { for ( int i = 0 ; i <= N - L ; i ++ ) { int k = L + i - 1 ; if ( k < N ) { if ( str [ i ] == str [ k ] ) cps [ i , k ] = cps [ i , k - 1 ] + cps [ i + 1 , k ] + 1 ; else cps [ i , k ] = cps [ i , k - 1 ] + cps [ i + 1 , k ] - cps [ i + 1 , k - 1 ] ; } } } return cps [ 0 , N - 1 ] ; } public static void Main ( ) { string str = " abcb " ; Console . Write ( " Total ▁ palindromic ▁ " + " subsequence ▁ are ▁ : ▁ " + countPS ( str ) ) ; } }
using System ; class GFG { static int n ; static int [ , ] dp = new int [ 1000 , 1000 ] ; static string str = " abcb " ; static int countPS ( int i , int j ) { if ( i > j ) return 0 ; if ( dp [ i , j ] != - 1 ) return dp [ i , j ] ; if ( i == j ) return dp [ i , j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i , j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i , j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; } static void Main ( ) { for ( int i = 0 ; i < 1000 ; i ++ ) for ( int j = 0 ; j < 1000 ; j ++ ) dp [ i , j ] = - 1 ; n = str . Length ; Console . Write ( " Total ▁ palindromic ▁ subsequence " + " are ▁ : ▁ " + countPS ( 0 , n - 1 ) ) ; } }
using System ; class GFG { static int minimum ( int a , int b , int c ) { return Math . Min ( Math . Min ( a , b ) , c ) ; } static int findMinSum ( int [ ] arr , int n ) { int [ ] sum = new int [ n ] ; sum [ 0 ] = arr [ 0 ] ; sum [ 1 ] = arr [ 1 ] ; sum [ 2 ] = arr [ 2 ] ; for ( int i = 3 ; i < n ; i ++ ) sum [ i ] = arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ; return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 20 , 2 , 10 , 1 } ; int n = arr . Length ; Console . WriteLine ( " Min ▁ Sum ▁ is ▁ " + findMinSum ( arr , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { public static int MinimumCost ( int [ ] cost , int n , int W ) { List < int > val = new List < int > ( ) ; List < int > wt = new List < int > ( ) ; int size = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . Add ( cost [ i ] ) ; wt . Add ( i + 1 ) ; size ++ ; } } n = size ; int [ , ] min_cost = new int [ n + 1 , W + 1 ] ; for ( int i = 0 ; i <= W ; i ++ ) min_cost [ 0 , i ] = int . MaxValue ; for ( int i = 1 ; i <= n ; i ++ ) min_cost [ i , 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= W ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i , j ] = min_cost [ i - 1 , j ] ; else min_cost [ i , j ] = Math . Min ( min_cost [ i - 1 , j ] , min_cost [ i , j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } return ( min_cost [ n , W ] == int . MaxValue ) ? - 1 : min_cost [ n , W ] ; } public static void Main ( ) { int [ ] cost = { 1 , 2 , 3 , 4 , 5 } ; int W = 5 ; int n = cost . Length ; Console . WriteLine ( MinimumCost ( cost , n , W ) ) ; } }
using System ; class GFG { static int count ( string a , string b , int m , int n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; } public static void Main ( ) { string a = " GeeksforGeeks " ; string b = " Gks " ; Console . Write ( count ( a , b , a . Length , b . Length ) ) ; } }
using System ; class GFG { static int lcs ( String X , String Y , int m , int n ) { int [ , ] L = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; else L [ i , j ] = Math . Max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } return L [ m , n ] ; } static int findMinCost ( String X , String Y , int costX , int costY ) { int m = X . Length ; int n = Y . Length ; int len_LCS ; len_LCS = lcs ( X , Y , m , n ) ; return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ; } public static void Main ( ) { String X = " ef " ; String Y = " gh " ; Console . Write ( " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ " + " ▁ identical ▁ is ▁ = ▁ " + findMinCost ( X , Y , 10 , 20 ) ) ; } }
using System ; class GFG { static int countIntegralSolutions ( int n ) { int result = 0 ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= n - i ; j ++ ) for ( int k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; } public static void Main ( ) { int n = 3 ; Console . Write ( countIntegralSolutions ( n ) ) ; } }
using System ; class GFG { static int countIntegralSolutions ( int n ) { return ( ( n + 1 ) * ( n + 2 ) ) / 2 ; } public static void Main ( String [ ] args ) { int n = 3 ; Console . Write ( countIntegralSolutions ( n ) ) ; } }
using System ; class GFG { static int maxLeftSubArraySum ( int [ ] a , int size , int [ ] sum ) { int max_so_far = a [ 0 ] ; int curr_max = a [ 0 ] ; sum [ 0 ] = max_so_far ; for ( int i = 1 ; i < size ; i ++ ) { curr_max = Math . Max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . Max ( max_so_far , curr_max ) ; sum [ i ] = max_so_far ; } return max_so_far ; } static int maxRightSubArraySum ( int [ ] a , int n , int [ ] sum ) { int max_so_far = a [ n ] ; int curr_max = a [ n ] ; sum [ n ] = max_so_far ; for ( int i = n - 1 ; i >= 0 ; i -- ) { curr_max = Math . Max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . Max ( max_so_far , curr_max ) ; sum [ i ] = max_so_far ; } return max_so_far ; } static int findMaxAbsDiff ( int [ ] arr , int n ) { int [ ] leftMax = new int [ n ] ; maxLeftSubArraySum ( arr , n , leftMax ) ; int [ ] rightMax = new int [ n ] ; maxRightSubArraySum ( arr , n - 1 , rightMax ) ; int [ ] invertArr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) invertArr [ i ] = - arr [ i ] ; int [ ] leftMin = new int [ n ] ; maxLeftSubArraySum ( invertArr , n , leftMin ) ; for ( int i = 0 ; i < n ; i ++ ) leftMin [ i ] = - leftMin [ i ] ; int [ ] rightMin = new int [ n ] ; maxRightSubArraySum ( invertArr , n - 1 , rightMin ) ; for ( int i = 0 ; i < n ; i ++ ) rightMin [ i ] = - rightMin [ i ] ; int result = - 2147483648 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int absValue = Math . Max ( Math . Abs ( leftMax [ i ] - rightMin [ i + 1 ] ) , Math . Abs ( leftMin [ i ] - rightMax [ i + 1 ] ) ) ; if ( absValue > result ) result = absValue ; } return result ; } public static void Main ( ) { int [ ] a = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n = a . Length ; Console . Write ( findMaxAbsDiff ( a , n ) ) ; } }
using System ; class GFG { static int countWays ( int p , int q , int r , int last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( last == 0 ) return countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; if ( last == 1 ) return countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; if ( last == 2 ) return countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return 0 ; } static int countUtil ( int p , int q , int r ) { return countWays ( p , q , r , 0 ) + countWays ( p , q , r , 1 ) + countWays ( p , q , r , 2 ) ; } public static void Main ( ) { int p = 1 , q = 1 , r = 1 ; Console . Write ( countUtil ( p , q , r ) ) ; } }
using System ; class GFG { public static int countP ( int n , int k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; } public static void Main ( ) { Console . WriteLine ( countP ( 3 , 2 ) ) ; } }
using System ; class GFG { static int countP ( int n , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = 0 ; for ( int i = 0 ; i <= k ; i ++ ) dp [ 0 , k ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i , j ] = 1 ; else dp [ i , j ] = j * dp [ i - 1 , j ] + dp [ i - 1 , j - 1 ] ; return dp [ n , k ] ; } public static void Main ( ) { Console . Write ( countP ( 5 , 2 ) ) ; } }
using System ; class GFG { static int printCountRec ( int dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; } public static void Main ( ) { int dist = 4 ; Console . WriteLine ( printCountRec ( dist ) ) ; } }
using System ; public class GFG { static int countNumbersWith4 ( int n ) { int result = 0 ; for ( int x = 1 ; x <= n ; x ++ ) result += has4 ( x ) ? 1 : 0 ; return result ; } static bool has4 ( int x ) { while ( x != 0 ) { if ( x % 10 == 4 ) return true ; x = x / 10 ; } return false ; } public static void Main ( ) { int n = 328 ; Console . WriteLine ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ a ▁ digit ▁ is ▁ " + countNumbersWith4 ( n ) ) ; } }
using System ; class GFG { static int countNumbersWith4 ( int n ) { if ( n < 4 ) return 0 ; int d = ( int ) Math . Log10 ( n ) ; int [ ] a = new int [ d + 2 ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( int i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + ( int ) Math . Ceiling ( Math . Pow ( 10 , i - 1 ) ) ; int p = ( int ) Math . Ceiling ( Math . Pow ( 10 , d ) ) ; int msd = n / p ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; } static void Main ( ) { int n = 328 ; Console . WriteLine ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " + n + " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is ▁ " + countNumbersWith4 ( n ) ) ; } }
using System ; public class GFG { static int minRemovalsDP ( int [ ] arr , int n ) { int longest_start = - 1 , longest_end = 0 ; for ( int start = 0 ; start < n ; start ++ ) { int min = int . MaxValue , max = int . MinValue ; for ( int end = start ; end < n ; end ++ ) { int val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > longest_end - longest_start longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) { return n ; } return ( n - ( longest_end - longest_start + 1 ) ) ; } public static void Main ( ) { int [ ] arr = { 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 } ; int n = arr . Length ; Console . WriteLine ( minRemovalsDP ( arr , n ) ) ; } }
using System ; public class GFG { static int optimalStrategyOfGame ( int [ ] arr , int n ) { int [ , ] table = new int [ n , n ] ; int gap , i , j , x , y , z ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 , j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 , j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i , j - 2 ] : 0 ; table [ i , j ] = Math . Max ( arr [ i ] + Math . Min ( x , y ) , arr [ j ] + Math . Min ( y , z ) ) ; } } return table [ 0 , n - 1 ] ; } static public void Main ( ) { int [ ] arr1 = { 8 , 15 , 3 , 7 } ; int n = arr1 . Length ; Console . WriteLine ( " " + optimalStrategyOfGame ( arr1 , n ) ) ; int [ ] arr2 = { 2 , 2 , 2 , 2 } ; n = arr2 . Length ; Console . WriteLine ( " " + optimalStrategyOfGame ( arr2 , n ) ) ; int [ ] arr3 = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = arr3 . Length ; Console . WriteLine ( " " + optimalStrategyOfGame ( arr3 , n ) ) ; } }
using System ; class GFG { static int maxSumIS ( int [ ] arr , int n ) { int i , j , max = 0 ; int [ ] msis = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = arr . Length ; Console . WriteLine ( " Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ " + " ▁ subsequence ▁ is ▁ " + maxSumIS ( arr , n ) ) ; } }
using System ; class GFG { static bool endsWith ( string str , string pat ) { int patLen = pat . Length ; int strLen = str . Length ; if ( patLen > strLen ) return false ; patLen -- ; strLen -- ; while ( patLen >= 0 ) { if ( pat [ patLen ] != str [ strLen ] ) return false ; patLen -- ; strLen -- ; } return true ; } static int countOfStrings ( string pat , int n , string [ ] sArr ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( endsWith ( sArr [ i ] , pat ) ) count ++ ; return count ; } public static void Main ( ) { string pat = " ks " ; int n = 4 ; string [ ] sArr = { " geeks " , " geeksforgeeks " , " games " , " unit " } ; Console . WriteLine ( countOfStrings ( pat , n , sArr ) ) ; } }
using System ; class GFG { static int getEndingIndex ( string str , int n , int i ) { i ++ ; while ( i < n ) { char curr = str [ i ] ; char prev = str [ i - 1 ] ; if ( ( curr == ' a ' && prev == ' z ' ) || ( curr - prev == 1 ) ) i ++ ; else break ; } return i - 1 ; } static int largestSubStr ( string str , int n ) { int len = 0 ; int i = 0 ; while ( i < n ) { int end = getEndingIndex ( str , n , i ) ; len = Math . Max ( end - i + 1 , len ) ; i = end + 1 ; } return len ; } public static void Main ( ) { string str = " abcabcdefabc " ; int n = str . Length ; Console . Write ( largestSubStr ( str , n ) ) ; } }
class GFG { static int getSum ( int n , int d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; int k = n / 10 ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; } public static void Main ( ) { int n = 30 ; int d = 3 ; System . Console . WriteLine ( getSum ( n , d ) ) ; } }
using System ; class GFG { public static int replace ( string A , string B ) { int n = A . Length , m = B . Length ; int count = 0 , i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { if ( i + j >= n ) { break ; } else if ( A [ i + j ] != B [ j ] ) { break ; } } if ( j == m ) { count ++ ; i += m - 1 ; } } return count ; } public static void Main ( string [ ] args ) { string str1 = " aaaaaaaa " ; string str2 = " aaa " ; Console . WriteLine ( replace ( str1 , str2 ) ) ; } }
using System ; class GFG { static int isSubstring ( string s1 , string s2 ) { int M = s1 . Length ; int N = s2 . Length ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return - 1 ; } public static void Main ( ) { string s1 = " for " ; string s2 = " geeksforgeeks " ; int res = isSubstring ( s1 , s2 ) ; if ( res == - 1 ) Console . Write ( " Not ▁ present " ) ; else Console . Write ( " Present ▁ at ▁ index ▁ " + res ) ; } }
using System ; class GFG { static int patternCount ( String str ) { char last = str [ 0 ] ; int i = 1 , counter = 0 ; while ( i < str . Length ) { if ( str [ i ] == '0' && last == '1' ) { while ( str [ i ] == '0' ) i ++ ; if ( str [ i ] == '1' ) counter ++ ; } last = str [ i ] ; i ++ ; } return counter ; } public static void Main ( ) { String str = "1001ab010abc01001" ; Console . Write ( patternCount ( str ) ) ; } }
using System ; class GFG { static int maxPrefix ( String s , String t ) { int count = 0 ; for ( int i = 0 ; i < t . Length ; i ++ ) { if ( count == s . Length ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; } public static void Main ( ) { String S = " digger " ; String T = " biggerdiagram " ; Console . Write ( maxPrefix ( S , T ) ) ; } }
using System ; class GFG { static void translate ( char [ ] str ) { for ( int i = 1 ; i < str . Length ; i ++ ) { if ( str [ i - 1 ] == ' A ' && str [ i ] == ' B ' ) { str [ i - 1 ] = ' C ' ; int j ; for ( j = i ; j < str . Length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ▁ ' ; } } return ; } public static void Main ( ) { String st = " helloABworldABGfG " ; char [ ] str = st . ToCharArray ( ) ; translate ( str ) ; Console . WriteLine ( " The ▁ modified ▁ string ▁ is ▁ : " ) ; Console . Write ( str ) ; } }
using System ; class GFG { public static int NUM = 31 ; static void positions ( string str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ( str [ i ] & NUM ) + " ▁ " ) ; } } public static void Main ( ) { string str = " Geeks " ; int n = str . Length ; positions ( str , n ) ; } }
using System ; class GFG { public static int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . ToCharArray ( ) ; for ( int i = 0 ; i < new_str . Length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; } public static void Main ( String [ ] args ) { String s = " synapse " ; Console . WriteLine ( lenoflongestnonpalindrome ( s ) ) ; } }
using System ; class GFG { static String makePalindrome ( char [ ] str ) { int i = 0 , j = str . Length - 1 ; while ( i <= j ) { if ( str [ i ] == ' * ' && str [ j ] == ' * ' ) { str [ i ] = ' a ' ; str [ j ] = ' a ' ; } else if ( str [ j ] == ' * ' ) str [ j ] = str [ i ] ; else if ( str [ i ] == ' * ' ) str [ i ] = str [ j ] ; else if ( str [ i ] != str [ j ] ) return " - 1" ; i ++ ; j -- ; } return String . Join ( " " , str ) ; } public static void Main ( String [ ] args ) { char [ ] str = " na * an " . ToCharArray ( ) ; Console . WriteLine ( makePalindrome ( str ) ) ; } }
using System ; class GFG { public static int calcScore ( String str ) { int score = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; ) { int chunkSize = 1 ; char currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == '1' ) score += ( int ) Math . Pow ( chunkSize , 2 ) ; else score -= ( int ) Math . Pow ( chunkSize , 2 ) ; } return score ; } public static void Main ( String [ ] args ) { String str = "11011" ; Console . WriteLine ( calcScore ( str ) ) ; } }
using System ; class GFG { static int countSubString ( char [ ] s , char c , int k ) { int leftCount = 0 , rightCount = 0 ; int left = 0 , right = 0 ; int freq = 0 ; int result = 0 , len = s . Length ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; } public static void Main ( String [ ] args ) { String s = " abada " ; char c = ' a ' ; int k = 2 ; Console . WriteLine ( countSubString ( s . ToCharArray ( ) , c , k ) ) ; } }
using System ; class GFG { static bool isValid ( String str , int n ) { if ( ! ( ( str [ 0 ] >= ' a ' && str [ 0 ] <= ' z ' ) || ( str [ 0 ] >= ' A ' && str [ 0 ] <= ' Z ' ) str [ 0 ] == ' _ ' ) ) return false ; for ( int i = 1 ; i < str . Length ; i ++ ) { if ( ! ( ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) || ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) || ( str [ i ] >= '0' && str [ i ] <= '9' ) str [ i ] == ' _ ' ) ) return false ; } return true ; } public static void Main ( String [ ] args ) { String str = " _ geeks123" ; int n = str . Length ; if ( isValid ( str , n ) ) Console . WriteLine ( " Valid " ) ; else Console . WriteLine ( " Invalid " ) ; } }
using System ; class GFG { static String FirstAndLast ( String str ) { char [ ] ch = str . ToCharArray ( ) ; for ( int i = 0 ; i < ch . Length ; i ++ ) { int k = i ; while ( i < ch . Length && ch [ i ] != ' ▁ ' ) i ++ ; ch [ k ] = ( char ) ( ch [ k ] >= ' a ' && ch [ k ] <= ' z ' ? ( ( int ) ch [ k ] - 32 ) : ( int ) ch [ k ] ) ; ch [ i - 1 ] = ( char ) ( ch [ i - 1 ] >= ' a ' && ch [ i - 1 ] <= ' z ' ? ( ( int ) ch [ i - 1 ] - 32 ) : ( int ) ch [ i - 1 ] ) ; } return new String ( ch ) ; } public static void Main ( String [ ] args ) { String str = " Geeks ▁ for ▁ Geeks " ; Console . WriteLine ( str ) ; Console . WriteLine ( FirstAndLast ( str ) ) ; } }
using System ; class GFG { static int findM ( String s , int x ) { int cnt = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] - '0' != x ) cnt ++ ; } return cnt ; } public static void Main ( ) { String s = "3662123" ; int x = 6 ; Console . Write ( findM ( s , x ) ) ; } }
using System ; class GFG { static int [ ] compute_lps ( string s ) { int n = s . Length ; int [ ] lps = new int [ n ] ; int len = 0 ; lps [ 0 ] = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } static void Longestsubstring ( string s ) { int [ ] lps = compute_lps ( s ) ; int n = s . Length ; if ( lps [ n - 1 ] == 0 ) { Console . WriteLine ( - 1 ) ; return ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { Console . WriteLine ( s . Substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) Console . WriteLine ( - 1 ) ; else Console . WriteLine ( s . Substring ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ) ; } public static void Main ( ) { string s = " fixprefixsuffix " ; Longestsubstring ( s ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int MAX = 64 ; static int getBitmask ( char [ ] s ) { int temp = 0 ; for ( int j = 0 ; j < s . Length ; j ++ ) { switch ( s [ j ] ) { case ' s ' : temp = temp | ( 1 ) ; break ; case ' t ' : temp = temp | ( 2 ) ; break ; case ' r ' : temp = temp | ( 4 ) ; break ; case ' i ' : temp = temp | ( 8 ) ; break ; case ' n ' : temp = temp | ( 16 ) ; break ; case ' g ' : temp = temp | ( 32 ) ; break ; default : break ; } } return temp ; } static int countPairs ( String [ ] arr , int n ) { int [ ] bitMask = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) bitMask [ getBitmask ( arr [ i ] . ToCharArray ( ) ) ] ++ ; int cnt = 0 ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i ; j < MAX ; j ++ ) { if ( ( i j ) == ( MAX - 1 ) ) { if ( i == j ) cnt += ( ( bitMask [ i ] * bitMask [ i ] - 1 ) / 2 ) ; else cnt += ( bitMask [ i ] * bitMask [ j ] ) ; } } } return cnt ; } public static void Main ( String [ ] args ) { String [ ] arr = { " strrr " , " string " , " gstrin " } ; int n = arr . Length ; Console . WriteLine ( countPairs ( arr , n ) ) ; } }
using System ; class GFG { static int countOcc ( string s ) { int cnt = 0 ; for ( int i = 0 ; i < s . Length - 3 ; i ++ ) { int c = 0 , l = 0 , a = 0 , p = 0 ; for ( int j = i ; j < i + 4 ; j ++ ) { switch ( s [ j ] ) { case ' c ' : c ++ ; break ; case ' l ' : l ++ ; break ; case ' a ' : a ++ ; break ; case ' p ' : p ++ ; break ; } } if ( c == 1 && l == 1 && a == 1 && p == 1 ) cnt ++ ; } return cnt ; } public static void Main ( ) { string s = " clapc " ; Console . Write ( countOcc ( s . ToLower ( ) ) ) ; } }
using System ; class GfG { static int calculateWays ( String s , int n , int l , int r ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < l i > r ) freq [ s [ i ] - ' a ' ] ++ ; } int ways = 1 ; for ( int i = l ; i <= r ; i ++ ) { if ( freq [ s [ i ] - ' a ' ] != 0 ) { ways = ways * freq [ s [ i ] - ' a ' ] ; freq [ s [ i ] - ' a ' ] -- ; } else { ways = 0 ; break ; } } return ways ; } public static void Main ( ) { String s = " cabcaab " ; int n = s . Length ; int l = 1 , r = 3 ; Console . WriteLine ( calculateWays ( s , n , l , r ) ) ; } }
using System ; class GFG { static void asciiToSentence ( String str , int len ) { int num = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( num >= 32 && num <= 122 ) { char ch = ( char ) num ; Console . Write ( ch ) ; num = 0 ; } } } public static void Main ( ) { String str = "7110110110711510211111471101101107115" ; int len = str . Length ; asciiToSentence ( str , len ) ; } }
using System ; class GFG { static readonly int [ ] arr = { 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 } ; public static int countKeyPressed ( String str , int len ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) count = count + arr [ str [ i ] - ' a ' ] ; return count ; } public static void Main ( ) { String str = " abcdef " ; int len = str . Length ; Console . Write ( countKeyPressed ( str , len ) ) ; } }
using System ; class GFG { static bool isReverseEqual ( String s1 , String s2 ) { if ( s1 . Length != s2 . Length ) return false ; int len = s1 . Length ; for ( int i = 0 ; i < len ; i ++ ) if ( s1 [ i ] != s2 [ len - i - 1 ] ) return false ; return true ; } static String getWord ( String [ ] str , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( isReverseEqual ( str [ i ] , str [ j ] ) ) return str [ i ] ; return " - 1" ; } public static void Main ( String [ ] args ) { String [ ] str = { " geeks " , " for " , " skeeg " } ; int n = str . Length ; Console . Write ( getWord ( str , n ) ) ; } }
using System ; class GFG { static bool isPrefix ( String str , int len , int i , int k ) { if ( i + k > len ) return false ; for ( int j = 0 ; j < k ; j ++ ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; } return true ; } static bool isKPeriodic ( String str , int len , int k ) { for ( int i = k ; i < len ; i += k ) if ( ! isPrefix ( str , len , i , k ) ) return false ; return true ; } public static void Main ( ) { String str = " geeksgeeks " ; int len = str . Length ; int k = 5 ; if ( isKPeriodic ( str , len , k ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int minLettersNeeded ( int n ) { if ( n % 26 == 0 ) return ( n / 26 ) ; else return ( ( n / 26 ) + 1 ) ; } public static void Main ( ) { int n = 52 ; Console . Write ( minLettersNeeded ( n ) ) ; } }
using System ; class GFG { static int minReplacement ( String s , int len ) { int ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s [ i ] == '1' ) ans ++ ; if ( i % 2 == 1 && s [ i ] == '0' ) ans ++ ; } return Math . Min ( ans , len - ans ) ; } public static void Main ( String [ ] args ) { String s = "1100" ; int len = s . Length ; Console . Write ( minReplacement ( s , len ) ) ; } }
using System ; class GFG { static String groupCharacters ( char [ ] s , int len ) { string temp = " " ; for ( int j = 0 ; j < len ; j ++ ) if ( s [ j ] != ' ▁ ' ) temp = temp + s [ j ] ; len = temp . Length ; string ans = " " ; int i = 0 ; while ( i < len ) { if ( temp [ i ] >= ( ' A ' ) && temp [ i ] <= ( ' Z ' ) ) { while ( i < len && temp [ i ] >= ( ' A ' ) && temp [ i ] <= ( ' Z ' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " ▁ " ; } else if ( temp [ i ] >= ( '0' ) && temp [ i ] <= ( '9' ) ) { while ( i < len && temp [ i ] >= ( '0' ) && temp [ i ] <= ( '9' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " ▁ " ; } else { while ( i < len && temp [ i ] >= ( ' * ' ) && temp [ i ] <= ( ' / ' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " ▁ " ; } } return ans ; } public static void Main ( ) { string s = "34FTG234 + ▁ + - ▁ * " ; int len = s . Length ; Console . WriteLine ( groupCharacters ( s . ToCharArray ( ) , len ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int Preprocess ( string A , string B ) { int n = A . Length ; int ans = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; if ( mp . ContainsKey ( A [ i ] ) ) mp [ A [ i ] ] ++ ; else mp [ A [ i ] ] = 1 ; if ( mp . ContainsKey ( A [ n - i - 1 ] ) ) mp [ A [ n - i - 1 ] ] ++ ; else mp [ A [ n - i - 1 ] ] = 1 ; if ( mp . ContainsKey ( B [ i ] ) ) mp [ B [ i ] ] ++ ; else mp [ B [ i ] ] = 1 ; if ( mp . ContainsKey ( B [ n - i - 1 ] ) ) mp [ B [ n - i - 1 ] ] ++ ; else mp [ B [ n - i - 1 ] ] = 1 ; int sz = mp . Count ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp [ A [ i ] ] != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A [ n / 2 ] != B [ n / 2 ] ) ans ++ ; return ans ; } public static void Main ( ) { string A = " abacaba " , B = " bacabaa " ; Console . WriteLine ( Preprocess ( A , B ) ) ; } }
using System ; class GFG { static String leastLexiString ( String s ) { if ( s . Length == 1 ) return s ; String x = leastLexiString ( s . Substring ( 0 , s . Length / 2 ) ) ; String y = leastLexiString ( s . Substring ( s . Length / 2 ) ) ; return ( ( x + y ) . CompareTo ( y + x ) . ToString ( ) ) ; } static Boolean areEquivalent ( String a , String b ) { return ! ( leastLexiString ( a ) . Equals ( leastLexiString ( b ) ) ) ; } public static void Main ( String [ ] args ) { String a = " aaba " ; String b = " abaa " ; if ( areEquivalent ( a , b ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; a = " aabb " ; b = " abab " ; if ( areEquivalent ( a , b ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static void generateString ( int A , int B ) { string rt = " " ; while ( 0 < A 0 < B ) { if ( A < B ) { if ( 0 < B -- ) { rt += ( ' b ' ) ; } if ( 0 < B -- ) { rt += ( ' b ' ) ; } if ( 0 < A -- ) { rt += ( ' a ' ) ; } } else if ( B < A ) { if ( 0 < A -- ) { rt += ( ' a ' ) ; } if ( 0 < A -- ) { rt += ( ' a ' ) ; } if ( 0 < B -- ) { rt += ( ' b ' ) ; } } else { if ( 0 < A -- ) { rt += ( ' a ' ) ; } if ( 0 < B -- ) { rt += ( ' b ' ) ; } } } Console . WriteLine ( rt ) ; } public static void Main ( ) { int A = 2 , B = 6 ; generateString ( A , B ) ; } }
using System ; class GFG { static String getSubSeq ( String s , int n ) { String res = " " ; int cr = 0 ; while ( cr < n ) { char mx = s [ cr ] ; for ( int i = cr + 1 ; i < n ; i ++ ) { mx = ( char ) Math . Max ( mx , s [ i ] ) ; } int lst = cr ; for ( int i = cr ; i < n ; i ++ ) { if ( s [ i ] == mx ) { res += s [ i ] ; lst = i ; } } cr = lst + 1 ; } return res ; } public static void Main ( String [ ] args ) { String s = " geeksforgeeks " ; int n = s . Length ; Console . WriteLine ( getSubSeq ( s , n ) ) ; } }
using System ; class GFG { static int countSubStr ( String str , int len , int k ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) { int n = 0 ; for ( int j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] - '0' ) ; if ( n % k == 0 ) count ++ ; } } return count ; } public static void Main ( ) { String str = "33445" ; int len = str . Length ; int k = 11 ; Console . WriteLine ( countSubStr ( str , len , k ) ) ; } }
using System ; class GFG { static char Colour_Combination ( string s ) { char temp = s [ 0 ] ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' B ' temp == ' G ' ) && ( s [ i ] == ' G ' s [ i ] == ' B ' ) ) temp = ' Y ' ; else if ( ( temp == ' B ' temp == ' Y ' ) && ( s [ i ] == ' Y ' s [ i ] == ' B ' ) ) temp = ' G ' ; else temp = ' B ' ; } } return temp ; } static void Main ( ) { string s = " GBYGB " ; Console . WriteLine ( Colour_Combination ( s ) ) ; } }
using System ; class GFG { static void reverse ( string str , int x ) { int n = ( str . Length - x ) / 2 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( str [ i ] ) ; for ( int i = n + x - 1 ; i >= n ; i -- ) Console . Write ( str [ i ] ) ; for ( int i = n + x ; i < str . Length ; i ++ ) Console . Write ( str [ i ] ) ; } public static void Main ( ) { string str = " geeksforgeeks " ; int x = 3 ; reverse ( str , x ) ; } }
using System ; using System . Text ; class GFG { static string lexoSmallest ( string str , int n ) { int ca = 0 , cb = 0 , cc = 0 ; StringBuilder s = new StringBuilder ( str ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( s [ j ] == ' a ' ) ca ++ ; else if ( s [ j ] == ' b ' ) cb ++ ; else cc ++ ; } if ( ca == cb && cb == cc ) { return s . ToString ( ) ; } int cnt = n / 3 ; if ( cnt * 3 != n ) { return " - 1" ; } int i = 0 ; while ( ca < cnt && i < n ) { if ( s [ i ] == ' b ' && cb > cnt ) { cb -- ; s [ i ] = ' a ' ; ca ++ ; } else if ( s [ i ] == ' c ' && cc > cnt ) { cc -- ; s [ i ] = ' a ' ; ca ++ ; } i ++ ; } i = 0 ; while ( cb < cnt && i < n ) { if ( s [ i ] == ' c ' && cc > cnt ) { cc -- ; s [ i ] = '1' ; cb ++ ; } i ++ ; } i = n - 1 ; while ( cc < cnt && i >= 0 ) { if ( s [ i ] == ' a ' && ca > cnt ) { ca -- ; s [ i ] = ' c ' ; cc ++ ; } i -- ; } i = n - 1 ; while ( cb < cnt && i >= 0 ) { if ( s [ i ] == ' a ' && ca > cnt ) { ca -- ; s [ i ] = ' b ' ; cb ++ ; } i -- ; } i = n - 1 ; while ( cc < cnt && i >= 0 ) { if ( s [ i ] == ' b ' && cb > cnt ) { cb -- ; s [ i ] = ' c ' ; cc ++ ; } i -- ; } return s . ToString ( ) ; } public static void Main ( string [ ] args ) { string s = " aaaaaa " ; int n = s . Length ; Console . Write ( lexoSmallest ( s , n ) ) ; } }
using System ; class GFG { static int getSteps ( string str , int i , int j , int n ) { int k = i + 1 ; int steps = 0 ; char ch = str [ i ] ; while ( k <= j ) { if ( str [ k ] != ch ) { steps ++ ; ch = str [ k ] ; } k ++ ; } return steps ; } static int getMinSteps ( string str , int i , int j , int n ) { if ( j < i ) { int temp = i ; i = j ; j = temp ; } int stepsToRight = getSteps ( str , i , j , n ) ; int stepsToLeft = getSteps ( str , 0 , i , n ) + getSteps ( str , j , n - 1 , n ) ; if ( str [ 0 ] != str [ n - 1 ] ) stepsToLeft ++ ; return Math . Min ( stepsToLeft , stepsToRight ) ; } public static void Main ( ) { string str = " SSNSS " ; int n = str . Length ; int i = 0 , j = 3 ; Console . WriteLine ( getMinSteps ( str , i , j , n ) ) ; } }
using System ; class GFG { static string removeChars ( string s ) { string modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( char . IsUpper ( s [ i ] ) && char . IsLower ( s [ i - 1 ] ) || char . IsLower ( s [ i ] ) && char . IsUpper ( s [ i - 1 ] ) ) modifiedStr += s [ i ] ; } return modifiedStr ; } public static void Main ( ) { string s = " GeeksForGeeks " ; Console . Write ( removeChars ( s ) ) ; } }
using System ; class GFG { static int pangramCost ( int [ ] arr , string str ) { int cost = 0 ; bool [ ] occurred = new bool [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) occurred [ i ] = false ; for ( int i = 0 ; i < str . Length ; i ++ ) occurred [ str [ i ] - ' a ' ] = true ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( occurred [ i ] == false ) cost += arr [ i ] ; } return cost ; } public static void Main ( string [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 } ; string str = " abcdefghijklmopqrstuvwz " ; Console . WriteLine ( pangramCost ( arr , str ) ) ; } }
using System ; class GFG { static String output = " " ; static void pairStar ( String input , int i ) { output = output + input [ i ] ; if ( i == input . Length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' * ' ; pairStar ( input , i + 1 ) ; } public static void Main ( String [ ] args ) { String input = " geeks " ; pairStar ( input , 0 ) ; Console . WriteLine ( output ) ; } }
using System ; public class GFG { static int maxOperations ( string str ) { int i , g , gk , gks ; i = g = gk = gks = 0 ; for ( i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ' g ' ) { g ++ ; } else if ( str [ i ] == ' k ' ) { if ( g > 0 ) { g -- ; gk ++ ; } } else if ( str [ i ] == ' s ' ) { if ( gk > 0 ) { gk -- ; gks ++ ; } } } return gks ; } public static void Main ( ) { string a = " ggkssk " ; Console . WriteLine ( maxOperations ( a ) ) ; } }
using System ; class GFG { static string printFinalString ( string s ) { int i , n ; n = s . Length ; int x = 0 , y = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' x ' ) { x ++ ; else { y ++ ; } } string finalString = " " ; if ( x > y ) { for ( i = 0 ; i < x - y ; i ++ ) { finalString += " x " ; } } else { for ( i = 0 ; i < y - x ; i ++ ) { finalString += " y " ; } } return finalString ; } public static void Main ( ) { string s = " xxyyxyy " ; Console . WriteLine ( printFinalString ( s ) ) ; } }
using System ; class GFG { static String K_String ( String s , int k ) { int n = s . Length ; int [ ] fre = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - ' a ' ] ++ ; String str = " " ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % k == 0 ) { int x = fre [ i ] / k ; while ( x != 0 ) { str += ( char ) ( i + ' a ' ) ; x -- ; } } else { return " - 1" ; } } return str ; } public static void Main ( String [ ] args ) { String s = " aabb " ; int k = 2 ; Console . WriteLine ( K_String ( s , k ) ) ; } }
using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; Dictionary < char , int > m = new Dictionary < char , int > ( ) ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] && str [ i ] <= r ) ) { cnt ++ ; if ( ! m . ContainsKey ( str [ i ] ) ) { m [ str [ i ] ] = 0 ; Console . Write ( str [ i ] + " ▁ " ) ; } m [ str [ i ] ] ++ ; } } return cnt ; } public static void Main ( string [ ] args ) { string str = " geeksforgeeks " ; int l = 102 , r = 111 ; Console . Write ( " Characters ▁ with ▁ ASCII ▁ values " + " not ▁ in ▁ the ▁ range ▁ [ l , ▁ r ] ▁ STRNEWLINE in " + " the ▁ given ▁ string ▁ are : ▁ " ) ; Console . WriteLine ( " and count is " CountCharacters ( str , l , r ) ) ; } }
using System ; class GFG { static void CountWords ( String str , int k ) { int sum = 0 ; int NumberOfWords = 0 ; int counter = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; ++ i ) { if ( str [ i ] == ' ▁ ' ) { if ( sum < k ) { counter ++ ; } sum = 0 ; NumberOfWords ++ ; } { sum += str [ i ] ; } } NumberOfWords ++ ; if ( sum < k ) { counter ++ ; } Console . WriteLine ( " Number ▁ of ▁ words ▁ having ▁ sum ▁ " + " of ▁ ASCII ▁ values ▁ less ▁ than ▁ k ▁ = ▁ " + counter ) ; Console . WriteLine ( " Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ " + " ASCII ▁ values ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ k ▁ = ▁ " + ( NumberOfWords - counter ) ) ; } public static void Main ( String [ ] args ) { String str = " Learn ▁ how ▁ to ▁ code " ; int k = 400 ; CountWords ( str , k ) ; } }
using System ; public class GFG { readonly static int MAX_CHAR = 26 ; static int countPalindrome ( String str ) { int n = str . Length ; int sum = 0 ; int [ ] hashTable = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { hashTable [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < 26 ; i ++ ) { if ( hashTable [ i ] != 0 ) { sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) / 2 ) ; } } return sum ; } public static void Main ( ) { String str = " ananananddd " ; Console . Write ( countPalindrome ( str ) ) ; } }
using System ; public class GFG { static int countConsecutive ( String s ) { int count = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { i ++ ; } else { count ++ ; } } return count ; } public static void Main ( ) { String str = "44522255" ; Console . WriteLine ( countConsecutive ( str ) ) ; } }
using System ; class GFG { static int check_digits ( int n ) { while ( n != 0 ) { return 0 ; n /= 10 ; } return 1 ; } static int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) == 1 ) return i ; } static void Main ( ) { int N = 2397 ; Console . WriteLine ( smallest_number ( N ) ) ; } }
using System ; class GFG { static int CountCharacters ( string str , int l , int r ) { int cnt = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( l <= str [ i ] && str [ i ] <= r ) { cnt ++ ; Console . Write ( str [ i ] + " ▁ " ) ; } } return cnt ; } public static void Main ( ) { string str = " geeksforgeeks " ; int l = 102 , r = 111 ; Console . Write ( " Characters ▁ with ▁ ASCII ▁ values " + " ▁ in ▁ the ▁ range ▁ [ l , ▁ r ] ▁ are ▁ STRNEWLINE " ) ; Console . Write ( " and count is " CountCharacters ( str , l , r ) ) ; } }
using System ; class GFG { static int minSteps ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . Length - 2 ; i ++ ) { if ( ( ( int ) str [ i ] ) == '0' ) { if ( str [ i + 1 ] == '1' ) { if ( str [ i + 2 ] == '0' ) { count ++ ; i += 2 ; } } } } return count ; } public static void Main ( ) { string str = "0101010" ; Console . Write ( minSteps ( str ) ) ; } }
using System ; class GFG { static int CountCharacters ( String str , int k ) { int cnt = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( ( ( int ) str [ i ] ) < k ) cnt ++ ; } return cnt ; } public static void Main ( ) { String str = " GeeksForGeeks " ; int k = 90 ; int count = CountCharacters ( str , k ) ; Console . WriteLine ( " Characters ▁ with ▁ ASCII ▁ values " + " less ▁ than ▁ K ▁ are ▁ " + count ) ; Console . WriteLine ( " Characters ▁ with ▁ ASCII ▁ values ▁ greater " + " than ▁ or ▁ equal ▁ to ▁ K ▁ are ▁ " + ( str . Length - count ) ) ; } }
using System ; class GFG { static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { f = f * i ; } return f ; } static int npr ( int n , int r ) { return fact ( n ) / fact ( n - r ) ; } static int countPermutations ( String str ) { int even = ( int ) Math . Floor ( ( double ) ( str . Length / 2 ) ) ; int odd = str . Length - even ; int ways = 0 ; int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < str . Length ; i ++ ) { freq [ ( int ) ( str [ i ] - ' a ' ) ] ++ ; } int nvowels = freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ; int nconsonants = str . Length - nvowels ; ways = npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ; return ways ; } static void Main ( ) { String str = " geeks " ; Console . WriteLine ( countPermutations ( str ) ) ; } }
using System ; class GFG { static bool isVowel ( char ch ) { if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' ) { return false ; } return true ; } static String replaceConsonants ( char [ ] s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ! isVowel ( s [ i ] ) ) { if ( s [ i ] == ' z ' ) { s [ i ] = ' b ' ; } else { s [ i ] = ( char ) ( s [ i ] + 1 ) ; if ( isVowel ( s [ i ] ) ) { s [ i ] = ( char ) ( s [ i ] + 1 ) ; } } } } return String . Join ( " " , s ) ; } public static void Main ( String [ ] args ) { String s = " geeksforgeeks " ; Console . WriteLine ( replaceConsonants ( s . ToCharArray ( ) ) ) ; } }
using System ; class GFG { public static int countOnOff ( string n ) { int [ ] Led = new int [ ] { 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 } ; int len = n . Length ; int sum = Led [ n [ 0 ] - '0' ] ; for ( int i = 1 ; i < len ; i ++ ) { sum = sum + Math . Abs ( Led [ n [ i ] - '0' ] - Led [ n [ i - 1 ] - '0' ] ) ; } return sum ; } public static void Main ( string [ ] args ) { string n = "082" ; Console . WriteLine ( countOnOff ( n ) ) ; } }
using System ; class GFG { static int max_length_substring ( string st , int n , int k ) { int max_len = 0 ; int len = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( st [ i ] == '0' ) len ++ ; else len = 0 ; max_len = Math . Max ( max_len , len ) ; } if ( max_len == n ) return n * k ; int pref = 0 , suff = 0 ; for ( int i = 0 ; st [ i ] == '0' ; ++ i , ++ pref ) ; for ( int i = n - 1 ; st [ i ] == '0' ; -- i , ++ suff ) ; if ( k > 1 ) max_len = Math . Max ( max_len , pref + suff ) ; return max_len ; } public static void Main ( string [ ] args ) { int n = 6 ; int k = 3 ; string st = "110010" ; int ans = max_length_substring ( st , n , k ) ; Console . WriteLine ( ans ) ; } }
using System ; class GFG { static int count ( string S , int X ) { int count = 0 ; int N = S . Length ; for ( int i = 0 ; i < N ; ++ i ) { if ( S [ i ] != '0' ) { for ( int len = 1 ; ( i + len ) <= N ; ++ len ) { int num = Int32 . Parse ( S . Substring ( i , len ) ) ; if ( num > X ) count ++ ; } } } return count ; } public static void Main ( String [ ] args ) { string S = "2222" ; int X = 97 ; Console . WriteLine ( count ( S , X ) ) ; } }
using System ; public class Solution { public static bool isBinary ( int n ) { while ( n != 0 ) { int temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = n / 10 ; } return true ; } public static void formBinaryStr ( int n , int [ ] a ) { bool flag = true ; string s = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( isBinary ( a [ i ] ) ) { s += " " + a [ i ] ; } else { flag = false ; break ; } } if ( flag ) { Console . Write ( s + " STRNEWLINE " ) ; } else { Console . Write ( " - 1 STRNEWLINE " ) ; } } public static void Main ( string [ ] args ) { int [ ] a = new int [ ] { 10 , 1 , 0 , 11 , 10 } ; int N = a . Length ; formBinaryStr ( N , a ) ; } }
using System ; public class GFG { static bool checkPalindrome ( String s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] != s [ ( s . Length - i - 1 ) ] ) return false ; } return true ; } static bool CheckOdd ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { String x = " " ; for ( int j = i ; j < n ; j ++ ) { x += s [ j ] ; if ( x . Length % 2 == 0 && checkPalindrome ( x ) == true ) return false ; } } return true ; } public static void Main ( ) { String s = " geeksforgeeks " ; if ( CheckOdd ( s ) ) Console . Write ( " YES " ) ; else Console . Write ( " NO " ) ; } }
using System ; class GFG { static int fact ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result *= i ; return result ; } static int getResult ( string str , char ch ) { int [ ] has = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) has [ i ] = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) has [ str [ i ] - ' A ' ] ++ ; int particular = has [ ch - ' A ' ] ; if ( particular == 0 ) return 0 ; has [ ch - ' A ' ] = 0 ; int total = str . Length ; total = total - particular + 1 ; int result = fact ( total ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( has [ i ] > 1 ) { result = result / fact ( has [ i ] ) ; } } return result ; } public static void Main ( ) { string str = " MISSISSIPPI " ; Console . WriteLine ( getResult ( str , ' S ' ) ) ; } }
using System ; class GFG { static long factorial ( long n ) { long res = 1 ; for ( int i = 1 ; i <= n ; i ++ ) res = res * i ; return res ; } static long count ( string word ) { int [ ] freq = new int [ 27 ] ; for ( int i = 0 ; i < 27 ; i ++ ) freq [ i ] = 0 ; long vowel = 0 , consonant = 0 ; for ( int i = 0 ; i < word . Length ; i ++ ) { freq [ word [ i ] - ' A ' ] ++ ; if ( word [ i ] == ' A ' word [ i ] == ' E ' word [ i ] == ' I ' word [ i ] == ' O ' word [ i ] == ' U ' ) { vowel ++ ; } else consonant ++ ; } long vowelArrange ; vowelArrange = factorial ( vowel ) ; vowelArrange /= factorial ( freq [ 0 ] ) ; vowelArrange /= factorial ( freq [ 4 ] ) ; vowelArrange /= factorial ( freq [ 8 ] ) ; vowelArrange /= factorial ( freq [ 14 ] ) ; vowelArrange /= factorial ( freq [ 20 ] ) ; long consonantArrange ; consonantArrange = factorial ( consonant ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 ) consonantArrange /= factorial ( freq [ i ] ) ; } long total = vowelArrange * consonantArrange ; return total ; } public static void Main ( ) { string word = " COMPUTER " ; long ans = count ( word ) ; Console . WriteLine ( ans ) ; } }
using System ; class GFG { static long productAscii ( String str ) { long prod = 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { prod *= str [ i ] ; } return prod ; } static public void Main ( ) { String str = " GfG " ; Console . Write ( productAscii ( str ) ) ; } }
using System ; class GFG { public static void balancedString ( String str ) { int count = 0 , i ; int n = str . Length ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) { Console . Write ( str [ i ] ) ; count ++ ; } else if ( str [ i ] == ' ) ' && count != 0 ) { Console . Write ( str [ i ] ) ; count -- ; } else if ( str [ i ] != ' ) ' ) Console . Write ( str [ i ] ) ; } if ( count != 0 ) for ( i = 0 ; i < count ; i ++ ) Console . Write ( " ) " ) ; } public static void Main ( ) { String str = " gau ) ra ) v ( ku ( mar ( rajput ) ) " ; balancedString ( str ) ; } }
using System ; class GFG { static int countStrings ( String s ) { int sum = 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( i % 2 == 0 && s [ i ] == ' $ ' ) sum *= 21 ; else if ( s [ i ] == ' $ ' ) sum *= 5 ; } return sum ; } public static void Main ( ) { String str = " s $ $ e $ " ; Console . WriteLine ( countStrings ( str ) ) ; } }
using System ; class GFG { static string removeDuplicatesFromString ( string string1 ) { int counter = 0 ; char [ ] str = string1 . ToCharArray ( ) ; int i = 0 ; int size = str . Length ; int x ; int length = 0 ; while ( i < size ) { x = str [ i ] - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = ( char ) ( ' a ' + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return ( new string ( str ) ) . Substring ( 0 , length ) ; } static void Main ( ) { string str = " geeksforgeeks " ; Console . WriteLine ( removeDuplicatesFromString ( str ) ) ; } }
using System ; class GFG { static int firstPos ( string str , int start , int end ) { int firstChar = - 1 ; for ( int i = start ; i <= end ; i ++ ) { if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { firstChar = i ; break ; } } return firstChar ; } static int lastPos ( string str , int start , int end ) { int lastChar = - 1 ; for ( int i = start ; i >= end ; i -- ) { if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { lastChar = i ; break ; } } return lastChar ; } static bool isPalindrome ( string str ) { int firstChar = 0 , lastChar = str . Length - 1 ; bool ch = true ; for ( int i = 0 ; i < str . Length ; i ++ ) { firstChar = firstPos ( str , firstChar , lastChar ) ; lastChar = lastPos ( str , lastChar , firstChar ) ; if ( lastChar < 0 firstChar < 0 ) break ; if ( str [ firstChar ] == str [ lastChar ] ) { firstChar ++ ; lastChar -- ; continue ; } ch = false ; break ; } return ch ; } public static void Main ( ) { string str = " m ▁ a ▁ 343 ▁ la ▁ y ▁ a ▁ l ▁ am " ; if ( isPalindrome ( str ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { public static int powerOfJump ( String s ) { int count = 1 ; int max_so_far = int . MinValue ; char ch = s [ s . Length - 1 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; } public static void Main ( ) { String st = "1010101" ; Console . WriteLine ( powerOfJump ( st ) ) ; } }
using System ; class GFG { public static int averageValue ( String s ) { int sum_char = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { sum_char += ( int ) s [ i ] ; } return sum_char / s . Length ; } public static void Main ( ) { String s = " GeeksforGeeks " ; Console . Write ( averageValue ( s ) ) ; } }
using System ; class GFG { static String commonPrefixUtil ( String str1 , String str2 ) { string result = " " ; int n1 = str1 . Length , n2 = str2 . Length ; for ( int i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 [ i ] != str2 [ j ] ) break ; result += ( str1 [ i ] ) ; } return ( result ) ; } static void commonPrefix ( String [ ] arr , int n ) { Array . Sort ( arr ) ; Console . Write ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) ; } public static void Main ( ) { String [ ] arr = { " geeksforgeeks " , " geeks " , " geek " , " geezer " } ; int n = arr . Length ; commonPrefix ( arr , n ) ; } }
using System ; class GFG { static String addBinaryUtil ( String a , String b ) { String result = " " ; int s = 0 ; int i = a . Length - 1 , j = b . Length - 1 ; while ( i >= 0 j >= 0 s == 1 ) { s += ( ( i >= 0 ) ? a [ i ] - '0' : 0 ) ; s += ( ( j >= 0 ) ? b [ j ] - '0' : 0 ) ; result = s % 2 + result ; s /= 2 ; i -- ; j -- ; } return result ; } static String addBinary ( String [ ] arr , int n ) { String result = " " ; for ( int i = 0 ; i < n ; i ++ ) { result = addBinaryUtil ( result , arr [ i ] ) ; } return result ; } public static void Main ( String [ ] args ) { String [ ] arr = { "1" , "10" , "11" } ; int n = arr . Length ; Console . WriteLine ( addBinary ( arr , n ) ) ; } }
using System ; class GFG { static int prefix ( String k , int n ) { int a = 0 , b = 0 , count = 0 ; int i = 0 ; int len = k . Length ; for ( i = 0 ; i < len ; i ++ ) { if ( k [ i ] == ' a ' ) a ++ ; if ( k [ i ] == ' b ' ) b ++ ; if ( a > b ) { count ++ ; } } if ( count == 0 n == 1 ) { Console . WriteLine ( count ) ; return 0 ; } if ( count == len a - b == 0 ) { Console . WriteLine ( count * n ) ; return 0 ; } int n2 = n - 1 , count2 = 0 ; while ( n2 != 0 ) { for ( i = 0 ; i < len ; i ++ ) { if ( k [ i ] == ' a ' ) a ++ ; if ( k [ i ] == ' b ' ) b ++ ; if ( a > b ) { count2 ++ ; } } count += count2 ; n2 -- ; if ( count2 == 0 ) break ; if ( count2 == len ) { count += ( n2 * count2 ) ; break ; } count2 = 0 ; } return count ; } public static void Main ( ) { string S = " aba " ; int N = 2 ; Console . WriteLine ( prefix ( S , N ) ) ; S = " baa " ; N = 3 ; Console . WriteLine ( prefix ( S , N ) ) ; } }
using System ; class GFG { static bool isCommonBase ( String Base , String s1 , String s2 ) { for ( int j = 0 ; j < s1 . Length ; ++ j ) { if ( Base [ j % Base . Length ] != s1 [ j ] ) { return false ; } } for ( int j = 0 ; j < s2 . Length ; ++ j ) { if ( Base [ j % Base . Length ] != s2 [ j ] ) { return false ; } } return true ; } static int countCommonBases ( String s1 , String s2 ) { int n1 = s1 . Length , n2 = s2 . Length ; int count = 0 ; for ( int i = 1 ; i <= Math . Min ( n1 , n2 ) ; i ++ ) { String Base = s1 . Substring ( 0 , i ) ; if ( isCommonBase ( Base , s1 , s2 ) ) { count ++ ; } } return count ; } public static void Main ( ) { String s1 = " pqrspqrs " ; String s2 = " pqrspqrspqrspqrs " ; Console . Write ( countCommonBases ( s1 , s2 ) ) ; } }
using System ; class GFG { static bool isPerfectSquareString ( string str ) { int sum = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) sum += ( int ) str [ i ] ; double squareRoot = Math . Sqrt ( sum ) ; double F = Math . Floor ( squareRoot ) ; return ( ( squareRoot - F ) == 0 ) ; } public static void Main ( ) { string str = " d " ; if ( isPerfectSquareString ( str ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool is_vow ( char c ) { return ( c == ' a ' ) || ( c == ' e ' ) || ( c == ' i ' ) || ( c == ' o ' ) || ( c == ' u ' ) ; } static void removeVowels ( string str ) { Console . Write ( str [ 0 ] ) ; for ( int i = 1 ; i < str . Length ; i ++ ) if ( ( ! is_vow ( str [ i - 1 ] ) ) || ( ! is_vow ( str [ i ] ) ) ) Console . Write ( str [ i ] ) ; } static void Main ( ) { string str = " geeks ▁ for ▁ geeks " ; removeVowels ( str ) ; } }
using System ; using System . Text ; using System . Collections . Generic ; class GFG { static bool transformString ( ref StringBuilder s ) { char ch = ' a ' ; if ( s . Length < 26 ) return false ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( int ) ch > 122 ) break ; if ( s [ i ] <= ch ) { s [ i ] = ch ; ch = ( char ) ( ( int ) ch + 1 ) ; } } if ( ch <= ' z ' ) return false ; return true ; } public static void Main ( ) { StringBuilder str = new StringBuilder ( " aaaaaaaaaaaaaaaaaaaaaaaaaa " ) ; if ( transformString ( ref str ) ) Console . WriteLine ( str + " STRNEWLINE " ) ; else Console . WriteLine ( " Not ▁ Possible " + " STRNEWLINE " ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int isPanDigital ( string s ) { int [ ] digits = new int [ 10 ] ; Array . Clear ( digits , 0 , 10 ) ; for ( int i = 0 ; i < s . Length ; i ++ ) digits [ s [ i ] - ( int ) '0' ] = 1 ; for ( int i = 0 ; i <= 9 ; i ++ ) if ( digits [ i ] == 0 ) return 0 ; return 1 ; } static int countPandigitalPairs ( ref List < string > v ) { int pairs = 0 ; for ( int i = 0 ; i < v . Count ; i ++ ) for ( int j = i + 1 ; j < v . Count ; j ++ ) if ( isPanDigital ( v [ i ] + v [ j ] ) == 1 ) pairs ++ ; return pairs ; } static void Main ( ) { List < string > v = new List < string > { "123567" , "098234" , "14765" , "19804" } ; Console . WriteLine ( countPandigitalPairs ( ref v ) ) ; } }
using System ; class GFG { static int MAX_CHAR = 26 ; public static int minChanges ( string str ) { int n = str . Length ; if ( n > MAX_CHAR ) return - 1 ; int dist_count = 0 ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( count [ str [ i ] - ' a ' ] == 0 ) dist_count ++ ; count [ str [ i ] - ' a ' ] ++ ; } return ( n - dist_count ) ; } public static void Main ( ) { string str = " aebaecedabbee " ; Console . WriteLine ( minChanges ( str ) ) ; } }
using System ; class GFG { static int numofstring ( int n , int m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * ( int ) Math . Pow ( m - 2 , n - 2 ) ; } public static void Main ( ) { int n = 2 , m = 3 ; Console . Write ( numofstring ( n , m ) ) ; } }
using System ; class GFG { public static int CountSpecialPalindrome ( String str ) { int n = str . Length ; int result = 0 ; int [ ] sameChar = new int [ n ] ; for ( int v = 0 ; v < n ; v ++ ) sameChar [ v ] = 0 ; int i = 0 ; while ( i < n ) { int sameCharCount = 1 ; int j = i + 1 ; while ( j < n && str [ i ] == str [ j ] ) { sameCharCount ++ ; j ++ ; } result += ( sameCharCount * ( sameCharCount + 1 ) / 2 ) ; sameChar [ i ] = sameCharCount ; i = j ; } for ( int j = 1 ; j < n ; j ++ ) { if ( str [ j ] == str [ j - 1 ] ) sameChar [ j ] = sameChar [ j - 1 ] ; if ( j > 0 && j < ( n - 1 ) && ( str [ j - 1 ] == str [ j + 1 ] && str [ j ] != str [ j - 1 ] ) ) result += Math . Min ( sameChar [ j - 1 ] , sameChar [ j + 1 ] ) ; } return result - n ; } public static void Main ( ) { String str = " abccba " ; Console . Write ( CountSpecialPalindrome ( str ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void printBracketNumber ( string exp , int n ) { int left_bnum = 1 ; Stack < int > right_bnum = new Stack < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( exp [ i ] == ' ( ' ) { Console . Write ( left_bnum + " ▁ " ) ; right_bnum . Push ( left_bnum ) ; left_bnum ++ ; } else if ( exp [ i ] == ' ) ' ) { Console . Write ( right_bnum . Peek ( ) + " ▁ " ) ; right_bnum . Pop ( ) ; } } } static void Main ( ) { string exp = " ( a + ( b * c ) ) + ( d / e ) " ; int n = exp . Length ; printBracketNumber ( exp , n ) ; } }
using System ; class GFG { static bool isCornerPresent ( string str , string corner ) { int n = str . Length ; int cl = corner . Length ; if ( n < cl ) return false ; return ( str . Substring ( 0 , cl ) . Equals ( corner ) && str . Substring ( n - cl , cl ) . Equals ( corner ) ) ; } static void Main ( ) { string str = " geeksforgeeks " ; string corner = " geeks " ; if ( isCornerPresent ( str , corner ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool isConvertible ( string str1 , string str2 , int k ) { if ( ( str1 . Length + str2 . Length ) < k ) return true ; int commonLength = 0 ; for ( int i = 0 ; i < Math . Min ( str1 . Length , str2 . Length ) ; i ++ ) { if ( str1 == str2 ) commonLength ++ ; else break ; } if ( ( k - str1 . Length - str2 . Length + 2 * commonLength ) % 2 == 0 ) return true ; return false ; } public static void Main ( ) { string str1 = " geek " ; string str2 = " geek " ; int k = 7 ; if ( isConvertible ( str1 , str2 , k ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; str1 = " geeks " ; str2 = " geek " ; k = 5 ; if ( isConvertible ( str1 , str2 , k ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int MAX_CHAR = 26 ; static int maxLower ( String str ) { int n = str . Length ; int i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { i ++ ; break ; } } int maxCount = 0 ; int [ ] count = new int [ MAX_CHAR ] ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { int currCount = 0 ; for ( int j = 0 ; j < MAX_CHAR ; j ++ ) { if ( count [ j ] > 0 ) { currCount ++ ; } } maxCount = Math . Max ( maxCount , currCount ) ; Array . Fill ( count , 0 ) ; } if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { count [ str [ i ] - ' a ' ] ++ ; } } return maxCount ; } public static void Main ( String [ ] args ) { String str = " zACaAbbaazzC " ; Console . WriteLine ( maxLower ( str ) ) ; } }
using System ; class GFG { static char first ( string str ) { for ( int i = 0 ; i < str . Length ; i ++ ) if ( char . IsUpper ( str [ i ] ) ) return str [ i ] ; return '0' ; } public static void Main ( ) { string str = " geeksforGeeKS " ; char res = first ( str ) ; if ( res == '0' ) Console . WriteLine ( " No ▁ uppercase " + " ▁ letter " ) ; else Console . WriteLine ( res ) ; } }
using System ; class GFG { static int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { int decimalValue = 0 ; int powerOf2 = 1 ; for ( int k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - '0' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; } public static void Main ( ) { String str = "10010" ; int n = 5 ; Console . WriteLine ( evenDecimalValue ( str , n ) ) ; } }
using System ; class GFG { public static void solve ( string s ) { int l = s . Length ; int x = l / 2 ; int y = l ; string p = " " ; while ( x > 0 && y > l / 2 ) { char ch = s [ x - 1 ] ; p += ch ; x -- ; ch = s [ y - 1 ] ; p += ch ; y -- ; } if ( y > l / 2 ) { char ch = s [ x - 1 ] ; p += ch ; y -- ; } Console . WriteLine ( p ) ; } public static void Main ( ) { string s = " sunshine " ; solve ( s ) ; } }
using System ; public class GFG { private static int recLen ( string str ) { if ( str . Equals ( " " ) ) return 0 ; else return recLen ( str . Substring ( 1 ) ) + 1 ; } public static void Main ( ) { string str = " GeeksforGeeks " ; Console . WriteLine ( recLen ( str ) ) ; } }
using System ; class GFG { static bool isConsonant ( char ch ) { ch = Char . ToUpper ( ch ) ; return ! ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) && ch >= 65 && ch <= 90 ; } static int totalConsonants ( String str ) { int count = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( isConsonant ( str [ i ] ) ) ++ count ; return count ; } public static void Main ( ) { String str = " abc ▁ de " ; Console . Write ( totalConsonants ( str ) ) ; } }
using System ; public class GfG { public static long reverseBits ( long n ) { long rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( ( n & 1 ) == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } public static bool isPalindrome ( long n ) { long rev = reverseBits ( n ) ; return ( n == rev ) ; } public static void Main ( ) { long n = 9 ; if ( isPalindrome ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class Geek { static void solve ( int n , int t , char [ ] s ) { for ( int i = 0 ; i < t ; i ++ ) for ( int j = 0 ; j < n - 1 ; j ++ ) if ( s [ j ] == ' B ' && s [ j + 1 ] == ' G ' ) { char temp = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = temp ; j ++ ; } Console . Write ( s ) ; } public static void Main ( String [ ] args ) { int n = 6 , t = 2 ; String s = " BBGBBG " ; char [ ] str = s . ToCharArray ( ) ; solve ( n , t , str ) ; } }
using System ; class GFG { static int calSumUtil ( int [ ] a , int [ ] b , int n , int m ) { int [ ] sum = new int [ n ] ; int i = n - 1 , j = m - 1 , k = n - 1 ; int carry = 0 , s = 0 ; while ( j >= 0 ) { s = a [ i ] + b [ j ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; k -- ; i -- ; j -- ; } while ( i >= 0 ) { s = a [ i ] + carry ; sum [ k ] = ( s % 10 ) ; carry = s / 10 ; i -- ; k -- ; } int ans = 0 ; if ( carry == 1 ) ans = 10 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { ans += sum [ i ] ; ans *= 10 ; } return ans / 10 ; } static int calSum ( int [ ] a , int [ ] b , int n , int m ) { if ( n >= m ) return calSumUtil ( a , b , n , m ) ; else return calSumUtil ( b , a , m , n ) ; } public static void Main ( ) { int [ ] a = { 9 , 3 , 9 } ; int [ ] b = { 6 , 1 } ; int n = a . Length ; int m = b . Length ; Console . WriteLine ( calSum ( a , b , n , m ) ) ; } }
using System ; class GFG { static int SIZE = 26 ; static int longCommomAnagramSubseq ( string str1 , string str2 , int n1 , int n2 ) { int [ ] freq1 = new int [ SIZE ] ; int [ ] freq2 = new int [ SIZE ] ; for ( int i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } int len = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < SIZE ; i ++ ) len += Math . Min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; } static void Main ( ) { string str1 = " abdacp " ; string str2 = " ckamb " ; int n1 = str1 . Length ; int n2 = str2 . Length ; Console . Write ( " Length ▁ = ▁ " + longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) ) ; } }
using System ; class GFG { static bool isPanalphabeticWindow ( string s , int n ) { char ch = ' a ' ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch ++ ; if ( ch == ' z ' + 1 ) return true ; } return false ; } public static void Main ( ) { string s = " abujm ▁ zvcd ▁ acefc ▁ deghf " + " ▁ gijklem ▁ n ▁ o ▁ p ▁ pafqrstuvwxyzfap " ; int n = s . Length ; if ( isPanalphabeticWindow ( s , n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static void prime_index ( string input ) { int n = input . Length ; for ( int i = 2 ; i <= n ; i ++ ) if ( isPrime ( i ) ) Console . Write ( input [ i - 1 ] ) ; } public static void Main ( ) { string input = " GeeksforGeeks " ; prime_index ( input ) ; } }
using System ; class GFG { static bool isHeterogram ( string s , int n ) { int [ ] hash = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != ' ▁ ' ) { if ( hash [ s [ i ] - ' a ' ] == 0 ) hash [ s [ i ] - ' a ' ] = 1 ; else return false ; } } return true ; } public static void Main ( ) { string s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " ; int n = s . Length ; if ( isHeterogram ( s , n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GeeksforGeeks { static void ASCIISentence ( string str ) { int l = str . Length ; int convert ; for ( int i = 0 ; i < l ; i ++ ) { convert = str [ i ] ; Console . Write ( convert ) ; } } public static void Main ( ) { string str = " GeeksforGeeks " ; Console . WriteLine ( " ASCII ▁ Sentence : " ) ; ASCIISentence ( str ) ; } }
using System ; class GFG { static void convert ( string str ) { int n = str . Length ; string str1 = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ▁ ' ) str1 = str1 + ' _ ' ; else str1 = str1 + Char . ToLower ( str [ i ] ) ; } Console . Write ( str1 ) ; } static void Main ( ) { string str = " I ▁ got ▁ intern ▁ at ▁ geeksforgeeks " ; convert ( str ) ; } }
using System ; public class GFG { static String replace ( String s , char c1 , char c2 ) { int l = s . Length ; char [ ] arr = s . ToCharArray ( ) ; for ( int i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return string . Join ( " " , arr ) ; } public static void Main ( ) { String s = " grrksfoegrrks " ; char c1 = ' e ' , c2 = ' r ' ; Console . WriteLine ( replace ( s , c1 , c2 ) ) ; } }
using System ; class GFG { static String constructPalin ( char [ ] str , int len ) { int i = 0 , j = len - 1 ; for ( ; i < j ; i ++ , j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != ' * ' ) continue ; else if ( str [ i ] == str [ j ] && str [ i ] == ' * ' ) { str [ i ] = ' a ' ; str [ j ] = ' a ' ; continue ; } else if ( str [ i ] == ' * ' ) { str [ i ] = str [ j ] ; continue ; } else if ( str [ j ] == ' * ' ) { str [ j ] = str [ i ] ; continue ; } Console . WriteLine ( " Not ▁ Possible " ) ; return " " ; } return String . Join ( " " , str ) ; } public static void Main ( String [ ] args ) { String str = " bca * xc * * b " ; int len = str . Length ; Console . WriteLine ( constructPalin ( str . ToCharArray ( ) , len ) ) ; } }
using System ; class GFG { static int max = 100 ; static void carveCross ( String str ) { int n = str . Length ; if ( n % 2 == 0 ) { Console . Write ( " Not ▁ possible . ▁ Please ▁ enter ▁ " + " odd ▁ length ▁ string . " ) ; } else { char [ , ] arr = new char [ max , max ] ; int m = n / 2 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { arr [ i , j ] = ' X ' ; } } for ( int i = 0 ; i < n ; i ++ ) { arr [ i , m ] = str [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { arr [ m , i ] = str [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( arr [ i , j ] + " ▁ " ) ; } Console . WriteLine ( ) ; } } } public static void Main ( ) { string str = " PICTURE " ; carveCross ( str ) ; } }
using System ; class GFG { static int remainder ( string str ) { int len = str . Length ; int num , rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - '0' ) ; rem = num % 11 ; } return rem ; } public static void Main ( ) { string str = "3435346456547566345436457867978" ; Console . WriteLine ( remainder ( str ) ) ; } }
using System ; public class GFG { static void findPermutations ( char [ ] str , int index , int n ) { if ( index >= n || ( index + 1 ) >= n ) { Console . WriteLine ( str ) ; return ; } findPermutations ( str , index + 1 , n ) ; swap ( str , index ) ; findPermutations ( str , index + 2 , n ) ; swap ( str , index ) ; } static void swap ( char [ ] arr , int index ) { char temp = arr [ index ] ; arr [ index ] = arr [ index + 1 ] ; arr [ index + 1 ] = temp ; } public static void Main ( ) { char [ ] str = "12345" . ToCharArray ( ) ; int n = str . Length ; findPermutations ( str , 0 , n ) ; } }
using System ; class GFG { static bool isUnique ( int [ ] a , int n , int k ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; } static public void Main ( ) { int [ ] a = { 3 , 3 , 3 } ; int n = a . Length ; int k = 12 ; if ( isUnique ( a , n , k ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool isPalindrome ( String s , int i , int j ) { int p = j ; for ( int k = i ; k <= p ; k ++ ) { if ( s [ k ] != s [ p ] ) return false ; p -- ; } return true ; } static int countWays ( String s ) { int n = s . Length ; int count = 0 ; if ( isPalindrome ( s , 0 , n - 1 ) ) { for ( int i = n / 2 ; i < n ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) count ++ ; else break ; } if ( n % 2 == 0 ) { count ++ ; count = 2 * count + 1 ; } else count = 2 * count + 2 ; } else { for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( s [ i ] != s [ n - 1 - i ] ) { int j = n - 1 - i ; if ( isPalindrome ( s , i , n - 2 - i ) ) { for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( s [ k ] != s [ j ] ) break ; count ++ ; } count ++ ; } if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) { for ( int k = n - i ; k < n ; k ++ ) { if ( s [ k ] != s [ i ] ) break ; count ++ ; } count ++ ; } break ; } } } return count ; } public static void Main ( ) { String s = " abca " ; Console . Write ( countWays ( s ) ) ; } }
using System ; public class GFG { static int countOfSubstringWithKOnes ( string s , int K ) { int N = s . Length ; int res = 0 ; int countOfOne = 0 ; int [ ] freq = new int [ N + 1 ] ; freq [ 0 ] = 1 ; for ( int i = 0 ; i < N ; i ++ ) { countOfOne += ( s [ i ] - '0' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; } static public void Main ( ) { string s = "10010" ; int K = 1 ; Console . WriteLine ( countOfSubstringWithKOnes ( s , K ) ) ; } }
using System ; class GFG { public static void reverse ( char [ ] num , int i , int j ) { while ( i < j ) { char temp = num [ i ] ; num [ i ] = num [ j ] ; num [ j ] = temp ; i ++ ; j -- ; } } public static void nextPalin ( char [ ] num , int n ) { if ( n <= 3 ) { Console . WriteLine ( " Not ▁ Possible " ) ; return ; } char temp ; int mid = n / 2 - 1 ; int i , j ; for ( i = mid - 1 ; i >= 0 ; i -- ) if ( num [ i ] < num [ i + 1 ] ) break ; if ( i < 0 ) { Console . WriteLine ( " Not ▁ Possible " ) ; return ; } int smallest = i + 1 ; for ( j = i + 2 ; j <= mid ; j ++ ) if ( num [ j ] > num [ i ] && num [ j ] < num [ smallest ] ) smallest = j ; temp = num [ i ] ; num [ i ] = num [ smallest ] ; num [ smallest ] = temp ; temp = num [ n - i - 1 ] ; num [ n - i - 1 ] = num [ n - smallest - 1 ] ; num [ n - smallest - 1 ] = temp ; reverse ( num , i + 1 , mid ) ; if ( n % 2 == 0 ) reverse ( num , mid + 1 , n - i - 2 ) ; else reverse ( num , mid + 2 , n - i - 2 ) ; String result = new String ( num ) ; Console . WriteLine ( " Next ▁ Palindrome : ▁ " + result ) ; } public static void Main ( ) { String str = "4697557964" ; char [ ] num = str . ToCharArray ( ) ; int n = str . Length ; nextPalin ( num , n ) ; } }
using System ; class GFG { static void printRec ( String number , int extraOnes , int remainingPlaces ) { if ( 0 == remainingPlaces ) { Console . Write ( number + " ▁ " ) ; return ; } printRec ( number + "1" , extraOnes + 1 , remainingPlaces - 1 ) ; if ( 0 < extraOnes ) printRec ( number + "0" , extraOnes - 1 , remainingPlaces - 1 ) ; } static void printNums ( int n ) { String str = " " ; printRec ( str , 0 , n ) ; } public static void Main ( ) { int n = 4 ; printNums ( n ) ; } }
using System ; using System . Collections . Generic ; class stem { public static String findstem ( String [ ] arr ) { int n = arr . Length ; String s = arr [ 0 ] ; int len = s . Length ; String res = " " ; for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i + 1 ; j <= len ; j ++ ) { String stem = s . Substring ( i , j - i ) ; int k = 1 ; for ( k = 1 ; k < n ; k ++ ) if ( ! arr [ k ] . Contains ( stem ) ) break ; if ( k == n && res . Length < stem . Length ) res = stem ; } } return res ; } public static void Main ( String [ ] args ) { String [ ] arr = { " grace " , " graceful " , " disgraceful " , " gracefully " } ; String stems = findstem ( arr ) ; Console . WriteLine ( stems ) ; } }
using System ; class GFG { static String nextHighUsingAtMostOneSwap ( String st ) { char [ ] num = st . ToCharArray ( ) ; int l = num . Length ; int posRMax = l - 1 ; int index = - 1 ; for ( int i = l - 2 ; i >= 0 ; i -- ) { if ( num [ i ] >= num [ posRMax ] ) posRMax = i ; else { index = i ; break ; } } if ( index == - 1 ) return " Not ▁ Possible " ; int greatSmallDgt = - 1 ; for ( int i = l - 1 ; i > index ; i -- ) { if ( num [ i ] > num [ index ] ) { if ( greatSmallDgt == - 1 ) greatSmallDgt = i ; else if ( num [ i ] <= num [ greatSmallDgt ] ) greatSmallDgt = i ; } } char temp = num [ index ] ; num [ index ] = num [ greatSmallDgt ] ; num [ greatSmallDgt ] = temp ; string res = new string ( num ) ; return res ; } public static void Main ( ) { String num = "218765" ; Console . WriteLine ( " Original ▁ number : ▁ " + num ) ; Console . WriteLine ( " Next ▁ higher ▁ number : ▁ " + nextHighUsingAtMostOneSwap ( num ) ) ; } }
using System ; class GFG { static bool isVowel ( char c ) { return ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } static int longestVowel ( String str ) { int count = 0 , res = 0 ; char [ ] s = str . ToCharArray ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( isVowel ( s [ i ] ) ) count ++ ; else { res = Math . Max ( res , count ) ; count = 0 ; } } return Math . Max ( res , count ) ; } public static void Main ( ) { String s = " theeare " ; Console . Write ( longestVowel ( s ) ) ; } }
using System ; class GFG { static int MAX_CHAR = 26 ; static bool check ( int [ ] freq , int k ) { for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] != 0 && freq [ i ] != k ) return false ; return true ; } static int substrings ( String s , int k ) { for ( int i = 0 ; i < s . Length ; i ++ ) { int [ ] freq = new int [ MAX_CHAR ] ; for ( int j = i ; j < s . Length ; j ++ ) { int index = s [ j ] - ' a ' ; freq [ index ] ++ ; if ( freq [ index ] > k ) break ; else if ( freq [ index ] == k && check ( freq , k ) == true ) res ++ ; } } return res ; } public static void Main ( String [ ] args ) { String s = " aabbcc " ; int k = 2 ; Console . WriteLine ( substrings ( s , k ) ) ; s = " aabbc " ; k = 2 ; Console . WriteLine ( substrings ( s , k ) ) ; } }
using System ; class GFG { static int countSubstrs ( string str , int i , int j , int n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; int res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; } public static void Main ( ) { string str = " abcab " ; int n = str . Length ; Console . WriteLine ( countSubstrs ( str , 0 , n - 1 , n ) ) ; } }
using System ; public class GFG { static int countManipulations ( string s1 , string s2 ) { int count = 0 ; int [ ] char_count = new int [ 26 ] ; for ( int i = 0 ; i < s1 . Length ; i ++ ) char_count [ s1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < s2 . Length ; i ++ ) char_count [ s2 [ i ] - ' a ' ] -- ; for ( int i = 0 ; i < 26 ; ++ i ) { if ( char_count [ i ] != 0 ) { count += Math . Abs ( char_count [ i ] ) ; } } return count / 2 ; } public static void Main ( ) { string s1 = " ddcf " ; string s2 = " cedk " ; Console . WriteLine ( countManipulations ( s1 , s2 ) ) ; } }
using System ; class First_Palin { static int MAX_CHAR = 26 ; static char stringPalindrome ( string A , string B ) { int [ ] countA = new int [ MAX_CHAR ] ; int [ ] countB = new int [ MAX_CHAR ] ; int l1 = A . Length ; int l2 = B . Length ; for ( int i = 0 ; i < l1 ; i ++ ) countA [ A [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) countB [ B [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' A ' ; return ' B ' ; } public static void Main ( ) { string a = " abcdea " ; string b = " bcdesg " ; Console . WriteLine ( stringPalindrome ( a , b ) ) ; } }
using System ; class GFG { static int MAX_CHAR = 256 ; static int countBalance ( string s ) { int [ ] rightVisited = new int [ MAX_CHAR ] ; int [ ] leftVisited = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) rightVisited [ s [ i ] ] ++ ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { leftVisited [ s [ i ] ] ++ ; rightVisited [ s [ i ] ] -- ; int j ; for ( j = 0 ; j < MAX_CHAR ; j ++ ) { if ( ( leftVisited [ j ] == 0 && rightVisited [ j ] != 0 ) || ( leftVisited [ j ] != 0 && rightVisited [ j ] == 0 ) ) break ; } if ( j == MAX_CHAR ) res ++ ; } return res ; } public static void Main ( String [ ] args ) { string str = " abaababa " ; Console . WriteLine ( countBalance ( str ) ) ; } }
using System ; public class GFG { static int findFlips ( String str , int n ) { char last = ' ▁ ' ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( last != str [ i ] ) res ++ ; last = str [ i ] ; } return res / 2 ; } public static void Main ( ) { String str = "00011110001110" ; int n = str . Length ; Console . Write ( findFlips ( str , n ) ) ; } }
using System ; class GFG { public static int findLen ( string A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ; while ( r < n ) { if ( A [ r ] != ch ) { ++ cnt ; } while ( cnt > k ) { if ( A [ l ] != ch ) { -- cnt ; } ++ l ; } maxlen = Math . Max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; } public static int answer ( string A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = Math . Max ( maxlen , findLen ( A , n , k , ( char ) ( i + ' A ' ) ) ) ; maxlen = Math . Max ( maxlen , findLen ( A , n , k , ( char ) ( i + ' a ' ) ) ) ; } return maxlen ; } public static void Main ( string [ ] args ) { int n = 5 , k = 2 ; string A = " ABABA " ; Console . WriteLine ( " Maximum ▁ length ▁ = ▁ " + answer ( A , n , k ) ) ; n = 6 ; k = 4 ; string B = " HHHHHH " ; Console . WriteLine ( " Maximum ▁ length ▁ = ▁ " + answer ( B , n , k ) ) ; } }
using System ; class GFG { static int MAX_CHAR = 26 ; static bool checkCorrectOrNot ( string s ) { int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int n = s . Length ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s [ i ] - ' a ' ] ++ ; count2 [ s [ j ] - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; } public static void Main ( ) { string s = " abab " ; if ( checkCorrectOrNot ( s ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static String maximumNum ( string curr_num , string res ) { int len1 = curr_num . Length ; int len2 = res . Length ; if ( len1 == len2 ) { int i = 0 ; while ( curr_num [ i ] == res [ i ] ) i ++ ; if ( curr_num [ i ] < res [ i ] ) return res ; else return curr_num ; } return len1 < len2 ? res : curr_num ; } static string extractMaximum ( string str ) { int n = str . Length ; string curr_num = " " ; string res = " " ; for ( int i = 0 ; i < n ; i ++ ) { while ( i < n && str [ i ] == '0' ) i ++ ; while ( i < n && Char . IsDigit ( str [ i ] ) ) { curr_num = curr_num + str [ i ] ; i ++ ; } if ( i == n ) break ; if ( curr_num . Length > 0 ) i -- ; res = maximumNum ( curr_num , res ) ; curr_num = " " ; } if ( curr_num . Length == 0 && res . Length == 0 ) res = res + '0' ; return maximumNum ( curr_num , res ) ; } public static void Main ( ) { string str = "100klh564abc365bg " ; Console . WriteLine ( extractMaximum ( str ) ) ; } }
using System ; class Test { static bool isDivisible999 ( String num ) { int n = num . Length ; if ( n == 0 && num [ 0 ] == '0' ) return true ; if ( n % 3 == 1 ) num = "00" + num ; if ( n % 3 == 2 ) num = "0" + num ; int gSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int group = 0 ; group += ( num [ i ++ ] - '0' ) * 100 ; group += ( num [ i ++ ] - '0' ) * 10 ; group += num [ i ] - '0' ; gSum += group ; } if ( gSum > 1000 ) { num = Convert . ToString ( gSum ) ; n = num . Length ; gSum = isDivisible999 ( num ) ? 1 : 0 ; } return ( gSum == 999 ) ; } public static void Main ( ) { String num = "1998" ; Console . WriteLine ( isDivisible999 ( num ) ? " Divisible " : " Not ▁ divisible " ) ; } }
using System ; class GFG { static int MAX_CHAR = 26 ; static String arrangeString ( string str ) { int [ ] char_count = new int [ MAX_CHAR ] ; int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( char . IsUpper ( str [ i ] ) ) char_count [ str [ i ] - ' A ' ] ++ ; else sum = sum + ( str [ i ] - '0' ) ; } string res = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { char ch = ( char ) ( ' A ' + i ) ; while ( char_count [ i ] -- != 0 ) res = res + ch ; } if ( sum > 0 ) res = res + sum ; return res ; } public static void Main ( ) { string str = " ACCBA10D2EW30" ; Console . Write ( arrangeString ( str ) ) ; } }
using System ; public class GFG { static void subString ( string str , int n ) { for ( int len = 1 ; len <= n ; len ++ ) { for ( int i = 0 ; i <= n - len ; i ++ ) { int j = i + len - 1 ; for ( int k = i ; k <= j ; k ++ ) Console . Write ( str [ k ] ) ; Console . WriteLine ( ) ; } } } static public void Main ( ) { string str = " abc " ; subString ( str , str . Length ) ; } }
using System ; class GFG { public static bool isVowel ( char ch ) { ch = char . ToUpper ( ch ) ; return ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) ; } public static int countVowels ( string str ) { int count = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( isVowel ( str [ i ] ) ) { ++ count ; } } return count ; } public static void Main ( string [ ] args ) { string str = " abc ▁ de " ; Console . WriteLine ( countVowels ( str ) ) ; } }
using System ; using System . Text ; class GFG { public static void printRotatedString ( string str ) { int len = str . Length ; StringBuilder sb ; for ( int i = 0 ; i < len ; i ++ ) { sb = new StringBuilder ( ) ; int j = i ; int k = 0 ; for ( int k2 = j ; k2 < str . Length ; k2 ++ ) { sb . Insert ( k , str [ j ] ) ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { sb . Insert ( k , str [ j ] ) ; j ++ ; k ++ ; } Console . WriteLine ( sb ) ; } } public static void Main ( string [ ] args ) { string str = " geeks " ; printRotatedString ( str ) ; } }
using System ; class GFG { static bool isPalindrome ( String str ) { int n = str . Length ; for ( int i = 0 ; i < n / 2 ; i ++ ) if ( str [ i ] != str [ n - i - 1 ] ) return false ; return true ; } static int maxLengthNonPalinSubstring ( String str ) { int n = str . Length ; char ch = str [ 0 ] ; int i = 1 ; for ( i = 1 ; i < n ; i ++ ) if ( str [ i ] != ch ) break ; if ( i == n ) return 0 ; if ( isPalindrome ( str ) ) return n - 1 ; return n ; } public static void Main ( ) { String str = " abba " ; Console . Write ( " Maximum ▁ Length ▁ = ▁ " + maxLengthNonPalinSubstring ( str ) ) ; } }
using System ; class GFG { static void isKthBitSet ( int n , int k ) { if ( ( ( n >> ( k - 1 ) ) & 1 ) > 0 ) Console . WriteLine ( " SET " ) ; else Console . WriteLine ( " NOT ▁ SET " ) ; } static public void Main ( ) { int n = 5 , k = 1 ; isKthBitSet ( n , k ) ; } }
using System ; class GFG { static int MAX_CHAR = 26 ; static void countFreq ( string str , int [ ] freq , int len ) { for ( int i = 0 ; i < len ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } } static bool canMakePalindrome ( int [ ] freq , int len ) { int count_odd = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { count_odd ++ ; } } if ( len % 2 == 0 ) { if ( count_odd > 0 ) { return false ; } else { return true ; } } if ( count_odd != 1 ) { return false ; } return true ; } static string findOddAndRemoveItsFreq ( int [ ] freq ) { string odd_str = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { freq [ i ] -- ; odd_str = odd_str + ( char ) ( i + ' a ' ) ; return odd_str ; } } return odd_str ; } static string findPalindromicString ( string str ) { int len = str . Length ; int [ ] freq = new int [ MAX_CHAR ] ; countFreq ( str , freq , len ) ; if ( ! canMakePalindrome ( freq , len ) ) { return " No ▁ Palindromic ▁ String " ; } string odd_str = findOddAndRemoveItsFreq ( freq ) ; string front_str = " " , rear_str = " ▁ " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { String temp = " " ; if ( freq [ i ] != 0 ) { char ch = ( char ) ( i + ' a ' ) ; for ( int j = 1 ; j <= freq [ i ] / 2 ; j ++ ) { temp = temp + ch ; } front_str = front_str + temp ; rear_str = temp + rear_str ; } } return ( front_str + odd_str + rear_str ) ; } public static void Main ( ) { string str = " malayalam " ; Console . Write ( findPalindromicString ( str ) ) ; } }
using System ; class GFG { static bool checkEquality ( string s ) { return ( s [ 0 ] == s [ s . Length - 1 ] ) ; } static int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) for ( int len = 1 ; len <= n - i ; len ++ ) if ( checkEquality ( s . Substring ( i , len ) ) ) result ++ ; return result ; } public static void Main ( ) { string s = " abcab " ; Console . WriteLine ( countSubstringWithEqualEnds ( s ) ) ; } }
using System ; public class GFG { static int countSubstringWithEqualEnds ( string s ) { int result = 0 ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s [ i ] == s [ j ] ) result ++ ; return result ; } public static void Main ( ) { string s = " abcab " ; Console . Write ( countSubstringWithEqualEnds ( s ) ) ; } }
using System ; class GFG { static char maxRepeating ( string str ) { int len = str . Length ; int count = 0 ; char res = str [ 0 ] ; for ( int i = 0 ; i < len ; i ++ ) { int cur_count = 1 ; for ( int j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] != str [ j ] ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } } return res ; } public static void Main ( ) { string str = " aaaabbaaccde " ; Console . Write ( maxRepeating ( str ) ) ; } }
using System ; class GFG { static string findSum ( string str1 , string str2 ) { if ( str1 . Length > str2 . Length ) { string t = str1 ; str1 = str2 ; str2 = t ; } string str = " " ; int n1 = str1 . Length , n2 = str2 . Length ; char [ ] ch = str1 . ToCharArray ( ) ; Array . Reverse ( ch ) ; str1 = new string ( ch ) ; char [ ] ch1 = str2 . ToCharArray ( ) ; Array . Reverse ( ch1 ) ; str2 = new string ( ch1 ) ; int carry = 0 ; for ( int i = 0 ; i < n1 ; i ++ ) { int sum = ( ( int ) ( str1 [ i ] - '0' ) + ( int ) ( str2 [ i ] - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n1 ; i < n2 ; i ++ ) { int sum = ( ( int ) ( str2 [ i ] - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; char [ ] ch2 = str . ToCharArray ( ) ; Array . Reverse ( ch2 ) ; str = new string ( ch2 ) ; return str ; } static void Main ( ) { string str1 = "12" ; string str2 = "198111" ; Console . WriteLine ( findSum ( str1 , str2 ) ) ; } }
using System ; class GFG { static string findSum ( string str1 , string str2 ) { if ( str1 . Length > str2 . Length ) { string t = str1 ; str1 = str2 ; str2 = t ; } string str = " " ; int n1 = str1 . Length , n2 = str2 . Length ; int diff = n2 - n1 ; int carry = 0 ; for ( int i = n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str1 [ i ] - '0' ) + ( int ) ( str2 [ i + diff ] - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } for ( int i = n2 - n1 - 1 ; i >= 0 ; i -- ) { int sum = ( ( int ) ( str2 [ i ] - '0' ) + carry ) ; str += ( char ) ( sum % 10 + '0' ) ; carry = sum / 10 ; } if ( carry > 0 ) str += ( char ) ( carry + '0' ) ; char [ ] ch2 = str . ToCharArray ( ) ; Array . Reverse ( ch2 ) ; return new string ( ch2 ) ; } static void Main ( ) { string str1 = "12" ; string str2 = "198111" ; Console . WriteLine ( findSum ( str1 , str2 ) ) ; } }
using System ; class GFG { static bool areChractersUnique ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; ++ i ) { int val = ( str [ i ] - ' a ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; } public static void Main ( ) { string s = " aaabbccdaa " ; if ( areChractersUnique ( s ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; public class GFG { static int countWords ( string str , int len ) { int count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( int j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; } public static void Main ( ) { string str = " abc " ; int len = str . Length ; Console . WriteLine ( countWords ( str , len ) ) ; } }
using System ; class GFG { static int replaceDig ( int x , int from , int to ) { int result = 0 ; int multiply = 1 ; while ( x > 0 ) { int reminder = x % 10 ; if ( reminder == from ) result = result + to * multiply ; else result = result + reminder * multiply ; multiply *= 10 ; x = x / 10 ; } return result ; } static void calculateMinMaxSum ( int x1 , int x2 ) { int minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) ; int maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) ; Console . Write ( " Minimum ▁ sum ▁ = ▁ " + minSum ) ; Console . Write ( " STRNEWLINE Maximum ▁ sum ▁ = ▁ " + maxSum ) ; } public static void Main ( ) { int x1 = 5466 , x2 = 4555 ; calculateMinMaxSum ( x1 , x2 ) ; } }
using System ; class GFG { static void qType1 ( int l , int x , char [ ] str ) { str [ l - 1 ] = ( char ) x ; } static void qType2 ( int l , int r , char [ ] str ) { int [ ] freq = new int [ 27 ] ; for ( int i = l - 1 ; i <= r - 1 ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } int count = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( freq [ j ] % 2 != 0 ) { count ++ ; } } if ( count <= 1 ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } public static void Main ( String [ ] args ) { char [ ] str = " geeksforgeeks " . ToCharArray ( ) ; int n = str . Length ; qType1 ( 4 , ' g ' , str ) ; qType2 ( 1 , 4 , str ) ; qType2 ( 2 , 3 , str ) ; qType1 ( 10 , ' t ' , str ) ; qType2 ( 10 , 11 , str ) ; } }
using System ; using System . Text ; class GFG { public static string findTwoscomplement ( StringBuilder str ) { int n = str . Length ; int i ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '1' ) { break ; } } if ( i == - 1 ) { return "1" + str ; } for ( int k = i - 1 ; k >= 0 ; k -- ) { if ( str [ k ] == '1' ) { str . Remove ( k , k + 1 - k ) . Insert ( k , "0" ) ; } else { str . Remove ( k , k + 1 - k ) . Insert ( k , "1" ) ; } } return str . ToString ( ) ; } public static void Main ( string [ ] args ) { StringBuilder str = new StringBuilder ( "00000101" ) ; Console . WriteLine ( findTwoscomplement ( str ) ) ; } }
using System ; class GFG { static bool isequal ( string str ) { int n = str . Length ; int num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( '0' <= str [ i ] && str [ i ] <= '9' ) { num = ( str [ i ] - '0' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; } static public void Main ( ) { string str = " geeksforgeeks13" ; if ( isequal ( str ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class GFG { static int countToMake0lternate ( string s ) { int result = 0 ; for ( int i = 0 ; i < ( s . Length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; } static public void Main ( ) { Console . WriteLine ( countToMake0lternate ( "000111" ) ) ; Console . WriteLine ( countToMake0lternate ( "11111" ) ) ; Console . WriteLine ( countToMake0lternate ( "01010101" ) ) ; } }
using System ; public class GFG { static bool isPossiblePalindrome ( char [ ] str ) { int n = str . Length ; for ( int i = 0 ; i < n / 2 ; i ++ ) { if ( str [ i ] != ' . ' && str [ n - i - 1 ] != ' . ' && str [ i ] != str [ n - i - 1 ] ) return false ; } return true ; } static void smallestPalindrome ( char [ ] str ) { if ( ! isPossiblePalindrome ( str ) ) Console . WriteLine ( " Not ▁ Possible " ) ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' . ' ) { if ( str [ n - i - 1 ] != ' . ' ) str [ i ] = str [ n - i - 1 ] ; else str [ i ] = str [ n - i - 1 ] = ' a ' ; } } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( str [ i ] + " " ) ; } public static void Main ( ) { String str = " ab . . e . c . a " ; char [ ] s = str . ToCharArray ( ) ; smallestPalindrome ( s ) ; } }
using System ; class GFG { public static char flip ( char ch ) { return ( ch == '0' ) ? '1' : '0' ; } public static int getFlipWithStartingCharcter ( String str , char expected ) { int flipCount = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] != expected ) flipCount ++ ; expected = flip ( expected ) ; } return flipCount ; } public static int minFlipToMakeStringAlternate ( string str ) { return Math . Min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) ) ; } public static void Main ( ) { string str = "0001010111" ; Console . Write ( minFlipToMakeStringAlternate ( str ) ) ; } }
using System ; class GFG { static int remainderWith7 ( String num ) { int [ ] series = { 1 , 3 , 2 , - 1 , - 3 , - 2 } ; int series_index = 0 ; int result = 0 ; for ( int i = num . Length - 1 ; i >= 0 ; i -- ) { int digit = num [ i ] - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; } public static void Main ( ) { String str = "12345" ; Console . Write ( " Remainder ▁ with ▁ 7 ▁ is ▁ " + remainderWith7 ( str ) ) ; } }
using System ; class GFG { static String intToRoman ( int num ) { String [ ] m = { " " , " M " , " MM " , " MMM " } ; String [ ] c = { " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM " } ; String [ ] x = { " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " } ; String [ ] i = { " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " } ; String thousands = m [ num / 1000 ] ; String hundereds = c [ ( num % 1000 ) / 100 ] ; String tens = x [ ( num % 100 ) / 10 ] ; String ones = i [ num % 10 ] ; String ans = thousands + hundereds + tens + ones ; return ans ; } public static void Main ( ) { int number = 3549 ; Console . WriteLine ( intToRoman ( number ) ) ; } }
using System ; class GFG { static void pattern ( String str , int len ) { for ( int i = 0 ; i < len ; i ++ ) { int j = len - 1 - i ; for ( int k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) Console . Write ( str [ k ] ) ; else Console . Write ( " ▁ " ) ; } Console . WriteLine ( " " ) ; } } public static void Main ( String [ ] args ) { String str = " geeksforgeeks " ; int len = str . Length ; pattern ( str , len ) ; } }
using System ; class GFG { static int no_of_chars = 256 ; static String findSubString ( String str , String pat ) { int len1 = str . Length ; int len2 = pat . Length ; if ( len1 < len2 ) { Console . WriteLine ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } int [ ] hash_pat = new int [ no_of_chars ] ; int [ ] hash_str = new int [ no_of_chars ] ; for ( int i = 0 ; i < len2 ; i ++ ) hash_pat [ pat [ i ] ] ++ ; int start = 0 , start_index = - 1 , min_len = int . MaxValue ; int count = 0 ; for ( int j = 0 ; j < len1 ; j ++ ) { hash_str [ str [ j ] ] ++ ; if ( hash_str [ str [ j ] ] <= hash_pat [ str [ j ] ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] hash_pat [ str [ start ] ] == 0 ) { if ( hash_str [ str [ start ] ] > hash_pat [ str [ start ] ] ) hash_str [ str [ start ] ] -- ; start ++ ; } int len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == - 1 ) { Console . WriteLine ( " No ▁ such ▁ window ▁ exists " ) ; return " " ; } return str . Substring ( start_index , min_len ) ; } public static void Main ( String [ ] args ) { String str = " this ▁ is ▁ a ▁ test ▁ string " ; String pat = " tist " ; Console . WriteLine ( " Smallest ▁ window ▁ is ▁ : STRNEWLINE ▁ " + findSubString ( str , pat ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static List < int > set = new List < int > ( ) ; static List < int > prime = new List < int > ( ) ; static bool isPrime ( int x ) { int sqroot = ( int ) Math . Sqrt ( x ) ; if ( x == 1 ) return false ; for ( int i = 2 ; i <= sqroot ; i ++ ) if ( x % i == 0 ) return false ; return true ; } static void display ( ) { int length = set . Count ; for ( int i = 0 ; i < length ; i ++ ) Console . Write ( set [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } static void primeSum ( int total , int N , int S , int index ) { if ( total == S && set . Count == N ) { display ( ) ; return ; } if ( total > S index == prime . Count ) return ; set . Add ( prime [ index ] ) ; primeSum ( total + prime [ index ] , N , S , index + 1 ) ; set . RemoveAt ( set . Count - 1 ) ; primeSum ( total , N , S , index + 1 ) ; } static void allPrime ( int N , int S , int P ) { for ( int i = P + 1 ; i <= S ; i ++ ) { if ( isPrime ( i ) ) prime . Add ( i ) ; } if ( prime . Count < N ) return ; primeSum ( 0 , N , S , 0 ) ; } static void Main ( ) { int S = 54 , N = 2 , P = 3 ; allPrime ( N , S , P ) ; } }
class GFG { static long F ( long A , long B ) { if ( A == 1 ) return ( 4 % B ) ; else { long temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } } static void Main ( ) { long A = 25 , B = 50 ; System . Console . WriteLine ( F ( A , B ) ) ; } }
using System ; class GFG { const int MOD = 1000000007 ; static int rangeSum ( int l , int r ) { int a = 1 , b = 9 , res = 0 ; for ( int i = 1 ; i <= 10 ; i ++ ) { int L = Math . Max ( l , a ) ; int R = Math . Min ( r , b ) ; if ( L <= R ) { int sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; } public static void Main ( ) { int l = 98 , r = 102 ; Console . WriteLine ( rangeSum ( l , r ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static List < int > permutation = new List < int > ( ) ; static void printPermutation ( ) { foreach ( int i in permutation ) Console . Write ( i + " ▁ " ) ; } static int give_random_number ( int l , int r ) { Random rnd = new Random ( ) ; int num = rnd . Next ( l , r ) ; int x = ( int ) ( num % ( r - l + 1 ) + l ) ; return x ; } static void generate_random_permutation ( int l , int r ) { if ( l > r ) return ; int n = give_random_number ( l , r ) ; permutation . Add ( n ) ; generate_random_permutation ( l , n - 1 ) ; generate_random_permutation ( n + 1 , r ) ; } public static void Main ( String [ ] args ) { int l = 5 ; int r = 15 ; generate_random_permutation ( l , r ) ; printPermutation ( ) ; } }
using System ; class solution { static int INF = 99999 ; static int size = 10 ; static int getSetBitsFromOneToN ( int N ) { int two = 2 , ans = 0 ; int n = N ; while ( n != 0 ) { ans += ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; } static int findMinimum ( int x ) { int low = 0 , high = 100000 ; int ans = high ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( getSetBitsFromOneToN ( mid ) >= x ) { ans = Math . Min ( ans , mid ) ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; } public static void Main ( ) { int x = 20 ; Console . WriteLine ( findMinimum ( x ) ) ; } }
using System ; class GFG { static int trailingZeroes ( int n ) { int cnt = 0 ; while ( n > 0 ) { n /= 5 ; cnt += n ; } return cnt ; } static void binarySearch ( int n ) { int low = 0 ; int high = 1000000 ; while ( low < high ) { int mid = ( low + high ) / 2 ; int count = trailingZeroes ( mid ) ; if ( count < n ) low = mid + 1 ; else high = mid ; } int [ ] result = new int [ 1000 ] ; int k = 0 ; while ( trailingZeroes ( low ) == n ) { result [ k ] = low ; k ++ ; low ++ ; } for ( int i = 0 ; i < k ; i ++ ) Console . Write ( result [ i ] + " ▁ " ) ; } public static void Main ( ) { int n = 2 ; binarySearch ( n ) ; } }
using System ; class GFG { static int minDaysToEmpty ( int C , int l ) { if ( l >= C ) return C ; double eq_root = ( Math . Sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( int ) ( Math . Ceiling ( eq_root ) + l ) ; } static public void Main ( ) { Console . WriteLine ( minDaysToEmpty ( 5 , 2 ) ) ; Console . WriteLine ( minDaysToEmpty ( 6514683 , 4965 ) ) ; } }
class GFG { static int kth ( int [ ] arr1 , int [ ] arr2 , int m , int n , int k ) { int [ ] sorted1 = new int [ m + n ] ; int i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; } static void Main ( ) { int [ ] arr1 = { 2 , 3 , 6 , 7 , 9 } ; int [ ] arr2 = { 1 , 4 , 8 , 10 } ; int k = 5 ; System . Console . WriteLine ( kth ( arr1 , arr2 , 5 , 4 , k ) ) ; } }
using System ; class GFG { static public int R = 2 ; static public int C = 2 ; static int bsearch ( int low , int high , int n , int [ ] arr ) { int mid = ( low + high ) / 2 ; if ( low <= high ) { if ( arr [ mid ] < n ) return bsearch ( mid + 1 , high , n , arr ) ; return bsearch ( low , mid - 1 , n , arr ) ; } return low ; } public static int [ ] GetRow ( int [ , ] matrix , int row ) { var rowLength = matrix . GetLength ( 1 ) ; var rowVector = new int [ rowLength ] ; for ( var i = 0 ; i < rowLength ; i ++ ) rowVector [ i ] = matrix [ row , i ] ; return rowVector ; } static int mindiff ( int [ , ] arr , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) Array . Sort ( GetRow ( arr , i ) ) ; int ans = + 2147483647 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { int p = bsearch ( 0 , m - 1 , arr [ i , j ] , GetRow ( arr , i + 1 ) ) ; ans = Math . Min ( ans , Math . Abs ( arr [ i + 1 , p ] - arr [ i , j ] ) ) ; if ( p - 1 >= 0 ) ans = Math . Min ( ans , Math . Abs ( arr [ i + 1 , p - 1 ] - arr [ i , j ] ) ) ; } } return ans ; } public static void Main ( String [ ] args ) { int [ , ] m = { { 8 , 5 } , { 6 , 8 } } ; Console . WriteLine ( mindiff ( m , R , C ) ) ; } }
using System ; class GFG { static int binarySearch ( int [ ] arr , int left , int right ) { if ( left <= right ) { int mid = ( left + right ) / 2 ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 } ; int n = arr . Length ; int index = binarySearch ( arr , 1 , n - 2 ) ; if ( index != - 1 ) Console . Write ( arr [ index ] ) ; } }
using System ; class Test { static int findRepeatingElement ( int [ ] arr , int low , int high ) { if ( low > high ) return - 1 ; int mid = ( low + high ) / 2 ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 3 , 4 , 5 } ; int index = findRepeatingElement ( arr , 0 , arr . Length - 1 ) ; if ( index != - 1 ) Console . Write ( arr [ index ] ) ; } }
using System ; class GFG { static double diff ( double n , double mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; } static double cubicRoot ( double n ) { double start = 0 , end = n ; double e = 0.0000001 ; while ( true ) { double mid = ( start + end ) / 2 ; double error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } } public static void Main ( ) { double n = 3 ; Console . Write ( " Cube ▁ root ▁ of ▁ " + n + " ▁ is ▁ " + cubicRoot ( n ) ) ; } }
using System ; class GFG { static int floorSqrt ( int x ) { if ( x == 0 x == 1 ) return x ; int i = 1 , result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; } static public void Main ( ) { int x = 11 ; Console . WriteLine ( floorSqrt ( x ) ) ; } }
using System ; class GFG { static int sumOfInternalAngles ( int n ) { if ( n < 3 ) return 0 ; return ( ( n - 2 ) * 180 ) ; } public static void Main ( ) { int n = 5 ; Console . Write ( sumOfInternalAngles ( n ) ) ; } }
using System ; class GFG { static float diagonal_length ( float a ) { float L ; L = a * ( float ) Math . Sqrt ( 3 ) ; return L ; } public static void Main ( ) { float a = 5 ; Console . Write ( diagonal_length ( a ) ) ; } }
using System ; public class GFG { static double PI = 3.14 ; static double find_area ( int r , int d ) { double R = d / PI ; R += Math . Pow ( r , 2 ) ; R = Math . Sqrt ( R ) ; double area = PI * Math . Pow ( R , 2 ) ; return area ; } static public void Main ( ) { int r = 4 , d = 5 ; Console . Write ( find_area ( r , d ) ) ; } }
class GFG { static bool Valid ( int a , int b , int c , int d ) { if ( a + b + c + d == 360 ) return true ; return false ; } public static void Main ( ) { int a = 80 , b = 70 , c = 100 , d = 110 ; if ( Valid ( a , b , c , d ) ) Console . WriteLine ( " Valid ▁ quadrilateral " ) ; else Console . WriteLine ( " Invalid ▁ quadrilateral " ) ; } }
using System ; class GFG { static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; } public static void Main ( String [ ] args ) { int x1 = - 10 , y1 = 8 ; int x2 = 14 , y2 = - 24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) Console . WriteLine ( " There ▁ are ▁ 3 ▁ common ▁ tangents " + " ▁ between ▁ the ▁ circles . " ) ; else if ( t < 0 ) Console . WriteLine ( " There ▁ are ▁ 4 ▁ common ▁ tangents " + " ▁ between ▁ the ▁ circles . " ) ; else Console . WriteLine ( " There ▁ are ▁ 2 ▁ common ▁ tangents " + " ▁ between ▁ the ▁ circles . " ) ; } }
using System ; class GFG { static int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; } static void ratiotang ( int r1 , int r2 ) { Console . WriteLine ( " The ▁ ratio ▁ is ▁ " + r1 / GCD ( r1 , r2 ) + " : " + r2 / GCD ( r1 , r2 ) ) ; } static public void Main ( ) { int r1 = 4 , r2 = 8 ; ratiotang ( r1 , r2 ) ; } }
using System ; class GFG { static int Regions ( int Vertices , int Edges ) { int R = Edges + 2 - Vertices ; return R ; } static public void Main ( ) { int V = 5 , E = 7 ; Console . WriteLine ( Regions ( V , E ) ) ; } }
using System ; class GFG { static int GCD ( int a , int b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; } static void ratiotang ( int r1 , int r2 ) { Console . WriteLine ( " The ▁ ratio ▁ is ▁ " + r1 / GCD ( r1 , r2 ) + " ▁ : ▁ " + r2 / GCD ( r1 , r2 ) ) ; } public static void Main ( String [ ] args ) { int r1 = 4 , r2 = 6 ; ratiotang ( r1 , r2 ) ; } }
using System ; class GFG { static void lengthOfTangent ( double r1 , double r2 , double d ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ transverse " + " ▁ common ▁ tangent ▁ is ▁ " + Math . Sqrt ( Math . Pow ( d , 2 ) - Math . Pow ( ( r1 + r2 ) , 2 ) ) ) ; } static public void Main ( ) { double r1 = 4 , r2 = 6 , d = 12 ; lengthOfTangent ( r1 , r2 , d ) ; } }
using System ; class GFG { static int remainingArea ( int N , int M , int K ) { while ( K -- > 0 && N > 0 && M > 0 ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; } static public void Main ( ) { int N = 5 , M = 3 , K = 2 ; Console . WriteLine ( remainingArea ( N , M , K ) ) ; } }
using System ; class GFG { static void lengtang ( double r1 , double r2 ) { Console . WriteLine ( " The ▁ length ▁ of ▁ the ▁ " + " direct ▁ common ▁ tangent ▁ is ▁ " + ( 2 * Math . Sqrt ( r1 * r2 ) ) ) ; } static public void Main ( ) { double r1 = 5 , r2 = 9 ; lengtang ( r1 , r2 ) ; } }
using System ; class GFG { static void dist ( double x1 , double y1 , double x2 , double y2 , double r ) { Console . WriteLine ( " The ▁ shortest ▁ distance ▁ " + " between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " + ( Math . Sqrt ( ( Math . Pow ( ( x2 - x1 ) , 2 ) ) + ( Math . Pow ( ( y2 - y1 ) , 2 ) ) ) - r ) ) ; } public static void Main ( String [ ] args ) { double x1 = 4 , y1 = 6 , x2 = 35 , y2 = 42 , r = 5 ; dist ( x1 , y1 , x2 , y2 , r ) ; } }
using System ; class GFG { static double dist ( double m , double b1 , double b2 ) { double d = Math . Abs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; return d ; } public static void Main ( ) { double m = 2 , b1 = 4 , b2 = 3 ; Console . Write ( dist ( m , b1 , b2 ) ) ; } }
using System ; class GFG { static float normal ( float m , float n ) { float N = ( float ) ( ( Math . Abs ( m ) * Math . Abs ( n ) ) / Math . Sqrt ( ( Math . Abs ( m ) * Math . Abs ( m ) ) + ( Math . Abs ( n ) * Math . Abs ( n ) ) ) ) ; return N ; } public static void Main ( ) { float m = - 5 , n = 3 ; Console . Write ( normal ( m , n ) ) ; } }
using System ; class GFG { static bool isPossible ( int [ ] a , int n ) { int sum = 0 , maxS = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . Max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; } static void Main ( ) { int [ ] a = { 2 , 3 , 4 } ; int n = a . Length ; if ( isPossible ( a , n ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static float findAreaShaded ( float a ) { float sqArea = a * a ; float semiCircleArea = ( float ) ( 3.14 * ( a * a ) / 8 ) ; float ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; } public static void Main ( ) { float a = 10 ; Console . WriteLine ( findAreaShaded ( a ) ) ; } }
using System ; class GfG { static int countSteps ( int x , int y ) { if ( x < y ) { return x + y + 2 * ( ( y - x ) / 2 ) ; } else { return x + y + 2 * ( ( ( x - y ) + 1 ) / 2 ) ; } } public static void Main ( ) { int x = 4 , y = 3 ; Console . WriteLine ( countSteps ( x , y ) ) ; } }
using System ; using System . Collections . Generic ; class GfG { static bool isSlopeGood ( double slope , int [ ] arr , int n ) { HashSet < Double > setOfLines = new HashSet < Double > ( ) ; for ( int i = 0 ; i < n ; i ++ ) setOfLines . Add ( arr [ i ] - slope * ( i ) ) ; return setOfLines . Count == 2 ; } static bool checkForParallel ( int [ ] arr , int n ) { bool slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) ; bool slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) ; bool slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) / 2 , arr , n ) ; return ( slope1 == true slope2 == true slope3 == true ) ; } public static void Main ( ) { int [ ] arr = { 1 , 6 , 3 , 8 , 5 } ; int n = arr . Length ; if ( checkForParallel ( arr , n ) == true ) Console . WriteLine ( "1" ) ; else Console . WriteLine ( "0" ) ; } }
using System ; class GFG { static bool pointIsOnLine ( int m , int c , int x , int y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; } public static void Main ( ) { int m = 3 , c = 2 ; int x = 1 , y = 5 ; if ( pointIsOnLine ( m , c , x , y ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static double Area ( double a , double b ) { if ( a < 0 && b < 0 ) return - 1 ; double h = ( double ) Math . Sqrt ( ( ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) / ( Math . Pow ( a , 2 ) * Math . Pow ( b , 2 ) ) ) ) ; double A = ( double ) ( 0.70477 * Math . Pow ( h , 2 ) ) ; return A ; } static void Main ( ) { double a = 5 , b = 4 ; Console . WriteLine ( Math . Round ( Area ( a , b ) , 7 ) ) ; } }
using System ; class GFG { static int maxRectangles ( int L , int B , int l , int b ) { int horizontal = 0 , vertical = 0 ; if ( l <= L && b <= B ) { int columns = B / b ; int rows = L / l ; horizontal = rows * columns ; } if ( l <= B && b <= L ) { int columns = L / b ; int rows = B / l ; vertical = rows * columns ; } return Math . Max ( horizontal , vertical ) ; } public static void Main ( ) { int L = 10 , B = 7 , l = 4 , b = 3 ; Console . WriteLine ( maxRectangles ( L , B , l , b ) ) ; } }
using System ; class GFG { static double cone ( double a ) { if ( a < 0 ) return - 1 ; double r = ( double ) ( a * Math . Sqrt ( 2 ) ) / 3 ; double h = ( 2 * a ) / 3 ; double V = ( double ) ( 3.14 * Math . Pow ( r , 2 ) * h ) ; return Math . Round ( V , 4 ) ; } static void Main ( ) { double a = 5 ; Console . WriteLine ( cone ( a ) ) ; } }
using System ; class GFG { static float Area ( float a ) { if ( a < 0 ) return - 1 ; float h = ( float ) 1.268 * a ; float A = ( float ) ( 0.70477 * Math . Pow ( h , 2 ) ) ; return A ; } public static void Main ( ) { float a = 5 ; Console . WriteLine ( Area ( a ) ) ; } }
using System ; class GFG { static double Area ( double r ) { if ( r < 0 ) return - 1 ; double x = ( 2 * r ) / ( double ) ( Math . Sqrt ( 5 ) ) ; double A = 0.70477 * ( double ) ( Math . Pow ( x , 2 ) ) ; return A ; } public static void Main ( ) { double r = 5 ; Console . WriteLine ( Area ( r ) ) ; } }
using System ; class GFG { static float Area ( float a ) { if ( a < 0 ) return - 1 ; float x = 0.464f * a ; float A = 0.70477f * ( float ) Math . Pow ( x , 2 ) ; return A ; } public static void Main ( ) { float a = 5 ; Console . WriteLine ( String . Format ( " { 0,0 : # .00000 } " , Area ( a ) ) ) ; } }
using System ; class GFG { static double areaSquare ( double side , double fold ) { double area = side * side ; return area * 1.0 / Math . Pow ( 2 , fold ) ; } public static void Main ( ) { double side = 4 , fold = 2 ; Console . Write ( areaSquare ( side , fold ) ) ; } }
using System ; class GFG { static double ReuleauxArea ( double r ) { if ( r < 0 ) return - 1 ; double A = 0.70477 * 2 * Math . Pow ( r , 2 ) ; return A ; } public static void Main ( ) { double r = 6 ; Console . WriteLine ( ReuleauxArea ( r ) ) ; } }
using System ; class GFG { static float cyl ( float a ) { if ( a < 0 ) return - 1 ; float r = ( 2 * a * ( float ) ( Math . Sqrt ( 2 ) ) / 3 ) ; float h = ( 2 * a ) / 3 ; float V = ( 3.14f * ( float ) ( Math . Pow ( r , 2 ) * h ) ) ; return V ; } public static void Main ( ) { float a = 5 ; Console . Write ( cyl ( a ) ) ; } }
using System ; class GFG { static double Area ( double l , double b , double h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; double x = ( l * b ) / ( l + b ) ; double A = 0.70477 * Math . Pow ( x , 2 ) ; return A ; } public static void Main ( ) { double l = 5 , b = 12 , h = 13 ; Console . WriteLine ( ( Area ( l , b , h ) ) ) ; } }
using System ; class GFG { static float squareSide ( float a ) { if ( a < 0 ) return - 1 ; float x = ( 0.423f * a ) ; return x ; } public static void Main ( ) { float a = 8 ; Console . WriteLine ( squareSide ( a ) ) ; } }
using System ; class GFG { static bool isPossible ( float x , float y , float z ) { float a = x * x + y * y + z * z ; if ( Math . Ceiling ( a ) == 1 && Math . Floor ( a ) == 1 ) return true ; return false ; } public static void Main ( ) { float l = 0.70710678f , m = 0.5f , n = 0.5f ; if ( isPossible ( l , m , n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class GFG { static float polydiagonal ( float n , float a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( float ) ( 2 * a * Math . Sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; } static public void Main ( ) { float a = 9 , n = 10 ; Console . WriteLine ( polydiagonal ( n , a ) ) ; } }
using System ; public class GFG { static double decdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.902 * a ; return d ; } public static void Main ( ) { int a = 9 ; Console . WriteLine ( decdiagonal ( a ) ) ; } }
using System ; public class GFG { static double heptdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.802 * a ; return d ; } public static void Main ( ) { int a = 6 ; Console . WriteLine ( heptdiagonal ( a ) ) ; }
using System ; public class GFG { static double hexDiagonal ( float a ) { if ( a < 0 ) return - 1 ; double d = ( double ) 1.73 * a ; return d ; } public static void Main ( ) { float a = 9 ; Console . WriteLine ( hexDiagonal ( a ) ) ; } }
using System ; public class GFG { static double ReuleauxArea ( float a ) { if ( a < 0 ) return - 1 ; double A = ( double ) 0.70477 * Math . Pow ( a , 2 ) ; return A ; } public static void Main ( ) { float a = 6 ; Console . WriteLine ( ReuleauxArea ( a ) ) ; } }
using System ; class Solution { static float squareArea ( float a ) { if ( a < 0 ) return - 1 ; float area = ( float ) ( Math . Pow ( 1.268 , 2 ) * Math . Pow ( a , 2 ) ) ; return area ; } public static void Main ( ) { float a = 6 ; Console . WriteLine ( squareArea ( a ) ) ; } }
using System ; public class GFG { static float CubeVolume ( float d ) { float Volume ; Volume = ( float ) ( Math . Sqrt ( 3 ) * Math . Pow ( d , 3 ) ) / 9 ; return Volume ; } public static void Main ( ) { float d = 5 ; Console . WriteLine ( " Volume ▁ of ▁ Cube : ▁ { 0 : F4 } " , CubeVolume ( d ) ) ; } }
using System ; class GFG { public static double per ( double a , double b ) { return ( a + b ) ; } public static double area ( double s ) { return ( s / 2 ) ; } public static void Main ( ) { double a = 7.0 , b = 8.0 , s = 10.0 ; Console . WriteLine ( per ( a , b ) ) ; Console . Write ( area ( s ) ) ; } }
using System ; class GFG { static double PI = 3.14159265 ; public static double area_leaf ( double a ) { return ( a * a * ( PI / 2 - 1 ) ) ; } public static void Main ( ) { double a = 7 ; Console . Write ( area_leaf ( a ) ) ; } }
using System ; class GFG { static double PI = 3.14159265 ; public static double length_rope ( double r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } public static void Main ( ) { double r = 7.0 ; Console . Write ( length_rope ( r ) ) ; } }
using System ; class GFG { static double PI = 3.14159265 ; public static double area_inscribed ( double P , double B , double H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; } public static void Main ( ) { double P = 3.0 , B = 4.0 , H = 5.0 ; Console . Write ( area_inscribed ( P , B , H ) ) ; } }
using System ; class GFG { static double PI = 3.14159265 ; public static double area_cicumscribed ( double c ) { return ( c * c * ( PI / 4 ) ) ; } public static void Main ( ) { double c = 8.0 ; Console . Write ( area_cicumscribed ( c ) ) ; } }
using System ; class GFG { static double cyl ( double r , double h ) { if ( r < 0 && h < 0 ) return - 1 ; double R = ( 2 * r ) / 3 ; double H = ( 2 * h ) / 3 ; double V = 3.14 * Math . Pow ( R , 2 ) * H ; return V ; } static public void Main ( ) { double r = 4 , h = 8 ; Console . WriteLine ( cyl ( r , h ) ) ; } }
using System ; class GFG { static float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( float ) Math . Pow ( h , 3 ) ; return a ; } public static void Main ( ) { float h = 5 , r = 4 ; Console . Write ( cube ( h , r ) ) ; } }
using System ; class GFG { static float sph ( float r , float h ) { if ( r < 0 && h < 0 ) return - 1 ; float R = r ; return R ; } public static void Main ( ) { float r = 4 , h = 8 ; Console . WriteLine ( sph ( r , h ) ) ; } }
using System ; class GFG { static float cyl ( float R ) { if ( R < 0 ) return - 1 ; float V = ( float ) ( ( 2 * 3.14 * Math . Pow ( R , 3 ) ) / ( 3 * Math . Sqrt ( 3 ) ) ) ; return V ; } public static void Main ( ) { float R = 4 ; Console . WriteLine ( cyl ( R ) ) ; } }
using System ; class GFG { static float rod ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float l = ( float ) ( Math . Sqrt ( Math . Pow ( h , 2 ) + 4 * Math . Pow ( r , 2 ) ) ) ; return l ; } public static void Main ( ) { float h = 4 ; float r = 1.5f ; Console . WriteLine ( rod ( h , r ) ) ; } }
using System ; class GFG { static double PI = 3.14159265 ; public static double area_inscribed ( double a ) { return ( a * a * ( PI / 12 ) ) ; } public static double perm_inscribed ( double a ) { return ( PI * ( a / Math . Sqrt ( 3 ) ) ) ; } public static void Main ( ) { double a = 6.0 ; Console . Write ( " Area ▁ of ▁ inscribed ▁ circle ▁ is ▁ : " + area_inscribed ( a ) ) ; Console . Write ( " STRNEWLINE Perimeter ▁ of ▁ inscribed ▁ circle ▁ is ▁ : " + perm_inscribed ( a ) ) ; } }
using System ; class GFG { static float cube ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float a = ( h * r * ( float ) Math . Sqrt ( 2 ) ) / ( h + ( float ) Math . Sqrt ( 2 ) * r ) ; return a ; } public static void Main ( ) { float h = 5 , r = 6 ; Console . Write ( cube ( h , r ) ) ; } }
using System ; class GFG { static float coner ( float R ) { if ( R < 0 ) return - 1 ; float r = ( float ) ( 2 * Math . Sqrt ( 2 ) * R ) / 3 ; return r ; } static float coneh ( float R ) { if ( R < 0 ) return - 1 ; float h = ( 4 * R ) / 3 ; return h ; } public static void Main ( ) { float R = 10 ; Console . WriteLine ( " r ▁ = ▁ " + coner ( R ) + " , ▁ " + " h ▁ = ▁ " + coneh ( R ) ) ; } }
using System ; class GFG { static float coneRadius ( float a ) { if ( a < 0 ) return - 1 ; float r = ( float ) ( a / Math . Sqrt ( 2 ) ) ; return r ; } static float coneHeight ( float a ) { if ( a < 0 ) return - 1 ; float h = a ; return h ; } public static void Main ( ) { float a = 6 ; Console . WriteLine ( " r ▁ = ▁ " + coneRadius ( a ) + " , ▁ " + " h ▁ = ▁ " + coneHeight ( a ) ) ; } }
using System ; class Solution { static float largestCube ( float r ) { if ( r < 0 ) return - 1 ; float a = ( 2 * r ) / ( float ) Math . Sqrt ( 3 ) ; return a ; } static void Main ( ) { float r = 5 ; Console . WriteLine ( largestCube ( r ) ) ; } }
using System ; class GFG { static float sphere ( float a ) { if ( a < 0 ) return - 1 ; float r = a / 2 ; return r ; } static public void Main ( ) { float a = 5 ; Console . WriteLine ( sphere ( a ) ) ; } }
using System ; public class GFG { static int numberOfCuts ( int M , int N ) { int result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; } static public void Main ( ) { int M = 4 , N = 4 ; int Cuts = numberOfCuts ( M , N ) ; Console . WriteLine ( " Maximum ▁ cuts ▁ = ▁ " + Cuts ) ; } }
using System ; class GFG { static float maxVol ( float P , float A ) { float l = ( float ) ( P - Math . Sqrt ( P * P - 24 * A ) ) / 12 ; float V = ( float ) ( l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ) ; return V ; } public static void Main ( ) { float P = 20 , A = 16 ; Console . WriteLine ( maxVol ( P , A ) ) ; } }
using System ; class GFG { static int rhombusAreaPeri ( int d1 , int d2 ) { int area , perimeter ; area = ( d1 * d2 ) / 2 ; perimeter = ( int ) ( 2 * Math . Sqrt ( Math . Pow ( d1 , 2 ) + Math . Pow ( d2 , 2 ) ) ) ; Console . WriteLine ( " The ▁ area ▁ of ▁ rhombus ▁ with ▁ " + " diagonals ▁ " + d1 + " ▁ and ▁ " + d2 + " ▁ is ▁ " + area + " . " ) ; Console . WriteLine ( " The ▁ perimeter ▁ of ▁ rhombus ▁ " + " with ▁ diagonals ▁ " + d1 + " ▁ and ▁ " + d2 + " ▁ is ▁ " + perimeter + " . " ) ; return 0 ; } public static void Main ( ) { int d1 = 2 , d2 = 4 ; rhombusAreaPeri ( d1 , d2 ) ; } }
using System ; class GFG { static double area ( double r ) { if ( r < 0 ) return - 1 ; double area = ( 5 * Math . Pow ( r , 2 ) * ( 3 - Math . Sqrt ( 5 ) ) * ( Math . Sqrt ( 5 ) + ( ( 2 * Math . Sqrt ( 5 ) ) ) ) / 4 ) ; return area ; } static public void Main ( ) { double r = 8 ; Console . WriteLine ( area ( r ) ) ; } }
using System ; class GFG { static int maxArea ( float perimeter ) { int length = ( int ) Math . Ceiling ( perimeter / 4 ) ; int breadth = ( int ) Math . Floor ( perimeter / 4 ) ; return length * breadth ; } public static void Main ( ) { float n = 38 ; Console . WriteLine ( " Maximum ▁ Area ▁ = ▁ " + maxArea ( n ) ) ; } }
using System ; using System . Globalization ; class GFG { static void foot ( float a , float b , float c , float d , float x1 , float y1 , float z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; NumberFormatInfo form = new NumberFormatInfo ( ) ; form . NumberDecimalSeparator = " . " ; Console . Write ( " ▁ x2 ▁ = ▁ " + x2 . ToString ( form ) ) ; Console . Write ( " ▁ y2 ▁ = ▁ " + y2 . ToString ( form ) ) ; Console . Write ( " ▁ z2 ▁ = ▁ " + z2 . ToString ( form ) ) ; } public static void Main ( String [ ] arr ) { float a = 1 ; float b = - 2 ; float c = 0 ; float d = 0 ; float x1 = - 1 ; float y1 = 3 ; float z1 = 4 ; foot ( a , b , c , d , x1 , y1 , z1 ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int countRectangles ( int l , int w ) { int squareSide = __gcd ( l , w ) ; return ( l * w ) / ( squareSide * squareSide ) ; } public static void Main ( ) { int l = 4 , w = 6 ; System . Console . WriteLine ( countRectangles ( l , w ) ) ; } }
using System ; class GFG { public static void circle_equation ( double x1 , double y1 , double r ) { double a = - 2 * x1 ; double b = - 2 * y1 ; double c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; Console . Write ( " x ^ 2 ▁ + ▁ ( " + a + " ▁ x ) ▁ + ▁ " ) ; Console . Write ( " y ^ 2 ▁ + ▁ ( " + b + " ▁ y ) ▁ = ▁ " ) ; Console . WriteLine ( c + " . " ) ; } public static void Main ( string [ ] arr ) { double x1 = 2 , y1 = - 3 , r = 8 ; circle_equation ( x1 , y1 , r ) ; } }
using System ; class GFG { static float area ( float r ) { return ( float ) ( ( 0.5 ) * ( 3.14 ) * ( r * r ) ) ; } static float perimeter ( float r ) { return ( float ) ( ( 3.14 ) * ( r ) ) ; } public static void Main ( ) { float r = 10 ; Console . WriteLine ( " The ▁ Area ▁ of ▁ Semicircle : ▁ " + area ( r ) ) ; Console . WriteLine ( " The ▁ Perimeter ▁ of ▁ Semicircle : " + perimeter ( r ) ) ; } }
class GFG { static bool checkEquilibrium ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int resx = x1 + x2 + x3 ; int resy = y1 + y2 + y3 ; int resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; } public static void Main ( ) { int x1 = - 2 , y1 = - 7 , z1 = - 9 , x2 = 5 , y2 = - 14 , z2 = 14 , x3 = - 3 , y3 = 21 , z3 = - 5 ; if ( checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ) System . Console . WriteLine ( " The ▁ vectors ▁ are ▁ " + " at ▁ equilibrium . " ) ; else System . Console . WriteLine ( " The ▁ vectors ▁ are ▁ not ▁ " + " at ▁ equilibrium . " ) ; } }
using System ; class GFG { static void findTangent ( int A , int x , int y ) { int dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) Console . Write ( " y ▁ = ▁ " + dif + " x " + ( x * dif + y ) + " STRNEWLINE " ) ; else if ( dif > 0 ) Console . Write ( " y ▁ = ▁ " + dif + " x + " + - x * dif + y + " STRNEWLINE " ) ; else Console . Write ( " Not ▁ possible " + " STRNEWLINE " ) ; } } public static void Main ( ) { int A = 2 , x = 2 , y = 0 ; findTangent ( A , x , y ) ; } }
using System ; class GFG { static float hexadiagonal ( float a ) { if ( a < 0 ) return - 1 ; return 2 * a ; } public static void Main ( ) { float a = 4 ; Console . WriteLine ( hexadiagonal ( a ) ) ; } }
using System ; class GFG { static double octaside ( double a ) { if ( a < 0 ) return - 1 ; double s = a / ( Math . Sqrt ( 2 ) + 1 ) ; return s ; } static public void Main ( ) { double a = 4 ; Console . WriteLine ( octaside ( a ) ) ; } }
using System ; class GFG { static bool Arrive ( int a , int b , int n ) { if ( n >= Math . Abs ( a ) + Math . Abs ( b ) && ( n - ( Math . Abs ( a ) + Math . Abs ( b ) ) ) % 2 == 0 ) return true ; return false ; } public static void Main ( ) { int a = 5 , b = 5 , n = 11 ; if ( Arrive ( a , b , n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool Move ( int a , int x , int b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; } public static void Main ( ) { int a = 3 , x = 2 , b = 7 ; if ( Move ( a , x , b ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static float area ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float A = a * b ; return A ; } static public void Main ( ) { float a = 5 , b = 2 ; Console . WriteLine ( area ( a , b ) ) ; } }
using System ; class GFG { static float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float radius = ( float ) Math . Sqrt ( Math . Pow ( l , 2 ) + Math . Pow ( b , 2 ) ) / 2 ; return radius ; } public static void Main ( ) { float l = 4 , b = 3 ; Console . WriteLine ( findRadiusOfcircumcircle ( l , b ) ) ; } }
using System ; class gfg { public double circlearea ( double a , double b , double c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; double p = ( a + b + c ) / 2 ; double At = Math . Sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; double A = 3.14 * Math . Pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) ; return A ; } } class geek { public static int Main ( ) { gfg g = new gfg ( ) ; double a = 4 , b = 5 , c = 3 ; Console . WriteLine ( g . circlearea ( a , b , c ) ) ; return 0 ; } }
using System ; class GFG { static float altitude ( float a , float b ) { return ( float ) ( Math . Sqrt ( Math . Pow ( a , 2 ) - ( Math . Pow ( b , 2 ) / 4 ) ) ) ; } static float area ( float b , float h ) { return ( 1 * b * h ) / 2 ; } public static void Main ( ) { float a = 2 , b = 3 ; float h = altitude ( a , b ) ; Console . WriteLine ( " Altitude ▁ = ▁ " + h + " , ▁ " ) ; Console . WriteLine ( " Area ▁ = ▁ " + area ( b , h ) ) ; } }
using System ; class GFG { static int surfaceArea ( int b , int s ) { return 2 * b * s + ( int ) Math . Pow ( b , 2 ) ; } public static void Main ( ) { int b = 3 , s = 4 ; Console . WriteLine ( surfaceArea ( b , s ) ) ; } }
using System ; class GFG { static float trianglearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; float area = ( l * b ) / 2 ; return area ; } public static void Main ( ) { float l = 5 , b = 4 ; Console . WriteLine ( trianglearea ( l , b ) ) ; } }
using System ; class GFG { static void halfsquare ( int n , int x , int y ) { int half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) Console . WriteLine ( " NO " ) ; else Console . WriteLine ( " YES " ) ; } public static void Main ( ) { int n = 100 ; int x = 51 , y = 100 ; halfsquare ( n , x , y ) ; } }
using System ; class GFG { static bool check ( long a , long b , long p , long q ) { long d = p * p + q * q ; if ( d == 0 ) return a == 0 && b == 0 ; else return ( a * p + b * q ) % d == 0 && ( b * p - a * q ) % d == 0 ; } static bool check ( int a , int b , int x , int y , int p , int q ) { if ( check ( a - x , b - y , p , q ) || check ( a + x , b + y , p , q ) || check ( a - y , b + x , p , q ) || check ( a + y , b - x , p , q ) ) return true ; else return false ; } public static void Main ( ) { int a = - 4 , b = - 2 ; int x = 0 , y = 0 ; int p = - 2 , q = - 1 ; if ( check ( a , b , x , y , p , q ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static float trianglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = ( float ) ( 3 * Math . Sqrt ( 3 ) * Math . Pow ( a , 2 ) ) / ( 4 * b ) ; return area ; } public static void Main ( ) { float a = 4 , b = 2 ; Console . WriteLine ( trianglearea ( a , b ) ) ; } }
using System ; class GFG { static float squarearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; float area = 4 * ( float ) ( ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) / ( Math . Pow ( a , 2 ) * Math . Pow ( b , 2 ) ) ) ; return area ; } public static void Main ( ) { float a = 4 , b = 2 ; Console . WriteLine ( squarearea ( a , b ) ) ; } }
using System ; class GFG { static float trianglearea ( float r ) { if ( r < 0 ) return - 1 ; return r * r ; } public static void Main ( ) { float r = 5 ; Console . Write ( trianglearea ( r ) ) ; } }
using System ; class GFG { static float squarearea ( float r ) { if ( r < 0 ) return - 1 ; float a = 4 * ( float ) ( Math . Pow ( r , 2 ) / 5 ) ; return a ; } public static void Main ( ) { float r = 5 ; Console . WriteLine ( squarearea ( r ) ) ; } }
using System ; class GFG { static float rectanglearea ( float a , float b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; } public static void Main ( ) { float a = 10 , b = 8 ; Console . WriteLine ( rectanglearea ( a , b ) ) ; } }
using System ; class GFG { static float squareArea ( float l , float b , float h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; float a = ( l * b ) / ( l + b ) ; return a * a ; } public static void Main ( ) { float l = 5 , b = 12 , h = 13 ; Console . WriteLine ( squareArea ( l , b , h ) ) ; } }
using System ; class GFG { static int MAX = 50 ; static void solveQuery ( int n , int q , int [ ] qi , int [ ] qj ) { int [ ] arr = new int [ MAX ] ; for ( int i = 0 ; i <= n ; i ++ ) arr [ i ] = 0 ; for ( int k = 0 ; k < q ; k ++ ) { int flag = 0 ; if ( qj [ k ] < qi [ k ] ) { int temp = qi [ k ] ; qi [ k ] = qj [ k ] ; qj [ k ] = temp ; } if ( arr [ qi [ k ] ] != 0 arr [ qj [ k ] ] != 0 ) flag = 1 ; else if ( qi [ k ] == qj [ k ] ) flag = 1 ; else { for ( int i = 1 ; i < qi [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] < qj [ k ] && qi [ k ] < arr [ i ] ) { flag = 1 ; break ; } } if ( flag == 0 ) { for ( int i = qi [ k ] + 1 ; i < qj [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] > qj [ k ] ) { flag = 1 ; break ; } } } } if ( flag == 0 ) { Console . Write ( " YES STRNEWLINE " ) ; arr [ qi [ k ] ] = qj [ k ] ; arr [ qj [ k ] ] = qi [ k ] ; } else Console . Write ( " NO STRNEWLINE " ) ; } } public static void Main ( ) { int n = 10 ; int q = 7 ; int [ ] qi = { 1 , 2 , 2 , 2 , 9 , 10 , 8 } ; int [ ] qj = { 5 , 7 , 3 , 4 , 9 , 9 , 6 } ; solveQuery ( n , q , qi , qj ) ; } }
using System ; class GFG { static int squares ( int l , int b , int a ) { return ( int ) ( Math . Ceiling ( l / ( double ) a ) * Math . Ceiling ( b / ( double ) a ) ) ; } public static void Main ( ) { int l = 11 , b = 23 , a = 14 ; Console . Write ( squares ( l , b , a ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } static int squarearea ( int l , int b ) { if ( l < 0 b < 0 ) return - 1 ; int n = ( l * b ) / gcd ( l , b ) ; return n * n ; } public static void Main ( ) { int l = 6 , b = 4 ; Console . Write ( squarearea ( l , b ) ) ; } }
using System ; class GFG { static double angle_triangle ( int x1 , int x2 , int x3 , int y1 , int y2 , int y3 , int z1 , int z2 , int z3 ) { int num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; double den = Math . Sqrt ( Math . Pow ( ( x2 - x1 ) , 2 ) + Math . Pow ( ( y2 - y1 ) , 2 ) + Math . Pow ( ( z2 - z1 ) , 2 ) ) * Math . Sqrt ( Math . Pow ( ( x3 - x1 ) , 2 ) + Math . Pow ( ( y3 - y1 ) , 2 ) + Math . Pow ( ( z3 - z1 ) , 2 ) ) ; double angle = Math . Acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; } public static void Main ( ) { int x1 = - 1 , y1 = 3 , z1 = 2 ; int x2 = 2 , y2 = 3 , z2 = 5 ; int x3 = 3 , y3 = 5 , z3 = - 2 ; double angle_A = angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) ; double angle_B = angle_triangle ( x2 , x3 , x1 , y2 , y3 , y1 , z2 , z3 , z1 ) ; double angle_C = angle_triangle ( x3 , x2 , x1 , y3 , y2 , y1 , z3 , z2 , z1 ) ; Console . WriteLine ( " Angles ▁ are ▁ : " ) ; Console . WriteLine ( " angle ▁ A ▁ = ▁ " + angle_A + " ▁ degree " ) ; Console . WriteLine ( " angle ▁ B ▁ = ▁ " + angle_B + " ▁ degree " ) ; Console . WriteLine ( " angle ▁ C ▁ = ▁ " + angle_C + " ▁ degree " ) ; } }
using System ; class GFG { static int solve ( int M , int N , int s ) { if ( N % s == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( M % s == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return M * N ; } static void Main ( ) { int N = 12 , M = 13 , s = 4 ; Console . WriteLine ( solve ( M , N , s ) ) ; } }
using System ; class GFG { static int solve ( double M , double N , double s ) { int ans = ( ( int ) ( Math . Ceiling ( M / s ) ) * ( int ) ( Math . Ceiling ( N / s ) ) ) ; return ans ; } public static void Main ( ) { double N = 12 , M = 13 , s = 4 ; Console . WriteLine ( solve ( M , N , s ) ) ; } }
using System ; class GFG { static void equation_plane ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 , float x3 , float y3 , float z3 ) { float a1 = x2 - x1 ; float b1 = y2 - y1 ; float c1 = z2 - z1 ; float a2 = x3 - x1 ; float b2 = y3 - y1 ; float c2 = z3 - z1 ; float a = b1 * c2 - b2 * c1 ; float b = a2 * c1 - a1 * c2 ; float c = a1 * b2 - b1 * a2 ; float d = ( - a * x1 - b * y1 - c * z1 ) ; Console . Write ( " equation ▁ of ▁ plane ▁ is ▁ " + a + " x ▁ + ▁ " + b + " y ▁ + ▁ " + c + " z ▁ + ▁ " + d + " ▁ = ▁ 0" ) ; } public static void Main ( ) { float x1 = - 1 ; float y1 = 2 ; float z1 = 1 ; float x2 = 0 ; float y2 = - 3 ; float z2 = 2 ; float x3 = 1 ; float y3 = 1 ; float z3 = - 4 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; } }
using System ; class GFG { static void shortest_distance ( float x1 , float y1 , float a , float b , float c ) { double d = Math . Abs ( ( ( a * x1 + b * y1 + c ) ) / ( Math . Sqrt ( a * a + b * b ) ) ) ; Console . WriteLine ( " Perpendicular ▁ " + " distance ▁ is ▁ " + d ) ; return ; } public static void Main ( ) { float x1 = 5 ; float y1 = 6 ; float a = - 2 ; float b = 3 ; float c = 4 ; shortest_distance ( x1 , y1 , a , b , c ) ; } }
using System ; class GFG { static void octant ( float x , float y , float z ) { if ( x >= 0 && y >= 0 && z >= 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 1st ▁ octant " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 2nd ▁ octant " ) ; else if ( x < 0 && y < 0 && z >= 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 3rd ▁ octant " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 4th ▁ octant " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 5th ▁ octant " ) ; else if ( x < 0 && y >= 0 && z < 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 6th ▁ octant " ) ; else if ( x < 0 && y < 0 && z < 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 7th ▁ octant " ) ; else if ( x >= 0 && y < 0 && z < 0 ) Console . WriteLine ( " Point ▁ lies ▁ in ▁ 8th ▁ octant " ) ; } static public void Main ( ) { float x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = - 4 ; y = 2 ; z = - 8 ; octant ( x , y , z ) ; x = - 6 ; y = - 2 ; z = 8 ; octant ( x , y , z ) ; } }
using System ; class GFG { static int countNumberOfTriangles ( int n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( countNumberOfTriangles ( n ) ) ; } }
using System ; class GFG { static long centeredTridecagonalNum ( long n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; } public static void Main ( ) { long n = 3 ; Console . WriteLine ( centeredTridecagonalNum ( n ) ) ; n = 10 ; Console . WriteLine ( centeredTridecagonalNum ( n ) ) ; } }
using System ; class GFG { static int pentagon_pyramidal ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; } static public void Main ( ) { int n = 4 ; Console . WriteLine ( pentagon_pyramidal ( n ) ) ; } }
using System ; class GFG { static int pentagon_pyramidal ( int n ) { return n * n * ( n + 1 ) / 2 ; } static public void Main ( ) { int n = 4 ; Console . WriteLine ( pentagon_pyramidal ( n ) ) ; } }
using System ; class GFG { static bool checkConcurrent ( int a1 , int b1 , int c1 , int a2 , int b2 , int c2 , int a3 , int b3 , int c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; } public static void Main ( ) { int a1 = 2 , b1 = - 3 , c1 = 5 ; int a2 = 3 , b2 = 4 , c2 = - 7 ; int a3 = 9 , b3 = - 5 , c3 = 8 ; if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int center_octadecagon_num ( int n ) { return 9 * n * n - 9 * n + 1 ; } static public void Main ( ) { int n = 3 ; Console . Write ( n + " th ▁ centered ▁ " + " octadecagonal ▁ number ▁ : ▁ " ) ; Console . WriteLine ( center_octadecagon_num ( n ) ) ; n = 13 ; Console . Write ( n + " th ▁ centered ▁ " + " octadecagonal ▁ number ▁ : ▁ " ) ; Console . WriteLine ( center_octadecagon_num ( n ) ) ; } }
using System ; class GFG { static int centereddecagonalnum ( int n ) { return ( 5 * n * n + 5 * n + 1 ) ; } static public void Main ( ) { int n = 5 ; Console . Write ( n + " th ▁ centered ▁ decagonal " + " number : ▁ " ) ; Console . WriteLine ( centereddecagonalnum ( n ) ) ; n = 9 ; Console . Write ( n + " th ▁ centered ▁ decagonal " + " number : ▁ " ) ; Console . WriteLine ( centereddecagonalnum ( n ) ) ; } }
using System ; class GFG { static int factorial ( int a , int b ) { int res = 1 ; for ( int i = 1 ; i <= ( a + b ) ; i ++ ) res = res * i ; for ( int i = 1 ; i <= a ; i ++ ) res = res / i ; for ( int i = 1 ; i <= b ; i ++ ) res = res / i ; return res ; } static void Ksmallest ( int x , int y , int k ) { if ( x == 0 && y == 0 ) return ; else if ( x == 0 ) { y -- ; Console . Write ( " V " ) ; Ksmallest ( x , y , k ) ; } else if ( y == 0 ) { x -- ; Console . Write ( " H " ) ; Ksmallest ( x , y , k ) ; } else { if ( factorial ( x - 1 , y ) > k ) { Console . Write ( " H " ) ; Ksmallest ( x - 1 , y , k ) ; } else { Console . Write ( " V " ) ; Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) ; } } } public static void Main ( String [ ] args ) { int x = 2 , y = 2 , k = 2 ; Ksmallest ( x , y , k ) ; } }
using System ; class GFG { static int centered_pentagonal_Num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; } public static void Main ( ) { int n = 7 ; Console . Write ( n + " th ▁ Centered ▁ " + " pentagonal ▁ number : ▁ " ) ; Console . WriteLine ( centered_pentagonal_Num ( n ) ) ; } }
using System ; class GFG { static int pivotDis ( int x0 , int y0 , int x1 , int y1 ) { return ( int ) Math . Sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) ; } static int minDis ( int D , int r1 , int r2 ) { return Math . Max ( ( D - r1 - r2 ) , 0 ) ; } static int maxDis ( int D , int r1 , int r2 ) { return D + r1 + r2 ; } public static void Main ( ) { int x0 = 0 , y0 = 0 , x1 = 8 , y1 = 0 , r1 = 4 , r2 = 5 ; int D = pivotDis ( x0 , y0 , x1 , y1 ) ; Console . WriteLine ( " Distance ▁ while ▁ " + " repulsion ▁ = ▁ " + maxDis ( D , r1 , r2 ) ) ; Console . WriteLine ( " Distance ▁ while ▁ " + " attraction ▁ = ▁ " + minDis ( D , r1 , r2 ) ) ; } }
using System ; class GFG { static double maximumValueOfF ( int R ) { return 4 * R * R + 0.25 ; } public static void Main ( ) { int R = 3 ; Console . WriteLine ( maximumValueOfF ( R ) ) ; } }
using System ; class GFG { static void otherEndPoint ( int x1 , int y1 , int m1 , int m2 ) { float x2 = ( float ) ( 2 * m1 - x1 ) ; float y2 = ( float ) ( 2 * m2 - y1 ) ; Console . WriteLine ( " x2 ▁ = ▁ " + x2 + " , ▁ " + " y2 ▁ = ▁ " + y2 ) ; } public static void Main ( String [ ] args ) { int x1 = - 4 , y1 = - 1 , m1 = 3 , m2 = 5 ; otherEndPoint ( x1 , y1 , m1 , m2 ) ; } }
using System . Linq ; using System ; public class GFG { static void printRect ( int [ ] X , int [ ] Y , int n ) { int Xmax = X . Max ( ) ; int Xmin = X . Min ( ) ; int Ymax = Y . Max ( ) ; int Ymin = Y . Min ( ) ; Console . WriteLine ( " { " + Xmin + " , ▁ " + Ymin + " } " ) ; Console . WriteLine ( " { " + Xmin + " , ▁ " + Ymax + " } " ) ; Console . WriteLine ( " { " + Xmax + " , ▁ " + Ymax + " } " ) ; Console . WriteLine ( " { " + Xmax + " , ▁ " + Ymin + " } " ) ; } static public void Main ( ) { int [ ] X = { 4 , 3 , 6 , 1 , - 1 , 12 } ; int [ ] Y = { 4 , 1 , 10 , 3 , 7 , - 1 } ; int n = X . Length ; printRect ( X , Y , n ) ; } }
using System ; class GFG { static bool checkOrigin ( int x1 , int y1 , int x2 , int y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; } public static void Main ( ) { if ( checkOrigin ( 1 , 28 , 2 , 56 ) == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool isBetween ( int a , int b , int c ) { return ( Math . Min ( a , b ) <= c && c <= Math . Max ( a , b ) ) ; } static bool canJoin ( int [ ] x , int [ ] y , int i , int j , int k ) { return ( x [ k ] == x [ i ] x [ k ] == x [ j ] ) && isBetween ( y [ i ] , y [ j ] , y [ k ] ) || ( y [ k ] == y [ i ] y [ k ] == y [ j ] ) && isBetween ( x [ i ] , x [ j ] , x [ k ] ) ; } static int countLineSegments ( int [ ] x , int [ ] y ) { if ( ( x [ 0 ] == x [ 1 ] && x [ 1 ] == x [ 2 ] ) || ( y [ 0 ] == y [ 1 ] && y [ 1 ] == y [ 2 ] ) ) return 1 ; else if ( canJoin ( x , y , 0 , 1 , 2 ) || canJoin ( x , y , 0 , 2 , 1 ) || canJoin ( x , y , 1 , 2 , 0 ) ) return 2 ; else return 3 ; } public static void Main ( ) { int [ ] x = new int [ 3 ] ; int [ ] y = new int [ 3 ] ; x [ 0 ] = - 1 ; y [ 0 ] = - 1 ; x [ 1 ] = - 1 ; y [ 1 ] = 3 ; x [ 2 ] = 4 ; y [ 2 ] = 3 ; Console . WriteLine ( countLineSegments ( x , y ) ) ; } }
using System ; class GFG { static Boolean pythagorean_quadruple ( int a , int b , int c , int d ) { int sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; } public static void Main ( ) { int a = 1 , b = 2 , c = 2 , d = 3 ; if ( pythagorean_quadruple ( a , b , c , d ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class demo { static float pi = 3.14159f ; public static float volume ( float r , float R , float h ) { return ( float ) 1 / 3 * pi * h * ( r * r + R * R + r * R ) ; } public static float curved_surface_area ( float r , float R , float l ) { return pi * l * ( R + r ) ; } public static float total_surface_area ( float r , float R , float l , float h ) { return pi * l * ( R + r ) + pi * ( r * r + R * R ) ; } public static void Main ( ) { float small_radius = 3 ; float big_radius = 8 ; float slant_height = 13 ; float height = 12 ; Console . Write ( " Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " ) ; Console . WriteLine ( volume ( small_radius , big_radius , height ) ) ; Console . Write ( " Curved ▁ Surface ▁ Area ▁ Of " + " ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " ) ; Console . WriteLine ( curved_surface_area ( small_radius , big_radius , slant_height ) ) ; Console . Write ( " Total ▁ Surface ▁ Area ▁ Of " + " ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " ) ; Console . WriteLine ( total_surface_area ( small_radius , big_radius , slant_height , height ) ) ; } }
using System ; class GFG { static int Circumference ( int a ) { return 4 * a ; } public static void Main ( ) { int a = 5 ; Console . WriteLine ( " Circumference " + " ▁ of ▁ a ▁ square ▁ is ▁ " + Circumference ( a ) ) ; } }
using System ; class GFG { static double maxArea ( double a , double b , double c , double d ) { double semiperimeter = ( a + b + c + d ) / 2 ; return Math . Sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; } public static void Main ( ) { double a = 1 , b = 2 , c = 1 , d = 2 ; Console . WriteLine ( maxArea ( a , b , c , d ) ) ; } }
using System ; class GFG { static int minRadius ( int k , int [ ] x , int [ ] y , int n ) { int [ ] dis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; Array . Sort ( dis ) ; return dis [ k - 1 ] ; } public static void Main ( ) { int k = 3 ; int [ ] x = { 1 , - 1 , 1 } ; int [ ] y = { 1 , - 1 , - 1 } ; int n = x . Length ; Console . WriteLine ( minRadius ( k , x , y , n ) ) ; } }
using System ; class GFG { static int areaRectangle ( int a , int b ) { int area = a * b ; return area ; } static int perimeterRectangle ( int a , int b ) { int perimeter = 2 * ( a + b ) ; return perimeter ; } public static void Main ( ) { int a = 5 ; int b = 6 ; Console . WriteLine ( " Area ▁ = ▁ " + areaRectangle ( a , b ) ) ; Console . WriteLine ( " Perimeter ▁ = ▁ " + perimeterRectangle ( a , b ) ) ; } }
using System ; class GFG { static int areaSquare ( int side ) { int area = side * side ; return area ; } public static void Main ( ) { int side = 4 ; Console . WriteLine ( areaSquare ( side ) ) ; } }
using System ; class GFG { public static long minPerimeter ( int n ) { int l = ( int ) Math . Sqrt ( n ) ; int sq = l * l ; if ( sq == n ) return l * 4 ; else { long row = n / l ; long perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } } public static void Main ( ) { int n = 10 ; Console . Write ( minPerimeter ( n ) ) ; } }
using System ; class GFG { static void possibleOrNot ( long a1 , long a2 , long b1 , long b2 , long c1 , long c2 ) { long dis1 = ( long ) Math . Pow ( b1 - a1 , 2 ) + ( long ) Math . Pow ( b2 - a2 , 2 ) ; long dis2 = ( long ) Math . Pow ( c1 - b1 , 2 ) + ( long ) Math . Pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) Console . Write ( " No " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) Console . Write ( " No " ) ; else Console . Write ( " Yes " ) ; } public static void Main ( ) { long a1 = 1 , a2 = 0 , b1 = 2 , b2 = 0 , c1 = 3 , c2 = 0 ; possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) ; } }
using System ; class GFG { static int circle ( int x1 , int y1 , int x2 , int y2 , int r1 , int r2 ) { int distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; int radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; } public static void Main ( ) { int x1 = - 10 , y1 = 8 ; int x2 = 14 , y2 = - 24 ; int r1 = 30 , r2 = 10 ; int t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) Console . WriteLine ( " Circle ▁ touch " + " ▁ to ▁ each ▁ other . " ) ; else if ( t < 0 ) Console . WriteLine ( " Circle ▁ not ▁ touch " + " ▁ to ▁ each ▁ other . " ) ; else Console . WriteLine ( " Circle ▁ intersect " + " ▁ to ▁ each ▁ other . " ) ; } }
using System ; class GFG { static int countObtuseAngles ( int a , int b , int k ) { int c1 = ( b - a ) - 1 ; int c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return Math . Min ( c1 , c2 ) ; } public static void Main ( ) { int k = 6 , a = 1 , b = 3 ; Console . WriteLine ( countObtuseAngles ( a , b , k ) ) ; } }
using System ; class GFG { static void findTriangle ( int [ ] a , int n ) { int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; Array . Sort ( a ) ; Array . Sort ( b ) ; int x = 0 , y = 0 , z = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int p = i + 1 ; int q = i + 1 ; for ( int j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . Max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . Max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . Max ( p - j , 0 ) ; z += q - p ; } } } Console . Write ( " Acute ▁ Triangle : ▁ " + x + " STRNEWLINE " ) ; Console . Write ( " Right ▁ Triangle : ▁ " + y + " STRNEWLINE " ) ; Console . Write ( " Obtuse ▁ Triangle : ▁ " + z + " STRNEWLINE " ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 2 , 3 , 9 , 10 , 12 , 15 } ; int n = arr . Length ; findTriangle ( arr , n ) ; } }
using System ; class GFG { public static double polygonArea ( double [ ] X , double [ ] Y , int n ) { double area = 0.0 ; int j = n - 1 ; for ( int i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . Abs ( area / 2.0 ) ; } public static void Main ( ) { double [ ] X = { 0 , 2 , 4 } ; double [ ] Y = { 1 , 3 , 7 } ; int n = 3 ; Console . WriteLine ( polygonArea ( X , Y , n ) ) ; } }
using System ; class GFG { static void last_digit ( int X , int Y ) { Console . Write ( X % Y ) ; } public static void Main ( String [ ] args ) { int X = 55 , Y = 3 ; last_digit ( X , Y ) ; } }
using System ; class GFG { static void printRoots ( long a , long b , long c ) { Console . WriteLine ( "1 , ▁ " + c / ( a * 1.0 ) ) ; } public static void Main ( ) { long a = 2 ; long b = 3 ; long c = - 5 ; printRoots ( a , b , c ) ; } }
using System ; class GFG { static int MAX = 130 ; static Boolean validQuadruple ( int [ ] arr , int n ) { if ( n >= MAX ) return true ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) for ( int l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 2 , 3 , 7 } ; int n = arr . Length ; if ( validQuadruple ( arr , n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool solve ( int n , int k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; } static public void Main ( ) { int n = 12 , k = 4 ; if ( solve ( n , k ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int closetAND ( int [ ] arr , int n , int k ) { int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . Min ( ans , Math . Abs ( k - X ) ) ; } } return ans ; } public static void Main ( ) { int [ ] arr = { 4 , 7 , 10 } ; int n = arr . Length ; int k = 2 ; Console . WriteLine ( closetAND ( arr , n , k ) ) ; } }
using System ; class GFG { static int Rate ( int N1 , int N2 ) { float rate = ( N2 - N1 ) * 100 / N1 ; return ( int ) rate ; } static public void Main ( ) { int N1 = 100 , N2 = 120 ; Console . WriteLine ( Rate ( N1 , N2 ) + " ▁ % " ) ; } }
using System ; using System . Linq ; using System . Collections . Generic ; class GFG { static int getPrime ( int [ ] arr , int n ) { int max_val = arr . Max ( ) ; List < Boolean > prime = new List < Boolean > ( max_val + 1 ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) prime . Insert ( i , true ) ; prime . Insert ( 1 , false ) ; prime . Insert ( 2 , false ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime . Insert ( i , false ) ; } } int maximum = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { maximum = Math . Max ( maximum , arr [ i ] ) ; } } return maximum ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 10 , 15 , 7 , 6 , 8 , 13 } ; int n = arr . Length ; Console . WriteLine ( getPrime ( arr , n ) ) ; } }
using System ; class GFG { static long getMinNum ( int N ) { int lcm = 1 ; for ( int i = 2 ; i <= N ; i ++ ) lcm = ( ( i * lcm ) / ( __gcd ( i , lcm ) ) ) ; return ( lcm + 1 ) ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void Main ( ) { int N = 5 ; Console . WriteLine ( getMinNum ( N ) ) ; } }
using System ; class GFG { static double maxEdges ( double N ) { double edges = 0 ; edges = Math . Floor ( ( N * N ) / 4 ) ; return edges ; } static public void Main ( ) { double N = 5 ; Console . WriteLine ( maxEdges ( N ) ) ; } }
using System ; class GFG { static void Permutation ( int n , int k ) { int [ ] p = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( int i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( p [ i ] + " ▁ " ) ; } static public void Main ( ) { int n = 5 , k = 2 ; Permutation ( n , k ) ; } }
using System ; class GFG { static int validPosition ( int [ ] arr , int N , int K ) { int count = 0 , sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 1 , 6 , 7 } ; int K = 4 ; int N = arr . Length ; Console . WriteLine ( validPosition ( arr , N , K ) ) ; } }
using System ; class GFG { static int maxBitElement ( int [ ] arr , int n ) { int num = 0 , max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = BitCount ( arr [ i ] ) ; if ( cnt > max ) { max = cnt ; num = arr [ i ] ; } } return num ; } static int BitCount ( int n ) { int count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 2 , 4 , 7 , 1 , 10 , 5 , 8 , 9 , 6 } ; int n = arr . Length ; Console . Write ( maxBitElement ( arr , n ) ) ; } }
using System ; class GFG { static int smallestSum ( int n ) { if ( n == 1 ) return 0 ; return ( 2 * ( int ) Math . Pow ( 10 , n - 1 ) ) ; } static int largestSum ( int n ) { return ( 2 * ( ( int ) Math . Pow ( 10 , n ) - 1 ) ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( " Largest ▁ = ▁ " + largestSum ( n ) ) ; Console . Write ( " Smallest ▁ = ▁ " + smallestSum ( n ) ) ; } }
using System ; class GFG { static int count_pairs ( int [ ] a , int [ ] b , int n , int m ) { int odd1 = 0 , even1 = 0 ; int odd2 = 0 , even2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd1 ++ ; } else { even1 ++ ; } } for ( int i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) { odd2 ++ ; } else { even2 ++ ; } } int pairs = Math . Min ( odd1 , even2 ) + Math . Min ( odd2 , even1 ) ; return pairs ; } static public void Main ( ) { int [ ] a = { 9 , 14 , 6 , 2 , 11 } ; int [ ] b = { 8 , 4 , 7 , 20 } ; int n = a . Length ; int m = b . Length ; Console . WriteLine ( count_pairs ( a , b , n , m ) ) ; } }
using System ; class GFG { static int find_leftmost_unsetbit ( int n ) { int ind = - 1 ; int i = 1 ; while ( n > 0 ) { if ( ( n % 2 ) != 1 ) { ind = i ; } i ++ ; n >>= 1 ; } return ind ; } static void perform_steps ( int n ) { int left = find_leftmost_unsetbit ( n ) ; if ( left == - 1 ) { Console . Write ( " No ▁ steps ▁ required " ) ; return ; } int step = 1 ; while ( find_leftmost_unsetbit ( n ) != - 1 ) { if ( step % 2 == 0 ) { n += 1 ; Console . WriteLine ( " Step " + step + " : ▁ Increase ▁ by ▁ 1" ) ; } else { int m = find_leftmost_unsetbit ( n ) ; int num = ( int ) ( Math . Pow ( 2 , m ) - 1 ) ; n = n ^ num ; Console . WriteLine ( " Step " + step + " : ▁ Xor ▁ with ▁ " + num ) ; } step += 1 ; } } static public void Main ( ) { int n = 39 ; perform_steps ( n ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int vertices ( int N , int A , int B ) { int position = 0 ; int minisum = int . MaxValue ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { int x = Math . Abs ( i - A ) ; int y = Math . Abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; } public static void Main ( String [ ] args ) { int N = 3 , A = 1 , B = 2 ; Console . WriteLine ( " Vertex ▁ = ▁ " + vertices ( N , A , B ) ) ; } }
using System ; class GFG { static int factorial ( int n ) { int f = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; } static int sumFactorial ( int [ ] arr , int n ) { int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; } public static void Main ( ) { int [ ] arr = { 7 , 3 , 5 , 4 , 8 } ; int n = arr . Length ; Console . WriteLine ( sumFactorial ( arr , n ) ) ; } }
using System ; class GFG { static int highestPower ( String str , int len ) { int ans = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' ) ans ++ ; else break ; } return ans ; } public static void Main ( String [ ] args ) { String str = "100100" ; int len = str . Length ; Console . WriteLine ( highestPower ( str , len ) ) ; } }
using System ; class GFG { static long mod = ( long ) ( 1e9 + 7 ) ; static long factorial ( long n , long p ) { for ( int i = 2 ; i <= n ; i ++ ) res = ( res * i ) % p ; return res ; } static long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long modInverse ( long n , long p ) { return power ( n , p - 2 , p ) ; } static long nCrModP ( long n , long r , long p ) { if ( r == 0 ) return 1 ; long [ ] fac = new long [ ( int ) n + 1 ] ; fac [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ ( int ) n ] * modInverse ( fac [ ( int ) r ] , p ) % p * modInverse ( fac [ ( int ) n - ( int ) r ] , p ) % p ) % p ; } static long countArrangements ( long n , long k , long p ) { return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p ; } public static void Main ( ) { long N = 5 , K = 8 ; Console . WriteLine ( countArrangements ( N , K , mod ) ) ; } }
using System ; class GFG { static int maxProd ( int N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . Max ( maxProd ( N / 10 ) * ( N % 10 ) , maxProd ( N / 10 - 1 ) * 9 ) ; } static public void Main ( ) { int N = 390 ; Console . WriteLine ( maxProd ( N ) ) ; } }
using System ; class GFG { static int N = 2 ; static int M = 3 ; static bool check ( int [ , ] mat ) { int xorr = 0 ; for ( int i = 0 ; i < N ; i ++ ) { xorr ^= mat [ i , 0 ] ; } if ( xorr != 0 ) return true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 1 ; j < M ; j ++ ) { if ( mat [ i , j ] != mat [ i , 0 ] ) return true ; } } return false ; } static void Main ( ) { int [ , ] mat = { { 7 , 7 , 7 } , { 10 , 10 , 7 } } ; if ( check ( mat ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int sumodd ( int n ) { return ( n * n ) ; } static int sumeven ( int n ) { return ( n * ( n + 1 ) ) ; } static int findSum ( int num ) { int sumo = 0 ; int sume = 0 ; int x = 1 ; int cur = 0 ; int ans = 0 ; while ( num > 0 ) { int inc = Math . Min ( x , num ) ; num -= inc ; if ( cur == 0 ) { ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) ; sumo += inc ; } else { ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) ; sume += inc ; } x *= 2 ; cur ^= 1 ; } return ans ; } public static void Main ( String [ ] args ) { int n = 4 ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; class GFG { static int oddTriangularNumber ( int N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; } public static void Main ( String [ ] args ) { int N = 3 ; Console . WriteLine ( oddTriangularNumber ( N ) ) ; } }
using System ; class GFG { static void idstrt ( double a1 , double b1 , double c1 , double a2 , double b2 , double c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) Console . WriteLine ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ identical " ) ; else Console . WriteLine ( " The ▁ given ▁ straight " + " ▁ lines ▁ are ▁ not ▁ identical " ) ; } public static void Main ( String [ ] args ) { double a1 = - 2 , b1 = 4 , c1 = 3 , a2 = - 6 , b2 = 12 , c2 = 9 ; idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) ; } }
using System ; class GFG { static void line ( double x0 , double y0 ) { double c = ( int ) ( 2 * y0 * x0 ) ; Console . WriteLine ( y0 + " x " + " ▁ + ▁ " + x0 + " y ▁ = ▁ " + c ) ; } public static void Main ( String [ ] args ) { double x0 = 4 , y0 = 3 ; line ( x0 , y0 ) ; } }
using System ; class GFG { static int N = 3 ; static int M = 7 ; static void printOriginalMatrix ( int [ ] a , int [ ] b , int [ , ] mat ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mat [ i , j ] == 1 ) Console . Write ( Math . Min ( a [ i ] , b [ j ] ) + " ▁ " ) ; else Console . Write ( "0" + " ▁ " ) ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int [ ] a = { 2 , 1 , 3 } ; int [ ] b = { 2 , 3 , 0 , 0 , 2 , 0 , 1 } ; int [ , ] mat = { { 1 , 0 , 0 , 0 , 1 , 0 , 0 } , { 0 , 0 , 0 , 0 , 0 , 0 , 1 } , { 1 , 1 , 0 , 0 , 0 , 0 , 0 } } ; printOriginalMatrix ( a , b , mat ) ; } }
using System ; class GFG { static float percent ( int n , int x ) { float p = n * x ; p /= 100 ; return p ; } static float getLoss ( int [ ] price , int [ ] quantity , int [ ] X , int n ) { float loss = 0 ; for ( int i = 0 ; i < n ; i ++ ) { float originalPrice = price [ i ] ; float sellingPrice = originalPrice + percent ( ( int ) originalPrice , X [ i ] ) ; float afterDiscount = sellingPrice - percent ( ( int ) sellingPrice , X [ i ] ) ; loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; } return loss ; } public static void Main ( ) { int [ ] price = { 20 , 48 , 200 , 100 } ; int [ ] quantity = { 20 , 48 , 1 , 1 } ; int [ ] X = { 0 , 48 , 200 , 5 } ; int n = X . Length ; Console . Write ( getLoss ( price , quantity , X , n ) ) ; } }
using System ; class GFG { static int maxAbsDiff ( int [ ] arr , int n ) { int minEle = arr [ 0 ] ; int maxEle = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { minEle = Math . Min ( minEle , arr [ i ] ) ; maxEle = Math . Max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; } public static void Main ( ) { int [ ] arr = { 2 , 1 , 5 , 3 } ; int n = arr . Length ; Console . WriteLine ( maxAbsDiff ( arr , n ) ) ; } }
using System ; class GFG { static int maxSubArraySum ( int [ ] a , int size ) { int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } static int maximizeSum ( int [ ] a , int n ) { int cnt = 0 ; int mini = int . MaxValue ; int minSubarray = int . MaxValue ; int sum = maxSubArraySum ( a , n ) ; int max_so_far = int . MinValue , max_ending_here = 0 ; for ( int i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; cnt ++ ; minSubarray = Math . Min ( a [ i ] , minSubarray ) ; if ( sum == max_ending_here ) { if ( cnt == 1 ) mini = Math . Min ( mini , 0 ) ; else mini = Math . Min ( mini , minSubarray ) ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; cnt = 0 ; minSubarray = int . MaxValue ; } } return sum - mini ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 2 , 3 , - 2 , 3 } ; int n = a . Length ; Console . WriteLine ( maximizeSum ( a , n ) ) ; } }
using System ; class GFG { static bool isOsiris ( int n ) { int a = n % 10 ; int b = ( n / 10 ) % 10 ; int c = n / 100 ; int digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; } static void Main ( ) { int n = 132 ; if ( isOsiris ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool isDudeney ( int n ) { int cube_rt = ( int ) ( Math . Round ( ( Math . Pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; int dig_sum = 0 ; int temp = n ; while ( temp > 0 ) { int rem = temp % 10 ; dig_sum += rem ; temp /= 10 ; } if ( cube_rt != dig_sum ) return false ; return true ; } public static void Main ( ) { int n = 17576 ; if ( isDudeney ( n ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int countTriangles ( int [ ] a , int n ) { int cnt = 0 ; int pairs = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += ( 2 * pairs ) / 3 ; return cnt ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 2 , 2 , 2 } ; int n = a . Length ; Console . WriteLine ( countTriangles ( a , n ) ) ; } }
using System ; class GFG { static int smallestMultiple ( int n ) { if ( n == 1 ) return 5 ; return ( int ) ( Math . Pow ( 10 , n - 1 ) ) ; } public static void Main ( ) { int n = 4 ; Console . Write ( smallestMultiple ( n ) ) ; } }
using System ; class GFG { static int getHCF ( int x , int y ) { int minimum = Math . Min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( int i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; } static void Main ( ) { int x = 16 , y = 32 ; Console . WriteLine ( getHCF ( x , y ) ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isDivisible ( int n ) { if ( isPrime ( n + 1 ) ) return false ; return true ; } static void Main ( ) { int n = 6 ; if ( isDivisible ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int R = 5 ; static int C = 5 ; static int findMaxCock ( int [ , ] ar ) { if ( R < 3 C < 3 ) return - 1 ; int max_sum = int . MinValue ; for ( int i = 0 ; i < R - 2 ; i ++ ) { for ( int j = 0 ; j < C - 2 ; j ++ ) { int sum = ( ar [ i , j ] + ar [ i , j + 2 ] ) + ( ar [ i + 1 , j + 1 ] ) + ( ar [ i + 2 , j ] + ar [ i + 2 , j + 1 ] + ar [ i + 2 , j + 2 ] ) ; max_sum = Math . Max ( max_sum , sum ) ; } } return max_sum ; } public static void Main ( ) { int [ , ] ar = { { 0 , 3 , 0 , 6 , 0 } , { 0 , 1 , 1 , 0 , 0 } , { 1 , 1 , 1 , 0 , 0 } , { 0 , 0 , 2 , 0 , 1 } , { 0 , 2 , 0 , 1 , 3 } } ; Console . WriteLine ( findMaxCock ( ar ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { public static int segments ( int n , int [ ] p , int m ) { Dictionary < int , int > c = new Dictionary < int , int > ( ) ; c . Add ( 0 , 1 ) ; bool has = false ; int sum = 0 ; int ans = 0 ; for ( int r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) has = true ; if ( has ) ans += ( ! c . ContainsKey ( sum ) ? 0 : c [ sum ] ) + ( ! c . ContainsKey ( sum - 1 ) ? 0 : c [ sum - 1 ] ) ; else c . Add ( sum , ! c . ContainsKey ( sum ) ? 1 : c [ sum ] + 1 ) ; } return ans ; } public static void Main ( String [ ] args ) { int [ ] a = { 2 , 4 , 5 , 3 , 1 } ; int n = a . Length ; int m = 4 ; Console . WriteLine ( segments ( n , a , m ) ) ; } }
using System ; class GFG { static int oddDays ( int N ) { int hund1 = N / 100 ; int hund4 = N / 400 ; int leap = N >> 2 ; int ord = N - leap ; if ( hund1 > 0 ) { ord += hund1 ; leap -= hund1 ; } if ( hund4 > 0 ) { ord -= hund4 ; leap += hund4 ; } int days = ord + leap * 2 ; int odd = days % 7 ; return odd ; } static void Main ( ) { int N = 100 ; Console . WriteLine ( oddDays ( N ) ) ; } }
using System ; class GFG { static float ellipsearea ( float r ) { if ( r < 0 ) return - 1 ; float a = ( float ) ( ( 3.14 * r * r ) / 4 ) ; return a ; } public static void Main ( ) { float r = 5 ; Console . WriteLine ( ellipsearea ( r ) ) ; } }
using System ; class GfG { static int CntDivbyX ( int [ ] arr , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = arr . Length ; int x = 2 ; Console . WriteLine ( CntDivbyX ( arr , n , x ) ) ; } }
using System ; class GfG { static int countCon ( int [ ] ar , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; } public static void Main ( ) { int [ ] ar = { 1 , 2 , 2 , 3 , 4 , 4 , 5 , 5 , 5 , 5 } ; int n = ar . Length ; Console . WriteLine ( countCon ( ar , n ) ) ; } }
using System ; class GFG { static void reduceFraction ( int x , int y ) { int d ; d = __gcd ( x , y ) ; x = x / d ; y = y / d ; Console . WriteLine ( " x ▁ = ▁ " + x + " , ▁ y ▁ = ▁ " + y ) ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int x = 16 ; int y = 10 ; reduceFraction ( x , y ) ; } }
using System ; class GFG { static float noOfYears ( int t1 , int n1 , int t2 ) { float years = ( ( t2 - 1 ) * n1 / ( float ) ( t1 - 1 ) ) ; return years ; } public static void Main ( String [ ] args ) { int T1 = 3 , N1 = 5 , T2 = 6 ; Console . WriteLine ( noOfYears ( T1 , N1 , T2 ) ) ; } }
using System ; class GFG { static bool isPossible ( int n ) { int [ ] fac = new int [ 10 ] ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( int i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; int sum = 0 ; int x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x /= 10 ; } if ( sum % n == 0 ) return true ; return false ; } public static void Main ( ) { int n = 19 ; if ( isPossible ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void findSubsequence ( int [ ] arr , int n , int k ) { Dictionary < int , int > M = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { if ( M . ContainsKey ( arr [ i ] ) ) M [ arr [ i ] ] ++ ; else M [ arr [ i ] ] = 1 ; } int [ ] numCount = new int [ k + 1 ] ; for ( int i = 0 ; i <= k ; ++ i ) numCount [ i ] = 0 ; Dictionary < int , int > . KeyCollection keyColl = M . Keys ; foreach ( int key in keyColl ) { if ( key <= k ) { for ( int i = 1 ; ; ++ i ) { if ( key * i > k ) break ; numCount [ key * i ] += M [ key ] ; } } else break ; } int lcm = 0 , length = 0 ; for ( int i = 1 ; i <= k ; ++ i ) { if ( numCount [ i ] > length ) { length = numCount [ i ] ; lcm = i ; } } if ( lcm == 0 ) Console . WriteLine ( - 1 ) ; else { Console . WriteLine ( " LCM ▁ = ▁ " + lcm + " ▁ Length ▁ = ▁ " + length ) ; Console . Write ( " Indexes ▁ = ▁ " ) ; for ( int i = 0 ; i < n ; ++ i ) if ( lcm % arr [ i ] == 0 ) Console . Write ( i + " ▁ " ) ; } } public static void Main ( ) { int k = 14 ; int [ ] arr = { 2 , 3 , 4 , 5 } ; int n = arr . Length ; findSubsequence ( arr , n , k ) ; } }
using System ; class GFG { static int mod = ( int ) ( 1e9 + 7 ) ; static int power ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static int findCount ( int N ) { int count = power ( 2 , N , mod ) ; return count ; } public static void Main ( ) { int N = 25 ; Console . WriteLine ( findCount ( N ) ) ; } }
using System ; class GFG { static int msb ( int x ) { int ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; } static int xorRange ( int l , int r ) { int max_bit = msb ( r ) ; int mul = 2 ; int ans = 0 ; for ( int i = 1 ; i <= max_bit ; i ++ ) { if ( ( l / mul ) * mul == ( r / mul ) * mul ) { if ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ans += mul ; mul *= 2 ; continue ; } int odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ; if ( odd_c != 0 ) ans += mul ; mul *= 2 ; } int zero_bit_cnt = zero_bit_cnt = ( r - l + 1 ) / 2 ; if ( l % 2 == 1 && r % 2 == 1 ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans ++ ; return ans ; } public static void Main ( String [ ] args ) { int l = 1 , r = 4 ; Console . Write ( xorRange ( l , r ) ) ; } }
using System ; class GFG { static long computeXOR ( int n ) { int x = n & 3 ; switch ( x ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } return 0 ; } static void Main ( ) { int l = 1 , r = 4 ; Console . WriteLine ( computeXOR ( r ) ^ computeXOR ( l - 1 ) ) ; } }
using System ; class GFG { static int countNumbers ( int x , int n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; } public static void Main ( ) { int n = 120 ; Console . WriteLine ( countNumbers ( 1 , n ) ) ; } }
using System ; class GFG { static bool checkfact ( int N , int countprime , int prime ) { int countfact = 0 ; if ( prime == 2 prime == 3 ) countfact ++ ; int divide = prime ; while ( N / divide != 0 ) { countfact += N / divide ; divide = divide * divide ; } if ( countfact >= countprime ) return true ; else return false ; } static bool check ( int N ) { int sumsquares = ( N + 1 ) * ( 2 * N + 1 ) ; int countprime = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( sumsquares ) ; i ++ ) { int flag = 0 ; while ( sumsquares % i == 0 ) { flag = 1 ; countprime ++ ; sumsquares /= i ; } if ( flag == 1 ) { if ( ! checkfact ( N - 1 , countprime , i ) ) return false ; countprime = 0 ; } } if ( sumsquares != 1 ) if ( ! checkfact ( N - 1 , 1 , sumsquares ) ) return false ; return true ; } public static void Main ( ) { int N = 5 ; if ( check ( N ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int countNonIncreasing ( int [ ] arr , int n ) { int cnt = 0 ; int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , 2 , 3 , 7 , 1 , 1 } ; int n = arr . Length ; Console . Write ( countNonIncreasing ( arr , n ) ) ; } }
using System ; class GFG { static int printPermutation ( int n ) { if ( n % 2 != 0 ) { Console . WriteLine ( " - 1" ) ; } else for ( int i = 1 ; i <= n / 2 ; i ++ ) { Console . WriteLine ( 2 * i + " ▁ " + ( ( 2 * i ) - 1 ) + " ▁ " ) ; } return n ; } public static void Main ( String [ ] args ) { int n = 4 ; printPermutation ( n ) ; } }
using System ; class GFG { static int MAXN = 10000000 ; static int minimumSteps ( int n , int m , int a , int b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . Min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; } public static void Main ( ) { int n = 120 , m = 51840 ; int a = 2 , b = 3 ; Console . WriteLine ( minimumSteps ( n , m , a , b ) ) ; } }
using System ; class GFG { static int minOperations ( int n , int m ) { if ( m % n != 0 ) return - 1 ; int minOperations = 0 ; int q = m / n ; while ( q % 2 == 0 ) { q = q / 2 ; minOperations ++ ; } while ( q % 3 == 0 ) { q = q / 3 ; minOperations ++ ; } if ( q == 1 ) return minOperations ; return - 1 ; } public static void Main ( ) { int n = 120 , m = 51840 ; Console . WriteLine ( minOperations ( n , m ) ) ; } }
using System ; class GFG { static int fib ( int n ) { double phi = ( 1 + Math . Sqrt ( 5 ) ) / 2 ; return ( int ) Math . Round ( Math . Pow ( phi , n ) / Math . Sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; } public static void Main ( ) { int l = 4 , r = 8 ; Console . WriteLine ( calculateSum ( l , r ) ) ; } }
using System ; class GFG { static float sphereSide ( float h , float r ) { if ( h < 0 && r < 0 ) return - 1 ; float R = ( float ) ( ( h * r * Math . Sqrt ( 2 ) ) / ( h + Math . Sqrt ( 2 ) * r ) ) / 2 ; return R ; } public static void Main ( ) { float h = 5 , r = 6 ; Console . WriteLine ( sphereSide ( h , r ) ) ; } }
class GFG { static int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; } static void Main ( ) { int n = 20 ; System . Console . WriteLine ( possibleways ( n ) ) ; } }
using System ; class GFG { static int countSubarrays ( int [ ] arr , int n , int K ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { long product = 1 ; for ( int x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; } public static void Main ( ) { int [ ] arr = { 6 , 2 , 8 } ; int n = arr . Length ; int K = 4 ; Console . WriteLine ( countSubarrays ( arr , n , K ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void printMaxValPair ( List < long > v , int n ) { v . Sort ( ) ; long N = v [ ( int ) n - 1 ] ; if ( N % 2 == 1 ) { long first_maxima = N / 2 ; long second_maxima = first_maxima + 1 ; long ans1 = ( long ) 3e18 , ans2 = ( long ) 3e18 ; long from_left = - 1 , from_right = - 1 ; long from = - 1 ; for ( long i = 0 ; i < n ; ++ i ) { if ( v [ ( int ) i ] > first_maxima ) { from = i ; break ; } else { long diff = first_maxima - v [ ( int ) i ] ; if ( diff < ans1 ) { ans1 = diff ; from_left = v [ ( int ) i ] ; } } } from_right = v [ ( int ) from ] ; long diff1 = first_maxima - from_left ; long diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) Console . WriteLine ( N + " ▁ " + from_left ) ; else Console . WriteLine ( N + " ▁ " + from_right ) ; } else { long maxima = N / 2 ; long ans1 = ( long ) 3e18 ; long R = - 1 ; for ( long i = 0 ; i < n - 1 ; ++ i ) { long diff = Math . Abs ( v [ ( int ) i ] - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v [ ( int ) i ] ; } } Console . WriteLine ( N + " ▁ " + R ) ; } } public static void Main ( String [ ] args ) { long [ ] arr = { 1 , 1 , 2 , 3 , 6 , 1 } ; List < long > v = new List < long > ( ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) v . Add ( arr [ i ] ) ; int n = v . Count ; printMaxValPair ( v , n ) ; } }
using System ; class GFG { static int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; } public static void Main ( ) { int n = 5 , k = 2 ; Console . WriteLine ( Permutations ( n , k ) ) ; } }
using System ; class GFG { static long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) ; p = p * p ; if ( n % 2 == 1 ) p = p * a ; return p ; } static int countIntegers ( long l , long r ) { long ans = 0 , i = 1 ; long v = power ( 2 , i ) ; while ( v <= r ) { while ( v <= r ) { if ( v >= l ) ans ++ ; v = v * 3 ; } i ++ ; v = power ( 2 , i ) ; } if ( l == 1 ) ans ++ ; return ( int ) ans ; } public static void Main ( ) { long l = 12 , r = 21 ; Console . WriteLine ( countIntegers ( l , r ) ) ; } }
class GfG { static int findPairCount ( int N , int K ) { int count = 0 ; int [ ] rem = new int [ K ] ; rem [ 0 ] = N / K ; for ( int i = 1 ; i < K ; i ++ ) rem [ i ] = ( N - i ) / K + 1 ; if ( K % 2 == 0 ) { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( int i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; } static void Main ( ) { int N = 10 , K = 4 ; System . Console . WriteLine ( findPairCount ( N , K ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int N = 1000005 ; static Boolean [ ] prime = new Boolean [ N ] ; static void sieve ( ) { Array . Fill ( prime , true ) ; prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int i = 2 ; i < N ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * 2 ; j < N ; j += i ) { prime [ j ] = false ; } } } } static int sumTruncatablePrimes ( int n ) { int sum = 0 ; for ( int i = 2 ; i < n ; i ++ ) { int num = i ; Boolean flag = true ; while ( num > 0 ) { if ( ! prime [ num ] ) { flag = false ; break ; } num /= 10 ; } num = i ; int power = 10 ; while ( num / power > 0 ) { if ( ! prime [ num % power ] ) { flag = false ; break ; } power *= 10 ; } if ( flag ) { sum += i ; } } return sum ; } public static void Main ( String [ ] args ) { int n = 25 ; sieve ( ) ; Console . WriteLine ( sumTruncatablePrimes ( n ) ) ; } }
using System ; public class GFG { static void nDigitPerfectSquares ( int n ) { int smallest = ( int ) Math . Pow ( Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n - 1 ) ) ) , 2 ) ; Console . Write ( smallest + " ▁ " ) ; int largest = ( int ) Math . Pow ( Math . Ceiling ( Math . Sqrt ( Math . Pow ( 10 , n ) ) ) - 1 , 2 ) ; Console . Write ( largest ) ; } public static void Main ( String [ ] args ) { int n = 4 ; nDigitPerfectSquares ( n ) ; } }
using System ; class GFG { static int N = 3 ; static int MaxTraceSub ( int [ ] [ ] mat ) { int max_trace = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { int r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . Max ( trace , max_trace ) ; } } } return max_trace ; } public static void Main ( ) { int [ ] [ ] mat = new int [ ] [ ] { new int [ ] { 10 , 2 , 5 } , new int [ ] { 6 , 10 , 4 } , new int [ ] { 2 , 7 , - 10 } } ; Console . WriteLine ( MaxTraceSub ( mat ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static readonly int n = 3 ; static readonly int m = 3 ; static bool check ( int [ , ] a , int [ , ] b ) { for ( int i = 0 ; i < n ; i ++ ) { List < int > v1 = new List < int > ( ) ; List < int > v2 = new List < int > ( ) ; int r = i ; int col = 0 ; while ( r >= 0 && col < m ) { v1 . Add ( a [ r , col ] ) ; v2 . Add ( b [ r , col ] ) ; r -- ; col ++ ; } v1 . Sort ( ) ; v2 . Sort ( ) ; for ( int j = 0 ; j < v1 . Count ; j ++ ) { if ( v1 [ j ] != v2 [ j ] ) { return false ; } } } for ( int j = 1 ; j < m ; j ++ ) { List < int > v1 = new List < int > ( ) ; List < int > v2 = new List < int > ( ) ; int r = n - 1 ; int col = j ; while ( r >= 0 && col < m ) { v1 . Add ( a [ r , col ] ) ; v2 . Add ( b [ r , col ] ) ; r -- ; col ++ ; } v1 . Sort ( ) ; v2 . Sort ( ) ; for ( int i = 0 ; i < v1 . Count ; i ++ ) { if ( v1 [ i ] != v2 [ i ] ) { return false ; } } } return true ; } public static void Main ( ) { int [ , ] a = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; int [ , ] b = { { 1 , 4 , 7 } , { 2 , 5 , 6 } , { 3 , 8 , 9 } } ; if ( check ( a , b ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class Solution { public static void lastDigit ( String a , String b ) { int lastDig = ( a [ a . Length - 1 ] - '0' ) * ( b [ b . Length - 1 ] - '0' ) ; Console . Write ( lastDig % 10 ) ; } public static void Main ( ) { String a = "1234567891233" , b = "1234567891233156" ; lastDigit ( a , b ) ; } }
using System ; class GfG { static void printPalindrome ( int n ) { if ( n == 1 ) { Console . WriteLine ( " Smallest ▁ Palindrome : ▁ 0" ) ; Console . WriteLine ( " Largest ▁ Palindrome : ▁ 9" ) ; } else { Console . WriteLine ( " Smallest ▁ Palindrome : ▁ " + ( int ) ( Math . Pow ( 10 , n - 1 ) ) + 1 ) ; Console . WriteLine ( " Largest ▁ Palindrome : ▁ " + ( ( int ) ( Math . Pow ( 10 , n ) ) - 1 ) ) ; } } public static void Main ( String [ ] args ) { int n = 4 ; printPalindrome ( n ) ; } }
using System ; class GFG { static int printSum ( int a , int b ) { int res = 0 ; int temp1 = 0 , temp2 = 0 ; while ( a != 0 ) { temp1 = temp1 * 10 + ( a % 10 ) ; a /= 10 ; } a = temp1 ; while ( b != 0 ) { temp2 = temp2 * 10 + ( b % 10 ) ; b /= 10 ; } b = temp2 ; while ( a != 0 ) { int sum = ( a % 10 + b % 10 ) ; if ( sum / 10 == 0 ) res = res * 10 + sum ; else { temp1 = 0 ; while ( sum != 0 ) { temp1 = temp1 * 10 + ( sum % 10 ) ; sum /= 10 ; } sum = temp1 ; while ( sum != 0 ) { res = res * 10 + ( sum % 10 ) ; sum /= 10 ; } } a /= 10 ; b /= 10 ; } return res ; } public static void Main ( ) { int a = 7752 , b = 8834 ; Console . Write ( printSum ( a , b ) ) ; } }
using System ; class GFG { static int countDigits ( int a , int b ) { int count = 0 ; int p = Math . Abs ( a / b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; } public static void Main ( ) { int a = 100 ; int b = 10 ; Console . Write ( countDigits ( a , b ) ) ; } }
using System ; class GFG { public static int countDigits ( int a , int b ) { double digits = Math . Log10 ( Math . Abs ( a ) ) - Math . Log10 ( Math . Abs ( b ) ) + 1 ; return ( int ) Math . Floor ( digits ) ; } static void Main ( ) { int a = 100 ; int b = 10 ; Console . Write ( countDigits ( a , b ) ) ; } }
using System ; class Solution { static int smallestOdd ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) + 1 ; } public static void Main ( ) { int n = 4 ; Console . Write ( smallestOdd ( n ) ) ; } }
using System ; class GFG { static void findNumbers ( int n ) { int odd = ( int ) Math . Pow ( 10 , n ) - 1 ; int even = odd - 1 ; Console . WriteLine ( " Even ▁ = ▁ " + even ) ; Console . Write ( " Odd ▁ = ▁ " + odd ) ; } public static void Main ( ) { int n = 4 ; findNumbers ( n ) ; } }
using System ; class GFG { static int longestSubArray ( int [ ] arr , int n ) { bool isZeroPresent = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 0 , 1 , 2 , 0 } ; int n = arr . Length ; Console . Write ( longestSubArray ( arr , n ) ) ; } }
using System ; class Solution { static int smallestEven ( int n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; } public static void Main ( ) { int n = 4 ; Console . Write ( smallestEven ( n ) ) ; } }
using System ; class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int maxProfit ( int n , int a , int b , int x , int y ) { int res = x * ( n / a ) ; res += y * ( n / b ) ; res -= Math . Min ( x , y ) * ( n / ( ( a * b ) / __gcd ( a , b ) ) ) ; return res ; } static void Main ( ) { int n = 6 , a = 6 , b = 2 , x = 8 , y = 2 ; Console . WriteLine ( maxProfit ( n , a , b , x , y ) ) ; } }
using System ; class GFG { const int MOD = 1000000007 ; static int sumOfSeries ( int n ) { int ans = ( int ) Math . Pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; } public static void Main ( ) { int n = 10 ; Console . Write ( sumOfSeries ( n ) ) ; } }
using System ; class GFG { static int kthOdd ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . Length ; int k = 2 ; Console . WriteLine ( kthOdd ( arr , n , k ) ) ; } }
using System ; class GFG { public static void lastFiveDigits ( int n ) { n = ( n / 10000 ) * 10000 + ( ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( n / 10 ) % 10 ) * 10 + ( n / 1000 ) % 10 ; int ans = 1 ; for ( int i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } Console . WriteLine ( ans ) ; } public static void Main ( string [ ] args ) { int n = 12345 ; lastFiveDigits ( n ) ; } }
using System ; using System . Collections ; class GFG { static int mod = 1000000007 ; static long power ( long a , long n ) { if ( n == 0 ) { return 1 ; } long p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n == 1 ) { p = ( p * a ) % mod ; } return p ; } static long computeSum ( int [ ] arr , int n ) { Array . Sort ( arr ) ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { long maxs = ( power ( 2 , i ) - 1 + mod ) % mod ; maxs = ( maxs * arr [ i ] ) % mod ; long mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod ; mins = ( mins * arr [ i ] ) % mod ; long V = ( maxs - mins + mod ) % mod ; sum = ( sum + V ) % mod ; } return sum ; } public static void Main ( ) { int [ ] arr = { 4 , 3 , 1 } ; int n = arr . Length ; Console . WriteLine ( computeSum ( arr , n ) ) ; } }
using System ; class GFG { static int countNumbers ( int n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * ( int ) Math . Pow ( 10 , n / 2 - 1 ) ) ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( countNumbers ( n ) ) ; } }
using System ; class GFG { static int count ( int n ) { int cnt = 0 ; int p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; } public static void Main ( ) { int n = 7 ; Console . Write ( count ( n ) ) ; } }
using System ; class GFG { static int KthMinValAfterMconcatenate ( int [ ] A , int N , int M , int K ) { Array . Sort ( A ) ; return ( A [ ( ( K - 1 ) / M ) ] ) ; } static void Main ( ) { int [ ] A = { 3 , 1 , 2 } ; int M = 3 , K = 4 ; int N = A . Length ; Console . WriteLine ( KthMinValAfterMconcatenate ( A , N , M , K ) ) ; } }
using System ; public class GFG { public static int sum ( int n ) { n = ( n + 1 ) / 2 ; return ( n * n ) ; } public static void Main ( string [ ] args ) { int n = 3 ; Console . WriteLine ( sum ( n ) ) ; } }
using System ; class GFG { static int countNumbers ( int n ) { return n - n / 2 - n / 3 - n / 5 - n / 7 + n / 6 + n / 10 + n / 14 + n / 15 + n / 21 + n / 35 - n / 30 - n / 42 - n / 70 - n / 105 + n / 210 ; } static void Main ( ) { int n = 20 ; Console . WriteLine ( countNumbers ( n ) ) ; } }
using System ; class GFG { static int maxPrimes ( int n ) { return n / 2 ; } public static void Main ( ) { int n = 17 ; Console . WriteLine ( maxPrimes ( n ) ) ; } }
using System ; class GFG { static int sum ( int n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; } public static void Main ( String [ ] args ) { int n = 2 ; Console . WriteLine ( sum ( n ) ) ; } }
using System ; class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int findMinimum ( int n , int m ) { int mini = m ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int sec = n / i ; if ( __gcd ( m , i ) > 1 ) { return i ; } else if ( __gcd ( sec , m ) > 1 ) { mini = Math . Min ( sec , mini ) ; } } } if ( mini == m ) return - 1 ; else return mini ; } static void Main ( ) { int n = 8 , m = 10 ; Console . WriteLine ( findMinimum ( n , m ) ) ; } }
using System ; class GFG { public static int nthTerm ( int N ) { int nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += ( int ) Math . Pow ( i , i ) ; } return nth ; } public static void Main ( ) { int N = 3 ; Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; class GFG { static int kthSmallest ( int n , int k ) { return ( 2 * k ) ; } public static void Main ( ) { int n = 8 , k = 4 ; Console . WriteLine ( kthSmallest ( n , k ) ) ; } }
using System ; class GFG { static bool isSumOfPowersOfTwo ( int n ) { if ( n % 2 == 1 ) return false ; else return true ; } public static void Main ( ) { int n = 10 ; if ( isSumOfPowersOfTwo ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int findMinRemoval ( int [ ] arr , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . Abs ( arr [ i ] - arr [ i + 1 ] ) + Math . Abs ( arr [ i ] - arr [ i - 1 ] ) - Math . Abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . Abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . Max ( maximum , temp ) ; } return ( value - maximum ) ; } public static void Main ( ) { int [ ] arr = { 1 , 5 , 3 , 2 , 10 } ; int n = arr . Length ; Console . WriteLine ( findMinRemoval ( arr , n ) ) ; } }
using System ; class GFG { static double getTime ( int u , int v , int x ) { double speed = u + v ; double time = x / speed ; return time ; } public static void Main ( ) { int u = 3 , v = 3 , x = 3 ; Console . WriteLine ( getTime ( u , v , x ) ) ; } }
using System ; class GFG { static int number_of_teams ( int M ) { int N1 , N2 , sqr ; sqr = ( int ) Math . Sqrt ( 1 + ( 8 * M ) ) ; N1 = ( 1 + sqr ) / 2 ; N2 = ( 1 - sqr ) / 2 ; if ( N1 > 0 ) return N1 ; return N2 ; } public static void Main ( ) { int M = 45 ; Console . WriteLine ( number_of_teams ( M ) ) ; } }
using System ; class GFG { static int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; c = a + b ; a = b ; b = c ; } return sum ; } public static void Main ( String [ ] args ) { int N = 20 ; Console . WriteLine ( LucasSum ( N ) ) ; } }
using System ; class GFG { static int countNumbers ( int l , int r ) { return ( ( r / 6 ) - ( l - 1 ) / 6 ) ; } public static void Main ( String [ ] args ) { int l = 1000 , r = 6000 ; Console . WriteLine ( countNumbers ( l , r ) ) ; } }
using System ; class GFG { static int findMinSum ( int [ ] arr , int n ) { int occ = n - 1 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * ( int ) Math . Pow ( 2 , occ ) ; occ -- ; } return sum ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 5 } ; int n = arr . Length ; Console . WriteLine ( findMinSum ( arr , n ) ) ; } }
using System ; class GFG { static int countNumbers ( int X , int Y , int N ) { int count = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( ( i % X == 0 ) && ( i % Y != 0 ) ) count ++ ; } return count ; } public static void Main ( ) { int X = 2 , Y = 3 , N = 10 ; Console . WriteLine ( countNumbers ( X , Y , N ) ) ; } }
using System ; class GFG { static int getPosition ( int n , int m ) { if ( m > ( n / 2 ) ) return ( m - ( n / 2 ) ) ; return ( m + ( n / 2 ) ) ; } static public void Main ( ) { int n = 8 , m = 5 ; Console . WriteLine ( getPosition ( n , m ) ) ; } }
using System ; class GFG { static int parity ( int a ) { return a % 3 ; } static int solve ( int [ ] array , int size ) { int operations = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { int pari1 = parity ( array [ i ] ) ; int pari2 = parity ( array [ i + 2 ] ) ; if ( pari1 == pari2 ) { if ( pari1 == 0 ) array [ i + 1 ] = 1 ; else if ( pari1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( pari1 == 0 && pari2 == 1 ) || ( pari1 == 1 && pari2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( pari1 == 1 && pari2 == 2 ) || ( pari1 == 2 && pari2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( pari1 == 2 && pari2 == 0 ) || ( pari1 == 0 && pari2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; } public static void Main ( ) { int [ ] array = { 2 , 1 , 3 , 0 } ; int size = array . Length ; Console . WriteLine ( solve ( array , size ) ) ; } }
using System ; class GFG { static int submatrixXor ( int [ , ] arr ) { int n = 3 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i , j ] ) ; } } return ans ; } public static void Main ( ) { int [ , ] arr = { { 6 , 7 , 13 } , { 8 , 3 , 4 } , { 9 , 7 , 6 } } ; Console . Write ( submatrixXor ( arr ) ) ; } }
using System ; class GFG { static int findDigitalRoot ( int num ) { int sum = int . MaxValue , tempNum = num ; while ( sum >= 10 ) { sum = 0 ; while ( tempNum > 0 ) { sum += tempNum % 10 ; tempNum /= 10 ; } tempNum = sum ; } return sum ; } static void findAnswer ( int X , int N ) { int counter = 0 ; for ( int i = 1 ; counter < N ; ++ i ) { int digitalRoot = findDigitalRoot ( i ) ; if ( digitalRoot == X ) { ++ counter ; } if ( counter == N ) { Console . Write ( i ) ; break ; } } } public static void Main ( String [ ] args ) { int X = 1 , N = 3 ; findAnswer ( X , N ) ; } }
using System ; class GFG { static int findAnswer ( int X , int N ) { return ( N - 1 ) * 9 + X ; } public static void Main ( ) { int X = 7 , N = 43 ; Console . WriteLine ( findAnswer ( X , N ) ) ; } }
using System ; class GFG { static long count ( int N , int K , int R ) { long sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; } public static void Main ( ) { int N = 20 , K = 4 , R = 3 ; Console . Write ( count ( N , K , R ) ) ; } }
using System ; class GFG { static int getCount ( int a , int b , int c ) { int count = 0 ; for ( int i = 1 ; i <= 81 ; i ++ ) { int cr = b * ( int ) Math . Pow ( i , a ) + c ; int tmp = cr ; int sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp /= 10 ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; } public static void Main ( ) { int a = 3 , b = 2 , c = 8 ; Console . Write ( getCount ( a , b , c ) ) ; } }
using System ; class GFG { static bool isSpiltPossible ( int n , int [ ] a ) { int sum = 0 , c1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; } public static void Main ( ) { int n = 3 ; int [ ] a = { 1 , 1 , 2 } ; if ( isSpiltPossible ( n , a ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static int n = 3 ; static int matrixSum ( int [ , ] arr ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int top_left = ( i + 1 ) * ( j + 1 ) ; int bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i , j ] ) ; } } return sum ; } public static void Main ( ) { int [ , ] arr = { { 1 , 1 , 1 } , { 1 , 1 , 1 } , { 1 , 1 , 1 } } ; Console . WriteLine ( matrixSum ( arr ) ) ; } }
using System ; class GFG { static int maxAND ( int L , int R ) { int maximum = L & R ; for ( int i = L ; i < R ; i ++ ) for ( int j = i + 1 ; j <= R ; j ++ ) maximum = Math . Max ( maximum , ( i & j ) ) ; return maximum ; } public static void Main ( String [ ] args ) { int L = 1 , R = 632 ; Console . WriteLine ( maxAND ( L , R ) ) ; } }
using System ; class GFG { static int checkArray ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; } static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . Length ; Console . WriteLine ( checkArray ( arr , n ) ) ; } }
using System ; class GfG { static int findCount ( int [ ] arr , int n ) { int countOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 5 , 1 } ; int n = arr . Length ; Console . WriteLine ( findCount ( arr , n ) ) ; } }
using System ; class GFG { static bool isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; return ( ( sr - Math . Floor ( sr ) ) == 0 ) ; } static bool isSunnyNum ( int n ) { if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; } public static void Main ( ) { int n = 3 ; if ( isSunnyNum ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; using System . Collections ; class GfG { static int N = 100005 ; static bool [ ] isprime = new bool [ N ] ; static bool [ ] can = new bool [ N ] ; static ArrayList SieveOfEratosthenes ( ) { for ( int a = 0 ; a < N ; a ++ ) { isprime [ a ] = true ; } for ( int p = 2 ; p * p < N ; p ++ ) { if ( isprime [ p ] == true ) { for ( int i = p * p ; i < N ; i += p ) isprime [ i ] = false ; } } ArrayList primes = new ArrayList ( ) ; for ( int i = 2 ; i < N ; i ++ ) if ( isprime [ i ] ) primes . Add ( i ) ; return primes ; } static int Prime_Numbers ( int n ) { ArrayList primes = SieveOfEratosthenes ( ) ; for ( int i = 0 ; i < primes . Count - 1 ; i ++ ) if ( ( int ) primes [ i ] + ( int ) primes [ i + 1 ] + 1 < N ) can [ ( int ) primes [ i ] + ( int ) primes [ i + 1 ] + 1 ] = true ; int ans = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( can [ i ] && isprime [ i ] == true ) { ans ++ ; } } return ans ; } static void Main ( ) { int n = 50 ; Console . WriteLine ( Prime_Numbers ( n ) ) ; } }
using System ; class GFG { static int findAndSum ( int [ ] arr , int n ) { int sum = 0 ; int mul = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { bool count_on = false ; int l = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) if ( count_on ) l ++ ; else { count_on = true ; l ++ ; } else if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } } if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = false ; l = 0 ; } mul *= 2 ; } return sum ; } public static void Main ( ) { int [ ] arr = { 7 , 1 , 1 , 5 } ; int n = arr . Length ; Console . Write ( findAndSum ( arr , n ) ) ; } }
using System ; class GFG { static bool isPossible ( int Sx , int Sy , int Dx , int Dy , int x , int y ) { if ( Math . Abs ( Sx - Dx ) % x == 0 && Math . Abs ( Sy - Dy ) % y == 0 && ( Math . Abs ( Sx - Dx ) / x ) % 2 == ( Math . Abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; } static void Main ( ) { int Sx = 0 , Sy = 0 , Dx = 0 , Dy = 0 ; int x = 3 , y = 4 ; if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int getPairs ( int [ ] a ) { int count = 0 ; for ( int i = 0 ; i < a . Length ; i ++ ) { for ( int j = 0 ; j < a . Length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; } public static void Main ( ) { int [ ] a = { 2 , 4 , 3 , 1 } ; Console . WriteLine ( getPairs ( a ) ) ; } }
using System ; class GFG { static bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } static bool isDigitSumOne ( int nm ) { while ( nm > 9 ) { int sum_digit = 0 ; while ( nm > 0 ) { int digit = nm % 10 ; sum_digit = sum_digit + digit ; nm = nm / 10 ; } nm = sum_digit ; } if ( nm == 1 ) return true ; else return false ; } static void printValidNums ( int l , int r ) { for ( int i = l ; i <= r ; i ++ ) { if ( isComposite ( i ) && isDigitSumOne ( i ) ) Console . Write ( i + " ▁ " ) ; } } static public void Main ( ) { int l = 10 , r = 100 ; printValidNums ( l , r ) ; } }
using System ; class GFG { static int calcNodes ( int N , int I ) { int result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; } public static void Main ( ) { int N = 5 , I = 2 ; Console . Write ( " Leaf ▁ nodes ▁ = ▁ " + calcNodes ( N , I ) ) ; } }
class GFG { static long mod = 1000000007 ; static long [ ] arr = new long [ 1000001 ] ; static void cal_factorial ( ) { arr [ 0 ] = 1 ; for ( long i = 1 ; i <= 1000000 ; i ++ ) { arr [ i ] = ( arr [ i - 1 ] * i ) % mod ; } } static long mod_exponent ( long num , long p ) { if ( p == 0 ) return 1 ; if ( ( p & 1 ) != 0 ) { return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ) % mod ; } else return ( mod_exponent ( ( num * num ) % mod , p / 2 ) ) % mod ; } static long getCount ( long x , long y ) { long ans = arr [ x + y - 1 ] ; ans *= mod_exponent ( arr [ x ] , mod - 2 ) ; ans %= mod ; ans *= mod_exponent ( arr [ y ] , mod - 2 ) ; ans %= mod ; ans *= ( x - y ) ; ans %= mod ; return ans ; } static void Main ( ) { cal_factorial ( ) ; long x = 3 , y = 1 ; System . Console . WriteLine ( getCount ( x , y ) ) ; } }
using System ; class GFG { static void findValues ( int a , int b ) { if ( ( a - b ) % 2 == 1 ) { Console . Write ( " - 1" ) ; return ; } Console . WriteLine ( ( ( a - b ) / 2 ) + " ▁ " + ( ( a + b ) / 2 ) ) ; } static public void Main ( ) { int a = 12 , b = 8 ; findValues ( a , b ) ; } }
using System ; using System . Collections . Generic ; class GFG { public class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int countTriplets ( int n , List < pair > points ) { HashSet < pair > pts = new HashSet < pair > ( ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) pts . Add ( points [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points [ i ] . first + points [ j ] . first ; int y = points [ i ] . second + points [ j ] . second ; if ( x % 2 == 0 && y % 2 == 0 ) if ( ! pts . Contains ( new pair ( x / 2 , y / 2 ) ) ) ct ++ ; } return ct ; } public static void Main ( String [ ] args ) { List < pair > points = new List < pair > ( ) ; points . Add ( new pair ( 1 , 1 ) ) ; points . Add ( new pair ( 2 , 2 ) ) ; points . Add ( new pair ( 3 , 3 ) ) ; int n = points . Count ; Console . WriteLine ( countTriplets ( n , points ) ) ; } }
using System ; class GFG { static double mixtureConcentration ( int n , int [ ] p ) { double res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return Math . Round ( res , 4 ) ; } static void Main ( ) { int [ ] arr = { 0 , 20 , 20 } ; int n = arr . Length ; Console . WriteLine ( mixtureConcentration ( n , arr ) ) ; } }
using System ; class GFG { static int countOddSquares ( int n , int m ) { return ( int ) Math . Pow ( m , 0.5 ) - ( int ) Math . Pow ( n - 1 , 0.5 ) ; } static public void Main ( ) { int n = 5 , m = 100 ; Console . WriteLine ( " Count ▁ is ▁ " + ( ( m - n + 1 ) - countOddSquares ( n , m ) ) ) ; } }
using System ; class GFG { static int Square ( int row , int column , int moves ) { int a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; } public static void Main ( ) { int R = 4 , C = 5 , M = 2 ; Console . Write ( Square ( R , C , M ) ) ; } }
using System ; class GFG { static int findNumber ( int n , int m ) { int num = ( m - 1 ) * 9 + n ; return num ; } public static void Main ( ) { int n = 2 , m = 5 ; Console . Write ( findNumber ( n , m ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static bool checkTriangularSumRepresentation ( int n ) { HashSet < int > tri = new HashSet < int > ( ) ; int i = 1 ; while ( true ) { int x = i * ( i + 1 ) / 2 ; if ( x >= n ) { break ; } tri . Add ( x ) ; i ++ ; } foreach ( int tm in tri ) { if ( tri . Contains ( n - tm ) ) { return true ; } } return false ; } public static void Main ( String [ ] args ) { int n = 24 ; if ( checkTriangularSumRepresentation ( n ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static int digitsCount ( int n ) { int len = 0 ; while ( n > 0 ) { len ++ ; n /= 10 ; } return len ; } static int absoluteFirstLast ( int n , int x ) { int i = 0 , mod = 1 ; while ( i < x ) { mod *= 10 ; i ++ ; } int last = n % mod ; int len = digitsCount ( n ) ; while ( len != x ) { n /= 10 ; len -- ; } int first = n ; return Math . Abs ( first - last ) ; } public static void Main ( String [ ] args ) { int n = 21546 , x = 2 ; Console . Write ( absoluteFirstLast ( n , x ) ) ; } }
using System ; class GFG { public static void make_sequence ( int N ) { int [ ] arr = new int [ N + 1 ] ; int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int N = 9 ; make_sequence ( N ) ; } }
using System ; class GFG { static int countOdd ( int L , int R ) { int N = ( R - L ) / 2 ; if ( R % 2 != 0 L % 2 != 0 ) N ++ ; return N ; } public static void Main ( ) { int L = 3 , R = 7 ; int odds = countOdd ( L , R ) ; int evens = ( R - L + 1 ) - odds ; Console . WriteLine ( " Count ▁ of ▁ odd ▁ numbers ▁ is ▁ " + odds ) ; Console . WriteLine ( " Count ▁ of ▁ even ▁ numbers ▁ is ▁ " + evens ) ; } }
using System ; class GFG { static int getMinCost ( int n , int m ) { int cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; } public static void Main ( ) { int n = 4 , m = 5 ; Console . WriteLine ( getMinCost ( n , m ) ) ; } }
using System ; class GFG { static void minOperation ( int n , int k , int [ ] a ) { for ( int i = k ; i < n ; i ++ ) { if ( a [ i ] != a [ k - 1 ] ) Console . WriteLine ( - 1 ) ; } for ( int i = k - 2 ; i > - 1 ; i -- ) { if ( a [ i ] != a [ k - 1 ] ) Console . WriteLine ( i + 1 ) ; } } static public void Main ( ) { int n = 5 ; int k = 3 ; int [ ] a = { 2 , 1 , 1 , 1 , 1 } ; minOperation ( n , k , a ) ; } }
using System ; class GFG { static int binomialCoeff ( int n , int k ) { if ( k > n ) return 0 ; int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void Main ( ) { int N = 5 , M = 1 ; int P = ( N * ( N - 1 ) ) / 2 ; Console . Write ( binomialCoeff ( P , M ) ) ; } }
using System ; class GFG { static void generateSequence ( int n , int g ) { for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( i * g + " ▁ " ) ; } public static void Main ( ) { int n = 6 , g = 5 ; generateSequence ( n , g ) ; } }
using System ; class GFG { static int MAX = 1000 ; static int [ ] f = new int [ MAX ] ; static int fib ( int n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] != 0 ) return f [ n ] ; int k = 0 ; if ( ( n & 1 ) != 0 ) k = ( n + 1 ) / 2 ; else k = n / 2 ; if ( ( n & 1 ) != 0 ) f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; else f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findLCMFibonacci ( int a , int b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; } static void Main ( ) { int a = 3 , b = 12 ; Console . WriteLine ( findLCMFibonacci ( a , b ) ) ; } }
using System ; class GFG { static string isEvenOrOdd ( int L , int R ) { int oddCount = ( R - L ) / 2 ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " Even " ; else return " Odd " ; } public static void Main ( ) { int L = 5 , R = 15 ; Console . WriteLine ( isEvenOrOdd ( L , R ) ) ; } }
using System ; class GFG { static int trailing_zeros ( int N ) { int count_of_two = 0 , count_of_five = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { int val = i ; while ( val % 2 == 0 && val > 0 ) { val /= 2 ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val /= 5 ; count_of_five += i ; } } int ans = Math . Min ( count_of_two , count_of_five ) ; return ans ; } public static void Main ( ) { int N = 12 ; Console . WriteLine ( trailing_zeros ( N ) ) ; } }
using System ; class GFG { static void midptellipse ( double rx , double ry , double xc , double yc ) { double dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ; d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25f * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ; while ( dx < dy ) { Console . WriteLine ( String . Format ( " { 0:0.000000 } " , ( x + xc ) ) + " , ▁ " + String . Format ( " { 0:0.000000 } " , ( y + yc ) ) ) ; Console . WriteLine ( String . Format ( " { 0:0.000000 } " , ( - x + xc ) ) + " , ▁ " + String . Format ( " { 0:0.000000 } " , ( y + yc ) ) ) ; Console . WriteLine ( String . Format ( " { 0:0.000000 } " , ( x + xc ) ) + " , ▁ " + String . Format ( " { 0:0.000000 } " , ( - y + yc ) ) ) ; Console . WriteLine ( String . Format ( " { 0:0.000000 } " , ( - x + xc ) ) + " , ▁ " + String . Format ( " { 0:0.000000 } " , ( - y + yc ) ) ) ; if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } } d2 = ( ( ry * ry ) * ( ( x + 0.5f ) * ( x + 0.5f ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ; while ( y >= 0 ) { Console . WriteLine ( String . Format ( " { 0:0.000000 } " , ( x + xc ) ) + " , ▁ " + String . Format ( " { 0:0.000000 } " , ( y + yc ) ) ) ; Console . WriteLine ( String . Format ( " { 0:0.000000 } " , ( - x + xc ) ) + " , ▁ " + String . Format ( " { 0:0.000000 } " , ( y + yc ) ) ) ; Console . WriteLine ( String . Format ( " { 0:0.000000 } " , ( x + xc ) ) + " , ▁ " + String . Format ( " { 0:0.000000 } " , ( - y + yc ) ) ) ; Console . WriteLine ( String . Format ( " { 0:0.000000 } " , ( - x + xc ) ) + " , ▁ " + String . Format ( " { 0:0.000000 } " , ( - y + yc ) ) ) ; if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } } static void Main ( ) { midptellipse ( 10 , 15 , 50 , 50 ) ; } }
using System ; class GFG { static String isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int k = ( int ) n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; } public static void Main ( ) { long n = 123 ; Console . WriteLine ( isDivisible ( n ) ) ; } }
using System ; class GFG { static void alter ( long x , long y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } Console . WriteLine ( " X ▁ = ▁ " + x + " , ▁ " + " Y ▁ = ▁ " + y ) ; } public static void Main ( ) { long x = 12 , y = 5 ; alter ( x , y ) ; } }
class GFG { static int digitProduct ( int n ) { int prod = 1 ; while ( n > 0 ) { prod = prod * ( n % 10 ) ; n = n / 10 ; } return prod ; } static void printMultiplicativePrimes ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] && prime [ digitProduct ( i ) ] ) System . Console . Write ( i + " ▁ " ) ; } } static void Main ( ) { int n = 10 ; printMultiplicativePrimes ( n ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static bool coPrime ( int n1 , int n2 ) { if ( gcd ( n1 , n2 ) == 1 ) return true ; else return false ; } static int largestCoprime ( int N ) { int half = ( int ) ( N / 2 ) ; while ( coPrime ( N , half ) == false ) half -- ; return half ; } static void Main ( ) { int n = 50 ; Console . WriteLine ( largestCoprime ( n ) ) ; } }
using System ; class GfG { static int largestCoprime ( int N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; } public static void Main ( ) { int n = 50 ; Console . WriteLine ( largestCoprime ( n ) ) ; } }
using System ; class GFG { static void printSafePrimes ( int n ) { int [ ] prime = new int [ n + 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == 1 ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = 0 ; } } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] != 0 ) { int temp = ( 2 * i ) + 1 ; if ( temp <= n && prime [ temp ] != 0 ) prime [ temp ] = 2 ; } } for ( int i = 5 ; i <= n ; i ++ ) if ( prime [ i ] == 2 ) Console . Write ( i + " ▁ " ) ; } public static void Main ( ) { int n = 20 ; printSafePrimes ( n ) ; } }
using System ; using System . Collections . Generic ; class GFG { static List < int > Divisors ( int x ) { int c = 0 ; List < int > v = new List < int > ( ) ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . Add ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . Add ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . Add ( c ) ; v . Add ( x ) ; return v ; } static int MinOperations ( int a , int b ) { List < int > va = Divisors ( a ) ; List < int > vb = Divisors ( b ) ; if ( va [ 3 ] != vb [ 3 ] ) { return - 1 ; } int minOperations = Math . Abs ( va [ 0 ] - vb [ 0 ] ) + Math . Abs ( va [ 1 ] - vb [ 1 ] ) + Math . Abs ( va [ 2 ] - vb [ 2 ] ) ; return minOperations ; } public static void Main ( String [ ] args ) { int a = 14 , b = 28 ; Console . WriteLine ( MinOperations ( a , b ) ) ; } }
using System ; class GFG { static int largestOddDigit ( int n ) { int maxOdd = - 1 ; while ( n > 0 ) { int digit = n % 10 ; if ( digit % 2 == 1 && digit > maxOdd ) maxOdd = digit ; n = n / 10 ; } return maxOdd ; } static int getProduct ( int n ) { int maxOdd = largestOddDigit ( n ) ; if ( maxOdd == - 1 ) return - 1 ; return ( n * maxOdd ) ; } public static void Main ( ) { int n = 12345 ; Console . Write ( getProduct ( n ) ) ; } }
using System ; class GFG { static int n = 1000002 ; static int [ ] phi = new int [ n + 2 ] ; static int [ ] ans = new int [ n + 2 ] ; static void ETF ( ) { for ( int i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { phi [ i ] = i - 1 ; for ( int j = 2 * i ; j <= n ; j += i ) { phi [ j ] = ( phi [ j ] * ( i - 1 ) ) / i ; } } } } static int LcmSum ( int m ) { ETF ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = i ; j <= n ; j += i ) { ans [ j ] += ( i * phi [ i ] ) ; } } int answer = ans [ m ] ; answer = ( answer + 1 ) * m ; answer = answer / 2 ; return answer ; } static void Main ( ) { int m = 5 ; Console . WriteLine ( LcmSum ( m ) ) ; } }
using System ; class GFG { static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } static int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } static int countWays ( String str ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; } int nvowels = 0 , nconsonants = 0 ; int vplaces , cways , vways ; for ( int i = 0 ; i < str . Length ; i ++ ) ++ freq [ str [ i ] - ' a ' ] ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) nvowels += freq [ i ] ; else nconsonants += freq [ i ] ; } vplaces = nconsonants + 1 ; cways = factorial ( nconsonants ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { cways = cways / factorial ( freq [ i ] ) ; } } vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { vways = vways / factorial ( freq [ i ] ) ; } } return cways * vways ; } public static void Main ( ) { String str = " permutation " ; Console . WriteLine ( countWays ( str ) ) ; } }
using System ; class GFG { static int setBits ( int n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } static int countPairs ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int setbits_x = setBits ( a [ i ] ) ; for ( int j = i + 1 ; j < n ; j ++ ) { int setbits_y = setBits ( a [ j ] ) ; int setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) ; if ( setbits_x + setbits_y == setbits_xor_xy ) count ++ ; } } return count ; } public static void Main ( ) { int [ ] a = { 2 , 3 , 4 , 5 , 6 } ; int n = a . Length ; Console . Write ( countPairs ( a , n ) ) ; } }
using System ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findPossibleDerivables ( int [ ] arr , int n , int D , int A , int B ) { int gcdAB = gcd ( A , B ) ; int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( Math . Abs ( arr [ i ] - D ) % gcdAB ) == 0 ) { counter ++ ; } } return counter ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 7 , 13 } ; int n = arr . Length ; int D = 5 , A = 4 , B = 2 ; Console . WriteLine ( findPossibleDerivables ( arr , n , D , A , B ) ) ; int [ ] a = { 1 , 2 , 3 } ; n = a . Length ; D = 6 ; A = 3 ; B = 2 ; Console . WriteLine ( findPossibleDerivables ( a , n , D , A , B ) ) ; } }
using System ; class GFG { static int calSum ( int n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( calSum ( n ) ) ; } }
using System ; class GFG { static void getElements ( int a , int [ ] arr , int n ) { int [ ] elements = new int [ n + 1 ] ; elements [ 0 ] = a ; for ( int i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( int i = 0 ; i < n + 1 ; i ++ ) Console . Write ( elements [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 13 , 2 , 6 , 1 } ; int n = arr . Length ; int a = 5 ; getElements ( a , arr , n ) ; } }
using System ; public class GFG { static int distinctDigitSum ( int n ) { bool [ ] used = new bool [ 10 ] ; int sum = 0 ; while ( n > 0 ) { int digit = n % 10 ; if ( ! used [ digit ] ) { used [ digit ] = true ; sum += digit ; } n = n / 10 ; } return sum ; } static String checkSum ( int m , int n ) { int sumM = distinctDigitSum ( m ) ; int sumN = distinctDigitSum ( n ) ; if ( sumM == sumN ) return " YES " ; return " NO " ; } static public void Main ( ) { int m = 2452 , n = 9222 ; Console . WriteLine ( checkSum ( m , n ) ) ; } }
using System ; class GFG { static int doubleFactorial ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { fact = fact * i ; } return fact ; } static int hermiteNumber ( int n ) { if ( n % 2 == 1 ) return 0 ; else { int number = ( int ) ( Math . Pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ; if ( ( n / 2 ) % 2 == 1 ) number = number * - 1 ; return number ; } } public static void Main ( ) { int n = 6 ; Console . WriteLine ( hermiteNumber ( n ) ) ; } }
using System ; public class GFG { static void printThreeParts ( int N ) { if ( N % 3 == 0 ) Console . WriteLine ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " + ( N - 2 ) ) ; else Console . WriteLine ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " + ( N - 3 ) ) ; } static public void Main ( ) { int N = 10 ; printThreeParts ( N ) ; } }
using System ; class GFG { static bool isPrime ( int N ) { for ( int i = 2 ; i <= Math . Sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; } static int getDifference ( int N ) { if ( N == 0 ) return 2 ; else if ( N == 1 ) return 1 ; else if ( isPrime ( N ) ) return 0 ; int aboveN = - 1 , belowN = - 1 ; int n1 ; n1 = N + 1 ; while ( true ) { if ( isPrime ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPrime ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } int diff1 = aboveN - N ; int diff2 = N - belowN ; return Math . Min ( diff1 , diff2 ) ; } public static void Main ( ) { int N = 25 ; Console . WriteLine ( getDifference ( N ) ) ; } }
using System ; public class GFG { static bool check ( int [ ] arr , int x , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { double y = Math . Sqrt ( arr [ i ] ) ; if ( Math . Floor ( y ) == Math . Ceiling ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 9 , 10 } ; int n = arr . Length ; int x = 13 ; if ( check ( arr , x , n ) ) { Console . Write ( " Yes " ) ; } else { Console . Write ( " No " ) ; } } }
using System ; class GFG { static void MinimumMaximumPairs ( int n , int m ) { int max_pairs = ( ( n - m + 1 ) * ( n - m ) ) / 2 ; int min_pairs = m * ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 + ( int ) Math . Ceiling ( ( double ) ( ( n - m ) / ( double ) ( m ) ) ) * ( ( n - m ) % m ) ; Console . WriteLine ( " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " + min_pairs ) ; Console . WriteLine ( " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " + max_pairs ) ; } public static void Main ( ) { int n = 5 , m = 2 ; MinimumMaximumPairs ( n , m ) ; } }
using System ; public class GFG { static void findGreater ( int a , int b ) { double x = ( double ) a * ( double ) ( Math . Log ( ( double ) ( b ) ) ) ; double y = ( double ) b * ( double ) ( Math . Log ( ( double ) ( a ) ) ) ; if ( y > x ) { Console . Write ( " a ^ b ▁ is ▁ greater STRNEWLINE " ) ; } else if ( y < x ) { Console . Write ( " b ^ a ▁ is ▁ greater " + " STRNEWLINE " ) ; } else { Console . Write ( " Both ▁ are ▁ equal " ) ; } } public static void Main ( ) { int a = 3 , b = 5 , c = 2 , d = 4 ; findGreater ( a , b ) ; findGreater ( c , d ) ; } }
using System ; public class GFG { static long m = 1000000007 ; static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long modexp ( long x , long n ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) ; } } static long getFractionModulo ( long a , long b ) { long c = gcd ( a , b ) ; a = a / c ; b = b / c ; long d = modexp ( b , m - 2 ) ; long ans = ( ( a % m ) * ( d % m ) ) % m ; return ans ; } static public void Main ( ) { long a = 2 , b = 6 ; Console . WriteLine ( getFractionModulo ( a , b ) ) ; } }
using System ; class GFG { static int maxPrimeFactors ( int n ) { int num = n ; int maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n /= 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } } if ( n > 2 ) { maxPrime = n ; } int sum = maxPrime + num ; return sum ; } static void Main ( ) { int n = 19 ; Console . WriteLine ( maxPrimeFactors ( n ) ) ; } }
using System ; class GFG { static int sumOfDigits ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; } static int findNumber ( int n ) { int i = n - 1 ; while ( i > 0 ) { if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) return i ; i -- ; } return - 1 ; } static public void Main ( ) { int n = 824 ; Console . WriteLine ( findNumber ( n ) ) ; } }
using System ; public class GFG { static int findNth ( int N ) { int b = 14 ; int i ; for ( i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; } static public void Main ( ) { int N = 6 ; Console . WriteLine ( findNth ( N ) ) ; } }
using System ; class GFG { readonly static int N = 4 ; static void predictMatrix ( int [ , ] arr , int range1a , int range1b , int range0a , int range0b , int K , int [ , ] b ) { int c = 0 ; while ( K != 0 ) { K -- ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { c = 0 ; if ( i > 0 && arr [ i - 1 , j ] == 1 ) c ++ ; if ( j > 0 && arr [ i , j - 1 ] == 1 ) c ++ ; if ( i > 0 && j > 0 && arr [ i - 1 , j - 1 ] == 1 ) c ++ ; if ( i < N - 1 && arr [ i + 1 , j ] == 1 ) c ++ ; if ( j < N - 1 && arr [ i , j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j < N - 1 && arr [ i + 1 , j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j > 0 && arr [ i + 1 , j - 1 ] == 1 ) c ++ ; if ( i > 0 && j < N - 1 && arr [ i - 1 , j + 1 ] == 1 ) c ++ ; if ( arr [ i , j ] == 1 ) { if ( c >= range1a && c <= range1b ) b [ i , j ] = 1 ; else b [ i , j ] = 0 ; } if ( arr [ i , j ] == 0 ) { if ( c >= range0a && c <= range0b ) b [ i , j ] = 1 ; else b [ i , j ] = 0 ; } } } for ( int k = 0 ; k < N ; k ++ ) for ( int m = 0 ; m < N ; m ++ ) arr [ k , m ] = b [ k , m ] ; } } public static void Main ( ) { int [ , ] arr = { { 0 , 0 , 0 , 0 } , { 0 , 1 , 1 , 0 } , { 0 , 0 , 1 , 0 } , { 0 , 1 , 0 , 1 } } ; int range1a = 2 , range1b = 2 ; int range0a = 2 , range0b = 3 ; int K = 3 ; int [ , ] b = new int [ N , N ] ; predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) ; for ( int i = 0 ; i < N ; i ++ ) { Console . WriteLine ( ) ; for ( int j = 0 ; j < N ; j ++ ) Console . Write ( b [ i , j ] + " ▁ " ) ; } } }
using System ; class GFG { static int countMoves ( int n ) { int ct = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; } static void Main ( ) { int n = 3 ; Console . WriteLine ( countMoves ( n ) ) ; } }
using System ; class GFG { static double countNumbers ( int N ) { return ( Math . Pow ( 10 , N ) - 1 ) - ( Math . Pow ( 10 , N ) - Math . Pow ( 8 , N ) ) / 2 ; } static public void Main ( ) { int n = 2 ; Console . WriteLine ( countNumbers ( n ) ) ; } }
using System ; class GFG { static int N = 3 ; static double calcDeterminant ( int [ ] arr ) { double determinant = 0 ; for ( int i = 0 ; i < N ; i ++ ) { determinant += Math . Pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; } static public void Main ( ) { int [ ] arr = { 4 , 5 , 3 } ; Console . WriteLine ( calcDeterminant ( arr ) ) ; } }
using System ; class GFG { static int minimumMoves ( int k , int l , int r ) { int count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; } public static void Main ( ) { int k = 3 , l = 10 , r = 10 ; Console . WriteLine ( minimumMoves ( k , l , r ) ) ; } }
using System ; public class GFG { static int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) ; return sum ; } static int sumEven ( int l , int r ) { return sumNatural ( r / 2 ) - sumNatural ( ( l - 1 ) / 2 ) ; } static public void Main ( ) { int l = 2 , r = 5 ; Console . WriteLine ( " Sum ▁ of ▁ Natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " + sumEven ( l , r ) ) ; } }
using System ; class GFG { static bool isDivisibleRec ( int x , int a , int b , int n ) { if ( x > n ) return false ; if ( n % x == 0 ) return true ; return ( isDivisibleRec ( x * 10 + a , a , b , n ) || isDivisibleRec ( x * 10 + b , a , b , n ) ) ; } static bool isDivisible ( int a , int b , int n ) { return isDivisibleRec ( a , a , b , n ) || isDivisibleRec ( b , a , b , n ) ; } static public void Main ( ) { int a = 3 , b = 5 , n = 53 ; if ( isDivisible ( a , b , n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static void MinSteps ( int SourceX , int SourceY , int DestX , int DestY ) { Console . WriteLine ( Math . Max ( Math . Abs ( SourceX - DestX ) , Math . Abs ( SourceY - DestY ) ) ) ; while ( ( SourceX != DestX ) || ( SourceY != DestY ) ) { if ( SourceX < DestX ) { Console . Write ( ' U ' ) ; SourceX ++ ; } if ( SourceX > DestX ) { Console . Write ( ' D ' ) ; SourceX -- ; } if ( SourceY > DestY ) { Console . Write ( ' L ' ) ; SourceY -- ; } if ( SourceY < DestY ) { Console . Write ( ' R ' ) ; SourceY ++ ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int sourceX = 4 , sourceY = 4 ; int destinationX = 7 , destinationY = 0 ; MinSteps ( sourceX , sourceY , destinationX , destinationY ) ; } }
using System ; using System . Collections ; using System . Collections . Generic ; public class GFG { public static ArrayList getPerfectSquares ( int n ) { ArrayList perfectSquares = new ArrayList ( ) ; int current = 1 , i = 1 ; while ( current <= n ) { perfectSquares . Add ( current ) ; current = ( int ) Math . Pow ( ++ i , 2 ) ; } return perfectSquares ; } public static int maxPairSum ( int [ ] arr ) { int n = arr . Length ; int max , secondMax ; if ( arr [ 0 ] > arr [ 1 ] ) { max = arr [ 0 ] ; secondMax = arr [ 1 ] ; } else { max = arr [ 1 ] ; secondMax = arr [ 0 ] ; } for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } } return ( max + secondMax ) ; } public static int countPairsWith ( int n , ArrayList perfectSquares , ArrayList nums ) { int count = 0 ; for ( int i = 0 ; i < perfectSquares . Count ; i ++ ) { int temp = ( int ) perfectSquares [ i ] - n ; if ( temp > n && nums . Contains ( temp ) ) count ++ ; } return count ; } public static int countPairs ( int [ ] arr ) { int i , n = arr . Length ; int max = maxPairSum ( arr ) ; ArrayList perfectSquares = getPerfectSquares ( max ) ; ArrayList nums = new ArrayList ( ) ; for ( i = 0 ; i < n ; i ++ ) nums . Add ( arr [ i ] ) ; int count = 0 ; for ( i = 0 ; i < n ; i ++ ) { count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; } return count ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 6 , 9 , 10 , 20 } ; Console . WriteLine ( countPairs ( arr ) ) ; } }
using System ; class GFG { static int findEle ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; } static public void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 6 } ; int n = arr . Length ; Console . WriteLine ( findEle ( arr , n ) ) ; } }
using System ; class GFG { static int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; } static int suminRange ( int l , int r ) { return sumNatural ( r ) - sumNatural ( l - 1 ) ; } static public void Main ( ) { int l = 2 , r = 5 ; Console . WriteLine ( " Sum ▁ of ▁ Natural ▁ numbers ▁ " + " from ▁ L ▁ to ▁ R ▁ is ▁ " + suminRange ( l , r ) ) ; } }
using System ; class GFG { static bool divisibleBy3 ( string number ) { int sumOfDigit = 0 ; for ( int i = 0 ; i < number . Length ; i ++ ) sumOfDigit += number [ i ] - '0' ; if ( sumOfDigit % 3 == 0 ) return true ; return false ; } static bool divisibleBy25 ( string number ) { if ( number . Length < 2 ) return false ; int length = number . Length ; int lastTwo = ( number [ length - 2 ] - '0' ) * 10 + ( number [ length - 1 ] - '0' ) ; if ( lastTwo % 25 == 0 ) return true ; return false ; } static bool divisibleBy75 ( string number ) { if ( divisibleBy3 ( number ) && divisibleBy25 ( number ) ) return true ; return false ; } public static void Main ( ) { string number = "754586672150" ; bool divisible = divisibleBy75 ( number ) ; if ( divisible ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int otherNumber ( int A , int Lcm , int Hcf ) { return ( Lcm * Hcf ) / A ; } static public void Main ( String [ ] args ) { int A = 8 , Lcm = 8 , Hcf = 1 ; int result = otherNumber ( A , Lcm , Hcf ) ; Console . WriteLine ( " B ▁ = ▁ " + result ) ; } }
using System ; class GFG { static float successiveChange ( int [ ] arr , int N ) { float var1 , var2 , result = 0 ; var1 = arr [ 0 ] ; var2 = arr [ 1 ] ; result = var1 + var2 + ( ( var1 * var2 ) / 100 ) ; for ( int i = 2 ; i < N ; i ++ ) result = result + arr [ i ] + ( ( result * arr [ i ] ) / 100 ) ; return result ; } public static void Main ( ) { int [ ] arr = { 10 , 20 , 30 , 10 } ; int N = arr . Length ; float result = successiveChange ( arr , N ) ; Console . WriteLine ( " Percentage ▁ change ▁ is ▁ = ▁ " + result + " ▁ % " ) ; } }
using System ; class GFG { static int minimumNumbers ( int n , int s ) { if ( ( s % n ) > 0 ) return s / n + 1 ; else return s / n ; } public static void Main ( ) { int n = 5 ; int s = 11 ; Console . WriteLine ( minimumNumbers ( n , s ) ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int sumAP ( int n , int d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } static int sumMultiples ( int A , int B , int n ) { n -- ; int common = ( A * B ) / __gcd ( A , B ) ; return sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ; } public static void Main ( ) { int n = 100 , A = 5 , B = 10 ; System . Console . WriteLine ( " Sum ▁ = ▁ " + sumMultiples ( A , B , n ) ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static bool isPossible ( int N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) return true ; else return false ; } public static void Main ( ) { int n = 13 ; if ( isPossible ( n ) == true ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int contiguousPerfectSquare ( int [ ] arr , int n ) { int a ; float b ; int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b = ( float ) Math . Sqrt ( arr [ i ] ) ; a = ( int ) b ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . Max ( max_length , current_length ) ; } return max_length ; } public static void Main ( ) { int [ ] arr = { 9 , 75 , 4 , 64 , 121 , 25 } ; int n = arr . Length ; Console . WriteLine ( contiguousPerfectSquare ( arr , n ) ) ; } }
using System ; class GFG { static int countPairs ( int n ) { int count = 0 ; for ( int x = 1 ; x < n ; x ++ ) { for ( int y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; } public static void Main ( ) { int n = 15 ; Console . WriteLine ( countPairs ( n ) ) ; } }
using System ; class GFG { static int getIndex ( int [ ] a , int n ) { if ( n == 1 ) return 0 ; int ptrL = 0 , ptrR = n - 1 , sumL = a [ 0 ] , sumR = a [ n - 1 ] ; while ( ptrR - ptrL > 1 ) { if ( sumL < sumR ) { ptrL ++ ; sumL += a [ ptrL ] ; } else if ( sumL > sumR ) { ptrR -- ; sumR += a [ ptrR ] ; } else { break ; } } return ptrL ; } public static void Main ( ) { int [ ] a = { 2 , 7 , 9 , 8 , 7 } ; int n = a . Length ; Console . WriteLine ( getIndex ( a , n ) ) ; } }
using System ; class GFG { static int getPosition ( int [ ] a , int n , int m ) { for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m ) ) ; } int ans = - 1 , max = - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; } static public void Main ( ) { int [ ] a = { 2 , 5 , 4 } ; int n = a . Length ; int m = 2 ; Console . WriteLine ( getPosition ( a , n , m ) ) ; } }
using System ; public class GFG { static int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . Max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . Pow ( i , i ) ; int numerator = ( int ) Math . Pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; } public static void Main ( ) { int n = 6 , r = 2 ; Console . WriteLine ( "1 / " + calcFunction ( n , r ) ) ; } }
using System ; class GFG { static int findNum ( int [ ] div , int [ ] rem , int N ) { int num = rem [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; } static public void Main ( ) { int [ ] div = { 8 , 3 } ; int [ ] rem = { 2 , 2 } ; int N = div . Length ; Console . WriteLine ( findNum ( div , rem , N ) ) ; } }
using System ; class GFG { static void profitLoss ( int N , int M ) { if ( N == M ) Console . Write ( " No ▁ Profit ▁ nor ▁ Loss " ) ; else { float result = 0 ; result = ( float ) ( Math . Abs ( N - M ) ) / M ; if ( N - M < 0 ) Console . Write ( " Loss ▁ = ▁ - " + result * 100 + " % " ) ; else Console . Write ( " Profit ▁ = ▁ " + result * 100 + " % " ) ; } } static public void Main ( ) { int N = 8 , M = 9 ; profitLoss ( N , M ) ; } }
class solution { static int countPieces ( int N ) { return 2 * N ; } static void Main ( ) { int N = 100 ; System . Console . WriteLine ( countPieces ( N ) ) ; } }
using System ; class GFG { static long sumAP ( long n , long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } static long sumMultiples ( long n ) { n -- ; return sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ; } static public void Main ( String [ ] args ) { long n = 24 ; Console . WriteLine ( sumMultiples ( n ) ) ; } }
using System ; class GFG { static bool productSumDivisible ( int n , int size ) { int sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = n / 10 ; size -- ; } if ( product % sum == 0 ) { return true ; } return false ; } public static void Main ( ) { int n = 1234 ; int len = 4 ; if ( productSumDivisible ( n , len ) ) Console . WriteLine ( " TRUE " ) ; else Console . WriteLine ( " FALSE " ) ; } }
using System ; class GFG { public static long gcd ( long a , long b ) { if ( a == 0 ) { return b ; } return gcd ( b % a , a ) ; } public static long powGCD ( long a , long n , long b ) { for ( int i = 0 ; i < n ; i ++ ) { a = a * a ; } return gcd ( a , b ) ; } public static void Main ( string [ ] args ) { long a = 10 , b = 5 , n = 2 ; Console . WriteLine ( powGCD ( a , n , b ) ) ; } }
using System ; class GFG { public static int lastCoordinate ( int n , int a , int b ) { return ( ( n + 1 ) / 2 ) * a - ( n / 2 ) * b ; } public static void Main ( string [ ] args ) { int n = 3 , a = 5 , b = 2 ; Console . WriteLine ( lastCoordinate ( n , a , b ) ) ; } }
public class GFG { static int findNum ( int N , int K ) { int rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; } static void Main ( ) { int N = 45 , K = 6 ; System . Console . WriteLine ( " Smallest ▁ number ▁ greater ▁ than ▁ or ▁ equal ▁ to ▁ " + N + " that is divisible by " + K + " ▁ is ▁ " + findNum ( N , K ) ) ; } }
using System ; class GFG { static void countDigit ( int n ) { int temp = n , sum = 0 , product = 1 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } Console . Write ( " Sum ▁ = ▁ " + sum ) ; Console . Write ( " Product = " } public static void Main ( ) { int n = 1012 ; countDigit ( n ) ; } }
using System ; class GFG { static int findNum ( int N , int K ) { int rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; } public static void Main ( ) { int N = 45 , K = 6 ; Console . Write ( " Largest ▁ number ▁ smaller ▁ " + " than ▁ or ▁ equal ▁ to ▁ " + N + " that is divisible by " + K + " ▁ is ▁ " + findNum ( N , K ) ) ; } }
using System ; class GFG { static bool isDivisiblePalindrome ( int n ) { int [ ] hash = new int [ 10 ] ; int digitSum = 0 ; while ( n != 0 ) { digitSum += n % 10 ; hash [ n % 10 ] ++ ; n /= 10 ; } if ( digitSum % 3 != 0 ) return false ; int oddCount = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount > 1 ) return false ; else return true ; } static public void Main ( ) { int n = 34734 ; Console . WriteLine ( isDivisiblePalindrome ( n ) ) ; } }
using System ; class GFG { static bool productDivisible ( int n , int k ) { int product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) product *= n % 10 ; n = n / 10 ; position ++ ; } if ( product % k == 0 ) return true ; return false ; } public static void Main ( ) { int n = 321922 ; int k = 3 ; if ( productDivisible ( n , k ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } static int npr ( int n , int r ) { int pnr = factorial ( n ) / factorial ( n - r ) ; return pnr ; } static int countPermutations ( int n , int r , int k ) { return factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ; } static void Main ( ) { int n = 8 ; int r = 5 ; int k = 2 ; Console . WriteLine ( countPermutations ( n , r , k ) ) ; } }
using System ; class GFG { static int GIF ( double n ) { return ( int ) Math . Floor ( n ) ; } static void Main ( ) { double n = 2.3 ; Console . WriteLine ( GIF ( n ) ) ; } }
using System ; class GFG { static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } static int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } public static void Main ( ) { int m = 3 , n = 4 , k = 5 ; int totalTriangles = ncr ( m + n + k , 3 ) - ncr ( m , 3 ) - ncr ( n , 3 ) - ncr ( k , 3 ) ; Console . WriteLine ( totalTriangles ) ; } }
using System ; class GFG { static bool SumDivisible ( int n , int k ) { int sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = n / 10 ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; } static public void Main ( ) { int n = 592452 ; int k = 3 ; if ( SumDivisible ( n , k ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
class GFG { static string isTriangleExists ( int a , int b , int c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " YES " ; else return " NO " ; else return " NO " ; } static void Main ( ) { int a = 50 , b = 60 , c = 70 ; System . Console . WriteLine ( isTriangleExists ( a , b , c ) ) ; } }
using System ; class GfG { public int findX ( int n , int k ) { int r = n , v , u ; int m = ( int ) Math . Sqrt ( k ) + 1 ; for ( int i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; } for ( u = v = 0 ; k % i == 0 ; v ++ ) { k /= i ; } if ( v > 0 ) { int t = n ; while ( t > 0 ) { t /= i ; u += t ; } r = Math . Min ( r , u / v ) ; } } return r ; } } class geek { public static void Main ( ) { GfG g = new GfG ( ) ; int n = 5 ; int k = 2 ; Console . WriteLine ( g . findX ( n , k ) ) ; } }
class GFG { static int fact ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact *= i ; return fact ; } static int ncr ( int n , int r ) { int ncr = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; return ncr ; } static int ways ( int m , int w , int n , int k ) { int ans = 0 ; while ( m >= k ) { ans += ncr ( m , k ) * ncr ( w , n - k ) ; k += 1 ; } return ans ; } static void Main ( ) { int m , w , n , k ; m = 7 ; w = 6 ; n = 5 ; k = 3 ; System . Console . WriteLine ( ways ( m , w , n , k ) ) ; } }
using System ; class gfg { public int square ( int n ) { return n * n ; } public int sum ( int n ) { if ( n == 0 ) return 0 ; if ( n % 2 == 1 ) { return square ( ( n + 1 ) / 2 ) + sum ( n / 2 ) ; } else { return square ( n / 2 ) + sum ( n / 2 ) ; } } public int oddDivSum ( int a , int b ) { return sum ( b ) - sum ( a - 1 ) ; } } class geek { public static int Main ( ) { gfg g = new gfg ( ) ; int a = 3 , b = 9 ; Console . WriteLine ( g . oddDivSum ( a , b ) ) ; return 0 ; } }
using System ; class GFG { static int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; } static public void Main ( ) { int n = 32 ; Console . WriteLine ( " Minimum ▁ value ▁ of ▁ K ▁ is ▁ = ▁ " + countBits ( n ) ) ; } }
using System ; class GFG { static bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . Sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } static bool isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . Log ( a ) / Math . Log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; } static bool isAchillesNumber ( int n ) { if ( isPowerful ( n ) && ! isPower ( n ) ) return true ; else return false ; } public static void Main ( ) { int n = 72 ; if ( isAchillesNumber ( n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; n = 36 ; if ( isAchillesNumber ( n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class Geeks { static int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = 0 ; for ( int j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } } if ( ( divCount % 2 ) != 0 ) { ++ res ; } } return res ; } public static void Main ( String [ ] args ) { int a = 1 , b = 10 ; Console . WriteLine ( OddDivCount ( a , b ) ) ; } }
using System ; class GFG { static double largestSquareFactor ( double num ) { double answer = 1 ; for ( int i = 2 ; i < Math . Sqrt ( num ) ; ++ i ) { int cnt = 0 ; int j = i ; while ( num % j == 0 ) { cnt ++ ; j *= i ; } if ( ( cnt & 1 ) != 0 ) { cnt -- ; answer *= Math . Pow ( i , cnt ) ; } else { answer *= Math . Pow ( i , cnt ) ; } } return answer ; } static public void Main ( ) { int N = 420 ; Console . WriteLine ( largestSquareFactor ( N ) ) ; } }
class GFG { static int Nth_Term ( int n ) { return ( int ) ( 3 * System . Math . Pow ( n , 2 ) - n + 2 ) / ( 2 ) ; } static void Main ( ) { int N = 5 ; System . Console . WriteLine ( Nth_Term ( N ) ) ; } }
using System ; class GFG { static void countPermutations ( int N , int B ) { int x = ( int ) Math . Pow ( B , N ) ; int y = ( int ) Math . Pow ( B , N - 1 ) ; Console . WriteLine ( x - y ) ; } public static void Main ( ) { int N = 6 ; int B = 4 ; countPermutations ( N , B ) ; } }
using System ; using System . Linq ; class GFG { static int calculateDifference ( int [ ] arr , int n ) { int max_val = arr . Max ( ) ; var prime = Enumerable . Repeat ( true , max_val + 1 ) . ToArray ( ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int P1 = 1 , P2 = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { P1 *= arr [ i ] ; } else if ( arr [ i ] != 1 ) { P2 *= arr [ i ] ; } } return Math . Abs ( P2 - P1 ) ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 3 , 5 , 10 , 15 , 7 } ; int n = arr . Length ; Console . WriteLine ( calculateDifference ( arr , n ) ) ; } }
using System ; class GFG { static int EqualNumbers ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n != 0 ) return n - 1 ; return n ; } static public void Main ( ) { int [ ] a = { 1 , 4 , 1 } ; int n = a . Length ; Console . WriteLine ( EqualNumbers ( a , n ) ) ; } }
using System ; class GFG { static int count_odd_pair ( int n , int [ ] a ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } int ans = odd * even * 2 ; return ans ; } static int count_even_pair ( int odd_sum_pairs , int n ) { int total_pairs = ( n * ( n - 1 ) ) ; int ans = total_pairs - odd_sum_pairs ; return ans ; } public static void Main ( ) { int n = 6 ; int [ ] a = { 2 , 4 , 5 , 9 , 1 , 8 } ; int odd_sum_pairs = count_odd_pair ( n , a ) ; int even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) ; Console . WriteLine ( " Even ▁ Sum ▁ Pairs ▁ = ▁ " + even_sum_pairs ) ; Console . WriteLine ( " Odd ▁ Sum ▁ Pairs = ▁ " + odd_sum_pairs ) ; } }
using System ; class GFG { static int findSteps ( int n , int m , int [ ] a ) { int cur = 1 ; int steps = 0 ; for ( int i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; } public static void Main ( ) { int n = 3 , m = 3 ; int [ ] a = { 2 , 1 , 2 } ; Console . WriteLine ( findSteps ( n , m , a ) ) ; } }
class GFG { static void HexToBin ( char [ ] hexdec ) { int i = 0 ; while ( hexdec [ i ] != ' \u0000' ) { switch ( hexdec [ i ] ) { case '0' : System . Console . Write ( "0000" ) ; break ; case '1' : System . Console . Write ( "0001" ) ; break ; case '2' : System . Console . Write ( "0010" ) ; break ; case '3' : System . Console . Write ( "0011" ) ; break ; case '4' : System . Console . Write ( "0100" ) ; break ; case '5' : System . Console . Write ( "0101" ) ; break ; case '6' : System . Console . Write ( "0110" ) ; break ; case '7' : System . Console . Write ( "0111" ) ; break ; case '8' : System . Console . Write ( "1000" ) ; break ; case '9' : System . Console . Write ( "1001" ) ; break ; case ' A ' : case ' a ' : System . Console . Write ( "1010" ) ; break ; case ' B ' : case ' b ' : System . Console . Write ( "1011" ) ; break ; case ' C ' : case ' c ' : System . Console . Write ( "1100" ) ; break ; case ' D ' : case ' d ' : System . Console . Write ( "1101" ) ; break ; case ' E ' : case ' e ' : System . Console . Write ( "1110" ) ; break ; case ' F ' : case ' f ' : System . Console . Write ( "1111" ) ; break ; default : System . Console . Write ( " STRNEWLINE Invalid ▁ hexadecimal ▁ digit ▁ " + hexdec [ i ] ) ; break ; } i ++ ; } } static void Main ( ) { string s = "1AC5" ; char [ ] hexdec = new char [ 100 ] ; hexdec = s . ToCharArray ( ) ; System . Console . Write ( " Equivalent ▁ Binary ▁ value ▁ is ▁ : ▁ " ) ; try { HexToBin ( hexdec ) ; } catch ( System . IndexOutOfRangeException ) { System . Console . Write ( " " ) ; } } }
using System ; public class GFG { static bool isPowerOfTwo ( int x ) { return ( x > 0 && ( ! ( ( x & ( x - 1 ) ) > 0 ) ) ) ; } static void Count_pairs ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) ) count ++ ; } int ans = ( count * ( count - 1 ) ) / 2 ; Console . WriteLine ( ans ) ; } static public void Main ( ) { int [ ] a = { 2 , 5 , 8 , 16 , 128 } ; int n = a . Length ; Count_pairs ( a , n ) ; } }
using System ; public class GFG { static int factorial ( int n ) { int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = result * i ; return result ; } static int nCr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } static int calculate_result ( int n ) { int result = 2 * nCr ( ( n - 2 ) , ( n / 2 - 1 ) ) ; return result ; } public static void Main ( ) { int a = 2 , b = 4 ; Console . WriteLine ( calculate_result ( 2 * a ) ) ; Console . Write ( calculate_result ( 2 * b ) ) ; } }
using System ; class GFG { static void PossibleValues ( int b , int x , int n ) { int leastdivisible = ( b / x + 1 ) * x ; int flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { Console . Write ( leastdivisible - b + " ▁ " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) Console . WriteLine ( - 1 ) ; } public static void Main ( ) { int b = 10 , x = 6 , n = 40 ; PossibleValues ( b , x , n ) ; } }
using System ; using System . Collections ; using System . Collections . Generic ; public class GFG { static int digitProduct ( int [ ] digits , int start , int end ) { int pro = 1 ; for ( int i = start ; i <= end ; i ++ ) { pro *= digits [ i ] ; } return pro ; } static bool isDistinct ( int N ) { string s = N . ToString ( ) ; int len = s . Length ; int [ ] digits = new int [ len ] ; ArrayList products = new ArrayList ( ) ; for ( int i = 0 ; i < len ; i ++ ) { digits [ i ] = s [ i ] - '0' ; } for ( int i = 0 ; i < len ; i ++ ) { for ( int j = i ; j < len ; j ++ ) { int val = digitProduct ( digits , i , j ) ; if ( products . Contains ( val ) ) return false ; else products . Add ( val ) ; } } return true ; } public static void Main ( ) { int N = 324 ; if ( isDistinct ( N ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static long nthHilbertNumber ( int n ) { return 4 * ( n - 1 ) + 1 ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( nthHilbertNumber ( n ) ) ; } }
using System ; class GFG { static long nthKyneaNumber ( int n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( nthKyneaNumber ( n ) ) ; } }
using System ; class GFG { static long nthKyneaNumber ( int n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( nthKyneaNumber ( n ) ) ; } }
using System ; class GFG { static bool isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static bool isProthNumber ( int n ) { int k = 1 ; while ( k < ( n / k ) ) { if ( n % k == 0 ) { if ( isPowerOfTwo ( n / k ) ) return true ; } k = k + 2 ; } return false ; } public static void Main ( ) { int n = 25 ; if ( isProthNumber ( n - 1 ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static int get_last_two_digit ( long N ) { if ( N <= 10 ) { long ans = 0 , fac = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ( int ) ans % 100 ; } return 13 ; } public static void Main ( ) { long N = 1 ; for ( N = 1 ; N <= 10 ; N ++ ) Console . WriteLine ( " For ▁ N ▁ = ▁ " + N + " ▁ : ▁ " + get_last_two_digit ( N ) ) ; } }
using System ; class GFG { static bool isProductEven ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; } public static void Main ( ) { int [ ] arr = { 2 , 4 , 3 , 5 } ; int n = arr . Length ; if ( isProductEven ( arr , n ) ) Console . WriteLine ( " Even " ) ; else Console . WriteLine ( " Odd " ) ; } }
using System ; public class Improve { static int calculateSquareSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; } public static void Main ( ) { int n = 6 ; Console . Write ( " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " + calculateSquareSum ( n ) ) ; } }
using System ; class GFG { static int fnMod ( int n ) { int rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; } public static void Main ( ) { int n = 6 ; Console . Write ( fnMod ( n ) ) ; } }
using System ; class GFG { static int MinimumMoves ( int [ ] a , int n , int x ) { int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { int p = ( a [ i - 1 ] - a [ i ] ) / x + 1 ; ans += p ; a [ i ] += p * x ; } } return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 3 , 2 } ; int x = 2 ; int n = arr . Length ; Console . Write ( MinimumMoves ( arr , n , x ) ) ; } }
using System ; class GFG { static int SumOfDigits ( String str , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( str [ i ] - '0' ) ; return sum ; } static bool Divisible ( String str , int n ) { if ( SumOfDigits ( str , n ) % 3 == 0 && str [ n - 1 ] == '0' ) return true ; return false ; } public static void Main ( ) { String str = "263730746028908374890" ; int n = str . Length ; if ( Divisible ( str , n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static bool isPrime ( int k ) { if ( k <= 1 ) return false ; for ( int i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; } static int check ( int num , int k ) { int flag = 1 ; for ( int i = 2 ; i < k ; i ++ ) { if ( num % i == 0 ) flag = 0 ; } if ( flag == 1 ) { if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; } static int findCount ( int a , int b , int k ) { int count = 0 ; if ( ! isPrime ( k ) ) return 0 ; else { int ans ; for ( int i = a ; i <= b ; i ++ ) { ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; } public static void Main ( ) { int a = 2020 , b = 6300 , k = 29 ; Console . WriteLine ( findCount ( a , b , k ) ) ; } }
using System ; class GFG { static int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . Max ( c , i + 1 ) ) ans += d - Math . Max ( c , i + 1 ) + 1 ; return ans ; } public static void Main ( ) { int a = 2 , b = 3 , c = 3 , d = 4 ; Console . WriteLine ( NumberOfSolutions ( a , b , c , d ) ) ; } }
using System ; class GFG { static long findF_N ( long n ) { long ans = 0 ; for ( long i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; } public static void Main ( ) { long n = 3 ; Console . WriteLine ( findF_N ( n ) ) ; } }
using System ; class GFG { static string findNumber ( int n , int d ) { string ans = " " ; if ( d != 10 ) { ans += d . ToString ( ) ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } else { if ( n == 1 ) ans += " Impossible " ; else { ans += '1' ; for ( int i = 1 ; i < n ; i ++ ) ans += '0' ; } } return ans ; } public static void Main ( ) { int n = 12 , d = 3 ; Console . WriteLine ( findNumber ( n , d ) ) ; } }
using System ; class GFG { static int MAX = 1000000 ; static int [ ] sieve_Prime = new int [ MAX + 4 ] ; static int [ ] sieve_count = new int [ MAX + 4 ] ; static void form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( int j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } } public static void Main ( ) { form_sieve ( ) ; int n = 2 ; Console . WriteLine ( " Count ▁ = ▁ " + ( sieve_count [ n ] + 1 ) ) ; n = 3 ; Console . WriteLine ( " Count ▁ = ▁ " + ( sieve_count [ n ] + 1 ) ) ; } }
using System ; using System . Collections . Generic ; public class GFG { static List < int > PrimeFactors ( int n ) { List < int > v = new List < int > ( ) ; int x = n ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( x % i == 0 ) { v . Add ( i ) ; while ( x % i == 0 ) x /= i ; } } if ( x > 1 ) v . Add ( x ) ; return v ; } static int GoodNumber ( int n ) { List < int > v = new List < int > ( PrimeFactors ( n ) ) ; int ans = 1 ; for ( int i = 0 ; i < v . Count ; i ++ ) ans *= v [ i ] ; return ans ; } public static void Main ( String [ ] args ) { int n = 12 ; Console . WriteLine ( GoodNumber ( n ) ) ; } }
using System ; class GFG { static bool checkSpecialPrime ( bool [ ] sieve , int num ) { while ( num != 0 ) { if ( ! sieve [ num ] ) { return false ; } num /= 10 ; } return true ; } static void findSpecialPrime ( int N ) { bool [ ] sieve = new bool [ N + 10 ] ; for ( int i = 0 ; i < N + 10 ; i ++ ) sieve [ i ] = true ; sieve [ 0 ] = sieve [ 1 ] = false ; for ( int i = 2 ; i <= N ; i ++ ) { if ( sieve [ i ] ) { for ( int j = i * i ; j <= N ; j += i ) { sieve [ j ] = false ; } } } while ( true ) { if ( checkSpecialPrime ( sieve , N ) ) { Console . WriteLine ( N ) ; break ; } else N -- ; } } public static void Main ( ) { findSpecialPrime ( 379 ) ; findSpecialPrime ( 100 ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } public static void Main ( string [ ] args ) { int n = 13 ; if ( isPrime ( n ) && ( n % 4 == 1 ) ) { Console . WriteLine ( " YES " ) ; } else { Console . WriteLine ( " NO " ) ; } } }
using System ; class GFG { static float heightCalculate ( int H , int n , int m ) { float N = ( float ) ( n * 1.0 ) ; float M = ( float ) ( m * 1.0 ) ; float h = H * ( float ) Math . Sqrt ( N / ( N + M ) ) ; return h ; } public static void Main ( ) { int H = 10 , n = 3 , m = 4 ; Console . WriteLine ( heightCalculate ( H , n , m ) ) ; } }
using System ; class GFG { static bool isprime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; } static bool isNSqMinusnMSqPrime ( int m , int n ) { if ( n - m == 1 && isprime ( m + n ) ) return true ; else return false ; } public static void Main ( ) { int m = 13 , n = 16 ; if ( isNSqMinusnMSqPrime ( m , n ) ) Console . Write ( " YES " ) ; else Console . Write ( " NO " ) ; } }
using System ; class GFG { static void findsolution ( long n , long x , long y ) { if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x y < n ) { Console . WriteLine ( " No ▁ solution " ) ; return ; } Console . WriteLine ( y - n + 1 ) ; while ( n -- > 1 ) Console . WriteLine ( "1" ) ; } static public void Main ( ) { long n , x , y ; n = 5 ; x = 15 ; y = 15 ; findsolution ( n , x , y ) ; } }
using System ; class GFG { static int findPosition ( int n , int f , int b ) { return n - Math . Max ( f + 1 , n - b ) + 1 ; } public static void Main ( ) { int n = 5 , f = 2 , b = 3 ; Console . WriteLine ( findPosition ( n , f , b ) ) ; } }
using System ; class GFG { static int nthOdd ( int n ) { return ( 2 * n - 1 ) ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( nthOdd ( n ) ) ; } }
using System ; class GFG { static int nthEven ( int n ) { return ( 2 * n ) ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( nthEven ( n ) ) ; } }
using System ; class GFG { static double nthHarmonic ( int N ) { float harmonic = 1 ; for ( int i = 2 ; i <= N ; i ++ ) { harmonic += ( float ) 1 / i ; } return harmonic ; } static public void Main ( ) { int N = 8 ; Console . Write ( nthHarmonic ( N ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + n - 3 ; } public static void Main ( ) { int N = 4 ; Console . Write ( nthTerm ( N ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return 5 * ( int ) Math . Pow ( n , 2 ) - 5 * n ; } public static void Main ( ) { int N = 4 ; Console . Write ( nthTerm ( N ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) + n - 2 ; } public static void Main ( ) { int N = 4 ; Console . Write ( nthTerm ( N ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + 4 * n - 2 ; } public static void Main ( ) { int N = 4 ; Console . Write ( nthTerm ( N ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return 3 * ( int ) Math . Pow ( n , 2 ) + 2 * n - 5 ; } public static void Main ( ) { int N = 4 ; Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) + 3 * n - 5 ; } public static void Main ( ) { int N = 4 ; Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return 4 * ( int ) Math . Pow ( n , 2 ) - 3 * n + 2 ; } public static void Main ( ) { int N = 4 ; Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; class GFG { static double PI = 3.1415926535 ; static double findAnglesA ( double a , double b , double c ) { double A = Math . Acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) ; return A * 180 / PI ; } static double findAnglesB ( double a , double b , double c ) { double B = Math . Acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) ; return B * 180 / PI ; } static void printAngles ( int a , int b , int c ) { double x = ( double ) a ; double y = ( double ) b ; double z = ( double ) c ; double A = findAnglesA ( x , y , z ) ; double B = findAnglesB ( x , y , z ) ; Console . WriteLine ( " Angles ▁ are ▁ A ▁ = ▁ " + A + " , ▁ B ▁ = ▁ " + B + " , ▁ C ▁ = ▁ " + 90 ) ; } static void printOtherSides ( int n ) { int b = 0 , c = 0 ; if ( ( n & 1 ) > 0 ) { if ( n == 1 ) Console . WriteLine ( - 1 ) ; else { b = ( n * n - 1 ) / 2 ; c = ( n * n + 1 ) / 2 ; Console . WriteLine ( " Side ▁ b ▁ = ▁ " + b + " , ▁ Side ▁ c ▁ = ▁ " + c ) ; } } else { if ( n == 2 ) Console . WriteLine ( - 1 ) ; else { b = n * n / 4 - 1 ; c = n * n / 4 + 1 ; Console . WriteLine ( " Side ▁ b ▁ = ▁ " + b + " , ▁ Side ▁ c ▁ = ▁ " + c ) ; } } printAngles ( n , b , c ) ; } public static void Main ( ) { int a = 12 ; printOtherSides ( a ) ; } }
using System ; class GFG { static int calculateSum ( int n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( " Sum ▁ = ▁ " + calculateSum ( n ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return 2 * ( int ) Math . Pow ( n , 2 ) - n - 1 ; } static public void Main ( ) { int N = 4 ; Console . Write ( nthTerm ( N ) ) ; } }
using System ; class GFG { static int nthTerm ( int n ) { return 4 * ( int ) Math . Pow ( n , 2 ) - 7 * n + 3 ; } static public void Main ( ) { int N = 4 ; Console . Write ( nthTerm ( N ) ) ; } }
using System ; class GFG { static void checkIfPowerIsolated ( int num ) { int input = num ; int count = 0 ; int [ ] factor = new int [ num + 1 ] ; if ( num % 2 == 0 ) { while ( num % 2 == 0 ) { ++ count ; num /= 2 ; } factor [ 2 ] = count ; } for ( int i = 3 ; i * i <= num ; i += 2 ) { count = 0 ; while ( num % i == 0 ) { ++ count ; num /= i ; } if ( count > 0 ) factor [ i ] = count ; } if ( num > 1 ) factor [ num ] = 1 ; int product = 1 ; for ( int i = 0 ; i < num + 1 ; i ++ ) { if ( factor [ i ] > 0 ) product = product * factor [ i ] * i ; } if ( product == input ) Console . Write ( " Power - isolated ▁ Integer STRNEWLINE " ) ; else Console . Write ( " Not ▁ a ▁ Power - isolated ▁ Integer STRNEWLINE " ) ; } static void Main ( ) { checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ; } }
using System ; class GFG { static long getNthTerm ( long N ) { return ( ( int ) Math . Pow ( N , 2 ) + N + 1 ) ; } static public void Main ( ) { long N = 11 ; Console . Write ( getNthTerm ( N ) ) ; } }
using System ; class GFG { static long findSum ( int n ) { long sum2 , sum5 , sum10 ; sum2 = ( ( n / 2 ) * ( 4 + ( n / 2 - 1 ) * 2 ) ) / 2 ; sum5 = ( ( n / 5 ) * ( 10 + ( n / 5 - 1 ) * 5 ) ) / 2 ; sum10 = ( ( n / 10 ) * ( 20 + ( n / 10 - 1 ) * 10 ) ) / 2 ; return sum2 + sum5 - sum10 ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; class Nth { float CalculateRatio ( float m , float n ) { return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; } public static void Main ( ) { float m = 6 , n = 2 ; Nth a = new Nth ( ) ; Console . WriteLine ( a . CalculateRatio ( m , n ) ) ; } }
using System ; class GFG { static int calculateSum ( int n ) { return ( int ) Math . Pow ( n * ( n + 1 ) / 2 , 2 ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( calculateSum ( n ) ) ; } }
class GFG { static int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } static int powerDigitSum ( int a , int n ) { int res = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { res = res * digSum ( a ) ; res = digSum ( res ) ; } a = digSum ( digSum ( a ) * digSum ( a ) ) ; n /= 2 ; } return res ; } static void Main ( ) { int a = 9 , n = 4 ; System . Console . WriteLine ( powerDigitSum ( a , n ) ) ; } }
using System ; class GFG { static int totEdge ( int n ) { int result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; } public static void Main ( ) { int n = 6 ; Console . Write ( totEdge ( n ) ) ; } }
using System ; class GFG { static int coin ( int totalRupees , int X , int Y , int Z ) { float one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2 ) ; twentyfive = ( ( Z * 1 ) / 4 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return ( int ) result ; } public static void Main ( ) { int totalRupees = 1800 ; int X = 1 , Y = 2 , Z = 4 ; int Rupees = coin ( totalRupees , X , Y , Z ) ; Console . WriteLine ( "1 ▁ rupess ▁ coins ▁ = ▁ " + Rupees * 1 ) ; Console . WriteLine ( "50 ▁ paisa ▁ coins ▁ = ▁ " + Rupees * 2 ) ; Console . WriteLine ( "25 ▁ paisa ▁ coins ▁ = ▁ " + Rupees * 4 ) ; } }
using System ; class GFG { static float sumOfSeries ( int x , int k ) { float y = ( float ) ( ( ( float ) ( x ) / 81 ) * ( 9 * k - 1 + Math . Pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; } public static void Main ( ) { int x = 9 ; int k = 20 ; Console . Write ( sumOfSeries ( x , k ) ) ; } }
using System ; public class GFG { static int modExp ( int a , int b ) { int result = 1 ; while ( b > 0 ) { if ( b == 1 ) result = result * a ; a = a * a ; b /= 2 ; } return result ; } static int check ( int num ) { if ( num == 1 num < 3 ) return - 1 ; else if ( num % 4 == 0 ) return modExp ( num / 4 , 4 ) ; else if ( num % 6 == 0 ) return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) ; else if ( num % 10 == 0 ) return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) ; else return - 1 ; } static public void Main ( ) { int num = 10 ; Console . WriteLine ( check ( num ) ) ; } }
using System ; class GFG { static bool isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; } public static void Main ( ) { long n = 19877658 ; if ( isDivisible ( n ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; public class GFG { static int nextPowerOf2 ( int n ) { int count = 0 ; if ( n != 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } static int removeElement ( int n ) { if ( n == 1 n == 2 ) return 0 ; int a = nextPowerOf2 ( n ) ; if ( n == a n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; } public static void Main ( ) { int n = 5 ; Console . Write ( removeElement ( n ) ) ; } }
using System ; class GFG { static int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; } static void Main ( ) { int trainLength = 120 ; int Speed = 30 ; int Time = 18 ; Console . Write ( " Length ▁ of ▁ bridge ▁ = ▁ " + bridge_length ( trainLength , Speed , Time ) + " ▁ meters " ) ; } }
using System ; class gfg { public long MOD = 1000000007 ; public long modInv ( long x ) { long n = MOD - 2 ; long result = 1 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) result = result * x % MOD ; x = x * x % MOD ; n = n / 2 ; } return result ; } public long getSum ( long n , long k ) { long ans = 1 ; for ( long i = n + 1 ; i > n - k ; i -- ) ans = ans * i % MOD ; ans = ans * modInv ( k + 1 ) % MOD ; return ans ; } } class geek { public static int Main ( ) { gfg g = new gfg ( ) ; long n = 3 , k = 2 ; Console . WriteLine ( g . getSum ( n , k ) ) ; return 0 ; } }
class GFG { static void printCombination ( int n ) { System . Console . Write ( 1 + " ▁ " ) ; if ( ( n - 2 ) % 3 == 0 ) System . Console . Write ( 2 + " ▁ " + ( n - 3 ) ) ; else System . Console . Write ( 1 + " ▁ " + ( n - 2 ) ) ; } static void Main ( ) { int n = 233 ; printCombination ( n ) ; } }
using System ; class GFG { static bool checkPairs ( int l , int r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; } static public void Main ( ) { int l = 1 , r = 8 ; if ( checkPairs ( l , r ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static bool isPalindrome ( int n ) { if ( n % 11 == 0 ) { return true ; } return false ; } public static void Main ( ) { Console . Write ( isPalindrome ( 123321 ) ? " Palindrome " : " Not ▁ Palindrome " ) ; } }
using System ; class GFG { public static void Main ( ) { int target = 93 ; int [ ] arr = { 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 } ; int length = arr . Length ; int totalCount = 0 ; for ( int i = 0 ; i < length - 2 ; i ++ ) { if ( target % arr [ i ] == 0 ) { for ( int j = i + 1 ; j < length - 1 ; j ++ ) { if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) { int toFind = target / ( arr [ i ] * arr [ j ] ) ; for ( int k = j + 1 ; k < length ; k ++ ) { if ( arr [ k ] == toFind ) { totalCount ++ ; } } } } } } Console . Write ( " Total ▁ number ▁ of ▁ triplets ▁ found ▁ : ▁ " + totalCount ) ; } }
using System ; class GFG { static long binomialCoeff ( long n , long k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( long n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void Main ( String [ ] args ) { int n = 3 ; Console . WriteLine ( catalan ( n ) ) ; } }
using System ; class GFG { public static bool isFascinating ( int num ) { int [ ] freq = new int [ 10 ] ; String val = " " + num . ToString ( ) + ( num * 2 ) . ToString ( ) + ( num * 3 ) . ToString ( ) ; for ( int i = 0 ; i < val . Length ; i ++ ) { int digit = val [ i ] - '0' ; if ( freq [ digit ] && digit != 0 > 0 ) return false ; else freq [ digit ] ++ ; } for ( int i = 1 ; i < freq . Length ; i ++ ) { if ( freq [ i ] == 0 ) return false ; } return true ; } static void Main ( ) { int num = 192 ; if ( num < 100 ) Console . WriteLine ( " No " ) ; else { bool ans = isFascinating ( num ) ; if ( ans ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { public static int binomial_coefficient ( int n , int m ) { int res = 1 ; if ( m > n - m ) m = n - m ; for ( int i = 0 ; i < m ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static int calculate_ways ( int m , int n ) { if ( m < n ) { return 0 ; } int ways = binomial_coefficient ( n + m - 1 , n - 1 ) ; return ways ; } public static void Main ( ) { int m = 7 , n = 5 ; int result = calculate_ways ( m , n ) ; Console . WriteLine ( result . ToString ( ) ) ; } }
using System ; class GFG { static int N = 100005 ; static int [ ] phi ; static int [ ] S ; static void computeTotient ( ) { for ( int i = 1 ; i < N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } } static void CoPrimes ( ) { computeTotient ( ) ; for ( int i = 1 ; i < N ; i ++ ) S [ i ] = S [ i - 1 ] + phi [ i ] ; } public static void Main ( ) { phi = new int [ N ] ; S = new int [ N ] ; CoPrimes ( ) ; int [ ] q = { 3 , 4 } ; int n = q . Length ; for ( int i = 0 ; i < n ; i ++ ) Console . WriteLine ( " Number ▁ of ▁ unordered ▁ coprime STRNEWLINE " + " pairs ▁ of ▁ integers ▁ from ▁ 1 ▁ to ▁ " + q [ i ] + " ▁ are ▁ " + S [ q [ i ] ] ) ; } }
using System ; class GFG { static int binaryToDecimal ( String n ) { String num = n ; int dec_value = 0 ; int base_ = 1 ; int len = num . Length ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == '1' ) dec_value += base_ ; base_ = base_ * 2 ; } return dec_value ; } static int numberSequence ( int n ) { if ( n == 1 ) return 1 ; String s = " " ; for ( int i = 1 ; i < n ; i ++ ) s += '1' ; s += '0' ; for ( int i = 1 ; i <= n ; i ++ ) s += '1' ; int num = binaryToDecimal ( s ) ; return num ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( numberSequence ( n ) ) ; } }
using System ; class GFG { static int numberSequence ( int n ) { int num = ( int ) ( Math . Pow ( 4 , n ) - Math . Pow ( 2 , n ) ) - 1 ; return num ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( numberSequence ( n ) ) ; } }
using System ; class GFG { static int prime ( int num ) { int i , flag = 0 ; for ( i = 2 ; i <= num / 2 ; i ++ ) { if ( num % i == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) return 1 ; else return 0 ; } static void print_alternate_prime ( int n ) { int counter = 0 ; for ( int num = 2 ; num < n ; num ++ ) { if ( prime ( num ) == 1 ) { if ( counter % 2 == 0 ) Console . Write ( num + " ▁ " ) ; counter ++ ; } } } public static void Main ( ) { int n = 15 ; Console . Write ( " Following ▁ are ▁ the ▁ alternate ▁ " + " prime ▁ number ▁ smaller ▁ than ▁ " + " or ▁ equal ▁ to ▁ " + n + " STRNEWLINE " ) ; print_alternate_prime ( n ) ; } }
using System ; class GFG { static void SieveOfEratosthenes ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } bool flag = true ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { if ( flag ) { Console . Write ( p + " ▁ " ) ; flag = false ; } else { flag = true ; } } } } public static void Main ( ) { int n = 15 ; Console . Write ( " Following ▁ are ▁ the ▁ alternate " + " ▁ prime ▁ numbers ▁ smaller ▁ " + " than ▁ or ▁ equal ▁ to ▁ " + n + " STRNEWLINE " ) ; SieveOfEratosthenes ( n ) ; } }
using System ; class GFG { static bool findGreater ( int x , int y ) { if ( x > y ) { return false ; } else { return true ; } } public static void Main ( ) { int x = 4 ; int y = 9 ; if ( findGreater ( x , y ) ) Console . WriteLine ( "1" ) ; else Console . WriteLine ( "2" ) ; } }
using System ; class GFG { static int max_profit ( int [ ] a , int [ ] b , int n , int fee ) { int i , j , profit ; int l , r , diff_day = 1 , sum = 0 ; b [ 0 ] = 0 ; b [ 1 ] = diff_day ; for ( i = 1 ; i < n ; i ++ ) { l = 0 ; r = diff_day ; sum = 0 ; for ( j = n - 1 ; j >= i ; j -- ) { profit = ( a [ r ] - a [ l ] ) - fee ; if ( profit > 0 ) { sum = sum + profit ; } l ++ ; r ++ ; } if ( b [ 0 ] < sum ) { b [ 0 ] = sum ; b [ 1 ] = diff_day ; } diff_day ++ ; } return 0 ; } static public void Main ( ) { int [ ] arr = { 6 , 1 , 7 , 2 , 8 , 4 } ; int n = arr . Length ; int [ ] b = new int [ 2 ] ; int tranFee = 2 ; max_profit ( arr , b , n , tranFee ) ; Console . WriteLine ( b [ 0 ] + " , ▁ " + b [ 1 ] ) ; } }
using System ; class GFG { static int binomialCoeff ( int x , int n , int k ) { int sum = 0 , term = 1 ; for ( int i = 1 ; i <= n && sum < k ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; } return sum ; } static int minTrials ( int n , int k ) { int low = 1 , high = k ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( binomialCoeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; } public static void Main ( ) { Console . WriteLine ( minTrials ( 2 , 10 ) ) ; } }
using System ; using System . Text ; using System . Collections ; class Geeks { static bool isPrime ( int num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( int i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; } static int primePalindrome ( int N ) { if ( 8 <= N && N <= 11 ) return 11 ; for ( int x = 1 ; x < 100000 ; ++ x ) { string s = x . ToString ( ) ; char [ ] buffer = s . ToCharArray ( ) ; Array . Reverse ( buffer ) ; int y = Int32 . Parse ( s + new string ( buffer ) . Substring ( 1 ) ) ; if ( y >= N && isPrime ( y ) == true ) return y ; } return - 1 ; } public static void Main ( ) { Console . WriteLine ( primePalindrome ( 112 ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int getsum ( int a ) { int r = 0 , sum = 0 ; while ( a > 0 ) { r = a % 10 ; sum = sum + r ; a = a / 10 ; } return sum ; } static void value ( int a , int b , int c ) { int no , x = 0 , q = 0 , w = 0 ; List < int > v = new List < int > ( ) ; for ( int i = 1 ; i < 82 ; i ++ ) { no = ( int ) Math . Pow ( i , a ) ; no = b * no + c ; if ( no > 0 && no < 1000000000 ) { x = getsum ( no ) ; if ( x == i ) { q ++ ; v . Add ( no ) ; w ++ ; } } } for ( int i = 0 ; i < v . Count ; i ++ ) { Console . Write ( v [ i ] + " ▁ " ) ; } } public static void Main ( String [ ] args ) { int a = 2 , b = 2 , c = - 1 ; value ( a , b , c ) ; } }
using System ; class GFG { static void print ( int p0 ) { int p1 , i = 0 , x , flag , k ; while ( true ) { flag = 1 ; x = ( int ) ( Math . Pow ( 2 , i ) ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; Console . Write ( p1 + " ▁ " ) ; i ++ ; } } static void Main ( ) { int p0 = 19 ; print ( p0 ) ; } }
using System ; class GFG { public static int findOddPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( ( A [ i ] % 2 == 1 ) ) { count ++ ; } } return count * ( count - 1 ) / 2 ; } public static void Main ( string [ ] args ) { int [ ] a = new int [ ] { 5 , 1 , 3 , 2 } ; int n = a . Length ; Console . WriteLine ( findOddPair ( a , n ) ) ; } }
using System ; class GFG { static bool isSurd ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; } public static void Main ( ) { int n = 15 ; if ( isSurd ( n ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static long LastTwoDigit ( long num ) { long one = num % 10 ; num /= 10 ; long tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; } public static void Main ( String [ ] args ) { int n = 10 ; long num = 1 ; num = ( long ) Math . Pow ( 2 , n ) ; Console . WriteLine ( " Last ▁ 2 ▁ digits ▁ of ▁ 2 ^ 10 ▁ = ▁ " + LastTwoDigit ( num ) ) ; } }
using System ; class GFG { static int power ( long x , long y , long p ) { while ( y > 0 ) { long r = y & 1 ; if ( r == 1 ) res = ( res * ( int ) x ) % ( int ) p ; x = ( x * x ) % p ; } return res ; } static int numberOfDigits ( int x ) { int i = 0 ; while ( x != 0 ) { x /= 10 ; i ++ ; } return i ; } static void LastTwoDigit ( int n ) { Console . Write ( " Last ▁ " + 2 + " ▁ digits ▁ of ▁ " + 2 + " ^ " ) ; Console . Write ( n + " ▁ = ▁ " ) ; int temp = 1 ; for ( int i = 1 ; i <= 2 ; i ++ ) temp *= 10 ; temp = power ( 2 , n , temp ) ; for ( int i = 0 ; i < ( 2 - numberOfDigits ( temp ) ) ; i ++ ) Console . Write ( 0 + " ▁ " ) ; if ( temp != 0 ) Console . Write ( temp ) ; } public static void Main ( ) { int n = 72 ; LastTwoDigit ( n ) ; } }
using System ; class GFG { static long modPower ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long gcd ( long a , long b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static long gcdPow ( long a , long n , long c ) { if ( a % c == 0 ) return c ; long modexpo = modPower ( a , n , c ) ; return gcd ( modexpo , c ) ; } public static void Main ( ) { long a = 10248585 , n = 1000000 , c = 12564 ; Console . Write ( gcdPow ( a , n , c ) ) ; } }
using System ; class GFG { static int countOddSum ( int [ ] ar , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int val = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; } public static void Main ( ) { int [ ] ar = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = ar . Length ; Console . Write ( " The ▁ Number ▁ of ▁ Subarrays " + " ▁ with ▁ odd ▁ sum ▁ is ▁ " ) ; Console . WriteLine ( countOddSum ( ar , n ) ) ; } }
using System ; class GFG { static int countOddSum ( int [ ] ar , int n ) { int [ ] temp = { 1 , 0 } ; int result = 0 , val = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = temp [ 0 ] * temp [ 1 ] ; return ( result ) ; } public static void Main ( ) { int [ ] ar = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = ar . Length ; Console . Write ( " The ▁ Number ▁ of ▁ Subarrays " + " ▁ with ▁ odd ▁ sum ▁ is ▁ " + countOddSum ( ar , n ) ) ; } }
using System ; public class GEE { static void printPFsInPairs ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) Console . Write ( i + " * " + n / i + " STRNEWLINE " ) ; } public static void Main ( ) { int n = 24 ; printPFsInPairs ( n ) ; } }
using System ; class GFG { static int rangesum ( int n , int l , int r ) { int [ ] arr = new int [ n ] ; int c = 1 , i = 0 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } c = 2 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } int sum = 0 ; for ( i = l - 1 ; i < r ; i ++ ) { sum += arr [ i ] ; } return sum ; } public static void Main ( ) { int n = 12 ; int l = 1 , r = 11 ; Console . WriteLine ( rangesum ( n , l , r ) ) ; } }
using System ; class GFG { static void findAngle ( int n ) { int interiorAngle , exteriorAngle ; interiorAngle = ( n - 2 ) * 180 / n ; exteriorAngle = 360 / n ; Console . Write ( " Interior ▁ angle : ▁ " + interiorAngle + " STRNEWLINE " ) ; Console . Write ( " Exterior ▁ angle : ▁ " + exteriorAngle ) ; } public static void Main ( ) { int n = 10 ; findAngle ( n ) ; } }
using System ; class GFG { static void distance ( float x1 , float y1 , float z1 , float x2 , float y2 , float z2 ) { double d = Math . Pow ( ( Math . Pow ( x2 - x1 , 2 ) + Math . Pow ( y2 - y1 , 2 ) + Math . Pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; Console . WriteLine ( " Distance ▁ is ▁ STRNEWLINE " + d ) ; return ; } public static void Main ( ) { float x1 = 2 ; float y1 = - 5 ; float z1 = 7 ; float x2 = 3 ; float y2 = 4 ; float z2 = 5 ; distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ; } }
using System ; class GFG { static bool DivisibleBy41 ( int first , int second , int c , int n ) { int [ ] digit = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; } public static void Main ( ) { int first = 1 , second = 2 , c = 1 , n = 3 ; if ( DivisibleBy41 ( first , second , c , n ) ) Console . Write ( " YES " ) ; else Console . Write ( " NO " ) ; } }
using System ; public class GFG { static int findTetrahedralNumber ( int n ) { return ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ; } static void printSeries ( int n ) { int prev = 0 ; int curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTetrahedralNumber ( i ) ; curr = curr + prev ; Console . Write ( curr + " ▁ " ) ; prev = curr ; } } static public void Main ( ) { int n = 10 ; printSeries ( n ) ; } }
using System ; public class GFG { static void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; Console . Write ( num + " ▁ " ) ; } } static public void Main ( ) { int n = 10 ; printSeries ( n ) ; } }
using System ; class GFG { static int No_Of_Pairs ( int N ) { int i = 1 ; while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) i ++ ; return ( i - 1 ) ; } static void print_pairs ( int pairs ) { int i = 1 , mul ; for ( i = 1 ; i <= pairs ; i ++ ) { mul = i * ( i + 1 ) ; Console . WriteLine ( " Pair ▁ no . ▁ " + i + " ▁ - - > ▁ ( " + ( mul * i ) + " , ▁ " + mul * ( i + 1 ) + " ) " ) ; } } static void Main ( ) { int N = 500 , pairs ; pairs = No_Of_Pairs ( N ) ; Console . WriteLine ( " No . ▁ of ▁ pairs ▁ = ▁ " + pairs ) ; print_pairs ( pairs ) ; } }
using System ; public class GFG { static long findTriangularNumber ( int n ) { return ( n * ( n + 1 ) ) / 2 ; } static void printSeries ( int n ) { long prev = 0 ; long curr ; for ( int i = 1 ; i <= n ; i ++ ) { curr = findTriangularNumber ( i ) ; curr = curr + prev ; Console . Write ( curr + " ▁ " ) ; prev = curr ; } } static public void Main ( ) { int n = 10 ; printSeries ( n ) ; } }
using System ; public class GFG { static void printSeries ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { int num = i * ( i + 1 ) * ( i + 2 ) / 6 ; Console . Write ( num + " ▁ " ) ; } } static public void Main ( ) { int n = 10 ; printSeries ( n ) ; } }
using System ; class GFG { static void count_even_odd ( int min , int max , int [ , ] steps ) { int a , b , even , odd ; bool beven = true , aeven = false ; int n = 2 ; for ( int i = 0 ; i < n ; i ++ ) { a = steps [ i , 0 ] ; b = steps [ i , 1 ] ; if ( ! ( aeven || ( a & 1 ) > 0 ) ) aeven = true ; if ( beven ) { if ( ( b & 1 ) > 0 ) beven = false ; } else if ( ! ( ( a & 1 ) > 0 ) ) { if ( ! ( ( b & 1 ) > 0 ) ) beven = true ; } else { if ( ( b & 1 ) > 0 ) beven = true ; } } if ( beven ) { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } else { even = ( int ) max / 2 - ( int ) ( min - 1 ) / 2 ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) even += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; else odd += max - min + 1 - ( int ) max / 2 + ( int ) ( min - 1 ) / 2 ; Console . Write ( " even ▁ = ▁ " + even + " , ▁ odd ▁ = ▁ " + odd ) ; } public static void Main ( ) { int min = 1 , max = 4 ; int [ , ] steps = { { 1 , 2 } , { 3 , 4 } } ; count_even_odd ( min , max , steps ) ; } }
using System ; class GFG { static int getMaxOnes ( int n , int x ) { int zeroes = ( n / x ) ; zeroes = zeroes * zeroes ; int total = n * n ; int ans = total - zeroes ; return ans ; } static public void Main ( ) { int n = 5 ; int x = 2 ; Console . WriteLine ( getMaxOnes ( n , x ) ) ; } }
using System ; class GFG { static void check ( int n , int m ) { if ( n == 2 m == 2 n % m == 0 ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } public static void Main ( ) { int m = 3 , n = 9 ; check ( n , m ) ; } }
using System ; class GFG { static void findSurfaceArea ( float a , float h ) { float Area ; Area = 6 * a * h + 3 * ( float ) ( Math . Sqrt ( 3 ) ) * a * a ; Console . WriteLine ( " Surface ▁ Area : ▁ " + Area ) ; } static void findVolume ( float a , float h ) { float Volume ; Volume = 3 * ( float ) ( Math . Sqrt ( 3 ) ) * a * a * h / 2 ; Console . WriteLine ( " Volume : ▁ " + Volume ) ; } public static void Main ( ) { float a = 5 , h = 10 ; findSurfaceArea ( a , h ) ; findVolume ( a , h ) ; } }
using System ; class GFG { static double MinimumMail ( int n , int k , int x ) { double m = ( n - 1 ) + Math . Ceiling ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . Ceiling ( n * 1.0 / x ) * ( k - n ) ; return m ; } public static void Main ( ) { int N = 4 ; int K = 9 ; int X = 2 ; Console . WriteLine ( ( int ) MinimumMail ( N , K , X ) + " STRNEWLINE " ) ; } }
using System ; class GFG { static void findArea ( float a , float b ) { float Area ; Area = ( float ) 3.142 * a * b ; Console . WriteLine ( " Area : ▁ " + Area ) ; } public static void Main ( ) { float a = 5 , b = 4 ; findArea ( a , b ) ; } }
using System ; class GFG { static int calculate ( int x , int k , int m ) { int result = x ; k -- ; while ( k -- > 0 ) { result = ( int ) Math . Pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; } static public void Main ( ) { int x = 5 , k = 2 , m = 3 ; Console . WriteLine ( calculate ( x , k , m ) ) ; } }
using System ; class GFG { static int rev ( int n , int temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( n / 10 , temp ) ; } public static void Main ( ) { int n = 121 ; int temp = rev ( n , 0 ) ; if ( temp == n ) Console . WriteLine ( " yes " ) ; else Console . WriteLine ( " no " ) ; } }
using System ; class GFG { static void findGreater ( int a , int b , int n ) { if ( ! ( ( n & 1 ) > 0 ) ) { a = Math . Abs ( a ) ; b = Math . Abs ( b ) ; } if ( a == b ) Console . WriteLine ( " a ^ n ▁ is ▁ " + " equal ▁ to ▁ b ^ n " ) ; else if ( a > b ) Console . WriteLine ( " a ^ n ▁ is ▁ greater ▁ " + " than ▁ b ^ n " ) ; else Console . WriteLine ( " b ^ n ▁ is ▁ greater ▁ " + " than ▁ a ^ n " ) ; } public static void Main ( ) { int a = 12 , b = 24 , n = 5 ; findGreater ( a , b , n ) ; } }
using System ; public class GFG { static void fibonacci ( double n ) { double fib ; for ( double i = 0 ; i < n ; i ++ ) { fib = ( Math . Pow ( ( 1 + Math . Sqrt ( 5 ) ) , i ) - Math . Pow ( ( 1 - Math . Sqrt ( 5 ) ) , i ) ) / ( Math . Pow ( 2 , i ) * Math . Sqrt ( 5 ) ) ; Console . Write ( ( int ) fib + " ▁ " ) ; } } static public void Main ( ) { double n = 8 ; fibonacci ( n ) ; } }
using System ; class GFG { static int center_hexadecagonal_num ( int n ) { return 8 * n * n - 8 * n + 1 ; } static public void Main ( ) { int n = 2 ; Console . Write ( n + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " ) ; Console . WriteLine ( center_hexadecagonal_num ( n ) ) ; n = 12 ; Console . Write ( n + " th ▁ centered ▁ " + " hexadecagonal ▁ number : ▁ " ) ; Console . WriteLine ( center_hexadecagonal_num ( n ) ) ; } }
using System ; class GFG { public static int findNature ( int a , int b , int n ) { int [ ] seq = new int [ 100 ] ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( int i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; if ( ( seq [ n ] & 1 ) != 0 ) return 1 ; else return 0 ; } public static void Main ( ) { int a = 2 , b = 4 ; int n = 3 ; if ( findNature ( a , b , n ) == 1 ) Console . Write ( " Odd ▁ " ) ; else Console . Write ( " Even ▁ " ) ; } }
using System ; class GFG { static void check ( ulong m , ulong n ) { double RHS = m * ( double ) Math . Log ( n ) ; double LHS = n * ( double ) Math . Log ( m ) ; if ( LHS > RHS ) Console . Write ( " m ^ n ▁ > ▁ n ^ m " ) ; else if ( LHS < RHS ) Console . Write ( " m ^ n ▁ < ▁ n ^ m " ) ; else Console . Write ( " m ^ n ▁ = ▁ n ^ m " ) ; } static public void Main ( ) { ulong m = 987654321 , n = 123456987 ; check ( m , n ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int maxDivisorRange ( int a , int b , int l , int h ) { int g = gcd ( a , b ) ; int res = - 1 ; for ( int i = l ; i * i <= g && i <= h ; i ++ ) if ( g % i == 0 ) res = Math . Max ( res , Math . Max ( i , g / i ) ) ; return res ; } public static void Main ( ) { int a = 3 , b = 27 , l = 1 , h = 5 ; Console . WriteLine ( maxDivisorRange ( a , b , l , h ) ) ; } }
using System ; class GFG { static void checksum ( int n ) { if ( n == 0 ) { Console . Write ( " - 2 ▁ - 1 ▁ 0 ▁ 1 ▁ 2" ) ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( int i = 0 ; i <= n - 4 ; i += inc ) { if ( i + i + 1 + i + 2 + i + 3 + i + 4 == n ) { Console . Write ( ( i ) + " ▁ " + ( i + 1 ) + " ▁ " + ( i + 2 ) + " ▁ " + ( i + 3 ) + " ▁ " + ( i + 4 ) ) ; return ; } } Console . WriteLine ( " - 1" ) ; } public static void Main ( ) { int n = 15 ; checksum ( n ) ; } }
using System ; class GFG { static void checksum ( int n ) { if ( n % 5 == 0 ) Console . WriteLine ( ( n / 5 - 2 ) + " ▁ " + ( n / 5 - 1 ) + " ▁ " + ( n / 5 ) + " ▁ " + ( n / 5 + 1 ) + " ▁ " + ( n / 5 + 2 ) ) ; else Console . WriteLine ( " - 1" ) ; } public static void Main ( ) { int n = 15 ; checksum ( n ) ; } }
using System ; class GFG { static int sumOfSeries ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( sumOfSeries ( n ) ) ; } }
using System ; class GFG { static int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; } public static void Main ( ) { int N = 4 ; Console . WriteLine ( " Number ▁ of ▁ unmarked ▁ " + " elements : ▁ " + countUnmarked ( N ) ) ; } }
using System ; class GFG { static int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int calculateSeries ( int n ) { return factorial ( n + 1 ) - 1 ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( calculateSeries ( n ) ) ; } }
using System ; class GFG { static int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int calculateSeries ( int n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( calculateSeries ( n ) ) ; } }
using System ; class GFG { static int minimumLength ( int x , int y , int z ) { return 1 + Math . Abs ( x - y ) + Math . Abs ( y - z ) ; } public static void Main ( ) { int x = 3 , y = 1 , z = 2 ; Console . WriteLine ( minimumLength ( x , y , z ) ) ; } }
using System ; class GFG { static void endPointOfDiameterofCircle ( int x1 , int y1 , int c1 , int c2 ) { Console . Write ( " x2 ▁ = ▁ " + ( 2 * c1 - x1 ) + " ▁ " ) ; Console . Write ( " y2 ▁ = ▁ " + ( 2 * c2 - y1 ) ) ; } public static void Main ( ) { int x1 = - 4 , y1 = - 1 ; int c1 = 3 , c2 = 5 ; endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) ; } }
using System ; class GFG { static float proterm ( int i , float value , float [ ] x ) { float pro = 1 ; for ( int j = 0 ; j < i ; j ++ ) { pro = pro * ( value - x [ j ] ) ; } return pro ; } static void dividedDiffTable ( float [ ] x , float [ , ] y , int n ) { for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) { y [ j , i ] = ( y [ j , i - 1 ] - y [ j + 1 , i - 1 ] ) / ( x [ j ] - x [ i + j ] ) ; } } } static float applyFormula ( float value , float [ ] x , float [ , ] y , int n ) { float sum = y [ 0 , 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum = sum + ( proterm ( i , value , x ) * y [ 0 , i ] ) ; } return sum ; } static void printDiffTable ( float [ , ] y , int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - i ; j ++ ) { Console . Write ( Math . Round ( y [ i , j ] , 4 ) + " TABSYMBOL ▁ " ) ; } Console . WriteLine ( " " ) ; } } public static void Main ( ) { int n = 4 ; float value ; float [ , ] y = new float [ 10 , 10 ] ; float [ ] x = { 5 , 6 , 9 , 11 } ; y [ 0 , 0 ] = 12 ; y [ 1 , 0 ] = 13 ; y [ 2 , 0 ] = 14 ; y [ 3 , 0 ] = 16 ; dividedDiffTable ( x , y , n ) ; printDiffTable ( y , n ) ; value = 7 ; Console . WriteLine ( " STRNEWLINE Value ▁ at ▁ " + ( value ) + " ▁ is ▁ " + Math . Round ( applyFormula ( value , x , y , n ) , 2 ) ) ; } }
using System ; class GFG { static long centered_heptagonal_num ( long n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; } public static void Main ( ) { long n = 5 ; Console . WriteLine ( n + " th ▁ Centered ▁ " + " heptagonal ▁ number ▁ : ▁ " + centered_heptagonal_num ( n ) ) ; } }
using System ; public class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ; return sum ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; class GFG { static bool checkHankelMatrix ( int n , int [ , ] m ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i , j ] != m [ i + j , 0 ] ) return false ; } else { if ( m [ i , j ] != m [ i + j - n + 1 , n - 1 ] ) return false ; } } } return true ; } public static void Main ( ) { int n = 4 ; int [ , ] m = { { 1 , 2 , 3 , 5 } , { 2 , 3 , 5 , 8 } , { 3 , 5 , 8 , 0 } , { 5 , 8 , 0 , 9 } } ; if ( checkHankelMatrix ( n , m ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static bool isPower ( int n ) { for ( int x = 2 ; x <= ( int ) Math . Sqrt ( n ) ; x ++ ) { float f = ( float ) Math . Log ( n ) / ( float ) Math . Log ( x ) ; if ( ( f - ( int ) f ) == 0.0 ) return true ; } return false ; } public static void Main ( ) { for ( int i = 2 ; i < 100 ; i ++ ) if ( isPower ( i ) ) Console . Write ( i + " ▁ " ) ; } }
using System ; class GFG { static int N = 1000005 ; static void sumOddDigit ( int [ ] digitSum ) { for ( int i = 1 ; i < N ; i ++ ) { digitSum [ i ] = digitSum [ i / 10 ] + ( i & 1 ) * ( i % 10 ) ; } } static void sumFactor ( int [ ] digitSum , int [ ] factorDigitSum ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = i ; j < N ; j += i ) { factorDigitSum [ j ] += digitSum [ i ] ; } } } static void wrapper ( int q , int [ ] n ) { int [ ] digitSum = new int [ N ] ; int [ ] factorDigitSum = new int [ N ] ; sumOddDigit ( digitSum ) ; sumFactor ( digitSum , factorDigitSum ) ; for ( int i = 0 ; i < q ; i ++ ) Console . Write ( factorDigitSum [ n [ i ] ] + " ▁ " ) ; } public static void Main ( ) { int q = 2 ; int [ ] n = new int [ ] { 10 , 36 } ; wrapper ( q , n ) ; } }
using System ; public class GFG { static int number_of_digits ( int n ) { int i ; int res ; int sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; } static public void Main ( ) { int n = 21 ; Console . WriteLine ( number_of_digits ( n ) ) ; } }
using System ; class GFG { static void reverseorder ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int i = n ; i >= 2 ; i -- ) if ( prime [ i ] == true ) Console . Write ( i + " ▁ " ) ; } public static void Main ( ) { int N = 25 ; Console . WriteLine ( " Prime ▁ number ▁ in " + " ▁ reverse ▁ order " ) ; if ( N == 1 ) Console . WriteLine ( " No ▁ prime ▁ no " + " ▁ exist ▁ in ▁ this ▁ range " ) ; else reverseorder ( N ) ; } }
using System ; class GFG { public static int magicOfSequence ( int N ) { int sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; } static public void Main ( ) { int N = 4 ; Console . WriteLine ( magicOfSequence ( N ) ) ; } }
using System ; class GFG { static int countOddFactors ( long n ) { int odd_factors = 0 ; for ( int i = 1 ; 1 * i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( 1 * i * i == n ) { if ( ( i & 1 ) == 1 ) odd_factors ++ ; } else { if ( ( i & 1 ) == 1 ) odd_factors ++ ; int factor = ( int ) n / i ; if ( ( factor & 1 ) == 1 ) odd_factors ++ ; } } } return odd_factors - 1 ; } static void Main ( ) { long N = 15 ; Console . WriteLine ( countOddFactors ( N ) ) ; N = 10 ; Console . WriteLine ( countOddFactors ( N ) ) ; } }
using System ; class GFG { static bool isPossibleToZero ( int [ ] a , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; } static public void Main ( ) { int [ ] arr = { 0 , 1 , 1 , 0 } ; int n = arr . Length ; if ( isPossibleToZero ( arr , n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static double PI = 3.142 ; static double cosXSertiesSum ( double x , int n ) { x = x * ( PI / 180.0 ) ; double res = 1 ; double sign = 1 , fact = 1 , pow = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; } public static void Main ( ) { float x = 50 ; int n = 5 ; Console . Write ( ( float ) ( cosXSertiesSum ( x , n ) * 1000000 ) / 1000000.00 ) ; } }
using System ; class GFG { static int solve ( int n , int base1 ) { int result = 0 ; while ( n > 0 ) { int remainder = n % base1 ; result = result + remainder ; n = n / base1 ; } return result ; } static void printSumsOfDigits ( int n ) { for ( int base1 = 2 ; base1 < n ; ++ base1 ) Console . Write ( solve ( n , base1 ) + " ▁ " ) ; } public static void Main ( ) { int n = 8 ; printSumsOfDigits ( n ) ; } }
using System ; class GFG { static bool check ( int N , int D ) { int temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; } static public void Main ( ) { int N = 5 ; int M = 7 ; if ( check ( N , M ) ) Console . Write ( " yes " ) ; else Console . Write ( " no " ) ; } }
using System ; class GFG { static int perfectSquare ( string s ) { int n = s . Length ; int ans = - 1 ; string num = " " ; for ( int i = 1 ; i < ( 1 << n ) ; i ++ ) { string str = " " ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( ( i >> j ) & 1 ) == 1 ) { str += s [ j ] ; } } if ( str [ 0 ] != '0' ) { int temp = 0 ; for ( int j = 0 ; j < str . Length ; j ++ ) temp = temp * 10 + ( int ) ( str [ j ] - '0' ) ; int k = ( int ) Math . Sqrt ( temp ) ; if ( k * k == temp ) { if ( ans < ( int ) str . Length ) { ans = ( int ) str . Length ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { Console . Write ( num + " ▁ " ) ; return n - ans ; } } public static void Main ( ) { Console . WriteLine ( perfectSquare ( "8314" ) ) ; Console . WriteLine ( perfectSquare ( "753" ) ) ; } }
using System ; class GFG { static void printFourSquares ( int a ) { for ( int i = 0 ; i * i <= a ; i ++ ) { for ( int j = i ; j * j <= a ; j ++ ) { for ( int k = j ; k * k <= a ; k ++ ) { for ( int l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { Console . Write ( a + " ▁ = ▁ " + i + " * " + i + " ▁ + ▁ " + j + " * " + j + " ▁ + ▁ " ) ; Console . Write ( k + " * " + k + " ▁ + ▁ " + l + " * " + l + " STRNEWLINE " ) ; } } } } } } public static void Main ( ) { int a = 74 ; printFourSquares ( a ) ; } }
using System ; class GFG { static int exactPrimeFactorCount ( int n ) { int count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; } public static void Main ( ) { int n = 51242183 ; Console . WriteLine ( " The ▁ number ▁ of " + " ▁ distinct ▁ prime ▁ factors ▁ is / are ▁ " + exactPrimeFactorCount ( n ) ) ; Console . WriteLine ( " The ▁ value ▁ of ▁ " + " log ( log ( n ) ) ▁ is ▁ " + Math . Log ( Math . Log ( n ) ) ) ; } }
using System ; class GFG { static int no_of_digit ( int a , int b ) { return ( ( int ) ( b * Math . Log10 ( a ) ) + 1 ) ; } public static void Main ( ) { int a = 2 , b = 100 ; Console . Write ( " no . ▁ of ▁ digits ▁ = ▁ " + no_of_digit ( a , b ) ) ; } }
using System ; class GFG { static bool checkSemiprime ( int num ) { int cnt = 0 ; for ( int i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num /= i ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; } static bool isEmirpimes ( int n ) { if ( checkSemiprime ( n ) == false ) return false ; int r = 0 ; for ( int t = n ; t != 0 ; t = t / n ) r = r * 10 + t % 10 ; if ( r == n ) return false ; return ( checkSemiprime ( r ) ) ; } public static void Main ( ) { int n = 15 ; if ( isEmirpimes ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class Program { static long factorial ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { res *= i ; } return res ; } static void printNComposite ( int n ) { long fact = factorial ( n + 1 ) ; for ( int i = 2 ; i <= n + 1 ; ++ i ) { Console . Write ( fact + i + " ▁ " ) ; } } public static void Main ( ) { int n = 4 ; printNComposite ( n ) ; } }
using System ; using System . Collections . Generic ; class GFG { static List < long > primes ( long n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } List < long > arr = new List < long > ( ) ; for ( int i = 2 ; i < n ; i ++ ) if ( prime [ i ] ) arr . Add ( i ) ; return arr ; } static int countDigits ( long n ) { long temp = n ; int c = 0 ; while ( temp != 0 ) { temp = temp / 10 ; c ++ ; } return c ; } static bool frugal ( long n ) { List < long > r = primes ( n ) ; long t = n ; long s = 0 ; for ( int i = 0 ; i < r . Count ; i ++ ) { if ( t % r [ i ] == 0 ) { long k = 0 ; while ( t % r [ i ] == 0 ) { t = t / r [ i ] ; k ++ ; } if ( k == 1 ) s = s + countDigits ( r [ i ] ) ; else if ( k != 1 ) s = s + countDigits ( r [ i ] ) + countDigits ( k ) ; } } return ( countDigits ( n ) > s && s != 0 ) ; } static void Main ( ) { long n = 343 ; if ( frugal ( n ) ) Console . Write ( " A ▁ Frugal ▁ number STRNEWLINE " ) ; else Console . Write ( " Not ▁ a ▁ frugal ▁ number STRNEWLINE " ) ; } }
using System ; class GFG { static int nthSquareCube ( int n ) { return n * n * n * n * n * n ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( nthSquareCube ( n ) ) ; } }
using System ; class GFG { public static int findS ( int s ) { int sum = 0 ; for ( int n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; } static public void Main ( string [ ] args ) { int s = 9 ; int n = findS ( s ) ; if ( n == - 1 ) Console . WriteLine ( " - 1" ) ; else Console . WriteLine ( n ) ; } }
using System ; class GFG { public static int findKthGoodNo ( int n ) { int lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; } static public void Main ( string [ ] args ) { int n = 10 ; Console . WriteLine ( findKthGoodNo ( n ) ) ; } }
using System ; class GFG { static void NicomachuTheorum_sum ( int n ) { int sum = 0 ; for ( int k = 1 ; k <= n ; k ++ ) sum += k * k * k ; int triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } public static void Main ( ) { int n = 5 ; NicomachuTheorum_sum ( n ) ; } }
using System ; public class GFG { static int checkDigits ( int n ) { while ( n > 0 ) { if ( ( ( n % 10 ) % 2 ) > 0 ) return 0 ; n /= 10 ; } return 1 ; } static int largestNumber ( int n ) { for ( int i = n ; ; i -- ) if ( checkDigits ( i ) > 0 ) return i ; } static public void Main ( ) { int N = 23 ; Console . WriteLine ( largestNumber ( N ) ) ; } }
using System ; class GFG { static int largestNumber ( int n ) { string s = " " ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( ( ( int ) ( s [ i ] - '0' ) % 2 ) & 1 ) > 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( int ) ( s [ i ] - '0' ) ; num = num * 10 + ( ( int ) s [ index ] - ( int ) ( '0' ) - 1 ) ; for ( int i = index + 1 ; i < s . Length ; i ++ ) num = num * 10 + 8 ; return num ; } static void Main ( ) { int N = 24578 ; Console . WriteLine ( largestNumber ( N ) ) ; } }
using System ; class GFG { static int countDigits ( int n ) { return ( int ) ( n * Math . Log10 ( 2 ) + 1 ) ; } static void Main ( ) { int n = 5 ; Console . Write ( countDigits ( n ) ) ; } }
using System ; class GFG { static int check_digits ( int n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 != 0 ) return 0 ; n /= 10 ; } return 1 ; } static int smallest_number ( int n ) { for ( int i = n ; ; i ++ ) if ( check_digits ( i ) != 0 ) return i ; } public static void Main ( ) { int N = 2397 ; Console . WriteLine ( smallest_number ( N ) ) ; } }
using System ; class GFG { static int findBucketNo ( int p ) { return ( int ) Math . Ceiling ( ( Math . Sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; } static public void Main ( ) { int p = 10 ; Console . WriteLine ( findBucketNo ( p ) ) ; } }
using System ; class GFG { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } static int LCMOfNeighbourFact ( int n ) { return factorial ( n + 1 ) ; } public static void Main ( ) { int N = 5 ; Console . WriteLine ( LCMOfNeighbourFact ( N ) ) ; } }
using System ; class GFG { static int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static bool checkFriendly ( int n , int m ) { int sumFactors_n = sumofFactors ( n ) ; int sumFactors_m = sumofFactors ( m ) ; int gcd_n = gcd ( n , sumFactors_n ) ; int gcd_m = gcd ( m , sumFactors_m ) ; if ( n / gcd_n == m / gcd_m && sumFactors_n / gcd_n == sumFactors_m / gcd_m ) return true ; else return false ; } public static void Main ( String [ ] args ) { int n = 6 , m = 28 ; if ( checkFriendly ( n , m ) ) Console . Write ( " Yes STRNEWLINE " ) ; else Console . Write ( " No STRNEWLINE " ) ; } }
using System ; class GFG { public static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } public static int primorial ( int n ) { int p = 2 ; n -- ; for ( int i = 3 ; n != 0 ; i ++ ) { if ( isPrime ( i ) == true ) { p = p * i ; n -- ; } i ++ ; } return p ; } public static int findNextPrime ( int n ) { int nextPrime = n + 2 ; while ( true ) { if ( isPrime ( nextPrime ) == true ) break ; nextPrime ++ ; } return nextPrime ; } public static int fortunateNumber ( int n ) { int p = primorial ( n ) ; return findNextPrime ( p ) - p ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( fortunateNumber ( n ) ) ; } }
using System ; class GFG { static double procal ( int n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 3 , 4 , 5 } ; int n = a . Length ; Console . Write ( Math . Round ( procal ( n ) * 1000000.0 ) / 1000000.0 ) ; } }
using System ; class GFG { static void testSomeNumbers ( int limit , int n ) { if ( n < 3 ) return ; for ( int a = 1 ; a <= limit ; a ++ ) for ( int b = a ; b <= limit ; b ++ ) { int pow_sum = ( int ) ( Math . Pow ( a , n ) + Math . Pow ( b , n ) ) ; double c = Math . Pow ( pow_sum , 1.0 / n ) ; int c_pow = ( int ) Math . Pow ( ( int ) c , n ) ; if ( c_pow == pow_sum ) { Console . WriteLine ( " Count ▁ example ▁ found " ) ; return ; } } Console . WriteLine ( " No ▁ counter ▁ example ▁ within " + " ▁ given ▁ range ▁ and ▁ data " ) ; } public static void Main ( ) { testSomeNumbers ( 12 , 3 ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void productReduce ( int n , int [ ] num , int [ ] den ) { int new_num = 1 , new_den = 1 ; for ( int i = 0 ; i < n ; i ++ ) { new_num *= num [ i ] ; new_den *= den [ i ] ; } int GCD = gcd ( new_num , new_den ) ; new_num /= GCD ; new_den /= GCD ; Console . WriteLine ( new_num + " / " + new_den ) ; } public static void Main ( ) { int n = 3 ; int [ ] num = { 1 , 2 , 5 } ; int [ ] den = { 2 , 1 , 6 } ; productReduce ( n , num , den ) ; } }
using System ; class GFG { static int fnMod ( int n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( fnMod ( n ) ) ; n = 11 ; Console . WriteLine ( fnMod ( n ) ) ; } }
using System ; public class GFG { static int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } static int repeatedNumberSum ( int n , int x ) { int sum = x * digSum ( n ) ; return digSum ( sum ) ; } public static void Main ( ) { int n = 24 , x = 3 ; Console . Write ( repeatedNumberSum ( n , x ) ) ; } }
using System ; class GFG { static int totalSumDivisibleByNum ( int n , int number ) { int firstnum = ( int ) Math . Pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , n ) ; int sum = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; } public static void Main ( ) { int n = 3 , num = 7 ; Console . WriteLine ( totalSumDivisibleByNum ( n , num ) ) ; } }
using System ; class GFG { static int numberofterm ( int n , int number ) { int firstnum = ( int ) Math . Pow ( 10 , n - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , n ) ; int count = 0 ; for ( int i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; } public static void Main ( ) { int n = 3 , num = 7 ; Console . Write ( numberofterm ( n , num ) ) ; } }
using System ; class GFG { static void georgeCantor ( int n ) { int i = 1 ; int j = 1 ; int k = 1 ; while ( k < n ) { j ++ ; k ++ ; if ( k == n ) break ; while ( j > 1 && k < n ) { i ++ ; j -- ; k ++ ; } if ( k == n ) break ; i ++ ; k ++ ; if ( k == n ) break ; while ( i > 1 && k < n ) { i -- ; j ++ ; k ++ ; } } Console . WriteLine ( " N - th ▁ term ▁ : ▁ " + i + " / " + j ) ; } public static void Main ( ) { int n = 15 ; georgeCantor ( n ) ; } }
using System ; class GFG { static bool isDivisible ( long n ) { while ( n / 100 > 0 ) { int last_digit = ( int ) n % 10 ; n /= 10 ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; } public static void Main ( ) { long n = 348 ; if ( isDivisible ( n ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static string solveEquation ( string equation ) { int n = equation . Length , sign = 1 , coeff = 0 ; int total = 0 , i = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( equation [ j ] == ' + ' equation [ j ] == ' - ' ) { if ( j > i ) total += sign * Int32 . Parse ( equation . Substring ( i , j - i ) ) ; i = j ; } else if ( equation [ j ] == ' x ' ) { if ( ( i == j ) equation [ j - 1 ] == ' + ' ) coeff += sign ; else if ( equation [ j - 1 ] == ' - ' ) coeff -= sign ; else coeff += sign * Int32 . Parse ( equation . Substring ( i , j - i ) ) ; i = j + 1 ; } else if ( equation [ j ] == ' = ' ) { if ( j > i ) total += sign * Int32 . Parse ( equation . Substring ( i , j - i ) ) ; sign = - 1 ; i = j + 1 ; } } if ( i < n ) total += sign * Int32 . Parse ( equation . Substring ( i ) ) ; if ( coeff == 0 && total == 0 ) return " Infinite ▁ solutions " ; if ( coeff == 0 && total != 0 ) return " No ▁ solution " ; int ans = - total / coeff ; return " x ▁ = ▁ " + ans . ToString ( ) ; } static void Main ( ) { string equation = " x + 5-3 + x = 6 + x - 2" ; Console . Write ( solveEquation ( equation ) ) ; } }
using System ; class GFG { static bool pronic_check ( int n ) { int x = ( int ) ( Math . Sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; } public static void Main ( ) { int n = 56 ; if ( pronic_check ( n ) == true ) Console . Write ( " YES " ) ; else Console . Write ( " NO " ) ; } }
using System ; class GFG { static int MAX = 100000 ; static int multiply ( int x , int [ ] res , int res_size ) { int carry = 0 ; for ( int i = 0 ; i < res_size ; i ++ ) { int prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry > 0 ) { res [ res_size ] = carry % 10 ; carry = carry / 10 ; res_size ++ ; } return res_size ; } static void power ( int x , int n ) { if ( n == 0 ) { Console . Write ( "1" ) ; return ; } int [ ] res = new int [ MAX ] ; int res_size = 0 ; int temp = x ; while ( temp != 0 ) { res [ res_size ++ ] = temp % 10 ; temp = temp / 10 ; } for ( int i = 2 ; i <= n ; i ++ ) res_size = multiply ( x , res , res_size ) ; Console . Write ( x + " ^ " + n + " ▁ = ▁ " ) ; for ( int i = res_size - 1 ; i >= 0 ; i -- ) Console . Write ( res [ i ] ) ; } public static void Main ( ) { int exponent = 100 ; int b_ase = 2 ; power ( b_ase , exponent ) ; } }
using System ; class GFG { static bool check ( int n , int p ) { int maximum = - 1 ; while ( ( n % 2 ) == 0 ) { maximum = Math . Max ( maximum , 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { maximum = Math . Max ( maximum , i ) ; n = n / i ; } } if ( n > 2 ) maximum = Math . Max ( maximum , n ) ; return ( maximum <= p ) ; } public static void Main ( ) { int n = 24 , p = 7 ; if ( check ( n , p ) ) Console . Write ( " yes " ) ; else Console . Write ( " no " ) ; } }
using System ; class GFG { static void find_time ( int h1 ) { int theta = 30 * h1 ; Console . WriteLine ( " ( " + theta * 2 + " / " + " ▁ 11 ▁ ) minutes " ) ; } public static void Main ( ) { int h1 = 3 ; find_time ( h1 ) ; } }
using System ; class GFG { static int sum_series ( int n ) { int nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; } public static void Main ( ) { int n = 2 ; Console . Write ( sum_series ( n ) ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { if ( n == 0 n == 1 ) return false ; int root = ( int ) Math . Sqrt ( n ) ; for ( int i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static bool isSandwitched ( int n ) { return ( isPrime ( n - 1 ) && isPrime ( n + 1 ) ) ; } public static void Main ( ) { int n = 642 ; Console . Write ( n + " ▁ : ▁ " ) ; if ( isSandwitched ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . Write ( " No " ) ; n = 9 ; Console . Write ( n + " ▁ : ▁ " ) ; if ( isSandwitched ( n ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { public static int day_of_the_week ( int y , int m , int d ) { int [ ] t = { 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 } ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; } public static void Main ( ) { int day = 13 , month = 7 , year = 2017 ; Console . WriteLine ( day_of_the_week ( year , month , day ) ) ; } }
using System ; class GFG { static bool isPrime ( int n , int i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; } static void Main ( ) { int n = 15 ; if ( isPrime ( n , 2 ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static bool isSquareFree ( int n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; } public static void Main ( ) { int n = 10 ; if ( isSquareFree ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static double findArea ( double d ) { return ( d * d ) / 2 ; } public static void Main ( ) { double d = 10 ; Console . WriteLine ( findArea ( d ) ) ; } }
using System ; class GFG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; } public static void Main ( ) { int n = 10 ; Console . Write ( sumOfSeries ( n ) ) ; } }
using System ; class GFG { static int sumOfSeries ( int n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; } public static void Main ( ) { int n = 10 ; Console . Write ( sumOfSeries ( n ) ) ; } }
using System ; class GFG { static float mean ( float [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; } static float SSD ( float [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; return ( float ) Math . Sqrt ( sum / ( n - 1 ) ) ; } static float sampleError ( float [ ] arr , int n ) { return SSD ( arr , n ) / ( float ) Math . Sqrt ( n ) ; } public static void Main ( ) { float [ ] arr = { 78.53f , 79.62f , 80.25f , 81.05f , 83.21f , 83.46f } ; int n = arr . Length ; Console . Write ( sampleError ( arr , n ) ) ; } }
using System ; class GFG { static int StepstoReachTarget ( int target ) { target = Math . Abs ( target ) ; int n = ( int ) Math . Ceiling ( ( - 1.0 + ( int ) Math . Sqrt ( 1 + 8.0 * target ) ) / 2 ) ; int sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; int d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; } public static void Main ( ) { int target = 5 ; Console . Write ( StepstoReachTarget ( target ) ) ; } }
using System ; class GFG { static double seriesSum ( int n ) { int i = 1 ; double res = 0.0 ; bool sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ( double ) ++ i / ++ i ; } else { sign = ! sign ; res = res - ( double ) ++ i / ++ i ; } } return res ; } public static void Main ( ) { int n = 5 ; Console . Write ( seriesSum ( n ) ) ; } }
using System ; class GFG { static int countSymmetric ( int n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( countSymmetric ( n ) ) ; } }
using System ; class GFG { static int centeredNonagonal ( int n ) { return ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ; } public static void Main ( ) { int n = 10 ; Console . Write ( centeredNonagonal ( n ) ) ; } }
using System ; class GFG { static float Mean ( float [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; } static float meanAbsDevtion ( float [ ] arr , int n ) { float absSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) absSum = absSum + Math . Abs ( arr [ i ] - Mean ( arr , n ) ) ; return absSum / n ; } public static void Main ( ) { float [ ] arr = { 10 , 15 , 15 , 17 , 18 , 21 } ; int n = arr . Length ; Console . WriteLine ( meanAbsDevtion ( arr , n ) ) ; } }
using System ; class Ratio { static bool isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; } public static void Main ( ) { int lowCost = 14 , upCost = 30 , lowQuant = 5 , upQuant = 12 , r = 9 ; if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static void findNumbers ( int n , int d ) { for ( int i = 0 ; i < n - 2 ; i ++ ) Console . Write ( "1" + " ▁ " ) ; Console . Write ( "2" + " ▁ " ) ; Console . Write ( n + d ) ; } public static void Main ( ) { int N = 3 , D = 5 ; findNumbers ( N , D ) ; } }
using System ; class GFG { static long oddNumSum ( int n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; } public static void Main ( ) { int n = 4 ; Console . Write ( oddNumSum ( n ) ) ; } }
using System ; class GFG { static int trailingZero ( int x ) { int i = 5 , count = 0 ; while ( x > i ) { count = count + x / i ; i = i * 5 ; } return count ; } static int countProductTrailing ( int M , int N ) { return trailingZero ( N ) + trailingZero ( M ) ; } public static void Main ( ) { int N = 67 , M = 98 ; Console . WriteLine ( countProductTrailing ( N , M ) ) ; } }
using System ; class GFG { static bool isTrimorphic ( int N ) { int cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N /= 10 ; cube /= 10 ; } return true ; } public static void Main ( ) { int N = 24 ; if ( isTrimorphic ( N ) == true ) Console . Write ( " trimorphic " ) ; else Console . Write ( " not ▁ trimorphic " ) ; } }
using System ; class GFG { static int INT_MAX = 2147483647 ; static bool checkTrimorphic ( int num ) { int cube = num * num * num ; while ( num > 0 ) { if ( num % 10 != cube % 10 ) return false ; num /= 10 ; cube /= 10 ; } return true ; } static int nthTrimorphic ( int n ) { int count = 0 ; for ( int i = 0 ; i < INT_MAX ; i ++ ) { if ( checkTrimorphic ( i ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; } static int Main ( ) { int n = 9 ; Console . Write ( nthTrimorphic ( n ) ) ; return 0 ; } }
using System ; class GFG { static int reachTarget ( int target ) { target = Math . Abs ( target ) ; int sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; } public static void Main ( ) { int target = 5 ; Console . WriteLine ( reachTarget ( target ) ) ; } }
using System ; class GFG { static long fifthPowerSum ( int n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; } public static void Main ( ) { int n = 5 ; Console . Write ( fifthPowerSum ( n ) ) ; } }
using System ; class GFG { static int unitDigitXRaisedY ( int x , int y ) { int res = 1 ; for ( int i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; } public static void Main ( ) { Console . WriteLine ( unitDigitXRaisedY ( 4 , 2 ) ) ; } }
using System ; class GFG { static int findDivisor ( int x , int y ) { if ( x == y ) return y ; return 2 ; } public static void Main ( ) { int x = 3 , y = 16 ; Console . Write ( findDivisor ( x , y ) ) ; } }
using System ; public class GFG { static float AvgofSquareN ( int n ) { float sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } static public void Main ( String [ ] args ) { int n = 2 ; Console . WriteLine ( AvgofSquareN ( n ) ) ; } }
using System ; public class GfG { public static int sumofFactors ( int n ) { if ( n % 2 != 0 ) return 0 ; int res = 1 ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } public static void Main ( ) { int n = 18 ; Console . WriteLine ( sumofFactors ( n ) ) ; } }
using System ; class GfG { public static float focal_length_concave ( float R ) { return R / 2 ; } public static float focal_length_convex ( float R ) { return - ( R / 2 ) ; } public static void Main ( String [ ] argc ) { float R = 30 ; Console . Write ( " Focal ▁ length ▁ of " + " spherical ▁ concave " + " mirror ▁ is ▁ : ▁ " + focal_length_concave ( R ) + " ▁ units STRNEWLINE " ) ; Console . Write ( " Focal ▁ length ▁ of " + " spherical ▁ convex " + " mirror ▁ is ▁ : ▁ " + focal_length_convex ( R ) + " ▁ units " ) ; } }
using System ; class GFG { static int sumofoddFactors ( int n ) { int res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } public static void Main ( String [ ] argc ) { int n = 30 ; Console . Write ( sumofoddFactors ( n ) ) ; } }
using System ; class GFG { static int countSolutions ( int n , int val ) { int total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( int i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; } public static void Main ( ) { int n = 5 ; int val = 20 ; Console . WriteLine ( countSolutions ( n , val ) ) ; } }
using System ; class GFG { static int N = 6 ; static void fib ( int [ ] f , int n ) { int i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( i = 2 ; i <= n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } static void fibcoef ( int [ , ] fc , int [ ] f , int n ) { for ( int i = 0 ; i <= n ; i ++ ) fc [ i , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { int k = j ; while ( k > 0 ) { k -- ; fc [ i , j ] *= f [ k ] ; } k = 1 ; while ( ( j + 1 ) != k ) fc [ i , j ] /= f [ k ++ ] ; } } } static void printFibonomialTriangle ( int n ) { int [ ] f = new int [ N + 1 ] ; fib ( f , n ) ; int [ , ] dp = new int [ N + 1 , N + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = dp [ i , i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) dp [ i , j ] = f [ i - j + 1 ] * dp [ i - 1 , j - 1 ] + f [ j - 1 ] * dp [ i - 1 , j ] ; } for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) Console . Write ( dp [ i , j ] + " ▁ " ) ; Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 6 ; printFibonomialTriangle ( n ) ; } }
using System ; class GFG { static int sumofNterm ( int a , int d , int b , int r , int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( int ) ( ( a + ( i - 1 ) * d ) * ( b * Math . Pow ( r , i - 1 ) ) ) ; return sum ; } public static void Main ( ) { int a = 1 , d = 1 , b = 2 , r = 2 , n = 3 ; Console . Write ( sumofNterm ( a , d , b , r , n ) ) ; } }
using System ; class GFG { static int sumOfTheSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int k = 2 ; for ( int j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; } public static void Main ( ) { int n = 5 ; Console . Write ( " Sum ▁ = ▁ " + sumOfTheSeries ( n ) ) ; } }
using System ; public class GfG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( sumOfSeries ( n ) ) ; } }
using System ; class GFG { static double Series ( double x , int n ) { double sum = 1 , term = 1 , fct , j , y = 2 , m ; int i ; for ( i = 1 ; i < n ; i ++ ) { fct = 1 ; for ( j = 1 ; j <= y ; j ++ ) { fct = fct * j ; } term = term * ( - 1 ) ; m = Math . Pow ( x , y ) / fct ; m = m * term ; sum = sum + m ; y += 2 ; } return sum ; } public static void Main ( ) { double x = 9 ; int n = 10 ; Console . Write ( Series ( x , n ) * 10000.0 / 10000.0 ) ; } }
using System ; class GFG { static float Series ( double x , int n ) { double sum = 1 , term = 1 , fct = 1 ; double p = 1 , multi = 1 ; for ( int i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return ( float ) sum ; } public static void Main ( ) { double x = 9 ; int n = 10 ; Console . Write ( Series ( x , n ) ) ; } }
using System ; public class GfG { static int two_factor ( int n ) { int twocount = 0 ; while ( n % 2 == 0 ) { twocount ++ ; n = n / 2 ; } return twocount ; } static int five_factor ( int n ) { int fivecount = 0 ; while ( n % 5 == 0 ) { fivecount ++ ; n = n / 5 ; } return fivecount ; } static int find_con_zero ( int [ ] arr , int n ) { int twocount = 0 ; int fivecount = 0 ; for ( int i = 0 ; i < n ; i ++ ) { twocount += two_factor ( arr [ i ] ) ; fivecount += five_factor ( arr [ i ] ) ; } if ( twocount < fivecount ) return twocount ; else return fivecount ; } public static void Main ( ) { int [ ] arr = { 100 , 10 , 5 , 25 , 35 , 14 } ; int n = 6 ; Console . WriteLine ( find_con_zero ( arr , n ) ) ; } }
using System ; public class GfG { public static int first ( int a , int b , int c ) { a %= b ; for ( int i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; } public static void Main ( ) { int a = 1 , b = 4 , c = 5 ; Console . WriteLine ( first ( a , b , c ) ) ; } }
using System ; class GFG { static void subsetDifference ( int n ) { int s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { Console . WriteLine ( " First ▁ " + " subset ▁ sum ▁ = ▁ " + s / 2 ) ; Console . WriteLine ( " Second ▁ " + " subset ▁ sum ▁ = ▁ " + s / 2 ) ; Console . WriteLine ( " Difference " + " ▁ = ▁ " + 0 ) ; } else { if ( n % 4 == 1 n % 4 == 2 ) { Console . WriteLine ( " First ▁ " + " subset ▁ sum ▁ = ▁ " + s / 2 ) ; Console . WriteLine ( " Second ▁ " + " subset ▁ sum ▁ = ▁ " + ( ( s / 2 ) + 1 ) ) ; Console . WriteLine ( " Difference " + " ▁ = ▁ " + 1 ) ; } else { Console . WriteLine ( " First ▁ " + " subset ▁ sum ▁ = ▁ " + s / 2 ) ; Console . WriteLine ( " Second ▁ " + " subset ▁ sum ▁ = ▁ " + s / 2 ) ; Console . WriteLine ( " Difference " + " ▁ = ▁ " + 0 ) ; } } } public static void Main ( ) { int n = 6 ; subsetDifference ( n ) ; } }
using System ; public class GFG { static void timeToMeet ( double s , double v ) { double V = 3 * v / 2 ; double time = s / V ; Console . WriteLine ( ( float ) time ) ; } static public void Main ( ) { double s = 25 , v = 56 ; timeToMeet ( s , v ) ; } }
using System ; class GFG { static void checksum ( int n ) { if ( n == 0 ) { Console . WriteLine ( " - 1 ▁ 0 ▁ 1" ) ; return ; } int inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( int i = 0 ; i <= n - 2 ; i += inc ) { if ( i + i + 1 + i + 2 == n ) { Console . WriteLine ( i + " ▁ " + ( i + 1 ) + " ▁ " + ( i + 2 ) ) ; return ; } } Console . WriteLine ( " - 1" ) ; } public static void Main ( ) { int n = 6 ; checksum ( n ) ; } }
using System ; class GFG { static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( divisorSum ( n ) ) ; n = 5 ; Console . WriteLine ( divisorSum ( n ) ) ; } }
using System ; public class GFG { static void printbinomial ( int max ) { for ( int m = 0 ; m <= max ; m ++ ) { Console . Write ( m + " ▁ " ) ; int binom = 1 ; for ( int x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; Console . Write ( binom + " ▁ " ) ; } Console . WriteLine ( ) ; } } static public void Main ( ) { int max = 10 ; printbinomial ( max ) ; } }
using System ; class GFG { static long maxPrimeFactors ( long n ) { long maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n >>= 1 ; } while ( n % 3 == 0 ) { maxPrime = 3 ; n = n / 3 ; } for ( int i = 5 ; i <= Math . Sqrt ( n ) ; i += 6 ) { while ( n % i == 0 ) { maxPrime = i ; n = n / i ; } while ( n % ( i + 2 ) == 0 ) { maxPrime = i + 2 ; n = n / ( i + 2 ) ; } } if ( n > 4 ) maxPrime = n ; return maxPrime ; } public static void Main ( ) { long n = 15L ; Console . WriteLine ( maxPrimeFactors ( n ) ) ; n = 25698751364526L ; Console . WriteLine ( maxPrimeFactors ( n ) ) ; } }
using System ; class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static int countUnsetBitsInGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( r - l + 1 ) - countSetBits ( n & num ) ; } public static void Main ( ) { int n = 80 ; int l = 1 , r = 4 ; Console . Write ( countUnsetBitsInGivenRange ( n , l , r ) ) ; } }
using System ; class GFG { static long evenPowerSum ( int n ) { long sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; } public static void Main ( ) { int n = 5 ; Console . Write ( evenPowerSum ( n ) ) ; } }
using System ; class GFG { static long evenPowerSum ( int n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; } public static void Main ( ) { int n = 4 ; Console . Write ( evenPowerSum ( n ) ) ; } }
using System ; using System . Collections . Generic ; public class GFG { static int MAX = 501 ; public static int balancedprime ( int n ) { bool [ ] prime = new bool [ MAX + 1 ] ; for ( int k = 0 ; k < MAX + 1 ; k ++ ) prime [ k ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } List < int > v = new List < int > ( ) ; for ( int p = 3 ; p <= MAX ; p += 2 ) if ( prime [ p ] ) v . Add ( p ) ; int c = 0 ; for ( int i = 1 ; i < v . Count - 1 ; i ++ ) { if ( ( int ) v [ i ] == ( int ) ( v [ i + 1 ] + v [ i - 1 ] ) / 2 ) c ++ ; if ( c == n ) return ( int ) v [ i ] ; } return 1 ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( balancedprime ( n ) ) ; } }
using System ; class GfG { private static int MAX = 1000001 ; private static int [ ] factor = new int [ MAX ] ; public static void generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } public static int calculateNoOFactors ( int n ) { if ( n == 1 ) return 1 ; int ans = 1 ; int dup = factor [ n ] ; int c = 1 ; int j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; } public static int smallest ( int n ) { for ( int i = 1 ; ; i ++ ) if ( calculateNoOFactors ( i ) >= n ) return i ; } public static void Main ( ) { generatePrimeFactors ( ) ; int n = 4 ; Console . Write ( smallest ( n ) ) ; } }
using System ; class GFG { static int squaresum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( squaresum ( n ) ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; } static int minimumSum ( int n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; } public static void Main ( ) { int n = 27 ; Console . WriteLine ( minimumSum ( n ) ) ; } }
using System ; public class GfG { public static int firstDigit ( int n ) { while ( n >= 10 ) n /= 10 ; return n ; } public static int lastDigit ( int n ) { return ( n % 10 ) ; } public static void Main ( ) { int n = 98562 ; Console . WriteLine ( firstDigit ( n ) + " ▁ " + lastDigit ( n ) ) ; } }
using System ; class GFG { static int firstDigit ( int n ) { int digits = ( int ) ( Math . Log10 ( n ) ) ; n = ( int ) ( n / ( int ) ( Math . Pow ( 10 , digits ) ) ) ; return n ; } static int lastDigit ( int n ) { return ( n % 10 ) ; } public static void Main ( ) { int n = 98562 ; Console . WriteLine ( firstDigit ( n ) + " ▁ " + lastDigit ( n ) ) ; } }
using System ; class GFG { public static bool isPrime ( int x ) { if ( x == 0 x == 1 ) return false ; for ( int i = 2 ; i * i <= x ; ++ i ) if ( x % i == 0 ) return false ; return true ; } public static void findPrimes ( int n ) { Console . WriteLine ( n ) ; Console . Write ( 2 + " ▁ " + ( n - 2 ) ) ; { Console . Write ( 3 + " ▁ " ) ; n = n - 3 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime ( i ) && isPrime ( n - i ) ) { Console . WriteLine ( i + " ▁ " + ( n - i ) ) ; break ; } } } } public static void Main ( ) { int n = 27 ; findPrimes ( n ) ; } }
using System ; class GFG { static long [ ] c = new long [ 100 ] ; static void coef ( int n ) { c [ 0 ] = 1 ; for ( int i = 0 ; i < n ; c [ 0 ] = - c [ 0 ] , i ++ ) { c [ 1 + i ] = 1 ; for ( int j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; } } static bool isPrime ( int n ) { coef ( n ) ; c [ 0 ] ++ ; c [ n ] -- ; int i = n ; while ( ( i -- ) > 0 && c [ i ] % n == 0 ) ; return i < 0 ; } public static void Main ( ) { int n = 37 ; if ( isPrime ( n ) ) Console . WriteLine ( " Prime " ) ; else Console . WriteLine ( " Not ▁ Prime " ) ; } }
using System ; class GFG { public static int motzkin ( int n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; } public static void Main ( ) { int n = 8 ; Console . WriteLine ( motzkin ( n ) ) ; } }
using System ; class GFG { static double sumOfSeries ( int n ) { return ( 0.666 ) * ( 1 - 1 / Math . Pow ( 10 , n ) ) ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( sumOfSeries ( n ) ) ; } }
using System ; class narcissistic { int countDigit ( int n ) { if ( n == 0 ) return 0 ; return 1 + countDigit ( n / 10 ) ; } bool check ( int n ) { int l = countDigit ( n ) ; int dup = n ; int sum = 0 ; while ( dup > 0 ) { sum += ( int ) Math . Pow ( dup % 10 , l ) ; dup /= 10 ; } return ( n == sum ) ; } public static void Main ( ) { narcissistic obj = new narcissistic ( ) ; int n = 1634 ; if ( obj . check ( n ) ) Console . WriteLine ( " yes " ) ; else Console . WriteLine ( " no " ) ; } }
using System ; class GFG { public static int summation ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( summation ( n ) ) ; } }
using System ; using System . Collections ; class GFG { public static void leyland ( int n ) { ArrayList ans = new ArrayList ( ) ; for ( int x = 2 ; x <= n ; x ++ ) { for ( int y = 2 ; y <= x ; y ++ ) { int temp = ( int ) Math . Pow ( x , y ) + ( int ) Math . Pow ( y , x ) ; ans . Add ( temp ) ; } } ans . Sort ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + " ▁ " ) ; } } public static void Main ( ) { int n = 6 ; leyland ( n ) ; } }
using System ; class GFG { public static int kthgroupsum ( int k ) { int cur = ( k * ( k - 1 ) ) + 1 ; int sum = 0 ; while ( k -- > 0 ) { sum += cur ; cur += 2 ; } return sum ; } public static void Main ( ) { int k = 3 ; Console . WriteLine ( kthgroupsum ( k ) ) ; } }
using System ; class GFG { public static int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( nthTerm ( n ) ) ; } }
using System ; class GFG { static int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( seriesSum ( n ) ) ; } }
using System ; class GFG { static double cal_speed ( double dist , double time ) { Console . WriteLine ( " ▁ Distance ( km ) ▁ : ▁ " + dist ) ; Console . WriteLine ( " ▁ Time ( hr ) ▁ : ▁ " + time ) ; return dist / time ; } static double cal_dis ( double speed , double time ) { Console . WriteLine ( " ▁ Time ( hr ) ▁ : ▁ " + time ) ; Console . WriteLine ( " ▁ Speed ( km ▁ / ▁ hr ) ▁ : ▁ " + speed ) ; return speed * time ; } static double cal_time ( double dist , double speed ) { Console . WriteLine ( " ▁ Distance ( km ) ▁ : ▁ " + dist ) ; Console . WriteLine ( " ▁ Speed ( km ▁ / ▁ hr ) ▁ : ▁ " + speed ) ; return speed * dist ; } public static void Main ( ) { Console . WriteLine ( " ▁ The ▁ calculated ▁ Speed ( km ▁ / ▁ hr ) ▁ is ▁ : ▁ " + cal_speed ( 45.9 , 2.0 ) ) ; Console . WriteLine ( " ▁ The ▁ calculated ▁ Distance ( km ) ▁ : ▁ " + cal_dis ( 62.9 , 2.5 ) ) ; Console . WriteLine ( " ▁ The ▁ calculated ▁ Time ( hr ) ▁ : ▁ " + cal_time ( 48.0 , 4.5 ) ) ; } }
using System ; class GFG { static int term ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( term ( n ) ) ; } }
using System ; class GFG { static float avgOfFirstN ( int n ) { return ( float ) ( 1 + n ) / 2 ; } public static void Main ( ) { int n = 20 ; Console . WriteLine ( avgOfFirstN ( n ) ) ; } }
using System ; class GFG { static int summation ( int n ) { int sum ; sum = ( int ) ( Math . Pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( summation ( n ) ) ; } }
using System ; class GFG { static float sum ( int x , int n ) { double i , total = 1.0 , multi = x ; for ( i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return ( float ) total ; } public static void Main ( ) { int x = 2 ; int n = 5 ; Console . WriteLine ( sum ( x , n ) ) ; } }
using System ; class Series { static int term ( int n ) { int x = ( ( ( 1 ) + ( int ) Math . Sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( term ( n ) ) ; } }
using System ; class Deserium { static int countDigits ( int n ) { int c = 0 ; do { c ++ ; n = n / 10 ; } while ( n != 0 ) ; return c ; } static bool isDeserium ( int x ) { int temp = x ; int p = countDigits ( x ) ; int sum = 0 ; while ( x != 0 ) { int digit = x % 10 ; sum += ( int ) Math . Pow ( digit , p ) ; p -- ; x = x / 10 ; } return ( sum == temp ) ; } public static void Main ( ) { int x = 135 ; if ( isDeserium ( x ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int sameRemainder ( int a , int b , int c ) { int a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; } public static void Main ( ) { int a = 62 , b = 132 , c = 237 ; Console . WriteLine ( sameRemainder ( a , b , c ) ) ; } }
using System ; class GFG { static float mean ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; float mean = ( float ) sum / n ; return mean ; } static float sd ( int [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; float sdd = sum / n ; return sdd ; } static float combinedVariance ( int [ ] arr1 , int [ ] arr2 , int n , int m ) { float mean1 = mean ( arr1 , n ) ; float mean2 = mean ( arr2 , m ) ; Console . Write ( " Mean1 : ▁ " + mean1 + " ▁ " ) ; Console . WriteLine ( " Mean2 : ▁ " + mean2 ) ; float sd1 = sd ( arr1 , n ) ; float sd2 = sd ( arr2 , m ) ; Console . Write ( " StandardDeviation1 : ▁ " + sd1 + " ▁ " ) ; Console . WriteLine ( " StandardDeviation2 : ▁ " + sd2 + " ▁ " ) ; float combinedMean = ( float ) ( n * mean1 + m * mean2 ) / ( n + m ) ; Console . WriteLine ( " Combined ▁ Mean : ▁ " + combinedMean + " ▁ " ) ; float d1_square = ( mean1 - combinedMean ) * ( mean1 - combinedMean ) ; float d2_square = ( mean2 - combinedMean ) * ( mean2 - combinedMean ) ; Console . Write ( " d1 ▁ square : ▁ " + d1_square + " ▁ " ) ; Console . WriteLine ( " d2 _ square : ▁ " + d2_square ) ; float combinedVar = ( n * ( sd1 + d1_square ) + m * ( sd2 + d2_square ) ) / ( n + m ) ; return combinedVar ; } public static void Main ( ) { int [ ] arr1 = { 23 , 45 , 34 , 78 , 12 , 76 , 34 } ; int [ ] arr2 = { 65 , 67 , 34 , 23 , 45 } ; int n = arr1 . Length ; int m = arr2 . Length ; Console . WriteLine ( " Combined ▁ Variance : ▁ " + combinedVariance ( arr1 , arr2 , n , m ) ) ; } }
using System ; class GFG { static bool checkDivisibility ( string num ) { int length = num . Length ; if ( length == 1 && num [ 0 ] == '0' ) return true ; if ( length % 3 == 1 ) { num += "00" ; length += 2 ; } else if ( length % 3 == 2 ) { num += "0" ; length += 1 ; } int sum = 0 , p = 1 ; for ( int i = length - 1 ; i >= 0 ; i -- ) { int group = 0 ; group += num [ i -- ] - '0' ; group += ( num [ i -- ] - '0' ) * 10 ; group += ( num [ i ] - '0' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . Abs ( sum ) ; return ( sum % 13 == 0 ) ; } static void Main ( ) { string number = "83959092724" ; if ( checkDivisibility ( number ) ) Console . Write ( number + " ▁ is ▁ divisible ▁ by ▁ 13 . " ) ; else Console . Write ( number + " ▁ is ▁ not ▁ divisible ▁ by ▁ 13 . " ) ; } }
using System ; class GFG { static void modularEquation ( int a , int b ) { if ( a < b ) { Console . WriteLine ( " No ▁ solution ▁ possible ▁ " ) ; return ; } if ( a == b ) { Console . WriteLine ( " Infinite ▁ Solution ▁ possible ▁ " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) Math . Sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; Console . WriteLine ( count ) ; } public static void Main ( ) { int a = 21 , b = 5 ; modularEquation ( a , b ) ; } }
using System ; public class GFG { static int countWays ( int num ) { int [ ] dp = new int [ num + 1 ] ; int MOD = ( int ) 1E9 + 7 ; dp [ 1 ] = 2 ; for ( int i = 2 ; i <= num ; ++ i ) { dp [ i ] = 0 ; for ( int j = 1 ; j <= 3 ; ++ j ) { if ( i - j == 0 ) dp [ i ] += 1 ; else if ( j == 1 ) dp [ i ] += dp [ i - j ] * 2 ; else if ( i - j > 0 ) dp [ i ] += dp [ i - j ] ; if ( dp [ i ] >= MOD ) dp [ i ] %= MOD ; } } return dp [ num ] ; } static public void Main ( String [ ] args ) { int n = 3 ; Console . WriteLine ( countWays ( n ) ) ; } }
using System ; class GFG { public static bool judgeSquareSum ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { int count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n /= i ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; } static public void Main ( ) { int n = 17 ; if ( judgeSquareSum ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i *= 10 ) { int divider = i * 10 ; countr += ( n / divider ) * i + Math . Min ( Math . Max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; } public static void Main ( ) { int n = 13 ; Console . WriteLine ( countDigitOne ( n ) ) ; n = 113 ; Console . WriteLine ( countDigitOne ( n ) ) ; n = 205 ; Console . WriteLine ( countDigitOne ( n ) ) ; } }
using System ; class GFG { static void greatest ( string s ) { int n = s . Length ; int [ ] a = new int [ n ] ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = s [ i ] - '0' ; sum += a [ i ] ; } { if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 0 ) { Console . Write ( " - 1" ) ; } else { Console . Write ( n ) ; } } else { int re = sum % 3 ; int del = - 1 ; int flag = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 == re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ; break ; } else { del = i ; } } } if ( flag == 0 ) { if ( a [ n - 2 ] % 2 == 0 && re == a [ n - 1 ] % 3 ) del = n - 1 ; } if ( del == - 1 ) Console . Write ( - 1 ) ; else { Console . Write ( del + 1 ) ; } } } public static void Main ( ) { string s = "7510222" ; greatest ( s ) ; } }
using System ; class GFG { static bool asPowerSum ( int w , int m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; } static public void Main ( ) { int w = 3 , m = 7 ; if ( asPowerSum ( w , m ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int divisible ( String num ) { int n = num . Length ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( int ) ( num [ i ] ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num [ i ] - '0' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; } public static void Main ( ) { string num = "1234" ; Console . WriteLine ( divisible ( num ) ) ; } }
using System ; class GFG { static int n = 3 ; static int dotProduct ( int [ ] vect_A , int [ ] vect_B ) { int product = 0 ; for ( int i = 0 ; i < n ; i ++ ) product = product + vect_A [ i ] * vect_B [ i ] ; return product ; } static void crossProduct ( int [ ] vect_A , int [ ] vect_B , int [ ] cross_P ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; } public static void Main ( ) { int [ ] vect_A = { 3 , - 5 , 4 } ; int [ ] vect_B = { 2 , 6 , 5 } ; int [ ] cross_P = new int [ n ] ; Console . Write ( " Dot ▁ product : " ) ; Console . WriteLine ( dotProduct ( vect_A , vect_B ) ) ; Console . Write ( " Cross ▁ product : " ) ; crossProduct ( vect_A , vect_B , cross_P ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( cross_P [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int MOD = 1000000007 ; static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( 1 * res * x ) % p ; x = ( 1 * x * x ) % p ; } return res ; } static int countEvenWays ( int n ) { return power ( 2 , n / 2 - 1 , MOD ) ; } public static void Main ( ) { int n = 6 ; Console . WriteLine ( countEvenWays ( n ) ) ; n = 8 ; Console . WriteLine ( countEvenWays ( n ) ) ; } }
using System ; class GFG { static int MAX = 1000001 ; static int [ ] factor = new int [ MAX ] ; static void cal_factor ( ) { factor [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( int i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( int i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( int j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } static int no_of_representations ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int temp = a [ i ] ; int flag = 0 ; while ( factor [ temp ] != 1 ) { flag = - 1 ; count ++ ; temp = temp / factor [ temp ] ; } count += flag ; } return count ; } public static void Main ( ) { cal_factor ( ) ; int [ ] a = { 4 , 4 , 4 } ; int n = a . Length ; Console . WriteLine ( no_of_representations ( a , n ) ) ; } }
using System ; class GFG { static int coutSubSeq ( int [ ] A , int N , int M ) { int sum = 0 ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { for ( int k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; } public static void Main ( ) { int M = 3 ; int [ ] A = { 1 , 2 , 4 , 3 } ; int N = A . Length ; Console . WriteLine ( coutSubSeq ( A , N , M ) ) ; } }
using System ; class GFG { static int countSubSeq ( int [ ] A , int N , int M ) { int ans = 0 ; int [ ] h = new int [ M ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = i ; j < M ; j ++ ) { int rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; } public static void Main ( ) { int M = 3 ; int [ ] A = { 1 , 2 , 4 , 3 } ; int N = A . Length ; Console . WriteLine ( countSubSeq ( A , N , M ) ) ; } }
using System ; class GFG { static int findTerm ( int n ) { if ( n == 1 ) return n ; else { int term = 7 ; for ( int i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } } public static void Main ( ) { int n = 5 ; Console . WriteLine ( findTerm ( n ) ) ; } }
using System ; class GFG { static int findNumber ( int n ) { n -- ; int i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( findNumber ( n ) ) ; } }
using System ; class GFG { static float correlationCoefficient ( int [ ] X , int [ ] Y , int n ) { int sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; int squareSum_X = 0 , squareSum_Y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } float corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / ( float ) ( Math . Sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; } public static void Main ( ) { int [ ] X = { 15 , 18 , 21 , 24 , 27 } ; int [ ] Y = { 25 , 25 , 27 , 31 , 32 } ; int n = X . Length ; Console . Write ( Math . Round ( correlationCoefficient ( X , Y , n ) * 1000000.0 ) / 1000000.0 ) ; } }
using System ; class GFG { static void result ( long n , long k , long t ) { if ( t <= k ) Console . WriteLine ( t ) ; else if ( t <= n ) Console . WriteLine ( k ) ; else { long temp = t - n ; temp = k - temp ; Console . WriteLine ( temp ) ; } } public static void Main ( ) { long n , k , t ; n = 10 ; k = 5 ; t = 12 ; result ( n , k , t ) ; } }
using System ; class GFG { static float weightedMean ( int [ ] X , int [ ] W , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) ( numWeight ) / sum ; } public static void Main ( ) { int [ ] X = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int [ ] W = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = X . Length ; int m = W . Length ; if ( n == m ) Console . WriteLine ( weightedMean ( X , W , n ) ) ; else Console . WriteLine ( " - 1" ) ; } }
using System ; class GFG { static float gcd ( double a , double b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . Abs ( b ) < 0.001 ) return ( float ) a ; else return ( float ) ( gcd ( b , a - Math . Floor ( a / b ) * b ) ) ; } public static void Main ( ) { double a = 1.20 , b = 22.5 ; Console . WriteLine ( gcd ( a , b ) ) ; } }
using System ; class GFG { static float harmonicMean ( float [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) 1 / arr [ i ] ; return ( float ) n / sum ; } public static void Main ( ) { float [ ] arr = { 13.5f , 14.5f , 14.8f , 15.2f , 16.1f } ; int n = arr . Length ; Console . WriteLine ( harmonicMean ( arr , n ) ) ; } }
using System ; class GFG { static float harmonicMean ( int [ ] arr , int [ ] freq , int n ) { float sum = 0 , frequency_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + ( float ) freq [ i ] / arr [ i ] ; frequency_sum = frequency_sum + freq [ i ] ; } return ( frequency_sum / sum ) ; } public static void Main ( ) { int [ ] num = { 13 , 14 , 15 , 16 , 17 } ; int [ ] freq = { 2 , 5 , 13 , 7 , 3 } ; int n = num . Length ; Console . WriteLine ( harmonicMean ( num , freq , n ) ) ; } }
using System ; class GFG { static void point ( int a , int b , int c , int d , int n ) { int x , flag = 0 ; for ( int i = 0 ; i < n ; i ++ ) { x = b + i * a ; if ( ( x - d ) % c == 0 && x - d >= 0 ) { Console . WriteLine ( x ) ; flag = 1 ; break ; } } if ( flag == 0 ) { Console . WriteLine ( " No ▁ collision ▁ point " ) ; } } public static void Main ( ) { int a = 20 ; int b = 2 ; int c = 9 ; int d = 19 ; int n = 20 ; point ( a , b , c , d , n ) ; } }
using System ; class GFG { static void findArmstrong ( int low , int high ) { for ( int i = low + 1 ; i < high ; ++ i ) { int x = i ; int n = 0 ; while ( x != 0 ) { x /= 10 ; ++ n ; } int pow_sum = 0 ; x = i ; while ( x != 0 ) { int digit = x % 10 ; pow_sum += ( int ) Math . Pow ( digit , n ) ; x /= 10 ; } if ( pow_sum == i ) Console . Write ( i + " ▁ " ) ; } } public static void Main ( ) { int num1 = 100 ; int num2 = 400 ; findArmstrong ( num1 , num2 ) ; Console . WriteLine ( ) ; } }
using System ; class GFG { static void gcdMax ( int [ ] a , int [ ] b , int n , int N ) { int [ ] cnt = new int [ N ] ; int [ ] first = new int [ N ] ; int [ ] second = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . Max ( first [ i ] , j ) ; cnt = new int [ N ] ; for ( int i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( int i = 1 ; i < N ; ++ i ) for ( int j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . Max ( second [ i ] , j ) ; int x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; Console . WriteLine ( first [ x ] + " ▁ " + second [ x ] ) ; } static int Main ( ) { int [ ] a = { 3 , 1 , 4 , 2 , 8 } ; int [ ] b = { 5 , 2 , 12 , 8 , 3 } ; int n = a . Length ; int N = 20 ; gcdMax ( a , b , n , N ) ; return 0 ; } }
using System ; using System . Collections ; class GFG { static void printPierpont ( int n ) { bool [ ] arr = new bool [ n + 1 ] ; int two = 1 , three = 1 ; while ( two + 1 < n ) { arr [ two ] = true ; while ( two * three + 1 < n ) { arr [ three ] = true ; arr [ two * three ] = true ; three *= 3 ; } three = 1 ; two *= 2 ; } ArrayList v = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] ) v . Add ( i + 1 ) ; arr = new bool [ n + 1 ] ; for ( int p = 2 ; p * p < n ; p ++ ) { if ( arr [ p ] == false ) for ( int i = p * 2 ; i < n ; i += p ) arr [ i ] = true ; } for ( int i = 0 ; i < v . Count ; i ++ ) if ( ! arr [ ( int ) v [ i ] ] ) Console . Write ( v [ i ] + " ▁ " ) ; } static void Main ( ) { int n = 200 ; printPierpont ( n ) ; } }
using System ; class GFG { static bool isWoodall ( int x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; int p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; } public static void Main ( ) { int x = 383 ; if ( isWoodall ( x ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void print_result ( int [ ] a , int n , int k , int m ) { List < List < int > > v = new List < List < int > > ( m ) ; for ( int i = 0 ; i < m ; i ++ ) v . Add ( new List < int > ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { int rem = a [ i ] % m ; v [ rem ] . Add ( a [ i ] ) ; if ( v [ rem ] . Count == k ) { for ( int j = 0 ; j < k ; j ++ ) Console . Write ( v [ rem ] [ j ] + " ▁ " ) ; return ; } } Console . Write ( " - 1" ) ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 8 , 4 } ; int n = a . Length ; print_result ( a , n , 2 , 3 ) ; } }
using System ; class GFG { public static int smallestX ( int n ) { int [ ] temp = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) temp [ i ] = 0 ; if ( n == 0 ) return - 1 ; int count = 0 , x = 0 ; for ( x = 1 ; count < 10 ; x ++ ) { int y = x * n ; while ( y > 0 ) { if ( temp [ y % 10 ] == 0 ) { count ++ ; temp [ y % 10 ] = 1 ; } y /= 10 ; } } return x - 1 ; } static void Main ( ) { int n = 5 ; Console . Write ( smallestX ( n ) ) ; } }
using System ; class GFG { static int digSum ( int n ) { int sum = 0 , rem = 0 ; while ( n > 0 ) { rem = n % 10 ; sum += rem ; n /= 10 ; } return sum ; } static int findX ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) if ( i + digSum ( i ) == n ) return i ; return - 1 ; } public static void Main ( ) { int n = 43 ; Console . Write ( " x ▁ = ▁ " + findX ( n ) ) ; } }
using System ; class GFG { static void complement ( string number1 ) { char [ ] number = number1 . ToCharArray ( ) ; for ( int i = 0 ; i < number . Length ; i ++ ) if ( number [ i ] != ' . ' ) number [ i ] = ( char ) ( ( int ) ( '9' ) - ( int ) ( number [ i ] ) + ( int ) ( '0' ) ) ; System . Console . WriteLine ( "9 ' s ▁ complement ▁ is ▁ : ▁ " + new string ( number ) ) ; } public static void Main ( ) { String number = "345.45" ; complement ( number ) ; } }
using System ; public class main { static int countWays ( int n ) { int count = 0 ; for ( int i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; } public static void Main ( ) { int n = 12 ; Console . WriteLine ( countWays ( n ) ) ; } }
using System ; class GFG { static bool isDigitPresent ( int m , bool [ ] hash ) { while ( m > 0 ) { if ( hash [ m % 10 ] ) return true ; m = m / 10 ; } return false ; } static int countDivisibles ( int n ) { bool [ ] hash = new bool [ 10 ] ; int m = n ; while ( m > 0 ) { hash [ m % 10 ] = true ; m = m / 10 ; } int ans = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( isDigitPresent ( i , hash ) ) ans ++ ; if ( n / i != i ) { if ( isDigitPresent ( n / i , hash ) ) ans ++ ; } } } return ans ; } public static void Main ( ) { int n = 15 ; Console . Write ( countDivisibles ( n ) ) ; } }
using System ; class GFG { static int MAX = 100 ; static String s = " " ; static void luDecomposition ( int [ , ] mat , int n ) { int [ , ] lower = new int [ n , n ] ; int [ , ] upper = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int k = i ; k < n ; k ++ ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ i , j ] * upper [ j , k ] ) ; upper [ i , k ] = mat [ i , k ] - sum ; } for ( int k = i ; k < n ; k ++ ) { if ( i == k ) else { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ( lower [ k , j ] * upper [ j , i ] ) ; lower [ k , i ] = ( mat [ k , i ] - sum ) / upper [ i , i ] ; } } } Console . WriteLine ( setw ( 2 ) + " TABSYMBOL Lower ▁ Triangular " + setw ( 10 ) + " Upper ▁ Triangular " ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) Console . Write ( setw ( 4 ) + lower [ i , j ] + " TABSYMBOL " ) ; Console . Write ( " TABSYMBOL " ) ; for ( int j = 0 ; j < n ; j ++ ) Console . Write ( setw ( 4 ) + upper [ i , j ] + " TABSYMBOL " ) ; Console . Write ( " STRNEWLINE " ) ; } } static String setw ( int noOfSpace ) { s = " " ; for ( int i = 0 ; i < noOfSpace ; i ++ ) s += " ▁ " ; return s ; } public static void Main ( String [ ] arr ) { int [ , ] mat = { { 2 , - 1 , - 2 } , { - 4 , 6 , 3 } , { - 4 , - 2 , 8 } } ; luDecomposition ( mat , 3 ) ; } }
using System ; class GFG { static void printTwoDivisibleParts ( String num , int f , int s ) { int N = num . Length ; int [ ] prefixReminder = new int [ N + 1 ] ; int [ ] suffixReminder = new int [ N + 1 ] ; suffixReminder [ 0 ] = 0 ; for ( int i = 1 ; i < N ; i ++ ) suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( num [ i - 1 ] - '0' ) ) % f ; prefixReminder [ N ] = 0 ; int base1 = 1 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( num [ i ] - '0' ) * base1 ) % s ; base1 = ( base1 * 10 ) % s ; } for ( int i = 0 ; i < N ; i ++ ) { if ( prefixReminder [ i ] == 0 && suffixReminder [ i ] == 0 && num [ i ] != '0' ) { Console . WriteLine ( num . Substring ( 0 , i ) + " ▁ " + num . Substring ( i ) ) ; return ; } } Console . WriteLine ( " Not ▁ Possible " ) ; } public static void Main ( ) { String num = "246904096" ; int f = 12345 ; int s = 1024 ; printTwoDivisibleParts ( num , f , s ) ; } }
using System ; class Subarray { static int calculate ( int [ ] a , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int r = i + 1 ; for ( int j = r ; j < n ; j ++ ) { if ( a [ i ] == a [ j ] ) r += 1 ; else break ; } int d = r - i ; ans += ( d * ( d + 1 ) / 2 ) ; i = r - 1 ; } return ans ; } public static void Main ( ) { int [ ] a = { 2 , 4 , 5 , 3 , 3 , 3 } ; Console . WriteLine ( calculate ( a , a . Length ) ) ; } }
using System ; class GFG { static int sum ( int n ) { int rem = 0 ; int sum_of_digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_of_digits += rem ; n = n / 10 ; } return sum_of_digits ; } static int count ( int n ) { int c = 0 ; for ( int i = n - 97 ; i <= n ; i ++ ) { int a = sum ( i ) ; int b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; } public static void Main ( ) { int n = 9939 ; Console . Write ( count ( n ) ) ; } }
using System ; class GFG { static bool isPowerOfK ( int n , int k ) { bool oneSeen = false ; while ( n > 0 ) { int digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n /= k ; } return true ; } public static void Main ( ) { int n = 64 , k = 4 ; if ( isPowerOfK ( n , k ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static long MAX_DIGITS = 20 ; static long isOctal ( long n ) { while ( n > 0 ) { if ( ( n % 10 ) >= 8 ) return 0 ; else n = n / 10 ; } return 1 ; } static long isPalindrome ( long n ) { long divide = ( isOctal ( n ) == 0 ) ? 8 : 10 ; long [ ] octal = new long [ MAX_DIGITS ] ; long i = 0 ; while ( n != 0 ) { octal [ i ++ ] = n % divide ; n = n / divide ; } for ( long j = i - 1 , k = 0 ; k <= j ; j -- , k ++ ) if ( octal [ j ] != octal [ k ] ) return 0 ; return 1 ; } static int Main ( ) { long n = 97 ; if ( isPalindrome ( n ) > 0 ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; return 0 ; } }
using System ; class GFG { static void printFactorialNums ( int n ) { int fact = 1 ; int x = 2 ; while ( fact <= n ) { Console . Write ( fact + " ▁ " ) ; fact = fact * x ; x ++ ; } } public static void Main ( ) { int n = 100 ; printFactorialNums ( n ) ; } }
using System ; public class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isThreeDisctFactors ( long n ) { int sq = ( int ) Math . Sqrt ( n ) ; if ( 1L L * sq * sq != n ) return false ; return isPrime ( sq ) ? true : false ; } static public void Main ( ) { long num = 9 ; if ( isThreeDisctFactors ( num ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; num = 15 ; if ( isThreeDisctFactors ( num ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; num = 12397923568441 ; if ( isThreeDisctFactors ( num ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int computeLastDigit ( long A , long B ) { int variable = 1 ; if ( A == B ) return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( long i = A + 1 ; i <= B ; i ++ ) variable = ( int ) ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } } public static void Main ( ) { Console . WriteLine ( computeLastDigit ( 2632 , 2634 ) ) ; } }
using System ; class GFG { static float sumOfAP ( float a , float d , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; } public static void Main ( ) { int n = 20 ; float a = 2.5f , d = 1.5f ; Console . Write ( sumOfAP ( a , d , n ) ) ; } }
using System ; class GFG { public static long M = 1000000007 ; static long multiplyFactors ( int n ) { long prod = 1 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; } public static void Main ( ) { int n = 12 ; Console . Write ( multiplyFactors ( n ) ) ; } }
using System ; class GFG { public static long M = 1000000007 ; static long power ( long x , long y ) { long res = 1 ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % M ; y = ( y >> 1 ) % M ; x = ( x * x ) % M ; } return res ; } static int countFactors ( int n ) { int count = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count ++ ; else count += 2 ; } } return count ; } static long multiplyFactors ( int n ) { int numFactor = countFactors ( n ) ; long product = power ( n , numFactor / 2 ) ; if ( numFactor % 2 == 1 ) product = ( product * ( int ) Math . Sqrt ( n ) ) % M ; return product ; } public static void Main ( ) { int n = 12 ; Console . Write ( multiplyFactors ( n ) ) ; } }
using System ; class GFG { static bool isDivisibleBy10 ( String bin ) { int n = bin . Length ; if ( bin [ n - 1 ] == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; } public static void Main ( ) { String bin = "11000111001110" ; if ( isDivisibleBy10 ( bin ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static void printTrib ( int n ) { if ( n < 1 ) return ; int first = 0 , second = 0 ; int third = 1 ; Console . Write ( first + " ▁ " ) ; if ( n > 1 ) Console . Write ( second + " ▁ " ) ; if ( n > 2 ) Console . Write ( second + " ▁ " ) ; for ( int i = 3 ; i < n ; i ++ ) { int curr = first + second + third ; first = second ; second = third ; third = curr ; Console . Write ( curr + " ▁ " ) ; } } public static void Main ( ) { int n = 10 ; printTrib ( n ) ; } }
using System ; using System . Linq ; using System . Collections ; class GFG { static ArrayList SieveOfEratosthenes ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = true ; } ArrayList lis = new ArrayList ( ) ; for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] == false ) lis . Add ( p ) ; return lis ; } static int setBits ( int n ) { return ( int ) Convert . ToString ( n , 2 ) . Count ( c => c == '1' ) ; } public static void Main ( ) { int x = 4 , y = 8 ; int count = 0 ; ArrayList primeArr = new ArrayList ( ) ; primeArr = SieveOfEratosthenes ( Convert . ToInt32 ( Math . Ceiling ( Math . Log ( y , 2.0 ) ) ) ) ; for ( int i = x ; i < y + 1 ; i ++ ) { int temp = setBits ( i ) ; if ( primeArr . Contains ( temp ) ) count += 1 ; } Console . WriteLine ( count ) ; } }
using System ; class GFG { static int count_square ( int n ) { int count = 0 ; for ( int i = 1 ; i <= n ; i = i + 2 ) { int k = n - i + 1 ; count += ( k * k ) ; } return count ; } public static void Main ( ) { int N = 8 ; Console . WriteLine ( count_square ( N ) ) ; } }
using System ; class GFG { static int countAnomalies ( int [ ] arr , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . Abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 5 } ; int n = arr . Length ; int k = 1 ; Console . WriteLine ( countAnomalies ( arr , n , k ) ) ; } }
using System ; class GFG { static int N = 100005 ; static int [ ] d = new int [ N ] ; static int [ ] pre = new int [ N ] ; static void Positive_Divisors ( ) { for ( int i = 1 ; i < N ; i ++ ) { for ( int j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } int ans = 0 ; for ( int i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } } public static void Main ( String [ ] args ) { Positive_Divisors ( ) ; int n = 15 ; Console . WriteLine ( pre [ n ] ) ; } }
using System ; class GFG { static int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = number * 10 + 1 ; if ( ( number % K == 0 ) ) return len ; } return - 1 ; } static void Main ( ) { int K = 7 ; Console . WriteLine ( numLen ( K ) ) ; } }
using System ; class GFG { static bool doesContainB ( int a , int b , int c ) { if ( a == b ) { return true ; } if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) { return true ; } return false ; } public static void Main ( ) { int a = 1 , b = 7 , c = 3 ; if ( doesContainB ( a , b , c ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static void printPermutation ( int n , int k ) { for ( int i = 1 ; i <= n ; i ++ ) { int x = 2 * i - 1 ; int y = 2 * i ; if ( i <= k ) Console . Write ( y + " ▁ " + x + " ▁ " ) ; else Console . Write ( x + " ▁ " + y + " ▁ " ) ; } } public static void Main ( ) { int n = 2 , k = 1 ; printPermutation ( n , k ) ; } }
using System ; class GFG { static int maxSum ( int N ) { int ans = 0 ; for ( int u = 1 ; u <= N ; u ++ ) { for ( int v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; int degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; int degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; } static void Main ( ) { int N = 6 ; Console . WriteLine ( maxSum ( N ) ) ; } }
using System ; using System . Collections ; using System . Linq ; class GFG { static void maximumFactor ( int [ ] arr ) { int [ ] rank = new int [ arr . Max ( ) + 1 ] ; int [ ] factors = new int [ arr . Max ( ) + 1 ] ; int g = 0 ; for ( int i = 2 ; i <= arr . Max ( ) ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . Length ; j ++ ) if ( arr [ j ] % i == 0 ) count += 1 ; rank [ g ] = count ; factors [ g ] = i ; g ++ ; } int m = rank . Max ( ) ; for ( int i = 0 ; i < rank . Length ; i ++ ) { if ( ( int ) rank [ i ] == m ) Console . Write ( factors [ i ] + " ▁ " ) ; } } static void Main ( ) { int [ ] arr = { 120 , 15 , 24 , 63 , 18 } ; maximumFactor ( arr ) ; } }
using System ; class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; } public static void Main ( ) { int n = 5 ; Console . Write ( findSum ( n ) ) ; } }
using System ; class GFG { public static double findMedian ( int [ ] a , int n ) { Array . Sort ( a ) ; if ( n % 2 != 0 ) return ( double ) a [ n / 2 ] ; return ( double ) ( a [ ( n - 1 ) / 2 ] + a [ n / 2 ] ) / 2.0 ; } public static void Main ( ) { int [ ] a = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = a . Length ; Console . Write ( " Median ▁ = ▁ " + findMedian ( a , n ) + " STRNEWLINE " ) ; } }
using System ; class GFG { public static double findMean ( int [ ] a , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return ( double ) sum / ( double ) n ; } public static void Main ( ) { int [ ] a = { 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 } ; int n = a . Length ; Console . Write ( " Mean ▁ = ▁ " + findMean ( a , n ) + " STRNEWLINE " ) ; } }
using System ; using System . Collections ; class GFG { static bool CheckArray ( int [ ] arr , int n ) { int prod = 1 ; ArrayList freq = new ArrayList ( ) ; for ( int i = 0 ; i < n ; ++ i ) { freq . Add ( arr [ i ] ) ; prod *= arr [ i ] ; } int root = ( int ) Math . Sqrt ( prod ) ; if ( root * root == prod ) { if ( freq . Contains ( root ) & freq . LastIndexOf ( root ) != ( freq . Count ) ) { return true ; } } return false ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 12 , 3 , 2 } ; int n = arr . Length ; if ( CheckArray ( arr , n ) ) { Console . WriteLine ( " YES " ) ; } else { Console . WriteLine ( " NO " ) ; } } }
using System ; class GFG { static int toK ( int N , int K ) { int w = 1 ; int s = 0 ; while ( N != 0 ) { int r = N % K ; N = N / K ; s = r * w + s ; w *= 10 ; } return s ; } static Boolean check ( int N ) { Boolean fl = false ; while ( N != 0 ) { int r = N % 10 ; N = N / 10 ; if ( fl == true && r == 0 ) return false ; if ( r > 0 ) { fl = false ; continue ; } fl = true ; } return true ; } static void hasConsecutiveZeroes ( int N , int K ) { int z = toK ( N , K ) ; if ( check ( z ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } public static void Main ( String [ ] args ) { int N = 15 ; int K = 8 ; hasConsecutiveZeroes ( N , K ) ; } }
class GFG { static int MAX = 1000000 ; static bool [ ] prime = new bool [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } } static void SumOfKthPrimes ( int [ ] arr , int n , int k ) { int c = 0 ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { sum += arr [ i ] ; c = 0 ; } } } System . Console . WriteLine ( sum ) ; } static void Main ( ) { SieveOfEratosthenes ( ) ; int [ ] arr = new int [ ] { 2 , 3 , 5 , 7 , 11 } ; int n = arr . Length ; int k = 2 ; SumOfKthPrimes ( arr , n , k ) ; } }
class GFG { static int MAX = 100000 ; static bool [ ] prime = new bool [ 100002 ] ; static void SieveOfEratosthenes ( ) { for ( int p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } static int superpower ( int n ) { SieveOfEratosthenes ( ) ; int superPower = 0 , factor = 0 ; int i = 2 ; while ( n > 1 && i <= MAX ) { if ( ! prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; } static void Main ( ) { int n = 256 ; System . Console . WriteLine ( superpower ( n ) ) ; } }
using System ; class GFG { static int smallestDivisor ( int n ) { if ( n % 2 == 0 ) return 2 ; for ( int i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; } static public void Main ( ) { int n = 31 ; Console . WriteLine ( smallestDivisor ( n ) ) ; } }
using System ; class GFG { static int countRabbits ( int Heads , int Legs ) { int count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; } public static void Main ( ) { int Heads = 100 , Legs = 300 ; int Rabbits = countRabbits ( Heads , Legs ) ; Console . WriteLine ( " Rabbits ▁ = ▁ " + Rabbits ) ; Console . WriteLine ( " Pigeons ▁ = ▁ " + ( Heads - Rabbits ) ) ; } }
using System ; class gfg { public static double calculateSum ( double n ) { return 2 * ( Math . Pow ( n , 6 ) + 15 * Math . Pow ( n , 4 ) + 15 * Math . Pow ( n , 2 ) + 1 ) ; } public static int Main ( ) { double n = 1.4142 ; Console . WriteLine ( Math . Ceiling ( calculateSum ( n ) ) ) ; return 0 ; } }
class GFG { static int Sum_upto_nth_Term ( int n ) { return ( 1 - ( int ) System . Math . Pow ( - 2 , n ) ) ; } public static void Main ( ) { int N = 5 ; System . Console . WriteLine ( Sum_upto_nth_Term ( N ) ) ; } }
using System ; class GFG { static int xorEqualsOrCount ( int N ) { int count = 0 ; int bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = N / 2 ; } return ( int ) Math . Pow ( 2 , count ) ; } public static void Main ( ) { int N = 7 ; Console . WriteLine ( xorEqualsOrCount ( N ) ) ; } }
using System ; class SumOfSeries { static int fact ( int n ) { if ( n == 1 ) return 1 ; return n * fact ( n - 1 ) ; } static double sum ( int x , int n ) { double total = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { total = total + ( Math . Pow ( x , i ) / fact ( i + 1 ) ) ; } return total ; } public static void Main ( ) { int x = 5 , n = 4 ; Console . WriteLine ( " Sum ▁ is : ▁ " + sum ( x , n ) ) ; } }
using System ; class GFG { static int sum_of_series ( int n ) { int result = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - ( int ) Math . Pow ( i , 2 ) ; else result = result + ( int ) Math . Pow ( i , 2 ) ; } return result ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( sum_of_series ( n ) ) ; n = 10 ; Console . WriteLine ( sum_of_series ( n ) ) ; } }
using System ; class GFG { static int findSum ( int N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; } static void Main ( ) { int N = 4 ; Console . Write ( findSum ( N ) ) ; } }
using System ; class GFG { private static int MAX = 16 ; static long [ , ] nCr = new long [ MAX , MAX ] ; static void binomial ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i , j ] = 1 ; else nCr [ i , j ] = nCr [ i - 1 , j ] + nCr [ i - 1 , j - 1 ] ; } } } static double findCosNTheta ( double sinTheta , int n ) { double cosTheta = Math . Sqrt ( 1 - sinTheta * sinTheta ) ; double ans = 0 ; long toggle = 1 ; for ( int i = 1 ; i <= n ; i += 2 ) { ans = ans + nCr [ n , i ] * Math . Pow ( cosTheta , n - i ) * Math . Pow ( sinTheta , i ) * toggle ; toggle = toggle * - 1 ; } return ans ; } public static void Main ( ) { binomial ( ) ; double sinTheta = 0.5 ; int n = 10 ; Console . Write ( findCosNTheta ( sinTheta , n ) ) ; } }
using System ; class GFG { static int nthTerm ( int N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; } public static void Main ( ) { int N = 4 ; Console . WriteLine ( nthTerm ( N ) ) ; } }
using System ; class solution { static int calculateSum ( int n ) { return ( ( int ) Math . Pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / ( int ) Math . Pow ( 9 , 3 ) - n * ( n + 1 ) / 18 ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( " Sum = ▁ " + calculateSum ( n ) ) ; } }
using System ; class GFG { static int calculateSum ( int n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; } public static void Main ( ) { int n = 8 ; Console . WriteLine ( calculateSum ( n ) ) ; } }
using System ; class GFG { public static bool isPower ( int a ) { if ( a == 1 ) { return true ; } for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . Log ( a ) / Math . Log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) { return true ; } } return false ; } public static void Main ( string [ ] args ) { int n = 16 ; Console . WriteLine ( isPower ( n ) ? " Yes " : " No " ) ; } }
using System ; class GFG { static float rmsValue ( int [ ] arr , int n ) { int square = 0 ; float mean = 0 ; float root = 0 ; for ( int i = 0 ; i < n ; i ++ ) { square += ( int ) Math . Pow ( arr [ i ] , 2 ) ; } mean = ( square / ( float ) ( n ) ) ; root = ( float ) Math . Sqrt ( mean ) ; return root ; } public static void Main ( ) { int [ ] arr = { 10 , 4 , 6 , 8 } ; int n = arr . Length ; Console . Write ( rmsValue ( arr , n ) ) ; } }
using System ; class GFG { static double Mixture ( int X , int Y , int Z ) { double result1 = 0.0 , result = 0.0 ; result1 = ( ( X - Y ) / ( float ) X ) ; result = Math . Pow ( result1 , Z ) ; result = result * X ; return result ; } public static void Main ( ) { int X = 10 , Y = 2 , Z = 2 ; Console . WriteLine ( ( float ) Mixture ( X , Y , Z ) + " ▁ litres " ) ; } }
using System ; class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y != 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int check ( int n ) { int mod = ( int ) ( 1e9 + 7 ) ; n -- ; int ans = n * n ; if ( ans >= mod ) ans %= mod ; ans += n + 2 ; if ( ans >= mod ) ans %= mod ; ans = ( power ( 2 , n , mod ) % mod * ans % mod ) % mod ; ans = ( ans - 1 + mod ) % mod ; return ans ; } public static void Main ( String [ ] args ) { int n = 4 ; Console . WriteLine ( check ( n ) ) ; } }
using System ; class GfG { public static int findLCM ( int a , int b ) { int lar = Math . Max ( a , b ) ; int small = Math . Min ( a , b ) ; for ( int i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } } public static void Main ( ) { int a = 5 , b = 7 ; Console . WriteLine ( " LCM ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + findLCM ( a , b ) ) ; } }
class GFG { static void primes ( int n ) { int i = 2 ; int j = 0 ; int [ ] result = new int [ n ] ; int z = 0 ; while ( j < n ) { bool flag = true ; for ( int item = 2 ; item <= ( int ) ( i * 1 / 2 ) ; item ++ ) if ( i % item == 0 && i != item ) { flag = false ; break ; } if ( flag ) { result [ z ++ ] = i ; j += 1 ; } i += 1 ; } for ( i = 0 ; i < result . Length ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) System . Console . Write ( result [ j ] ) ; System . Console . Write ( " ▁ " ) ; } } static void smar_wln ( int n ) { primes ( n ) ; } static void Main ( ) { int n = 5 ; System . Console . WriteLine ( " First ▁ " + n + " ▁ terms ▁ of ▁ the ▁ Sequence ▁ are " ) ; smar_wln ( n ) ; } }
using System ; class GFG { static int Pentatope_number ( int n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; } public static void Main ( ) { int n = 7 ; Console . WriteLine ( n + " th ▁ " + " Pentatope ▁ number ▁ : " + Pentatope_number ( n ) ) ; n = 12 ; Console . WriteLine ( n + " th ▁ " + " Pentatope ▁ number ▁ : " + Pentatope_number ( n ) ) ; } }
using System ; class GFG { static int centeredIcosahedralNum ( int n ) { return ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( centeredIcosahedralNum ( n ) ) ; n = 12 ; Console . WriteLine ( centeredIcosahedralNum ( n ) ) ; } }
using System ; public class GFG { static int centered_square_num ( int n ) { return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; } static public void Main ( ) { int n = 7 ; Console . WriteLine ( n + " th ▁ Centered " + " ▁ square ▁ number : ▁ " + centered_square_num ( n ) ) ; } }
using System ; class GFG { static int seriesSum ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( seriesSum ( n ) ) ; } }
using System ; class GFG { static int Dodecagonal_number ( int n ) { return 5 * n * n - 4 * n ; } static void Main ( ) { int n = 7 ; Console . WriteLine ( Dodecagonal_number ( n ) ) ; n = 12 ; Console . WriteLine ( Dodecagonal_number ( n ) ) ; } }
using System ; class GFG { static void SieveOfEratosthenes ( int n , bool [ ] prime , bool [ ] primesquare , int [ ] a ) { for ( int i = 2 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int i = 0 ; i <= ( n * n ) ; i ++ ) primesquare [ i ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } int j = 0 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { a [ j ] = p ; primesquare [ p * p ] = true ; j ++ ; } } } static int countDivisors ( int n ) { if ( n == 1 ) return 1 ; bool [ ] prime = new bool [ n + 1 ] ; bool [ ] primesquare = new bool [ n * n + 1 ] ; SieveOfEratosthenes ( n , prime , primesquare , a ) ; int ans = 1 ; for ( int i = 0 ; ; i ++ ) { if ( a [ i ] * a [ i ] * a [ i ] > n ) break ; int cnt = 1 ; while ( n % a [ i ] == 0 ) { n = n / a [ i ] ; } ans = ans * cnt ; } if ( prime [ n ] ) ans = ans * 2 ; else if ( primesquare [ n ] ) ans = ans * 3 ; else if ( n != 1 ) ans = ans * 4 ; } static int sumofFactors ( int n ) { int res = 1 ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { int count = 0 , curr_sum = 1 ; int curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } static bool checkArithmetic ( int n ) { int count = countDivisors ( n ) ; int sum = sumofFactors ( n ) ; return ( sum % count == 0 ) ; } public static void Main ( String [ ] args ) { int n = 6 ; if ( checkArithmetic ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int magicOfSequence ( int N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; } public static void Main ( ) { int N = 6 ; Console . Write ( magicOfSequence ( N ) ) ; } }
using System ; using System . Collections . Generic ; using System . Linq ; using System . Collections ; class GFG { static void nextPower ( int N , ref List < int > power ) { int carry = 0 ; for ( int i = 0 ; i < power . Count ; i ++ ) { int prod = ( power [ i ] * N ) + carry ; power [ i ] = prod % 10 ; carry = prod / 10 ; } while ( carry >= 1 ) { power . Add ( carry % 10 ) ; carry = carry / 10 ; } } static void printPowerNumber ( int X , int N ) { List < int > power = new List < int > ( ) ; power . Add ( 1 ) ; List < int > res = new List < int > ( ) ; for ( int i = 1 ; i <= X ; i ++ ) { nextPower ( N , ref power ) ; res . Add ( power . Last ( ) ) ; res . Add ( power . First ( ) ) ; } for ( int i = 0 ; i < res . Count ; i ++ ) Console . Write ( res [ i ] ) ; } public static void Main ( ) { int N = 19 , X = 4 ; printPowerNumber ( X , N ) ; } }
using System ; class GFG { static int firstDigit ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return fact ; } public static void Main ( ) { int n = 5 ; Console . Write ( firstDigit ( n ) ) ; } }
using System ; class GFG { static int sumofseries ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; } public static void Main ( ) { Console . WriteLine ( sumofseries ( 3 ) ) ; } }
using System ; public class GFG { static void printGMeans ( int A , int B , int N ) { float R = ( float ) Math . Pow ( ( float ) ( B / A ) , 1.0 / ( float ) ( N + 1 ) ) ; for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( A * Math . Pow ( R , i ) + " ▁ " ) ; } public static void Main ( ) { int A = 3 , B = 81 , N = 2 ; printGMeans ( A , B , N ) ; } }
using System ; class GFG { static long digitSum ( long n ) { long digSum = 0 ; while ( n > 0 ) { digSum += n % 10 ; n /= 10 ; } return digSum ; } public static long countInteger ( long n , long s ) { if ( n < s ) return 0 ; for ( long i = s ; i <= Math . Min ( n , s + 163 ) ; i ++ ) if ( ( i - digitSum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; } public static void Main ( ) { long n = 1000 , s = 100 ; Console . WriteLine ( countInteger ( n , s ) ) ; } }
using System ; class GFG { static int division ( int num1 , int num2 ) { if ( num1 == 0 ) return 0 ; if ( num2 == 0 ) return int . MaxValue ; bool negResult = false ; if ( num1 < 0 ) { num1 = - num1 ; if ( num2 < 0 ) num2 = - num2 ; else negResult = true ; } else if ( num2 < 0 ) { num2 = - num2 ; negResult = true ; } int quotient = 0 ; while ( num1 >= num2 ) { num1 = num1 - num2 ; quotient ++ ; } if ( negResult ) quotient = - quotient ; return quotient ; } public static void Main ( ) { int num1 = 13 , num2 = 2 ; Console . Write ( division ( num1 , num2 ) ) ; } }
using System ; class GFG { static void Nonagonal ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( i * ( 7 * i - 5 ) / 2 ) ; Console . Write ( " ▁ " ) ; } } public static void Main ( ) { int n = 10 ; Nonagonal ( n ) ; } }
using System ; class GFG { static int seriesFunc ( int n ) { int sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; int sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; } public static void Main ( ) { int n = 8 ; Console . WriteLine ( seriesFunc ( n ) ) ; n = 13 ; Console . WriteLine ( seriesFunc ( 13 ) ) ; } }
using System ; class GFG { static bool checkplusperfect ( int x ) { int temp = x ; int n = 0 ; while ( x != 0 ) { x /= 10 ; n ++ ; } x = temp ; int sum = 0 ; while ( x != 0 ) { sum += ( int ) Math . Pow ( x % 10 , n ) ; x /= 10 ; } return ( sum == temp ) ; } public static void Main ( ) { int x = 9474 ; if ( checkplusperfect ( x ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int subsetCount ( int [ ] arr , int n ) { return 1 << n ; } public static void Main ( ) { int [ ] A = { 1 , 2 , 3 } ; int n = A . Length ; Console . WriteLine ( subsetCount ( A , n ) ) ; } }
using System ; class GFG { static float Calculate_GST ( float org_cost , float N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; } public static void Main ( ) { float org_cost = 100 ; float N_price = 120 ; Console . Write ( " ▁ GST ▁ = ▁ " + Calculate_GST ( org_cost , N_price ) + " % " ) ; } }
using System ; class GFG { static int centeredHexagonalNumber ( int n ) { return 3 * n * ( n - 1 ) + 1 ; } public static void Main ( ) { int n = 10 ; Console . Write ( n + " th ▁ centered ▁ " + " hexagonal ▁ number : ▁ " ) ; Console . Write ( centeredHexagonalNumber ( n ) ) ; } }
using System ; class GFG { public static int find_distance ( int n ) { return n * ( ( 3 * n ) + 7 ) ; } public static void Main ( ) { int n = 5 ; Console . Write ( find_distance ( n ) ) ; } }
using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool twinPrime ( int n1 , int n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . Abs ( n1 - n2 ) == 2 ) ; } public static void Main ( ) { int n1 = 11 , n2 = 13 ; if ( twinPrime ( n1 , n2 ) ) Console . WriteLine ( " Twin ▁ Prime " ) ; else Console . WriteLine ( " Not ▁ Twin ▁ Prime " ) ; } }
using System ; class GFG { static double sumOfSeries ( int n ) { return 0.0246 * ( Math . Pow ( 10 , n ) - 1 - ( 9 * n ) ) ; } public static void Main ( ) { int n = 3 ; Console . Write ( sumOfSeries ( n ) ) ; } }
using System ; class GFG { static int evenbinomialCoeffSum ( int n ) { return ( 1 << ( n - 1 ) ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( evenbinomialCoeffSum ( n ) ) ; } }
using System ; class GFG { static void triangular_series ( int n ) { int i , j = 1 , k = 1 ; for ( i = 1 ; i <= n ; i ++ ) { Console . Write ( k + " ▁ " ) ; j += 1 ; k += j ; } } public static void Main ( ) { int n = 5 ; triangular_series ( n ) ; } }
using System ; class GfG { static int sumOfTheSeries ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } public static void Main ( ) { int n = 5 ; Console . Write ( " Sum ▁ = ▁ " + sumOfTheSeries ( n ) ) ; } }
using System ; class GFG { static int sumOfSeries ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; } public static void Main ( ) { int n = 10 ; Console . Write ( sumOfSeries ( n ) ) ; } }
using System ; class Triangle { public static double numberOfTriangles ( int n ) { double ans = 2 * ( Math . Pow ( 3 , n ) ) - 1 ; return ans ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( numberOfTriangles ( n ) ) ; } }
using System ; class GFG { public static int motzkin ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = ( ( 2 * i + 1 ) * dp [ i - 1 ] + ( 3 * i - 3 ) * dp [ i - 2 ] ) / ( i + 2 ) ; return dp [ n ] ; } public static void Main ( ) { int n = 8 ; Console . WriteLine ( motzkin ( n ) ) ; } }
using System ; class GFG { public static int kthgroupsum ( int k ) { return k * k * k ; } public static void Main ( ) { int k = 3 ; Console . WriteLine ( kthgroupsum ( k ) ) ; } }
using System ; class GFG { static void printXYZ ( int n ) { if ( n == 1 ) Console . WriteLine ( - 1 ) ; else { Console . WriteLine ( " x ▁ is ▁ " + n ) ; Console . WriteLine ( " y ▁ is ▁ " + ( n + 1 ) ) ; Console . WriteLine ( " z ▁ is ▁ " + ( n * ( n + 1 ) ) ) ; } } public static void Main ( ) { int n = 7 ; printXYZ ( n ) ; } }
using System ; class GFG { static int term ( int n ) { return n * ( n + 1 ) / 2 ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( term ( n ) ) ; } }
using System ; class GeeksforGeeks { static double compute ( int a , int b ) { double AM , GM , HM ; AM = ( a + b ) / 2 ; GM = Math . Sqrt ( a * b ) ; HM = ( GM * GM ) / AM ; return HM ; } public static void Main ( ) { int a = 5 , b = 15 ; double HM = compute ( a , b ) ; Console . WriteLine ( " Harmonic ▁ Mean ▁ between ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + HM ) ; } }
using System ; class GFG { static int series ( int n ) { return ( 8 * n * n ) + 1 ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( series ( n ) ) ; } }
using System ; class GFG { public static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } static bool isDivisible ( int x , int y ) { if ( y == 1 ) return true ; int z = gcd ( x , y ) ; if ( z == 1 ) return false ; return isDivisible ( x , y / z ) ; } public static void Main ( ) { int x = 18 , y = 12 ; if ( isDivisible ( x , y ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { public static void Main ( ) { double n = 5 , a = 2 ; Console . WriteLine ( sumOfSeries ( a , n ) ) ; } static float sumOfSeries ( double a , double n ) { double res = 0 , prev = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( float ) ( res ) ; } }
using System ; class GFG { static float Cel_To_Fah ( float n ) { return ( ( n * 9.0f / 5.0f ) + 32.0f ) ; } public static void Main ( ) { float n = 20.0f ; Console . Write ( Cel_To_Fah ( n ) ) ; } }
using System ; class GFG { static void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { Console . Write ( " - 1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) Console . Write ( r * i + " ▁ " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; Console . WriteLine ( res ) ; } } public static void Main ( ) { int n = 24 ; int k = 4 ; print_sequence ( n , k ) ; n = 24 ; k = 5 ; print_sequence ( n , k ) ; n = 6 ; k = 4 ; print_sequence ( n , k ) ; } }
using System ; class GFG { public static int countCompositions ( int n ) { return 1 << ( n - 1 ) ; } public static void Main ( ) { int n = 4 ; Console . Write ( countCompositions ( n ) ) ; } }
using System ; class GFG { static int countDigit ( long n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( n / 10 ) ; } public static void Main ( ) { long n = 345289467 ; Console . WriteLine ( " Number ▁ of ▁ " + " digits ▁ : ▁ " + countDigit ( n ) ) ; } }
using System ; class GFG { static void printTrib ( int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( dp [ i ] + " ▁ " ) ; } public static void Main ( ) { int n = 10 ; printTrib ( n ) ; } }
using System ; class GFG { static void multiply ( int [ , ] T , int [ , ] M ) { int a , b , c , d , e , f , g , h , i ; a = T [ 0 , 0 ] * M [ 0 , 0 ] + T [ 0 , 1 ] * M [ 1 , 0 ] + T [ 0 , 2 ] * M [ 2 , 0 ] ; b = T [ 0 , 0 ] * M [ 0 , 1 ] + T [ 0 , 1 ] * M [ 1 , 1 ] + T [ 0 , 2 ] * M [ 2 , 1 ] ; c = T [ 0 , 0 ] * M [ 0 , 2 ] + T [ 0 , 1 ] * M [ 1 , 2 ] + T [ 0 , 2 ] * M [ 2 , 2 ] ; d = T [ 1 , 0 ] * M [ 0 , 0 ] + T [ 1 , 1 ] * M [ 1 , 0 ] + T [ 1 , 2 ] * M [ 2 , 0 ] ; e = T [ 1 , 0 ] * M [ 0 , 1 ] + T [ 1 , 1 ] * M [ 1 , 1 ] + T [ 1 , 2 ] * M [ 2 , 1 ] ; f = T [ 1 , 0 ] * M [ 0 , 2 ] + T [ 1 , 1 ] * M [ 1 , 2 ] + T [ 1 , 2 ] * M [ 2 , 2 ] ; g = T [ 2 , 0 ] * M [ 0 , 0 ] + T [ 2 , 1 ] * M [ 1 , 0 ] + T [ 2 , 2 ] * M [ 2 , 0 ] ; h = T [ 2 , 0 ] * M [ 0 , 1 ] + T [ 2 , 1 ] * M [ 1 , 1 ] + T [ 2 , 2 ] * M [ 2 , 1 ] ; i = T [ 2 , 0 ] * M [ 0 , 2 ] + T [ 2 , 1 ] * M [ 1 , 2 ] + T [ 2 , 2 ] * M [ 2 , 2 ] ; T [ 0 , 0 ] = a ; T [ 0 , 1 ] = b ; T [ 0 , 2 ] = c ; T [ 1 , 0 ] = d ; T [ 1 , 1 ] = e ; T [ 1 , 2 ] = f ; T [ 2 , 0 ] = g ; T [ 2 , 1 ] = h ; T [ 2 , 2 ] = i ; } static void power ( int [ , ] T , int n ) { if ( n == 0 n == 1 ) return ; int [ , ] M = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; power ( T , n / 2 ) ; multiply ( T , T ) ; if ( n % 2 != 0 ) multiply ( T , M ) ; } static int tribonacci ( int n ) { int [ , ] T = { { 1 , 1 , 1 } , { 1 , 0 , 0 } , { 0 , 1 , 0 } } ; if ( n == 0 n == 1 ) return 0 ; else power ( T , n - 2 ) ; return T [ 0 , 0 ] ; } public static void Main ( ) { int n = 10 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( tribonacci ( i ) + " ▁ " ) ; Console . WriteLine ( ) ; } }
using System ; class GFG { static float geometricMean ( int [ ] arr , int n ) { float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + ( float ) Math . Log ( arr [ i ] ) ; sum = sum / n ; return ( float ) Math . Exp ( sum ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 } ; int n = arr . Length ; Console . WriteLine ( geometricMean ( arr , n ) ) ; } }
using System ; using System . Collections . Generic ; public class GFG { static long smallestNumber ( int n ) { if ( n >= 0 && n <= 9 ) { return n ; } Stack < int > digits = new Stack < int > ( ) ; for ( int i = 9 ; i >= 2 && n > 1 ; i -- ) { while ( n % i == 0 ) { digits . Push ( i ) ; n = n / i ; } } if ( n != 1 ) { return - 1 ; } long k = 0 ; while ( digits . Count != 0 ) { k = k * 10 + digits . Peek ( ) ; digits . Pop ( ) ; } return k ; } static public void Main ( ) { int n = 100 ; Console . Write ( smallestNumber ( n ) ) ; } }
using System ; class GFG { public static bool isMagic ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum == 1 ) ; } public static void Main ( ) { int n = 1234 ; if ( isMagic ( n ) ) Console . WriteLine ( " Magic ▁ Number " ) ; else Console . WriteLine ( " Not ▁ a ▁ magic ▁ Number " ) ; } }
using System ; class GFG { public static void printSequence ( int n ) { int a = 1 ; int ans = 2 ; int N = 1000000007 ; for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( ans + " ▁ " ) ; ans = ( ( a % N ) * ( ans % N ) ) % N ; a = ans ; ans = ( ans + 1 ) % N ; } } public static void Main ( ) { int n = 6 ; printSequence ( n ) ; } }
using System ; class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; } public static void Main ( ) { int n = 5 ; Console . Write ( findSum ( n ) ) ; } }
using System ; class GFG { static int c ; static int HailstoneNumbers ( int N ) { Console . Write ( N + " ▁ " ) ; if ( N == 1 && c == 0 ) { return c ; } else if ( N == 1 && c != 0 ) { c ++ ; return c ; } else if ( N % 2 == 0 ) { c ++ ; HailstoneNumbers ( N / 2 ) ; } else if ( N % 2 != 0 ) { c ++ ; HailstoneNumbers ( 3 * N + 1 ) ; } return c ; } public static void Main ( ) { int N = 7 ; int x ; x = HailstoneNumbers ( N ) ; Console . WriteLine ( ) ; Console . WriteLine ( " Number ▁ of ▁ Steps : ▁ " + x ) ; } }
using System ; class GFG { static int SUM ( int n , int m ) { if ( m == 1 ) return ( n * ( n + 1 ) / 2 ) ; int sum = SUM ( n , m - 1 ) ; return ( sum * ( sum + 1 ) / 2 ) ; } public static void Main ( ) { int n = 5 ; int m = 3 ; Console . Write ( " SUM ( " + n + " , ▁ " + m + " ) : ▁ " + SUM ( n , m ) ) ; } }
using System ; class GFG { static int xorCalc ( int k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return k / 2 ; return 1 ; } public static void Main ( ) { int k = 31 ; Console . WriteLine ( xorCalc ( k ) ) ; } }
using System ; class GFG { static string findNthNo ( int n ) { string res = " " ; while ( n >= 1 ) { if ( ( n & 1 ) == 1 ) { res = res + "4" ; n = ( n - 1 ) / 2 ; } else { res = res + "7" ; n = ( n - 2 ) / 2 ; } } char [ ] arr = res . ToCharArray ( ) ; Array . Reverse ( arr ) ; return new string ( arr ) ; } public static void Main ( ) { int n = 13 ; Console . Write ( findNthNo ( n ) ) ; } }
using System ; class GFG { static int divCount ( int n ) { bool [ ] hash = new bool [ n + 1 ] ; for ( int p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == false ) for ( int i = p * 2 ; i < n ; i += p ) hash [ i ] = true ; int total = 1 ; for ( int p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] == false ) { int count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = n / p ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; } public static void Main ( ) { int n = 24 ; Console . WriteLine ( divCount ( n ) ) ; } }
using System ; class GFG { static int getMax ( int [ ] Arr ) { int max = Arr [ 0 ] ; for ( int i = 1 ; i < Arr . Length ; i ++ ) if ( Arr [ i ] > max ) max = Arr [ i ] ; return max ; } static int maxPrimefactorNum ( int N ) { int [ ] arr = new int [ N + 1 ] ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) for ( int j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } return getMax ( arr ) ; } public static void Main ( ) { int N = 40 ; Console . WriteLine ( maxPrimefactorNum ( N ) ) ; } }
using System ; class GFG { static String decToBin ( int n ) { if ( n == 0 ) return "0" ; String bin = " " ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? '0' : '1' ) + bin ; n >>= 1 ; } return bin ; } public static void Main ( ) { int n = 38 ; Console . WriteLine ( decToBin ( n ) ) ; } }
using System ; class GFG { public static int arraySum ( int [ ] arr , int n ) { int x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; } public static void Main ( ) { int [ ] arr = { 10 , 11 , 12 , 13 , 12 , 11 , 10 } ; int n = arr . Length ; Console . WriteLine ( arraySum ( arr , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static bool isBalancePossible ( int T , int a ) { List < int > baseForm = new List < int > ( ) ; int s = 0 ; while ( T > 0 ) { baseForm . Add ( T % a ) ; T /= a ; s ++ ; } baseForm . Add ( 0 ) ; for ( int i = 0 ; i < s ; i ++ ) { if ( baseForm [ i ] != 0 && baseForm [ i ] != 1 && baseForm [ i ] != ( a - 1 ) && baseForm [ i ] != a ) { return false ; } if ( baseForm [ i ] == a || baseForm [ i ] == ( a - 1 ) ) { baseForm . Insert ( i + 1 , baseForm [ i + 1 ] + 1 ) ; } } return true ; } public static void Main ( ) { int T = 11 ; int a = 4 ; bool balancePossible = isBalancePossible ( T , a ) ; if ( balancePossible ) { Console . WriteLine ( " Balance ▁ is ▁ possible " ) ; } else { Console . WriteLine ( " Balance ▁ is ▁ not ▁ possible " ) ; } } }
using System ; class GFG { public static int countDigits ( int a , int b ) { if ( a == 0 b == 0 ) return 1 ; return ( int ) Math . Floor ( Math . Log10 ( Math . Abs ( a ) ) + Math . Log10 ( Math . Abs ( b ) ) ) + 1 ; } static void Main ( ) { int a = 33 ; int b = - 24 ; Console . Write ( countDigits ( a , b ) ) ; } }
using System ; class GFG { static int lastPosition ( int n , int m , int k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; } public static void Main ( ) { int n = 5 ; int m = 8 ; int k = 2 ; Console . WriteLine ( lastPosition ( n , m , k ) ) ; } }
class GFG { static void primesInRange ( int n ) { int fact = 1 ; for ( int k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) System . Console . WriteLine ( k ) ; } } static void Main ( ) { int n = 15 ; primesInRange ( n ) ; } }
using System ; class GFG { static double EPS = 1e-9 ; static void productPuzzle ( int [ ] a , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . Log10 ( a [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ( int ) ( EPS + Math . Pow ( 10.00 , sum - Math . Log10 ( a [ i ] ) ) ) + " ▁ " ) ; } public static void Main ( ) { int [ ] a = { 10 , 3 , 5 , 6 , 2 } ; int n = a . Length ; Console . WriteLine ( " The ▁ product ▁ array ▁ is : ▁ " ) ; productPuzzle ( a , n ) ; } }
using System ; class GFG { static int changeEvenBits ( int n ) { int to_subtract = 0 ; int m = 0 ; for ( int x = n ; x > 0 ; x >>= 2 ) { if ( ( x & 1 ) > 0 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; } public static void Main ( ) { int n = 30 ; Console . Write ( changeEvenBits ( n ) ) ; } }
using System ; class GFG { static int closestNumber ( int n , int m ) { int q = n / m ; int n1 = m * q ; int n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . Abs ( n - n1 ) < Math . Abs ( n - n2 ) ) return n1 ; return n2 ; } public static void Main ( ) { int n = 13 , m = 4 ; Console . WriteLine ( closestNumber ( n , m ) ) ; n = - 15 ; m = 6 ; Console . WriteLine ( closestNumber ( n , m ) ) ; n = 0 ; m = 8 ; Console . WriteLine ( closestNumber ( n , m ) ) ; n = 18 ; m = - 7 ; Console . WriteLine ( closestNumber ( n , m ) ) ; } }
using System ; class GFG { static bool checkPronic ( int x ) { for ( int i = 0 ; i <= ( int ) ( Math . Sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; } public static void Main ( ) { for ( int i = 0 ; i <= 200 ; i ++ ) if ( checkPronic ( i ) ) Console . Write ( i + " ▁ " ) ; } }
using System ; public class GFG { static int findMinSum ( int num ) { int sum = 0 ; for ( int i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; } public static void Main ( ) { int num = 12 ; Console . Write ( findMinSum ( num ) ) ; } }
using System ; class GFG { static void findMin ( int sum ) { int a = 0 , b = 0 ; while ( sum > 0 ) { if ( sum % 7 == 0 ) { b ++ ; sum -= 7 ; } else if ( sum % 4 == 0 ) { a ++ ; sum -= 4 ; } else { a ++ ; sum -= 4 ; } } if ( sum < 0 ) { Console . Write ( " - 1n " ) ; return ; } for ( int i = 0 ; i < a ; i ++ ) Console . Write ( "4" ) ; for ( int i = 0 ; i < b ; i ++ ) Console . Write ( "7" ) ; Console . WriteLine ( ) ; } public static void Main ( ) { findMin ( 15 ) ; } }
using System ; class GFG { static int minNum ( int [ ] arr , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . Length ; Console . Write ( minNum ( arr , n ) ) ; } }
using System ; class GFG { static int printMaxNum ( int num ) { int [ ] count = new int [ 10 ] ; String str = num . ToString ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) count [ str [ i ] - '0' ] ++ ; int result = 0 , multiplier = 1 ; for ( int i = 0 ; i <= 9 ; i ++ ) { while ( count [ i ] > 0 ) { result = result + ( i * multiplier ) ; count [ i ] -- ; multiplier = multiplier * 10 ; } } return result ; } public static void Main ( ) { int num = 38293367 ; Console . Write ( printMaxNum ( num ) ) ; } }
using System ; using System . Text ; public class GFG { static String largestNumber ( String num ) { int n = num . Length ; int right ; int [ ] rightMax = new int [ n ] ; rightMax [ n - 1 ] = - 1 ; right = n - 1 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( num [ i ] < num [ right ] ) rightMax [ i ] = right ; else { rightMax [ i ] = - 1 ; right = i ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( rightMax [ i ] != - 1 ) { num = swap ( num , i , rightMax [ i ] ) ; break ; } } return num ; } static String swap ( String num , int i , int j ) { StringBuilder sb = new StringBuilder ( num ) ; sb [ i ] = num [ j ] ; sb [ j ] = num [ i ] ; return sb . ToString ( ) ; } public static void Main ( ) { String num = "8725634" ; Console . WriteLine ( " Largest ▁ Number ▁ : ▁ " + largestNumber ( num ) ) ; } }
using System ; class GFG { static int nCr ( int n , int r ) { if ( r > n / 2 ) r = n - r ; int answer = 1 ; for ( int i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ) ; answer /= i ; } return answer ; } static float binomialProbability ( int n , int k , float p ) { return nCr ( n , k ) * ( float ) Math . Pow ( p , k ) * ( float ) Math . Pow ( 1 - p , n - k ) ; } public static void Main ( ) { int n = 10 ; int k = 5 ; float p = ( float ) 1.0 / 3 ; float probability = binomialProbability ( n , k , p ) ; Console . Write ( " Probability ▁ of ▁ " + k ) ; Console . Write ( " ▁ heads ▁ when ▁ a ▁ coin ▁ " + " is ▁ tossed ▁ " + n ) ; Console . Write ( " ▁ times ▁ where ▁ " + " probability ▁ of ▁ each ▁ head ▁ is ▁ " + p ) ; Console . Write ( " ▁ is ▁ = ▁ " + probability ) ; } }
using System ; class GFG { public static int findMaxGCD ( int [ ] arr , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . Max ( high , arr [ i ] ) ; int [ ] divisors = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . Sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; return 1 ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 8 , 8 , 12 } ; int n = arr . Length ; Console . WriteLine ( findMaxGCD ( arr , n ) ) ; } }
using System ; class GFG { public static int findMaxGCD ( int [ ] arr , int n ) { int high = 0 ; for ( int i = 0 ; i < n ; i ++ ) high = Math . Max ( high , arr [ i ] ) ; int [ ] count = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; int counter = 0 ; for ( int i = high ; i >= 1 ; i -- ) { int j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 1 ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 4 , 8 , 8 , 12 } ; int n = arr . Length ; Console . WriteLine ( findMaxGCD ( arr , n ) ) ; } }
using System ; class GFG { static int count_one ( int n ) { int c_one = 0 ; while ( n != 0 ) { int rem = n % 10 ; if ( rem == 1 ) c_one = c_one + 1 ; n = n / 10 ; } return c_one ; } static int checkEvil ( int n ) { int i = 0 , bin = 0 , n_one = 0 ; while ( n != 0 ) { int r = n % 2 ; bin = bin + r * ( int ) ( Math . Pow ( 10 , i ) ) ; n = n / 2 ; } n_one = count_one ( bin ) ; if ( n_one % 2 == 0 ) return 1 ; else return 0 ; } public static void Main ( String [ ] args ) { int check , num ; num = 32 ; check = checkEvil ( num ) ; if ( check == 1 ) Console . WriteLine ( num + " ▁ is ▁ Evil ▁ Number " ) ; else Console . WriteLine ( num + " ▁ is ▁ Odious ▁ Number " ) ; } }
using System ; class GFG { static int CountPairs ( int n ) { int k = n ; int imin = 1 ; int ans = 0 ; while ( imin <= n ) { int imax = n / k ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = n / imin ; } return ans ; } public static void Main ( String [ ] args ) { Console . WriteLine ( CountPairs ( 1 ) ) ; Console . WriteLine ( CountPairs ( 2 ) ) ; Console . WriteLine ( CountPairs ( 3 ) ) ; } }
class GFG { static long powermod ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long modInverse ( long a , long m ) { long m0 = m , t , q ; long x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } static long evaluteExpression ( long n ) { long firstsum = 0 , mod = 10 ; for ( int i = 2 , j = 0 ; ( 1 << j ) <= n ; i *= i , ++ j ) firstsum = ( firstsum + i ) % mod ; long secondsum = ( powermod ( 4L , n + 1 , mod ) - 1 ) * modInverse ( 3L , mod ) ; return ( firstsum * secondsum ) % mod ; } public static void Main ( ) { long n = 3 ; System . Console . WriteLine ( evaluteExpression ( n ) ) ; n = 10 ; System . Console . WriteLine ( evaluteExpression ( n ) ) ; } }
using System ; public class GFG { static int PowerOFPINnfactorial ( int n , int p ) { int ans = 0 ; int temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; } public static void Main ( String [ ] args ) { Console . WriteLine ( PowerOFPINnfactorial ( 4 , 2 ) ) ; } }
class GFG { public static int binaryToDecimal ( int n ) { int num = n ; int dec_value = 0 ; int base1 = 1 ; int temp = num ; while ( temp > 0 ) { int last_digit = temp % 10 ; temp = temp / 10 ; dec_value += last_digit * base1 ; base1 = base1 * 2 ; } return dec_value ; } public static void Main ( ) { int num = 10101001 ; System . Console . Write ( binaryToDecimal ( num ) ) ; } }
class GFG { public static int stirlingFactorial ( double n ) { if ( n == 1 ) return 1 ; double z ; z = System . Math . Sqrt ( 2 * 3.14 * n ) * System . Math . Pow ( ( n / e ) , n ) ; return ( int ) ( z ) ; } public static void Main ( ) { System . Console . WriteLine ( stirlingFactorial ( 1 ) ) ; System . Console . WriteLine ( stirlingFactorial ( 2 ) ) ; System . Console . WriteLine ( stirlingFactorial ( 3 ) ) ; System . Console . WriteLine ( stirlingFactorial ( 4 ) ) ; System . Console . WriteLine ( stirlingFactorial ( 5 ) ) ; System . Console . WriteLine ( stirlingFactorial ( 6 ) ) ; System . Console . WriteLine ( stirlingFactorial ( 7 ) ) ; } }
using System ; public class CountXor { static int countXorPair ( int [ ] arr , int n ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; Console . WriteLine ( countXorPair ( arr , arr . Length ) ) ; } }
using System ; class GFG { private static int MAX_ITERATIONS = 20 ; private static bool isLychrel ( long number ) { for ( int i = 0 ; i < MAX_ITERATIONS ; i ++ ) { number = number + reverse ( number ) ; if ( isPalindrome ( number ) ) return false ; } return true ; } private static bool isPalindrome ( long number ) { return number == reverse ( number ) ; } private static long reverse ( long number ) { long reverse = 0 ; while ( number > 0 ) { long remainder = number % 10 ; reverse = ( reverse * 10 ) + remainder ; number = number / 10 ; } return reverse ; } public static void Main ( ) { long number = 295 ; Console . Write ( number + " ▁ is ▁ lychrel ? ▁ " + isLychrel ( number ) ) ; } }
using System ; class GFG { static int findRectNum ( int n ) { return n * ( n + 1 ) ; } public static void Main ( ) { int n = 6 ; Console . Write ( findRectNum ( n ) ) ; } }
using System ; class Muller1 { static int MAX_ITERATIONS = 10000 ; static double f ( double x ) { return 1 * Math . Pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ; } static void Muller ( double a , double b , double c ) { int i ; double res ; for ( i = 0 ; ; ++ i ) { double f1 = f ( a ) ; double f2 = f ( b ) ; double f3 = f ( c ) ; double d1 = f1 - f3 ; double d2 = f2 - f3 ; double h1 = a - c ; double h2 = b - c ; double a0 = f3 ; double a1 = ( ( ( d2 * Math . Pow ( h1 , 2 ) ) - ( d1 * Math . Pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; double a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; double x = ( ( - 2 * a0 ) / ( a1 + Math . Abs ( Math . Sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; double y = ( ( - 2 * a0 ) / ( a1 - Math . Abs ( Math . Sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; if ( x >= y ) res = x + c ; else res = y + c ; double m = res * 100 ; double n = c * 100 ; m = Math . Floor ( m ) ; n = Math . Floor ( n ) ; if ( m == n ) break ; a = b ; b = c ; c = res ; if ( i > MAX_ITERATIONS ) { Console . WriteLine ( " Root ▁ cannot ▁ be ▁ found ▁ using " + " ▁ Muller ' s ▁ method " ) ; break ; } } if ( i <= MAX_ITERATIONS ) Console . WriteLine ( " The ▁ value ▁ of ▁ the ▁ root ▁ is ▁ " + Math . Round ( res , 4 ) ) ; } static void Main ( ) { double a = 0 , b = 1 , c = 2 ; Muller ( a , b , c ) ; } }
using System ; using System . Collections ; class GFG { static int MAX = 100001 ; static ArrayList p = new ArrayList ( ) ; static void sieve ( ) { int [ ] isPrime = new int [ MAX + 1 ] ; for ( int i = 2 ; i <= MAX ; i ++ ) { if ( isPrime [ i ] == 0 ) { p . Add ( i ) ; for ( int j = 2 ; i * j <= MAX ; j ++ ) isPrime [ i * j ] = 1 ; } } } static int phi ( int n ) { int res = n ; for ( int i = 0 ; ( int ) p [ i ] * ( int ) p [ i ] <= n ; i ++ ) { if ( n % ( int ) p [ i ] == 0 ) { res -= ( res / ( int ) p [ i ] ) ; while ( n % ( int ) p [ i ] == 0 ) n /= ( int ) p [ i ] ; } } if ( n > 1 ) res -= ( res / n ) ; return res ; } static void Main ( ) { sieve ( ) ; Console . WriteLine ( phi ( 11 ) ) ; Console . WriteLine ( phi ( 21 ) ) ; Console . WriteLine ( phi ( 31 ) ) ; Console . WriteLine ( phi ( 41 ) ) ; Console . WriteLine ( phi ( 51 ) ) ; Console . WriteLine ( phi ( 61 ) ) ; Console . WriteLine ( phi ( 91 ) ) ; Console . WriteLine ( phi ( 101 ) ) ; } }
using System ; public class GFG { static void nthprimedigitsnumber ( long n ) { long len = 1 ; long prev_count = 0 ; while ( true ) { long curr_count = ( long ) ( prev_count + Math . Pow ( 4 , len ) ) ; if ( prev_count < n && curr_count >= n ) break ; len ++ ; prev_count = curr_count ; } for ( int i = 1 ; i <= len ; i ++ ) { for ( long j = 1 ; j <= 4 ; j ++ ) { if ( prev_count + Math . Pow ( 4 , len - i ) < n ) prev_count += ( long ) Math . Pow ( 4 , len - i ) ; else { if ( j == 1 ) Console . Write ( "2" ) ; else if ( j == 2 ) Console . Write ( "3" ) ; else if ( j == 3 ) Console . Write ( "5" ) ; else if ( j == 4 ) Console . Write ( "7" ) ; break ; } } } Console . WriteLine ( ) ; } public static void Main ( ) { nthprimedigitsnumber ( 10 ) ; nthprimedigitsnumber ( 21 ) ; } }
using System ; class GFG { static int cassini ( int n ) { return ( n & 1 ) != 0 ? - 1 : 1 ; } public static void Main ( ) { int n = 5 ; Console . Write ( cassini ( n ) ) ; } }
using System ; class GFG { static bool findNoIsDivisibleOrNot ( int [ ] a , int n ) { for ( int i = 0 ; i < a . Length ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; } public static void Main ( ) { int [ ] a = { 14 , 12 , 4 , 18 } ; int n = 2 ; if ( findNoIsDivisibleOrNot ( a , n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int factorial ( int n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } static void printRange ( int n ) { int a = factorial ( n + 2 ) + 2 ; int b = a + n - 1 ; Console . WriteLine ( " [ " + a + " , ▁ " + b + " ] " ) ; } public static void Main ( ) { int n = 3 ; printRange ( n ) ; } }
using System ; public class GFG { static long findMinValue ( long [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { val += ( double ) ( Math . Log ( ( double ) ( arr [ i ] ) ) ) ; } long left = arr [ 0 ] , right = arr [ n - 1 ] ; long ans = 0 ; while ( left <= right ) { long mid = ( left + right ) / 2 ; double temp = ( double ) n * ( double ) ( Math . Log ( ( double ) ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else { left = mid + 1 ; } } return ans ; } static public void Main ( ) { long [ ] arr = { 4 , 2 , 1 , 10 , 6 } ; int n = arr . Length ; Console . WriteLine ( findMinValue ( arr , n ) ) ; } }
using System ; class Test { static int sumOfTermsInNthRow ( int n ) { int sum = ( int ) ( n * ( 2 * Math . Pow ( n , 2 ) + 1 ) ) ; return sum ; } public static void Main ( ) { int n = 4 ; Console . Write ( " Sum ▁ of ▁ all ▁ the ▁ terms ▁ in ▁ nth ▁ row ▁ = ▁ " + sumOfTermsInNthRow ( n ) ) ; } }
using System ; public class GFG { static int firstDigit ( int x ) { while ( x >= 10 ) x = x / 10 ; return x ; } public static void Main ( ) { Console . WriteLine ( firstDigit ( 12345 ) ) ; Console . WriteLine ( firstDigit ( 5432 ) ) ; } }
using System ; public class GFG { static int getOccurence ( int n , int d ) { int result = 0 ; int itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && itr / 10 == d ) { result ++ ; itr ++ ; } else if ( itr / 10 == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; } public static void Main ( ) { int n = 11 , d = 1 ; Console . Write ( getOccurence ( n , d ) ) ; } }
using System ; class GFG { static void cal_cos ( float n ) { float accuracy = ( float ) 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( float ) ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . Cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= cosval - cosx ) ; Console . WriteLine ( cosx ) ; } static void Main ( ) { float n = 30 ; cal_cos ( n ) ; } }
using System ; using System . Collections ; class GFG { static ArrayList v = new ArrayList ( ) ; static void multiply ( int x ) { int carry = 0 ; int size = v . Count ; for ( int i = 0 ; i < size ; i ++ ) { int res = carry + ( int ) v [ i ] * x ; v [ i ] = res % 10 ; carry = res / 10 ; } while ( carry != 0 ) { v . Add ( carry % 10 ) ; carry /= 10 ; } } static int findSumOfDigits ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) multiply ( i ) ; int sum = 0 ; int size = v . Count ; for ( int i = 0 ; i < size ; i ++ ) sum += ( int ) v [ i ] ; return sum ; } static void Main ( ) { int n = 1000 ; Console . WriteLine ( findSumOfDigits ( n ) ) ; } }
using System ; class GFG { static void printOtherSides ( int n ) { if ( n % 2 != 0 ) { if ( n == 1 ) Console . WriteLine ( " - 1" ) ; else { int b = ( n * n - 1 ) / 2 ; int c = ( n * n + 1 ) / 2 ; Console . Write ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } else { if ( n == 2 ) Console . Write ( " - 1" ) ; else { int b = n * n / 4 - 1 ; int c = n * n / 4 + 1 ; Console . Write ( " b ▁ = ▁ " + b + " , ▁ c ▁ = ▁ " + c ) ; } } } public static void Main ( ) { int a = 3 ; printOtherSides ( a ) ; } }
using System ; class GFG { static int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; } public static void Main ( ) { int n = 36 ; int res = makeOdd ( n ) ; Console . Write ( res ) ; } }
using System ; class GFG { static int getTotalXorOfSubarrayXors ( int [ ] arr , int N ) { if ( N % 2 == 0 ) return 0 ; int res = 0 ; for ( int i = 0 ; i < N ; i += 2 ) res ^= arr [ i ] ; return res ; } static void Main ( ) { int [ ] arr = { 3 , 5 , 2 , 4 , 6 } ; int N = arr . Length ; Console . Write ( getTotalXorOfSubarrayXors ( arr , N ) ) ; } }
using System ; class Test { static int countIterations ( int [ ] arr , int n ) { bool oneFound = false ; int res = 0 ; for ( int i = 0 ; i < n ; ) { if ( arr [ i ] == 1 ) oneFound = true ; while ( i < n && arr [ i ] == 1 ) i ++ ; int count_zero = 0 ; while ( i < n && arr [ i ] == 0 ) { count_zero ++ ; i ++ ; } if ( oneFound == false && i == n ) return - 1 ; int curr_count ; if ( i < n && oneFound == true ) { if ( ( count_zero & 1 ) == 0 ) curr_count = count_zero / 2 ; else curr_count = ( count_zero + 1 ) / 2 ; count_zero = 0 ; } else { curr_count = count_zero ; count_zero = 0 ; } res = Math . Max ( res , curr_count ) ; } return res ; } public static void Main ( ) { int [ ] arr = { 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 } ; Console . Write ( countIterations ( arr , arr . Length ) ) ; } }
using System ; class GfG { static void printConsecutive ( int last , int first ) { Console . Write ( first ++ ) ; for ( int x = first ; x <= last ; x ++ ) Console . Write ( " ▁ + ▁ " + x ) ; } static void findConsecutive ( int N ) { for ( int last = 1 ; last < N ; last ++ ) { for ( int first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { Console . Write ( N + " ▁ = ▁ " ) ; printConsecutive ( last , first + 1 ) ; return ; } } } Console . Write ( " - 1" ) ; } public static void Main ( ) { int n = 12 ; findConsecutive ( n ) ; } }
using System ; class GFG { static int printNthElement ( int n ) { int [ ] arr = new int [ n + 1 ] ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( int i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; } public static void Main ( ) { int n = 6 ; Console . Write ( printNthElement ( n ) ) ; } }
using System ; class MaxSum { static int maxSumLCM ( int n ) { int max_sum = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; } public static void Main ( String [ ] args ) { int n = 2 ; Console . Write ( maxSumLCM ( n ) ) ; } }
using System ; class GFG { public static void Main ( ) { double n = 12 ; Console . Write ( Math . Sqrt ( n ) ) ; } }
using System ; class GFG { public static int findMaxValue ( ) { int res = 2 ; long fact = 2 ; while ( true ) { if ( fact < 0 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; } public static void Main ( ) { Console . Write ( " Maximum ▁ value ▁ of " + " ▁ integer ▁ " + findMaxValue ( ) ) ; } }
using System ; class GFG { static bool func ( int [ ] a , int k ) { for ( int i = 0 ; i < a . Length ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; } public static void Main ( ) { int [ ] a = { 14 , 27 , 38 , 76 , 84 } ; int k = 19 ; bool res = func ( a , k ) ; Console . Write ( res ) ; } }
using System ; class GFG { static String tidyNum ( String str1 , int len ) { char [ ] str = str1 . ToCharArray ( ) ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( int j = i + 1 ; j < len ; j ++ ) str [ j ] = '9' ; } } string s = new string ( str ) ; return s ; } static void Main ( ) { String str = "11333445538" ; int len = str . Length ; Console . WriteLine ( tidyNum ( str , len ) ) ; } }
using System ; class GfG { static int findCount ( int m , int n ) { int num1 = 0 ; for ( int i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; int num2 = 0 ; for ( int i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; } public static void Main ( ) { int m = 2 , n = 6 ; Console . Write ( findCount ( m , n ) ) ; } }
using System ; class GFG { static int findNthEvenDigitNumber ( int n ) { int count = 0 ; for ( int i = 0 ; ; i ++ ) { int curr = i ; bool isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = curr / 10 ; } if ( isCurrEvenDigit == true ) count ++ ; if ( count == n ) return i ; } } public static void Main ( ) { Console . WriteLine ( findNthEvenDigitNumber ( 2 ) ) ; Console . WriteLine ( findNthEvenDigitNumber ( 10 ) ) ; } }
using System ; using System . Collections ; class GFG { static int findNthEvenDigitNumber ( int n ) { if ( n == 1 ) { return 0 ; } ArrayList v = new ArrayList ( ) ; n = n - 1 ; while ( n > 0 ) { v . Add ( n % 5 ) ; n = n / 5 ; } int result = 0 ; for ( int i = v . Count - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + ( int ) v [ i ] ; } return 2 * result ; } public static void Main ( ) { Console . WriteLine ( findNthEvenDigitNumber ( 2 ) ) ; Console . WriteLine ( findNthEvenDigitNumber ( 10 ) ) ; } }
using System ; class IsDivisible { static bool isDivisibleBy25 ( String str ) { int n = str . Length ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - '0' == 0 && str [ n - 2 ] - '0' == 0 ) || ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 25 == 0 ) ; } public static void Main ( ) { String str = "76955" ; if ( isDivisibleBy25 ( str ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static bool check ( String str ) { int n = str . Length ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - '0' ) * 100 + ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 16 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; int fourth_last = str [ n - 4 ] - '0' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; } public static void Main ( ) { String str = "769528" ; if ( check ( str ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No ▁ " ) ; } }
using System ; class GFG { static int findIndex ( int n ) { if ( n <= 1 ) return n ; int a = 0 , b = 1 , c = 1 ; int res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; } public static void Main ( ) { int result = findIndex ( 21 ) ; Console . WriteLine ( result ) ; } }
using System ; class GFG { static int divisorSum ( int N , int K ) { int sum = 0 ; for ( int i = 2 ; i <= Math . Ceiling ( Math . Sqrt ( N ) ) ; i ++ ) if ( N % i == 0 ) sum += ( i + N / i ) ; return sum ; } static bool isPrime ( int n ) { if ( n == 1 n == 0 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isHyperPerfect ( int N , int K ) { int sum = divisorSum ( N , K ) ; if ( ( 1 + K * ( sum ) ) == N ) return true ; else return false ; } static public void Main ( ) { int N1 = 1570153 , K1 = 12 ; int N2 = 321 , K2 = 3 ; if ( isHyperPerfect ( N1 , K1 ) ) Console . WriteLine ( N1 + " ▁ is ▁ " + K1 + " - HyperPerfect " ) ; else Console . WriteLine ( N1 + " ▁ is ▁ not ▁ " + K1 + " - HyperPerfect " ) ; if ( isHyperPerfect ( N2 , K2 ) ) Console . WriteLine ( N2 + " ▁ is ▁ " + K2 + " - HyperPerfect " ) ; else Console . WriteLine ( N2 + " ▁ is ▁ not ▁ " + K2 + " - HyperPerfect " ) ; } }
using System ; class GFG { public static long firstkdigits ( int n , int k ) { double product = n * Math . Log10 ( n ) ; double decimal_part = product - Math . Floor ( product ) ; decimal_part = Math . Pow ( 10 , decimal_part ) ; double digits = Math . Pow ( 10 , k - 1 ) ; return ( ( long ) ( decimal_part * digits ) ) ; } public static void Main ( ) { int n = 1450 ; int k = 6 ; Console . Write ( firstkdigits ( n , k ) ) ; } }
using System ; class GFG { static void printWellOrdered ( int number , int x , int k ) { if ( k == 0 ) { Console . Write ( number + " ▁ " ) ; return ; } for ( int i = ( x + 1 ) ; i < 10 ; i ++ ) printWellOrdered ( number * 10 + i , i , k - 1 ) ; } static void generateWellOrdered ( int k ) { printWellOrdered ( 0 , 0 , k ) ; } public static void Main ( ) { int k = 3 ; generateWellOrdered ( k ) ; } }
using System ; class GFG { static long moduloMultiplication ( long a , long b , long mod ) { a %= mod ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) res = ( res + a ) % mod ; a = ( 2 * a ) % mod ; } return res ; } static void Main ( ) { long a = 10123465234878998 ; long b = 65746311545646431 ; long m = 10005412336548794 ; Console . WriteLine ( moduloMultiplication ( a , b , m ) ) ; } }
using System ; class GFG { static int count2sinRangeAtDigit ( int number , int d ) { int powerOf10 = ( int ) Math . Pow ( 10 , d ) ; int nextPowerOf10 = powerOf10 * 10 ; int right = number % powerOf10 ; int roundDown = number - number % nextPowerOf10 ; int roundup = roundDown + nextPowerOf10 ; int digit = ( number / powerOf10 ) % 10 ; if ( digit < 2 ) { return roundDown / 10 ; } if ( digit == 2 ) { return roundDown / 10 + right + 1 ; } return roundup / 10 ; } static int numberOf2sinRange ( int number ) { string convert ; convert = number . ToString ( ) ; string s = convert ; int len = s . Length ; int count = 0 ; for ( int digit = 0 ; digit < len ; digit ++ ) { count += count2sinRangeAtDigit ( number , digit ) ; } return count ; } public static void Main ( ) { Console . WriteLine ( numberOf2sinRange ( 22 ) ) ; Console . WriteLine ( numberOf2sinRange ( 100 ) ) ; } }
using System ; class GFG { static int findStarNum ( int n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; } public static void Main ( ) { int n = 3 ; Console . Write ( findStarNum ( n ) ) ; } }
using System ; class IsDivisible { static bool isDivisibleBy5 ( String str ) { int n = str . Length ; return ( ( ( str [ n - 1 ] - '0' ) == 0 ) || ( ( str [ n - 1 ] - '0' ) == 5 ) ) ; } public static void Main ( ) { String str = "76955" ; if ( isDivisibleBy5 ( str ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static bool isTidy ( int num ) { int prev = 10 ; while ( num != 0 ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; } public static void Main ( ) { int num = 1556 ; Console . WriteLine ( isTidy ( num ) ? " Yes " : " No " ) ; } }
using System ; class GFG { public static int squareFree ( int n ) { int cnt = 0 ; for ( int i = 1 ; ; i ++ ) { bool isSqFree = true ; for ( int j = 2 ; j * j <= i ; j ++ ) { if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } } if ( isSqFree == true ) { cnt ++ ; if ( cnt == n ) return i ; } } } public static void Main ( ) { int n = 10 ; Console . Write ( " " + squareFree ( n ) ) ; } }
using System ; using System . Collections ; class GFG { static void kFactors ( int n , int k ) { ArrayList P = new ArrayList ( ) ; while ( n % 2 == 0 ) { P . Add ( 2 ) ; n /= 2 ; } for ( int i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; P . Add ( i ) ; } } if ( n > 2 ) P . Add ( n ) ; if ( P . Count < k ) { Console . WriteLine ( " - 1" ) ; return ; } for ( int i = 0 ; i < k - 1 ; i ++ ) Console . Write ( P [ i ] + " , ▁ " ) ; int product = 1 ; for ( int i = k - 1 ; i < P . Count ; i ++ ) product = product * ( int ) P [ i ] ; Console . WriteLine ( product ) ; } static void Main ( ) { int n = 54 , k = 3 ; kFactors ( n , k ) ; } }
using System ; class GFG { static int nondecdigits ( int n ) { int x = 0 ; for ( x = n ; x >= 1 ; x -- ) { int no = x ; int prev_dig = 11 ; bool flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no /= 10 ; } if ( flag == true ) break ; } return x ; } static public void Main ( ) { int n = 200 ; Console . WriteLine ( nondecdigits ( n ) ) ; } }
using System ; class GFG { static void nondecdigits ( string s ) { int m = s . Length ; int [ ] a = new int [ m + 1 ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = ( int ) s [ i ] - ( int ) '0' ; int level = m - 1 ; for ( int i = m - 1 ; i > 0 ; i -- ) { if ( a [ i ] < a [ i - 1 ] ) { a [ i - 1 ] -- ; level = i - 1 ; } } if ( a [ 0 ] != 0 ) { for ( int i = 0 ; i <= level ; i ++ ) Console . Write ( a [ i ] ) ; for ( int i = level + 1 ; i < m ; i ++ ) Console . Write ( "9" ) ; } else { for ( int i = 1 ; i < level ; i ++ ) Console . Write ( a [ i ] ) ; for ( int i = level + 1 ; i < m ; i ++ ) Console . Write ( "9" ) ; } } static void Main ( ) { string n = "200" ; nondecdigits ( n ) ; } }
using System ; class GFG { static int countDivisors ( int n ) { int cnt = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; else cnt = cnt + 2 ; } } return cnt ; } public static void Main ( ) { Console . WriteLine ( " Total ▁ distinct " + " ▁ divisors ▁ of ▁ 100 ▁ are ▁ : ▁ " + countDivisors ( 100 ) ) ; } }
using System ; class GFG { static bool hasEvenNumberOfFactors ( int n ) { double root_n = Math . Sqrt ( n ) ; if ( ( root_n * root_n ) == n ) return false ; return true ; } static void printStatusOfDoors ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) { if ( hasEvenNumberOfFactors ( i ) ) Console . Write ( " closed " + " ▁ " ) ; else Console . Write ( " open " + " ▁ " ) ; } } static public void Main ( ) { int n = 5 ; printStatusOfDoors ( n ) ; } }
using System ; public class GFG { static bool validate ( long n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long temp = n ; int count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; } static public void Main ( String [ ] args ) { long n = 1552793 ; if ( validate ( n ) ) Console . WriteLine ( " True " ) ; else Console . WriteLine ( " False " ) ; } }
using System ; class GFG { static bool divisibleBy36 ( String num ) { int l = num . Length ; if ( l == 0 ) return false ; if ( l == 1 && num [ 0 ] != '0' ) return false ; int two_digit_num = ( num [ l - 2 ] - '0' ) * 10 + ( num [ l - 1 ] - '0' ) ; if ( two_digit_num % 4 != 0 ) return false ; int sum = 0 ; for ( int i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - '0' ) ; if ( sum % 9 != 0 ) return false ; return true ; } public static void Main ( ) { String num = "92567812197966231384" ; if ( divisibleBy36 ( num ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class IsDivisible { static bool check ( String str ) { int n = str . Length ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - '0' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - '0' ) * 10 + ( str [ n - 1 ] - '0' ) ) % 8 == 0 ) ; int last = str [ n - 1 ] - '0' ; int second_last = str [ n - 2 ] - '0' ; int third_last = str [ n - 3 ] - '0' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; } public static void Main ( ) { String str = "76952" ; if ( check ( str ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int countDigits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n / 10 ; } return count ; } static int checkPrime ( int n ) { if ( n <= 1 ) return - 1 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return - 1 ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return - 1 ; return 0 ; } static void printPrimePoints ( int n ) { int count = countDigits ( n ) ; if ( count == 1 count == 2 ) { Console . Write ( " - 1" ) ; return ; } bool found = false ; for ( int i = 1 ; i < ( count - 1 ) ; i ++ ) { int left = n / ( ( int ) Math . Pow ( 10 , count - i ) ) ; int right = n % ( ( int ) Math . Pow ( 10 , count - i - 1 ) ) ; if ( checkPrime ( left ) == 0 && checkPrime ( right ) == 0 ) { Console . Write ( i + " ▁ " ) ; found = true ; } } if ( found == false ) Console . Write ( " - 1" ) ; } static public void Main ( ) { int n = 2317 ; printPrimePoints ( n ) ; } }
using System ; class GFG { static int power ( int num , int n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , n / 2 ) * power ( num , n / 2 ) ; else return num * power ( num , n / 2 ) * power ( num , n / 2 ) ; } static int checkRecursive ( int x , int n , int curr_num , int curr_sum ) { int results = 0 ; int p = power ( curr_num , n ) ; while ( p + curr_sum < x ) { results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) ; curr_num ++ ; p = power ( curr_num , n ) ; } if ( p + curr_sum == x ) results ++ ; return results ; } public static void Main ( ) { int x = 10 , n = 2 ; System . Console . WriteLine ( checkRecursive ( x , n , 1 , 0 ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void printGenerators ( int n ) { Console . Write ( "1 ▁ " ) ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) Console . Write ( i + " ▁ " ) ; } public static void Main ( String [ ] args ) { int n = 10 ; printGenerators ( n ) ; } }
using System ; class GFG { static bool check ( string str ) { int n = str . Length ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; } public static void Main ( ) { string str = "1332" ; if ( check ( str ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int MAX = 100001 ; static int [ ] perfectDiv = new int [ MAX ] ; static void precomputeCounts ( ) { for ( int i = 1 ; i * i < MAX ; ++ i ) { for ( int j = i * i ; j < MAX ; j += i * i ) ++ perfectDiv [ j ] ; } } static int countPerfectDivisors ( int n ) { return perfectDiv [ n ] ; } public static void Main ( ) { precomputeCounts ( ) ; int n = 16 ; Console . WriteLine ( " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; n = 12 ; Console . WriteLine ( " Total ▁ perfect ▁ divisors ▁ of ▁ " + n + " ▁ = ▁ " + countPerfectDivisors ( n ) ) ; } }
using System ; using System . Collections ; class GFG { static int MAXN = 100001 ; static int [ ] spf = new int [ MAXN ] ; static void sieve ( ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static ArrayList getFactorization ( int x ) { ArrayList ret = new ArrayList ( ) ; while ( x != 1 ) { ret . Add ( spf [ x ] ) ; x = x / spf [ x ] ; } return ret ; } public static void Main ( ) { sieve ( ) ; int x = 12246 ; Console . Write ( " prime ▁ factorization ▁ for ▁ " + x + " ▁ : ▁ " ) ; ArrayList p = getFactorization ( x ) ; for ( int i = 0 ; i < p . Count ; i ++ ) Console . Write ( p [ i ] + " ▁ " ) ; Console . WriteLine ( " " ) ; } }
using System ; using System . Linq ; public class GFG { static int largestGCDSubsequence ( int [ ] arr , int n ) { int ans = 0 ; int maxele = arr . Max ( ) ; for ( int i = 2 ; i <= maxele ; ++ i ) { int count = 0 ; for ( int j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . Max ( ans , count ) ; } return ans ; } public static void Main ( ) { int [ ] arr = { 3 , 6 , 2 , 5 , 4 } ; int size = arr . Length ; Console . Write ( largestGCDSubsequence ( arr , size ) ) ; } }
using System ; class GFG { static int MAX = 1000006 ; static void sieve ( int [ ] count ) { for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( count [ i ] == 0 ) { for ( int j = 2 * i ; j < MAX ; j += i ) count [ j ] ++ ; count [ i ] = 1 ; } } } static int query ( int [ ] count , int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += count [ i ] ; return sum ; } public static void Main ( ) { int [ ] count = new int [ MAX ] ; sieve ( count ) ; Console . Write ( query ( count , 6 , 10 ) + " ▁ " + query ( count , 1 , 5 ) ) ; } }
using System ; class GFG { static void generateNumbers ( int [ ] factor , int n , int k ) { int [ ] next = new int [ k ] ; for ( int i = 0 ; i < n ; ) { int toincrement = 0 ; for ( int j = 0 ; j < k ; j ++ ) if ( next [ j ] < next [ toincrement ] ) toincrement = j ; if ( output != next [ toincrement ] ) { output = next [ toincrement ] ; Console . Write ( next [ toincrement ] + " ▁ " ) ; i ++ ; } next [ toincrement ] += factor [ toincrement ] ; } } static public void Main ( ) { int [ ] factor = { 3 , 5 , 7 } ; int n = 10 ; int k = factor . Length ; generateNumbers ( factor , n , k ) ; } }
using System ; class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static int multiplicativeOrder ( int A , int N ) { if ( GCD ( A , N ) != 1 ) return - 1 ; int result = 1 ; int K = 1 ; while ( K < N ) { result = ( result * A ) % N ; if ( result == 1 ) return K ; K ++ ; } return - 1 ; } public static void Main ( ) { int A = 4 , N = 7 ; Console . Write ( multiplicativeOrder ( A , N ) ) ; } }
using System ; class GFG { static int sumOfRange ( int a , int b ) { int i = ( a * ( a + 1 ) ) >> 1 ; int j = ( b * ( b + 1 ) ) >> 1 ; return ( i - j ) ; } static int sumofproduct ( int n ) { int sum = 0 ; int root = ( int ) Math . Sqrt ( n ) ; for ( int i = 1 ; i <= root ; i ++ ) { int up = n / i ; int low = Math . Max ( n / ( i + 1 ) , root ) ; sum += ( i * sumOfRange ( up , low ) ) ; sum += ( i * ( n / i ) ) ; } return sum ; } static public void Main ( String [ ] args ) { int n = 10 ; Console . WriteLine ( sumofproduct ( n ) ) ; } }
using System ; class GFG { static int minPower ( int n , int x ) { if ( x == 1 ) return n ; int ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n /= x ; } return ans ; } public static void Main ( ) { int n = 5 , x = 3 ; Console . WriteLine ( minPower ( n , x ) ) ; } }
using System ; class GFG { static int calSum ( int n ) { int a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; int sum = 5 ; while ( n > 2 ) { int d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; } public static void Main ( ) { int n = 9 ; Console . WriteLine ( calSum ( n ) ) ; } }
using System ; class GFG { static int findKHCF ( int x , int y , int k ) { int small = Math . Min ( x , y ) ; int count = 1 ; for ( int i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; } public static void Main ( ) { int x = 4 , y = 24 , k = 3 ; Console . Write ( findKHCF ( x , y , k ) ) ; } }
using System ; class GFG { static int findMinNumber ( int n ) { int count = 0 , ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 == 1 ) ans *= 2 ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 == 1 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; } public static void Main ( ) { int n = 72 ; Console . WriteLine ( findMinNumber ( n ) ) ; } }
using System ; class GFG { static bool isToOne ( int n ) { return ( n > 0 ) ; } public static void Main ( ) { int n = 5 ; if ( isToOne ( n ) == true ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void findgcd ( int n , int x , int y ) { int g = gcd ( x , y ) ; for ( int i = 0 ; i < g ; i ++ ) Console . Write ( n ) ; } public static void Main ( ) { int n = 123 , x = 5 , y = 2 ; findgcd ( n , x , y ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; } static int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; } static int countFactorialXNotY ( int x , int y ) { return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) ; } public static void Main ( ) { int x = 15 , y = 25 ; Console . Write ( countFactorialXNotY ( x , y ) ) ; } }
using System ; class GFG { static int firstFactorialDivisibleNumber ( int x ) { int fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; } public static void Main ( ) { int x = 16 ; Console . Write ( firstFactorialDivisibleNumber ( x ) ) ; } }
using System ; class GFG { static bool SieveOfEratosthenes ( int n , bool [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } return false ; } static void findPrimePair ( int n ) { bool [ ] isPrime = new bool [ n + 1 ] ; SieveOfEratosthenes ( n , isPrime ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPrime [ i ] && isPrime [ n - i ] ) { Console . Write ( i + " ▁ " + ( n - i ) ) ; return ; } } } public static void Main ( ) { int n = 74 ; findPrimePair ( n ) ; } }
using System ; class GFG { public static int getFirstDigit ( int x ) { while ( x >= 10 ) x /= 10 ; return x ; } public static int getCountWithSameStartAndEndFrom1 ( int x ) { if ( x < 10 ) return x ; int tens = x / 10 ; int res = tens + 9 ; int firstDigit = getFirstDigit ( x ) ; int lastDigit = x % 10 ; if ( lastDigit < firstDigit ) res -- ; return res ; } public static int getCountWithSameStartAndEnd ( int start , int end ) { return getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ; } public static void Main ( ) { int start = 5 , end = 40 ; Console . Write ( getCountWithSameStartAndEnd ( start , end ) ) ; } }
using System ; class GFG { static void sieveOfEratosthenes ( int n , bool [ ] isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( int i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } static bool rightTruPrime ( int n ) { bool [ ] isPrime = new bool [ n + 1 ] ; sieveOfEratosthenes ( n , isPrime ) ; while ( n != 0 ) { if ( isPrime [ n ] ) n = n / 10 ; else return false ; } return true ; } public static void Main ( ) { int n = 59399 ; if ( rightTruPrime ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static void SieveOfEratosthenes ( int n , bool [ ] prime ) { for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } static void mersennePrimes ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; SieveOfEratosthenes ( n , prime ) ; for ( int k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { long num = ( 1 << k ) - 1 ; if ( prime [ ( int ) ( num ) ] ) Console . Write ( num + " ▁ " ) ; } } public static void Main ( ) { int n = 31 ; Console . WriteLine ( " Mersenne ▁ prime ▁ numbers " + " ▁ smaller ▁ than ▁ or ▁ equal ▁ to ▁ " + n ) ; mersennePrimes ( n ) ; } }
using System ; class GFG { static int findSum ( int N , int K ) { int ans = 0 ; for ( int i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; } static public void Main ( ) { int N = 10 , K = 2 ; Console . WriteLine ( findSum ( N , K ) ) ; } }
using System ; class GFG { static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; } static public void Main ( ) { int N = 10 , K = 2 ; Console . WriteLine ( findSum ( N , K ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int findnum ( String str ) { int n = str . Length ; int count_after_dot = 0 ; bool dot_seen = false ; int num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] != ' . ' ) { num = num * 10 + ( str [ i ] - '0' ) ; if ( dot_seen == true ) count_after_dot ++ ; } else dot_seen = true ; } if ( dot_seen == false ) return 1 ; int dem = ( int ) Math . Pow ( 10 , count_after_dot ) ; return ( dem / gcd ( num , dem ) ) ; } public static void Main ( ) { String str = "5.125" ; Console . Write ( findnum ( str ) ) ; } }
using System ; class GFG { static int maxHandshake ( int n ) { return ( n * ( n - 1 ) ) / 2 ; } public static void Main ( ) { int n = 10 ; Console . Write ( maxHandshake ( n ) ) ; } }
using System ; class GFG { static bool divisible ( string N , int digit ) { int ans = 0 ; for ( int i = 0 ; i < N . Length ; i ++ ) { ans = ( ans * 10 + ( N [ i ] - '0' ) ) ; ans %= digit ; } return ( ans == 0 ) ; } static int allDigits ( string N ) { bool [ ] divide = new bool [ 10 ] ; for ( int i = 0 ; i < divide . Length ; i ++ ) { divide [ i ] = false ; } divide [ 1 ] = true ; for ( int digit = 2 ; digit <= 9 ; digit ++ ) { if ( divisible ( N , digit ) ) divide [ digit ] = true ; } int result = 0 ; for ( int i = 0 ; i < N . Length ; i ++ ) { if ( divide [ N [ i ] - '0' ] == true ) result ++ ; } return result ; } public static void Main ( ) { string N = "122324" ; Console . Write ( allDigits ( N ) ) ; } }
using System ; public class GFG { static int countNums ( int n , int x , int y ) { bool [ ] arr = new bool [ n + 1 ] ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; int result = 0 ; for ( int i = Math . Min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; } static public void Main ( ) { int n = 15 , x = 5 , y = 7 ; Console . WriteLine ( countNums ( n , x , y ) ) ; } }
using System ; class GFG { static int reverse ( int x ) { int rev = 0 ; while ( x > 0 ) { rev = ( rev * 10 ) + x % 10 ; x = x / 10 ; } return rev ; } static void printEmirp ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { int rev = reverse ( p ) ; if ( p != rev && rev <= n && prime [ rev ] ) { Console . Write ( p + " ▁ " + rev + " ▁ " ) ; prime [ rev ] = false ; } } } } public static void Main ( ) { int n = 100 ; printEmirp ( n ) ; } }
using System ; class GFG { static int getSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= ( Math . Sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; { sum = sum + i ; sum = sum + ( n / i ) ; } } } sum = sum - n ; return sum ; } static bool checkAbundant ( int n ) { return ( getSum ( n ) > n ) ; } public static void Main ( ) { if ( checkAbundant ( 12 ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; if ( checkAbundant ( 15 ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . Sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } public static void Main ( ) { if ( isPowerful ( 20 ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; if ( isPowerful ( 27 ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static int divisorsSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= ( Math . Sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; } static bool isDeficient ( int n ) { return ( divisorsSum ( n ) < ( 2 * n ) ) ; } public static void Main ( ) { string var = isDeficient ( 12 ) ? " YES " : " NO " ; Console . WriteLine ( var ) ; string var1 = isDeficient ( 15 ) ? " YES " : " NO " ; Console . WriteLine ( var1 ) ; } }
using System ; using System . Collections ; class Test { static int MAX = 10000 ; static ArrayList primes = new ArrayList ( 10 ) ; static void sieveSundaram ( ) { bool [ ] marked = new bool [ MAX / 2 + 100 ] ; for ( int i = 1 ; i <= ( Math . Sqrt ( MAX ) - 1 ) / 2 ; i ++ ) for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j = j + 2 * i + 1 ) marked [ j ] = true ; primes . Add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) if ( marked [ i ] == false ) primes . Add ( 2 * i + 1 ) ; } static bool isSmith ( int n ) { int original_no = n ; int pDigitSum = 0 ; for ( int i = 0 ; ( int ) primes [ i ] <= n / 2 ; i ++ ) { while ( n % ( int ) primes [ i ] == 0 ) { int p = ( int ) primes [ i ] ; n = n / p ; while ( p > 0 ) { pDigitSum += ( p % 10 ) ; p = p / 10 ; } } } if ( n != 1 && n != original_no ) { while ( n > 0 ) { pDigitSum = pDigitSum + n % 10 ; n = n / 10 ; } } int sumDigits = 0 ; while ( original_no > 0 ) { sumDigits = sumDigits + original_no % 10 ; original_no = original_no / 10 ; } return ( pDigitSum == sumDigits ) ; } public static void Main ( ) { sieveSundaram ( ) ; Console . WriteLine ( " Printing ▁ first ▁ few ▁ Smith ▁ Numbers " + " ▁ using ▁ isSmith ( ) " ) ; for ( int i = 1 ; i < 500 ; i ++ ) if ( isSmith ( i ) ) Console . Write ( i + " ▁ " ) ; } }
using System ; class GFG { static bool iskaprekar ( int n ) { if ( n == 1 ) return true ; int sq_n = n * n ; int count_digits = 0 ; while ( sq_n != 0 ) { count_digits ++ ; sq_n /= 10 ; } sq_n = n * n ; for ( int r_digits = 1 ; r_digits < count_digits ; r_digits ++ ) { int eq_parts = ( int ) Math . Pow ( 10 , r_digits ) ; if ( eq_parts == n ) continue ; int sum = sq_n / eq_parts + sq_n % eq_parts ; if ( sum == n ) return true ; } return false ; } public static void Main ( ) { Console . WriteLine ( " Printing ▁ first ▁ few ▁ " + " Kaprekar ▁ Numbers ▁ using ▁ iskaprekar ( ) " ) ; for ( int i = 1 ; i < 10000 ; i ++ ) if ( iskaprekar ( i ) ) Console . Write ( i + " ▁ " ) ; } }
using System ; using System . Collections ; class GFG { static bool isKeith ( int x ) { ArrayList terms = new ArrayList ( ) ; while ( temp > 0 ) { terms . Add ( temp % 10 ) ; temp = temp / 10 ; n ++ ; } terms . Reverse ( ) ; int next_term = 0 , i = n ; while ( next_term < x ) { next_term = 0 ; for ( int j = 1 ; j <= n ; j ++ ) next_term += ( int ) terms [ i - j ] ; terms . Add ( next_term ) ; i ++ ; } return ( next_term == x ) ; } public static void Main ( ) { if ( isKeith ( 14 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; if ( isKeith ( 12 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; if ( isKeith ( 197 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class Test { static bool canBeSumofConsec ( int n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; } public static void Main ( ) { int n = 15 ; Console . Write ( canBeSumofConsec ( n ) ? " True " : " False " ) ; } }
using System ; class GFG { static int evenFibSum ( int limit ) { if ( limit < 2 ) return 0 ; long ef1 = 0 , ef2 = 2 ; long sum = ef1 + ef2 ; while ( ef2 <= limit ) { long ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return ( int ) sum ; } public static void Main ( ) { int limit = 400 ; Console . Write ( evenFibSum ( limit ) ) ; } }
using System ; class GFG { static bool isPerfect ( int n ) { int s = ( int ) ( Math . Sqrt ( n ) ) ; return ( s * s == n ) ; } static int divisorsCount ( int n ) { int count = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count += 1 ; else count += 2 ; } } return count ; } static int kDivisors ( int a , int b , int k ) { int count = 0 ; for ( int i = a ; i <= b ; i ++ ) { if ( isPerfect ( i ) ) if ( divisorsCount ( i ) == k ) count ++ ; } return count ; } public static void Main ( String [ ] args ) { int a = 21 , b = 149 , k = 333 ; Console . Write ( kDivisors ( a , b , k ) ) ; } }
using System ; class GFG { static long evenFib ( int n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; } public static void Main ( ) { int n = 7 ; Console . Write ( evenFib ( n ) ) ; } }
using System . Collections . Generic ; class GFG { static int MAX = 3000 ; public static int smartNumber ( int n ) { int [ ] primes = new int [ MAX ] ; List < int > result = new List < int > ( ) ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( primes [ i ] == 0 ) { primes [ i ] = 1 ; for ( int j = i * 2 ; j < MAX ; j = j + i ) { primes [ j ] -= 1 ; if ( ( primes [ j ] + 3 ) == 0 ) result . Add ( j ) ; } } } result . Sort ( ) ; return result [ n - 1 ] ; } public static void Main ( ) { int n = 50 ; System . Console . WriteLine ( smartNumber ( n ) ) ; } }
using System ; class GFG { static int countSteps ( int x , int y ) { if ( x % y == 0 ) return x / y ; return x / y + countSteps ( y , x % y ) ; } static public void Main ( ) { int x = 100 , y = 19 ; Console . WriteLine ( countSteps ( x , y ) ) ; } }
using System ; class GFG { static int findCountOfSolutions ( int n , int p ) { int ans = 0 ; for ( int x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { int last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; } static public void Main ( ) { int n = 10 ; int p = 5 ; Console . WriteLine ( findCountOfSolutions ( n , p ) ) ; } }
using System ; class GFG { static int kaprekarRec ( int n , int prev ) { if ( n == 0 ) return 0 ; prev = n ; int [ ] digits = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) { digits [ i ] = n % 10 ; n = n / 10 ; } Array . Sort ( digits ) ; int asc = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) asc = asc * 10 + digits [ i ] ; Array . Sort ( digits ) ; int desc = 0 ; for ( int i = 3 ; i >= 0 ; i -- ) desc = desc * 10 + digits [ i ] ; int diff = Math . Abs ( asc - desc ) ; if ( diff == prev ) return diff ; return kaprekarRec ( diff , prev ) ; } static int kaprekar ( int n ) { int prev = 0 ; return kaprekarRec ( n , prev ) ; } public static void Main ( ) { System . Console . WriteLine ( kaprekar ( 1000 ) ) ; System . Console . WriteLine ( kaprekar ( 1112 ) ) ; System . Console . WriteLine ( kaprekar ( 9812 ) ) ; } }
using System ; class GFG { static float sqroot ( float s ) { int pSq = 0 ; int N = 0 ; for ( int i = ( int ) ( s ) ; i > 0 ; i -- ) { for ( int j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } float d = s - pSq ; float P = d / ( 2.0f * N ) ; float A = N + P ; float sqrt_of_s = A - ( ( P * P ) / ( 2.0f * A ) ) ; return sqrt_of_s ; } public static void Main ( ) { float num = 9.2345f ; float sqroot_of_num = sqroot ( num ) ; Console . Write ( " Square ▁ root ▁ of ▁ " + num + " ▁ = ▁ " + Math . Round ( sqroot_of_num * 100000.0 ) / 100000.0 ) ; } }
class GFG { static int power ( int x , int a ) { int res = 1 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; } static int breakInteger ( int N ) { if ( N == 2 ) return 1 ; if ( N == 3 ) return 2 ; int maxProduct = - 1 ; switch ( N % 3 ) { case 0 : maxProduct = power ( 3 , N / 3 ) ; break ; case 1 : maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; break ; case 2 : maxProduct = 2 * power ( 3 , N / 3 ) ; break ; } return maxProduct ; } public static void Main ( ) { int maxProduct = breakInteger ( 10 ) ; System . Console . WriteLine ( maxProduct ) ; } }
using System ; class GFG { static int digSum ( int n ) { int sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return sum ; } public static void Main ( ) { int n = 1234 ; Console . Write ( digSum ( n ) ) ; } }
using System ; class GFG { static int digSum ( int n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } public static void Main ( ) { int n = 9999 ; Console . Write ( digSum ( n ) ) ; } }
using System ; class GFG { static int countMultiples ( int n ) { return n / 3 + n / 7 - n / 21 ; } static public void Main ( ) { Console . WriteLine ( " Count ▁ = ▁ " + countMultiples ( 25 ) ) ; } }
using System ; class GFG { static int Modulo ( int a , char [ ] b ) { int mod = 0 ; for ( int i = 0 ; i < b . Length ; i ++ ) mod = ( mod * 10 + b [ i ] - '0' ) % a ; return mod ; } static int LastDigit ( char [ ] a , char [ ] b ) { int len_a = a . Length , len_b = b . Length ; if ( len_a == 1 && len_b == 1 && b [ 0 ] == '0' && a [ 0 ] == '0' ) return 1 ; if ( len_b == 1 && b [ 0 ] == '0' ) return 1 ; if ( len_a == 1 && a [ 0 ] == '0' ) return 0 ; int exp = ( Modulo ( 4 , b ) == 0 ) ? 4 : Modulo ( 4 , b ) ; int res = ( int ) ( Math . Pow ( a [ len_a - 1 ] - '0' , exp ) ) ; return res % 10 ; } public static void Main ( ) { char [ ] a = "117" . ToCharArray ( ) , b = { '3' } ; Console . Write ( LastDigit ( a , b ) ) ; } }
using System ; class GFG { static long reversDigits ( long num ) { long rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static bool isPalindrome ( long num ) { return ( reversDigits ( num ) == num ) ; } static void ReverseandAdd ( long num ) { long rev_num = 0 ; while ( num <= 4294967295 ) { rev_num = reversDigits ( num ) ; num = num + rev_num ; if ( isPalindrome ( num ) ) { Console . WriteLine ( num ) ; break ; } else if ( num > 4294967295 ) { Console . WriteLine ( " No ▁ palindrome ▁ exist " ) ; } } } public static void Main ( ) { ReverseandAdd ( 195 ) ; ReverseandAdd ( 265 ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( ( ~ a & 1 ) == 1 ) { if ( ( b & 1 ) == 1 ) return gcd ( a >> 1 , b ) ; else return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; } public static void Main ( ) { int a = 34 , b = 17 ; Console . Write ( " Gcd ▁ of ▁ given " + " numbers ▁ is ▁ " + gcd ( a , b ) ) ; } }
using System ; class GFG { static void findNDigitNumsUtil ( int n , int sum , char [ ] ou , int index ) { if ( index > n sum < 0 ) return ; if ( index == n ) { if ( sum == 0 ) { ou [ index ] = ' \0' ; Console . Write ( ou ) ; Console . Write ( " ▁ " ) ; } return ; } for ( int i = 0 ; i <= 9 ; i ++ ) { ou [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , sum - i , ou , index + 1 ) ; } } static void findNDigitNums ( int n , int sum ) { char [ ] ou = new char [ n + 1 ] ; for ( int i = 1 ; i <= 9 ; i ++ ) { ou [ 0 ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , sum - i , ou , 1 ) ; } } public static void Main ( ) { int n = 2 , sum = 3 ; findNDigitNums ( n , sum ) ; } }
using System ; class GFG { static bool oneDigit ( int num ) { return ( num >= 0 && num < 10 ) ; } static bool isPalUtil ( int num , int dupNum ) { if ( oneDigit ( num ) ) return ( num == ( dupNum ) % 10 ) ; if ( ! isPalUtil ( num / 10 , dupNum ) ) return false ; dupNum /= 10 ; return ( num % 10 == ( dupNum ) % 10 ) ; } static bool isPal ( int num ) { if ( num < 0 ) num = - num ; return isPalUtil ( num , dupNum ) ; } static void printPalPrimesLessThanN ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] && isPal ( p ) ) { Console . Write ( p + " ▁ " ) ; } } } public static void Main ( ) { int n = 100 ; Console . Write ( " Palindromic ▁ primes ▁ smaller ▁ than ▁ or ▁ " + " equal ▁ to ▁ are ▁ : STRNEWLINE " , n ) ; printPalPrimesLessThanN ( n ) ; } }
using System ; class GFG { static int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } static void printKAlmostPrimes ( int k , int n ) { for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == k ) { Console . Write ( num + " ▁ " ) ; i ++ ; } } return ; } public static void Main ( ) { int n = 10 , k = 2 ; Console . WriteLine ( " First ▁ " + n + " ▁ " + k + " - almost ▁ prime ▁ numbers ▁ : ▁ " ) ; printKAlmostPrimes ( k , n ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void lowest ( int den3 , int num3 ) { int common_factor = gcd ( num3 , den3 ) ; den3 = den3 / common_factor ; num3 = num3 / common_factor ; System . Console . WriteLine ( num3 + " / " + den3 ) ; } static void addFraction ( int num1 , int den1 , int num2 , int den2 ) { int den3 = gcd ( den1 , den2 ) ; den3 = ( den1 * den2 ) / den3 ; int num3 = ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ; lowest ( den3 , num3 ) ; } public static void Main ( ) { int num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 ; System . Console . Write ( num1 + " / " + den1 + " ▁ + ▁ " + num2 + " / " + den2 + " ▁ is ▁ equal ▁ to ▁ " ) ; addFraction ( num1 , den1 , num2 , den2 ) ; } }
using System ; class GFG { static int findPieces ( int n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; } public static void Main ( ) { Console . WriteLine ( findPieces ( 1 ) ) ; Console . WriteLine ( findPieces ( 2 ) ) ; Console . WriteLine ( findPieces ( 3 ) ) ; Console . Write ( findPieces ( 50 ) ) ; } }
using System ; class GFG { public static double M_E = 2.71828182845904523536 ; public static double M_PI = 3.141592654 ; static long findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double x = ( n * Math . Log10 ( n / M_E ) + Math . Log10 ( 2 * M_PI * n ) / 2.0 ) ; return ( long ) Math . Floor ( x ) + 1 ; } public static void Main ( ) { Console . WriteLine ( findDigits ( 1 ) ) ; Console . WriteLine ( findDigits ( 50000000 ) ) ; Console . WriteLine ( findDigits ( 1000000000 ) ) ; Console . Write ( findDigits ( 120 ) ) ; } }
using System ; class GFG { static int findDigits ( int n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; double digits = 0 ; for ( int i = 2 ; i <= n ; i ++ ) digits += Math . Log10 ( i ) ; return ( int ) Math . Floor ( digits ) + 1 ; } public static void Main ( ) { Console . Write ( findDigits ( 1 ) + " STRNEWLINE " ) ; Console . Write ( findDigits ( 5 ) + " STRNEWLINE " ) ; Console . Write ( findDigits ( 10 ) + " STRNEWLINE " ) ; Console . Write ( findDigits ( 120 ) + " STRNEWLINE " ) ; } }
using System ; class GFG { static int countEvenSum ( int [ ] arr , int n ) { int result = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { int sum = 0 ; for ( int j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = arr . Length ; Console . Write ( " The ▁ Number ▁ of ▁ Subarrays " + " ▁ with ▁ even ▁ sum ▁ is ▁ " ) ; Console . WriteLine ( countEvenSum ( arr , n ) ) ; } }
using System ; class GFG { static int countEvenSum ( int [ ] arr , int n ) { int [ ] temp = { 1 , 0 } ; int result = 0 , sum = 0 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 ; temp [ sum ] ++ ; } result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) / 2 ) ; result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) / 2 ) ; return ( result ) ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = arr . Length ; Console . WriteLine ( " The ▁ Number ▁ of ▁ Subarrays " + " ▁ with ▁ even ▁ sum ▁ is ▁ " + countEvenSum ( arr , n ) ) ; } }
using System ; class GFG { static int calculateSum ( int n ) { if ( n <= 0 ) return 0 ; int [ ] fibo = new int [ n + 1 ] ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; int sum = fibo [ 0 ] + fibo [ 1 ] ; for ( int i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; } static void Main ( ) { int n = 4 ; Console . WriteLine ( " Sum ▁ of ▁ Fibonacci " + " ▁ numbers ▁ is ▁ : ▁ " + calculateSum ( n ) ) ; } }
using System ; class GFG { static int MAX = 1000 ; static int [ ] f = new int [ MAX ] ; static int fib ( int n ) { for ( int i = 0 ; i < MAX ; i ++ ) f [ i ] = 0 ; if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] == 1 ) return f [ n ] ; int k ; if ( ( n & 1 ) == 1 ) k = ( n + 1 ) / 2 ; else k = n / 2 ; if ( ( n & 1 ) == 1 ) f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; else f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } static int calculateSum ( int n ) { return fib ( n + 2 ) - 1 ; } public static void Main ( ) { int n = 4 ; Console . Write ( " Sum ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " + calculateSum ( n ) ) ; } }
using System ; class GFG { static void findCombinationsUtil ( int [ ] arr , int index , int num , int reducedNum ) { if ( reducedNum < 0 ) return ; if ( reducedNum == 0 ) { for ( int i = 0 ; i < index ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; return ; } int prev = ( index == 0 ) ? 1 : arr [ index - 1 ] ; for ( int k = prev ; k <= num ; k ++ ) { arr [ index ] = k ; findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ; } } static void findCombinations ( int n ) { int [ ] arr = new int [ n ] ; findCombinationsUtil ( arr , 0 , n , n ) ; } static public void Main ( ) { int n = 5 ; findCombinations ( n ) ; } }
using System ; class GFG { static int z = 0 ; static int pow1 ( int base1 , int exponent , int modulus ) { int result = 1 ; base1 = base1 % modulus ; while ( exponent > 0 ) { if ( exponent % 2 == 1 ) result = ( result * base1 ) % modulus ; exponent = exponent >> 1 ; base1 = ( base1 * base1 ) % modulus ; } return result ; } static int gcd ( int a , int b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } static int order ( int p , int b ) { if ( gcd ( p , b ) != 1 ) { Console . WriteLine ( " p ▁ and ▁ b ▁ are " + " not ▁ co - prime . " ) ; return - 1 ; } int k = 3 ; while ( true ) { if ( pow1 ( b , k , p ) == 1 ) return k ; k ++ ; } } static int convertx2e ( int x ) { z = 0 ; while ( x % 2 == 0 ) { x /= 2 ; z ++ ; } return x ; } static int STonelli ( int n , int p ) { if ( gcd ( n , p ) != 1 ) { Console . WriteLine ( " a ▁ and ▁ p ▁ are ▁ not ▁ coprime " ) ; return - 1 ; } if ( pow1 ( n , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) { Console . WriteLine ( " no ▁ sqrt ▁ possible " ) ; return - 1 ; } int s , e ; s = convertx2e ( p - 1 ) ; e = z ; int q ; for ( q = 2 ; ; q ++ ) { if ( pow1 ( q , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) break ; } int x = pow1 ( n , ( s + 1 ) / 2 , p ) ; int b = pow1 ( n , s , p ) ; int g = pow1 ( q , s , p ) ; int r = e ; while ( true ) { int m ; for ( m = 0 ; m < r ; m ++ ) { if ( order ( p , b ) == - 1 ) return - 1 ; if ( order ( p , b ) == Math . Pow ( 2 , m ) ) break ; } if ( m == 0 ) return x ; x = ( x * pow1 ( g , ( int ) Math . Pow ( 2 , r - m - 1 ) , p ) ) % p ; g = pow1 ( g , ( int ) Math . Pow ( 2 , r - m ) , p ) ; b = ( b * g ) % p ; if ( b == 1 ) return x ; r = m ; } } static void Main ( ) { int n = 2 ; int p = 113 ; int x = STonelli ( n , p ) ; if ( x == - 1 ) Console . WriteLine ( " Modular ▁ square ▁ root " + " is ▁ not ▁ exist STRNEWLINE " ) ; else Console . WriteLine ( " Modular ▁ square ▁ root ▁ of " + " { 0 } ▁ and ▁ { 1 } ▁ is ▁ { 2 } STRNEWLINE " , n , p , x ) ; } }
using System ; class GFG { static bool isPower ( int x , int y ) { int res1 = ( int ) Math . Log ( y ) / ( int ) Math . Log ( x ) ; double res2 = Math . Log ( y ) / Math . Log ( x ) ; return ( res1 == res2 ) ; } static void Main ( ) { if ( isPower ( 27 , 729 ) ) Console . WriteLine ( "1" ) ; else Console . WriteLine ( "0" ) ; } }
using System ; class Quadratic { void findRoots ( int a , int b , int c ) { if ( a == 0 ) { Console . Write ( " Invalid " ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = Math . Abs ( d ) ; if ( d > 0 ) { Console . Write ( " Roots ▁ are ▁ real ▁ and ▁ different ▁ STRNEWLINE " ) ; Console . Write ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) + " STRNEWLINE " + ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else { Console . Write ( " Roots ▁ are ▁ complex ▁ STRNEWLINE " ) ; Console . Write ( - ( double ) b / ( 2 * a ) + " ▁ + ▁ i " + sqrt_val + " STRNEWLINE " + - ( double ) b / ( 2 * a ) + " ▁ - ▁ i " + sqrt_val ) ; } } public static void Main ( ) { Quadratic obj = new Quadratic ( ) ; int a = 1 , b = - 7 , c = 12 ; obj . findRoots ( a , b , c ) ; } }
using System ; public class GFG { static bool isPerfectSquare ( int n ) { for ( int sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; } public static void Main ( String [ ] args ) { if ( isPerfectSquare ( 35 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; if ( isPerfectSquare ( 49 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int findCount ( int d ) { return 9 * ( ( int ) ( Math . Pow ( 10 , d - 1 ) ) - ( int ) ( Math . Pow ( 9 , d - 1 ) ) ) ; } public static void Main ( ) { int d = 1 ; Console . WriteLine ( findCount ( d ) ) ; d = 2 ; Console . WriteLine ( findCount ( d ) ) ; d = 4 ; Console . WriteLine ( findCount ( d ) ) ; } }
using System ; class GFG { static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( " Number ▁ of ▁ " + " Dyck ▁ Paths ▁ is ▁ " + countDyckPaths ( n ) ) ; } }
using System ; class GFG { static bool isTriangular ( int num ) { if ( num < 0 ) return false ; int sum = 0 ; for ( int n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; } public static void Main ( ) { int n = 55 ; if ( isTriangular ( n ) ) Console . WriteLine ( " The ▁ number ▁ " + " is ▁ a ▁ triangular ▁ number " ) ; else Console . WriteLine ( " The ▁ number " + " ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) ; } }
using System ; class GFG { static bool isTriangular ( int num ) { if ( num < 0 ) return false ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; float root1 = ( - b + ( float ) Math . Sqrt ( d ) ) / ( 2 * a ) ; float root2 = ( - b - ( float ) Math . Sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . Floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . Floor ( root2 ) == root2 ) return true ; return false ; } public static void Main ( ) { int num = 55 ; if ( isTriangular ( num ) ) Console . WriteLine ( " The ▁ number ▁ is ▁ a ▁ " + " triangular ▁ number " ) ; else Console . WriteLine ( " The ▁ number ▁ is ▁ NOT ▁ " + " a ▁ triangular ▁ number " ) ; } }
using System ; class GFG { static int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } static int toDeci ( string str , int b_ase ) { int len = str . Length ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= b_ase ) { Console . WriteLine ( " Invalid ▁ Number " ) ; return - 1 ; } num += val ( str [ i ] ) * power ; power = power * b_ase ; } return num ; } public static void Main ( ) { string str = "11A " ; int b_ase = 16 ; Console . WriteLine ( " Decimal ▁ equivalent ▁ of ▁ " + str + " ▁ in ▁ base ▁ " + b_ase + " ▁ is ▁ " + toDeci ( str , b_ase ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { int c ; while ( a != 0 ) { c = a ; a = b % a ; b = c ; } return b ; } static void forbenius ( int X , int Y ) { if ( gcd ( X , Y ) != 1 ) { Console . WriteLine ( " NA " ) ; return ; } int A = ( X * Y ) - ( X + Y ) ; int N = ( X - 1 ) * ( Y - 1 ) / 2 ; Console . WriteLine ( " Largest ▁ Amount ▁ = ▁ " + A ) ; Console . WriteLine ( " Total ▁ Count ▁ = ▁ " + N ) ; } public static void Main ( ) { int X = 2 , Y = 5 ; forbenius ( X , Y ) ; X = 5 ; Y = 10 ; Console . WriteLine ( ) ; forbenius ( X , Y ) ; } }
using System ; class GFG { static char xor_c ( char a , char b ) { return ( a == b ) ? '0' : '1' ; } static char flip ( char c ) { return ( c == '0' ) ? '1' : '0' ; } static String binarytoGray ( String binary ) { String gray = " " ; gray += binary [ 0 ] ; for ( int i = 1 ; i < binary . Length ; i ++ ) { gray += xor_c ( binary [ i - 1 ] , binary [ i ] ) ; } return gray ; } static String graytoBinary ( String gray ) { String binary = " " ; binary += gray [ 0 ] ; for ( int i = 1 ; i < gray . Length ; i ++ ) { if ( gray [ i ] == '0' ) binary += binary [ i - 1 ] ; else binary += flip ( binary [ i - 1 ] ) ; } return binary ; } public static void Main ( ) { String binary = "01001" ; Console . WriteLine ( " Gray ▁ code ▁ of ▁ " + binary + " ▁ is ▁ " + binarytoGray ( binary ) ) ; String gray = "01101" ; Console . Write ( " Binary ▁ code ▁ of ▁ " + gray + " ▁ is ▁ " + graytoBinary ( gray ) ) ; } }
using System ; class GFG { static int seriesSum ( int calculated , int current , int N ) { int i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; } public static void Main ( ) { int N = 5 ; Console . WriteLine ( seriesSum ( 1 , 1 , N ) ) ; } }
using System ; class GFG { static int modFact ( int n , int p ) { if ( n >= p ) return 0 ; int result = 1 ; for ( int i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; } static void Main ( ) { int n = 25 , p = 29 ; Console . Write ( modFact ( n , p ) ) ; } }
using System ; class GFG { static int inv ( int a , int m ) { int m0 = m , t , q ; int x0 = 0 , x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { q = a / m ; t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } static int findMinX ( int [ ] num , int [ ] rem , int k ) { int prod = 1 ; for ( int i = 0 ; i < k ; i ++ ) prod *= num [ i ] ; int result = 0 ; for ( int i = 0 ; i < k ; i ++ ) { int pp = prod / num [ i ] ; result += rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; } static public void Main ( ) { int [ ] num = { 3 , 4 , 5 } ; int [ ] rem = { 2 , 3 , 1 } ; int k = num . Length ; Console . WriteLine ( " x ▁ is ▁ " + findMinX ( num , rem , k ) ) ; } }
using System ; class GFG { static int findMinX ( int [ ] num , int [ ] rem , int k ) { int x = 1 ; while ( true ) { int j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } } public static void Main ( ) { int [ ] num = { 3 , 4 , 5 } ; int [ ] rem = { 2 , 3 , 1 } ; int k = num . Length ; Console . WriteLine ( " x ▁ is ▁ " + findMinX ( num , rem , k ) ) ; } }
using System ; class GFG { static int nCrModpDP ( int n , int r , int p ) { int [ ] C = new int [ r + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; } static int nCrModpLucas ( int n , int r , int p ) { if ( r == 0 ) return 1 ; int ni = n % p ; int ri = r % p ; } public static void Main ( ) { int n = 1000 , r = 900 , p = 13 ; Console . Write ( " Value ▁ of ▁ nCr ▁ % ▁ p ▁ is ▁ " + nCrModpLucas ( n , r , p ) ) ; } }
using System ; class GFG { static bool isValid ( int n , int d ) { int digit = n % 10 ; int sum = digit ; if ( digit == d ) return false ; n /= 10 ; while ( n > 0 ) { digit = n % 10 ; if ( digit == d digit <= sum ) return false ; else { sum += digit ; n /= 10 ; } } return true ; } static void printGoodNumber ( int L , int R , int d ) { for ( int i = L ; i <= R ; i ++ ) { if ( isValid ( i , d ) ) Console . Write ( i + " ▁ " ) ; } } public static void Main ( ) { int L = 410 , R = 520 , d = 3 ; printGoodNumber ( L , R , d ) ; } }
using System ; class GFG { public static int nearestSmallerEqFib ( int n ) { if ( n == 0 n == 1 ) return n ; int f1 = 0 , f2 = 1 , f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; } public static void printFibRepresntation ( int n ) { while ( n > 0 ) { int f = nearestSmallerEqFib ( n ) ; Console . Write ( f + " ▁ " ) ; n = n - f ; } } public static void Main ( ) { int n = 40 ; Console . WriteLine ( " Non - neighbouring ▁ Fibonacci ▁ " + " ▁ Representation ▁ of ▁ " + n + " ▁ is " ) ; printFibRepresntation ( n ) ; } }
using System ; class GFG { static int [ , , ] dp = new int [ 5001 , 5001 , 5 ] ; static int countWaysUtil ( int n , int parts , int nextPart ) { if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 parts <= 0 ) return 0 ; if ( dp [ n , nextPart , parts ] != - 1 ) return dp [ n , nextPart , parts ] ; for ( int i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ; return ( dp [ n , nextPart , parts ] = ans ) ; } static int countWays ( int n ) { for ( int i = 0 ; i < 5001 ; i ++ ) { for ( int j = 0 ; j < 5001 ; j ++ ) { for ( int l = 0 ; l < 5 ; l ++ ) dp [ i , j , l ] = - 1 ; } } return countWaysUtil ( n , 4 , 1 ) ; } public static void Main ( String [ ] args ) { int n = 8 ; Console . WriteLine ( countWays ( n ) ) ; } }
using System ; public class GFG { static void printTwins ( int low , int high ) { bool [ ] prime = new bool [ high + 1 ] ; bool twin = false ; for ( int i = 0 ; i < prime . Length ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p <= Math . Floor ( Math . Sqrt ( high ) ) + 1 ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= high ; i += p ) { prime [ i ] = false ; } } } for ( int i = low ; i <= high ; i ++ ) { if ( prime [ i ] && prime [ i + 2 ] ) { int a = i + 2 ; Console . Write ( " Smallest ▁ twins ▁ in ▁ given ▁ range : ▁ ( " + i + " , ▁ " + a + " ) " ) ; twin = true ; break ; } } if ( twin == false ) { Console . WriteLine ( " No ▁ such ▁ pair ▁ exists " ) ; } } public static void Main ( ) { printTwins ( 10 , 100 ) ; } }
using System ; using System . Collections ; class GFG { static int nextSparse ( int x ) { ArrayList bin = new ArrayList ( ) ; while ( x != 0 ) { bin . Add ( x & 1 ) ; x >>= 1 ; } bin . Add ( 0 ) ; int last_final = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( ( int ) bin [ i ] == 1 && ( int ) bin [ i - 1 ] == 1 && ( int ) bin [ i + 1 ] != 1 ) { bin [ i + 1 ] = 1 ; for ( int j = i ; j >= last_final ; j -- ) bin [ j ] = 0 ; last_final = i + 1 ; } } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += ( int ) bin [ i ] * ( 1 << i ) ; return ans ; } static void Main ( ) { int x = 38 ; Console . WriteLine ( " Next ▁ Sparse ▁ Number ▁ is ▁ " + nextSparse ( x ) ) ; } }
using System ; class GFG { static int sumBitDifferences ( int [ ] arr , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) == 0 ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 5 } ; int n = arr . Length ; Console . Write ( sumBitDifferences ( arr , n ) ) ; } }
using System ; class GFG { static void printArr ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] ) ; Console . WriteLine ( ) ; } static void generateUtil ( int x , int [ ] arr , int curr_sum , int curr_idx ) { if ( curr_sum == x ) { printArr ( arr , curr_idx ) ; return ; } int num = 1 ; while ( num <= x - curr_sum && ( curr_idx == 0 num <= arr [ curr_idx - 1 ] ) ) { arr [ curr_idx ] = num ; generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) ; num ++ ; } } static void generate ( int x ) { int [ ] arr = new int [ x ] ; generateUtil ( x , arr , 0 , 0 ) ; } public static void Main ( ) { int x = 5 ; generate ( x ) ; } }
class GFG { static bool isPerfect ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; } static void Main ( ) { System . Console . WriteLine ( " Below ▁ are ▁ all ▁ perfect " + " numbers ▁ till ▁ 10000" ) ; for ( int n = 2 ; n < 10000 ; n ++ ) if ( isPerfect ( n ) ) System . Console . WriteLine ( n + " ▁ is ▁ a ▁ perfect ▁ number " ) ; } }
using System ; class GFG { static bool checkUtil ( int num , int dig , int i ) { if ( dig == 1 && num < i ) return true ; if ( dig > 1 && num >= i ) return checkUtil ( ( num / i ) , -- dig , i ) ; return false ; } static bool check ( int num , int dig ) { for ( int i = 2 ; i <= 32 ; i ++ ) if ( checkUtil ( num , dig , i ) ) return true ; return false ; } public static void Main ( ) { int num = 8 ; int dig = 3 ; if ( check ( num , dig ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; public class GFG { static int mod ( String num , int a ) { int res = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) res = ( res * 10 + ( int ) num [ i ] - '0' ) % a ; return res ; } public static void Main ( ) { String num = "12316767678678" ; Console . WriteLine ( mod ( num , 10 ) ) ; } }
using System ; class GFG { static int modInverse ( int a , int m ) { for ( int x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; return 1 ; } public static void Main ( ) { int a = 3 , m = 11 ; Console . WriteLine ( modInverse ( a , m ) ) ; } }
using System ; class GFG { static int modInverse ( int a , int m ) { int m0 = m ; int y = 0 , x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { int q = a / m ; int t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } public static void Main ( ) { int a = 3 , m = 11 ; Console . WriteLine ( " Modular ▁ multiplicative ▁ " + " inverse ▁ is ▁ " + modInverse ( a , m ) ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int phi ( int n ) { int result = 1 ; for ( int i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; } public static void Main ( ) { for ( int n = 1 ; n <= 10 ; n ++ ) Console . WriteLine ( " phi ( " + n + " ) ▁ = ▁ " + phi ( n ) ) ; } }
using System ; class GFG { static int phi ( int n ) { float result = n ; for ( int p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( float ) ( 1.0 - ( 1.0 / ( float ) p ) ) ; } } if ( n > 1 ) result *= ( float ) ( 1.0 - ( 1.0 / ( float ) n ) ) ; return ( int ) result ; } public static void Main ( ) { int n ; for ( n = 1 ; n <= 10 ; n ++ ) Console . WriteLine ( " phi ( " + n + " ) ▁ = ▁ " + phi ( n ) ) ; } }
using System ; class GFG { static int factorial ( int n ) { int res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res *= i ; return res ; } static double sum ( int n ) { double sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) sum += 1.0 / factorial ( i ) ; return sum ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( sum ( n ) ) ; } }
using System ; class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } static long findWays ( int n ) { if ( ( n & 1 ) != 0 ) return 0 ; return catalan ( n / 2 ) ; } public static void Main ( ) { int n = 6 ; Console . Write ( " Total ▁ possible ▁ expressions " + " of ▁ length ▁ " + n + " ▁ is ▁ " + findWays ( 6 ) ) ; } }
using System ; class GFG { static bool isOperand ( char c ) { return ( c >= '0' && c <= '9' ) ; } static int value ( char c ) { return ( int ) ( c - '0' ) ; } static int evaluate ( string exp ) { if ( exp . Length == 0 ) return - 1 ; int res = value ( exp [ 0 ] ) ; for ( int i = 1 ; i < exp . Length ; i += 2 ) { char opr = exp [ i ] , opd = exp [ i + 1 ] ; if ( isOperand ( opd ) == false ) return - 1 ; if ( opr == ' + ' ) res += value ( opd ) ; else if ( opr == ' - ' ) res -= value ( opd ) ; else if ( opr == ' * ' ) res *= value ( opd ) ; else if ( opr == ' / ' ) res /= value ( opd ) ; else return - 1 ; } return res ; } static void Main ( ) { string expr1 = "1 + 2*5 + 3" ; int res = evaluate ( expr1 ) ; if ( res == - 1 ) Console . WriteLine ( expr1 + " ▁ is ▁ Invalid " ) ; else Console . WriteLine ( " Value ▁ of ▁ " + expr1 + " ▁ is ▁ " + res ) ; string expr2 = "1 + 2*3" ; res = evaluate ( expr2 ) ; if ( res == - 1 ) Console . WriteLine ( expr2 + " ▁ is ▁ Invalid " ) ; else Console . WriteLine ( " Value ▁ of ▁ " + expr2 + " ▁ is ▁ " + res ) ; string expr3 = "4-2 + 6*3" ; res = evaluate ( expr3 ) ; if ( res == - 1 ) Console . WriteLine ( expr3 + " ▁ is ▁ Invalid " ) ; else Console . WriteLine ( " Value ▁ of ▁ " + expr3 + " ▁ is ▁ " + res ) ; string expr4 = "1 + + 2" ; res = evaluate ( expr4 ) ; if ( res == - 1 ) Console . WriteLine ( expr4 + " ▁ is ▁ Invalid " ) ; else Console . WriteLine ( " Value ▁ of ▁ " + expr4 + " ▁ is ▁ " + res ) ; } }
using System ; class Test { static void printFibonacciNumbers ( int n ) { int f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; Console . Write ( f1 + " ▁ " ) ; for ( i = 1 ; i < n ; i ++ ) { Console . Write ( f2 + " ▁ " ) ; int next = f1 + f2 ; f1 = f2 ; f2 = next ; } } public static void Main ( ) { printFibonacciNumbers ( 7 ) ; } }
using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int lcm ( int a , int b ) { return ( a / gcd ( a , b ) ) * b ; } public static void Main ( ) { int a = 15 , b = 20 ; Console . WriteLine ( " LCM ▁ of ▁ " + a + " ▁ and ▁ " + b + " ▁ is ▁ " + lcm ( a , b ) ) ; } }
using System ; class GFG { static void convert_to_words ( char [ ] num ) { int len = num . Length ; if ( len == 0 ) { Console . WriteLine ( " empty ▁ string " ) ; return ; } if ( len > 4 ) { Console . WriteLine ( " Length ▁ more ▁ than ▁ " + "4 ▁ is ▁ not ▁ supported " ) ; return ; } string [ ] single_digits = new string [ ] { " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " } ; string [ ] two_digits = new string [ ] { " " , " ten " , " eleven " , " twelve " , " thirteen " , " fourteen " , " fifteen " , " sixteen " , " seventeen " , " eighteen " , " nineteen " } ; string [ ] tens_multiple = new string [ ] { " " , " " , " twenty " , " thirty " , " forty " , " fifty " , " sixty " , " seventy " , " eighty " , " ninety " } ; string [ ] tens_power = new string [ ] { " hundred " , " thousand " } ; Console . Write ( ( new string ( num ) ) + " : ▁ " ) ; if ( len == 1 ) { Console . WriteLine ( single_digits [ num [ 0 ] - '0' ] ) ; return ; } int x = 0 ; while ( x < num . Length ) { if ( len >= 3 ) { if ( num [ x ] - '0' != 0 ) { Console . Write ( single_digits [ num [ x ] - '0' ] + " ▁ " ) ; Console . Write ( tens_power [ len - 3 ] + " ▁ " ) ; } -- len ; } else { if ( num [ x ] - '0' == 1 ) { int sum = num [ x ] - '0' + num [ x + 1 ] - '0' ; Console . WriteLine ( two_digits [ sum ] ) ; return ; } else if ( num [ x ] - '0' == 2 && num [ x + 1 ] - '0' == 0 ) { Console . WriteLine ( " twenty " ) ; return ; } else { int i = ( num [ x ] - '0' ) ; if ( i > 0 ) Console . Write ( tens_multiple [ i ] + " ▁ " ) ; else Console . Write ( " " ) ; ++ x ; if ( num [ x ] - '0' != 0 ) Console . WriteLine ( single_digits [ num [ x ] - '0' ] ) ; } } ++ x ; } } public static void Main ( ) { convert_to_words ( "9923" . ToCharArray ( ) ) ; convert_to_words ( "523" . ToCharArray ( ) ) ; convert_to_words ( "89" . ToCharArray ( ) ) ; convert_to_words ( "8" . ToCharArray ( ) ) ; } }
class GFG { static int MAX = 11 ; static bool isMultipleof5 ( int n ) { char [ ] str = new char [ MAX ] ; int len = str . Length ; if ( str [ len - 1 ] == '5' str [ len - 1 ] == '0' ) return true ; return false ; } static void Main ( ) { int n = 19 ; if ( isMultipleof5 ( n ) == true ) Console . WriteLine ( " { 0 } ▁ is ▁ " + " multiple ▁ of ▁ 5" , n ) ; else Console . WriteLine ( " { 0 } ▁ is ▁ not ▁ a ▁ " + " multiple ▁ of ▁ 5" , n ) ; } }
using System ; class GFG { static int pairORSum ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . Length ; Console . Write ( pairORSum ( arr , n ) ) ; } }
using System ; class GFG { static long multiplyByFifteen ( long n ) { long prod = ( n << 4 ) ; prod = prod - n ; return prod ; } public static void Main ( ) { long n = 7 ; Console . Write ( multiplyByFifteen ( n ) ) ; } }
class GFG { static void minAND ( int [ ] arr , int n ) { int s = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } System . Console . WriteLine ( s ) ; } static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int n = arr . Length ; minAND ( arr , n ) ; } }
using System ; class GFG { static bool check ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) return true ; return false ; } public static void Main ( ) { int [ ] a = { 0 , 1 , 0 , 1 } ; int n = a . Length ; if ( check ( a , n ) == true ) Console . Write ( " YES STRNEWLINE " ) ; else Console . Write ( " NO STRNEWLINE " ) ; } }
using System ; class GFG { static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } static void findArray ( int [ ] q , int n ) { int ans ; int [ ] arr = new int [ n ] ; for ( int k = 0 , j = 0 ; j < n / 4 ; j ++ ) { ans = q [ k ] ^ q [ k + 3 ] ; arr [ k + 1 ] = q [ k + 1 ] ^ ans ; arr [ k + 2 ] = q [ k + 2 ] ^ ans ; arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) ; arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) ; k += 4 ; } printArray ( arr , n ) ; } public static void Main ( ) { int [ ] q = { 4 , 1 , 7 , 0 } ; int n = q . Length ; findArray ( q , n ) ; } }
using System ; class GFG { static bool isEqualBlock ( int n ) { int first_bit = n % 2 ; int first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; } if ( n == 0 ) return false ; while ( n > 0 ) { first_bit = n % 2 ; int curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; } public static void Main ( ) { int n = 51 ; if ( isEqualBlock ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static void binToDecimal3 ( int n ) { int last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; int first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; Console . WriteLine ( first_3 + " ▁ " + last_3 ) ; } static public void Main ( ) { int n = 86 ; binToDecimal3 ( n ) ; } }
using System ; class GFG { static bool isPowerOfTwo ( int x ) { if ( x == 0 ) return false ; if ( ( x & ( x - 1 ) ) == 0 ) return true ; else return false ; } static int countNum ( int [ ] a , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) || isPowerOfTwo ( a [ i ] + 1 ) ) count ++ ; } return count ; } public static void Main ( ) { int [ ] arr = { 5 , 6 , 9 , 3 , 1 } ; int n = arr . Length ; Console . WriteLine ( countNum ( arr , n ) ) ; } }
using System ; class GFG { static bool checkEvenParity ( int x ) { int parity = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; parity ++ ; } if ( parity % 2 == 0 ) return true ; else return false ; } static long sumlist ( int [ ] a , int n ) { long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkEvenParity ( a [ i ] ) ) sum += a [ i ] ; } return sum ; } public static void Main ( ) { int [ ] arr = { 2 , 4 , 3 , 5 , 9 } ; int n = arr . Length ; Console . WriteLine ( sumlist ( arr , n ) ) ; } }
using System ; public class GFG { static int findOddPair ( int [ ] A , int N ) { int oddPair = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; } static public void Main ( ) { int [ ] A = { 5 , 6 , 2 , 8 } ; int N = A . Length ; Console . WriteLine ( findOddPair ( A , N ) ) ; } }
using System ; class GFG { static int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; } public static void Main ( ) { int [ ] A = { 5 , 4 , 7 , 2 , 1 } ; int N = A . Length ; Console . WriteLine ( findevenPair ( A , N ) ) ; } }
using System ; public class GFG { static int findEvenPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 != 0 ) count ++ ; } int totalPairs = ( N * ( N - 1 ) / 2 ) ; int oddEvenPairs = count * ( N - count ) ; return totalPairs - oddEvenPairs ; } public static void Main ( ) { int [ ] a = { 5 , 4 , 7 , 2 , 1 } ; int n = a . Length ; Console . Write ( findEvenPair ( a , n ) ) ; } }
using System ; class GFG { static int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; } public static void Main ( ) { int [ ] a = { 5 , 1 , 3 , 2 } ; int n = a . Length ; Console . WriteLine ( findevenPair ( a , n ) ) ; } }
using System ; public class GFG { static int findevenPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; } static public void Main ( ) { int [ ] a = { 5 , 1 , 3 , 2 } ; int n = a . Length ; Console . WriteLine ( findevenPair ( a , n ) ) ; } }
using System ; class GFG { static int calculate ( int X ) { int number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; } public static void Main ( ) { int X = 4 ; Console . WriteLine ( " Required ▁ Number ▁ is ▁ : ▁ " + calculate ( X ) ) ; } }
using System ; public class GFG { static void ReplaceElements ( int [ ] arr , int n ) { int X = 0 ; for ( int i = 0 ; i < n ; ++ i ) { X ^= arr [ i ] ; } for ( int i = 0 ; i < n ; ++ i ) { arr [ i ] = X ^ arr [ i ] ; } } static public void Main ( ) { int [ ] arr = { 2 , 3 , 3 , 5 , 5 } ; int n = arr . Length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) { Console . Write ( arr [ i ] + " ▁ " ) ; } } }
using System ; public class GFG { static int alternate ( int a , int b , int x ) { return x = a ^ b ^ x ; } public static void Main ( ) { int a = - 10 ; int b = 15 ; int x = a ; Console . Write ( " x ▁ is ▁ : ▁ " + x ) ; x = alternate ( a , b , x ) ; Console . Write ( " STRNEWLINE After ▁ exchange ▁ " ) ; Console . Write ( " x is : " } }
using System ; class GFG { static int countZeros ( int x ) { int y ; int n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; } static public void Main ( ) { int x = 101 ; Console . WriteLine ( countZeros ( x ) ) ; } }
using System ; class GFG { static void LeadingZeros ( int x , int y ) { if ( ( x ^ y ) <= ( x & y ) ) Console . WriteLine ( " STRNEWLINE Equal " ) ; else if ( ( x & ( ~ y ) ) > y ) Console . WriteLine ( y ) ; else Console . WriteLine ( x ) ; } static public void Main ( ) { int x = 10 , y = 16 ; LeadingZeros ( x , y ) ; } }
using System ; class GFG { static void solve ( int A , int B ) { int count = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } Console . WriteLine ( " Number ▁ of ▁ different ▁ bits ▁ : ▁ " + count ) ; } public static void Main ( ) { int A = 12 , B = 15 ; solve ( A , B ) ; } }
using System ; public class GFG { static int setRightmostUnsetBit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; } public static void Main ( ) { int n = 21 ; Console . WriteLine ( setRightmostUnsetBit ( n ) ) ; } }
using System ; public class GFG { static int AND ( int [ ] a , int n ) { int ans = a [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 3 } ; int n = a . Length ; Console . WriteLine ( AND ( a , n ) ) ; } }
using System ; class GFG { static void TwoscomplementbyXOR ( string str ) { int n = str . Length ; bool check_bit = false ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '0' && check_bit == false ) { continue ; } else { if ( check_bit == true ) { if ( str [ i ] == '0' ) str = str . Substring ( 0 , i ) + '1' + str . Substring ( i + 1 ) ; else str = str . Substring ( 0 , i ) + '0' + str . Substring ( i + 1 ) ; } check_bit = true ; } } if ( check_bit == false ) { Console . WriteLine ( "1" + str ) ; } else Console . WriteLine ( str ) ; } static void Main ( ) { string str = "101" ; TwoscomplementbyXOR ( str ) ; } }
using System ; class GFG { static bool bitsAreInAltPatrnInGivenTRange ( int n , int l , int r ) { int num , prev , curr ; num = n >> ( l - 1 ) ; prev = num & 1 ; num = num >> 1 ; for ( int i = 1 ; i <= ( r - l ) ; i ++ ) { curr = num & 1 ; if ( curr == prev ) return false ; prev = curr ; num = num >> 1 ; } return true ; } static void Main ( ) { int n = 18 ; int l = 1 , r = 3 ; if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static long increment ( long i ) { i = - ( ~ i ) ; return i ; } public static void Main ( ) { long n = 3 ; Console . WriteLine ( increment ( n ) ) ; } }
using System ; class GFG { static int bit_count ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; } static int maxsum ( int [ ] arr , int n ) { int [ ] bits = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { bits [ i ] = bit_count ( arr [ i ] ) ; } int [ ] sum = new int [ 32 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum [ bits [ i ] ] += arr [ i ] ; } int maximum = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { maximum = Math . Max ( sum [ i ] , maximum ) ; } return maximum ; } static void Main ( ) { int [ ] arr = { 2 , 3 , 8 , 5 , 6 , 7 } ; int n = arr . Length ; Console . WriteLine ( maxsum ( arr , n ) ) ; } }
using System ; class GFG { static int xorPairSum ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; } static public void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 } ; int n = arr . Length ; Console . WriteLine ( xorPairSum ( arr , n ) ) ; } }
using System ; class GFG { static int findEvenPair ( int [ ] A , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; } public static void Main ( String [ ] args ) { int [ ] A = { 5 , 6 , 2 , 8 } ; int N = A . Length ; Console . WriteLine ( findEvenPair ( A , N ) ) ; } }
using System ; class GFG { static bool allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return true ; return false ; } public static void Main ( ) { int n = 17 ; int l = 2 , r = 4 ; if ( allBitsSetInTheGivenRange ( n , l , r ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; public class GFG { static bool checkSame ( int n ) { int set = 0 ; int unset = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; } static public void Main ( ) { int n = 12 ; if ( checkSame ( n ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static void KthCharacter ( int m , int n , int k ) { int distance = ( int ) Math . Pow ( 2 , n ) ; int Block_number = k / distance ; int remaining = k % distance ; int [ ] s = new int [ 32 ] ; int x = 0 ; for ( ; m > 0 ; x ++ ) { s [ x ] = m % 2 ; m = m / 2 ; } int root = s [ x - 1 - Block_number ] ; if ( remaining == 0 ) { Console . WriteLine ( root ) ; return ; } Boolean flip = true ; while ( remaining > 1 ) { if ( ( remaining & 1 ) > 0 ) { flip = ! flip ; } remaining = remaining >> 1 ; } if ( flip ) { Console . WriteLine ( ! ( root > 0 ) ) ; } else { Console . WriteLine ( root ) ; } } public static void Main ( ) { int m = 5 , k = 5 , n = 3 ; KthCharacter ( m , n , k ) ; } }
using System ; class GFG { static bool onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; } public static void Main ( ) { int n = 9 ; if ( onlyFirstAndLastAreSet ( n ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int getInteger ( int L , int R ) { int number = 0 ; for ( int i = L ; i <= R ; i ++ ) number += ( int ) Math . Pow ( 2 , i ) ; return number ; } public static void Main ( ) { int L = 2 , R = 5 ; Console . Write ( getInteger ( L , R ) ) ; } }
using System ; class GFG { static int setbitsfromLtoR ( int L , int R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; } public static void Main ( ) { int L = 2 , R = 5 ; Console . WriteLine ( setbitsfromLtoR ( L , R ) ) ; } }
using System ; class GFG { static int findXor ( int [ ] arr , int n ) { int xoR = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; } public static void Main ( ) { int [ ] arr = { 1 , 5 , 6 } ; int n = arr . Length ; Console . WriteLine ( findXor ( arr , n ) ) ; } }
using System ; class GFG { static void printOdds ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; int set_bit = res & ( ~ ( res - 1 ) ) ; int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit ) != 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } Console . WriteLine ( x + " ▁ " + y ) ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 3 , 4 , 4 , 5 } ; int n = arr . Length ; printOdds ( arr , n ) ; } }
using System ; using System . Collections ; class GFG { static void subsetBitwiseORk ( int [ ] arr , int n , int k ) { ArrayList v = new ArrayList ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] k ) == k ) { v . Add ( arr [ i ] ) ; } } int ans = 0 ; for ( int i = 0 ; i < v . Count ; i ++ ) ans = ans | ( int ) v [ i ] ; if ( ans != k ) { Console . WriteLine ( " Subset ▁ does " + " ▁ not ▁ exist " ) ; return ; } for ( int i = 0 ; i < v . Count ; i ++ ) Console . Write ( ( int ) v [ i ] + " ▁ " ) ; } static public void Main ( String [ ] args ) { int k = 3 ; int [ ] arr = { 1 , 4 , 2 } ; int n = arr . Length ; subsetBitwiseORk ( arr , n , k ) ; } }
using System ; class GFG { static int findEletobeInserted ( int [ ] A , int n , int k ) { int ans = k ; for ( int i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; } public static void Main ( ) { int [ ] A = { 1 , 2 , 3 , 4 , 5 } ; int n = A . Length ; int k = 10 ; Console . WriteLine ( findEletobeInserted ( A , n , k ) + " ▁ has ▁ to ▁ be ▁ inserted ▁ in ▁ " + " the ▁ given ▁ array ▁ to ▁ make " + " ▁ xor ▁ sum ▁ of ▁ " + k ) ; } }
using System ; class GFG { static int BITS = 32 ; static int andSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < BITS ; i ++ ) { int countSetBits = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } int subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int size = 3 ; Console . WriteLine ( andSum ( arr , size ) ) ; } }
using System ; class GFG { static long _popcnt32 ( long n ) { long count = 0 ; while ( n != 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } static long maximize ( long a ) { long n = _popcnt32 ( a ) ; if ( n == 32 ) return a ; long res = ( 1 << Convert . ToInt32 ( n ) ) - 1 ; return ( res << ( 32 - Convert . ToInt32 ( n ) ) ) ; } static void Main ( ) { long a = 3 ; Console . WriteLine ( maximize ( a ) ) ; } }
using System ; class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } public static void Main ( String [ ] args ) { int i = 3 ; Console . Write ( countSetBits ( i ) ) ; } }
using System ; public class GFG { static bool isEven ( int n ) { bool isEven = true ; for ( int i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; } public static void Main ( ) { int n = 101 ; if ( isEven ( n ) ) Console . Write ( " Even " ) ; else Console . Write ( " Odd " ) ; } }
using System ; class GFG { static bool isEven ( int n ) { return ( ( n / 2 ) * 2 == n ) ; } public static void Main ( String [ ] args ) { int n = 101 ; if ( isEven ( n ) != false ) Console . Write ( " Even " ) ; else Console . Write ( " Odd " ) ; } }
using System ; class GFG { static int add ( int x , int y ) { int keep = ( x & y ) << 1 ; int res = x ^ y ; if ( keep == 0 ) return res ; return add ( keep , res ) ; } public static void Main ( ) { Console . Write ( add ( 15 , 38 ) ) ; } }
using System ; class GFG { static bool checkValidPair ( int num1 , int num2 ) { string s1 = num1 . ToString ( ) ; string s2 = num2 . ToString ( ) ; for ( int i = 0 ; i < s1 . Length ; i ++ ) for ( int j = 0 ; j < s2 . Length ; j ++ ) if ( s1 [ i ] == s2 [ j ] ) return true ; return false ; } static int countPairs ( int [ ] arr , int n ) { int numberOfPairs = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) numberOfPairs ++ ; return numberOfPairs ; } static void Main ( ) { int [ ] arr = new int [ ] { 10 , 12 , 24 } ; int n = arr . Length ; Console . WriteLine ( countPairs ( arr , n ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static int NUM_BITS = 32 ; static bool isPowerOf2 ( int num ) { if ( num != 0 && ( num & ( num - 1 ) ) == 0 ) return true ; return false ; } static bool checkSubsequence ( int [ ] arr , int n ) { if ( n == 1 ) return isPowerOf2 ( arr [ 0 ] ) ; int total = 0 ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) total = total | ( 1 << i ) ; for ( int i = 0 ; i < NUM_BITS ; i ++ ) { int ans = total ; for ( int j = 0 ; j < n ; j ++ ) { int p = arr [ j ] & ( 1 << i ) ; if ( p == 0 ) ans = ans & arr [ j ] ; } if ( isPowerOf2 ( ans ) ) return true ; } return false ; } public static void Main ( ) { int [ ] arr = { 12 , 13 , 7 } ; int n = arr . Length ; if ( checkSubsequence ( arr , n ) ) Console . Write ( " YES STRNEWLINE " ) ; else Console . Write ( " NO STRNEWLINE " ) ; } }
using System ; class GFG { static String findWinner ( int [ ] A , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " Alice " ; else return " Bob " ; } public static void Main ( ) { int [ ] A = { 1 , 4 , 3 , 5 } ; int n = A . Length ; Console . WriteLine ( " Winner ▁ = ▁ " + findWinner ( A , n ) ) ; } }
using System ; class GFG { static bool isFibbinaryNum ( int n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; } public static void Main ( ) { int n = 10 ; if ( isFibbinaryNum ( n ) == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int maxXOR ( int n , int k ) { int c = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; } public static void Main ( String [ ] args ) { int n = 12 ; int k = 3 ; Console . Write ( maxXOR ( n , k ) ) ; } }
using System ; class GFG { public static long divide ( long dividend , long divisor ) { long sign = ( ( dividend < 0 ) ^ ( divisor < 0 ) ) ? - 1 : 1 ; dividend = Math . Abs ( dividend ) ; divisor = Math . Abs ( divisor ) ; long quotient = 0 , temp = 0 ; for ( int i = 31 ; i >= 0 ; -- i ) { if ( temp + ( divisor << i ) <= dividend ) { temp += divisor << i ; quotient |= 1L L << i ; } } if ( sign == - 1 ) quotient = - quotient ; return quotient ; } public static void Main ( ) { int a = 10 , b = 3 ; Console . WriteLine ( divide ( a , b ) ) ; int a1 = 43 , b1 = - 8 ; Console . WriteLine ( divide ( a1 , b1 ) ) ; } }
using System ; class GFG { static int count ( int n ) { int c = 0 ; while ( n != 0 ) { c ++ ; n = n >> 1 ; } return c ; } static int XOR ( int a , int b ) { int c = Math . Min ( a , b ) ; int d = Math . Max ( a , b ) ; if ( count ( c ) < count ( d ) ) c = c << ( count ( d ) - count ( c ) ) ; return ( c ^ d ) ; } public static void Main ( ) { int a = 13 , b = 5 ; Console . WriteLine ( XOR ( a , b ) ) ; } }
using System ; public class GFG { static uint swapBitsInPair ( uint x ) { return ( ( x & 010101010 ) >> 1 ) | ( ( x & 001010101 ) << 1 ) ; } static public void Main ( ) { uint x = 4 ; Console . WriteLine ( swapBitsInPair ( x ) ) ; } }
using System ; class GFG { static int setevenbits ( int n ) { int temp = n ; int count = 0 ; int res = 0 ; for ( temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n & res ) ; } static int setoddbits ( int m ) { int count = 0 ; int res = 0 ; for ( int temp = m ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( m & res ) ; } static int getAlternateBits ( int n , int m ) { int tempn = setevenbits ( n ) ; int tempm = setoddbits ( m ) ; return ( tempn tempm ) ; } public static void Main ( ) { int n = 10 ; int m = 11 ; Console . WriteLine ( getAlternateBits ( n , m ) ) ; } }
using System ; class GFG { static bool isDivisibleBy10 ( string bin , int n ) { if ( bin [ n - 1 ] == '1' ) return false ; int sum = 0 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == '1' ) { int posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; } static bool isDivisibleBy20 ( string bin , int n ) { if ( bin [ n - 1 ] == '1' ) return false ; return isDivisibleBy10 ( bin , n - 1 ) ; } public static void Main ( ) { string bin = "101000" ; int n = bin . Length ; if ( isDivisibleBy20 ( bin , n - 1 ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int toggleBits ( int n1 , int n2 ) { return ( n1 ^ n2 ) ; } public static void Main ( ) { int n1 = 2 , n2 = 5 ; Console . WriteLine ( toggleBits ( n1 , n2 ) ) ; } }
using System ; class GFG { static int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; } public static void Main ( ) { int n = 11 ; Console . WriteLine ( evenbittogglenumber ( n ) ) ; } }
using System ; class GFG { static int takeLandFsetbits ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 1 ) + 1 ; } static int toggleFandLbits ( int n ) { if ( n == 1 ) return 0 ; return n ^ takeLandFsetbits ( n ) ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( toggleFandLbits ( n ) ) ; } }
using System ; class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static bool checkOdious ( int n ) { return ( countSetBits ( n ) % 2 == 1 ) ; } public static void Main ( ) { int num = 32 ; if ( checkOdious ( num ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int setleftmostunsetbit ( int n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; int pos = 0 ; for ( int temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( setleftmostunsetbit ( n ) ) ; } }
using System ; public class main { static int maxXorSum ( int n , int k ) { if ( k == 1 ) return n ; int res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; } public static void Main ( ) { int n = 4 , k = 3 ; Console . WriteLine ( maxXorSum ( n , k ) ) ; } }
using System ; class GFG { static int getPosOfRightmostSetBit ( int n ) { return ( int ) ( Math . Log ( n & - n ) / Math . Log ( 2 ) ) ; } static int toggleLastKBits ( int n , int k ) { int num = ( 1 << k ) - 1 ; return ( n ^ num ) ; } static int incrementByOne ( int n ) { int k = getPosOfRightmostSetBit ( ~ n ) ; n = ( ( 1 << k ) n ) ; if ( k != 0 ) n = toggleLastKBits ( n , k ) ; return n ; } public static void Main ( ) { int n = 15 ; Console . WriteLine ( incrementByOne ( n ) ) ; } }
using System ; public class GfG { public static int xnor ( int a , int b ) { if ( a < b ) { int t = a ; a = b ; b = t ; } if ( a == 0 && b == 0 ) return 1 ; int a_rem = 0 ; int b_rem = 0 ; int count = 0 ; int xnornum = 0 ; while ( true ) { a_rem = a & 1 ; b_rem = b & 1 ; if ( a_rem == b_rem ) xnornum |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; if ( a < 1 ) break ; } return xnornum ; } public static void Main ( ) { int a = 10 , b = 50 ; Console . WriteLine ( xnor ( a , b ) ) ; } }
using System ; class GFG { static int togglebit ( int n ) { if ( n == 0 ) return 1 ; int i = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return i ^ n ; } static int xnor ( int num1 , int num2 ) { if ( num1 < num2 ) { int temp = num1 ; num1 = num2 ; num2 = temp ; } num1 = togglebit ( num1 ) ; return num1 ^ num2 ; } public static void Main ( ) { int a = 10 , b = 20 ; Console . WriteLine ( xnor ( a , b ) ) ; } }
using System ; class GFG { static void MaximumSum ( int [ ] a , int [ ] b , int n ) { int sum1 = 0 , sum2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } Console . WriteLine ( sum1 + sum2 ) ; } public static void Main ( ) { int [ ] A = { 1 , 2 , 4 , 3 , 2 } ; int [ ] B = { 2 , 3 , 3 , 12 , 1 } ; int n = A . Length ; MaximumSum ( A , B , n ) ; } }
using System ; class GFG { static bool isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } static bool differAtOneBitPos ( int a , int b ) { return isPowerOfTwo ( a ^ b ) ; } public static void Main ( ) { int a = 13 , b = 9 ; if ( differAtOneBitPos ( a , b ) == true ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static long power2 ( long n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 2 ; return power2 ( n / 2 ) * power2 ( n / 2 ) ; } static long multiply ( long x , long n ) { return x * power2 ( n ) ; } public static void Main ( ) { long x = 70 , n = 2 ; Console . WriteLine ( multiply ( x , n ) ) ; } }
using System ; class GFG { static int multiply ( int x , int n ) { return x << n ; } public static void Main ( ) { int x = 70 , n = 2 ; Console . WriteLine ( multiply ( x , n ) ) ; } }
using System ; class GFG { static bool isDivBy2PowerM ( int n , int m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; } public static void Main ( ) { int n = 8 , m = 2 ; if ( isDivBy2PowerM ( n , m ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int findWinner ( int N ) { return N & 1 ; } public static void Main ( ) { int N = 15 ; if ( findWinner ( N ) == 1 ) Console . Write ( " Player ▁ A " ) ; else Console . Write ( " Player ▁ B " ) ; } }
using System ; class GFG { static int evenbittogglenumber ( int n ) { int res = 0 , count = 0 ; for ( int temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; } public static void Main ( ) { int n = 11 ; Console . WriteLine ( evenbittogglenumber ( n ) ) ; } }
using System ; public class GFG { static void divide ( int n , int m ) { Console . WriteLine ( " Remainder ▁ = ▁ " + ( ( n ) & ( m - 1 ) ) ) ; Console . WriteLine ( " Quotient ▁ = ▁ " + ( n >> ( int ) ( Math . Log ( m ) ) ) ) ; } static public void Main ( ) { int n = 43 , m = 8 ; divide ( n , m ) ; } }
using System ; public class GfG { static int maxAND ( int [ ] arr , int n ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) res = res > ( arr [ i ] & arr [ j ] ) ? res : ( arr [ i ] & arr [ j ] ) ; return res ; } public static void Main ( ) { int [ ] arr = { 4 , 8 , 6 , 2 } ; int n = arr . Length ; Console . WriteLine ( " Maximum ▁ AND ▁ Value ▁ = ▁ " + maxAND ( arr , n ) ) ; } }
using System ; class GFG { static int index ( int i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; } static void check ( int n ) { String [ ] s = { " negative " , " zero " , " positive " } ; int val = index ( n ) ; Console . WriteLine ( n + " ▁ is ▁ " + s [ val ] ) ; } public static void Main ( ) { check ( 30 ) ; check ( - 20 ) ; check ( 0 ) ; } }
using System ; class GFG { static bool checking ( string s ) { int c = 0 ; int n = s . Length ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '0' ) c ++ ; if ( c >= 6 && s [ i ] == '1' ) return true ; } return false ; } public static void Main ( ) { String s = "100010001" ; if ( checking ( s ) ) Console . WriteLine ( " Possible " ) ; else Console . WriteLine ( " Not ▁ possible " ) ; } }
using System ; class GFG { public static int modifyBit ( int n , int p , int b ) { int mask = 1 << p ; return ( n & ~ mask ) | ( ( b << p ) & mask ) ; } static public void Main ( ) { Console . WriteLine ( modifyBit ( 6 , 2 , 0 ) ) ; Console . WriteLine ( modifyBit ( 6 , 5 , 1 ) ) ; } }
using System ; class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } static int countSetBitsInGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return countSetBits ( n & num ) ; } public static void Main ( ) { int n = 42 ; int l = 2 , r = 5 ; Console . WriteLine ( countSetBitsInGivenRange ( n , l , r ) ) ; } }
using System ; class GFG { public static bool areAllBitsSet ( long n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } public static bool isOnesComplementOfOther ( long a , long b ) { return areAllBitsSet ( a ^ b ) ; } public static void Main ( ) { long a = 10 , b = 5 ; if ( isOnesComplementOfOther ( a , b ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int findUnique ( int [ ] a , int n , int k ) { byte sizeof_int = 4 ; int INT_SIZE = 8 * sizeof_int ; int [ ] count = new int [ INT_SIZE ] ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; int res = 0 ; for ( int i = 0 ; i < INT_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; } public static void Main ( String [ ] args ) { int [ ] a = { 6 , 2 , 5 , 2 , 2 , 6 , 6 } ; int n = a . Length ; int k = 3 ; Console . WriteLine ( findUnique ( a , n , k ) ) ; } }
using System ; class GFG { static bool powerOfTwo ( uint n ) { return ( ( n & n - 1 ) == 0 ) ; } static bool onlyFirstAndLastAreSet ( uint n ) { if ( n == 1 ) return true ; return powerOfTwo ( n - 1 ) ; } public static void Main ( ) { uint n = ( uint ) 9 ; if ( onlyFirstAndLastAreSet ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static bool allBitsAreSet ( int n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } static bool bitsAreInAltOrder ( int n ) { int num = n ^ ( n >> 1 ) ; return allBitsAreSet ( num ) ; } public static void Main ( ) { int n = 10 ; if ( bitsAreInAltOrder ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int setBit ( int xorValue ) { int count = 0 ; while ( xorValue >= 1 ) { if ( xorValue % 2 == 1 ) count ++ ; xorValue /= 2 ; } return count ; } static int minFlip ( int n , int k ) { int size = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; int max = ( int ) Math . Pow ( 2 , k ) - 1 ; max = max << ( size - k ) ; int xorValue = ( n ^ max ) ; return ( setBit ( xorValue ) ) ; } public static void Main ( ) { int n = 27 , k = 3 ; Console . Write ( " Min ▁ Flips ▁ = ▁ " + minFlip ( n , k ) ) ; } }
using System ; class GFG { static int setallbitgivenrange ( int n , int l , int r ) { int range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; } static void Main ( ) { int n = 17 , l = 2 , r = 3 ; Console . Write ( setallbitgivenrange ( n , l , r ) ) ; } }
using System ; class GFG { static uint countBits ( uint number ) { return ( uint ) Math . Log ( number , 2.0 ) + 1 ; } public static void Main ( ) { uint num = 65 ; Console . WriteLine ( countBits ( num ) ) ; } }
using System ; public class GFG { static String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return " Yes " ; return " No " ; } static public void Main ( ) { int n = 17 ; int l = 2 ; int r = 4 ; Console . WriteLine ( allBitsSetInTheGivenRange ( n , l , r ) ) ; } }
using System ; class GFG { static int setAllBitsAfterMSB ( int n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; } static int toggle ( int n ) { n = n ^ setAllBitsAfterMSB ( n ) ; return n ; } public static void Main ( ) { int n = 10 ; n = toggle ( n ) ; Console . WriteLine ( n ) ; } }
using System ; class GFG { static int getRightMostSetBit ( int n ) { return ( int ) ( ( Math . Log ( n & - n ) ) / ( Math . Log ( 2 ) ) ) + 1 ; } static int posOfRightMostSameBit ( int m , int n ) { return getRightMostSetBit ( ~ ( m ^ n ) ) ; } public static void Main ( ) { int m = 16 , n = 7 ; Console . Write ( " Position ▁ = ▁ " + posOfRightMostSameBit ( m , n ) ) ; } }
using System ; class GFG { static String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( num == new_num ) return " Yes " ; return " No " ; } public static void Main ( ) { int n = 22 ; int l = 2 , r = 3 ; Console . Write ( allBitsSetInTheGivenRange ( n , l , r ) ) ; } }
using System ; class GFG { static void printNonConsecutive ( int n ) { int p = ( 1 << n ) ; for ( int i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) Console . Write ( i + " ▁ " ) ; } public static void Main ( ) { int n = 3 ; printNonConsecutive ( n ) ; } }
using System ; class GFG { static int INT_SIZE = 32 ; static int constructNthNumber ( int group_no , int aux_num , int op ) { int [ ] a = new int [ INT_SIZE ] ; int num = 0 , len_f ; int i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num > 0 ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; } static int getNthNumber ( int n ) { int group_no = 0 , group_offset ; int count_upto_group = 0 , count_temp = 1 ; int op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 == 1 ) else aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; } public static void Main ( String [ ] args ) { int n = 9 ; Console . Write ( " { 0 } " , getNthNumber ( n ) ) ; } }
using System ; class GFG { static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( countSetBits ( i ) == 2 ) sum += i ; return sum ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( findSum ( n ) ) ; } }
using System ; namespace Toggle { public class GFG { public static int toggleLastMBits ( int n , int m ) { int num = ( 1 << m ) - 1 ; return ( n ^ num ) ; } public static void Main ( ) { int n = 107 , m = 4 ; n = toggleLastMBits ( n , m ) ; Console . Write ( n ) ; } } }
using System ; class GFG { static int getFirstSetBitPos ( int n ) { return ( int ) ( Math . Log ( n & - n ) / Math . Log ( 2 ) ) + 1 ; } static int previousSmallerInteger ( int n ) { int pos = getFirstSetBitPos ( n ) ; return ( n & ~ ( 1 << ( pos - 1 ) ) ) ; } public static void Main ( ) { int n = 25 ; Console . WriteLine ( " Previous ▁ small ▁ Integer ▁ = " + previousSmallerInteger ( n ) ) ; } }
using System ; class GFG { static String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " No " ; n = n >> 1 ; } return " Yes " ; } static public void Main ( ) { int n = 7 ; Console . WriteLine ( areAllBitsSet ( n ) ) ; } }
using System ; class GFG { static String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; if ( ( ( n + 1 ) & n ) == 0 ) return " Yes " ; return " No " ; } static public void Main ( ) { int n = 7 ; Console . WriteLine ( areAllBitsSet ( n ) ) ; } }
using System ; class GFG { static int getFirstSetBitPos ( int n ) { return ( ( int ) ( Math . Log ( n & - n ) / Math . Log ( 2 ) ) + 1 ) - 1 ; } static int nextGreaterWithOneMoreSetBit ( int n ) { int pos = getFirstSetBitPos ( ~ n ) ; if ( pos > - 1 ) return ( 1 << pos ) | n ; return ( ( n << 1 ) + 1 ) ; } public static void Main ( ) { int n = 10 ; Console . Write ( " Next ▁ greater ▁ integer ▁ = ▁ " + nextGreaterWithOneMoreSetBit ( n ) ) ; } }
using System ; class GFG { static int CountZeroBit ( int x ) { int count = 0 ; while ( x > 0 ) { if ( ( x & 1 ) == 0 ) count ++ ; x >>= 1 ; } return count ; } static int CountXORandSumEqual ( int x ) { int count = CountZeroBit ( x ) ; return ( 1 << count ) ; } static public void Main ( ) { int x = 10 ; Console . WriteLine ( CountXORandSumEqual ( x ) ) ; } }
using System ; class GFG { static int missingNumber ( int [ ] arr1 , int [ ] arr2 , int n ) { int mnum = 0 ; for ( int i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; } public static void Main ( ) { int [ ] arr1 = { 4 , 8 , 1 , 3 , 7 } ; int [ ] arr2 = { 7 , 4 , 3 , 1 } ; int n = arr1 . Length ; Console . Write ( " Missing ▁ number ▁ = ▁ " + missingNumber ( arr1 , arr2 , n ) ) ; } }
using System ; class GFG { static int countValues ( int x ) { int count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x /= 2 ; } return count ; } public static void Main ( ) { int x = 10 ; Console . Write ( countValues ( x ) ) ; } }
using System ; class GFG { static void constructXOR ( int [ ] A , int n ) { int XOR = 0 ; for ( int i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( int i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; } public static void Main ( ) { int [ ] A = { 2 , 4 , 1 , 3 , 5 } ; int n = A . Length ; constructXOR ( A , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( A [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int bitCount ( int n ) { int count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) ++ count ; n >>= 1 ; } return count ; } static long countPairsWithKDiff ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < n - 1 ; ++ i ) { for ( int j = i + 1 ; j < n ; ++ j ) { int xoredNum = arr [ i ] ^ arr [ j ] ; if ( k == bitCount ( xoredNum ) ) ++ ans ; } } return ans ; } public static void Main ( ) { int k = 2 ; int [ ] arr = { 2 , 4 , 1 , 3 , 1 } ; int n = arr . Length ; Console . WriteLine ( " Total ▁ pairs ▁ for ▁ k ▁ = ▁ " + k + " ▁ are ▁ " + countPairsWithKDiff ( arr , n , k ) + " STRNEWLINE " ) ; } }
using System ; class GFG { static int multiply ( int n , int m ) { int ans = 0 , count = 0 ; while ( m > 0 ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m /= 2 ; } return ans ; } public static void Main ( ) { int n = 20 , m = 13 ; Console . WriteLine ( multiply ( n , m ) ) ; } }
using System ; class GFG { static bool EqualNumber ( int A , int B ) { if ( ( A ^ B ) > 0 ) return true ; else return false ; } public static void Main ( ) { int A = 5 , B = 6 ; if ( ! EqualNumber ( A , B ) == false ) Console . WriteLine ( "0" ) ; else Console . WriteLine ( "1" ) ; } }
using System ; class GFG { static bool areSetBitsIncreasing ( int n ) { int prev_count = int . MaxValue ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = n / 2 ; int curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; } static public void Main ( ) { int n = 10 ; if ( areSetBitsIncreasing ( n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class Test { static bool findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; } public static void Main ( ) { int n = 10 ; Console . WriteLine ( findPattern ( n ) ? " Yes " : " No " ) ; } }
using System ; class GFG { static int countXOR ( int n ) { int count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n /= 2 ; } return ( count0 ^ count1 ) ; } public static void Main ( ) { int n = 31 ; Console . WriteLine ( countXOR ( n ) ) ; } }
using System ; class GFG { static int msbPos ( long n ) { int msb_p = - 1 ; while ( n > 0 ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; } static long andOperator ( long x , long y ) { long res = 0 ; while ( x > 0 && y > 0 ) { int msb_p1 = msbPos ( x ) ; int msb_p2 = msbPos ( y ) ; if ( msb_p1 != msb_p2 ) break ; long msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ; x = x - msb_val ; y = y - msb_val ; } return res ; } public static void Main ( ) { long x = 10 , y = 15 ; Console . WriteLine ( andOperator ( x , y ) ) ; } }
using System ; class GFG { public static int multiplyTen ( int n ) { return ( n << 1 ) + ( n << 3 ) ; } public static void Main ( ) { int n = 50 ; Console . Write ( multiplyTen ( n ) ) ; } }
using System ; class GFG { public static int countValues ( int n ) { int countV = 0 ; for ( int i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; } public static void Main ( ) { int n = 12 ; Console . WriteLine ( countValues ( n ) ) ; } }
using System ; public class GFG { public static int countValues ( int n ) { int unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; } public static void Main ( String [ ] args ) { int n = 12 ; Console . WriteLine ( countValues ( n ) ) ; } }
using System ; class GFG { static char findProffesion ( int level , int pos ) { if ( level == 1 ) return ' e ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' d ' ) return ( pos % 2 > 0 ) ? ' d ' : ' e ' ; return ( pos % 2 > 0 ) ? ' e ' : ' d ' ; } public static void Main ( ) { int level = 4 , pos = 2 ; if ( findProffesion ( level , pos ) == ' e ' ) Console . WriteLine ( " Engineer " ) ; else Console . WriteLine ( " Doctor " ) ; } }
using System ; class GFG { static void printTwoSetBitNums ( int n ) { int x = 1 ; while ( n > 0 ) { int y = 0 ; while ( y < x ) { Console . Write ( ( ( 1 << x ) + ( 1 << y ) ) + " ▁ " ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } } public static void Main ( ) { int n = 4 ; printTwoSetBitNums ( n ) ; } }
using System ; class GFG { static void printRepeatingEven ( int [ ] arr , int n ) { long _xor = 0L ; long pos ; for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; _xor ^= pos ; } for ( int i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; if ( ! ( ( pos & _xor ) != 0 ) ) { Console . Write ( arr [ i ] + " ▁ " ) ; _xor ^= pos ; } } } public static void Main ( ) { int [ ] arr = { 9 , 12 , 23 , 10 , 12 , 12 , 15 , 23 , 14 , 12 , 15 } ; int n = arr . Length ; printRepeatingEven ( arr , n ) ; } }
using System ; class GFG { static int countSetBits ( int x ) { int count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; } static bool isBleak ( int n ) { for ( int x = 1 ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; } public static void Main ( ) { if ( isBleak ( 3 ) ) Console . Write ( " Yes " ) ; else Console . WriteLine ( " No " ) ; if ( isBleak ( 4 ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int INT_BITS = 32 ; static int maxSubarrayXOR ( int [ ] set , int n ) { int index = 0 ; for ( int i = INT_BITS - 1 ; i >= 0 ; i -- ) { int maxInd = index ; int maxEle = int . MinValue ; for ( int j = index ; j < n ; j ++ ) { if ( ( set [ j ] & ( 1 << i ) ) != 0 && set [ j ] > maxEle ) { maxEle = set [ j ] ; maxInd = j ; } } if ( maxEle == - 2147483648 ) continue ; int temp = set [ index ] ; set [ index ] = set [ maxInd ] ; set [ maxInd ] = temp ; maxInd = index ; for ( int j = 0 ; j < n ; j ++ ) { if ( j != maxInd && ( set [ j ] & ( 1 << i ) ) != 0 ) set [ j ] = set [ j ] ^ set [ maxInd ] ; } index ++ ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) res ^= set [ i ] ; return res ; } public static void Main ( ) { int [ ] set = { 9 , 8 , 5 } ; int n = set . Length ; Console . Write ( " Max ▁ subset ▁ XOR ▁ is ▁ " ) ; Console . Write ( maxSubarrayXOR ( set , n ) ) ; } }
using System ; class GFG { static int findXOR ( int [ ] Set , int n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; } public static void Main ( ) { int [ ] Set = { 1 , 2 , 3 } ; int n = Set . Length ; Console . Write ( " XOR ▁ of ▁ XOR ' s ▁ of ▁ all ▁ subsets ▁ is ▁ " + findXOR ( Set , n ) ) ; } }
using System ; class GFG { static int myXOR ( int x , int y ) { return ( x y ) & ( ~ x ~ y ) ; } static public void Main ( ) { int x = 3 , y = 5 ; Console . WriteLine ( " XOR ▁ is ▁ " + ( myXOR ( x , y ) ) ) ; } }
using System ; class GFG { static int N = 2 ; static bool freivald ( int [ , ] a , int [ , ] b , int [ , ] c ) { Random rand = new Random ( ) ; int [ ] r = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) r [ i ] = ( int ) ( rand . Next ( ) ) % 2 ; int [ ] br = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) br [ i ] = br [ i ] + b [ i , j ] * r [ j ] ; int [ ] cr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) cr [ i ] = cr [ i ] + c [ i , j ] * r [ j ] ; int [ ] axbr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) axbr [ i ] = axbr [ i ] + a [ i , j ] * br [ j ] ; for ( int i = 0 ; i < N ; i ++ ) if ( axbr [ i ] - cr [ i ] != 0 ) return false ; return true ; } static bool isProduct ( int [ , ] a , int [ , ] b , int [ , ] c , int k ) { for ( int i = 0 ; i < k ; i ++ ) if ( freivald ( a , b , c ) == false ) return false ; return true ; } static void Main ( ) { int [ , ] a = new int [ , ] { { 1 , 1 } , { 1 , 1 } } ; int [ , ] b = new int [ , ] { { 1 , 1 } , { 1 , 1 } } ; int [ , ] c = new int [ , ] { { 2 , 2 } , { 2 , 2 } } ; int k = 2 ; if ( isProduct ( a , b , c , k ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static float calc_Expectation ( float [ ] a , float n ) { float prb = ( 1 / n ) ; float sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; } public static void Main ( ) { float expect , n = 6f ; float [ ] a = { 1f , 2f , 3f , 4f , 5f , 6f } ; expect = calc_Expectation ( a , n ) ; Console . WriteLine ( " Expectation " + " ▁ of ▁ array ▁ E ( X ) ▁ is ▁ : ▁ " + expect ) ; } }
using System ; class GFG { static void findPoints ( int l1 , int r1 , int l2 , int r2 ) { int x = ( l1 != l2 ) ? Math . Min ( l1 , l2 ) : - 1 ; int y = ( r1 != r2 ) ? Math . Max ( r1 , r2 ) : - 1 ; Console . WriteLine ( x + " ▁ " + y ) ; } public static void Main ( ) { int l1 = 5 , r1 = 10 , l2 = 1 , r2 = 7 ; findPoints ( l1 , r1 , l2 , r2 ) ; } }
using System ; class GFG { static int fact ( int n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } public static void Main ( ) { Console . Write ( fact ( 5 ) ) ; } }
using System ; class GFG { static void printElements ( int [ ] a , int n ) { Array . Sort ( a ) ; a = reverse ( a ) ; int cnt = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] != a [ i + 1 ] ) { Console . Write ( a [ i ] + " ▁ occurs ▁ " + cnt + " ▁ times STRNEWLINE " ) ; cnt = 1 ; } else cnt += 1 ; } Console . Write ( a [ n - 1 ] + " ▁ occurs ▁ " + cnt + " ▁ times STRNEWLINE " ) ; } static int [ ] reverse ( int [ ] a ) { int i , n = a . Length , t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 } ; int n = a . Length ; printElements ( a , n ) ; } }
using System ; class GFG { static bool checkIndices ( int [ ] Arr , int N ) { for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; } static public void Main ( ) { int [ ] Arr = { 3 , 2 , 1 , 1 , 4 } ; int N = Arr . Length ; if ( checkIndices ( Arr , N ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static void printPairs ( int [ ] arr , int n , int sum ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) Console . Write ( " ( " + arr [ i ] + " , ▁ " + arr [ j ] + " ) " + " STRNEWLINE " ) ; } public static void Main ( ) { int [ ] arr = { 1 , 5 , 7 , - 1 , 5 } ; int n = arr . Length ; int sum = 6 ; printPairs ( arr , n , sum ) ; } }
using System ; class GFG { static int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { int j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; } public static void Main ( ) { int [ ] arr = { 2 , 2 , 3 , 5 , 6 } ; int n = arr . Length ; Console . WriteLine ( minSum ( arr , n ) ) ; } }
using System ; class GFG { static int minSum ( int [ ] arr , int n ) { int sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; } public static void Main ( ) { int [ ] arr = { 2 , 2 , 3 , 5 , 6 } ; int n = arr . Length ; Console . WriteLine ( minSum ( arr , n ) ) ; } }
using System ; class GFG { public static bool PandigitalProduct_1_9 ( int n ) { for ( int i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 && isPandigital ( " " + n + i + n / i ) ) return true ; return false ; } public static bool isPandigital ( String str ) { if ( str . Length != 9 ) return false ; char [ ] ch = str . ToCharArray ( ) ; Array . Sort ( ch ) ; return new String ( ch ) . Equals ( "123456789" ) ; } public static void Main ( ) { int n = 6952 ; if ( PandigitalProduct_1_9 ( n ) == true ) Console . Write ( " yes " ) ; else Console . Write ( " no " ) ; } }
using System ; using System . Linq ; class GFG { static void printModeMedian ( int [ ] a , int n ) { int [ ] b = new int [ n ] ; int max = a . Max ( ) ; int t = max + 1 ; int [ ] count = new int [ t ] ; for ( int i = 0 ; i < t ; i ++ ) { count [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { count [ a [ i ] ] ++ ; } int mode = 0 ; int k = count [ 0 ] ; for ( int i = 1 ; i < t ; i ++ ) { if ( count [ i ] > k ) { k = count [ i ] ; mode = i ; } } for ( int i = 1 ; i < t ; i ++ ) { count [ i ] = count [ i ] + count [ i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { b [ count [ a [ i ] ] - 1 ] = a [ i ] ; count [ a [ i ] ] -- ; } float median ; if ( n % 2 != 0 ) { median = b [ n / 2 ] ; } else { median = ( float ) ( ( b [ ( n - 1 ) / 2 ] + b [ ( n / 2 ) ] ) / 2.0 ) ; } Console . WriteLine ( " median ▁ = ▁ " + median ) ; Console . WriteLine ( " mode ▁ = ▁ " + mode ) ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 4 , 1 , 2 , 7 , 1 , 2 , 5 , 3 , 6 } ; int n = a . Length ; printModeMedian ( a , n ) ; } }
using System ; class GeeksforGeeks { static int MAX = 26 ; static bool function ( String str ) { int l = str . Length ; int [ ] counter1 = new int [ MAX ] ; int [ ] counter2 = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { counter1 [ i ] = 0 ; counter2 [ i ] = 0 ; } for ( int i = 0 ; i < l / 2 ; i ++ ) counter1 [ str [ i ] - ' a ' ] ++ ; for ( int i = l / 2 ; i < l ; i ++ ) counter2 [ str [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( counter2 [ i ] != counter1 [ i ] ) return true ; } return false ; } public static void Main ( ) { String str = " abcasdsabcae " ; if ( function ( str ) ) Console . WriteLine ( " Yes , ▁ both ▁ halves ▁ " + " differ ▁ by ▁ at ▁ least ▁ one ▁ character " ) ; else Console . WriteLine ( " No , ▁ both ▁ halves ▁ " + " do ▁ not ▁ differ ▁ at ▁ all " ) ; } }
using System ; class GFG { static int minDifferenceAmongMaxMin ( int [ ] arr , int N , int K ) { Array . Sort ( arr ) ; int res = 2147483647 ; for ( int i = 0 ; i <= ( N - K ) ; i ++ ) { int curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . Min ( res , curSeqDiff ) ; } return res ; } public static void Main ( ) { int [ ] arr = { 10 , 20 , 30 , 100 , 101 , 102 } ; int N = arr . Length ; int K = 3 ; Console . Write ( minDifferenceAmongMaxMin ( arr , N , K ) ) ; } }
using System ; class ArrayIndex { static int getIndexInSortedArray ( int [ ] arr , int n , int idx ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; } public static void Main ( ) { int [ ] arr = { 3 , 4 , 3 , 5 , 2 , 3 , 4 , 3 , 1 , 5 } ; int n = arr . Length ; int idxOfEle = 5 ; Console . WriteLine ( getIndexInSortedArray ( arr , n , idxOfEle ) ) ; } }
using System ; class GFG { static int getMaxValue ( int [ ] arr , int arr_size ) { int i , first , second ; if ( arr_size < 2 ) { return 0 ; } first = second = int . MinValue ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } if ( second == int . MinValue ) { return 0 ; } else { return second ; } } public static void Main ( ) { int [ ] arr = { 4 , 5 , 1 , 8 } ; int n = arr . Length ; Console . Write ( getMaxValue ( arr , n ) ) ; } }
using System ; class GFG { static int maximumResult ( int a , int b , int c ) { int countOfNegative = 0 ; int sum = a + b + c ; int product = a * b * c ; int largest = ( a > b ) ? ( ( a > c ) ? a : c ) : ( ( b > c ) ? b : c ) ; int smallest = ( a < b ) ? ( ( a < c ) ? a : c ) : ( ( b < c ) ? b : c ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } return - 1 ; } static void Main ( ) { int a = - 2 , b = - 1 , c = - 4 ; Console . WriteLine ( maximumResult ( a , b , c ) ) ; } }
using System ; using System . Collections . Generic ; using System . Collections ; using System . Linq ; class GFG { static int check ( int n , List < int > marks ) { int x = marks . Max ( ) ; int bonus = 100 - x ; int c = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; } public static void Main ( ) { int n = 5 ; List < int > marks = new List < int > ( new int [ ] { 0 , 21 , 83 , 45 , 64 } ) ; Console . WriteLine ( check ( n , marks ) ) ; } }
using System ; class GFG { static int find_sum ( int n , int k ) { int total_sum = ( n * ( n + 1 ) ) / 2 ; int power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; } public static void Main ( ) { int n = 11 , k = 2 ; Console . WriteLine ( find_sum ( n , k ) ) ; } }
using System ; public class Solution { public const int MAX = 10000 ; public static int [ ] hashTable = new int [ MAX ] ; public static int minOperations ( int [ ] arr , int n ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { hashTable [ arr [ i ] ] ++ ; } int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] != 0 ) { for ( int j = i ; j < n ; j ++ ) { if ( arr [ j ] % arr [ i ] == 0 ) { hashTable [ arr [ j ] ] = 0 ; } } res ++ ; } } return res ; } public static void Main ( string [ ] args ) { int [ ] arr = new int [ ] { 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 } ; int n = arr . Length ; Console . Write ( minOperations ( arr , n ) ) ; } }
using System ; class GFG { static bool ifPossible ( int [ ] arr , int n ) { int [ ] cp = new int [ n ] ; Array . Copy ( arr , cp , n ) ; Array . Sort ( cp ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == cp [ i ] ) && ! ( arr [ n - 1 - i ] == cp [ i ] ) ) return false ; } return true ; } public static void Main ( ) { int [ ] arr = new int [ ] { 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 } ; int n = arr . Length ; if ( ifPossible ( arr , n ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GfG { static int FindMinimumCost ( int ind , int [ ] a , int n , int k , int [ ] dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { int ans = int . MaxValue ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . Min ( ans , Math . Abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } } public static void Main ( ) { int [ ] a = { 10 , 30 , 40 , 50 , 20 } ; int k = 3 ; int n = a . Length ; int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = - 1 ; Console . WriteLine ( FindMinimumCost ( 0 , a , n , k , dp ) ) ; } }
using System ; using System ; class GFG { public const int MAX = 100000 ; public static long [ ] prefix = new long [ MAX ] ; public static void sieve_modified ( ) { for ( int i = 2 ; i < MAX ; i += 2 ) { for ( int j = i ; j < MAX ; j += i ) { prefix [ j ] += i ; } } for ( int i = 1 ; i < MAX ; i ++ ) { prefix [ i ] += prefix [ i - 1 ] ; } } public static long sumEvenFactors ( int L , int R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; } public static void Main ( string [ ] args ) { sieve_modified ( ) ; int l = 6 , r = 10 ; Console . Write ( sumEvenFactors ( l , r ) ) ; } }
using System ; class GFG { static readonly int N = 1000 ; static int find ( int index , int openbrk , int n , int [ , ] dp , int [ ] adj ) { if ( openbrk < 0 ) { return 0 ; } if ( index == n ) { if ( openbrk == 0 ) { return 1 ; } else { return 0 ; } } if ( dp [ index , openbrk ] != - 1 ) { return dp [ index , openbrk ] ; } if ( adj [ index ] == 1 ) { dp [ index , openbrk ] = find ( index + 1 , openbrk + 1 , n , dp , adj ) ; } else { dp [ index , openbrk ] = find ( index + 1 , openbrk + 1 , n , dp , adj ) + find ( index + 1 , openbrk - 1 , n , dp , adj ) ; } return dp [ index , openbrk ] ; } public static void Main ( ) { int [ , ] dp = new int [ N , N ] ; int n = 2 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { dp [ i , j ] = - 1 ; } } int [ ] adj = { 1 , 0 , 0 , 0 } ; Console . WriteLine ( find ( 0 , 0 , 2 * n , dp , adj ) ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void findMaxValUtil ( int [ ] arr , int n , int num , int maxLimit , int ind , ref int ans ) { if ( ind == n ) { ans = Math . Max ( ans , num ) ; return ; } if ( num - arr [ ind ] >= 0 ) { findMaxValUtil ( arr , n , num - arr [ ind ] , maxLimit , ind + 1 , ref ans ) ; } if ( num + arr [ ind ] <= maxLimit ) { findMaxValUtil ( arr , n , num + arr [ ind ] , maxLimit , ind + 1 , ref ans ) ; } } static int findMaxVal ( int [ ] arr , int n , int num , int maxLimit ) { int ans = 0 ; int ind = 0 ; findMaxValUtil ( arr , n , num , maxLimit , ind , ref ans ) ; return ans ; } public static void Main ( ) { int num = 1 ; int [ ] arr = { 3 , 10 , 6 , 4 , 5 } ; int n = arr . Length ; int maxLimit = 15 ; Console . Write ( findMaxVal ( arr , n , num , maxLimit ) ) ; } }
using System ; using System . Collections . Generic ; using System . Linq ; using System . Collections ; class GFG { static void printSets ( List < int > set1 , List < int > set2 ) { int i ; for ( i = 0 ; i < set1 . Count ; i ++ ) { Console . Write ( set1 [ i ] + " ▁ " ) ; } Console . WriteLine ( ) ; for ( i = 0 ; i < set2 . Count ; i ++ ) { Console . Write ( set2 [ i ] + " ▁ " ) ; } } static bool findSets ( int [ ] arr , int n , ref List < int > set1 , ref List < int > set2 , int sum1 , int sum2 , int pos ) { if ( pos == n ) { if ( sum1 == sum2 ) { printSets ( set1 , set2 ) ; return true ; } else return false ; } set1 . Add ( arr [ pos ] ) ; bool res = findSets ( arr , n , ref set1 , ref set2 , sum1 + arr [ pos ] , sum2 , pos + 1 ) ; if ( res == true ) return res ; set1 . RemoveAt ( set1 . Count - 1 ) ; set2 . Add ( arr [ pos ] ) ; res = findSets ( arr , n , ref set1 , ref set2 , sum1 , sum2 + arr [ pos ] , pos + 1 ) ; if ( res == false ) if ( set2 . Count > 0 ) set2 . RemoveAt ( set2 . Count - 1 ) ; return res ; } static bool isPartitionPoss ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; List < int > set1 = new List < int > ( ) ; List < int > set2 = new List < int > ( ) ; return findSets ( arr , n , ref set1 , ref set2 , 0 , 0 , 0 ) ; } public static void Main ( ) { int [ ] arr = { 5 , 5 , 1 , 11 } ; int n = arr . Length ; if ( isPartitionPoss ( arr , n ) == false ) { Console . Write ( " - 1" ) ; } } }
using System ; class GFG { static int maximumSumSubarray ( int [ ] arr , int n ) { int min_prefix_sum = 0 ; int res = int . MinValue ; int [ ] prefix_sum = new int [ n ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { res = Math . Max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . Min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; } public static void Main ( ) { int [ ] arr1 = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; int n1 = arr1 . Length ; Console . WriteLine ( maximumSumSubarray ( arr1 , n1 ) ) ; int [ ] arr2 = { 4 , - 8 , 9 , - 4 , 1 , - 8 , - 1 , 6 } ; int n2 = arr2 . Length ; Console . WriteLine ( maximumSumSubarray ( arr2 , n2 ) ) ; } }
using System ; class GFG { static int DP_s = 9 ; static int getNumMonotone ( int len ) { int [ , ] DP = new int [ len , DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 , i ] = i + 1 ; for ( int i = 0 ; i < len ; ++ i ) DP [ i , 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i , j ] = DP [ i - 1 , j ] + DP [ i , j - 1 ] ; return DP [ len - 1 , DP_s - 1 ] ; } public static void Main ( ) { Console . WriteLine ( getNumMonotone ( 10 ) ) ; } }
using System ; class GFG { static int sequence ( int n ) { int [ ] f = new int [ n + 1 ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; int i ; for ( i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; } public static void Main ( ) { int n = 10 ; Console . Write ( sequence ( n ) ) ; } }
using System ; using System . Linq ; public class GFG { static long lis ( long [ ] arr , long n ) { long [ ] mpis = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; return mpis . Max ( ) ; } static public void Main ( ) { long [ ] arr = { 3 , 100 , 4 , 5 , 150 , 6 } ; long n = arr . Length ; Console . WriteLine ( lis ( arr , n ) ) ; } }
using System ; class GFG { static int Hosoya ( int n , int m ) { if ( ( n == 0 && m == 0 ) || ( n == 1 && m == 0 ) || ( n == 1 && m == 1 ) || ( n == 2 && m == 1 ) ) return 1 ; if ( n > m ) return Hosoya ( n - 1 , m ) + Hosoya ( n - 2 , m ) ; else if ( m == n ) return Hosoya ( n - 1 , m - 1 ) + Hosoya ( n - 2 , m - 2 ) ; else return 0 ; } static void printHosoya ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) Console . Write ( Hosoya ( i , j ) + " ▁ " ) ; Console . WriteLine ( " " ) ; } } public static void Main ( ) { int n = 5 ; printHosoya ( n ) ; } }
using System ; class Eulerian { public static int eulerian ( int n , int m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; } public static void Main ( ) { int n = 3 , m = 1 ; Console . WriteLine ( eulerian ( n , m ) ) ; } }
using System ; using System . Linq ; public class GFG { static int largestSubset ( int [ ] a , int n ) { int [ ] dp = new int [ n ] ; dp [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int mxm = 0 ; for ( int j = i + 1 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) mxm = Math . Max ( mxm , dp [ j ] ) ; dp [ i ] = 1 + mxm ; } return dp . Max ( ) ; } static public void Main ( ) { int [ ] a = { 1 , 3 , 6 , 13 , 17 , 18 } ; int n = a . Length ; Console . WriteLine ( largestSubset ( a , n ) ) ; } }
using System ; class GFG { static int countFriendsPairings ( int n ) { int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; } public static void Main ( ) { int n = 4 ; Console . Write ( countFriendsPairings ( n ) ) ; } }
using System ; class GFG { static int countFriendsPairings ( int n ) { int a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( int i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; } public static void Main ( String [ ] args ) { int n = 4 ; Console . WriteLine ( countFriendsPairings ( n ) ) ; } }
using System ; class GFG { static int lcsOf3 ( String X , String Y , String Z , int m , int n , int o ) { int [ , , ] L = new int [ m + 1 , n + 1 , o + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { for ( int k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i , j , k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i , j , k ] = L [ i - 1 , j - 1 , k - 1 ] + 1 ; else L [ i , j , k ] = Math . Max ( Math . Max ( L [ i - 1 , j , k ] , L [ i , j - 1 , k ] ) , L [ i , j , k - 1 ] ) ; } } } return L [ m , n , o ] ; } public static void Main ( ) { string X = " AGGT12" ; string Y = "12TXAYB " ; string Z = "12XBA " ; int m = X . Length ; int n = Y . Length ; int o = Z . Length ; Console . Write ( " Length ▁ of ▁ LCS ▁ is ▁ " + lcsOf3 ( X , Y , Z , m , n , o ) ) ; } }
using System ; class GFG { static int findLongestRepeatingSubSeq ( string str ) { int n = str . Length ; int [ , ] dp = new int [ n + 1 , n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i , j ] = 1 + dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = Math . Max ( dp [ i , j - 1 ] , dp [ i - 1 , j ] ) ; } } return dp [ n , n ] ; } public static void Main ( ) { string str = " aabb " ; Console . Write ( " The ▁ length ▁ of ▁ the ▁ largest ▁ " + " subsequence ▁ that ▁ repeats ▁ itself ▁ is ▁ : ▁ " + findLongestRepeatingSubSeq ( str ) ) ; } }
using System ; class GFG { static int numberOfPaths ( int m , int n ) { int [ ] dp = new int [ n ] ; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; } public static void Main ( ) { Console . Write ( numberOfPaths ( 3 , 3 ) ) ; } }
using System ; class GFG { static int factorial ( int N ) { if ( N == 0 N == 1 ) return 1 ; return N * factorial ( N - 1 ) ; } static int nthTerm ( int N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; } public static void Main ( ) { int N = 6 ; Console . Write ( nthTerm ( N ) ) ; } }
using System ; class GFG { static bool isFrequencyEqual ( String str , int len ) { if ( len % 2 == 1 ) { return false ; } int i ; int [ ] freq = new int [ 26 ] ; for ( i = 0 ; i < len ; i ++ ) { freq [ str [ i ] - ' a ' ] ++ ; } for ( i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] == len / 2 ) { return true ; } } return false ; } public static void Main ( ) { String str = " geeksforgeeks " ; int len = str . Length ; if ( isFrequencyEqual ( str , len ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static readonly int MAX = 26 ; static int countMinimalReplacements ( char [ ] s ) { int n = s . Length ; int cnt = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { cnt += 1 ; if ( i != ( n - 1 ) ) { foreach ( char it in "012" . ToCharArray ( ) ) { if ( it != s [ i + 1 ] && it != s [ i - 1 ] ) { s [ i ] = it ; break ; } } } { foreach ( char it in "012" . ToCharArray ( ) ) { if ( it != s [ i - 1 ] ) { s [ i ] = it ; break ; } } } } } return cnt ; } public static void Main ( String [ ] args ) { String s = "201220211" ; Console . WriteLine ( countMinimalReplacements ( s . ToCharArray ( ) ) ) ; } }
using System ; public class GFG { static int nextIndex ( string str , int start , char c ) { for ( int i = start ; i < str . Length ; i ++ ) { if ( str [ i ] == c ) return i ; } return - 1 ; } static int countSubStrings ( string str ) { int i , n = str . Length ; int [ ] countX = new int [ n ] ; int count = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' x ' ) count ++ ; countX [ i ] = count ; } int nextIndexX = nextIndex ( str , 0 , ' x ' ) ; int nextIndexY = nextIndex ( str , 0 , ' y ' ) ; count = 0 ; while ( nextIndexX != - 1 && nextIndexY != - 1 ) { if ( nextIndexX > nextIndexY ) { nextIndexY = nextIndex ( str , nextIndexY + 1 , ' y ' ) ; continue ; } else { count += countX [ nextIndexY ] ; nextIndexX = nextIndex ( str , nextIndexX + 1 , ' x ' ) ; } } return count ; } public static void Main ( ) { string s = " xyyxx " ; Console . WriteLine ( countSubStrings ( s ) ) ; } }
using System ; class GFG { static String minimize ( string str ) { string mstr = " ▁ " ; int l , i ; int [ ] flagchar = new int [ 26 ] ; char ch ; l = str . Length ; for ( i = 0 ; i < str . Length ; i ++ ) { ch = str [ i ] ; if ( flagchar [ ch - 97 ] == 0 ) { mstr = mstr + ch ; flagchar [ ch - 97 ] = 1 ; } } } static void replaceMinimizeUtil ( string str ) { string minimizedStr , finalStr = " " ; int i , index , l ; char ch ; l = str . Length ; for ( i = 0 ; i < minimizedStr . Length ; i ++ ) { ch = minimizedStr [ i ] ; index = ( ch * ch ) % l ; finalStr = finalStr + str [ index ] ; } Console . Write ( " Final ▁ String : ▁ " + finalStr ) ; } public static void Main ( ) { string str = " geeks " ; replaceMinimizeUtil ( str ) ; } }
using System ; public class LatinCipher { static void cipher ( String str ) { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( ! char . IsLetter ( str [ i ] ) && str [ i ] != ' ▁ ' ) { Console . WriteLine ( " Enter ▁ only ▁ alphabets ▁ and ▁ space " ) ; return ; } } Console . WriteLine ( " Encrypted ▁ Code ▁ using ▁ Latin ▁ Alphabet " ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { Console . Write ( str [ i ] - ' A ' + 1 + " ▁ " ) ; } else if ( str [ i ] >= ' a ' && str [ i ] <= ' z ' ) { Console . Write ( str [ i ] - ' a ' + 1 + " ▁ " ) ; } if ( str [ i ] == ' ▁ ' ) Console . Write ( str [ i ] ) ; } Console . WriteLine ( ) ; } public static void Main ( String [ ] args ) { String str = " geeksforgeeks " ; cipher ( str ) ; } }
using System ; class GFG { static int round ( int n ) { int a = ( n / 10 ) * 10 ; int b = a + 10 ; return ( n - a > b - n ) ? b : a ; } public static void Main ( ) { int n = 4722 ; Console . WriteLine ( round ( n ) ) ; } }
using System ; class GFG { static int countOccurrences ( string s , int K ) { int n = s . Length ; int C = 0 , c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' ) c1 ++ ; if ( s [ i ] == ' b ' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; } public static void Main ( ) { string S = " abcb " ; int k = 2 ; Console . WriteLine ( countOccurrences ( S , k ) ) ; } }
using System ; public class GFG { static string findString ( int n , int k ) { string res = " " ; for ( int i = 0 ; i < k ; i ++ ) res = res + ( char ) ( ' a ' + i ) ; int count = 0 ; for ( int i = 0 ; i < n - k ; i ++ ) { res = res + ( char ) ( ' a ' + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; } static public void Main ( ) { int n = 5 , k = 2 ; Console . WriteLine ( findString ( n , k ) ) ; } }
using System ; public class GFG { public static int isVowel ( char ch ) { ch = char . ToUpper ( ch ) ; if ( ch == ' A ' ch == ' E ' ch == ' I ' ch == ' O ' ch == ' U ' ) { return 1 ; } else { return 0 ; } } public static int countVowels ( string str , int n ) { if ( n == 1 ) { return isVowel ( str [ n - 1 ] ) ; } return countVowels ( str , n - 1 ) + isVowel ( str [ n - 1 ] ) ; } public static void Main ( string [ ] args ) { string str = " abc ▁ de " ; Console . WriteLine ( countVowels ( str , str . Length ) ) ; } }
using System ; using System . Text ; class Test { static void printRotatedString ( String str ) { int n = str . Length ; StringBuilder sb = new StringBuilder ( str ) ; sb . Append ( str ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j != n ; j ++ ) Console . Write ( sb [ i + j ] ) ; Console . WriteLine ( ) ; } } public static void Main ( String [ ] args ) { String str = " geeks " ; printRotatedString ( str ) ; } }
using System ; class GFG { static int M = 26 ; static int getIdx ( char ch ) { return ( ch - ' a ' ) ; } static bool allSame ( int [ ] freq , int N ) { int same = 0 ; int i ; for ( i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 0 ) { same = freq [ i ] ; break ; } } for ( int j = i + 1 ; j < N ; j ++ ) if ( freq [ j ] > 0 && freq [ j ] != same ) return false ; return true ; } static bool possibleSameCharFreqByOneRemoval ( string str ) { int l = str . Length ; int [ ] freq = new int [ M ] ; for ( int i = 0 ; i < l ; i ++ ) freq [ getIdx ( str [ i ] ) ] ++ ; if ( allSame ( freq , M ) ) return true ; for ( char c = ' a ' ; c <= ' z ' ; c ++ ) { int i = getIdx ( c ) ; if ( freq [ i ] > 0 ) { freq [ i ] -- ; if ( allSame ( freq , M ) ) return true ; freq [ i ] ++ ; } } return false ; } public static void Main ( ) { string str = " xyyzz " ; if ( possibleSameCharFreqByOneRemoval ( str ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static bool check ( string str ) { int n = str . Length ; int oddDigSum = 0 , evenDigSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - '0' ) ; else evenDigSum += ( str [ i ] - '0' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; } public static void Main ( ) { String str = "76945" ; if ( check ( str ) ) Console . WriteLine ( " Yes " ) ; else Console . WriteLine ( " No " ) ; } }
using System ; class GFG { static int hammingDist ( String str1 , String str2 ) { int i = 0 , count = 0 ; while ( i < str1 . Length ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; } public static void Main ( ) { String str1 = " geekspractice " ; String str2 = " nerdspractise " ; Console . Write ( hammingDist ( str1 , str2 ) ) ; } }
using System ; class GFG { static int MAX_CHAR = 26 ; static bool arekAnagrams ( string str1 , string str2 , int k ) { int n = str1 . Length ; if ( str2 . Length != n ) return false ; int [ ] count1 = new int [ MAX_CHAR ] ; int [ ] count2 = new int [ MAX_CHAR ] ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . Abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; } public static void Main ( ) { string str1 = " anagram " ; string str2 = " grammar " ; int k = 2 ; if ( arekAnagrams ( str1 , str2 , k ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { int countSubStr ( char [ ] str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) m ++ ; } return m * ( m - 1 ) / 2 ; } public static void Main ( String [ ] args ) { GFG count = new GFG ( ) ; String strings = "00100101" ; char [ ] str = strings . ToCharArray ( ) ; int n = str . Length ; Console . Write ( count . countSubStr ( str , n ) ) ; } }
using System ; class GFG { static int count9s ( String number ) { int count = 0 ; int n = number . Length ; for ( int i = 0 ; i < n ; i ++ ) { int sum = number [ i ] - '0' ; if ( number [ i ] == '9' ) count ++ ; for ( int j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - '0' ) % 9 ; if ( sum == 0 ) count ++ ; } } return count ; } public static void Main ( ) { Console . WriteLine ( count9s ( "4189" ) ) ; Console . WriteLine ( count9s ( "1809" ) ) ; } }
using System ; class GFG { public static int minStepsRecur ( int [ ] height , int l , int r , int h ) { if ( l >= r ) return 0 ; int m = l ; for ( int i = l ; i < r ; i ++ ) if ( height [ i ] < height [ m ] ) m = i ; return Math . Min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) ; } public static int minSteps ( int [ ] height , int N ) { return minStepsRecur ( height , 0 , N , 0 ) ; } public static void Main ( ) { int [ ] height = { 2 , 1 , 2 , 5 , 1 } ; int N = height . Length ; Console . Write ( minSteps ( height , N ) ) ; } }
using System ; class GFG { static double reuleauxArea ( double a ) { if ( a < 0 ) return - 1 ; double A = 0.70477 * Math . Pow ( a , 2 ) ; return A ; } static public void Main ( ) { double a = 6 ; Console . WriteLine ( reuleauxArea ( a ) ) ; } }
using System ; class GFG { static double hexagonside ( double a ) { if ( a < 0 ) return - 1 ; double x = ( 0.5176 * a ) ; return x ; } public static void Main ( ) { double a = 6 ; Console . WriteLine ( hexagonside ( a ) ) ; } }
using System ; class CLG { static float hexagonside ( float a ) { if ( a < 0 ) return - 1 ; float x = a / 3 ; return x ; } public static void Main ( ) { float a = 6 ; Console . Write ( hexagonside ( a ) ) ; } }
using System ; class GFG { static int findSegment ( int n , int m , int [ ] segment_length ) { double meet_point = ( 1.0 * n ) / 2.0 ; int sum = 0 ; int segment_number = 0 ; for ( int i = 0 ; i < m ; i ++ ) { sum += segment_length [ i ] ; if ( ( double ) sum == meet_point ) { segment_number = - 1 ; break ; } if ( sum > meet_point ) { segment_number = i + 1 ; break ; } } return segment_number ; } public static void Main ( ) { int n = 13 ; int m = 3 ; int [ ] segment_length = new int [ ] { 3 , 2 , 8 } ; int ans = findSegment ( n , m , segment_length ) ; Console . WriteLine ( ans ) ; } }
using System ; class GFG { public static long countMaxIntersect ( long n ) { return ( n ) * ( n - 1 ) / 2 ; } public static void Main ( ) { long n = 8 ; Console . WriteLine ( countMaxIntersect ( n ) ) ; } }
using System ; class GFG { static float surfaceArea ( float a , float b , float h ) { return 5 * a * b + 5 * b * h ; } static float volume ( float b , float h ) { return ( 5 * b * h ) / 2 ; } public static void Main ( ) { float a = 5 ; float b = 3 ; float h = 7 ; Console . WriteLine ( " surface ▁ area ▁ = ▁ " + surfaceArea ( a , b , h ) + " , ▁ " ) ; Console . WriteLine ( " volume ▁ = ▁ " + volume ( b , h ) ) ; } }
using System ; class GFG { public static int checkpoint ( int h , int k , int x , int y , int a ) { int p = ( int ) Math . Pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ; return p ; } public static void Main ( string [ ] arr ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 ; if ( checkpoint ( h , k , x , y , a ) > 0 ) { Console . WriteLine ( " Outside " ) ; } else if ( checkpoint ( h , k , x , y , a ) == 0 ) { Console . WriteLine ( " On ▁ the ▁ parabola " ) ; } else { Console . WriteLine ( " Inside " ) ; } } }
using System ; class GFG { static int checkpoint ( int h , int k , int x , int y , int a , int b ) { int p = ( ( int ) Math . Pow ( ( x - h ) , 2 ) / ( int ) Math . Pow ( a , 2 ) ) + ( ( int ) Math . Pow ( ( y - k ) , 2 ) / ( int ) Math . Pow ( b , 2 ) ) ; return p ; } public static void Main ( ) { int h = 0 , k = 0 , x = 2 , y = 1 , a = 4 , b = 5 ; if ( checkpoint ( h , k , x , y , a , b ) > 1 ) Console . WriteLine ( " Outside " ) ; else if ( checkpoint ( h , k , x , y , a , b ) == 1 ) Console . WriteLine ( " On ▁ the ▁ ellipse " ) ; else Console . WriteLine ( " Inside " ) ; } }
using System ; public class GFG { public static float circlearea ( double a , double b ) { if ( a < 0 b < 0 ) return - 1 ; float A = ( float ) ( ( 3.14 * Math . Pow ( a , 2 ) * Math . Pow ( b , 2 ) ) / ( 4 * ( Math . Pow ( a , 2 ) + Math . Pow ( b , 2 ) ) ) ) ; return A ; } public static void Main ( ) { float a = 8 , b = 10 ; Console . WriteLine ( circlearea ( a , b ) ) ; } }
using System ; class GFG { static float circlearea ( float l , float b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( float ) ( 3.14 * Math . Pow ( l / 2 , 2 ) ) ; else return ( float ) ( 3.14 * Math . Pow ( b / 2 , 2 ) ) ; } public static void Main ( ) { float l = 4 , b = 8 ; Console . Write ( circlearea ( l , b ) ) ; } }
using System ; class GFG { static int centered_cube ( int n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; } static public void Main ( ) { int n = 3 ; Console . Write ( n + " th ▁ Centered " + " ▁ cube ▁ number : ▁ " ) ; Console . WriteLine ( centered_cube ( n ) ) ; n = 10 ; Console . Write ( n + " th ▁ Centered " + " ▁ cube ▁ number : ▁ " ) ; Console . WriteLine ( centered_cube ( n ) ) ; } }
using System ; class GFG { static void center ( int x1 , int x2 , int y1 , int y2 ) { Console . WriteLine ( ( float ) ( x1 + x2 ) / 2 + " , ▁ " + ( float ) ( y1 + y2 ) / 2 ) ; } public static void Main ( ) { int x1 = - 9 , y1 = 3 , x2 = 5 , y2 = - 7 ; center ( x1 , x2 , y1 , y2 ) ; } }
using System ; class GFG { public static void Main ( ) { double side = 3 ; Console . Write ( " Volume ▁ of ▁ octahedron ▁ = ▁ " ) ; Console . WriteLine ( vol_of_octahedron ( side ) ) ; } static double vol_of_octahedron ( double side ) { return ( ( side * side * side ) * ( Math . Sqrt ( 2 ) / 3 ) ) ; } }
using System ; class GfG { public static float volumeOfEllipsoid ( float r1 , float r2 , float r3 ) { float pi = ( float ) 3.14 ; return ( float ) 1.33 * pi * r1 * r2 * r3 ; } public static void Main ( ) { float r1 = ( float ) 2.3 , r2 = ( float ) 3.4 , r3 = ( float ) 5.7 ; Console . WriteLine ( " volume ▁ of ▁ ellipsoid ▁ is ▁ : ▁ " + volumeOfEllipsoid ( r1 , r2 , r3 ) ) ; } }
using System ; class GFG { static double areaOctagon ( double side ) { return ( float ) ( 2 * ( 1 + Math . Sqrt ( 2 ) ) * side * side ) ; } public static void Main ( ) { double side = 4 ; Console . WriteLine ( " Area ▁ of ▁ Regular ▁ Octagon ▁ = ▁ " + areaOctagon ( side ) ) ; } }
using System ; class GFG { static double areaCube ( double a ) { return ( a * a * a ) ; } static double surfaceCube ( double a ) { return ( 6 * a * a ) ; } public static void Main ( ) { double a = 5 ; Console . WriteLine ( " Area ▁ = ▁ " + areaCube ( a ) ) ; Console . WriteLine ( " Total ▁ surface ▁ area ▁ = ▁ " + surfaceCube ( a ) ) ; } }
using System ; class GFG { static double minRevolutions ( double r , int x1 , int y1 , int x2 , int y2 ) { double d = Math . Sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . Ceiling ( d / ( 2 * r ) ) ; } public static void Main ( ) { int r = 2 , x1 = 0 , y1 = 0 ; int x2 = 0 , y2 = 4 ; Console . Write ( ( int ) minRevolutions ( r , x1 , y1 , x2 , y2 ) ) ; } }
using System ; public class GFG { static double eps = ( double ) 1e-6 ; static double getArea ( double base1 , double hypotenuse ) { double height = Math . Sqrt ( hypotenuse * hypotenuse - base1 * base1 ) ; return 0.5 * base1 * height ; } static void printRightAngleTriangle ( int hypotenuse , int area ) { int hsquare = hypotenuse * hypotenuse ; double sideForMaxArea = Math . Sqrt ( hsquare / 2.0 ) ; double maxArea = getArea ( sideForMaxArea , hypotenuse ) ; if ( area > maxArea ) { Console . Write ( " Not ▁ possible " ) ; return ; } double low = 0.0 ; double high = sideForMaxArea ; double base1 = 0 ; while ( Math . Abs ( high - low ) > eps ) { base1 = ( low + high ) / 2.0 ; if ( getArea ( base1 , hypotenuse ) >= area ) { high = base1 ; } else { low = base1 ; } } double height = Math . Sqrt ( hsquare - base1 * base1 ) ; Console . WriteLine ( Math . Round ( base1 ) + " ▁ " + Math . Round ( height ) ) ; } static public void Main ( ) { int hypotenuse = 5 ; int area = 6 ; printRightAngleTriangle ( hypotenuse , area ) ; } }
using System ; class GFG { static int countLattice ( int r ) { if ( r <= 0 ) return 0 ; int result = 4 ; for ( int x = 1 ; x < r ; x ++ ) { int ySquare = r * r - x * x ; int y = ( int ) Math . Sqrt ( ySquare ) ; if ( y * y == ySquare ) result += 4 ; } return result ; } public static void Main ( ) { int r = 5 ; Console . Write ( countLattice ( r ) ) ; } }
using System ; class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } public static void Main ( ) { int L = 2 ; int P = ( int ) Math . Pow ( 10 , 9 ) ; int ans = power ( 325 , L , P ) ; Console . WriteLine ( ans ) ; } }
using System ; class GFG { static int MAXN = 30 ; static int countMaxLength ( int N ) { int res ; int [ ] pre = new int [ MAXN ] ; int p = 1 ; pre [ 0 ] = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { p *= 2 ; pre [ i ] = pre [ i - 1 ] + i * p ; } int ind = 0 ; for ( int i = 1 ; i < MAXN ; i ++ ) { if ( pre [ i ] >= N ) { ind = i ; break ; } } int x = N - pre [ ind - 1 ] ; int y = 2 * ind - 1 ; if ( x >= y ) res = Math . Min ( x , y ) ; else res = Math . Max ( x , 2 * ( ind - 2 ) + 1 ) ; return res ; } public static void Main ( ) { int N = 25 ; Console . WriteLine ( countMaxLength ( N ) ) ; } }
using System ; class GFG { static int factorialUsingRecursion ( int n ) { if ( n == 0 ) return 1 ; return n * factorialUsingRecursion ( n - 1 ) ; } static int factorialUsingIteration ( int n ) { int res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; } public static void Main ( String [ ] args ) { int num = 5 ; Console . WriteLine ( " Factorial ▁ of ▁ " + num + " ▁ using ▁ Recursion ▁ is : ▁ " + factorialUsingRecursion ( 5 ) ) ; Console . WriteLine ( " Factorial ▁ of ▁ " + num + " ▁ using ▁ Iteration ▁ is : ▁ " + factorialUsingIteration ( 5 ) ) ; } }
using System ; class GFG { static int maxSum ( int [ ] arr , int n , int K ) { int maximum = int . MinValue ; int [ ] sum = new int [ n ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i + K < n ) sum [ i ] = sum [ i + K ] + arr [ i ] ; else sum [ i ] = arr [ i ] ; maximum = Math . Max ( maximum , sum [ i ] ) ; } return maximum ; } public static void Main ( ) { int [ ] arr = { 3 , 6 , 4 , 7 , 2 } ; int n = arr . Length ; int K = 2 ; Console . Write ( maxSum ( arr , n , K ) ) ; } }
using System ; class GFG { static void findpair ( int l , int r ) { int c = 0 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { Console . Write ( i + " , ▁ " + j ) ; c = 1 ; break ; } } if ( c == 1 ) break ; } } static void Main ( ) { int l = 1 , r = 10 ; findpair ( l , r ) ; } }
using System ; using System . Collections . Generic ; class GFG { public static bool check ( int [ ] arr , int N , int K ) { HashSet < int > unique = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { unique . Add ( arr [ i ] ) ; } if ( unique . Count == K ) { return true ; } return false ; } public static void Main ( string [ ] args ) { int [ ] arr = new int [ ] { 1 , 1 , 2 , 3 } ; int N = arr . Length ; int K = 3 ; if ( check ( arr , N , K ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static int minIndex ( int [ ] arr , int n , int pos ) { int num = arr [ pos ] ; int i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 1 , 1 , 1 , 5 , 2 } ; int n = arr . Length ; int pos = 4 ; Console . WriteLine ( minIndex ( arr , n , pos ) ) ; } }
using System ; class GFG { static int findAnswer ( string str1 , string str2 , int n ) { int l = 0 , r = 0 ; int ans = 2 ; for ( int i = 0 ; i < n ; ++ i ) { if ( str1 [ i ] != str2 [ i ] ) { l = i ; break ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( str1 [ i ] != str2 [ i ] ) { r = i ; break ; } } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 [ i ] != str2 [ i - 1 ] ) { ans -- ; break ; } } for ( int i = l + 1 ; i <= r ; i ++ ) { if ( str1 [ i - 1 ] != str2 [ i ] ) { ans -- ; break ; } } return ans ; } } public static void Main ( ) { String str1 = " toy " , str2 = " try " ; int n = str1 . Length ; Console . WriteLine ( findAnswer ( str1 , str2 , n ) ) ; } }
using System ; public class GFG { static int findMinDifference ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . Min ( diff1 , diff2 ) ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 4 , 3 , 4 } ; int n = arr . Length ; Console . Write ( findMinDifference ( arr , n ) ) ; } }
using System ; public class GFG { static int findMinDifference ( int [ ] arr , int n ) { int min , secondMin , max , secondMax ; min = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { secondMax = max ; max = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min ) { secondMin = min ; min = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } int diff = Math . Min ( max - secondMin , secondMax - min ) ; return diff ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 4 , 3 , 4 } ; int n = arr . Length ; Console . WriteLine ( findMinDifference ( arr , n ) ) ; } }
using System ; class GFG { static Boolean checkDistinct ( int x ) { int last = x % 10 ; while ( x > 0 ) { if ( x % 10 != last ) return false ; x = x / 10 ; } return true ; } static int findCount ( int L , int R ) { int count = 0 ; for ( int i = L ; i <= R ; i ++ ) { if ( checkDistinct ( i ) ) count += 1 ; } return count ; } static public void Main ( String [ ] args ) { int L = 10 , R = 50 ; Console . WriteLine ( findCount ( L , R ) ) ; } }
using System ; class GFG { static int smallest_pair ( int [ ] a , int n ) { int min = int . MaxValue , secondMin = int . MaxValue ; for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int n = arr . Length ; Console . Write ( smallest_pair ( arr , n ) ) ; } }
using System ; class GFG { static int longestsubarray ( int [ ] arr , int n , int k ) { int current_count = 0 ; int max_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . Max ( current_count , max_count ) ; } return max_count ; } public static void Main ( ) { int [ ] arr = { 2 , 5 , 11 , 32 , 64 , 88 } ; int n = arr . Length ; int k = 8 ; Console . Write ( longestsubarray ( arr , n , k ) ) ; } }
using System ; public class GFG { static bool check ( String s ) { for ( int i = 0 ; i < s . Length - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; } public static void Main ( ) { String s = " xzyyz " ; if ( check ( s ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static int countAnomalies ( int [ ] arr , int n , int k ) { int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . Abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; } public static void Main ( ) { int [ ] arr = { 7 , 1 , 8 } ; int k = 5 ; int n = arr . Length ; Console . WriteLine ( countAnomalies ( arr , n , k ) ) ; } }
using System ; class GFG { static int colMaxDiff ( int [ , ] mat ) { int max_diff = int . MinValue ; for ( int i = 0 ; i < N ; i ++ ) { int max_val = mat [ 0 , i ] , min_val = mat [ 0 , i ] ; for ( int j = 1 ; j < N ; j ++ ) { max_val = Math . Max ( max_val , mat [ j , i ] ) ; min_val = Math . Min ( min_val , mat [ j , i ] ) ; } max_diff = Math . Max ( max_diff , max_val - min_val ) ; } return max_diff ; } public static void Main ( ) { int [ , ] mat = { { 1 , 2 , 3 , 4 , 5 } , { 5 , 3 , 5 , 4 , 0 } , { 5 , 6 , 7 , 8 , 9 } , { 0 , 6 , 3 , 4 , 12 } , { 9 , 7 , 12 , 4 , 3 } } ; Console . WriteLine ( " Max ▁ difference ▁ : ▁ " + colMaxDiff ( mat ) ) ; } }
using System ; class GFG { static int search ( int [ ] ar , int size ) { int a = 0 , b = size - 1 ; int mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 1 ) ; } static public void Main ( String [ ] args ) { int [ ] ar = { 1 , 2 , 3 , 4 , 5 , 6 , 8 } ; int size = ar . Length ; Console . WriteLine ( " Missing ▁ number : ▁ " + search ( ar , size ) ) ; } }
using System ; class GFG { static int deleteElement ( int [ ] A , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; } public static void Main ( ) { int [ ] A = new int [ ] { 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 } ; int L = 2 , R = 7 ; int n = A . Length ; int res_size = deleteElement ( A , L , R , n ) ; for ( int i = 0 ; i < res_size ; i ++ ) Console . Write ( A [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int findmissing ( int [ ] ar , int N ) { int l = 0 , r = N - 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return ( mid + 1 ) ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 7 , 8 } ; int N = arr . Length ; Console . WriteLine ( findmissing ( arr , N ) ) ; } }
using System ; class GFG { static int findFirst ( int [ ] arr , int n , int x ) { Array . Sort ( arr ) ; int ptr = lowerBound ( arr , 0 , n , x ) ; return ( arr [ ptr ] != x ) ? - 1 : ( ptr ) ; } static int lowerBound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) low = middle + 1 ; else high = middle ; } return low ; } static public void Main ( ) { int x = 20 ; int [ ] arr = { 10 , 30 , 20 , 50 , 20 } ; int n = arr . Length ; Console . Write ( findFirst ( arr , n , x ) ) ; } }
using System ; public class GFG { static int findFirst ( int [ ] arr , int n , int x ) { int count = 0 ; bool isX = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { isX = true ; } else if ( arr [ i ] < x ) { count ++ ; } } return ( isX == false ) ? - 1 : count ; } public static void Main ( ) { int x = 20 ; int [ ] arr = { 10 , 30 , 20 , 50 , 20 } ; int n = arr . Length ; Console . WriteLine ( findFirst ( arr , n , x ) ) ; } }
using System ; class GFG { public static int findDuplicate ( int [ ] arr ) { int slow = arr [ 0 ] ; int fast = arr [ 0 ] ; do { slow = arr [ slow ] ; fast = arr [ arr [ fast ] ] ; } while ( slow != fast ) ; int ptr1 = arr [ 0 ] ; int ptr2 = slow ; while ( ptr1 != ptr2 ) { ptr1 = arr [ ptr1 ] ; ptr2 = arr [ ptr2 ] ; } return ptr1 ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 2 , 1 } ; Console . WriteLine ( " " + findDuplicate ( arr ) ) ; } }
using System ; class GFG { static int MAX_CHAR = 26 ; static void printGreaterCount ( string str ) { int len = str . Length ; int [ ] ans = new int [ len ] ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = len - 1 ; i >= 0 ; i -- ) { count [ str [ i ] - ' a ' ] ++ ; for ( int j = str [ i ] - ' a ' + 1 ; j < MAX_CHAR ; j ++ ) { ans [ i ] += count [ j ] ; } } for ( int i = 0 ; i < len ; i ++ ) { Console . Write ( ans [ i ] + " ▁ " ) ; } } static void Main ( ) { string str = " abcd " ; printGreaterCount ( str ) ; } }
using System ; class GFG { static int maxProduct ( int [ ] arr , int n ) { if ( n < 4 ) { return - 1 ; } int maxA = int . MinValue , maxB = int . MinValue , maxC = int . MinValue , maxD = int . MinValue ; int minA = int . MaxValue , minB = int . MaxValue , minC = int . MaxValue , minD = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxD = maxC ; maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxD = maxC ; maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) { maxD = maxC ; maxC = arr [ i ] ; } else if ( arr [ i ] > maxD ) { maxD = arr [ i ] ; } if ( arr [ i ] < minA ) { minD = minC ; minC = minB ; minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) { minD = minC ; minC = minB ; minB = arr [ i ] ; } else if ( arr [ i ] < minC ) { minD = minC ; minC = arr [ i ] ; } else if ( arr [ i ] < minD ) { minD = arr [ i ] ; } } int x = maxA * maxB * maxC * maxD ; int y = minA * minB * minC * minD ; int z = minA * minB * maxA * maxB ; return Math . Max ( x , Math . Max ( y , z ) ) ; } public static void Main ( ) { int [ ] arr = { 1 , - 4 , 3 , - 6 , 7 , 0 } ; int n = arr . Length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) Console . Write ( " No ▁ Quadruple ▁ Exists " ) ; else Console . Write ( " Maximum ▁ product ▁ is ▁ " + max ) ; } }
using System ; class GFG { static int countTripletsLessThanL ( int n , int L , int [ ] arr ) { Array . Sort ( arr ) ; int ways = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { int mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . Length ; int L = 3 ; int ans = countTripletsLessThanL ( n , L , arr ) ; Console . WriteLine ( " Total ▁ Number ▁ of ▁ ways ▁ = ▁ " + ans ) ; } }
using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static int missingNum ( int [ ] arr , int n ) { List < int > list = new List < int > ( arr . Length ) ; foreach ( int i in arr ) { list . Add ( i ) ; } int minvalue = list . Min ( ) ; int xornum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; } public static void Main ( String [ ] args ) { int [ ] arr = { 13 , 12 , 11 , 15 } ; int n = arr . Length ; Console . WriteLine ( missingNum ( arr , n ) ) ; } }
using System ; class GFG { static int findLastIndex ( string str , char x ) { int index = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; } public static void Main ( ) { string str = " geeksforgeeks " ; char x = ' e ' ; int index = findLastIndex ( str , x ) ; if ( index == - 1 ) Console . WriteLine ( " Character ▁ not ▁ found " ) ; else Console . WriteLine ( " Last ▁ index ▁ is ▁ " + index ) ; } }
using System ; class GFG { static int findLastIndex ( string str , char x ) { for ( int i = str . Length - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return - 1 ; } public static void Main ( ) { string str = " geeksforgeeks " ; char x = ' e ' ; int index = findLastIndex ( str , x ) ; if ( index == - 1 ) Console . WriteLine ( " Character ▁ not ▁ found " ) ; else Console . WriteLine ( " Last ▁ index ▁ is ▁ " + index ) ; } }
using System ; class GFG { static int countMaxSetBits ( int left , int right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; } static public void Main ( ) { int l = 1 ; int r = 5 ; Console . WriteLine ( countMaxSetBits ( l , r ) ) ; l = 1 ; r = 10 ; Console . WriteLine ( countMaxSetBits ( l , r ) ) ; } }
using System ; public class GFG { static int findS ( int s ) { int l = 1 , r = ( s / 2 ) + 1 ; while ( l <= r ) { int mid = ( l + r ) / 2 ; int sum = mid * ( mid + 1 ) / 2 ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } static public void Main ( ) { int s = 15 ; int n = findS ( s ) ; if ( n == - 1 ) Console . WriteLine ( " - 1" ) ; else Console . WriteLine ( n ) ; } }
using System ; class GFG { static void pendulumArrangement ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int odd , temp , p , pos ; pos = n - 1 ; if ( n % 2 == 0 ) odd = n - 1 ; else odd = n - 2 ; while ( odd > 0 ) { temp = arr [ odd ] ; p = odd ; while ( p != pos ) { arr [ p ] = arr [ p + 1 ] ; p ++ ; } arr [ p ] = temp ; odd = odd - 2 ; pos = pos - 1 ; } int start = 0 , end = ( n - 1 ) / 2 ; for ( ; start < end ; start ++ , end -- ) { temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; } public static void Main ( ) { int [ ] arr = { 11 , 2 , 4 , 55 , 6 , 8 } ; int n = arr . Length ; pendulumArrangement ( arr , n ) ; } }
using System ; class GFG { static int findNumber ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int max = arr [ n - 1 ] ; int [ ] table = new int [ ( 2 * max ) + 1 ] ; table [ 0 ] = 0 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = int . MaxValue ; int ans = - 1 ; for ( int i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { int res = table [ i - arr [ j ] ] ; if ( res != int . MaxValue && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } } if ( i > arr [ n - 1 ] && table [ i ] == int . MaxValue ) { ans = i ; break ; } } return ans ; } public static void Main ( ) { int [ ] arr = { 6 , 7 , 15 } ; int n = arr . Length ; Console . WriteLine ( findNumber ( arr , n ) ) ; } }
using System ; class GFG { static int countPoints ( int n , int m , int [ ] a , int [ ] b , int x , int y ) { Array . Sort ( a ) ; Array . Sort ( b ) ; int j = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; } public static void Main ( ) { int x = 1 , y = 4 ; int [ ] a = { 1 , 5 } ; int n = a . Length ; int [ ] b = { 1 , 1 , 2 } ; int m = a . Length ; Console . WriteLine ( countPoints ( n , m , a , b , x , y ) ) ; } }
using System ; using System . Linq ; public class GFG { static int minSubarray ( int [ ] A , int n ) { int minValue = A . Min ( ) ; int maxValue = A . Max ( ) ; int pos_min = - 1 , pos_max = - 1 , ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] == minValue ) pos_min = i ; if ( A [ i ] == maxValue ) pos_max = i ; if ( pos_max != - 1 && pos_min != - 1 ) ans = Math . Min ( ans , Math . Abs ( pos_min - pos_max ) + 1 ) ; } return ans ; } static public void Main ( ) { int [ ] A = { 1 , 5 , 9 , 7 , 1 , 9 , 4 } ; int n = A . Length ; Console . WriteLine ( minSubarray ( A , n ) ) ; } }
using System ; class GFG { static int countSequences ( int [ ] arr , int n ) { int count = 1 ; Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; } static public void Main ( String [ ] args ) { int [ ] arr = { 1 , 7 , 3 , 5 , 10 } ; int n = arr . Length ; Console . WriteLine ( countSequences ( arr , n ) ) ; } }
using System ; class GFG { static long minimumMoves ( int [ ] a , int n ) { long operations = 0 ; Array . Sort ( a ) ; for ( int i = 0 ; i < n ; i ++ ) operations += ( long ) Math . Abs ( a [ i ] - ( i + 1 ) ) ; return operations ; } static public void Main ( ) { int [ ] arr = { 5 , 3 , 2 } ; int n = arr . Length ; Console . WriteLine ( minimumMoves ( arr , n ) ) ; } }
using System ; class GFG { static void printCase ( int n ) { if ( n <= 2 ) { Console . Write ( - 1 ) ; return ; } for ( int i = n ; i >= 1 ; i -- ) Console . Write ( i + " ▁ " ) ; } public static void Main ( ) { int n = 3 ; printCase ( n ) ; } }
using System ; using System . Collections ; using System . Collections . Generic ; class GFG { class sortHelper : IComparer { int IComparer . Compare ( object a , object b ) { Pair first = ( Pair ) a ; Pair second = ( Pair ) b ; if ( first . first == second . first ) { return first . second - second . second ; } return first . first - second . first ; } } public class Pair { public int first , second ; public Pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void findMissingNumber ( ArrayList ranges , int m ) { IComparer myComparer = new sortHelper ( ) ; ranges . Sort ( myComparer ) ; ArrayList ans = new ArrayList ( ) ; int prev = 0 ; for ( int j = 0 ; j < ranges . Count ; j ++ ) { int start = ( ( Pair ) ranges [ j ] ) . first ; int end = ( ( Pair ) ranges [ j ] ) . second ; for ( int i = prev + 1 ; i < start ; i ++ ) ans . Add ( i ) ; prev = end ; } for ( int i = prev + 1 ; i <= m ; i ++ ) ans . Add ( i ) ; for ( int i = 0 ; i < ans . Count ; i ++ ) { if ( ( int ) ans [ i ] <= m ) Console . Write ( ans [ i ] + " ▁ " ) ; } } public static void Main ( string [ ] args ) { int M = 6 ; ArrayList ranges = new ArrayList ( ) ; ranges . Add ( new Pair ( 1 , 2 ) ) ; ranges . Add ( new Pair ( 4 , 5 ) ) ; findMissingNumber ( ranges , M ) ; } }
using System ; class GFG { static bool check ( int n , int k , int [ ] a , int [ ] b ) { Array . Sort ( a ) ; Array . Sort ( b ) ; bool fl = false ; int ind = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { if ( fl == true ) { return false ; } fl = true ; ind = i ; } } if ( ind == - 1 | Math . Abs ( a [ ind ] - b [ ind ] ) <= k ) { return true ; } return false ; } public static void Main ( ) { int n = 2 , k = 4 ; int [ ] a = { 1 , 5 } ; int [ ] b = { 1 , 1 } ; if ( check ( n , k , a , b ) ) { Console . WriteLine ( " Yes " ) ; } else { Console . WriteLine ( " No " ) ; } } }
using System ; class GFG { static int MOD = 1000000007 ; static int SubseqWidths ( int [ ] A , int n ) { Array . Sort ( A ) ; int [ ] pow2 = new int [ n ] ; pow2 [ 0 ] = 1 ; for ( int i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; int ans = 0 ; for ( int i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; } static void Main ( ) { int [ ] A = new int [ ] { 5 , 6 , 4 , 3 , 8 } ; int n = A . Length ; Console . WriteLine ( SubseqWidths ( A , n ) ) ; } }
using System ; using System . Linq ; class GFG { static int maxArrayCover ( int [ ] a , int n , int x ) { Array . Sort ( a ) ; int cc = 0 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += a [ i ] ; if ( s > x ) { break ; } cc += 1 ; } if ( a . Sum ( ) == x ) { return n ; } else { if ( cc == n ) { return n - 1 ; } else { return cc ; } } } public static void Main ( ) { int n = 3 ; int x = 70 ; int [ ] a = new int [ ] { 10 , 20 , 30 } ; Console . WriteLine ( maxArrayCover ( a , n , x ) ) ; } }
using System ; class GFG { static int countTriplets ( int [ ] arr , int n , int m ) { int count = 0 ; Array . Sort ( arr ) ; int end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { long prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 1 , 1 , 1 , 1 } ; int n = arr . Length ; int m = 1 ; Console . WriteLine ( countTriplets ( arr , n , m ) ) ; } }
using System ; class GFG { static void sort3 ( int [ ] arr , int [ ] temp ) { if ( arr [ 1 ] < arr [ 0 ] ) { temp [ 0 ] = arr [ 0 ] ; arr [ 0 ] = arr [ 1 ] ; arr [ 1 ] = temp [ 0 ] ; } if ( arr [ 2 ] < arr [ 1 ] ) { temp [ 0 ] = arr [ 1 ] ; arr [ 1 ] = arr [ 2 ] ; arr [ 2 ] = temp [ 0 ] ; if ( arr [ 1 ] < arr [ 0 ] ) { temp [ 0 ] = arr [ 0 ] ; arr [ 0 ] = arr [ 1 ] ; arr [ 1 ] = temp [ 0 ] ; } } } public static void Main ( String [ ] args ) { int [ ] a = new int [ ] { 10 , 12 , 5 } ; int [ ] temp1 = new int [ 10 ] ; sort3 ( a , temp1 ) ; for ( int i = 0 ; i < 3 ; i ++ ) Console . Write ( a [ i ] + " ▁ " ) ; } }
using System ; class GFG { static void printTriplets ( int [ ] arr , int n , int sum ) { Array . Sort ( arr ) ; for ( int i = 0 ; i < n - 2 ; i ++ ) { int j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( int x = j + 1 ; x <= k ; x ++ ) Console . WriteLine ( arr [ i ] + " , ▁ " + arr [ j ] + " , ▁ " + arr [ x ] ) ; j ++ ; } } } } public static void Main ( ) { int [ ] arr = { 5 , 1 , 3 , 4 , 7 } ; int n = arr . Length ; int sum = 12 ; printTriplets ( arr , n , sum ) ; } }
using System ; class GFG { static bool checkFittingArrays ( int [ ] A , int [ ] B , int N ) { Array . Sort ( A ) ; Array . Sort ( B ) ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; } public static void Main ( ) { int [ ] A = { 7 , 5 , 3 , 2 } ; int [ ] B = { 5 , 4 , 8 , 7 } ; int N = A . Length ; if ( checkFittingArrays ( A , B , N ) ) Console . WriteLine ( " YES " ) ; else Console . WriteLine ( " NO " ) ; } }
using System ; class GFG { static int maximum_toys ( int [ ] cost , int N , int K ) { int count = 0 , sum = 0 ; Array . Sort ( cost ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; } public static void Main ( ) { int K = 50 ; int [ ] cost = { 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 } ; int N = cost . Length ; Console . Write ( maximum_toys ( cost , N , K ) ) ; } }
using System ; class GFG { public static bool almostSort ( int [ ] A , int n ) { for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { int temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( int i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; } public static void Main ( ) { int [ ] A = { 1 , 3 , 2 , 4 , 6 , 5 } ; int n = A . Length ; if ( almostSort ( A , n ) ) Console . Write ( " Yes " ) ; else Console . Write ( " No " ) ; } }
using System ; class GFG { static int nextGap ( int gap ) { if ( gap <= 1 ) return 0 ; return ( gap / 2 ) + ( gap % 2 ) ; } private static void merge ( int [ ] arr1 , int [ ] arr2 , int n , int m ) { int i , j , gap = n + m ; for ( gap = nextGap ( gap ) ; gap > 0 ; gap = nextGap ( gap ) ) { for ( i = 0 ; i + gap < n ; i ++ ) if ( arr1 [ i ] > arr1 [ i + gap ] ) { int temp = arr1 [ i ] ; arr1 [ i ] = arr1 [ i + gap ] ; arr1 [ i + gap ] = temp ; } for ( j = gap > n ? gap - n : 0 ; i < n && j < m ; i ++ , j ++ ) if ( arr1 [ i ] > arr2 [ j ] ) { int temp = arr1 [ i ] ; arr1 [ i ] = arr2 [ j ] ; arr2 [ j ] = temp ; } if ( j < m ) { for ( j = 0 ; j + gap < m ; j ++ ) if ( arr2 [ j ] > arr2 [ j + gap ] ) { int temp = arr2 [ j ] ; arr2 [ j ] = arr2 [ j + gap ] ; arr2 [ j + gap ] = temp ; } } } } public static void Main ( ) { int [ ] a1 = { 10 , 27 , 38 , 43 , 82 } ; int [ ] a2 = { 3 , 9 } ; merge ( a1 , a2 , a1 . Length , a2 . Length ) ; Console . Write ( " First ▁ Array : ▁ " ) ; for ( int i = 0 ; i < a1 . Length ; i ++ ) { Console . Write ( a1 [ i ] + " ▁ " ) ; } Console . WriteLine ( ) ; Console . Write ( " Second ▁ Array : ▁ " ) ; for ( int i = 0 ; i < a2 . Length ; i ++ ) { Console . Write ( a2 [ i ] + " ▁ " ) ; } } }
using System ; class GFG { public static void mergeArrays ( int [ ] arr1 , int [ ] arr2 , int n1 , int n2 , int [ ] arr3 ) { int i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) arr3 [ k ++ ] = arr1 [ i ++ ] ; else arr3 [ k ++ ] = arr2 [ j ++ ] ; } while ( i < n1 ) arr3 [ k ++ ] = arr1 [ i ++ ] ; while ( j < n2 ) arr3 [ k ++ ] = arr2 [ j ++ ] ; } public static void Main ( ) { int [ ] arr1 = { 1 , 3 , 5 , 7 } ; int n1 = arr1 . Length ; int [ ] arr2 = { 2 , 4 , 6 , 8 } ; int n2 = arr2 . Length ; int [ ] arr3 = new int [ n1 + n2 ] ; mergeArrays ( arr1 , arr2 , n1 , n2 , arr3 ) ; Console . Write ( " Array ▁ after ▁ merging STRNEWLINE " ) ; for ( int i = 0 ; i < n1 + n2 ; i ++ ) Console . Write ( arr3 [ i ] + " ▁ " ) ; } }
using System ; class GFG { static int findMinDiff ( int [ ] arr , int n , int m ) { if ( m == 0 n == 0 ) return 0 ; Array . Sort ( arr ) ; if ( n < m ) return - 1 ; int min_diff = int . MaxValue ; for ( int i = 0 ; i + m - 1 < n ; i ++ ) { int diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; } public static void Main ( ) { int [ ] arr = { 12 , 4 , 7 , 9 , 2 , 23 , 25 , 41 , 30 , 40 , 28 , 42 , 30 , 44 , 48 , 43 , 50 } ; int n = arr . Length ; Console . WriteLine ( " Minimum ▁ difference ▁ is ▁ " + findMinDiff ( arr , n , m ) ) ; } }
using System ; class GFG { static int distinctCount ( int [ ] arr , int n ) { int count = n ; int i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) { while ( i != j && arr [ i ] == arr [ i + 1 ] ) { count -- ; i ++ ; } while ( i != j && arr [ j ] == arr [ j - 1 ] ) { count -- ; j -- ; } if ( i == j ) break ; sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) { count -- ; i ++ ; j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; } public static void Main ( ) { int [ ] arr = { - 2 , - 1 , 0 , 1 , 1 } ; int n = arr . Length ; Console . WriteLine ( " Count ▁ of ▁ absolute ▁ distinct ▁ values ▁ : ▁ " + distinctCount ( arr , n ) ) ; } }
using System ; class GFG { static void sortByOneSwap ( int [ ] arr , int n ) { for ( int i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] < arr [ i - 1 ] ) { int j = i - 1 ; while ( j >= 0 && arr [ i ] < arr [ j ] ) j -- ; int temp = arr [ i ] ; arr [ i ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; break ; } } } static void printArray ( int [ ] arr , int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] arr = { 10 , 30 , 20 , 40 , 50 , 60 , 70 } ; int n = arr . Length ; Console . WriteLine ( " Given ▁ array ▁ is ▁ " ) ; printArray ( arr , n ) ; sortByOneSwap ( arr , n ) ; Console . WriteLine ( " Sorted ▁ array ▁ is ▁ " ) ; printArray ( arr , n ) ; } }
using System ; class GFG { static void flip ( int [ ] arr , int i ) { int temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } } static int findMax ( int [ ] arr , int n ) { int mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; } static int pancakeSort ( int [ ] arr , int n ) { for ( int curr_size = n ; curr_size > 1 ; -- curr_size ) { int mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } return 0 ; } static void printArray ( int [ ] arr , int arr_size ) { for ( int i = 0 ; i < arr_size ; i ++ ) Console . Write ( arr [ i ] + " ▁ " ) ; Console . Write ( " " ) ; } public static void Main ( ) { int [ ] arr = { 23 , 10 , 20 , 11 , 12 , 6 , 7 } ; int n = arr . Length ; pancakeSort ( arr , n ) ; Console . Write ( " Sorted ▁ Array : ▁ " ) ; printArray ( arr , n ) ; } }
using System ; class GFG { static String get_maximum ( char [ ] s , int [ ] a ) { int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] - '0' < a [ s [ i ] - '0' ] ) { int j = i ; while ( j < n && ( s [ j ] - '0' <= a [ s [ j ] - '0' ] ) ) { s [ j ] = ( char ) ( '0' + a [ s [ j ] - '0' ] ) ; j ++ ; } return String . Join ( " " , s ) ; } } return String . Join ( " " , s ) ; } public static void Main ( String [ ] args ) { String s = "1337" ; int [ ] a = { 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 } ; Console . WriteLine ( get_maximum ( s . ToCharArray ( ) , a ) ) ; } }
using System ; class GfG { static int countSteps ( int n ) { int steps = 0 ; while ( n > 0 ) { int largest = ( int ) Math . Sqrt ( n ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; } public static void Main ( ) { int n = 85 ; Console . WriteLine ( countSteps ( n ) ) ; } }
using System ; using System . Linq ; class GFG { static int sumArr ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } static int maxSum ( int [ ] arr , int n , int k ) { Array . Sort ( arr ) ; int i = 0 ; while ( i < n && k > 0 && arr [ i ] < 0 ) { arr [ i ] *= - 1 ; k -- ; i ++ ; } if ( k % 2 == 1 ) { int min = 0 ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ min ] > arr [ i ] ) min = i ; arr [ min ] *= - 1 ; } return sumArr ( arr , n ) ; } static void Main ( ) { int [ ] arr = { - 5 , 4 , 1 , 3 , 2 } ; int n = arr . Length ; int k = 4 ; Console . WriteLine ( maxSum ( arr , n , k ) ) ; } }
using System ; class GFG { static int Maxsum ( int c1 , int c2 , int c3 , int c4 ) { int sum = 0 ; int two34 = Math . Min ( c2 , Math . Min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . Min ( c2 , c1 ) * 12 ; return sum ; } public static void Main ( ) { int c1 = 5 , c2 = 2 , c3 = 3 , c4 = 4 ; Console . WriteLine ( Maxsum ( c1 , c2 , c3 , c4 ) ) ; } }
using System ; class GFG { static int findCountOfPairs ( int a , int b , int n ) { int ans = 0 ; ans += n * ( a / n ) * ( b / n ) ; ans += ( a / n ) * ( b % n ) ; ans += ( a % n ) * ( b / n ) ; ans += ( ( a % n ) + ( b % n ) ) / n ; return ans ; } static public void Main ( ) { int a = 5 , b = 13 , n = 3 ; Console . WriteLine ( findCountOfPairs ( a , b , n ) ) ; } }
using System ; class GFG { static void findArray ( int N , int P ) { int ans = ( P * ( P + 1 ) ) / 2 + ( N - P ) ; int [ ] arr = new int [ N + 1 ] ; for ( int i = 1 ; i <= P ; i ++ ) { arr [ i ] = i ; } for ( int i = P + 1 ; i <= N ; i ++ ) { arr [ i ] = 1 ; } Console . Write ( " The ▁ Minimum ▁ Possible ▁ Sum ▁ is : ▁ " + ans + " STRNEWLINE " ) ; Console . Write ( " The ▁ Array ▁ Elements ▁ are : ▁ STRNEWLINE " ) ; for ( int i = 1 ; i <= N ; i ++ ) { Console . Write ( arr [ i ] + " ▁ " ) ; } } public static void Main ( ) { int N = 5 , P = 3 ; findArray ( N , P ) ; } }
using System ; class GFG { static void findIntersection ( int [ , ] intervals , int N ) { int l = intervals [ 0 , 0 ] ; int r = intervals [ 0 , 1 ] ; for ( int i = 1 ; i < N ; i ++ ) { if ( intervals [ i , 0 ] > r intervals [ i , 1 ] < l ) { Console . WriteLine ( - 1 ) ; return ; } else { l = Math . Max ( l , intervals [ i , 0 ] ) ; r = Math . Min ( r , intervals [ i , 1 ] ) ; } } Console . WriteLine ( " [ " + l + " , ▁ " + r + " ] " ) ; } public static void Main ( ) { int [ , ] intervals = { { 1 , 6 } , { 2 , 8 } , { 3 , 10 } , { 5 , 8 } } ; int N = intervals . GetLength ( 0 ) ; findIntersection ( intervals , N ) ; } }
using System ; class GFG { static int cmp ( int a , int b ) { if ( a > b ) return 1 ; else if ( a == b ) return 0 ; else return - 1 ; } static int maxSubarraySize ( int [ ] arr , int n ) { int ans = 1 ; int anchor = 0 ; for ( int i = 1 ; i < n ; i ++ ) { int c = cmp ( arr [ i - 1 ] , arr [ i ] ) ; if ( c == 0 ) anchor = i ; else if ( i == n - 1 || c * cmp ( arr [ i ] , arr [ i + 1 ] ) != - 1 ) { ans = Math . Max ( ans , i - anchor + 1 ) ; anchor = i ; } } return ans ; } static void Main ( ) { int [ ] arr = { 9 , 4 , 2 , 10 , 7 , 8 , 8 , 1 , 9 } ; int n = arr . Length ; Console . WriteLine ( maxSubarraySize ( arr , n ) ) ; } }
using System ; class GFG { static int ValidPairs ( int [ ] arr , int n ) { int [ ] count = new int [ 121 ] ; for ( int i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] += 1 ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) continue ; if ( Math . Abs ( arr [ i ] - arr [ j ] ) % 2 == 1 ) continue ; ans += count [ arr [ i ] ] * count [ arr [ j ] ] ; if ( arr [ i ] == arr [ j ] ) ans -= count [ arr [ i ] ] ; } return ans ; } public static void Main ( ) { int [ ] arr = new int [ ] { 16 , 17 , 18 } ; int n = arr . Length ; Console . WriteLine ( ValidPairs ( arr , n ) ) ; } }
using System ; class GFG { static int minChanges ( int [ ] A , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; } public static void Main ( ) { int [ ] A = { 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 } ; int n = A . Length ; Console . Write ( minChanges ( A , n ) ) ; } }
using System ; class GFG { static void completeSequence ( String s ) { int n = s . Length ; int open = 0 , close = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) open ++ ; else close ++ ; if ( close > open ) { Console . Write ( " IMPOSSIBLE " ) ; return ; } } Console . Write ( s ) ; for ( int i = 0 ; i < open - close ; i ++ ) Console . Write ( " ) " ) ; } static void Main ( ) { String s = " ( ( ) ( ( ) ( " ; completeSequence ( s ) ; } }
using System ; class GFG { static void smallestPermute ( int n ) { char [ ] res = new char [ n + 1 ] ; if ( n % 2 == 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } } else { for ( int i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = ( char ) ( 48 + i + 2 ) ; else res [ i ] = ( char ) ( 48 + i ) ; } res [ n - 1 ] = ( char ) ( 48 + n - 2 ) ; res [ n - 2 ] = ( char ) ( 48 + n ) ; res [ n - 3 ] = ( char ) ( 48 + n - 1 ) ; } res [ n ] = ' \0' ; for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( res [ i ] ) ; } } public static void Main ( ) { int n = 7 ; smallestPermute ( n ) ; } }
using System ; class GFG { static int minInsertions ( int [ ] H , int n , int K ) { int inser = 0 ; for ( int i = 1 ; i < n ; ++ i ) { float diff = Math . Abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += ( int ) Math . Ceiling ( diff / K ) - 1 ; } return inser ; } static void Main ( ) { int [ ] H = new int [ ] { 2 , 4 , 8 , 16 } ; int K = 3 ; int n = H . Length ; Console . WriteLine ( minInsertions ( H , n , K ) ) ; } }
using System ; public class GFG { static int count_minimum_operations ( long n ) { int count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; } static public void Main ( ) { long n = 4 ; long ans = count_minimum_operations ( n ) ; Console . WriteLine ( ans ) ; } }
using System ; using System . Collections . Generic ; class GFG { static void maxSum ( int [ ] a , int n ) { List < int > l = new List < int > ( ) ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += Math . Abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . Add ( i + 1 ) ; else { l . Add ( i + 1 ) ; l . Add ( i ) ; } } Console . WriteLine ( s ) ; for ( int i = 0 ; i < l . Count ; i ++ ) Console . Write ( l [ i ] + " ▁ " ) ; } public static void Main ( String [ ] args ) { int n = 4 ; int [ ] a = { 1 , - 2 , - 3 , 4 } ; maxSum ( a , n ) ; } }
using System ; class GFG { static void LengthLCP ( String x , String y ) { int [ ] fr = new int [ 26 ] ; for ( int i = 0 ; i < b ; i ++ ) { fr [ y [ i ] - 97 ] += 1 ; } int c = 0 ; for ( int i = 0 ; i < a ; i ++ ) { if ( fr [ x [ i ] - 97 ] > 0 ) { c += 1 ; fr [ x [ i ] - 97 ] -= 1 ; } else break ; } Console . Write ( ( c ) ) ; } public static void Main ( ) { String x = " here " , y = " there " ; LengthLCP ( x , y ) ; } }
using System ; class GFG { static void CountPair ( int L , int R ) { int x = ( R - L + 1 ) ; Console . WriteLine ( x / 2 + " STRNEWLINE " ) ; } public static void Main ( ) { int L , R ; L = 1 ; R = 8 ; CountPair ( L , R ) ; } }
using System ; class GFG { public static int problemsLeft ( int K , int P , int N ) { if ( K <= P ) return 0 ; else return ( ( K - P ) * N ) ; } public static void Main ( ) { int K , P , N ; K = 4 ; P = 1 ; N = 10 ; Console . WriteLine ( problemsLeft ( K , P , N ) ) ; } }
using System ; class GFG { static int results ( int n , int k ) { return ( int ) Math . Round ( Math . Pow ( n , ( 1.0 / Math . Pow ( 2.0 , k ) ) ) ) ; } public static void Main ( ) { int k = 3 , n = 100000000 ; Console . Write ( " Chocolates ▁ left ▁ after ▁ " + k + " ▁ iterations ▁ are ▁ " + results ( n , k ) ) ; } }
using System ; class GFG { static int steps ( int N , int M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; } public static void Main ( ) { int N = 4 , M = 4 ; Console . WriteLine ( steps ( N , M ) ) ; } }
using System ; class GFG { static void survival ( int S , int N , int M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) Console . Write ( " No " ) ; else { int days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; Console . WriteLine ( " Yes ▁ " + days ) ; } } public static void Main ( ) { int S = 10 , N = 16 , M = 2 ; survival ( S , N , M ) ; } }
