function isEven ( arr , n , r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { let oddCount = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; } let arr = [ 1 , 0 ] ; let n = arr . length ; let r = 2 ; if ( isEven ( arr , n , r ) ) document . write ( " " ) ; else document . write ( " " ) ;
function solve ( a , n ) { let ones = 0 , twos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } let ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; let evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( let i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + " " ) ; } let a = [ 1 , 2 , 1 , 2 , 1 ] ; let n = a . length ; solve ( a , n ) ;
function CreateArray ( N , even , odd ) { let EvenPreSums = 1 ; let temp = - 1 ; let OddPreSums = 0 ; for ( let i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } } if ( temp == - 1 ) { document . write ( temp ) ; } else { EvenPreSums = ( ( N + 1 ) - OddPreSums ) ; let e = 1 ; let o = 0 ; let CurrSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( CurrSum % 2 == 0 ) { if ( e < EvenPreSums ) { e ++ ; document . write ( " " ) ; } else { o ++ ; document . write ( " " ) ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; document . write ( " " ) ; CurrSum ++ ; } else { o ++ ; document . write ( " " ) ; } } } document . write ( ) ; } } let N = 15 ; let even = 60 , odd = 60 ; CreateArray ( N , even , odd ) ;
function findX ( A , B ) { let j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; } let A = 2 , B = 3 ; let X = findX ( A , B ) ; document . write ( " " + X + " " + ( ( A ^ X ) + ( B ^ X ) ) ) ;
function isSumEqual ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; } let arr = [ 1 , 2 , 3 , 4 , 10 ] ; let n = arr . length ; if ( isSumEqual ( arr , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function perfectSquares ( a , b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; } function countOnes ( arr , n ) { return perfectSquares ( 1 , n ) ; } var N = 10 ; var arr = [ 0 ] ; document . write ( countOnes ( arr , N ) ) ;
function printPosition ( A , B , sizeOfA , sizeOfB ) { for ( i = 1 ; i < sizeOfA ; i ++ ) { A [ i ] += A [ i - 1 ] ; } for ( i = 0 ; i < sizeOfB ; i ++ ) { var row = lower_bound ( A , 0 , A . length , B [ i ] ) ; var boxNumber = ( row >= 1 ) ? B [ i ] - A [ row - 1 ] : B [ i ] ; document . write ( row + 1 + " " + boxNumber + " " ) ; } } function lower_bound ( a , low , high , element ) { while ( low < high ) { var middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) { low = middle + 1 ; } else { high = middle ; } } return low ; } var A = [ 2 , 2 , 2 , 2 ] ; var B = [ 1 , 2 , 3 , 4 ] ; var sizeOfA = A . length ; var sizeOfB = B . length ; printPosition ( A , B , sizeOfA , sizeOfB ) ;
function primeFactors ( n , freq ) { var cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ; var i ; for ( i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; } if ( n > 2 ) freq [ n ] = 1 ; } function getMaximumPower ( n , m ) { var freq1 = new Array ( n + 1 ) ; var freq2 = new Array ( m + 1 ) ; primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; var maxi = 0 ; for ( i = 2 ; i <= m ; i ++ ) { if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ; if ( freq2 [ i ] > freq1 [ i ] ) return 0 ; if ( freq2 [ i ] ) { maxi = Math . max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; } var n = 48 , m = 4 ; document . write ( getMaximumPower ( n , m ) ) ;
function findDivisors ( n ) { let div = new Array ( n + 1 ) . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( let i = 1 ; i <= n ; i ++ ) document . write ( div [ i ] + " " ) ; } let n = 10 ; findDivisors ( n ) ;
function decideWinner ( a , n ) { var count0 = 0 ; var count1 = 0 ; var count2 = 0 ; var count3 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; } var a = [ 4 , 8 , 5 , 9 ] ; var n = a . length ; if ( decideWinner ( a , n ) == 1 ) document . write ( " " ) ; else document . write ( " " ) ;
function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; } let arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] ; let n = arr . length ; let x = 2 ; document . write ( CntDivbyX ( arr , n , x ) ) ;
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; } var K = 7 ; document . write ( numLen ( K ) ) ;
var max_Element = 1e6 + 5 ; var sum1 = new Array ( max_Element ) . fill ( 0 ) ; var sum2 = new Array ( max_Element ) . fill ( 0 ) ; var sum3 = new Array ( max_Element ) . fill ( 0 ) ; function precomputation ( arr , n ) { for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( var i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( var i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( var i = 0 ; i < n ; i ++ ) document . write ( sum3 [ arr [ i ] ] + " " ) ; } var arr = [ 9 , 5 , 6 ] ; var n = 3 ; precomputation ( arr , n ) ;
function fib ( n ) { var phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return parseInt ( Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ) ; } function calculateSum ( l , r ) { var sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } var l = 4 , r = 8 ; document . write ( calculateSum ( l , r ) ) ;
function printBalancedExpression ( a , b , c , d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( i = 1 ; i <= a ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= c ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= d ; i ++ ) document . write ( " " ) ; for ( i = 1 ; i <= b ; i ++ ) document . write ( " " ) ; } else document . write ( - 1 ) ; } var a = 3 , b = 1 , c = 4 , d = 3 ; printBalancedExpression ( a , b , c , d ) ;
function factorial ( f ) { var fact = 1 ; for ( var i = 2 ; i <= f ; i ++ ) fact *= i ; return fact ; } function findPermutation ( N , M ) { var permutation = factorial ( N + M - 1 ) / ( factorial ( N ) * factorial ( M - 1 ) ) ; return permutation ; } var N = 3 , M = 3 ; document . write ( findPermutation ( N , M ) ) ;
function maxValue ( n ) { if ( n == 1 ) return 0 ; return ( parseInt ( n * n / 2 ) - 1 ) ; } var n = 4 ; document . write ( maxValue ( n ) ) ;
function findCount ( n ) { var a = 1 , b = 0 , c = 0 ; var x = parseInt ( n / 60 ) ; a = Math . pow ( 32 , x ) ; x = 60 * x ; for ( i = x + 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { b += a ; a = 0 ; } if ( i % 5 == 0 ) { c += b ; b = 0 ; } if ( i % 12 == 0 ) { a += ( 2 * c ) ; c = 0 ; } } document . write ( " " + a + " " + b + " " + c ) ; } var n = 72 ; findCount ( n ) ;
function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; } function gcdOfFactorial ( arr , n ) { var minm = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minm = minm > arr [ i ] ? arr [ i ] : minm ; return factorial ( minm ) ; } var arr = [ 9 , 12 , 122 , 34 , 15 ] ; var n = arr . length ; document . write ( gcdOfFactorial ( arr , n ) ) ;
function sum ( n ) { if ( n == 1 ) return 1 ; else return ( Math . pow ( n , n ) + sum ( n - 1 ) ) ; } var n = 2 ; document . write ( sum ( n ) ) ;
let mod = 1000000007 ; function power ( a , n ) { if ( n == 0 ) return 1 ; let p = power ( a , parseInt ( n / 2 , 10 ) ) % mod ; p = ( p * p ) % mod ; if ( ( n & 1 ) == 1 ) p = ( p * a ) % mod ; return p ; } function countPermutations ( n ) { if ( n == 1 ) { return 0 ; } return ( power ( 2 , n - 1 ) - 2 ) % mod ; } let n = 5 ; document . write ( countPermutations ( n ) ) ;
function numbers ( n ) { return ( Math . pow ( 2 , n + 1 ) ) - 2 ; } var n = 2 ; document . write ( numbers ( n ) ) ;
function NumberofWays ( n ) { var x = ( 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; var y = 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; return 1 * x * y ; } var n = 4 ; document . write ( NumberofWays ( n ) ) ;
function nthTerm ( N ) { let nth = 0 ; nth = parseInt ( ( N * N * ( N + 1 ) ) / 2 ) ; return nth ; } let N = 5 ; document . write ( nthTerm ( N ) ) ;
function findNumbers ( n ) { var i = 1 ; while ( i <= n ) { document . write ( ( ( 2 * i ) - 1 ) + " " ) ; i ++ ; } } var n = 3 ; findNumbers ( n ) ;
function findMissingNums ( even , sizeEven , odd , sizeOdd ) { let minEven = Number . MAX_VALUE ; let maxEven = Number . MIN_VALUE ; let minOdd = Number . MAX_VALUE ; let maxOdd = Number . MIN_VALUE ; let sumEvenArr = 0 , sumOddArr = 0 ; for ( let i = 0 ; i < sizeEven ; i ++ ) { minEven = Math . min ( minEven , even [ i ] ) ; maxEven = Math . max ( maxEven , even [ i ] ) ; sumEvenArr += even [ i ] ; } for ( let i = 0 ; i < sizeOdd ; i ++ ) { minOdd = Math . min ( minOdd , odd [ i ] ) ; maxOdd = Math . max ( maxOdd , odd [ i ] ) ; sumOddArr += odd [ i ] ; } let totalTerms = 0 , reqSum = 0 ; totalTerms = parseInt ( minEven / 2 , 10 ) ; let evenSumMin = ( totalTerms * ( totalTerms + 1 ) ) ; totalTerms = parseInt ( maxEven / 2 , 10 ) ; let evenSumMax = ( totalTerms * ( totalTerms + 1 ) ) ; reqSum = evenSumMax - evenSumMin + minEven ; document . write ( " " + ( reqSum - sumEvenArr ) + " " ) ; totalTerms = parseInt ( minOdd / 2 , 10 ) + 1 ; let oddSumMin = totalTerms * totalTerms ; totalTerms = parseInt ( maxOdd / 2 , 10 ) + 1 ; let oddSumMax = totalTerms * totalTerms ; reqSum = oddSumMax - oddSumMin + minOdd ; document . write ( " " + ( reqSum - sumOddArr ) ) ; } let even = [ 6 , 4 , 8 , 14 , 10 ] ; let sizeEven = even . length ; let odd = [ 7 , 5 , 3 , 11 , 13 ] ; let sizeOdd = odd . length ; findMissingNums ( even , sizeEven , odd , sizeOdd ) ;
function findMinimum ( x , y ) { let low = 0 , high = y ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; } let x = 6 , y = 5 ; document . write ( findMinimum ( x , y ) ) ;
function sumOfDigits ( x ) { let sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = Math . floor ( x / 10 ) ; } return sum ; } function countNumbers ( l , r ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 === 0 ) count ++ ; } return count ; } let l = 1000 , r = 6000 ; document . write ( countNumbers ( l , r ) ) ;
function findMinSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; } var arr = [ 3 , 5 , 7 , 8 ] ; var n = arr . length ; document . write ( findMinSum ( arr , n ) ) ;
function maxLenSubArr ( a , n ) { let count , j ; let cm = 1 , max = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( let i = 0 ; i < n - 1 ; ) { count = 1 ; if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; } let arr = [ 6 , 1 , 6 , 6 , 0 ] ; let n = arr . length ; document . write ( maxLenSubArr ( arr , n ) ) ;
function minSum ( arr , n , x ) { var sum = 0 ; var largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; var sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; } var arr = [ 5 , 5 , 5 , 5 , 6 ] ; var n = arr . length ; var x = 3 ; document . write ( minSum ( arr , n , x ) ) ;
function maxAND ( L , R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } } let L = 1 , R = 632 ; document . write ( maxAND ( L , R ) ) ;
function checkSpecialPrime ( sieve , num ) { while ( num > 0 ) { if ( sieve [ num ] ) { return false ; } num = parseInt ( num / 10 ) ; } return true ; } function findSpecialPrime ( N ) { var sieve = Array . from ( { length : N * 10 + 1 } , ( _ , i ) => false ) ; sieve [ 0 ] = true ; sieve [ 1 ] = true ; var i = 0 , j = 0 ; for ( i = 2 ; i <= N * 10 ; i ++ ) { if ( ! sieve [ i ] ) { for ( j = i * i ; j <= N * 10 ; j += i ) { sieve [ j ] = true ; } } } while ( true ) { if ( checkSpecialPrime ( sieve , N ) ) { document . write ( N + " " ) ; break ; } else N ++ ; } } var N = 379 ; findSpecialPrime ( N ) ; N = 100 ; findSpecialPrime ( N ) ;
function minMoves ( n ) { let s = n . toString ( ) ; let ans = Number . MAX_VALUE ; let len = s . length ; for ( let i = 0 ; i < len ; ++ i ) { for ( let j = 0 ; j < len ; ++ j ) { if ( i == j ) continue ; let t = s . split ( ' ' ) ; let cur = 0 ; for ( let k = i ; k < len - 1 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } for ( let k = j - ( ( j > i ) ? 1 : 0 ) ; k < len - 2 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } let pos = - 1 ; for ( let k = 0 ; k < len ; ++ k ) { if ( t [ k ] != ' ' ) { pos = k ; break ; } } for ( let k = pos ; k > 0 ; -- k ) { swap ( t , k , k - 1 ) ; ++ cur ; } let nn = parseInt ( t . join ( " " ) ) ; if ( nn % 25 == 0 ) ans = Math . min ( ans , cur ) ; } } if ( ans == Number . MAX_VALUE ) return - 1 ; return ans ; } function swap ( t , i , j ) { let temp = t [ i ] ; t [ i ] = t [ j ] ; t [ j ] = temp ; } let n = 509201 ; document . write ( minMoves ( n ) ) ;
function getMaxNum ( a , b , c ) { if ( b % c == 0 ) return b ; var x = ( parseInt ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; } var a = 2 , b = 10 , c = 3 ; document . write ( getMaxNum ( a , b , c ) ) ;
function countSquares ( row , column ) { var topLeft = Math . min ( row , column ) - 1 ; var bottomRight = 8 - Math . max ( row , column ) ; var topRight = Math . min ( row , 9 - column ) - 1 ; var bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; } var row = 4 , column = 4 ; document . write ( countSquares ( row , column ) ) ;
function canTakeDown ( bishopX , bishopY , pawnX , pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; } var bishopX = 5 , bishopY = 5 ; var pawnX = 1 , pawnY = 1 ; if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) document . write ( " " ) ; else document . write ( " " ) ;
let N = 1000005 ; let primeFactors = new Array ( N ) ; primeFactors . fill ( 0 ) ; function findPrimeFactors ( ) { for ( let i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( let j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ parseInt ( j / i , 10 ) ] + 1 ; for ( let i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; } findPrimeFactors ( ) ; let a = 6 , b = 3 ; document . write ( primeFactors [ a ] - primeFactors [ b ] ) ;
function digitSum ( n ) { var ans = 0 ; while ( n ) { ans += n % 10 ; n = parseInt ( n / 10 ) ; } return ans ; } function findInt ( n , m ) { var minDigit = Math . floor ( m / 9 ) ; var start = Math . pow ( 10 , minDigit ) - Math . pow ( 10 , minDigit ) % n ; while ( start < 1000000000 ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return - 1 ; } var n = 13 , m = 32 ; document . write ( findInt ( n , m ) ) ;
function smallestDivisor ( n ) { var mx = Math . sqrt ( n ) ; for ( i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; } function maxSum ( n ) { var res = n ; while ( n > 1 ) { var divi = smallestDivisor ( n ) ; n /= divi ; res += n ; } return res ; } var n = 34 ; document . write ( maxSum ( n ) ) ;
function isPossible ( n , k , arr ) { let sum = arr [ 0 ] ; let maxVal = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . max ( maxVal , arr [ i ] ) ; } if ( maxVal > ( sum + k ) / n ) return false ; return true ; } let k = 8 ; let arr = [ 1 , 2 , 3 , 4 ] ; let n = arr . length ; if ( isPossible ( n , k , arr ) ) document . write ( " " ) ; else document . write ( " " ) ;
function maxResult ( n , a , b , c ) { let maxVal = 0 ; for ( let i = 0 ; i <= n ; i += a ) for ( let j = 0 ; j <= n - i ; j += b ) { let z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { let x = i / a ; let y = j / b ; maxVal = Math . max ( maxVal , x + y + z ) ; } } return maxVal ; } let n = 10 , a = 5 , b = 3 , c = 4 ; document . write ( maxResult ( n , a , b , c ) ) ;
function EqualNumbers ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] = parseInt ( a [ i ] / 2 , 10 ) ; } while ( a [ i ] % 3 == 0 ) { a [ i ] = parseInt ( a [ i ] / 3 , 10 ) ; } if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; } let a = [ 50 , 75 , 150 ] ; let n = a . length ; if ( EqualNumbers ( a , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function max_gcd ( n , p ) { let count = 0 ; let gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= Math . pow ( 2 , parseInt ( count / n , 10 ) ) ; for ( let i = 3 ; i <= parseInt ( Math . sqrt ( p ) , 10 ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = parseInt ( p / i , 10 ) ; } if ( count > 0 ) { gcd *= Math . pow ( i , parseInt ( count / n , 10 ) ) ; } } if ( p > 2 ) gcd *= Math . pow ( p , parseInt ( 1 / n , 10 ) ) ; return gcd ; } let n = 3 ; let p = 80 ; document . write ( max_gcd ( n , p ) ) ;
function getMinNum ( a , b , c ) { if ( c < a c > b ) return c ; let x = ( parseInt ( b / c ) * c ) + c ; return x ; } let a = 2 , b = 4 , c = 4 ; document . write ( getMinNum ( a , b , c ) ) ;
function countPairs ( n ) { if ( n == 2 ) return 4 ; let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = n - max ; return count ; } let n = 5 ; document . write ( countPairs ( n ) ) ;
function checkSub ( sub , s ) { let j = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) if ( sub [ j ] == s [ i ] ) j ++ ; return j == sub . length ; } function getMultiple ( s ) { for ( let i = 0 ; i < 1e3 ; i += 8 ) { if ( checkSub ( i . toString ( ) , s ) ) return i ; } return - 1 ; } let s = " " ; document . write ( getMultiple ( s ) ) ;
function sum ( n ) { if ( n < 2 ) { return 1 } else { return 1 / n + ( sum ( n - 1 ) ) } } document . write ( sum ( 8 ) ) ; document . write ( " " ) ; document . write ( sum ( 10 ) ) ;
function findingValues ( m , n , mth , nth ) { let d = parseInt ( ( Math . abs ( mth - nth ) ) / Math . abs ( ( m - 1 ) - ( n - 1 ) ) , 10 ) ; let a = mth - ( ( m - 1 ) * d ) ; let res = [ ] ; res . push ( a ) ; res . push ( d ) ; return res ; } function findSum ( m , n , mth , nth , p ) { let ad = findingValues ( m , n , mth , nth ) ; let a = ad [ 0 ] ; let d = ad [ 1 ] ; let sum = parseInt ( ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 , 10 ) ; return sum ; } let m = 6 , n = 10 , mTerm = 12 , nTerm = 20 , p = 5 ; document . write ( findSum ( m , n , mTerm , nTerm , p ) ) ;
function powerfulIntegers ( x , y , bound ) { var s = new Set ( ) ; var powersOfY = [ ] ; var i ; powersOfY . push ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . push ( i ) ; i = 0 ; while ( true ) { var xPowI = Math . pow ( x , i ) ; powersOfY . forEach ( j => { var num = xPowI + j ; if ( num <= bound ) s . add ( num ) ; } ) ; if ( xPowI >= bound x == 1 ) break ; i ++ ; } [ ... s ] . sort ( ( a , b ) => a - b ) . forEach ( itr => { document . write ( itr + " " ) } ) ; } var x = 2 , y = 3 , bound = 10 ; powerfulIntegers ( x , y , bound ) ;
function candies ( n , k ) { var count = 0 ; var ind = 1 ; var arr = Array ( k ) ; for ( i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; while ( n > 0 ) { var f1 = ( ind - 1 ) * k ; var f2 = ind * k ; var sum1 = ( f1 * ( f1 + 1 ) ) / 2 ; var sum2 = ( f2 * ( f2 + 1 ) ) / 2 ; var res = sum2 - sum1 ; if ( res <= n ) { count ++ ; n -= res ; ind ++ ; { var i = 0 ; var term = ( ( ind - 1 ) * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ i ++ ] = term ; n -= term ; term ++ ; } else { arr [ i ++ ] = n ; n = 0 ; } } } } for ( i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( i = 0 ; i < k ; i ++ ) document . write ( arr [ i ] + " " ) ; } var n = 10 , k = 3 ; candies ( n , k ) ;
function candies ( n , k ) { var count = 0 ; var ind = 1 ; var arr = Array ( k ) . fill ( 0 ) ; for ( i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; var low = 0 , high = n ; while ( low <= high ) { var mid = parseInt ( ( low + high ) / 2 ) ; var sum = parseInt ( ( mid * ( mid + 1 ) ) / 2 ) ; if ( sum <= n ) { count = parseInt ( mid / k ) ; low = mid + 1 ; } else { high = mid - 1 ; } } var last = ( count * k ) ; n -= ( last * ( last + 1 ) ) / 2 ; var j = 0 ; var term = ( count * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ j ++ ] = term ; n -= term ; term ++ ; } else { arr [ j ] += n ; n = 0 ; } } for ( i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( i = 0 ; i < k ; i ++ ) document . write ( arr [ i ] + " " ) ; } var n = 7 , k = 4 ; candies ( n , k ) ;
function printSmallest ( a ) { a . sort ( function ( a , b ) { return a - b } ) ; let i , j , num ; for ( i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] % 3 == 0 ) { return a [ i ] ; } } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { num = ( a [ i ] * 10 ) + a [ j ] ; if ( num % 3 == 0 ) { return num ; } } } return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] ; } let arr = [ 7 , 7 , 1 ] ; document . write ( printSmallest ( arr ) ) ;
function updateMatrix ( n , q , mat ) { let i , j ; for ( i = 0 ; i < q . length ; i ++ ) { let X1 = q [ i ] [ 0 ] ; let Y1 = q [ i ] [ 1 ] ; let X2 = q [ i ] [ 2 ] ; let Y2 = q [ i ] [ 3 ] ; mat [ X1 ] [ Y1 ] ++ ; if ( Y2 + 1 < n ) mat [ X2 ] [ Y2 + 1 ] -- ; else if ( X2 + 1 < n ) mat [ X2 + 1 ] [ 0 ] -- ; } let sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { sum += mat [ i ] [ j ] ; document . write ( sum + " " ) ; } document . write ( " " ) ; } } let n = 5 ; let mat = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { mat [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { mat [ i ] [ j ] = 0 ; } } let q = [ [ 0 , 0 , 1 , 2 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 4 , 3 , 4 ] ] ; updateMatrix ( n , q , mat ) ;
function printArr ( arr , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( arr [ n - 1 ] . toFixed ( 6 ) ) ; } function replaceMax ( arr , n ) { let max = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } let min = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } let range = max - min ; let coeffOfRange = range / ( max + min ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } } printArr ( arr , n ) ; } let arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] ; let n = arr . length ; replaceMax ( arr , n ) ;
function divide ( a , b ) { for ( let i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } document . write ( " " + a + " " + b + " " ) ; } let A = 10 , B = 15 ; divide ( A , B ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function commDiv ( a , b ) { let n = gcd ( a , b ) ; a = parseInt ( a / n , 10 ) ; b = parseInt ( b / n , 10 ) ; document . write ( " " + a + " " + b ) ; } let a = 10 , b = 15 ; commDiv ( a , b ) ;
function minAbsDiff ( n ) { let left = 1 << ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; let right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; } let n = 15 ; document . write ( minAbsDiff ( n ) ) ;
function find_probability ( p , q , r , s ) { var t = ( 1 - p / q ) * ( 1 - r / s ) ; var ans = ( p / q ) / ( 1 - t ) ; return ans ; } var p = 1 , q = 2 , r = 1 , s = 2 ; document . write ( find_probability ( p , q , r , s ) . toFixed ( 9 ) ) ;
function FindAllElements ( n , k ) { let sum = k ; let A = new Array ( k ) . fill ( 1 ) ; for ( let i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { document . write ( " " ) ; } else { for ( let i = 0 ; i < k ; ++ i ) document . write ( A [ i ] + " " ) ; } } let n = 12 ; let k = 6 ; FindAllElements ( n , k ) ;
function removeZero ( n ) { let res = 0 ; let d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n = Math . floor ( n / 10 ) ; } return res ; } function isEqual ( a , b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; } let a = 105 , b = 106 ; if ( isEqual ( a , b ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function sumArray ( arr , n ) { let leftSum = new Array ( n ) ; let rightSum = new Array ( n ) ; let Sum = new Array ( n ) ; let i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) document . write ( Sum [ i ] + " " ) ; } let arr = [ 3 , 6 , 4 , 8 , 9 ] ; let n = arr . length ; sumArray ( arr , n ) ;
function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = parseInt ( n / i , 10 ) ; let num1 = fir * k + sec ; let res = parseInt ( ( num1 / k ) , 10 ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = parseInt ( ( num2 / k ) , 10 ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; } let n = 4 , k = 6 ; document . write ( minimumX ( n , k ) + " " ) ; n = 5 , k = 5 ; document . write ( minimumX ( n , k ) ) ;
function minimumX ( n , k ) { let ans = Number . MAX_VALUE ; for ( let rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; } let n = 4 , k = 6 ; document . write ( minimumX ( n , k ) + " " ) ; n = 5 , k = 5 ; document . write ( minimumX ( n , k ) ) ;
function getHermiteNumber ( n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; } let n = 6 ; document . write ( getHermiteNumber ( n ) ) ;
function find ( n ) { let b = n ; let a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { document . write ( " " + a + " " + b ) ; } else document . write ( - 1 ) ; } let n = 10 ; find ( n ) ;
function isPerfect ( N ) { if ( ( Math . sqrt ( N ) - Math . floor ( Math . sqrt ( N ) ) ) != 0 ) return false ; return true ; } function getClosestPerfectSquare ( N ) { if ( isPerfect ( N ) ) { document . write ( N + " " + " " + " " ) ; return ; } let aboveN = - 1 , belowN = - 1 ; let n1 ; n1 = N + 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } let diff1 = aboveN - N ; let diff2 = N - belowN ; if ( diff1 > diff2 ) document . write ( belowN + " " + diff2 ) ; else document . write ( aboveN + " " + diff1 ) ; } let N = 1500 ; getClosestPerfectSquare ( N ) ;
function gcd ( a , b ) { if ( a === 0 ) return b ; return gcd ( b % a , a ) ; } function lowest ( den3 , num3 ) { var common_factor = gcd ( num3 , den3 ) ; den3 = parseInt ( den3 / common_factor ) ; num3 = parseInt ( num3 / common_factor ) ; return [ den3 , num3 ] ; } function addFraction ( num1 , den1 , num2 , den2 , num3 , den3 ) { den3 = gcd ( den1 , den2 ) ; den3 = ( den1 * den2 ) / den3 ; num3 = num1 * ( den3 / den1 ) + num2 * ( den3 / den2 ) ; return lowest ( den3 , num3 ) ; } var num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 , den3 , num3 ; var [ den3 , num3 ] = addFraction ( num1 , den1 , num2 , den2 , num3 , den3 ) ; document . write ( num1 + " " + den1 + " " + num2 + " " + den2 + " " + num3 + " " + den3 + " " ) ;
function findLargestDivisor ( n ) { for ( let i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; } let n = 12 ; document . write ( findLargestDivisor ( n ) + " " ) ; n = 97 ; document . write ( findLargestDivisor ( n ) + " " ) ;
function compare ( a , b ) { if ( a < b ) { return - 1 ; } else if ( a > b ) { return 1 ; } else { return 0 ; } } function checkIsAP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( compare ) ; let d = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } let arr = [ 20 , 15 , 5 , 0 , 10 ] ; let n = arr . length ; ( checkIsAP ( arr , n ) ) ? document . write ( " " ) : document . write ( " " ) ;
function isTriPerfect ( n ) { let sum = 1 + n ; let i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( parseInt ( n / i , 10 ) == i ) sum = sum + i ; else sum = sum + i + parseInt ( n / i , 10 ) ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; } let n = 120 ; if ( isTriPerfect ( n ) ) document . write ( n + " " ) ;
function sum ( N , X , Y ) { var S1 , S2 , S3 ; S1 = ( parseInt ( N / X ) ) * ( 2 * X + parseInt ( N / X - 1 ) * X ) / 2 ; S2 = ( parseInt ( N / Y ) ) * ( 2 * Y + parseInt ( N / Y - 1 ) * Y ) / 2 ; S3 = ( parseInt ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + parseInt ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; } var N = 14 ; var X = 3 , Y = 5 ; document . write ( sum ( N , X , Y ) ) ;
function findTwoThreePrime ( l , r ) { if ( l == 1 ) l ++ ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; while ( num % 2 == 0 ) num = parseInt ( num / 2 , 10 ) ; while ( num % 3 == 0 ) num = parseInt ( num / 3 , 10 ) ; if ( num == 1 ) count ++ ; } return count ; } let l = 1 , r = 10 ; document . write ( findTwoThreePrime ( l , r ) ) ;
function getNumber ( s ) { let number_of_digits = s . length ; let freq = new Array ( 10 ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < number_of_digits ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { freq [ s [ i ] . charCodeAt ( ) - 48 ] += 1 ; } if ( s [ i ] == ' ' ) { freq [ 2 ] += 2 ; freq [ 3 ] ++ ; } if ( s [ i ] == ' ' ) { freq [ 5 ] ++ ; freq [ 3 ] ++ ; } if ( s [ i ] == ' ' ) { freq [ 7 ] ++ ; freq [ 2 ] += 3 ; } if ( s [ i ] == ' ' ) { freq [ 7 ] ++ ; freq [ 3 ] += 2 ; freq [ 2 ] ++ ; } } let t = " " ; if ( freq [ 1 ] == number_of_digits || freq [ 0 ] == number_of_digits || ( freq [ 0 ] + freq [ 1 ] ) == number_of_digits ) { return s ; } else { for ( let i = 9 ; i >= 2 ; i -- ) { let ctr = freq [ i ] ; while ( ( ctr -- ) > 0 ) { t += String . fromCharCode ( i + 48 ) ; } } return t ; } } let s = " " ; document . write ( getNumber ( s ) ) ;
function reversDigits ( num ) { let rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = parseInt ( num / 10 , 10 ) ; } return rev_num ; } function icanobifNumbers ( N ) { let first = 0 , second = 1 ; if ( N == 1 ) document . write ( first ) ; else if ( N == 2 ) document . write ( first + " " + second ) ; else { document . write ( first + " " + second + " " ) ; for ( let i = 3 ; i <= N ; i ++ ) { let x = reversDigits ( first ) ; let y = reversDigits ( second ) ; document . write ( x + y + " " ) ; let temp = second ; second = x + y ; first = temp ; } } } let N = 12 ; icanobifNumbers ( N ) ;
function addNDigits ( a , b , n ) { let num = a ; for ( let i = 0 ; i <= 9 ; i ++ ) { let tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( let j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; } let a = 5 , b = 3 , n = 3 ; document . write ( addNDigits ( a , b , n ) ) ;
function Triplets ( n ) { var ans = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = i ; j <= n ; ++ j ) { var x = i * i + j * j ; var y = parseInt ( Math . sqrt ( x ) ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; } var n = 10 ; document . write ( Triplets ( n ) ) ;
function solve ( n , base ) { var sum = 0 ; while ( n > 0 ) { var remainder = n % base ; sum += remainder ; n = parseInt ( n / base ) ; } return sum ; } function SumsOfDigits ( n ) { var sum = 0 ; for ( base = 2 ; base <= n / 2 ; ++ base ) sum += solve ( n , base ) ; document . write ( sum ) ; } var n = 8 ; SumsOfDigits ( n ) ;
function checkPerfectcube ( n ) { let d = Math . cbrt ( n ) ; if ( d * d * d == n ) return true ; return false ; } function largestNonPerfectcubeNumber ( a , n ) { let maxi = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! checkPerfectcube ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } let a = [ 16 , 64 , 25 , 2 , 3 , 10 ] ; let n = a . length ; document . write ( largestNonPerfectcubeNumber ( a , n ) ) ;
function checkIfPossibleRec ( x , a , b , isPossible , n ) { if ( x > n ) return ; if ( isPossible [ x ] ) return ; isPossible [ x ] = true ; checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; } function checkPossible ( n , a , b ) { var isPossible = Array ( n + 1 ) . fill ( false ) ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; } var a = 3 , b = 7 , n = 8 ; if ( checkPossible ( a , b , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function sumOdd ( n ) { terms = ( n + 1 ) / 2 ; sum = terms * terms ; return sum ; } function suminRange ( l , r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; } let l = 2 ; let r = 5 ; document . write ( " " + suminRange ( l , r ) ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function sumcommDiv ( a , b ) { var n = gcd ( a , b ) ; var sum = 0 ; for ( var i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; } var a = 10 , b = 15 ; document . write ( " " + sumcommDiv ( a , b ) ) ;
function checkNumber ( N ) { let temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp = parseInt ( temp / 1000 , 10 ) ; else if ( temp % 100 == 14 ) temp = parseInt ( temp / 100 , 10 ) ; else if ( temp % 10 == 1 ) temp = parseInt ( temp / 10 , 10 ) ; else { return " " ; } } return " " ; } let N = 1414 ; document . write ( checkNumber ( N ) ) ;
function getResult ( n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; } let n = 3 ; document . write ( getResult ( n ) ) ;
function findAandB ( N ) { let val = N * N - 4.0 * N ; if ( val < 0 ) { document . write ( " " ) ; return ; } let a = ( N + Math . sqrt ( val ) ) / 2.0 ; let b = ( N - Math . sqrt ( val ) ) / 2.0 ; document . write ( " " + a . toFixed ( 4 ) + " " ) ; document . write ( " " + b . toFixed ( 5 ) ) ; } let N = 69.0 ; findAandB ( N ) ;
function minOperations ( A , n ) { if ( ( n & 1 ) > 0 ) return - 1 ; let zeros = 0 , consZeros = 0 , ones = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; } let A = [ 1 , 1 , 0 , 0 ] ; let n = A . length ; document . write ( minOperations ( A , n ) ) ;
function countdig ( m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( parseInt ( m / 10 ) ) ; } function countSteps ( x ) { var c = 0 ; var last = x ; while ( last > 0 ) { var digits = countdig ( last ) ; digits -= 1 ; var divisor = parseInt ( Math . pow ( 10 , digits ) ) ; var first = parseInt ( last / divisor ) ; var lastnumber = first * divisor ; var skipped = parseInt ( ( last - lastnumber ) / first ) ; skipped += 1 ; c += skipped ; last = last - ( first * skipped ) ; } return c ; } var n = 14 ; document . write ( countSteps ( n ) ) ;
function power ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function powerGCD ( a , b , n ) { var e = power ( a , n , b ) ; return gcd ( e , b ) ; } var a = 5 , b = 4 , n = 2 ; document . write ( powerGCD ( a , b , n ) ) ;
function allOddDigits ( n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n = parseInt ( n / 10 ) ; } return true ; } function largestNumber ( n ) { if ( parseInt ( n % 2 ) == 0 ) n -- ; for ( i = n ; i > 0 ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; } var N = 23 ; document . write ( largestNumber ( N ) ) ;
function countNumbers ( N ) { return parseInt ( Math . sqrt ( N ) , 10 ) - 1 ; } let N = 36 ; document . write ( countNumbers ( N ) ) ;
function countOrderedPairs ( N ) { var count_pairs = 0 ; for ( var i = 1 ; i <= Math . sqrt ( N - 1 ) ; ++ i ) { for ( var j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= parseInt ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; } var N = 5 ; document . write ( countOrderedPairs ( N ) ) ;
function pairwiseDifference ( arr , n ) { var diff ; for ( i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; document . write ( diff + " " ) ; } } var arr = [ 4 , 10 , 15 , 5 , 6 ] ; var n = arr . length ; pairwiseDifference ( arr , n ) ;
function sumAP ( n , d ) { n = parseInt ( n / d ) ; return ( n ) * ( ( 1 + n ) * parseInt ( d ) / 2 ) ; } function sumMultiples ( n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; } n = 20 ; document . write ( sumMultiples ( n ) ) ;
function markingScheme ( N , answerKey , studentAnswer ) { var positive = 0 , negative = 0 , notattempt = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( studentAnswer [ i ] == 0 ) notattempt ++ ; else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ; else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; } return ( positive * 3 ) + ( negative * - 1 ) ; } var answerKey = [ 1 , 2 , 3 , 4 , 1 ] ; var studentAnswer = [ 1 , 2 , 3 , 4 , 0 ] ; var N = answerKey . length ; document . write ( markingScheme ( N , answerKey , studentAnswer ) ) ;
let MAX = 10000 ; let prime = new Array ( MAX + 1 ) . fill ( true ) ; function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } function solve ( n ) { let count = 0 ; let num = 1 ; let prod = 1 ; while ( count < n ) { if ( prime [ num ] == true ) { prod *= num ; count ++ ; } num ++ ; } return prod ; } SieveOfEratosthenes ( ) ; let n = 5 ; document . write ( solve ( n ) ) ;
function Check_is_possible ( l , r , k ) { var div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; } var l = 30 , r = 70 , k = 10 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function nth_group ( n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; } let N = 5 ; document . write ( nth_group ( N ) ) ;
function printPossible ( a , b , c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) document . write ( " " ) ; else document . write ( " " ) ; } let a = 2 , b = 4 , c = 2 ; printPossible ( a , b , c ) ;
function Sum_upto_nth_Term ( n ) { let r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; document . write ( r ) ; } let N = 5 ; Sum_upto_nth_Term ( N ) ;
function CalculateDifference ( arr , n ) { var max_val = Number . MIN_VALUE ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } var prime = Array ( max_val + 1 ) ; for ( i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } var S1 = 0 , S2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return Math . abs ( S2 - S1 ) ; } var arr = [ 1 , 3 , 5 , 10 , 15 , 7 ] ; var n = arr . length ; document . write ( CalculateDifference ( arr , n ) ) ;
function numberOfDivisors ( num ) { let c = 0 ; for ( let i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; } function countNumbers ( n ) { let c = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; } let n = 1000 ; document . write ( countNumbers ( n ) ) ;
function numberOfDistinct ( n ) { var ans = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; } var n = 3 ; document . write ( numberOfDistinct ( n ) ) ;
function NumberOfRectangles ( n , m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; } var n = 3 , m = 3 ; document . write ( NumberOfRectangles ( n , m ) ) ;
function findNumUtil ( res , a , aCount , b , bCount , n ) { if ( res > 1e11 ) return 1e11 ; if ( aCount == bCount && res >= n ) return res ; return Math . min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; } function findNum ( n , a , b ) { let result = 0 ; let aCount = 0 ; let bCount = 0 ; return findNumUtil ( result , a , aCount , b , bCount , n ) ; } let N = 4500 ; let A = 4 ; let B = 7 ; document . write ( findNum ( N , A , B ) ) ;
var n = 7 ; var k = 3 ; if ( n % k == 0 ) document . write ( n / k + " " + n / k ) ; else document . write ( ( n - ( n % k ) ) / k + " " + ( ( ( n - ( n % k ) ) / k ) + 1 ) ) ;
var m = 50 , n = 5 , x = 67 , h = 2927 ; var z = ( Math . ceil ( h / 60 * 1.0 ) ) ; if ( z <= n ) document . write ( z * m ) ; else document . write ( n * m + ( z - n ) * x ) ;
function sumProductDifference ( a , b , c , d , e ) { var rootSum = ( - 1 * b ) / a ; var rootProduct = e / a ; return Math . abs ( rootSum - rootProduct ) ; } document . write ( sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ) ;
function numberOfSolutions ( n ) { let c = 0 ; for ( let x = 0 ; x <= n ; ++ x ) if ( n == x + n ^ x ) ++ c ; return c ; } let n = 3 ; document . write ( numberOfSolutions ( n ) ) ;
function minimumLectures ( m , n ) { let ans = 0 ; if ( n < Math . ceil ( 0.75 * m ) ) ans = Math . ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; } let M = 9 , N = 1 ; document . write ( minimumLectures ( M , N ) ) ;
function countNumbers ( N ) { return parseInt ( ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 , 10 ) ; } let n = 5 ; document . write ( countNumbers ( n ) ) ;
function calculateSum ( n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; } let n = 3 ; document . write ( " " + calculateSum ( n ) ) ;
function checkSolution ( a , b , c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) document . write ( " " ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } var a = 2 , b = 5 , c = 2 ; checkSolution ( a , b , c ) ;
function Bits ( kilobytes ) { var Bits = 0 ; Bits = kilobytes * 8192 ; return Bits ; } function Bytes ( kilobytes ) { var Bytes = 0 ; Bytes = kilobytes * 1024 ; return Bytes ; } var kilobytes = 1 ; document . write ( kilobytes + " " + Bytes ( kilobytes ) + " " + Bits ( kilobytes ) + " " ) ;
let n = 3 ; let a = [ 1 , 2 , 3 ] ; let i = 0 ; let sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } let x = sum / n ; if ( x * n == sum ) document . write ( x ) ; else document . write ( " " ) ;
function findSum ( n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; } let n = 10 ; document . write ( findSum ( n ) . toFixed ( 4 ) ) ;
function sum ( x , y , n ) { sum1 = ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ; sum2 = ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; } let x = 2 ; let y = 2 ; let n = 2 ; document . write ( sum ( x , y , n ) ) ;
function printPair ( g , l ) { document . write ( g + " " + l ) ; } var g = 3 , l = 12 ; printPair ( g , l ) ;
function calculateSum ( n ) { let a1 = 1 , a2 = 2 ; let r = 2 ; let d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; } let n = 5 ; document . write ( " " + calculateSum ( n ) ) ;
function ispower ( n ) { if ( n < 125 ) return ( n == 1 n == 5 n == 25 ) ; if ( n % 125 != 0 ) return false ; else return ispower ( parseInt ( n / 125 ) ) ; } function number ( s , i , j ) { var ans = 0 ; for ( var x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s [ x ] - ' ' ) ; } return ans ; } function minCuts ( s , n ) { var dp = Array ( n + 1 ) . fill ( n + 1 ) ; dp [ 0 ] = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { if ( s [ i - 1 ] == ' ' ) continue ; for ( var j = 0 ; j < i ; j ++ ) { if ( s [ j ] == ' ' ) continue ; var num = number ( s , j , i ) ; if ( ! ispower ( num ) ) continue ; dp [ i ] = Math . min ( dp [ i ] , dp [ j ] + 1 ) ; } } return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : - 1 ) ; } var s = " " ; var n = s . length ; document . write ( minCuts ( s , n ) ) ;
function MinOfCubed ( k ) { if ( k < 8 ) return k ; let res = k ; for ( let i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; } let num = 15 ; document . write ( MinOfCubed ( num ) ) ;
function MinOfCubedDP ( k ) { let DP = new Array ( k + 1 ) ; DP . fill ( 0 ) ; let j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= k ; i ++ ) { DP [ i ] = Number . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; } let num = 15 ; document . write ( MinOfCubedDP ( num ) ) ;
function maxSum ( a , n ) { let ans = 0 ; let arr = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; ++ i ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; ++ j ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; } let arr = [ - 5 , 3 , 2 , 7 , - 8 , 3 , 7 , - 9 , 10 , 12 , - 6 ] ; let n = arr . length ; document . write ( maxSum ( arr , n ) ) ;
function MinimumCost ( a , n , x ) { for ( i = 1 ; i < n ; i ++ ) { a [ i ] = Math . min ( a [ i ] , 2 * a [ i - 1 ] ) ; } var ind = 0 ; var sum = 0 ; while ( x > 0 ) { if ( x != 0 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; } var a = [ 20 , 50 , 60 , 90 ] ; var x = 7 ; var n = a . length ; document . write ( MinimumCost ( a , n , x ) ) ;
function countWays ( n , l , r ) { let tL = l , tR = r ; let L = new Array ( 3 ) ; let R = new Array ( 3 ) ; L [ l % 2 ] = l ; R [ r % 2 ] = r ; l ++ ; r -- ; if ( l <= tR && r >= tL ) { L [ l % 2 ] = l ; R [ r % 2 ] = r ; } let cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] > 0 && L [ 0 ] > 0 ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] > 0 && L [ 1 ] > 0 ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 0 ] = cnt0 ; dp [ 1 ] [ 1 ] = cnt1 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) ; } return dp [ n ] [ 0 ] ; } let n = 2 , l = 1 , r = 3 ; document . write ( countWays ( n , l , r ) ) ;
let m = 1001 ; let MOD = 998244353 ; let dp = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { dp [ i ] = new Array ( m ) ; for ( let j = 0 ; j < m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } function solve ( idx , diff , N , M , K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; let ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; dp [ idx ] [ diff ] = ans % MOD ; return dp [ idx ] [ diff ] ; } let N = 3 , M = 3 , K = 0 ; for ( let i = 0 ; i <= M ; i ++ ) for ( let j = 0 ; j <= M ; j ++ ) dp [ i ] [ j ] = - 1 ; document . write ( ( M * solve ( 2 , 0 , N , M , K ) ) ) ;
N = 3 ; function maxPathSum ( tri ) { var ans = 0 ; for ( var i = N - 2 ; i >= 0 ; i -- ) { for ( var j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; } var tri = [ [ 1 , 5 , 3 ] , [ 4 , 8 , 0 ] , [ 1 , 0 , 0 ] ] ; document . write ( maxPathSum ( tri ) ) ;
function subsetXOR ( arr , n , K ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = new Array ( n + 1 ) ; for ( let k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { for ( let k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( k != 0 ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } } let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; } let arr = [ 1 , 2 , 3 ] ; let k = 1 ; let n = arr . length ; document . write ( subsetXOR ( arr , n , k ) ) ;
function get_max_splits ( num_String ) { let count = 0 , current_num ; let running_sum = 0 ; for ( let i = 0 ; i < num_String . length ; i ++ ) { current_num = num_String [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; } document . write ( get_max_splits ( " " ) + " " ) ;
function findMinimumCost ( n , x , y ) { let dp = new Array ( n + 1 ) ; dp [ 1 ] = x ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + y + x ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( i / 2 , 10 ) ] + y ) ; } } return dp [ n ] ; } let n = 4 , x = 2 , y = 1 ; document . write ( findMinimumCost ( n , x , y ) ) ;
function nCr ( n , r ) { var ans = 1 ; if ( r > n - r ) r = n - r ; for ( var i = 0 ; i < r ; i ++ ) { ans *= n - i ; ans /= i + 1 ; } return ans ; } function countDerangements ( n ) { var der = [ ... Array ( n + 1 ) ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( var i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; } function countPermutations ( n , k ) { var ans = 0 ; for ( var i = n - k ; i <= n ; i ++ ) { var ways = nCr ( n , i ) ; ans += ways * countDerangements ( n - i ) ; } return ans ; } var n = 5 , k = 3 ; document . write ( countPermutations ( n , k ) ) ;
function squares ( i ) { if ( ( i & 1 ) == 1 ) return parseInt ( i / 4 , 10 ) * 2 + 1 ; else return parseInt ( ( i - 1 ) / 4 , 10 ) * 2 + 2 ; } function bishop_placements ( n , k ) { if ( k > 2 * n - 1 ) return 0 ; let dp = new Array ( n * 2 ) ; for ( let i = 0 ; i < n * 2 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } dp [ i ] [ 0 ] = 1 ; } dp [ 1 ] [ 1 ] = 1 ; for ( let i = 2 ; i < n * 2 ; i ++ ) { for ( let j = 1 ; j <= k ; j ++ ) dp [ i ] [ j ] = dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ; } let ans = 0 ; for ( let i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ; } return ans ; } let n = 2 ; let k = 2 ; let ans = bishop_placements ( n , k ) ; document . write ( ans ) ;
function countStaircases ( N ) { let memo = new Array ( N + 5 ) ; for ( let i = 0 ; i < N + 5 ; i ++ ) { memo [ i ] = new Array ( N + 5 ) ; for ( let j = 0 ; j < N + 5 ; j ++ ) { memo [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= N ; i ++ ) { for ( let j = 0 ; j <= N ; j ++ ) { memo [ i ] [ j ] = 0 ; } } memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 ; for ( let i = 5 ; i <= N ; i ++ ) { for ( let j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 ; } else { memo [ i ] [ j ] = memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ; } } } let answer = 0 ; for ( let i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N ] [ i ] ; return answer ; } let N = 7 ; document . write ( countStaircases ( N ) ) ;
function countPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; } let n = 5 , m = 5 ; document . write ( countPaths ( n , m ) ) ;
function countPaths ( m , n ) { let dp = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; } let n = 5 ; let m = 5 ; document . write ( countPaths ( n , m ) ) ;
function binomialCoeff ( n , k ) { var res = 1 ; if ( k > n - k ) k = n - k ; for ( i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function catalan ( n ) { var c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } var n = 3 ; document . write ( catalan ( n ) ) ;
function alternateFib ( n ) { if ( n < 0 ) return ; var f1 = 0 ; var f2 = 1 ; document . write ( f1 + " " ) ; for ( i = 2 ; i <= n ; i ++ ) { var f3 = f2 + f1 ; if ( i % 2 == 0 ) document . write ( f3 + " " ) ; f1 = f2 ; f2 = f3 ; } } var N = 15 ; alternateFib ( N ) ;
function totalWays ( N , M , X ) { let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } if ( X == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( let i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; } let N = 4 , M = 3 , X = 2 ; document . write ( totalWays ( N , M , X ) ) ;
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } let n = 6 ; document . write ( fib ( n ) ) ;
let MAX = 100 ; function binomialCoeff ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } function sumOfproduct ( n ) { return binomialCoeff ( 2 * n , n - 1 ) ; } let n = 3 ; document . write ( sumOfproduct ( n ) ) ;
function fib ( n ) { let a = 0 , b = 1 , c ; if ( n >= 0 ) document . write ( a + " " ) ; if ( n >= 1 ) document . write ( b + " " ) ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; document . write ( c + " " ) ; a = b ; b = c ; } } fib ( 9 ) ;
function pre_compute ( a , n , index , k ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; } let a = [ 1 , 101 , 2 , 3 , 100 , 4 , 5 ] ; let n = a . length ; let index = 4 , k = 6 ; document . write ( pre_compute ( a , n , index , k ) ) ;
function gen ( n ) { let S = new Array ( n + 1 ) ; S . fill ( 0 ) ; S [ 0 ] = 0 ; if ( n != 0 ) S [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) S [ i ] = 4 * S [ parseInt ( i / 2 , 10 ) ] ; else S [ i ] = 4 * S [ parseInt ( i / 2 , 10 ) ] + 1 ; } return S [ n ] ; } function moserDeBruijn ( n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( gen ( i ) + " " ) ; } let n = 15 ; document . write ( " " + n + " " + " " + " " ) ; moserDeBruijn ( n ) ;
function LCSubStr ( X , Y ) { var m = X . length ; var n = Y . length ; var result = 0 ; var len = Array . from ( Array ( 2 ) , ( ) => Array ( n ) ) ; var currRow = 0 ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow ] [ j ] = len [ 1 - currRow ] [ j - 1 ] + 1 ; result = Math . max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; } var X = " " ; var Y = " " ; document . write ( LCSubStr ( X , Y ) ) ;
function printGolomb ( n ) { let dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 1 ] = 1 ; document . write ( dp [ 1 ] + " " ) ; for ( i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; document . write ( dp [ i ] + " " ) ; } } let n = 9 ; printGolomb ( n ) ;
function findLength ( str , n ) { let current_sum = 0 ; let max_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == ' ' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; } let str = " " ; let n = str . length ; document . write ( findLength ( str , n ) ) ;
function chordCnt ( A ) { var n = 2 * A ; var dpArray = Array ( n + 1 ) . fill ( 0 ) ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( var i = 4 ; i <= n ; i += 2 ) { for ( var j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; } var N ; N = 2 ; document . write ( chordCnt ( N ) + ' ' ) ; N = 1 ; document . write ( chordCnt ( N ) + ' ' ) ; N = 4 ; document . write ( chordCnt ( N ) + ' ' ) ;
var arr = [ [ 5 ] , [ 5 ] ] function isPath ( arr ) { arr [ 0 ] [ 0 ] = 1 ; for ( var i = 1 ; i < 5 ; i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( var i = 1 ; i < 5 ; i ++ ) for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; } var arr = [ [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , 0 , - 1 , - 1 ] , [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , - 1 , 0 , - 1 ] , [ 0 , 0 , - 1 , 0 , 0 ] ] ; if ( isPath ( arr ) ) document . write ( " " ) ; else document . write ( " " ) ;
function nswp ( n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; } let n = 3 ; document . write ( nswp ( n ) ) ;
function nswp ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; } let n = 3 ; document . write ( nswp ( n ) ) ;
function lcs ( X , Y , m , n ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; ++ i ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= m ; ++ i ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( X [ i - 1 ] - ' ' ) ; else L [ i ] [ j ] = L [ i - 1 ] [ j ] > L [ i ] [ j - 1 ] ? L [ i - 1 ] [ j ] : L [ i ] [ j - 1 ] ; } } return L [ m ] [ n ] ; } function findMinCost ( X , Y ) { let m = X . length , n = Y . length ; let cost = 0 ; for ( let i = 0 ; i < m ; ++ i ) cost += X [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; for ( let i = 0 ; i < n ; ++ i ) cost += Y [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; return cost - lcs ( X , Y , m , n ) ; } let X = ( " " ) . split ( ' ' ) ; let Y = ( " " ) . split ( ' ' ) ; document . write ( " " + " " + findMinCost ( X , Y ) ) ;
function isSubSeqDivisible ( str ) { let n = str . length ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { dp [ i ] = new Array ( 10 ) ; for ( let j = 0 ; j < 10 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let arr = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) arr [ i ] = ( str [ i - 1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; for ( let i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( let j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( let i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; } let str = " " ; if ( isSubSeqDivisible ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function maxLength ( s , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ' && s [ i + 1 ] == ' ' ) dp [ i ] [ i + 1 ] = 2 ; for ( let l = 2 ; l < n ; l ++ ) { for ( let i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ' && s [ j ] == ' ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( let k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; } let s = " " ; let n = s . length ; document . write ( maxLength ( s , n ) ) ;
function smallestSumSubarr ( arr , n ) { let min_ending_here = 2147483647 ; let min_so_far = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; } let arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] ; let n = arr . length ; document . write ( " " + smallestSumSubarr ( arr , n ) ) ;
function countWays ( n , k ) { let total = k ; let mod = 1000000007 ; let same = 0 , diff = k ; for ( let i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; } let n = 3 , k = 2 ; document . write ( countWays ( n , k ) ) ;
function sumOfSubstrings ( num ) { let sum = 0 ; let mf = 1 ; for ( let i = num . length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; } let num = " " ; document . write ( sumOfSubstrings ( num ) ) ;
function maxSumWithK ( a , n , k ) { let maxSum = new Array ( n ) ; maxSum [ 0 ] = a [ 0 ] ; let curr_max = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; } let sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) sum += a [ i ] ; let result = sum ; for ( let i = k ; i < n ; i ++ ) { sum = sum + a [ i ] - a [ i - k ] ; result = Math . max ( result , sum ) ; result = Math . max ( result , sum + maxSum [ i - k ] ) ; } return result ; } let arr = [ 1 , 2 , 3 , - 10 , - 3 ] ; let k = 4 ; document . write ( maxSumWithK ( arr , arr . length , k ) ) ;
let arr = [ 1 , 5 , 6 ] ; function countWays ( N ) { let count = new Array ( N + 1 ) ; count . fill ( 0 ) ; count [ 0 ] = 1 ; for ( let i = 1 ; i <= N ; i ++ ) for ( let j = 0 ; j < arr . length ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; } let N = 7 ; document . write ( " " + countWays ( N ) ) ;
function getTotalNumberOfSequences ( m , n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; } let m = 10 ; let n = 4 ; document . write ( " " , getTotalNumberOfSequences ( m , n ) ) ;
function getTotalNumberOfSequences ( m , n ) { let T = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { T [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ parseInt ( i / 2 , 10 ) ] [ j - 1 ] ; } } return T [ m ] [ n ] ; } let m = 10 ; let n = 4 ; document . write ( " " + getTotalNumberOfSequences ( m , n ) ) ;
function lis ( arr , n ) { let result = 0 ; let lis = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; } function minimumNumberOfDeletions ( arr , n ) { let len = lis ( arr , n ) ; return ( n - len ) ; } let arr = [ 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 ] ; let n = arr . length ; document . write ( " " + minimumNumberOfDeletions ( arr , n ) ) ;
function lps ( str ) { let n = str . length ; let L = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { L [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( let cl = 2 ; cl <= n ; cl ++ ) { for ( let i = 0 ; i < n - cl + 1 ; i ++ ) { let j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } function minimumNumberOfDeletions ( str ) { let n = str . length ; let len = lps ( str ) ; return ( n - len ) ; } let str = " " ; document . write ( " " + " " + minimumNumberOfDeletions ( str ) ) ;
function offeringNumber ( n , templeHeight ) { for ( let i = 0 ; i < n ; ++ i ) { let left = 0 , right = 0 ; for ( let j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( let j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . max ( right , left ) + 1 ; } return sum ; } let arr1 = [ 1 , 2 , 2 ] ; document . write ( offeringNumber ( 3 , arr1 ) + " " ) ; let arr2 = [ 1 , 4 , 3 , 6 , 2 , 1 ] ; document . write ( offeringNumber ( 6 , arr2 ) ) ;
function modularSum ( arr , n , m ) { if ( n > m ) return true ; let DP = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) DP [ l ] = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; let temp = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) temp [ l ] = false ; for ( let j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( let j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; } let arr = [ 1 , 7 ] ; let n = arr . length ; let m = 5 ; if ( modularSum ( arr , n , m ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function maxSum ( tri , n ) { if ( n > 1 ) tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] ; tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) { tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] ; tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] ; for ( let j = 1 ; j < i ; j ++ ) { if ( tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ) tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] ; else tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ; } } let max = tri [ n - 1 ] [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 ] [ i ] ) max = tri [ n - 1 ] [ i ] ; } return max ; } let tri = [ [ 1 ] , [ 2 , 1 ] , [ 3 , 3 , 2 ] ] ; document . write ( maxSum ( tri , 3 ) ) ;
function maximumDifferenceSum ( arr , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( let i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; } let arr = [ 3 , 2 , 1 , 4 , 5 ] ; let N = arr . length ; document . write ( maximumDifferenceSum ( arr , N ) ) ;
let N = 8 ; let dx = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] ; let dy = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] ; function inside ( x , y ) { return ( x >= 0 && x < N && y >= 0 && y < N ) ; } function findProb ( start_x , start_y , steps ) { let dp1 = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp1 [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp1 [ i ] [ j ] = new Array ( steps + 1 ) ; for ( let k = 0 ; k < steps + 1 ; k ++ ) { dp1 [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i < N ; ++ i ) for ( let j = 0 ; j < N ; ++ j ) dp1 [ i ] [ j ] [ 0 ] = 1 ; for ( let s = 1 ; s <= steps ; ++ s ) { for ( let x = 0 ; x < N ; ++ x ) { for ( let y = 0 ; y < N ; ++ y ) { let prob = 0.0 ; for ( let i = 0 ; i < 8 ; ++ i ) { let nx = x + dx [ i ] ; let ny = y + dy [ i ] ; if ( inside ( nx , ny ) ) prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 ; } dp1 [ x ] [ y ] [ s ] = prob ; } } } return dp1 [ start_x ] [ start_y ] [ steps ] ; } let K = 3 ; document . write ( findProb ( 0 , 0 , K ) ) ;
function countSubarray ( arr , n , k ) { let s = 0 ; let i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } let count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += parseInt ( ( count * ( count + 1 ) ) / 2 , 10 ) ; } return ( n * parseInt ( ( n + 1 ) / 2 , 10 ) - s ) ; } let arr = [ 1 , 2 , 3 ] ; let k = 2 ; let n = arr . length ; document . write ( countSubarray ( arr , n , k ) ) ;
function nCr ( n , k ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { C [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j <= k ; j ++ ) { C [ i ] [ j ] = 0 ; } } let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } function resultOfAllSubsets ( arr , N ) { let result = 0.0 ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( let n = 1 ; n <= N ; n ++ ) result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; } let arr = [ 2 , 3 , 5 , 7 ] ; let N = arr . length ; document . write ( resultOfAllSubsets ( arr , N ) ) ;
let arr = [ 100 , 1000 , 100 , 1000 , 1 ] ; let sum = new Array ( 10000 ) ; for ( let i = 0 ; i < 10000 ; i ++ ) { sum [ i ] = - 1 ; } function maxSumWO3Consec ( n ) { if ( sum [ n ] != - 1 ) { return sum [ n ] ; } if ( n == 0 ) { return sum [ n ] = 0 ; } if ( n == 1 ) { return sum [ n ] = arr [ 0 ] ; } if ( n == 2 ) { return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; } return sum [ n ] = 500 + Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; } let n = arr . length - 1 ; document . write ( maxSumWO3Consec ( n ) + 1 ) ;
function maxSumPairWithDifferenceLessThanK ( arr , N , k ) { var maxSum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; } var arr = [ 3 , 5 , 10 , 15 , 17 , 12 , 9 ] ; var N = arr . length ; var K = 4 ; document . write ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) ;
function countGroups ( position , previous_sum , length , num ) { if ( position == length ) return 1 ; let res = 0 ; let sum = 0 ; for ( let i = position ; i < length ; i ++ ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; } let num = " " ; let len = num . length ; document . write ( countGroups ( 0 , 0 , len , num ) ) ;
function count ( a , b ) { var m = a . length ; var n = b . length ; var lookup = Array ( m + 1 ) ; for ( var i = 0 ; i < m + 1 ; i ++ ) lookup [ i ] = Array ( n + 1 ) . fill ( 0 ) ; for ( i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( i = 1 ; i <= m ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; } var a = " " ; var b = " " ; document . write ( count ( a , b ) ) ;
function lcs ( X , Y ) { let m = X . length , n = Y . length ; let L = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = 0 ; } } let bi = 0 ; for ( let i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; } let X = " " ; let Y = " " ; document . write ( " " + lcs ( X , Y ) ) ;
function subsetXOR ( arr , n , k ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; if ( k > m ) { return 0 ; } let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let k = 4 ; let n = arr . length ; document . write ( " " + subsetXOR ( arr , n , k ) ) ;
function countSol ( coeff , start , end , rhs ) { if ( rhs == 0 ) return 1 ; let result = 0 ; for ( let i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; } let coeff = [ 2 , 2 , 5 ] ; let rhs = 4 ; let n = coeff . length ; document . write ( countSol ( coeff , 0 , n - 1 , rhs ) ) ;
function steps ( source , step , dest ) { if ( Math . abs ( source ) > ( dest ) ) return Number . MAX_SAFE_INTEGER ; if ( source == dest ) return step ; let pos = steps ( source + step + 1 , step + 1 , dest ) ; let neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . min ( pos , neg ) ; } let dest = 11 ; document . write ( " " + dest + " " + steps ( 0 , 0 , dest ) ) ;
let X , Y ; function lcs ( i , j , count ) { if ( i == 0 j == 0 ) return count ; if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . max ( count , Math . max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; } let n , m ; X = " " ; Y = " " ; n = X . length ; m = Y . length ; document . write ( lcs ( n , m , 0 ) ) ;
function no_of_characters ( M ) { let k = 1 ; while ( true ) { if ( Math . pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; } return k ; } function print_string ( M ) { let k , num , N ; k = no_of_characters ( M ) ; N = M - ( Math . pow ( 2 , k ) - 2 ) ; while ( k > 0 ) { num = Math . pow ( 2 , k - 1 ) ; if ( num >= N ) document . write ( " " ) ; else { document . write ( " " ) ; N -= num ; } k -- ; } document . write ( " " ) ; } let M ; M = 30 ; print_string ( M ) ; M = 55 ; print_string ( M ) ; M = 100 ; print_string ( M ) ;
function updateString ( S , A , B ) { let l = A . length ; for ( let i = 0 ; i + l <= S . length ; i ++ ) { let curr = S . substring ( i , i + l ) ; if ( curr == A ) { let new_string = S . substring ( 0 , i ) + B + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { let new_string = S . substring ( 0 , i ) + A + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; } let S = " " ; let A = " " ; let B = " " ; document . write ( updateString ( S , A , B ) ) ;
function printPattern ( n , m ) { if ( m > 2 * ( n + 1 ) m < n - 1 ) { document . write ( " " ) ; } else if ( Math . abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { document . write ( " " ) ; n -- ; m -- ; } if ( n != 0 ) { document . write ( " " ) ; } if ( m != 0 ) { document . write ( " " ) ; } } else { while ( m - n > 1 && n > 0 ) { document . write ( " " ) ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { document . write ( " " ) ; n -- ; m -- ; } while ( m > 0 ) { document . write ( " " ) ; m -- ; } } } var n = 4 , m = 8 ; printPattern ( n , m ) ;
function countDecreasing ( A , n ) { var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } var A = [ 100 , 3 , 1 , 13 ] ; var n = A . length ; document . write ( countDecreasing ( A , n ) ) ;
function minimumChar ( S1 , S2 ) { let n = S1 . length ; let m = S2 . length ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < m - n + 1 ; i ++ ) { let minRemovedChar = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . min ( minRemovedChar , ans ) ; } return ans ; } let S1 = " " ; let S2 = " " ; document . write ( minimumChar ( S1 , S2 ) ) ;
let mod = 100000007 ; function countFreq ( pat , txt ) { let M = pat . length ; let N = txt . length ; let res = 0 ; for ( let i = 0 ; i <= N - M ; i ++ ) { let j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; } let txt = " " ; let pat = " " ; document . write ( countFreq ( pat , txt ) ) ;
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { document . write ( " " + i + " " ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } let txt = " " ; let pat = " " ; search ( pat , txt ) ;
function printMatrix ( n , m ) { if ( n < 5 m < 5 ) { document . write ( - 1 ) ; return ; } var s = " " ; for ( var i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { document . write ( s [ j % 5 ] + " " ) ; } document . write ( " " ) ; var c = s [ 0 ] ; s = s . substring ( 1 , s . length ) + s . substring ( 0 , 1 ) ; s [ 4 ] = c ; } } var n = 5 , m = 5 ; printMatrix ( n , m ) ;
function minOperations ( n , a , b , c ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let x = a [ i ] ; let y = b [ i ] ; let z = c [ i ] ; if ( x == y && y == z ) { ; } else if ( x == y y == z x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; } let a = " " ; let b = " " ; let c = " " ; let n = a . length ; document . write ( minOperations ( n , a , b , c ) ) ;
function check ( s ) { let n = s . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; } let s = " " ; if ( check ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countSubStr ( str , n , x ) { let res = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; } let str = " " ; let n = str . length ; let x = ' ' ; document . write ( countSubStr ( str , n , x ) ) ;
function countSubStr ( str , n ) { var len = str . length ; return len - n + 1 ; } var str = " " ; var n = 5 ; document . write ( countSubStr ( str , n ) ) ;
function countSubstrings ( s , c ) { var n = s . length ; var cnt = 0 ; var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; } var s = " " ; var c = ' ' ; document . write ( countSubstrings ( s , c ) ) ;
function isPalindrome ( s ) { let i = 0 ; let j = s . length - 1 ; while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; } function getIndex ( S1 , S2 , n ) { let S = " " ; for ( let i = 0 ; i < n ; i ++ ) { S = S + S1 [ i ] ; let Temp = " " ; for ( let j = i + 1 ; j < n ; j ++ ) Temp += S2 [ j ] ; if ( isPalindrome ( S + Temp ) ) { return i ; } } return - 1 ; } let S1 = " " , S2 = " " ; let n = S1 . length ; document . write ( getIndex ( S1 , S2 , n ) ) ;
function valid ( cnt ) { for ( var i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; } function getGoodString ( ss , n ) { var s = ss . split ( " " ) ; if ( n < 26 ) return " " ; for ( var i = 25 ; i < n ; i ++ ) { var cnt = new Array ( 26 ) . fill ( 0 ) ; for ( var j = i ; j >= i - 25 ; j -- ) { cnt [ s [ j ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; } if ( valid ( cnt ) ) { var cur = 0 ; while ( cnt [ cur ] > 0 ) cur ++ ; for ( var j = i - 25 ; j <= i ; j ++ ) { if ( s [ j ] === " " ) { s [ j ] = String . fromCharCode ( cur + " " . charCodeAt ( 0 ) ) ; cur ++ ; while ( cnt [ cur ] > 0 ) cur ++ ; } } return s . join ( " " ) ; } } return " " ; } var s = " " ; var n = s . length ; document . write ( getGoodString ( s , n ) ) ;
function isVowel ( c ) { c = c . toLowerCase ( ) ; if ( c === " " c === " " c === " " c === " " c === " " ) { return true ; } return false ; } function swapRepeated ( str ) { for ( var i = 0 ; i < str . length - 1 ; i ++ ) { if ( ( isVowel ( str [ i ] ) && isVowel ( str [ i + 1 ] ) ) || ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i + 1 ] ) ) ) { var c = str [ i ] ; str [ i ] = str [ i + 1 ] ; str [ i + 1 ] = c ; } } return str . join ( " " ) ; } var str = " " ; document . write ( swapRepeated ( str . split ( " " ) ) ) ;
function largestPalinSub ( s ) { let res = " " ; let mx = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) mx = String . fromCharCode ( Math . max ( mx . charCodeAt ( ) , s [ i ] . charCodeAt ( ) ) ) ; for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; } let s = " " ; document . write ( largestPalinSub ( s ) ) ;
function printString ( str , n ) { let ones = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( str [ i ] == ' ' ) ones ++ ; let used = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' && ! used ) { used = true ; for ( let j = 0 ; j < ones ; j ++ ) document . write ( " " ) ; } if ( str [ i ] != ' ' ) document . write ( str [ i ] ) ; } if ( ! used ) for ( let j = 0 ; j < ones ; j ++ ) document . write ( " " ) ; } let str = " " ; let n = str . length ; printString ( str . split ( ' ' ) , n ) ;
function findPermutation ( str , k ) { var has = new Array ( 26 ) ; for ( var i = 0 ; i < 26 ; i ++ ) has [ i ] = false ; var cnt = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( ! has [ str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ) { cnt ++ ; has [ str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] = true ; } } var ans = 1 ; for ( var i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( var i = cnt - k ; i > 1 ; i -- ) ans /= i ; return ans ; } var str = " " ; var k = 4 ; document . write ( findPermutation ( str , k ) ) ;
function product ( x ) { let prod = 1 ; while ( x > 0 ) { prod *= ( x % 10 ) ; x = parseInt ( x / 10 , 10 ) ; } return prod ; } function findNumber ( l , r ) { let b = r . toString ( ) ; let ans = r ; for ( let i = 0 ; i < b . length ; i ++ ) { if ( b [ i ] == ' ' ) continue ; let curr = b . split ( ' ' ) ; curr [ i ] = String . fromCharCode ( ( ( curr [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) - 1 ) + ' ' . charCodeAt ( ) ) ; for ( let j = i + 1 ; j < curr . length ; j ++ ) curr [ j ] = ' ' ; let num = 0 ; for ( let j = 0 ; j < curr . length ; j ++ ) num = num * 10 + ( curr [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( num >= l && product ( ans ) < product ( num ) ) ans = num ; } return ans ; } let l = 1 , r = 10 ; document . write ( findNumber ( l , r ) + " " ) ; l = 51 ; r = 62 ; document . write ( findNumber ( l , r ) ) ;
function constructBinString ( a , b , x ) { let d , i ; d = parseInt ( x / 2 , 10 ) ; if ( x % 2 == 0 && parseInt ( x / 2 , 10 ) != a ) { d -- ; document . write ( " " ) ; a -- ; } for ( i = 0 ; i < d ; i ++ ) document . write ( " " ) ; a = a - d ; b = b - d ; for ( i = 0 ; i < b ; i ++ ) { document . write ( " " ) ; } for ( i = 0 ; i < a ; i ++ ) { document . write ( " " ) ; } } let a = 4 , b = 3 , x = 2 ; constructBinString ( a , b , x ) ;
function matchPattern ( s ) { let count = 0 ; let n = s . length ; let i = 0 ; while ( i < n ) { while ( i < n && s [ i ] == ' ' ) { count ++ ; i ++ ; } while ( i < n && s [ i ] == ' ' ) { count -- ; i ++ ; } if ( count != 0 ) return false ; } return true ; } let s = " " ; if ( matchPattern ( s ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function maximum_one ( s , n ) { var cnt_one = 0 ; var max_cnt = 0 , temp = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) { cnt_one ++ ; temp ++ ; } else { max_cnt = Math . max ( temp , max_cnt ) ; temp = 0 ; } } max_cnt = Math . max ( max_cnt , temp ) ; var left = Array ( n ) ; var right = Array ( n ) ; if ( s [ 0 ] == ' ' ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s [ n - 1 ] == ' ' ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ; for ( var i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) left [ i ] = left [ i - 1 ] + 1 ; else left [ i ] = 0 ; } for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == ' ' ) { var sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) max_cnt = Math . max ( max_cnt , sum + 1 ) ; else max_cnt = Math . max ( max_cnt , sum ) ; } } return max_cnt ; } var s = " " ; document . write ( maximum_one ( s , s . length ) ) ;
function maxFreq ( s , a , b ) { var fre = new Array ( 10 ) . fill ( 0 ) ; var n = s . length ; if ( a > b ) { var temp = a ; a = b ; b = temp ; } for ( var i = 0 ; i < n ; i ++ ) fre [ s [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; if ( fre [ a ] === 0 && fre [ b ] === 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; } var a = 4 , b = 7 ; var s = " " ; document . write ( maxFreq ( s , a , b ) ) ;
function convert ( n , a , b ) { let l = new Array ( n ) ; let i ; for ( i = 0 ; i < n ; i ++ ) l [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) l [ i ] = 1 ; } let cc = 0 ; let vl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( l [ i ] == 0 ) { if ( vl != 0 ) cc += 1 ; vl = 0 ; } else vl += 1 ; } if ( vl != 0 ) cc += 1 ; document . write ( cc + " " ) ; } let a = " " ; let b = " " ; let n = a . length ; convert ( n , a , b ) ;
function countWays ( s1 , s2 , n ) { var a , b , c , d ; a = b = c = d = 0 ; var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s2 . charAt ( i ) == ' ' ) { if ( s1 . charAt ( i ) == ' ' ) { c ++ ; } else { d ++ ; } } else { if ( s1 . charAt ( i ) == ' ' ) { a ++ ; } else { b ++ ; } } } result = a * d + b * c + c * d ; return result ; } var n = 5 ; var s1 = " " ; var s2 = " " ; document . write ( countWays ( s1 , s2 , n ) ) ;
function returnWinner ( s , l ) { let freq = new Array ( 26 ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < l ; i ++ ) { freq [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; } let cnt = 0 ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] % 2 != 0 ) cnt ++ ; } if ( ( cnt == 0 ) || ( cnt & 1 ) == 1 ) return 1 ; else return 2 ; } let s = " " ; let l = s . length ; let winner = returnWinner ( s , l ) ; document . write ( " " + winner ) ;
function maxProductSum ( str , m ) { let n = str . length ; let maxProd = Number . MIN_VALUE , maxSum = Number . MIN_VALUE ; for ( let i = 0 ; i <= n - m ; i ++ ) { let product = 1 , sum = 0 ; for ( let j = i ; j < m + i ; j ++ ) { product = product * ( str [ j ] - ' ' ) ; sum = sum + ( str [ j ] - ' ' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } document . write ( " " + maxProd + " " ) ; document . write ( " " + maxSum ) ; } let str = " " ; let m = 3 ; maxProductSum ( str , m ) ;
function maxLength ( s , n ) { var right = 0 , left = 0 ; var coun = 0 , max_length = Number . MIN_VALUE ; s = s + ' ' ; for ( var i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == ' ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == ' ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == ' ' ) ) left = 1 ; coun = Math . ceil ( coun / ( right + left ) ) ; max_length = Math . max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; } var s = " " ; var n = s . length ; document . write ( maxLength ( s , n ) ) ;
function areVowelsInOrder ( s ) { var n = s . length ; var c = String . fromCharCode ( 64 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; } var s = " " ; if ( areVowelsInOrder ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function Remainder ( str , R ) { var len = str . length ; var Num , Rem = 0 ; for ( var i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - ' ' ) ; Rem = Num % R ; } return Rem ; } var str = " " ; var R = 13 ; document . write ( Remainder ( str , R ) ) ;
function count_carry ( a , b ) { let carry = 0 ; let count = 0 ; let len_a = a . length , len_b = b . length ; while ( len_a != 0 len_b != 0 ) { let x = 0 , y = 0 ; if ( len_a > 0 ) { x = a [ len_a - 1 ] - ' ' ; len_a -- ; } if ( len_b > 0 ) { y = b [ len_b - 1 ] - ' ' ; len_b -- ; } let sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; } let a = " " , b = " " ; let count = count_carry ( a , b ) ; if ( count == 0 ) document . write ( " " + " " ) ; else if ( count == 1 ) document . write ( " " + " " ) ; else document . write ( count ) ;
function isInGivenBase ( str , bas ) { if ( bas > 16 ) return false ; else if ( bas <= 10 ) { for ( let i = 0 ; i < str . length ; i ++ ) if ( ! ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas ) ) ) return false ; } else { for ( let i = 0 ; i < str . length ; i ++ ) if ( ! ( ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas ) ) || ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas - 10 ) ) ) ) return false ; } return true ; } let str = " " ; if ( isInGivenBase ( str , 16 ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function printIndex ( str , s ) { var flag = false ; for ( var i = 0 ; i < str . length - s . length + 1 ; i ++ ) { if ( str . substring ( i , s . length + i ) == s ) { document . write ( i + " " ) ; flag = true ; } } if ( flag === false ) { document . write ( " " ) ; } } var str1 = " " ; var str2 = " " ; printIndex ( str1 , str2 ) ;
function matchClosing ( X , start , end , open , close ) { let c = 1 ; let i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i ++ ; } return i ; } function matchingOpening ( X , start , end , open , close ) { let c = - 1 ; let i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i -- ; } return - 1 ; } function isBalanced ( X , n ) { let i , j = 0 , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) { if ( X [ i ] == ' ' ) { j = matchClosing ( X , i , n - 1 , ' ' , ' ' ) ; } else if ( X [ i ] == ' ' ) { j = matchClosing ( X , i , n - 1 , ' ' , ' ' ) ; } else if ( X [ i ] == ' ' ) { j = matchClosing ( X , i , n - 1 , ' ' , ' ' ) ; } else { if ( X [ i ] == ' ' ) { j = matchingOpening ( X , 0 , i , ' ' , ' ' ) ; } else if ( X [ i ] == ' ' ) { j = matchingOpening ( X , 0 , i , ' ' , ' ' ) ; } else if ( X [ i ] == ' ' ) { j = matchingOpening ( X , 0 , i , ' ' , ' ' ) ; } if ( j < 0 j >= i ) { return false ; } continue ; } if ( j >= n j < 0 ) { return false ; } start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == ' ' ) { x = matchClosing ( X , k , end , ' ' , ' ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ' ) { x = matchingOpening ( X , start , k , ' ' , ' ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' ' ) { x = matchClosing ( X , k , end , ' ' , ' ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ' ) { x = matchingOpening ( X , start , k , ' ' , ' ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' ' ) { x = matchClosing ( X , k , end , ' ' , ' ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ' ) { x = matchingOpening ( X , start , k , ' ' , ' ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; } let X = " " . split ( " " ) ; let n = 6 ; if ( isBalanced ( X , n ) ) document . write ( " " ) ; else document . write ( " " ) ; let Y = " " . split ( " " ) ; n = 7 ; if ( isBalanced ( Y , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function possibleToSort ( arr , n , str ) { let max_element = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str [ i ] == ' ' ) { if ( max_element > i + 1 ) return " " ; } } return " " ; } let arr = [ 1 , 2 , 5 , 3 , 4 , 6 ] ; let n = arr . Length ; let str = " " ; document . write ( possibleToSort ( arr , n , str ) ) ;
function isPrimeString ( str ) { let len = str . length , n = 0 ; for ( let i = 0 ; i < len ; i ++ ) { n += str [ i ] . charCodeAt ( ) ; } if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( let i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } let str = " " ; if ( isPrimeString ( str ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
let MAX = 256 ; function fact ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } function countPalinPermutations ( str ) { let n = str . length ; let freq = new Array ( MAX ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) freq [ str [ i ] . charCodeAt ( ) ] ++ ; let res = fact ( n / 2 ) ; let oddFreq = false ; for ( let i = 0 ; i < MAX ; i ++ ) { let half = freq [ i ] / 2 ; if ( freq [ i ] % 2 != 0 ) { if ( oddFreq == true ) return 0 ; oddFreq = true ; } res = res / fact ( half ) ; } return res ; } let str = " " ; document . write ( countPalinPermutations ( str ) ) ;
function checkPalindrome ( str ) { let n = str . length ; let count = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; } let str = " " ; if ( checkPalindrome ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function evenDecimalValue ( str , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { result += ( n - i ) ; } } return result ; } let str = " " ; let n = 5 ; document . write ( evenDecimalValue ( str , n ) ) ;
function countSubstr ( s ) { let n = s . length ; let auxArr = new Array ( n ) ; if ( s [ 0 ] == ' ' ) auxArr [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } let count = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == ' ' ) count += auxArr [ i ] ; return count ; } let s = " " ; document . write ( countSubstr ( s ) ) ;
let MAX = 256 ; function canMakeStr2 ( str1 , str2 ) { let count = new Array ( MAX ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < str1 . length ; i ++ ) count [ str1 [ i ] ] ++ ; for ( let i = 0 ; i < str2 . length ; i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false ; count [ str2 [ i ] ] -- ; } return true ; } let str1 = " " ; let str2 = " " ; if ( canMakeStr2 ( str1 , str2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function finalPosition ( move ) { let l = move . length ; let countUp = 0 , countDown = 0 ; let countLeft = 0 , countRight = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( move [ i ] == ' ' ) countUp ++ ; else if ( move [ i ] == ' ' ) countDown ++ ; else if ( move [ i ] == ' ' ) countLeft ++ ; else if ( move [ i ] == ' ' ) countRight ++ ; } document . write ( " " + ( countRight - countLeft ) + " " + ( countUp - countDown ) + " " ) ; } let move = " " ; finalPosition ( move ) ;
function maxbalancedprefix ( str , n ) { var sum = 0 ; var maxi = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; } var str = " " ; var n = str . length ; document . write ( maxbalancedprefix ( str , n ) ) ;
function cost ( str ) { let len = str . length ; let res = 0 ; for ( let i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) { if ( str [ i ] != str [ j ] ) { res += Math . min ( str [ i ] . charCodeAt ( ) , str [ j ] . charCodeAt ( ) ) - ' ' . charCodeAt ( ) + 1 ; } } return res ; } let str = " " ; document . write ( cost ( str ) ) ;
let MAX_CHAR = 256 ; function isPresent ( s , q ) { let freq = new Array ( MAX_CHAR ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < s . length ; i ++ ) freq [ s [ i ] ] ++ ; for ( let i = 0 ; i < q . length ; i ++ ) { freq [ q [ i ] ] -- ; if ( freq [ q [ i ] ] < 0 ) return false ; } return true ; } let s = " " ; let q = " " ; if ( isPresent ( s , q ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countReduce ( str ) { let n = str . length ; let res = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) res += Math . abs ( str [ i ] . charCodeAt ( ) - str [ n - i - 1 ] . charCodeAt ( ) ) ; return res ; } let str = " " ; document . write ( countReduce ( str ) ) ;
function calculate ( s ) { let ans = 6 ; for ( let i = 0 ; i < 10 ; ++ i ) { for ( let j = 0 ; j < 10 ; ++ j ) { for ( let k = 0 ; k < 10 ; ++ k ) { for ( let l = 0 ; l < 10 ; ++ l ) { for ( let m = 0 ; m < 10 ; ++ m ) { for ( let n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { let c = 0 ; if ( i != s [ 0 ] - ' ' ) c ++ ; if ( j != s [ 1 ] - ' ' ) c ++ ; if ( k != s [ 2 ] - ' ' ) c ++ ; if ( l != s [ 3 ] - ' ' ) c ++ ; if ( m != s [ 4 ] - ' ' ) c ++ ; if ( n != s [ 5 ] - ' ' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; } let s = " " ; document . write ( calculate ( s ) ) ;
function makeAndCheckString ( words , str ) { let n = words . length ; let first = false , second = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; } let str = " " ; let words = [ " " , " " , " " , " " ] ; if ( makeAndCheckString ( words , str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function sentencePalindrome ( str ) { let l = 0 ; let h = str . length - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { let getAtl = str [ l ] ; let getAth = str [ h ] ; if ( ! ( getAtl >= ' ' && getAtl <= ' ' ) ) l ++ ; else if ( ! ( getAth >= ' ' && getAth <= ' ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; } let str = " " ; if ( sentencePalindrome ( str ) ) document . write ( " " ) ; else document . write ( " " + " " + " " ) ;
function xorZero ( s ) { let one_count = 0 , zero_count = 0 ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' ' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; } let s = " " ; document . write ( xorZero ( s ) ) ;
let MAX_CHAR = 26 ; function checkCorrectOrNot ( s ) { let count = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } let n = s . length ; if ( n == 1 ) return true ; for ( let i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s [ i ] - ' ' ] ++ ; count [ s [ j ] - ' ' ] -- ; } for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; } let s = " " ; if ( checkCorrectOrNot ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function uniqueCharacters ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let bitAtIndex = str [ i ] - ' ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; } let input = " " ; if ( uniqueCharacters ( input ) ) { document . write ( " " + input + " " ) ; } else { document . write ( " " + input + " " ) ; }
function isKthBitSet ( n , k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) document . write ( " " ) ; else document . write ( " " ) ; } let n = 5 , k = 1 ; isKthBitSet ( n , k ) ;
function isPalRec ( str , s , e ) { if ( s == e ) return true ; if ( ( str . charAt ( s ) ) != ( str . charAt ( e ) ) ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } function isPalindrome ( str ) { var n = str . length ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; } var str = " " ; if ( isPalindrome ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
var MAX_CHAR = 26 ; function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; var count = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; } var s = " " ; document . write ( countSubstringWithEqualEnds ( s ) ) ;
function maxRepeating ( str ) { var n = str . length ; var count = 0 ; var res = str [ 0 ] ; var cur_count = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; } var str = " " ; document . write ( maxRepeating ( str ) ) ;
function query ( s , i , j ) { let n = s . length ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; } let X = " " ; query ( X , 0 , 8 ) ; query ( X , 8 , 13 ) ; query ( X , 6 , 15 ) ;
function countPairs ( str ) { let result = 0 ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str [ i ] . charCodeAt ( ) - str [ j ] . charCodeAt ( ) ) == Math . abs ( i - j ) ) result ++ ; return result ; } let str = " " ; document . write ( countPairs ( str ) ) ;
function min ( a , b ) { if ( a < b ) return a ; else return b ; } function longestString ( str1 , str2 ) { var count1 = new Array ( 26 ) ; var count2 = new Array ( 26 ) ; count1 . fill ( 0 ) ; count2 . fill ( 0 ) ; for ( var i = 0 ; i < str1 . length ; i ++ ) { count1 [ str1 . charCodeAt ( i ) - 97 ] ++ ; } for ( var i = 0 ; i < str2 . length ; i ++ ) { count2 [ str2 . charCodeAt ( i ) - 97 ] ++ ; } var result = " " ; for ( var i = 0 ; i < 26 ; i ++ ) { for ( var j = 1 ; j <= min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += String . fromCharCode ( 97 + i ) ; } } document . write ( result ) ; } var str1 = " " ; var str2 = " " ; longestString ( str1 , str2 ) ;
function countkDist ( str , k ) { var res = 0 ; var n = str . length ; var cnt = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < n ; i ++ ) { var dist_count = 0 ; for ( j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; } var ch = " " ; var k = 3 ; document . write ( " " + k + " " + countkDist ( ch , k ) ) ;
function removeRecur ( n ) { let prev_digit = n % 10 ; let pow = 10 ; let res = prev_digit ; while ( n > 0 ) { let curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = parseInt ( n / 10 , 10 ) ; } return res ; } let n = 12224 ; document . write ( removeRecur ( n ) ) ;
function printTheArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + " " ) ; } document . write ( " " ) ; } function generateAllBinaryStrings ( n , arr , i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; } let n = 4 ; let arr = new Array ( n ) ; arr . fill ( 0 ) ; generateAllBinaryStrings ( n , arr , 0 ) ;
function firstDigit ( n ) { while ( n >= 10 ) { n = parseInt ( n / 10 , 10 ) ; } return n ; } function getCount ( n ) { let count = 1 ; while ( n != 0 ) { let leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; } function getLargestNumber ( k ) { let left = k ; let right = k * 10 ; let mid = parseInt ( ( left + right ) / 2 , 10 ) ; let len = getCount ( mid ) ; while ( len != k ) { mid = parseInt ( ( left + right ) / 2 , 10 ) ; len = getCount ( mid ) ; if ( len > k ) { right = mid ; } else { left = mid ; } } while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; } let k = 3 ; document . write ( getLargestNumber ( k ) ) ;
function diameter ( r ) { document . write ( " " + " " + 2 * r ) ; } var r = 4 ; diameter ( r ) ;
function getSlope ( m ) { return m ; } var m = 2 ; document . write ( getSlope ( m ) ) ;
function totalTriangles ( h , v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; var total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; } var h = 2 , v = 2 ; document . write ( totalTriangles ( h , v ) ) ;
function sph ( r , R , h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; var x = r ; var V = ( ( 4 * 3.14 * Math . pow ( r , 3 ) ) / 3 ) ; return V ; } var r = 5 , R = 8 , h = 11 ; document . write ( sph ( r , R , h ) . toFixed ( 5 ) ) ;
function checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { let m1 , m2 ; if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ; else if ( x2 - x1 == 0 ) { m2 = parseInt ( ( y4 - y3 ) / ( x4 - x3 ) , 10 ) ; if ( m2 == 0 ) return true ; else return false ; } else if ( x4 - x3 == 0 ) { m1 = parseInt ( ( y2 - y1 ) / ( x2 - x1 ) , 10 ) ; if ( m1 == 0 ) return true ; else return false ; } else { m1 = parseInt ( ( y2 - y1 ) / ( x2 - x1 ) , 10 ) ; m2 = parseInt ( ( y4 - y3 ) / ( x4 - x3 ) , 10 ) ; if ( m1 * m2 == - 1 ) return true ; else return false ; } } let x1 = 0 , y1 = 4 , x2 = 0 , y2 = - 9 ; let x3 = 2 , y3 = 0 , x4 = - 1 , y4 = 0 ; if ( checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function pentdiagonal ( a ) { if ( a < 0 ) return - 1 ; let d = 1.22 * a ; return d ; } let a = 6 ; document . write ( pentdiagonal ( a ) ) ;
function hexagonArea ( d ) { return ( 3 * Math . sqrt ( 3 ) * Math . pow ( d , 2 ) ) / 8 ; } let d = 10 ; document . write ( " " + hexagonArea ( d ) . toFixed ( 3 ) ) ;
function Squares ( n , m , a ) { return parseInt ( ( ( m + a - 1 ) / a ) ) * parseInt ( ( ( n + a - 1 ) / a ) ) ; } var n = 6 , m = 6 , a = 4 ; document . write ( Squares ( n , m , a ) ) ;
function octadiagonal ( a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; } var a = 4 ; document . write ( octadiagonal ( a ) . toFixed ( 5 ) ) ;
function CalPeri ( ) { var S = 5 , Perimeter ; Perimeter = 10 * S ; document . write ( " " + Perimeter ) ; } CalPeri ( ) ;
function findEdges ( s1 , s2 , s3 ) { let a = Math . sqrt ( s1 * s2 / s3 ) ; let b = Math . sqrt ( s3 * s1 / s2 ) ; let c = Math . sqrt ( s3 * s2 / s1 ) ; let sum = a + b + c ; return 4 * sum ; } let s1 , s2 , s3 ; s1 = 65 ; s2 = 156 ; s3 = 60 ; document . write ( findEdges ( s1 , s2 , s3 ) ) ;
function findMaximumPieces ( n ) { var x = parseInt ( n / 2 ) ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; } var n = 3 ; document . write ( " " + n + " " + findMaximumPieces ( 3 ) ) ;
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } var x1 = 3 ; var y1 = 2 ; var z1 = - 5 ; var x2 = - 1 ; var y2 = 4 ; var z2 = - 3 ; var x3 = - 3 ; var y3 = 8 ; var z3 = - 5 ; var x4 = - 3 ; var y4 = 2 ; var z4 = 1 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ;
function distance ( a1 , b1 , c1 , a2 , b2 , c2 ) { var d = a1 * a2 + b1 * b2 + c1 * c2 ; var e1 = Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; var e2 = Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = parseFloat ( d / ( e1 * e2 ) ) ; var pi = 3.14159 ; var A = ( 180 / pi ) * Math . acos ( d ) ; document . write ( " " + A . toFixed ( 1 ) + " " ) ; } var a1 = 1 ; var b1 = 1 ; var c1 = 2 ; var d1 = 1 ; var a2 = 2 ; var b2 = - 1 ; var c2 = 1 ; var d2 = - 4 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ;
function mirror_point ( a , b , c , d , x1 , y1 , z1 ) { var k = parseFloat ( ( - a * x1 - b * y1 - c * z1 - d ) / parseFloat ( a * a + b * b + c * c ) ) ; var x2 = parseFloat ( a * k + x1 ) ; var y2 = parseFloat ( b * k + y1 ) ; var z2 = parseFloat ( c * k + z1 ) ; var x3 = parseFloat ( 2 * x2 - x1 ) . toFixed ( 1 ) ; var y3 = parseFloat ( 2 * y2 - y1 ) . toFixed ( 1 ) ; var z3 = parseFloat ( 2 * z2 - z1 ) . toFixed ( 1 ) ; document . write ( " " + x3 ) ; document . write ( " " + y3 ) ; document . write ( " " + z3 ) ; } var a = 1 ; var b = - 2 ; var c = 0 ; var d = 0 ; var x1 = - 1 ; var y1 = 3 ; var z1 = 4 ; mirror_point ( a , b , c , d , x1 , y1 , z1 ) ;
function countRectangles ( radius ) { let rectangles = 0 ; let diameter = 2 * radius ; let diameterSquare = diameter * diameter ; for ( let a = 1 ; a < 2 * radius ; a ++ ) { for ( let b = 1 ; b < 2 * radius ; b ++ ) { let diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; } let radius = 2 ; let totalRectangles ; totalRectangles = countRectangles ( radius ) ; document . write ( totalRectangles + " " + radius ) ;
function simi_aaa ( a1 , a2 ) { a1 . sort ( function ( a , b ) { return a - b } ) ; a2 . sort ( function ( a , b ) { return a - b } ) ; if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; } function simi_sas ( s1 , s2 , a1 , a2 ) { a1 . sort ( function ( a , b ) { return a - b } ) ; a2 . sort ( function ( a , b ) { return a - b } ) ; s1 . sort ( function ( a , b ) { return a - b } ) ; s2 . sort ( function ( a , b ) { return a - b } ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) { if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; } function simi_sss ( s1 , s2 ) { s1 . sort ( function ( a , b ) { return a - b } ) ; s2 . sort ( function ( a , b ) { return a - b } ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; } let s1 = [ 2 , 3 , 3 ] ; let s2 = [ 4 , 6 , 6 ] ; let a1 = [ 80 , 60 , 40 ] ; let a2 = [ 40 , 60 , 80 ] ; let aaa = simi_aaa ( a1 , a2 ) ; let sss = simi_sss ( s1 , s2 ) ; let sas = simi_sas ( s1 , s2 , a1 , a2 ) ; if ( aaa == 1 sss == 1 sas == 1 ) { document . write ( " " + " " ) ; if ( aaa == 1 ) document . write ( " " ) ; if ( sss == 1 ) document . write ( " " ) ; if ( sas == 1 ) document . write ( " " ) ; } else document . write ( " " ) ;
function center_pentadecagonal_num ( n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; } var n = 3 ; document . write ( n + " " ) ; document . write ( center_pentadecagonal_num ( n ) + " " ) ; n = 10 ; document . write ( n + " " ) ; document . write ( center_pentadecagonal_num ( n ) ) ;
function center_nonadecagon_num ( n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; } var n = 2 ; document . write ( n + " " + " " ) ; document . write ( center_nonadecagon_num ( n ) + " " ) ; n = 7 ; document . write ( n + " " + " " ) ; document . write ( center_nonadecagon_num ( n ) ) ;
function hendecagonal_num ( n ) { return ( 9 * n * n - 7 * n ) / 2 ; } let n = 3 ; document . write ( n + " " ) ; document . write ( hendecagonal_num ( n ) + " " ) ; n = 10 ; document . write ( n + " " ) ; document . write ( hendecagonal_num ( n ) ) ;
function centeredoctagonalNumber ( n ) { return 4 * n * ( n - 1 ) + 1 ; } var n = 6 ; document . write ( n + " " + " " ) ; document . write ( centeredoctagonalNumber ( n ) + " " ) ; n = 11 ; document . write ( n + " " + " " ) ; document . write ( centeredoctagonalNumber ( n ) ) ;
function isValid ( arr , i , j , m , c ) { if ( i == j ) return false ; var lhs = arr [ j ] ; var rhs = m * arr [ i ] + c ; return lhs == rhs ; } function findOrderedPoints ( arr , n , m , c ) { var counter = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { var firstIndex = i , secondIndex = j ; if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; } var arr = [ 1 , 2 , 3 , 4 , 2 ] ; var n = arr . length ; var m = 1 , c = 1 ; document . write ( findOrderedPoints ( arr , n , m , c ) ) ;
function checkcircle ( r , R , r1 , x1 , y1 ) { let dis = Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; } let r = 8 , R = 4 , r1 = 2 , x1 = 6 , y1 = 0 ; if ( checkcircle ( r , R , r1 , x1 , y1 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function surface_area_octahedron ( side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; } let side = 7 ; document . write ( " " + surface_area_octahedron ( side ) ) ;
function nCk ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } function count_Straightlines ( n , m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; } let n = 4 , m = 3 ; document . write ( count_Straightlines ( n , m ) ) ;
function vol_of_dodecahedron ( side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; } let side = 4 ; document . write ( " " + vol_of_dodecahedron ( side ) . toFixed ( 2 ) ) ;
function overflow ( H , r , h , N , R ) { let tank_cap = 3.14 * r * r * H ; let water_vol = 3.14 * r * r * h ; let balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; let vol = water_vol + balls_vol ; if ( vol > tank_cap ) { document . write ( " " ) ; } else { document . write ( " " ) ; } } let H = 10 , r = 5 , h = 5 , N = 2 , R = 2 ; overflow ( H , r , h , N , R ) ;
function volume ( radius , height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; } function check_and_print ( required_time , given_time ) { if ( required_time < given_time ) document . write ( " " ) ; else if ( required_time > given_time ) document . write ( " " ) ; else document . write ( " " ) ; } let radius = 5 , height = 10 , rate_of_flow = 10 ; let given_time = 70.0 ; let required_time = volume ( radius , height ) / rate_of_flow ; check_and_print ( required_time , given_time ) ;
function cal_cos ( n ) { let accuracy = 0.0001 , x1 ; let denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; let i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; return cosx ; } function third_side ( a , b , c ) { let angle = cal_cos ( c ) ; return Math . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; } let c = 49 ; let a = 5 , b = 8 ; document . write ( Math . round ( third_side ( a , b , c ) * 100000.0 ) / 100000.0 ) ;
function fitOrNotFit ( R , r , x , y , rad ) { var val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) document . write ( " " ) ; else document . write ( " " ) ; } var R = 8 , r = 4 ; var x = 5 , y = 3 , rad = 3 ; fitOrNotFit ( R , r , x , y , rad ) ;
function checkPolygonWithMidpoints ( arr , N , midpoints ) { for ( let j = 0 ; j < midpoints ; j ++ ) { let val = 1 ; for ( let k = j ; k < N ; k += midpoints ) { val &= arr [ k ] ; } if ( val && parseInt ( N / midpoints ) > 2 ) { document . write ( " " + parseInt ( N / midpoints ) + " " ) ; return true ; } } return false ; } function isPolygonPossible ( arr , N ) { let limit = Math . sqrt ( N ) ; for ( let i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , parseInt ( N / i ) ) ) return ; } } document . write ( " " ) ; } let arr = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ; let N = arr . length ; isPolygonPossible ( arr , N ) ;
function squareRoot ( n ) { let x = n ; let y = 1 ; let e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } function findMaximumHeight ( N ) { let n = 1 + 8 * N ; let maxH = ( - 1 + squareRoot ( n ) ) / 2 ; return Math . round ( maxH ) ; } let N = 12 ; document . write ( findMaximumHeight ( N ) ) ;
function calculateSpan ( price , n , S ) { S [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( let j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } function printArray ( arr ) { let result = arr . join ( " " ) ; document . write ( result ) ; } let price = [ 10 , 4 , 5 , 90 , 120 , 80 ] ; let n = price . length ; let S = new Array ( n ) ; S . fill ( 0 ) ; calculateSpan ( price , n , S ) ; printArray ( S ) ;
function printNGE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next ) ; document . write ( " " ) ; } } var arr = [ 11 , 13 , 21 , 3 ] ; var n = arr . length ; printNGE ( arr , n ) ;
function towerOfHanoi ( n , from_rod , to_rod , aux_rod ) { if ( n == 1 ) { document . write ( " " + from_rod + " " + to_rod + " " ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; document . write ( " " + n + " " + from_rod + " " + to_rod + " " ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; } var n = 4 ; towerOfHanoi ( n , ' ' , ' ' , ' ' ) ;
var arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] ; function printMaxOfMin ( n ) { for ( k = 1 ; k <= n ; k ++ ) { var maxOfMin = Number . MIN_VALUE ; for ( i = 0 ; i <= n - k ; i ++ ) { var min = arr [ i ] ; for ( j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } document . write ( maxOfMin + " " ) ; } } printMaxOfMin ( arr . length ) ;
function heapify ( arr , n , i ) { var largest = i ; var l = 2 * i + 1 ; var r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { var swap = arr [ i ] ; arr [ i ] = arr [ largest ] ; arr [ largest ] = swap ; heapify ( arr , n , largest ) ; } } function sort ( arr ) { var n = arr . length ; for ( var i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( var i = n - 1 ; i > 0 ; i -- ) { var temp = arr [ 0 ] ; arr [ 0 ] = arr [ i ] ; arr [ i ] = temp ; heapify ( arr , i , 0 ) ; } } function printArray ( arr ) { var n = arr . length ; for ( var i = 0 ; i < n ; ++ i ) document . write ( arr [ i ] + " " ) ; } var arr = [ 12 , 11 , 13 , 5 , 6 , 7 ] ; var n = arr . length ; sort ( arr ) ; document . write ( " " ) ; printArray ( arr , n ) ;
function isHeap ( arr , n ) { for ( let i = 0 ; i <= Math . floor ( ( n - 2 ) / 2 ) ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; } let arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] ; let n = arr . length ; if ( isHeap ( arr , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function generate_derangement ( N ) { let S = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) S [ i ] = i ; let D = [ ] ; for ( let i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( let i = 1 ; i <= N ; i ++ ) document . write ( D [ i ] + " " ) ; document . write ( " " ) ; } generate_derangement ( 10 ) ;
function Profit ( costPrice , sellingPrice ) { let profit = ( sellingPrice - costPrice ) ; return profit ; } function Loss ( costPrice , ellingPrice ) { let Loss = ( costPrice - sellingPrice ) ; return Loss ; } let costPrice = 1500 , sellingPrice = 2000 ; if ( sellingPrice == costPrice ) document . write ( " " ) ; else if ( sellingPrice > costPrice ) document . write ( Profit ( costPrice , sellingPrice ) + " " ) ; else document . write ( Loss ( costPrice , sellingPrice ) + " " ) ;
function nextPerfectSquare ( N ) { let nextN = Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; } let n = 35 ; document . write ( nextPerfectSquare ( n ) ) ;
function printSubstrings ( n ) { var s = parseInt ( Math . log10 ( n ) ) ; var d = parseInt ( ( Math . pow ( 10 , s ) + 0.5 ) ) ; var k = d ; while ( n > 0 ) { while ( d > 0 ) { document . write ( parseInt ( n / d ) + " " ) ; d = parseInt ( d / 10 ) ; } n = n % k ; k = parseInt ( k / 10 ) ; d = k ; } } var n = 123 ; printSubstrings ( n ) ;
let MOD = ( 1e9 + 7 ) ; function powerLL ( x , n ) { let result = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { result = result * x % MOD ; } n = Math . floor ( n / 2 ) ; x = x * x % MOD ; } return result ; } function powerStrings ( sa , sb ) { let a = 0 , b = 0 ; for ( let i = 0 ; i < sa . length ; i ++ ) { a = ( a * 10 + ( sa [ i ] - ' ' ) ) % MOD ; } for ( let i = 0 ; i < sb . length ; i ++ ) { b = ( b * 10 + ( sb [ i ] - ' ' ) ) % ( MOD - 1 ) ; } return powerLL ( a , b ) ; } let sa = " " , sb = " " ; document . write ( powerStrings ( sa , sb ) ) ;
function isPowerOfTwo ( n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } function previousPowerOfTwo ( n ) { while ( ( n & n - 1 ) > 1 ) { n = n & n - 1 ; } return n ; } function checkSum ( n ) { if ( n == 0 n == 1 ) return false ; else if ( isPowerOfTwo ( n ) ) { document . write ( n / 2 + " " + n / 2 + " " ) ; } else { var x = previousPowerOfTwo ( n ) ; var y = n - x ; if ( isPowerOfTwo ( y ) ) { document . write ( x + " " + y + " " ) ; return true ; } } return false ; } var n1 = 20 ; if ( checkSum ( n1 ) == false ) document . write ( " " ) ; document . write ( ) ; var n2 = 11 ; if ( checkSum ( n2 ) == false ) document . write ( " " ) ;
function complement ( num ) { var i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = parseInt ( num / 10 ) ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = parseInt ( Math . pow ( 10 , len ) - num ) ; return comp ; } document . write ( complement ( 25 ) + " " ) ; document . write ( complement ( 456 ) ) ;
function gcd ( a , b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } var a = 98 , b = 56 ; document . write ( " " + a + " " + b + " " + gcd ( a , b ) ) ;
function calculateSum ( n ) { let sum = 0 ; for ( let row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; } let n = 10 ; document . write ( " " + calculateSum ( n ) ) ;
function findAllSequence ( N ) { if ( N % 2 == 0 ) { return ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } } let N = 2 ; document . write ( findAllSequence ( N ) ) ;
function countOnes ( n ) { let count = 1 ; let rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; } let n = 13 ; document . write ( countOnes ( n ) ) ;
function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; } var a = 22 , b = 1231 ; document . write ( largestNum ( a , b ) ) ;
function gcd ( a , b ) { var c = a % b ; while ( c != 0 ) { a = b ; b = c ; c = a % b ; } return b ; } function numberOfmeet ( a , b ) { var ans ; if ( a > b ) ans = a - b ; else ans = b - a ; if ( a < 0 ) a = a * ( - 1 ) ; if ( b < 0 ) b = b * ( - 1 ) ; return ans / gcd ( a , b ) ; } var a = 1 , b = - 1 ; document . write ( numberOfmeet ( a , b ) ) ;
function printGreater ( x , y ) { let X = y * Math . log ( x ) ; let Y = x * Math . log ( y ) ; if ( Math . abs ( X - Y ) < 1e-9 ) { document . write ( " " ) ; } else if ( X > Y ) { document . write ( x + " " + y ) ; } else { document . write ( y + " " + x ) ; } } let x = 5 , y = 8 ; printGreater ( x , y ) ;
function sumOfSeries ( n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; } let n = 4 ; document . write ( sumOfSeries ( n ) ) ;
function mulmod ( a , b , mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b = parseInt ( b / 2 , 10 ) ; } return res % mod ; } function findProduct ( N ) { let product = 1 , fact = 1 ; let MOD = ( 1e9 + 7 ) ; for ( let i = 1 ; i <= N ; i ++ ) { fact = mulmod ( fact , i , MOD ) ; product = mulmod ( product , fact , MOD ) ; if ( product == 0 ) return 0 ; } return product ; } let N = 3 ; document . write ( findProduct ( N ) + " " ) ; N = 5 ; document . write ( findProduct ( N ) ) ;
function divSum ( n ) { let sum = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + parseInt ( n / i , 10 ) ; return sum ; } function areEquivalent ( num1 , num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; } let num1 = 559 ; let num2 = 703 ; if ( areEquivalent ( num1 , num2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function dodecahedral_num ( n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; } var n = 5 ; document . write ( n + " " + " " ) ; document . write ( dodecahedral_num ( n ) ) ;
function bit ( x ) { let ans = 0 ; while ( x > 0 ) { x = parseInt ( x / 2 , 10 ) ; ans ++ ; } return ans ; } function check ( d , x ) { if ( bit ( parseInt ( x / d , 10 ) ) <= bit ( d ) ) return true ; return false ; } function bs ( n ) { let l = 1 , r = Math . sqrt ( n ) ; while ( l < r ) { let m = parseInt ( ( l + r ) / 2 , 10 ) ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; } function countDivisor ( n ) { return n - bs ( n ) + 1 ; } let n = 5 ; document . write ( countDivisor ( n ) ) ;
function swap ( a , b ) { let t = a ; a = b ; b = t ; } function everMeet ( x1 , x2 , v1 , v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } while ( x1 >= x2 ) { if ( x1 == x2 ) return true ; x1 = x1 + v1 ; x2 = x2 + v2 ; } return false ; } let x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function check ( k , d0 , d1 ) { let s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; let a = ( k - 3 ) % 4 ; let x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } let sum = d0 + d1 + parseInt ( ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return " " ; return " " ; } let k , d0 , d1 ; k = 13 ; d0 = 8 ; d1 = 1 ; document . write ( check ( k , d0 , d1 ) + " " ) ; k = 5 ; d0 = 3 ; d1 = 4 ; document . write ( check ( k , d0 , d1 ) + " " ) ;
var a = 4 ; var b = 3 , val = 0 ; if ( ( a % b ) != 0 ) val = parseInt ( a / b ) + ( a % b ) ; else val = parseInt ( a / b ) ; document . write ( " " + " " + val + " " ) ; a = 6 ; b = 3 ; if ( ( a % b ) != 0 ) val = parseInt ( a / b ) + ( a % b ) ; else val = parseInt ( a / b ) ; document . write ( " " + " " + val ) ;
function printCollatz ( n ) { while ( n != 1 ) { document . write ( n + " " ) ; if ( ( n & 1 ) != 0 ) n = 3 * n + 1 ; else n = parseInt ( n / 2 , 10 ) ; } document . write ( n ) ; } printCollatz ( 6 ) ;
function block ( x ) { let v = [ ] ; document . write ( " " + x + " " ) ; while ( x > 0 ) { v . push ( x % 2 ) ; x = parseInt ( x / 2 , 10 ) ; } for ( let i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] == 1 ) { document . write ( i ) ; if ( i != v . length - 1 ) document . write ( " " ) ; } } document . write ( " " ) ; } block ( 71307 ) ; block ( 1213 ) ; block ( 29 ) ; block ( 100 ) ;
function findNumberOfDigits ( n , base ) { var dig = parseInt ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; document . write ( " " + " " + n + " " + base + " " + dig ) ; } var n = 1446 ; var base = 7 ; findNumberOfDigits ( n , base ) ;
function isValidNesbitt ( a , b , c ) { let A = a / ( b + c ) ; let B = b / ( a + c ) ; let C = c / ( a + b ) ; let inequality = A + B + C ; return ( inequality >= 1.5 ) ; } let a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) == true ) { document . write ( " " + " " ) ; document . write ( " " + a + " " + b + " " + c ) ; } else document . write ( " " + " " ) ;
function printCubeFree ( n ) { var cubFree = Array ( n + 1 ) . fill ( false ) ; for ( i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) document . write ( i + " " ) ; } } printCubeFree ( 20 ) ;
function isTriangular ( num ) { if ( num < 0 ) return 0 ; var c = ( - 2 * num ) ; var b = 1 , a = 1 ; var d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return - 1 ; var root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; var root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( parseInt ( ( root1 ) ) > 0 && parseInt ( ( Math . floor ( root1 ) ) ) == parseInt ( ( root1 ) ) ) return parseInt ( root1 ) ; if ( parseInt ( ( root2 ) ) > 0 && parseInt ( ( Math . floor ( root2 ) ) ) == parseInt ( ( root2 ) ) ) return parseInt ( ( root2 ) ) ; return - 1 ; } function isPerfectSquare ( x ) { var sr = Math . sqrt ( x ) ; if ( ( sr - Math . floor ( sr ) ) == 0 ) return parseInt ( ( Math . floor ( sr ) ) ) ; else return - 1 ; } function findS ( s ) { var sr = isPerfectSquare ( s ) ; if ( sr == - 1 ) return - 1 ; return isTriangular ( sr ) ; } var s = 9 ; var n = findS ( s ) ; if ( n == - 1 ) document . write ( " " ) ; else document . write ( n ) ;
function trickyCase ( s , index ) { let index1 = - 1 ; for ( let i = index - 1 ; i >= 0 ; i -- ) { let digit = s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; if ( digit != 8 ) { index1 = i ; break ; } } if ( index1 == - 1 ) return 2 * Math . pow ( 10 , s . length ) ; let num = 0 ; for ( let i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( s [ index1 ] . charCodeAt ( ) % 2 == 0 ) num = num * 10 + ( s [ index1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 2 ) ; else num = num * 10 + ( s [ index1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) ; for ( let i = index1 + 1 ; i < s . length ; i ++ ) num = num * 10 ; return num ; } function smallestNumber ( n ) { let num = 0 ; let s = " " ; let duplicate = n ; while ( n > 0 ) { s = String . fromCharCode ( n % 10 + 48 ) + s ; n = parseInt ( n / 10 , 10 ) ; } let index = - 1 ; for ( let i = 0 ; i < s . length ; i ++ ) { let digit = s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; let val = digit & 1 ; if ( val == 1 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; if ( s [ index ] == ' ' ) { num = trickyCase ( s , index ) ; return num ; } for ( let i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; num = num * 10 + ( s [ index ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) ; for ( let i = index + 1 ; i < s . length ; i ++ ) num = num * 10 ; return num ; } let N = 2397 ; document . write ( smallestNumber ( N ) ) ;
function findNth ( n ) { let count = 0 ; for ( let curr = 19 ; ; curr += 9 ) { let sum = 0 ; for ( let x = curr ; x > 0 ; x = parseInt ( x / 10 ) ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; } document . write ( findNth ( 5 ) ) ;
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; } let n = 5 ; document . write ( findSum ( n ) ) ;
function findSum ( n ) { let multiTerms = n * ( n + 1 ) / 2 ; let sum = multiTerms ; for ( let i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; } let n = 5 ; document . write ( findSum ( n ) ) ;
function totalSumDivisibleByNum ( digit , number ) { let firstnum = Math . pow ( 10 , digit - 1 ) ; let lastnum = Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; let count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; } let n = 3 , number = 7 ; document . write ( totalSumDivisibleByNum ( n , number ) ) ;
function Nth_of_AP ( a , d , N ) { return ( a + ( N - 1 ) * d ) ; } let a = 2 ; let d = 1 ; let N = 5 ; document . write ( " " + N + " " + Nth_of_AP ( a , d , N ) ) ;
function checkFibinnary ( n ) { var prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; } var n = 10 ; if ( checkFibinnary ( n ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function sumOfSeries ( n ) { return parseInt ( ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ) ; } var n = 2 ; document . write ( sumOfSeries ( n ) ) ;
function Nonagonal ( n ) { return parseInt ( n * ( 7 * n - 5 ) / 2 ) ; } let n = 10 ; document . write ( Nonagonal ( n ) ) ;
function divisibleBy20 ( num ) { let lastTwoDigits = parseInt ( num . slice ( - 2 , num . length ) ) console . log ( num . slice ( - 2 , 1 ) ) return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) } let num = " " ; if ( divisibleBy20 ( num ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isDvisibleBy12 ( num ) { if ( num . length >= 3 ) { let d1 = num [ num . length - 1 ] . charCodeAt ( ) ; if ( d1 % 2 != 0 ) return false ; let d2 = num [ num . length - 2 ] . charCodeAt ( ) ; let sum = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) sum += num [ i ] . charCodeAt ( ) ; return ( ( sum % 3 == 0 ) && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { let number = parseInt ( num , 10 ) ; document . write ( number ) ; return ( number % 12 == 0 ) ; } } let num = " " ; if ( isDvisibleBy12 ( num ) ) document . write ( " " ) ; else document . write ( " " ) ;
function check ( n ) { let d = Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } function largestNonPerfectSquareNumber ( a , n ) { let maxi = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! check ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } let a = [ 16 , 20 , 25 , 2 , 3 , 10 ] ; let n = a . length ; document . write ( largestNonPerfectSquareNumber ( a , n ) ) ;
function printAP ( a , d , n ) { let curr_term ; curr_term = a ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( curr_term + " " ) ; curr_term = curr_term + d ; } } let a = 2 ; let d = 1 ; let n = 5 ; printAP ( a , d , n ) ;
function printNonSquare ( n ) { let curr_count = 2 , num = 2 , count = 0 ; while ( count < n ) { for ( let i = 0 ; i < curr_count && count < n ; i ++ ) { document . write ( num + " " ) ; count ++ ; num ++ ; } num ++ ; curr_count += 2 ; } } let n = 10 ; printNonSquare ( n ) ;
function countZeros ( a , n ) { let count2 = 0 , count5 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] = parseInt ( a [ i ] / 2 ) ; count2 ++ ; } while ( a [ i ] % 5 == 0 ) { a [ i ] = parseInt ( a [ i ] / 5 ) ; count5 ++ ; } } return ( count2 < count5 ) ? count2 : count5 ; } let a = [ 10 , 100 , 20 , 30 , 50 , 90 , 12 , 80 ] ; let n = a . length ; document . write ( countZeros ( a , n ) ) ;
function squareSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) ; return sum ; } document . write ( squareSum ( 8 ) ) ;
var pwr ; function isMunchhausen ( n ) { var sum = 0 ; var temp = n ; while ( temp > 0 ) { var index = temp % 10 ; sum = sum + pwr [ index ] ; temp = parseInt ( temp / 10 ) ; } return ( sum == n ) ; } function printMunchhausenNumbers ( n ) { pwr = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < 10 ; i ++ ) pwr [ i ] = Math . pow ( i , i ) ; for ( var i = 1 ; i <= n ; i ++ ) if ( isMunchhausen ( i ) == true ) document . write ( i + " " ) ; } var n = 10000 ; printMunchhausenNumbers ( n ) ;
function kthdigit ( a , b , k ) { let p = Math . pow ( a , b ) ; let count = 0 ; while ( p > 0 && count < k ) { let rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; } let a = 5 , b = 2 ; let k = 1 ; document . write ( kthdigit ( a , b , k ) ) ;
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } function PowDigSum ( n , x ) { let sum = digSum ( n ) ; let rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( Math . pow ( sum , 6 ) ) ; else return digSum ( Math . pow ( sum , rem ) ) ; } let n = 33333 ; let x = 332654 ; document . write ( PowDigSum ( n , x ) ) ;
function maxArea ( A , len ) { let l = 0 ; let r = len - 1 ; let area = 0 ; while ( l < r ) { area = Math . max ( area , Math . min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; } let a = [ 1 , 5 , 4 , 3 ] ; let b = [ 3 , 1 , 2 , 4 , 5 ] ; let len1 = a . length ; document . write ( maxArea ( a , len1 ) + " " ) ; let len2 = b . length ; document . write ( maxArea ( b , len2 ) ) ;
function mobius ( n ) { let p = 0 ; if ( n % 2 == 0 ) { n = parseInt ( n / 2 , 10 ) ; p ++ ; if ( n % 2 == 0 ) return 0 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = parseInt ( n / i , 10 ) ; p ++ ; if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? - 1 : 1 ; } let N = 17 ; document . write ( " " + " " + N + " " + mobius ( N ) + " " ) ; document . write ( " " + " " + 25 + " " + mobius ( 25 ) + " " ) ; document . write ( " " + " " + 6 + " " + mobius ( 6 ) ) ;
function factorial ( start , end ) { let res = 1 ; for ( let i = start ; i <= end ; i ++ ) res *= i ; return res ; } function sumofsquare ( n ) { return parseInt ( factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) , 10 ) ; } let n = 4 ; document . write ( sumofsquare ( n ) ) ;
let PHI = 1.6180339 ; let f = [ 0 , 1 , 1 , 2 , 3 , 5 ] ; function fib ( n ) { if ( n < 6 ) return f [ n ] ; let t = 5 , fn = 5 ; while ( t < n ) { fn = Math . round ( fn * PHI ) ; t ++ ; } return fn ; } let n = 9 ; document . write ( n + " " + fib ( n ) + " " ) ;
function func ( x , y ) { return ( x + y + x * y ) ; } function euler ( x0 , y , h , x ) { let temp = - 0 ; while ( x0 < x ) { temp = y ; y = y + h * func ( x0 , y ) ; x0 = x0 + h ; } document . write ( " " + x + " " + y ) ; } let x0 = 0 ; let y0 = 1 ; let h = 0.025 ; let x = 0.1 ; euler ( x0 , y0 , h , x ) ;
function solution ( a , b , n ) { for ( let i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { document . write ( " " + i + " " + ( n - ( i * a ) ) / b ) ; return ; } } document . write ( " " ) ; } let a = 2 , b = 3 , n = 7 ; solution ( a , b , n ) ;
function binomialCoeffSum ( n ) { return ( 1 << n ) ; } let n = 4 ; document . write ( binomialCoeffSum ( n ) ) ;
function precisionCompute ( x , y , n ) { if ( y == 0 ) { document . write ( " " ) ; return ; } if ( x == 0 ) { document . write ( " " ) ; return ; } if ( n <= 0 ) { document . write ( x / y ) ; return ; } if ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) { document . write ( " " ) ; x = x > 0 ? x : - x ; y = y > 0 ? y : - y ; } let d = x / y ; for ( let i = 0 ; i <= n ; i ++ ) { document . write ( d ) ; x = x - ( y * d ) ; if ( x == 0 ) break ; x = x * 10 ; d = x / y ; if ( i == 0 ) document . write ( " " ) ; } } let x = 22 , y = 7 , n = 15 ; precisionCompute ( x , y , n ) ;
function quadrant ( x , y ) { if ( x > 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y > 0 ) document . write ( " " ) ; else if ( x < 0 && y < 0 ) document . write ( " " ) ; else if ( x > 0 && y < 0 ) document . write ( " " ) ; else if ( x == 0 && y > 0 ) document . write ( " " ) ; else if ( x == 0 && y < 0 ) document . write ( " " ) ; else if ( y == 0 && x < 0 ) document . write ( " " ) ; else if ( y == 0 && x > 0 ) document . write ( " " ) ; else document . write ( " " ) ; } let x = 1 , y = 1 ; quadrant ( x , y ) ;
function checkDigits ( n ) { while ( n > 0 ) { let dig = n % 10 ; if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n = parseInt ( n / 10 , 10 ) ; } return true ; } function prime ( n ) { if ( n == 1 ) return false ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } function isFullPrime ( n ) { return ( checkDigits ( n ) && prime ( n ) ) ; } let n = 53 ; if ( isFullPrime ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
let MAX = 500 ; function nthSHN ( n , dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; } let n = 6 ; let dp = new Array ( MAX ) ; for ( let i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; document . write ( nthSHN ( n , dp ) ) ;
function evenSum ( n ) { let curr = 2 , sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; } let n = 20 ; document . write ( " " + n + " " + evenSum ( n ) ) ;
function evenSum ( n ) { return ( n * ( n + 1 ) ) ; } let n = 20 ; document . write ( " " + n + " " , evenSum ( n ) ) ;
function kmphTOmph ( kmph ) { return ( 0.6214 * kmph ) ; } function mphTOkmph ( mph ) { return ( 1.60934 * mph ) ; } var kmph = 150 var mph = 100 document . write ( " " + kmphTOmph ( kmph ) + " " ) ; document . write ( " " + mphTOkmph ( mph ) ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function findNumber ( arr , n ) { let ans = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return - 1 ; } let arr = [ 2 , 2 , 4 ] ; let n = arr . length ; document . write ( findNumber ( arr , n ) ) ;
let primes = [ ] ; function SieveofEratosthenes ( n ) { let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( let j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . push ( i ) ; } } function specialPrimeNumbers ( n , k ) { SieveofEratosthenes ( n ) ; let count = 0 ; for ( let i = 0 ; i < primes . length ; i ++ ) { for ( let j = 0 ; j < i - 1 ; j ++ ) { if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) { count ++ ; break ; } } if ( count == k ) return true ; } return false ; } let n = 27 , k = 2 ; if ( specialPrimeNumbers ( n , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
function factorize ( n ) { var count = 0 ; while ( ( n % 2 ) == 0 ) { count ++ ; } if ( count ) document . write ( 2 + " " + count + " " ) ; for ( var i = 3 ; i <= parseInt ( Math . sqrt ( n ) ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = parseInt ( n / i ) ; } if ( count != 0 ) document . write ( i + " " + count + " " ) ; } if ( n > 2 ) document . write ( n + " " + 1 + " " ) ; } var n = 1000000000000000000 ; factorize ( n ) ;
function __gcd ( a , b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } function minimumMoves ( A , N ) { let one = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ; if ( one != 0 ) return N - one ; let minimum = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < N ; i ++ ) { let g = A [ i ] ; for ( let j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = Math . min ( minimum , j - i ) ; break ; } } } if ( minimum == Number . MAX_SAFE_INTEGER ) return - 1 ; else return N + minimum - 1 ; } let A = [ 2 , 4 , 3 , 9 ] ; let N = A . length ; document . write ( minimumMoves ( A , N ) ) ;
function series ( n , d ) { if ( d == 0 ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( " " ) ; document . write ( ) ; return ; } if ( n % 2 == 0 ) { for ( let i = 1 ; i <= n ; i ++ ) { document . write ( Math . pow ( - 1 , i ) * d + " " ) ; } document . write ( ) ; } else { let m = n ; let r = ( m / ( m - 1 ) ) ; let g = ( d * ( Math . sqrt ( r ) ) ) ; document . write ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { document . write ( Math . pow ( - 1 , i ) * g + " " ) ; } document . write ( ) ; } } let n = 3 , d = 3 ; series ( n , d ) ;
function countDigitOne ( n ) { let countr = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let str = i . toString ( ) ; countr += str . split ( " " ) . length - 1 ; } return countr ; } let n = 13 ; document . write ( countDigitOne ( n ) + " " ) ; n = 131 ; document . write ( countDigitOne ( n ) + " " ) ; n = 159 ; document . write ( countDigitOne ( n ) + " " ) ;
function factorial ( x ) { if ( x <= 1 ) return 1 ; var res = 2 ; for ( i = 3 ; i <= x ; i ++ ) res = res * i ; return res ; } function gcdOfFactorial ( m , n ) { var min = m < n ? m : n ; return factorial ( min ) ; } var m = 5 , n = 9 ; document . write ( gcdOfFactorial ( m , n ) ) ;
function recDigSum ( n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } } function check ( n ) { n = recDigSum ( n ) ; if ( n == 2 n == 3 n == 5 n == 7 ) document . write ( " " ) ; else document . write ( " " ) ; } let n = 5602 ; check ( n ) ;
function findNumber ( n ) { let x = Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; let base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; } let n = 55 ; document . write ( findNumber ( n ) ) ;
function weightedMean ( n ) { return parseInt ( ( 2 * n + 1 ) / 3 , 10 ) ; } let n = 10 ; document . write ( weightedMean ( n ) ) ;
function calculate ( a , b , n , m ) { let mul = 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = Math . floor ( a [ i ] / mul ) ; document . write ( x + " " ) ; } } let a = [ 5 , 100 , 8 ] ; let b = [ 2 , 3 ] ; let n = a . length ; let m = b . length ; calculate ( a , b , n , m ) ;
function print ( n ) { document . write ( n + parseInt ( n / 2 ) + " " ) ; for ( i = 2 ; i <= n ; i += 2 ) document . write ( i + " " ) ; for ( i = 1 ; i <= n ; i += 2 ) document . write ( i + " " ) ; for ( i = 2 ; i <= n ; i += 2 ) document . write ( i + " " ) ; } var n = 3 ; print ( n ) ;
function lcm_fun ( a , b ) { if ( b == 0 ) return a ; return lcm_fun ( b , a % b ) ; } function digitLCM ( n ) { let lcm = 1 ; while ( n > 0 ) { lcm = ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ; if ( lcm == 0 ) return 0 ; n = parseInt ( n / 10 ) ; } return lcm ; } let n = 397 ; document . write ( digitLCM ( n ) ) ;
function u_cal ( u , n ) { var temp = u ; for ( var i = 1 ; i < n ; i ++ ) temp = temp * ( u + i ) ; return temp ; } function fact ( n ) { var f = 1 ; for ( var i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } var n = 5 ; var x = [ 1891 , 1901 , 1911 , 1921 , 1931 ] ; var y = Array ( n ) . fill ( 0.0 ) . map ( x => Array ( n ) . fill ( 0.0 ) ) ; y [ 0 ] [ 0 ] = 46 ; y [ 1 ] [ 0 ] = 66 ; y [ 2 ] [ 0 ] = 81 ; y [ 3 ] [ 0 ] = 93 ; y [ 4 ] [ 0 ] = 101 ; for ( var i = 1 ; i < n ; i ++ ) { for ( var j = n - 1 ; j >= i ; j -- ) y [ j ] [ i ] = y [ j ] [ i - 1 ] - y [ j - 1 ] [ i - 1 ] ; } for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) document . write ( y [ i ] [ j ] + " " ) ; document . write ( ' ' ) ; ; } var value = 1925 ; var sum = y [ n - 1 ] [ 0 ] ; var u = ( value - x [ n - 1 ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { sum = sum + ( u_cal ( u , i ) * y [ n - 1 ] [ i ] ) / fact ( i ) ; } document . write ( " " + value + " " + sum ) ;
function sumDigitSquare ( n ) { let sq = 0 ; while ( n != 0 ) { let digit = n % 10 ; sq += digit * digit ; n = parseInt ( n / 10 , 10 ) ; } return sq ; } function isHappy ( n ) { while ( true ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( n == 4 ) return false ; } } let n = 23 ; if ( isHappy ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findSumSubsets ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; } let n = 3 ; document . write ( findSumSubsets ( n ) ) ;
function findMin ( a , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; var x = parseInt ( Math . exp ( sum / n ) ) ; return x + 1 ; } var a = [ 3 , 2 , 1 , 4 ] ; var n = a . length ; document . write ( findMin ( a , n ) ) ;
function countdigits ( N ) { var count = 0 ; while ( N > 0 ) { count ++ ; N = parseInt ( N / 10 ) ; } return count ; } function cyclic ( N ) { var num = N ; var n = countdigits ( N ) ; while ( true ) { document . write ( num + " " ) ; var rem = num % 10 ; var dev = parseInt ( num / 10 ) ; num = parseInt ( ( ( Math . pow ( 10 , n - 1 ) ) * rem + dev ) ) ; if ( num == N ) break ; } } var N = 5674 ; cyclic ( N ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function checkCircular ( N ) { let count = 0 , temp = N ; while ( temp > 0 ) { count ++ ; temp = parseInt ( temp / 10 , 10 ) ; } let num = N ; while ( isPrime ( num ) ) { let rem = num % 10 ; let div = parseInt ( num / 10 , 10 ) ; num = ( ( Math . pow ( 10 , count - 1 ) ) * rem ) + div ; if ( num == N ) return true ; } return false ; } let N = 1193 ; if ( checkCircular ( N ) ) document . write ( " " ) ; else document . write ( " " ) ;
function sackRace ( p1 , s1 , p2 , s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; } let p1 = 4 , s1 = 4 , p2 = 8 , s2 = 2 ; if ( sackRace ( p1 , s1 , p2 , s2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function solve ( n ) { let a = n / 2 ; if ( n % 2 != 0 ) { document . write ( ( Math . ceil ( a ) - 1 ) + " " + ( Math . floor ( a ) + 1 ) ) ; } else { if ( parseInt ( a , 10 ) % 2 == 0 ) { document . write ( ( Math . ceil ( a ) - 1 ) + " " + ( Math . floor ( a ) + 1 ) ) ; } else { document . write ( ( Math . ceil ( a ) - 2 ) + " " + ( Math . floor ( a ) + 2 ) ) ; } } } let n = 34 ; solve ( n ) ;
let P = 1 , R = 1 , T = 1 ; let SI = ( P * T * R ) / 100 ; document . write ( " " + SI ) ;
function countDigits ( a , b ) { let count = 0 ; let p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 , 10 ) ; } return count ; } let a = 33 ; let b = - 24 ; document . write ( " " + countDigits ( a , b ) ) ;
function multiple ( a , b , x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) document . write ( " " ) ; else document . write ( " " ) ; } var mul = parseInt ( Math . pow ( a , b ) ) ; var ans = mul / x ; var ans1 = x * ans ; var ans2 = x * ( ans + 1 ) ; document . write ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; } var a = 349 , b = 1 , x = 4 ; multiple ( a , b , x ) ;
function maxSum ( n ) { if ( n == 1 ) return 1 ; else return ( parseInt ( n * ( n - 1 ) / 2 , 10 ) - 1 + parseInt ( n / 2 , 10 ) ) ; } let n = 3 ; document . write ( maxSum ( n ) ) ;
function minNum ( arr , n ) { let odd = false ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ; let n = arr . length ; document . write ( minNum ( arr , n ) ) ;
function checkJumbled ( num ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; while ( num != 0 ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; let digit1 = num % 10 ; let digit2 = parseInt ( num / 10 , 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = parseInt ( num / 10 , 10 ) ; } return true ; } let num = - 1234 ; if ( checkJumbled ( num ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; num = - 1247 ; if ( checkJumbled ( num ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function msbPos ( n ) { var pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; } function josephify ( n ) { var position = msbPos ( n ) ; var j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; } var n = 41 ; document . write ( josephify ( n ) ) ;
function countXorPair ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; } let arr = [ 1 , 2 , 3 ] ; document . write ( countXorPair ( arr , arr . length ) ) ;
function powmod ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function discreteLogarithm ( a , b , m ) { let n = ( parseInt ( Math . sqrt ( m ) , 10 ) + 1 ) ; let value = new Array ( m ) ; value . fill ( 0 ) ; for ( let i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( let j = 0 ; j < n ; ++ j ) { let cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] > 0 ) { let ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return - 1 ; } let a = 2 , b = 3 , m = 5 ; document . write ( discreteLogarithm ( a , b , m ) + " " ) ; a = 3 ; b = 7 ; m = 11 ; document . write ( discreteLogarithm ( a , b , m ) + " " ) ;
function discreteLogarithm ( a , b , m ) { let n = parseInt ( Math . sqrt ( m ) , 10 ) + 1 ; let an = 1 ; for ( let i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; let value = new Array ( m ) ; value . fill ( 0 ) ; for ( let i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( let i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { let ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; } let a = 2 , b = 3 , m = 5 ; document . write ( discreteLogarithm ( a , b , m ) + " " ) ; a = 3 ; b = 7 ; m = 11 ; document . write ( discreteLogarithm ( a , b , m ) ) ;
function nthprimedigitsnumber ( number ) { let rem ; let num = " " ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += ' ' ; break ; case 2 : num += ' ' ; break ; case 3 : num += ' ' ; break ; case 0 : num += ' ' ; break ; } if ( number % 4 == 0 ) number -- ; number = parseInt ( number / 4 , 10 ) ; } let st = num . split ( ' ' ) ; st . reverse ( ) ; return ( st . join ( " " ) ) ; } let number = 21 ; document . write ( nthprimedigitsnumber ( 10 ) + " " ) ; document . write ( nthprimedigitsnumber ( number ) ) ;
function countPairs ( N ) { let count = 0 ; for ( let i = 1 ; i <= parseInt ( Math . pow ( N , ( 1.0 / 3.0 ) ) , 10 ) ; i ++ ) { let cb = i * i * i ; let diff = N - cb ; let cbrtDiff = parseInt ( Math . pow ( diff , ( 1.0 / 3.0 ) ) , 10 ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; } for ( let i = 1 ; i <= 10 ; i ++ ) document . write ( " " + i + " " + countPairs ( i ) + " " + " " ) ;
function printEqualModNumbers ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { document . write ( " " ) ; return ; } v = new Array ( ) ; for ( i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . push ( i ) ; if ( i != d / i ) v . push ( d / i ) ; } } for ( i = 0 ; i < v . length ; i ++ ) { temp = arr [ 0 ] % v [ i ] ; j = 1 ; for ( ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) document . write ( v [ i ] + " " ) ; } } let arr = new Array ( 38 , 6 , 34 ) ; printEqualModNumbers ( arr , arr . length ) ;
function FirstDigit ( arr , n ) { let S = 0 ; for ( let i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; let fract_S = S - Math . floor ( S ) ; let ans = parseInt ( Math . pow ( 10 , fract_S ) , 10 ) ; return ans ; } let arr = [ 5 , 8 , 3 , 7 ] ; let n = arr . length ; document . write ( FirstDigit ( arr , n ) ) ;
function countDigit ( n ) { var temp = n , count = 0 ; while ( temp != 0 ) { var d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; } var n = 1012 ; document . write ( countDigit ( n ) ) ;
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var ans = 1 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 ) ; ans *= 2 ; } return ans ; } var n = 36 ; var res = makeOdd ( n ) ; document . write ( res ) ;
function closestMultiple ( n , x ) { if ( x > n ) return x ; n = n + parseInt ( x / 2 , 10 ) ; n = n - ( n % x ) ; return n ; } let n = 56287 , x = 27 ; document . write ( closestMultiple ( n , x ) ) ;
function printCubes ( a , b ) { let acrt = parseInt ( Math . pow ( a , 1 / 3 ) , 10 ) ; let bcrt = parseInt ( Math . pow ( b , 1 / 3 ) , 10 ) ; for ( let i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) document . write ( ( i * i * i ) + " " ) ; } let a = 24 ; let b = 576 ; document . write ( " " + " " + " " ) ; printCubes ( a , b ) ;
function number0f2s ( n ) { let count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = parseInt ( n / 10 , 10 ) ; } return count ; } function numberOf2sinRange ( n ) { let count = 0 ; for ( let i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; } document . write ( numberOf2sinRange ( 22 ) + " " ) ; document . write ( numberOf2sinRange ( 100 ) ) ;
function minToggle ( arr , n ) { let zero = new Array ( n + 1 ) ; zero [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } let ans = n ; for ( let i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; } let arr = [ 1 , 0 , 1 , 1 , 0 ] ; let n = arr . length ; document . write ( minToggle ( arr , n ) ) ;
function check ( str ) { let n = str . length ; if ( ( str [ n - 1 ] - ' ' ) % 2 != 0 ) return false ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 3 == 0 ) ; } let str = " " ; if ( check ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
let res = 0 ; function checkRecursive ( num , x , k , n ) { if ( x == 0 ) res ++ ; let r = Math . floor ( Math . pow ( num , 1.0 / n ) ) ; for ( let i = k + 1 ; i <= r ; i ++ ) { let a = x - Math . pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - Math . pow ( i , n ) , i , n ) ; } return res ; } function check ( x , n ) { return checkRecursive ( x , x , 0 , n ) ; } document . write ( check ( 10 , 2 ) ) ;
function reverseNum ( n ) { let rem , rev = 0 ; while ( n > 0 ) { rem = n % 10 ; rev = rev * 10 + rem ; n = parseInt ( n / 10 ) ; } return rev ; } function isPalindrom ( num ) { return num == reverseNum ( num ) ; } function nthPalindrome ( n , k ) { let num = Math . pow ( 10 , k - 1 ) ; while ( true ) { if ( isPalindrom ( num ) ) -- n ; if ( n == 0 ) break ; ++ num ; } return num ; } let n = 6 , k = 5 ; document . write ( n + " " + k + " " + nthPalindrome ( n , k ) + " " ) ; n = 10 ; k = 6 ; document . write ( n + " " + k + " " + nthPalindrome ( n , k ) ) ;
function nthPalindrome ( n , k ) { let temp = ( k & 1 ) != 0 ? parseInt ( k / 2 , 10 ) : ( parseInt ( k / 2 , 10 ) - 1 ) ; let palindrome = parseInt ( Math . pow ( 10 , temp ) , 10 ) ; palindrome += n - 1 ; document . write ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome = parseInt ( palindrome / 10 , 10 ) ; while ( palindrome > 0 ) { document . write ( palindrome % 10 ) ; palindrome = parseInt ( palindrome / 10 , 10 ) ; } document . write ( " " + " " ) ; } let n = 6 , k = 5 ; document . write ( n + " " + k + " " ) ; nthPalindrome ( n , k ) ; n = 10 ; k = 6 ; document . write ( n + " " + k + " " ) ; nthPalindrome ( n , k ) ;
function solve ( v ) { var res = [ ] ; var all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] ; res . push ( all3 - v [ 1 ] * 2 ) ; res . push ( all3 - v [ 2 ] * 2 ) ; res . push ( all3 - v [ 0 ] * 2 ) ; return res ; } function findVertex ( xmid , ymid ) { var V1 = solve ( xmid ) ; var V2 = solve ( ymid ) ; for ( var i = 0 ; i < 3 ; i ++ ) { document . write ( V1 [ i ] + " " + V2 [ i ] + " " ) ; } } var xmid = [ 5 , 4 , 5 ] ; var ymid = [ 3 , 4 , 5 ] ; findVertex ( xmid , ymid ) ;
function nthElement ( a , b , n ) { let seq = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) seq . push ( a * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . includes ( b * i ) ) { seq . push ( b * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; k -- ; } } return seq [ n - 1 ] ; } let a = 3 , b = 5 , n = 5 ; document . write ( nthElement ( a , b , n ) ) ;
function gcd ( a , b ) { return b > 0 ? gcd ( b , a % b ) : a ; } function countGCD ( L , R , g ) { L = parseInt ( ( L + g - 1 ) / g , 10 ) ; R = parseInt ( R / g , 10 ) ; let ans = 0 ; for ( let i = L ; i <= R ; i ++ ) for ( let j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; } let L = 1 , R = 11 , g = 5 ; document . write ( countGCD ( L , R , g ) ) ;
let dig = [ 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 ] ; function lastNon0Digit ( n ) { if ( n < 10 ) return dig [ n ] ; if ( ( parseInt ( n / 10 , 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; } let n = 14 ; document . write ( lastNon0Digit ( n ) ) ;
function gcd ( a , b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; } function firstFactorialDivisibleNumber ( x ) { let new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x = parseInt ( new_x / gcd ( i , new_x ) , 10 ) ; if ( new_x == 1 ) break ; } return i ; } let x = 16 ; document . write ( firstFactorialDivisibleNumber ( x ) ) ;
function sieve ( prime , n ) { for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } function maxDigitInPrimes ( L , R ) { let prime = new Array ( R + 1 ) ; for ( let i = 0 ; i < R + 1 ; i ++ ) { prime [ i ] = false ; } sieve ( prime , R ) ; let freq = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } let val ; for ( let i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) { while ( p > 0 ) { freq [ p % 10 ] ++ ; p = Math . floor ( p / 10 ) ; } } } let max = freq [ 0 ] , ans = 0 ; for ( let j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ans ; } let L = 1 , R = 20 ; document . write ( maxDigitInPrimes ( L , R ) ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function commDiv ( a , b ) { let n = gcd ( a , b ) ; let result = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) result += 1 ; else result += 2 ; } } return result ; } let a = 12 , b = 24 ; document . write ( commDiv ( a , b ) ) ;
function spellsCount ( num ) { let n = num . length ; let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * Math . pow ( 2 , count - 1 ) ; } return result ; } let num = " " ; document . write ( spellsCount ( num ) ) ;
function numSquareSum ( n ) { var squareSum = 0 ; while ( n != 0 ) { squareSum += ( n % 10 ) * ( n % 10 ) ; n = parseInt ( n / 10 ) ; } return squareSum ; } function isHappynumber ( n ) { var slow , fast ; slow = fast = n ; do { slow = numSquareSum ( slow ) ; fast = numSquareSum ( numSquareSum ( fast ) ) ; } while ( slow != fast ) ; return ( slow == 1 ) ; } var n = 13 ; if ( isHappynumber ( n ) ) document . write ( n + " " ) ; else document . write ( n + " " ) ;
let allPrimes = [ ] ; function sieve ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push ( p ) ; } function factorialDivisors ( n ) { let result = 1 ; for ( let i = 0 ; i < allPrimes . length ; i ++ ) { let p = allPrimes [ i ] ; let exp = 0 ; while ( p <= n ) { exp = exp + parseInt ( n / p , 10 ) ; p = p * allPrimes [ i ] ; } result = result * ( exp + 1 ) ; } return result ; } document . write ( factorialDivisors ( 6 ) ) ;
function nonFibonacci ( n ) { let prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; } document . write ( nonFibonacci ( 5 ) ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; let k ; for ( k = 0 ; ( ( a b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { let t = a ; a = b ; b = t ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; } let a = 34 , b = 17 ; document . write ( " " + gcd ( a , b ) ) ;
function findNDigitNumsUtil ( n , out , index , evenSum , oddSum ) { if ( index > n ) return ; if ( index == n ) { if ( Math . abs ( evenSum - oddSum ) == 1 ) { out [ index ] = ' ' ; for ( let i = 0 ; i < out . length ; i ++ ) { document . write ( out [ i ] ) ; } document . write ( " " ) ; } return ; } if ( index % 2 != 0 ) { for ( let i = 0 ; i <= 9 ; i ++ ) { out [ index ] = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum , oddSum + i ) ; } } { for ( let i = 0 ; i <= 9 ; i ++ ) { out [ index ] = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } } } function findNDigitNums ( n ) { let out = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { out [ i ] = 0 ; } let index = 0 ; let evenSum = 0 , oddSum = 0 ; for ( let i = 1 ; i <= 9 ; i ++ ) { out [ index ] = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } } let n = 3 ; findNDigitNums ( n ) ;
var one = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; var ten = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; function numToWords ( n , s ) { var str = " " ; if ( n > 19 ) { str += ten [ parseInt ( n / 10 ) ] + one [ n % 10 ] ; } else { str += one [ n ] ; } if ( n != 0 ) { str += s ; } return str ; } function convertToWords ( n ) { var out = " " ; out += numToWords ( parseInt ( n / 10000000 ) , " " ) ; out += numToWords ( parseInt ( ( n / 100000 ) % 100 ) , " " ) ; out += numToWords ( parseInt ( ( n / 1000 ) % 100 ) , " " ) ; out += numToWords ( parseInt ( ( n / 100 ) % 10 ) , " " ) ; if ( n > 100 && n % 100 > 0 ) { out += " " ; } out += numToWords ( parseInt ( n % 100 ) , " " ) ; return out ; } var n = 438237764 ; document . write ( convertToWords ( n ) ) ;
function gcd ( a , b ) { return ( a % b == 0 ) ? Math . abs ( b ) : gcd ( b , a % b ) ; } function isPossible ( a , b , c ) { return ( c % gcd ( a , b ) == 0 ) ; } let a = 3 , b = 6 , c = 9 ; if ( isPossible ( a , b , c ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; a = 3 ; b = 6 ; c = 8 ; if ( isPossible ( a , b , c ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; a = 2 ; b = 5 ; c = 1 ; if ( isPossible ( a , b , c ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function farey ( n ) { var x1 = 0 , y1 = 1 , x2 = 1 , y2 = n ; document . write ( x1 + " " + y1 + " " + x2 + " " + y2 + " " ) ; while ( y != 1.0 ) { x = Math . floor ( ( y1 + n ) / y2 ) * x2 - x1 ; y = Math . floor ( ( y1 + n ) / y2 ) * y2 - y1 ; document . write ( x + " " + y + " " ) ; x1 = x2 ; x2 = x ; y1 = y2 ; y2 = y ; } } var n = 7 ; document . write ( " " + n + " " ) ; farey ( n ) ;
function gcd ( a , b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; } function findSmallest ( a , b ) { let lcm = parseInt ( ( a * b ) / gcd ( a , b ) , 10 ) ; document . write ( " " + parseInt ( lcm / a , 10 ) + " " + parseInt ( lcm / b , 10 ) ) ; } let a = 25 , b = 35 ; findSmallest ( a , b ) ;
function power ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function modInverse ( a , p ) { return power ( a , p - 2 , p ) ; } function modFact ( n , p ) { if ( p <= n ) return 0 ; let res = ( p - 1 ) ; for ( let i = n + 1 ; i < p ; i ++ ) res = ( res * modInverse ( i , p ) ) % p ; return res ; } let n = 25 , p = 29 ; document . write ( modFact ( n , p ) ) ;
function countWays ( n ) { for ( let i = 1 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) for ( let k = j ; k < n ; k ++ ) for ( let l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; } let n = 8 ; document . write ( countWays ( n ) ) ;
function pairAndSum ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; } let arr = [ 5 , 10 , 15 ] ; let n = arr . length ; document . write ( pairAndSum ( arr , n ) ) ;
function pairAndSum ( arr , n ) { for ( let i = 0 ; i < 32 ; i ++ ) { let k = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) k ++ ; } ans += ( 1 << i ) * ( k * ( k - 1 ) / 2 ) ; } return ans ; } let arr = [ 5 , 10 , 15 ] ; let n = arr . length ; document . write ( pairAndSum ( arr , n ) ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } isPrime ( 11 ) ? document . write ( " " + " " ) : document . write ( " " + " " ) ; isPrime ( 15 ) ? document . write ( " " + " " ) : document . write ( " " + " " ) ;
function computeTotient ( n ) { let phi = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( let p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( let i = 2 * p ; i <= n ; i += p ) { phi [ i ] = parseInt ( phi [ i ] / p , 10 ) * ( p - 1 ) ; } } } for ( let i = 1 ; i <= n ; i ++ ) document . write ( " " + i + " " + phi [ i ] + " " ) ; } let n = 12 ; computeTotient ( n ) ;
function sumBetweenTwoKth ( arr , k1 , k2 ) { arr . sort ( function ( a , b ) { return a - b } ) ; var result = 0 ; for ( var i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; } var arr = [ 20 , 8 , 22 , 4 , 12 , 10 , 14 ] ; var k1 = 3 , k2 = 6 ; var n = arr . length ; document . write ( sumBetweenTwoKth ( arr , k1 , k2 ) ) ;
function countSquares ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } let n = 4 ; document . write ( " " + countSquares ( n ) ) ;
function nthMagicNo ( n ) { let pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; } let n = 5 ; document . write ( " " + " " + nthMagicNo ( n ) ) ;
function countOfMultiples ( n ) { return ( parseInt ( n / 3 , 10 ) + parseInt ( n / 5 , 10 ) - parseInt ( n / 15 , 10 ) ) ; } document . write ( countOfMultiples ( 6 ) + " " ) ; document . write ( countOfMultiples ( 16 ) + " " ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } let a = 98 , b = 56 ; document . write ( " " + a + " " + b + " " + gcd ( a , b ) ) ;
function isDefeat ( s1 , s2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else { return true ; } } return false ; } let s1 = ( " " ) ; let s2 = ( " " ) ; let n = 10 ; if ( isDefeat ( s1 , s2 , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
var N = 3 , M = 3 ; function check ( a , b ) { for ( i = 1 ; i < N ; i ++ ) { for ( j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { a [ i ] [ j ] ^= 1 ; a [ 0 ] [ 0 ] ^= 1 ; a [ 0 ] [ j ] ^= 1 ; a [ i ] [ 0 ] ^= 1 ; } } } for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) return false ; } } return true ; } var a = [ [ 0 , 1 , 0 ] , [ 0 , 1 , 0 ] , [ 1 , 0 , 0 ] ] ; var b = [ [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] ] ; if ( check ( a , b ) ) document . write ( " " ) ; else document . write ( " " ) ;
function FindIndexKthBit ( n , k ) { let cnt = 0 ; let ind = 0 ; while ( n > 0 ) { if ( n & 1 > 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; } let n = 15 , k = 3 ; let ans = FindIndexKthBit ( n , k ) ; if ( ans != - 1 ) document . write ( ans ) ; else document . write ( " " ) ;
function minDistance ( n1 , n2 ) { var bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; var bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; var bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; var maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } var xorValue = n1 ^ n2 ; var bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; } var disSimilarBitPosition = maxBitCount - bitCountXorValue ; var result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; } var n1 = 12 , n2 = 5 ; document . write ( minDistance ( n1 , n2 ) ) ;
function printMaxAfterRemoval ( s ) { let flag = false ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' && flag == false ) { flag = true ; continue ; } else document . write ( s [ i ] ) ; } return 0 ; } let s = " " ; printMaxAfterRemoval ( s ) ;
function bitPos ( n1 , n2 ) { if ( n1 == n2 ) return 0 ; let bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; let bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; let bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; let maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } let xorValue = n1 ^ n2 ; let bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; let disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; } let n1 = 53 , n2 = 55 ; document . write ( bitPos ( n1 , n2 ) ) ;
function countOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; let evenPairCount = parseInt ( count * ( count - 1 ) / 2 ) ; let totPairs = parseInt ( N * ( N - 1 ) / 2 ) ; return totPairs - evenPairCount ; } let A = [ 5 , 6 , 2 , 8 ] ; let N = A . length ; document . write ( countOddPair ( A , N ) ) ;
function ReplaceElements ( arr , n ) { if ( n <= 1 ) return ; let prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; } let arr = [ 2 , 3 , 4 , 5 , 6 ] ; let n = arr . length ; ReplaceElements ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ;
function OR ( a , n ) { var ans = a [ 0 ] ; for ( var i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; } var a = [ 1 , 4 , 6 ] ; var n = a . length ; document . write ( OR ( a , n ) ) ;
function bit ( n ) { let count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; } function maxSumOfBits ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } let incl = arr [ 0 ] ; let excl = 0 ; let excl_new ; for ( let i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } let arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] ; let n = arr . length ; document . write ( maxSumOfBits ( arr , n ) ) ;
function increment ( i ) { let i1 = - ( ~ ( i ) . charCodeAt ( ) ) ; return String . fromCharCode ( i1 ) ; } let n = ' ' ; document . write ( increment ( n ) ) ;
function findOddPair ( A , N ) { let i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; } let a = [ 5 , 4 , 7 , 2 , 1 ] ; let n = a . length ; document . write ( findOddPair ( a , n ) ) ;
function MSBPosition ( N ) { let msb_p = - 1 ; while ( N > 0 ) { N = N >> 1 ; msb_p ++ ; } return msb_p ; } function findBitwiseOR ( L , R ) { let res = 0 ; let msb_p1 = MSBPosition ( L ) ; let msb_p2 = MSBPosition ( R ) ; while ( msb_p1 == msb_p2 ) { let res_val = ( 1 << msb_p1 ) ; res += res_val ; L -= res_val ; R -= res_val ; msb_p1 = MSBPosition ( L ) ; msb_p2 = MSBPosition ( R ) ; } msb_p1 = Math . max ( msb_p1 , msb_p2 ) ; for ( let i = msb_p1 ; i >= 0 ; i -- ) { let res_val = ( 1 << i ) ; res += res_val ; } return res ; } let L = 12 , R = 18 ; document . write ( findBitwiseOR ( L , R ) ) ;
function maxOR ( arr , n , k , x ) { let preSum = new Array ( n + 1 ) ; let suffSum = new Array ( n + 1 ) ; let res = 0 , pow = 1 ; for ( let i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; } let arr = [ 1 , 2 , 4 , 8 ] ; let n = 4 ; let k = 2 , x = 3 ; let ans = maxOR ( arr , n , k , x ) ; document . write ( ans ) ;
function turnOnK ( n , k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; } let n = 4 ; let k = 2 ; document . write ( turnOnK ( n , k ) ) ;
function minSum ( a , n ) { a . sort ( ) ; let num1 = 0 ; let num2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; } let arr = [ 5 , 3 , 0 , 7 , 4 ] ; let n = arr . length ; document . write ( " " + minSum ( arr , n ) ) ;
function printKthBit ( n , k ) { document . write ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; } var n = 13 , k = 2 ; printKthBit ( n , k ) ;
function countSetBits ( n ) { let count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } function countOfOddsPascal ( n ) { let c = countSetBits ( n ) ; return Math . pow ( 2 , c ) ; } let n = 20 ; document . write ( countOfOddsPascal ( n ) ) ;
function ansQueries ( prefeven , prefodd , l , r ) { if ( ( r - l + 1 ) % 2 == 0 ) document . write ( " " ) ; else { if ( l % 2 == 0 ) document . write ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ; else document . write ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; } document . write ( " " ) ; } function wrapper ( arr , n , l , r , q ) { let prefodd = [ ] ; let prefeven = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } let i = 0 ; while ( i != q ) { ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) ; i ++ ; } } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let n = arr . length ; let l = [ 1 , 1 , 2 ] ; let r = [ 2 , 3 , 4 ] ; let q = l . length ; wrapper ( arr , n , l , r , q ) ;
function solve ( p , n ) { let G = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; else G ^= ( p [ i ] - 1 ) ; } return G ; } let n = 3 ; let p = [ 32 , 49 , 58 ] ; let res = solve ( p , n ) ; if ( res == 0 ) document . write ( " " ) ; else document . write ( " " ) ;
function checkBit ( pattern , arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; } function maxAND ( arr , n ) { let res = 0 , count ; for ( let bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } return res ; } let arr = [ 4 , 8 , 6 , 2 ] ; let n = arr . length ; document . write ( " " + maxAND ( arr , n ) ) ;
function checkPowerof8 ( n ) { let i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; } let n = 65 ; if ( checkPowerof8 ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
var longSize = 8 ; var ULL_SIZE = 8 * longSize ; function bit_anagram_check ( a ) { var ans = a . toString ( 2 ) . split ( ' ' ) . join ( ' ' ) . length == ( ULL_SIZE >> 1 ) ? 1 : 0 ; return ans ; } var a = 4294967295 ; document . write ( bit_anagram_check ( a ) ) ;
function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; 1 << i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { let num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; } let n = 10 ; document . write ( findSum ( n ) ) ;
function posOfRightMostDiffBit ( m , n ) { return parseInt ( Math . floor ( Math . log10 ( Math . pow ( m ^ n , 2 ) ) ) , 10 ) + 2 ; } let m = 52 , n = 4 ; document . write ( " " + posOfRightMostDiffBit ( m , n ) ) ;
function setKthBit ( n , k ) { return ( ( 1 << k ) n ) ; } let n = 10 , k = 2 ; document . write ( " " + setKthBit ( n , k ) ) ;
function reversearray ( arr , n ) { let x = parseInt ( - 2147483648 / 2147483647 , 10 ) ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) { let temp = arr [ i ] ; arr [ i ] = arr [ n + ( x * i ) + x ] ; arr [ n + ( x * i ) + x ] = temp ; } } let arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] ; let n = arr . length ; reversearray ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ;
function reverseArray ( arr , n ) { for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) { swap ( arr , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) ; } } function swap ( arr , i , j ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } let arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] ; let n = arr . length ; reverseArray ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + " " ) ; }
function maxXORInRange ( L , R ) { let LXR = L ^ R ; let msbPos = 0 ; while ( LXR > 0 ) { msbPos ++ ; LXR >>= 1 ; } let maxXOR = 0 ; let two = 1 ; while ( msbPos -- > 0 ) { maxXOR += two ; two <<= 1 ; } return maxXOR ; } let L = 8 ; let R = 20 ; document . write ( maxXORInRange ( L , R ) ) ;
function CountZeroBit ( n ) { let count = 0 ; while ( n > 0 ) { if ( n % 2 != 0 ) count ++ ; n >>= 1 ; } return count ; } function CountORandSumEqual ( N ) { let count = CountZeroBit ( N ) ; return ( 1 << count ) ; } let N = 10 ; document . write ( CountORandSumEqual ( N ) ) ;
function countNumbers ( n ) { let k = 0 ; let count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; } let n = 11 ; document . write ( countNumbers ( n ) ) ;
function isMultipleOf4 ( n ) { if ( n == 1 ) return false ; let XOR = 0 ; for ( let i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; } for ( let n = 0 ; n <= 42 ; n ++ ) document . write ( isMultipleOf4 ( n ) ? n : " " ) ;
function isMultipleOf4 ( n ) { if ( n == 0 ) return true ; return ( ( ( n >> 2 ) << 2 ) == n ) ; } for ( let n = 0 ; n <= 42 ; n ++ ) if ( isMultipleOf4 ( n ) ) document . write ( n + " " ) ;
function countSetBits ( x ) { let count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; } function ceilLog2 ( x ) { let count = 0 ; x -- ; while ( x > 0 ) { x = x >> 1 ; count ++ ; } return count ; } function isBleak ( n ) { for ( let x = n - ceilLog2 ( n ) ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; } if ( isBleak ( 3 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; if ( isBleak ( 4 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function countStrings ( n ) { let a = [ ] , b = [ ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; } document . write ( countStrings ( 5 ) ) ;
let N = 3 ; let M = 4 ; function printDistance ( mat ) { let ans = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { ans [ i ] = new Array ( M ) ; for ( let j = 0 ; j < M ; j ++ ) { ans [ i ] [ j ] = Number . MAX_VALUE ; } } for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < M ; j ++ ) { for ( let k = 0 ; k < N ; k ++ ) for ( let l = 0 ; l < M ; l ++ ) { if ( mat [ k ] [ l ] == 1 ) ans [ i ] [ j ] = Math . min ( ans [ i ] [ j ] , Math . abs ( i - k ) + Math . abs ( j - l ) ) ; } } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) document . write ( ans [ i ] [ j ] + " " ) ; document . write ( " " ) ; } } let mat = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 1 , 1 , 0 ] ] printDistance ( mat ) ;
function mostFrequent ( arr , n ) { arr . sort ( ) ; let max_count = 1 , res = arr [ 0 ] ; let curr_count = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count > max_count ) { max_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } let arr = [ 1 , 5 , 2 , 1 , 3 , 2 , 1 ] ; let n = arr . length ; document . write ( mostFrequent ( arr , n ) ) ;
function aredisjoint ( set1 , set2 ) { for ( let i = 0 ; i < set1 . length ; i ++ ) { for ( let j = 0 ; j < set2 . length ; j ++ ) { if ( set1 [ i ] == set2 [ j ] ) return false ; } } return true ; } let set1 = [ 12 , 34 , 11 , 9 , 3 ] ; let set2 = [ 7 , 2 , 1 , 5 ] ; result = aredisjoint ( set1 , set2 ) ; if ( result ) document . write ( " " ) ; else document . write ( " " ) ;
function findMissing ( a , b , n , m ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < m ; j ++ ) if ( a [ i ] == b [ j ] ) break ; if ( j == m ) document . write ( a [ i ] + " " ) ; } } let a = [ 1 , 2 , 6 , 3 , 4 , 5 ] ; let b = [ 2 , 4 , 3 , 1 , 0 ] ; let n = a . length ; let m = b . length ; findMissing ( a , b , n , m ) ;
function areEqual ( arr1 , arr2 ) { let n = arr1 . length ; let m = arr2 . length ; if ( n != m ) return false ; arr1 . sort ( ) ; arr2 . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return false ; return true ; } let arr1 = [ 3 , 5 , 2 , 5 , 2 ] ; let arr2 = [ 2 , 3 , 5 , 5 , 2 ] ; if ( areEqual ( arr1 , arr2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isProduct ( arr , n , x ) { for ( var i = 0 ; i < n - 1 ; i ++ ) for ( var j = i + 1 ; i < n ; i ++ ) if ( arr [ i ] * arr [ j ] == x ) return true ; return false ; } var arr = [ 10 , 20 , 9 , 40 ] ; var x = 400 ; var n = arr . length ; isProduct ( arr , n , x ) ? document . write ( " " ) : document . write ( " " ) ; x = 190 ; isProduct ( arr , n , x ) ? document . write ( " " ) : document . write ( " " ) ;
function findGreatest ( arr , n ) { let result = - 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ j ] * arr [ k ] == arr [ i ] ) result = Math . max ( result , arr [ i ] ) ; return result ; } let arr = [ 30 , 10 , 9 , 3 , 35 ] ; let n = arr . length ; document . write ( findGreatest ( arr , n ) ) ;
function getPairsCount ( arr , n , sum ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) count ++ ; return count ; } let arr = [ 1 , 5 , 7 , - 1 , 5 ] ; let n = arr . length ; let sum = 6 ; document . write ( " " + getPairsCount ( arr , n , sum ) ) ;
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( arr1 [ i ] + arr2 [ j ] ) == x ) count ++ ; return count ; } let arr1 = [ 1 , 3 , 5 , 7 ] ; let arr2 = [ 2 , 3 , 5 , 8 ] ; let m = arr1 . length ; let n = arr2 . length ; let x = 10 ; document . write ( " " + countPairs ( arr1 , arr2 , m , n , x ) ) ;
function isPresent ( arr , low , high , value ) { while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( arr [ mid ] == value ) return true ; else if ( arr [ mid ] > value ) high = mid - 1 ; else low = mid + 1 ; } return false ; } function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) { let value = x - arr1 [ i ] ; if ( isPresent ( arr2 , 0 , n - 1 , value ) ) count ++ ; } return count ; } let arr1 = [ 1 , 3 , 5 , 7 ] ; let arr2 = [ 2 , 3 , 5 , 8 ] ; let m = arr1 . length ; let n = arr2 . length ; let x = 10 ; document . write ( " " + countPairs ( arr1 , arr2 , m , n , x ) ) ;
function countPairs ( arr1 , arr2 , m , n , x ) { let count = 0 ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) { l ++ ; r -- ; count ++ ; } else if ( ( arr1 [ l ] + arr2 [ r ] ) < x ) l ++ ; else r -- ; } return count ; } let arr1 = [ 1 , 3 , 5 , 7 ] ; let arr2 = [ 2 , 3 , 5 , 8 ] ; let m = arr1 . length ; let n = arr2 . length ; let x = 10 ; document . write ( " " + countPairs ( arr1 , arr2 , m , n , x ) ) ;
function countPairs ( arr , n ) { var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { var product = arr [ i ] * arr [ j ] ; for ( k = 0 ; k < n ; k ++ ) { if ( arr [ k ] == product ) { result ++ ; break ; } } } } return result ; } var arr = [ 6 , 2 , 4 , 12 , 5 , 3 ] ; var n = arr . length ; document . write ( countPairs ( arr , n ) ) ;
function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } let n = 9 ; document . write ( fib ( n ) ) ;
function factTR ( n , a ) { if ( n == 0 ) return a ; return factTR ( n - 1 , n * a ) ; } function fact ( n ) { return factTR ( n , 1 ) ; } document . write ( fact ( 5 ) ) ;
function findPairs ( arr1 , arr2 , n , m , x ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( arr1 [ i ] + arr2 [ j ] == x ) document . write ( arr1 [ i ] + " " + arr2 [ j ] + " " ) ; } let arr1 = [ 1 , 2 , 3 , 7 , 5 , 4 ] ; let arr2 = [ 0 , 7 , 4 , 3 , 2 , 1 ] ; let n = arr1 . length ; let m = arr2 . length ; let x = 8 ; findPairs ( arr1 , arr2 , n , m , x ) ;
function findPair ( arr , n ) { let found = false ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = 0 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] == arr [ k ] ) { document . write ( arr [ i ] + " " + arr [ j ] + " " ) ; found = true ; } } } } if ( found == false ) document . write ( " " ) ; } let arr = [ 10 , 4 , 8 , 13 , 5 ] ; let n = arr . length ; findPair ( arr , n ) ;
function printPairs ( arr , n , k ) { let isPairFound = true ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j && arr [ i ] % arr [ j ] == k ) { document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; isPairFound = true ; } } } return isPairFound ; } let arr = [ 2 , 3 , 5 , 4 , 7 ] ; let k = 3 ; if ( printPairs ( arr , arr . length , k ) == false ) document . write ( " " ) ;
let ASCII_SIZE = 256 ; function getMaxOccuringChar ( str ) { let count = new Array ( ASCII_SIZE ) ; for ( let i = 0 ; i < ASCII_SIZE ; i ++ ) { count [ i ] = 0 ; } let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { count [ str [ i ] . charCodeAt ( 0 ) ] += 1 ; } let max = - 1 ; let result = ' ' ; for ( let i = 0 ; i < len ; i ++ ) { if ( max < count [ str [ i ] . charCodeAt ( 0 ) ] ) { max = count [ str [ i ] . charCodeAt ( 0 ) ] ; result = str [ i ] ; } } return result ; } let str = " " ; document . write ( " " , getMaxOccuringChar ( str ) ) ;
function findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) { for ( var i = 0 ; i < n1 ; i ++ ) for ( var j = 0 ; j < n2 ; j ++ ) for ( var k = 0 ; k < n3 ; k ++ ) if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) return true ; return false ; } var a1 = [ 1 , 2 , 3 , 4 , 5 ] ; var a2 = [ 2 , 3 , 6 , 1 , 2 ] ; var a3 = [ 3 , 2 , 4 , 5 , 6 ] ; var sum = 9 ; var n1 = a1 . length ; var n2 = a2 . length ; var n3 = a3 . length ; findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) ? document . write ( " " ) : document . write ( " " ) ;
function minInsertion ( str ) { let n = str . length ; let res = 0 ; let count = new Array ( 26 ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) count [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( count [ i ] % 2 == 1 ) res ++ ; } return ( res == 0 ) ? 0 : res - 1 ; } let str = " " ; document . write ( minInsertion ( str ) ) ;
function findDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let count = 0 , max_count = 0 , min_count = n ; for ( let i = 0 ; i < ( n - 1 ) ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) { count += 1 ; continue ; } else { max_count = Math . max ( max_count , count ) ; min_count = Math . min ( min_count , count ) ; count = 0 ; } } return ( max_count - min_count ) ; } let arr = [ 7 , 8 , 4 , 5 , 4 , 1 , 1 , 7 , 7 , 2 , 5 ] ; let n = arr . length ; document . write ( findDiff ( arr , n ) ) ;
function maxDiff ( arr , n ) { let SubsetSum_1 = 0 , SubsetSum_2 = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let isSingleOccurance = true ; for ( let j = i + 1 ; j <= n - 1 ; j ++ ) { if ( arr [ i ] == arr [ j ] ) { isSingleOccurance = false ; arr [ i ] = arr [ j ] = 0 ; break ; } } if ( isSingleOccurance ) { if ( arr [ i ] > 0 ) SubsetSum_1 += arr [ i ] ; else SubsetSum_2 += arr [ i ] ; } } return Math . abs ( SubsetSum_1 - SubsetSum_2 ) ; } let arr = [ 4 , 2 , - 3 , 3 , - 2 , - 2 , 8 ] ; let n = arr . length ; document . write ( " " + maxDiff ( arr , n ) ) ;
function maxDiff ( arr , n ) { var result = 0 ; arr . sort ( ( a , b ) => a - b ) for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] != arr [ i + 1 ] ) result += Math . abs ( arr [ i ] ) ; else i ++ ; } if ( arr [ n - 2 ] != arr [ n - 1 ] ) result += Math . abs ( arr [ n - 1 ] ) ; return result ; } var arr = [ 4 , 2 , - 3 , 3 , - 2 , - 2 , 8 ] ; var n = arr . length ; document . write ( " " + maxDiff ( arr , n ) ) ;
function printAllAPTriplets ( arr , n ) { const s = new Set ( ) for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let diff = arr [ j ] - arr [ i ] ; if ( s . has ( arr [ i ] - diff ) ) document . write ( arr [ i ] - diff + " " + arr [ i ] + " " + arr [ j ] + " " ) ; } s . add ( arr [ i ] ) ; } } let arr = [ 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ] ; let n = arr . length ; printAllAPTriplets ( arr , n ) ;
function printAllAPTriplets ( arr , n ) { for ( let i = 1 ; i < n - 1 ; i ++ ) { for ( let j = i - 1 , k = i + 1 ; j >= 0 && k < n ; ) { if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) { document . write ( arr [ j ] + " " + arr [ i ] + " " + arr [ k ] + " " ) ; k ++ ; j -- ; } else if ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) k ++ ; else j -- ; } } } let arr = [ 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ] ; let n = arr . length ; printAllAPTriplets ( arr , n ) ;
/ *function countTriplets(arr,n,m) { let count = 0 ; for ( let i = 0 ; i < n - 2 ; i ++ ) for ( let j = i + 1 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] * arr [ j ] * arr [ k ] == m ) count ++ ; return count ; } let arr = [ 1 , 4 , 6 , 2 , 3 , 8 ] ; let m = 24 ; document . write ( countTriplets ( arr , arr . length , m ) ) ;
function countPairs ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] == arr [ j ] ) ans ++ ; return ans ; } let arr = [ 1 , 1 , 2 ] ; let n = arr . length ; document . write ( countPairs ( arr , n ) ) ;
function preCalculate ( binary , n , left ) { let count1 = 0 , count0 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { left [ i ] [ 0 ] = count1 ; left [ i ] [ 1 ] = count0 ; if ( binary [ i ] != 0 ) count1 ++ ; else count0 ++ ; } } let binary = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] ; let n = binary . length ; let left = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) left [ i ] = [ 0 , 0 ] ; preCalculate ( binary , n , left ) ; let queries = [ 0 , 1 , 2 , 4 ] ; let q = queries . length ; for ( let i = 0 ; i < q ; i ++ ) document . write ( left [ queries [ i ] ] [ 0 ] + " " + left [ queries [ i ] ] [ 1 ] + " " ) ;
let pos1 = - 1 ; let pos2 = - 1 ; function equiSumUtil ( arr ) { let n = arr . length ; let pre = new Array ( n ) ; let sum = 0 , i ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; pre [ i ] = sum ; } let suf = new Array ( n ) ; sum = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { sum += arr [ i ] ; suf [ i ] = sum ; } let total_sum = sum ; let j = n - 1 ; i = 0 ; while ( i < j - 1 ) { if ( pre [ i ] == total_sum / 3 ) { pos1 = i ; } if ( suf [ j ] == total_sum / 3 ) { pos2 = j ; } if ( pos1 != - 1 && pos2 != - 1 ) { if ( suf [ pos1 + 1 ] - suf [ pos2 ] == total_sum / 3 ) { return true ; } else { return false ; } } if ( pre [ i ] < suf [ j ] ) { i ++ ; } else { j -- ; } } return false ; } function equiSum ( arr ) { let ans = equiSumUtil ( arr ) ; if ( ans ) { document . write ( " " ) ; for ( let i = 0 ; i <= pos1 ; i ++ ) { document . write ( arr [ i ] + " " ) ; } document . write ( " " ) ; document . write ( " " ) ; for ( let i = pos1 + 1 ; i < pos2 ; i ++ ) { document . write ( arr [ i ] + " " ) ; } document . write ( " " ) ; document . write ( " " ) ; for ( let i = pos2 ; i < arr . length ; i ++ ) { document . write ( arr [ i ] + " " ) ; } document . write ( " " ) ; } else { document . writeLine ( " " + " " ) ; } } let arr = [ 1 , 3 , 6 , 2 , 7 , 1 , 2 , 8 ] ; equiSum ( arr ) ;
function getRightMin ( arr , n ) { let min = arr [ 0 ] ; let rightMin = 0 ; let i = 1 ; while ( i < n ) { if ( arr [ i ] == min ) rightMin = i ; i *= 2 ; } i = rightMin + 1 ; while ( i < n && arr [ i ] == min ) { rightMin = i ; i ++ ; } return rightMin ; } function getLeftMax ( arr , n ) { let max = arr [ n - 1 ] ; let leftMax = n - 1 ; let i = n - 2 ; while ( i > 0 ) { if ( arr [ i ] == max ) leftMax = i ; i = parseInt ( i / 2 , 10 ) ; } i = leftMax - 1 ; while ( i >= 0 && arr [ i ] == max ) { leftMax = i ; i -- ; } return leftMax ; } let arr = [ 0 , 0 , 1 , 2 , 5 , 5 , 6 , 8 , 8 ] ; let n = arr . length ; document . write ( " " + 0 + " " ) ; document . write ( " " + getRightMin ( arr , n ) + " " ) ; document . write ( " " + getLeftMax ( arr , n ) + " " ) ; document . write ( " " + ( n - 1 ) ) ;
function countNum ( arr , n ) { let count = 0 ; arr . sort ( ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i + 1 ] - 1 ) count += arr [ i + 1 ] - arr [ i ] - 1 ; return count ; } let arr = [ 3 , 5 , 8 , 6 ] ; let n = arr . length ; document . write ( countNum ( arr , n ) ) ;
function countSubarrays ( arr , n ) { let difference = 0 ; let ans = 0 ; let hash_positive = new Array ( n + 1 ) ; let hash_negative = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { hash_positive [ i ] = 0 ; hash_negative [ i ] = 0 ; } hash_positive [ 0 ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & 1 ) == 1 ) { difference ++ ; } else { difference -- ; } if ( difference < 0 ) { ans += hash_negative [ - difference ] ; hash_negative [ - difference ] ++ ; } else { ans += hash_positive [ difference ] ; hash_positive [ difference ] ++ ; } } return ans ; } let arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] ; let n = arr . length ; document . write ( " " + " " + countSubarrays ( arr , n ) ) ;
function search ( mat , m , n , x ) { var i = m - 1 , j = 0 ; while ( i >= 0 && j < n ) { if ( mat [ i ] [ j ] == x ) return true ; if ( mat [ i ] [ j ] > x ) i -- ; else j ++ ; } return false ; } var mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] , [ 50 , 60 , 70 , 80 ] ] ; if ( search ( mat , 5 , 4 , 29 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function printGreaterCount ( str ) { let len = str . length ; let right = new Array ( len ) ; right . fill ( 0 ) ; for ( let i = 0 ; i < len ; i ++ ) { for ( let j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] . charCodeAt ( ) < str [ j ] . charCodeAt ( ) ) { right [ i ] ++ ; } } } for ( let i = 0 ; i < len ; i ++ ) { document . write ( right [ i ] + " " ) ; } } let str = " " ; printGreaterCount ( str ) ;
function appearsNBy3 ( arr , n ) { let count1 = 0 , count2 = 0 ; let first = Number . MAX_VALUE ; let second = Number . MAX_VALUE ; for ( let i = 1 ; i < n ; i ++ ) { if ( first == arr [ i ] ) count1 ++ ; else if ( second == arr [ i ] ) count2 ++ ; else if ( count1 == 0 ) { count1 ++ ; first = arr [ i ] ; } else if ( count2 == 0 ) { count2 ++ ; second = arr [ i ] ; } else { count1 -- ; count2 -- ; } } count1 = 0 ; count2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == first ) count1 ++ ; else if ( arr [ i ] == second ) count2 ++ ; } if ( count1 > parseInt ( n / 3 , 10 ) ) return first ; if ( count2 > parseInt ( n / 3 , 10 ) ) return second ; return - 1 ; } let arr = [ 1 , 2 , 3 , 1 , 1 ] ; let n = arr . length ; document . write ( appearsNBy3 ( arr , n ) ) ;
function countMaxSetBits ( left , right ) { let max_count = - 1 , num = 0 ; for ( let i = left ; i <= right ; ++ i ) { let temp = i , cnt = 0 ; while ( temp > 0 ) { if ( temp % 2 == 1 ) ++ cnt ; temp >>= 1 ; } if ( cnt > max_count ) { max_count = cnt ; num = i ; } } return num ; } let l = 1 , r = 5 ; document . write ( countMaxSetBits ( l , r ) + " " ) ; l = 1 ; r = 10 ; document . write ( countMaxSetBits ( l , r ) ) ;
function recaman ( n ) { let arr = new Array ( n ) ; arr [ 0 ] = 0 ; document . write ( arr [ 0 ] + " " ) ; for ( let i = 1 ; i < n ; i ++ ) { let curr = arr [ i - 1 ] - i ; let j ; for ( j = 0 ; j < i ; j ++ ) { if ( ( arr [ j ] == curr ) curr < 0 ) { curr = arr [ i - 1 ] + i ; break ; } } arr [ i ] = curr ; document . write ( arr [ i ] + " " ) ; } } let n = 17 ; recaman ( n ) ;
function recaman ( n ) { if ( n <= 0 ) return ; document . write ( 0 + " " ) ; let s = new Set ( ) ; s . add ( 0 ) ; let prev = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let curr = prev - i ; if ( curr < 0 || s . has ( curr ) ) curr = prev + i ; s . add ( curr ) ; document . write ( curr + " " ) ; prev = curr ; } } let n = 17 ; recaman ( n ) ;
function findArea ( arr , n ) { arr . sort ( ( a , b ) => { return b - a ; } ) var dimension = [ 0 , 0 ] ; for ( var i = 0 , j = 0 ; i < n - 1 && j < 2 ; i ++ ) if ( arr [ i ] == arr [ i + 1 ] ) dimension [ j ++ ] = arr [ i ++ ] ; return ( dimension [ 0 ] * dimension [ 1 ] ) ; } var arr = [ 4 , 2 , 1 , 4 , 6 , 6 , 2 , 5 ] ; var n = arr . length ; document . write ( findArea ( arr , n ) ) ;
function pairInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) return true ; if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return false ; } let arr = [ 11 , 15 , 6 , 8 , 9 , 10 ] ; let sum = 16 ; let n = arr . length ; if ( pairInSortedRotated ( arr , n , sum ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function pairsInSortedRotated ( arr , n , x ) { let i ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] > arr [ i + 1 ] ) break ; let l = ( i + 1 ) % n ; let r = i ; let cnt = 0 ; while ( l != r ) { if ( arr [ l ] + arr [ r ] == x ) { cnt ++ ; if ( l == ( r - 1 + n ) % n ) { return cnt ; } l = ( l + 1 ) % n ; r = ( r - 1 + n ) % n ; } else if ( arr [ l ] + arr [ r ] < x ) l = ( l + 1 ) % n ; else r = ( n + r - 1 ) % n ; } return cnt ; } let arr = [ 11 , 15 , 6 , 7 , 9 , 10 ] ; let sum = 16 ; let n = arr . length ; document . write ( pairsInSortedRotated ( arr , n , sum ) ) ;
function maxSum ( arr , n ) { let arrSum = 0 ; let currVal = 0 ; for ( let i = 0 ; i < n ; i ++ ) { arrSum = arrSum + arr [ i ] ; currVal = currVal + ( i * arr [ i ] ) ; } let maxVal = currVal ; for ( let j = 1 ; j < n ; j ++ ) { currVal = currVal + arrSum - n * arr [ n - j ] ; if ( currVal > maxVal ) maxVal = currVal ; } return maxVal ; } let arr = [ 10 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ; let n = arr . length ; document . write ( " " + maxSum ( arr , n ) ) ;
function maxSum ( arr , n ) { var res = Number . MIN_VALUE ; for ( i = 0 ; i < n ; i ++ ) { var curr_sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { var index = ( i + j ) % n ; curr_sum += j * arr [ index ] ; } res = Math . max ( res , curr_sum ) ; } return res ; } var arr = [ 8 , 3 , 1 , 2 ] ; var n = arr . length ; document . write ( maxSum ( arr , n ) ) ;
function maxSum ( arr , n ) { let cum_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) cum_sum += arr [ i ] ; let curr_val = 0 ; for ( let i = 0 ; i < n ; i ++ ) curr_val += i * arr [ i ] ; let res = curr_val ; for ( let i = 1 ; i < n ; i ++ ) { let next_val = curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ; curr_val = next_val ; res = Math . max ( res , next_val ) ; } return res ; } let arr = [ 8 , 3 , 1 , 2 ] ; let n = arr . length ; document . write ( maxSum ( arr , n ) + " " ) ;
function countRotations ( arr , n ) { let min = arr [ 0 ] , min_index = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min > arr [ i ] ) { min = arr [ i ] ; min_index = i ; } } return min_index ; } let arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] ; let n = arr . length ; document . write ( countRotations ( arr , n ) ) ;
function countRotations ( arr , low , high ) { if ( high < low ) return 0 ; if ( high == low ) return low ; let mid = Math . floor ( low + ( high - low ) / 2 ) ; if ( mid < high && arr [ mid + 1 ] < arr [ mid ] ) return ( mid + 1 ) ; if ( mid > low && arr [ mid ] < arr [ mid - 1 ] ) return mid ; if ( arr [ high ] > arr [ mid ] ) return countRotations ( arr , low , mid - 1 ) ; return countRotations ( arr , mid + 1 , high ) ; } let arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] ; let n = arr . length ; document . write ( countRotations ( arr , 0 , n - 1 ) ) ;
function preprocess ( arr , n , temp ) { for ( i = 0 ; i < n ; i ++ ) temp [ i ] = temp [ i + n ] = arr [ i ] ; } function leftRotate ( arr , n , k , temp ) { var start = k % n ; for ( i = start ; i < start + n ; i ++ ) document . write ( temp [ i ] + " " ) ; document . write ( " " ) ; } var arr = [ 1 , 3 , 5 , 7 , 9 ] ; var n = arr . length ; var temp = Array ( 2 * n ) . fill ( 0 ) ; preprocess ( arr , n , temp ) ; var k = 2 ; leftRotate ( arr , n , k , temp ) ; k = 3 ; leftRotate ( arr , n , k , temp ) ; k = 4 ; leftRotate ( arr , n , k , temp ) ;
function leftRotate ( arr , n , k ) { for ( let i = k ; i < k + n ; i ++ ) document . write ( arr [ i % n ] + " " ) ; } let arr = [ 1 , 3 , 5 , 7 , 9 ] ; n = arr . length ; k = 2 ; leftRotate ( arr , n , k ) ; document . write ( " " ) ; k = 3 ; leftRotate ( arr , n , k ) ; document . write ( " " ) ; k = 4 ; leftRotate ( arr , n , k ) ; document . write ( " " ) ;
function reverseArray ( arr , start , end ) { while ( start < end ) { let temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } return arr ; } function rightRotate ( arr , d , n ) { arr = reverseArray ( arr , 0 , n - 1 ) ; arr = reverseArray ( arr , 0 , d - 1 ) ; arr = reverseArray ( arr , d , n - 1 ) ; return arr ; } function printArray ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + " " ) ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ; let n = arr . length ; let k = 3 ; arr = rightRotate ( arr , k , n ) ; printArray ( arr , n ) ;
function maxHamming ( arr , n ) { let brr = new Array ( 2 * n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) brr [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) brr [ n + i ] = arr [ i ] ; let maxHam = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let currHam = 0 ; for ( let j = i , k = 0 ; j < ( i + n ) ; j ++ , k ++ ) if ( brr [ j ] != arr [ k ] ) currHam ++ ; if ( currHam == n ) return n ; maxHam = max ( maxHam , currHam ) ; } return maxHam ; } let arr = [ 2 , 4 , 6 , 8 ] ; let n = arr . length ; document . write ( maxHamming ( arr , n ) ) ;
function leftRotate ( arr , n , k ) { let mod = k % n ; for ( let i = 0 ; i < n ; i ++ ) document . write ( ( arr [ ( mod + i ) % n ] ) + " " ) ; document . write ( " " ) ; } let arr = [ 1 , 3 , 5 , 7 , 9 ] ; let n = arr . length ; let k = 2 ; leftRotate ( arr , n , k ) ; document . write ( " " ) ; k = 3 ; leftRotate ( arr , n , k ) ; document . write ( " " ) ; k = 4 ; leftRotate ( arr , n , k ) ;
let findElement = ( arr , ranges , rotations , index ) => { for ( let i = rotations - 1 ; i >= 0 ; i -- ) { let left = ranges [ i ] [ 0 ] ; let right = ranges [ i ] [ 1 ] ; if ( left <= index && right >= index ) { if ( index == left ) index = right ; else index -- ; } } return arr [ index ] ; } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let rotations = 2 ; let ranges = [ [ 0 , 2 ] , [ 0 , 3 ] ] ; let index = 1 ; document . write ( findElement ( arr , ranges , rotations , index ) ) ;
function splitArr ( arr , n , k ) { for ( let i = 0 ; i < k ; i ++ ) { let x = arr [ 0 ] ; for ( let j = 0 ; j < n - 1 ; ++ j ) arr [ j ] = arr [ j + 1 ] ; arr [ n - 1 ] = x ; } } let arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] ; let n = arr . length ; let position = 2 ; splitArr ( arr , 6 , position ) ; for ( let i = 0 ; i < n ; ++ i ) document . write ( arr [ i ] + " " ) ;
function swap ( arr , i , j ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } function sort_shell_metzner ( arr , n ) { let i , j , k , l , m , temp ; m = n ; while ( m > 0 ) { m = Math . floor ( m / 2 ) ; k = n - m ; j = 0 ; do { i = j ; do { l = i + m ; if ( l < n && arr [ i ] > arr [ l ] ) { swap ( arr , i , l ) ; i -= m ; } else { break ; } } while ( i >= 0 ) ; j ++ ; } while ( j <= k ) ; } } function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + " " ) ; } } let arr = [ 0 , - 2 , 8 , 5 , 1 ] ; let n = arr . length ; sort_shell_metzner ( arr , n ) ; printArray ( arr , n ) ;
function rearrangeArr ( arr , n ) { let evenPos = Math . floor ( n / 2 ) ; let oddPos = n - evenPos ; let tempArr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) tempArr [ i ] = arr [ i ] ; tempArr . sort ( ) ; let j = oddPos - 1 ; for ( let i = 0 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j -- ; } j = oddPos ; for ( let i = 1 ; i < n ; i += 2 ) { arr [ i ] = tempArr [ j ] ; j ++ ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ; let size = arr . length ; rearrangeArr ( arr , size ) ;
function MaxSumDifference ( a , n ) { let finalSequence = [ ] ; a . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n / 2 ; ++ i ) { finalSequence . push ( a [ i ] ) ; finalSequence . push ( a [ n - i - 1 ] ) ; } if ( n % 2 != 0 ) finalSequence . push ( a [ Math . floor ( n / 2 ) ] ) ; let MaximumSum = 0 ; for ( let i = 0 ; i < n - 1 ; ++ i ) { MaximumSum = MaximumSum + Math . abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ; } MaximumSum = MaximumSum + Math . abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ; return MaximumSum ; } let a = [ 1 , 2 , 4 , 8 ] ; let n = a . length ; document . write ( MaxSumDifference ( a , n ) ) ;
function maxProductSubarrayOfSizeK ( A , n , k ) { A . sort ( function ( a , b ) { return a - b } ) ; let product = 1 ; let i ; if ( A [ n - 1 ] == 0 && k % 2 != 0 ) return 0 ; if ( A [ n - 1 ] <= 0 && k % 2 != 0 ) { for ( i = n - 1 ; i >= n - k ; i -- ) product *= A [ i ] ; return product ; } i = 0 ; let j = n - 1 ; if ( k % 2 != 0 ) { product *= A [ j ] ; j -- ; k -- ; } k >>= 1 ; for ( let itr = 0 ; itr < k ; itr ++ ) { let left_product = A [ i ] * A [ i + 1 ] ; let right_product = A [ j ] * A [ j - 1 ] ; if ( left_product > right_product ) { product *= left_product ; i += 2 ; } else { product *= right_product ; j -= 2 ; } } return product ; } let A = [ 1 , 2 , - 1 , - 3 , - 6 , 4 ] ; let n = A . length ; let k = 4 ; document . write ( maxProductSubarrayOfSizeK ( A , n , k ) ) ;
function reorder ( arr , index , n ) { var temp = [ ... Array ( n ) ] ; for ( var i = 0 ; i < n ; i ++ ) temp [ index [ i ] ] = arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) { arr [ i ] = temp [ i ] ; index [ i ] = i ; } } var arr = [ 50 , 40 , 70 , 60 , 90 ] ; var index = [ 3 , 0 , 4 , 1 , 2 ] ; var n = arr . length ; reorder ( arr , index , n ) ; document . write ( " " ) ; document . write ( " " ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; document . write ( " " ) ; document . write ( " " ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( index [ i ] + " " ) ;
function numofsubset ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; var count = 1 ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; } return count ; } var arr = [ 100 , 56 , 5 , 6 , 102 , 58 , 101 , 57 , 7 , 103 , 59 ] ; var n = arr . length ; document . write ( numofsubset ( arr , n ) ) ;
function gnomeSort ( arr , n ) { let index = 0 ; while ( index < n ) { if ( index == 0 ) index ++ ; if ( arr [ index ] >= arr [ index - 1 ] ) index ++ ; else { let temp = 0 ; temp = arr [ index ] ; arr [ index ] = arr [ index - 1 ] ; arr [ index - 1 ] = temp ; index -- ; } } return ; } let arr = [ 34 , 2 , 10 , - 9 ] ; gnomeSort ( arr , arr . length ) ; document . write ( " " ) ; document . write ( arr . toString ( ) ) ;
function findMaxGuests ( arrl , exit , n ) { arrl . sort ( function ( a , b ) { return a - b } ) ; exit . sort ( function ( a , b ) { return a - b } ) ; let guests_in = 1 , max_guests = 1 , time = arrl [ 0 ] ; let i = 1 , j = 0 ; while ( i < n && j < n ) { if ( arrl [ i ] <= exit [ j ] ) { guests_in ++ ; if ( guests_in > max_guests ) { max_guests = guests_in ; time = arrl [ i ] ; } i ++ ; } else { guests_in -- ; j ++ ; } } document . write ( " " + max_guests + " " + time ) ; } let arrl = [ 1 , 2 , 10 , 5 , 5 ] ; let exit = [ 4 , 5 , 12 , 9 , 12 ] ; let n = arrl . length ; findMaxGuests ( arrl , exit , n ) ;
function maxOverlap ( start , end , n ) { let maxa = 0 ; for ( let i = 0 ; i < start . length ; i ++ ) { maxa = Math . max ( maxa , start [ i ] ) ; } let maxb = 0 ; for ( let i = 0 ; i < end . length ; i ++ ) { maxb = Math . max ( maxb , end [ i ] ) ; } let maxc = Math . max ( maxa , maxb ) ; let x = new Array ( maxc + 2 ) ; x . fill ( 0 ) ; let cur = 0 , idx = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ++ x [ start [ i ] ] ; -- x [ end [ i ] + 1 ] ; } let maxy = Number . MIN_VALUE ; for ( let i = 0 ; i <= maxc ; i ++ ) { cur += x [ i ] ; if ( maxy < cur ) { maxy = cur ; idx = i ; } } document . write ( " " + maxy + " " + idx + " " ) ; } let start = [ 13 , 28 , 29 , 14 , 40 , 17 , 3 ] ; let end = [ 107 , 95 , 111 , 105 , 70 , 127 , 74 ] ; let n = start . length ; maxOverlap ( start , end , n ) ;
function rearrange ( arr , n ) { let temp = new Array ( n ) ; let small = 0 , large = n - 1 ; let flag = true ; for ( let i = 0 ; i < n ; i ++ ) { if ( flag ) temp [ i ] = arr [ large -- ] ; else temp [ i ] = arr [ small ++ ] ; flag = ! flag ; } for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; let n = arr . length ; document . write ( " " ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; rearrange ( arr , n ) ; document . write ( " " ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ;
function rearrange ( arr , n ) { let max_idx = n - 1 , min_idx = 0 ; let max_elem = arr [ n - 1 ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem ; max_idx -- ; } else { arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem ; min_idx ++ ; } } for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = Math . floor ( arr [ i ] / max_elem ) ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ; let n = arr . length ; document . write ( " " ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; rearrange ( arr , n ) ; document . write ( " " ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ;
function rearrange ( arr , n ) { let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 0 ) { if ( i != j ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } } } function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; } let arr = [ - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 ] ; let n = arr . length ; rearrange ( arr , n ) ; printArray ( arr , n ) ;
function segregateElements ( arr , n ) { let temp = new Array ( n ) ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] >= 0 ) temp [ j ++ ] = arr [ i ] ; if ( j == n j == 0 ) return ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] < 0 ) temp [ j ++ ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } let arr = [ 1 , - 1 , - 3 , - 2 , 7 , 5 , 11 , 6 ] ; let n = arr . length ; segregateElements ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ;
let rearrange = ( arr , n ) => { for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( i % 2 == 0 && arr [ i ] > arr [ i + 1 ] ) { let temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } if ( i % 2 != 0 && arr [ i ] < arr [ i + 1 ] ) { let temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } } } let printArray = ( arr , size ) => { ans = ' ' ; for ( let i = 0 ; i < size ; i ++ ) { ans += arr [ i ] + " " ; } document . write ( ans ) ; } let arr = [ 6 , 4 , 2 , 1 , 8 , 3 ] ; let n = arr . length ; document . write ( " " ) ; printArray ( arr , n ) ; rearrange ( arr , n ) ; document . write ( " " ) ; document . write ( " " ) ; printArray ( arr , n ) ;
function rearrange ( a , size ) { let positive = 0 ; let negative = 1 ; let temp ; while ( true ) { while ( positive < size && a [ positive ] >= 0 ) positive += 2 ; while ( negative < size && a [ negative ] <= 0 ) negative += 2 ; if ( positive < size && negative < size ) { temp = a [ positive ] ; a [ positive ] = a [ negative ] ; a [ negative ] = temp ; } else break ; } } let arr = [ 1 , - 3 , 5 , 6 , - 3 , 6 , 7 , - 4 , 9 , 10 ] ; let n = arr . length ; rearrange ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ;
function arrayEvenAndOdd ( arr , n ) { let i = - 1 , j = 0 ; let t ; while ( j != n ) { if ( arr [ j ] % 2 == 0 ) { i ++ ; let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } j ++ ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; } let arr = [ 1 , 3 , 2 , 4 , 7 , 6 , 9 , 10 ] ; let n = arr . length ; arrayEvenAndOdd ( arr , n ) ;
function largest ( arr ) { let i ; let max = arr [ 0 ] ; for ( i = 1 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } let arr = [ 10 , 324 , 45 , 90 , 9808 ] ; document . write ( " " + largest ( arr ) ) ;
function largest ( arr , n ) { arr . sort ( ) ; return arr [ n - 1 ] ; } let arr = [ 10 , 324 , 45 , 90 , 9808 ] ; let n = arr . length ; document . write ( largest ( arr , n ) ) ;
function findMean ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return sum / n ; } function findMedian ( a , n ) { a . sort ( ) ; if ( n % 2 != 0 ) return a [ n / 2 ] ; return ( a [ Math . floor ( ( n - 1 ) / 2 ) ] + a [ n / 2 ] ) / 2 ; } let a = [ 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ] let n = a . length ; document . write ( " " + findMean ( a , n ) + " " ) ; document . write ( " " + findMedian ( a , n ) ) ;
function printSmall ( arr , n , k ) { for ( let i = k ; i < n ; ++ i ) { let max_var = arr [ k - 1 ] ; let pos = k - 1 ; for ( let j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { let j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( let i = 0 ; i < k ; i ++ ) document . write ( arr [ i ] + " " ) ; } let arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] ; let n = 10 ; let k = 5 ; printSmall ( arr , n , k ) ;
function print2largest ( arr , arr_size ) { let i ; let largest = second = - 2454635434 ; if ( arr_size < 2 ) { document . write ( " " ) ; return ; } for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > largest ) { second = largest ; largest = arr [ i ] } else if ( arr [ i ] != largest && arr [ i ] > second ) { second = arr [ i ] ; } } if ( second == - 2454635434 ) { document . write ( " " ) ; } else { document . write ( " " + second ) ; return ; } } let arr = [ 12 , 35 , 1 , 10 , 34 , 1 ] ; let n = arr . length ; print2largest ( arr , n ) ;
function sumNodes ( l ) { let leafNodeCount = Math . pow ( 2 , l - 1 ) ; let sumLastLevel = 0 ; sumLastLevel = ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ; let sum = sumLastLevel * l ; return sum ; } let l = 3 ; document . write ( sumNodes ( l ) ) ;
function add ( arr , N , lo , hi , val ) { arr [ lo ] += val ; if ( hi != N - 1 ) arr [ hi + 1 ] -= val ; } function updateArray ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) arr [ i ] += arr [ i - 1 ] ; } function printArr ( arr , N ) { updateArray ( arr , N ) ; for ( let i = 0 ; i < N ; i ++ ) document . write ( " " + arr [ i ] + " " ) ; document . write ( " " ) ; } let N = 6 ; let arr = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { arr [ i ] = 0 ; } add ( arr , N , 0 , 2 , 100 ) ; add ( arr , N , 1 , 5 , 100 ) ; add ( arr , N , 2 , 3 , 100 ) ; printArr ( arr , N ) ;
function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } function FillPrefixSuffix ( prefix , arr , suffix , n ) { prefix [ 0 ] = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) prefix [ i ] = GCD ( prefix [ i - 1 ] , arr [ i ] ) ; suffix [ n - 1 ] = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) suffix [ i ] = GCD ( suffix [ i + 1 ] , arr [ i ] ) ; } function GCDoutsideRange ( l , r , prefix , suffix , n ) { if ( l == 0 ) return suffix [ r + 1 ] ; if ( r == n - 1 ) return prefix [ l - 1 ] ; return GCD ( prefix [ l - 1 ] , suffix [ r + 1 ] ) ; } var arr = [ 2 , 6 , 9 ] ; var n = arr . length ; var prefix = Array ( n ) . fill ( 0 ) ; var suffix = Array ( n ) . fill ( 0 ) ; FillPrefixSuffix ( prefix , arr , suffix , n ) ; var l = 0 , r = 0 ; document . write ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) ; document . write ( " " ) ; l = 1 ; r = 1 ; document . write ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) ; document . write ( " " ) ; l = 1 ; r = 2 ; document . write ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) ; document . write ( " " ) ;
function countInRange ( arr , n , x , y ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= x && arr [ i ] <= y ) count ++ ; } return count ; } let arr = [ 1 , 3 , 4 , 9 , 10 , 3 ] ; let n = arr . length ; let i = 1 , j = 4 ; document . write ( countInRange ( arr , n , i , j ) + " " ) ; i = 9 ; j = 12 ; document . write ( countInRange ( arr , n , i , j ) ) ;
function lowerIndex ( arr , n , x ) { let l = 0 , h = n - 1 ; while ( l <= h ) { let mid = parseInt ( ( l + h ) / 2 , 10 ) ; if ( arr [ mid ] >= x ) h = mid - 1 ; else l = mid + 1 ; } return l ; } function upperIndex ( arr , n , y ) { let l = 0 , h = n - 1 ; while ( l <= h ) { let mid = parseInt ( ( l + h ) / 2 , 10 ) ; if ( arr [ mid ] <= y ) l = mid + 1 ; else h = mid - 1 ; } return h ; } function countInRange ( arr , n , x , y ) { let count = 0 ; count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; return count ; } let arr = [ 1 , 4 , 4 , 9 , 10 , 3 ] ; let n = arr . length ; arr . sort ( function ( a , b ) { return a - b } ) ; let i = 1 , j = 4 ; document . write ( countInRange ( arr , n , i , j ) + " " ) ; ; i = 9 ; j = 12 ; document . write ( countInRange ( arr , n , i , j ) ) ;
function precompute ( arr , n , pre ) { for ( let i = 0 ; i < n ; i ++ ) pre [ i ] = 0 ; pre [ n - 1 ] = arr [ n - 1 ] * ( Math . pow ( 2 , 0 ) ) ; for ( let i = n - 2 ; i >= 0 ; i -- ) pre [ i ] = pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ; } function decimalOfSubarr ( arr , l , r , n , pre ) { if ( r != n - 1 ) return ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ; return pre [ l ] / ( 1 << ( n - 1 - r ) ) ; } let arr = [ 1 , 0 , 1 , 0 , 1 , 1 ] ; let n = arr . length ; let pre = new Array ( n ) precompute ( arr , n , pre ) ; document . write ( decimalOfSubarr ( arr , 2 , 4 , n , pre ) + " " ) ; document . write ( decimalOfSubarr ( arr , 4 , 5 , n , pre ) ) ;
function answerQuery ( a , n , l , r ) { var count = 0 ; l = l - 1 ; for ( i = l ; i < r ; i ++ ) { var element = a [ i ] ; var divisors = 0 ; for ( j = l ; j < r ; j ++ ) { if ( a [ j ] % a [ i ] == 0 ) divisors ++ ; else break ; } if ( divisors == ( r - l ) ) count ++ ; } return count ; } var a = [ 1 , 2 , 3 , 5 ] ; var n = a . length ; var l = 1 , r = 4 ; document . write ( answerQuery ( a , n , l , r ) + " " ) ; l = 2 ; r = 4 ; document . write ( answerQuery ( a , n , l , r ) ) ;
const MAX = 2147483647 ; let one = new Array ( 100001 ) ; for ( let i = 0 ; i < 100001 ; i ++ ) one [ i ] = new Array ( 32 ) ; function make_prefix ( A , n ) { for ( let j = 0 ; j < 32 ; j ++ ) one [ 0 ] [ j ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let a = A [ i - 1 ] ; for ( let j = 0 ; j < 32 ; j ++ ) { let x = Math . pow ( 2 , j ) ; if ( a & x ) one [ i ] [ j ] = 1 + one [ i - 1 ] [ j ] ; else one [ i ] [ j ] = one [ i - 1 ] [ j ] ; } } } function Solve ( L , R ) { let l = L , r = R ; let tot_bits = r - l + 1 ; let X = MAX ; for ( let i = 0 ; i < 31 ; i ++ ) { let x = one [ r ] [ i ] - one [ l - 1 ] [ i ] ; if ( x >= tot_bits - x ) { let ith_bit = Math . pow ( 2 , i ) ; X = X ^ ith_bit ; } } return X ; } let n = 5 , q = 3 ; let A = [ 210 , 11 , 48 , 22 , 133 ] ; let L = [ 1 , 4 , 2 ] , R = [ 3 , 14 , 4 ] ; make_prefix ( A , n ) ; for ( let j = 0 ; j < q ; j ++ ) document . write ( Solve ( L [ j ] , R [ j ] ) + " " ) ;
function findCountOfPairs ( a , b , n ) { let ans = 0 ; for ( let i = 1 ; i <= a ; i ++ ) { ans += parseInt ( b / n , 10 ) ; ans += ( i % n + b % n ) >= n ? 1 : 0 ; } return ans ; } let a = 5 , b = 13 , n = 3 ; document . write ( findCountOfPairs ( a , b , n ) ) ;
function minItems ( k , r ) { for ( let i = 1 ; i < 10 ; i ++ ) if ( ( i * k - r ) % 10 == 0 || ( i * k ) % 10 == 0 ) return i ; return 10 ; } let k = 15 ; let r = 2 ; document . write ( minItems ( k , r ) ) ;
function answer_query ( a , n , l , r ) { var count = 0 ; for ( var i = l ; i < r ; i ++ ) if ( a [ i ] == a [ i + 1 ] ) count += 1 ; return count ; } var a = [ 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] var n = a . length ; var L , R ; L = 1 ; R = 8 ; document . write ( answer_query ( a , n , L , R ) + " " ) ; L = 0 ; R = 4 ; document . write ( answer_query ( a , n , L , R ) ) ;
const N = 1000 ; let prefixans = new Uint8Array ( N ) ; function countIndex ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == a [ i + 1 ] ) prefixans [ i ] = 1 ; if ( i != 0 ) prefixans [ i ] += prefixans [ i - 1 ] ; } } function answer_query ( l , r ) { if ( l == 0 ) return prefixans [ r - 1 ] ; else return prefixans [ r - 1 ] - prefixans [ l - 1 ] ; } let a = [ 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] ; let n = a . length ; countIndex ( a , n ) ; let L , R ; L = 1 ; R = 8 ; document . write ( answer_query ( L , R ) + " " ) ; L = 0 ; R = 4 ; document . write ( answer_query ( L , R ) + " " ) ;
function primeSubarrays ( A , n ) { var max_val = parseInt ( Math . pow ( 10 , 7 ) ) ; var prime = new Array ( max_val + 1 ) ; prime . fill ( true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( var p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } var cnt = 0 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { var val = A [ i ] ; for ( var j = i + 1 ; j < n ; ++ j ) { val += A [ j ] ; if ( prime [ val ] ) ++ cnt ; } } return cnt ; } var A = [ 1 , 2 , 3 , 4 , 5 ] ; var n = A . length ; document . write ( primeSubarrays ( A , n ) ) ;
function countMinSwaps ( st ) { let min_swaps = 0 ; let odd_0 = 0 , even_0 = 0 ; let odd_1 = 0 , even_1 = 0 ; let n = st . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) { if ( st [ i ] == ' ' ) { even_1 ++ ; } else { even_0 ++ ; } } else { if ( st [ i ] == ' ' ) { odd_1 ++ ; } else { odd_0 ++ ; } } } let cnt_swaps_1 = Math . min ( even_0 , odd_1 ) ; let cnt_swaps_2 = Math . min ( even_1 , odd_0 ) ; return Math . min ( cnt_swaps_1 , cnt_swaps_2 ) ; } let st = " " ; document . write ( countMinSwaps ( st ) ) ;
function modpow ( base , exp , modulus ) { base %= modulus ; let result = 1 ; while ( exp > 0 ) { if ( ( exp & 1 ) > 0 ) result = ( result * base ) % modulus ; base = ( base * base ) % modulus ; exp >>= 1 ; } return result ; } let n = 654654 ; let mod = 971 ; document . write ( ( ( modpow ( n , 6 , mod ) + modpow ( n , 2 , mod ) ) % mod + 355 ) % mod ) ;
function maxSubArraySum ( a , size ) { var maxint = Math . pow ( 2 , 53 ) var max_so_far = - maxint - 1 var max_ending_here = 0 for ( var i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] if ( max_so_far < max_ending_here ) max_so_far = max_ending_here if ( max_ending_here < 0 ) max_ending_here = 0 } return max_so_far } var a = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] document . write ( " " , maxSubArraySum ( a , a . length ) )
function findMinRooms ( slots , n , m ) { let counts = Array ( m ) . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) counts [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( slots [ i ] [ j ] == ' ' ) counts [ j ] ++ ; let max = - 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( max < counts [ i ] ) max = counts [ i ] ; return max ; } let n = 3 , m = 7 ; let slots = [ " " , " " , " " ] ; document . write ( findMinRooms ( slots , n , m ) ) ;
function maxSubArraySum ( a , size ) { let max_so_far = a [ 0 ] ; let curr_max = a [ 0 ] ; for ( let i = 1 ; i < size ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; } let a = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] ; let n = a . length ; document . write ( " " , maxSubArraySum ( a , n ) ) ;
function countCurrency ( amount ) { let notes = [ 2000 , 500 , 200 , 100 , 50 , 20 , 10 , 5 , 1 ] ; let noteCounter = Array ( 9 ) . fill ( 0 ) ; for ( let i = 0 ; i < 9 ; i ++ ) { if ( amount >= notes [ i ] ) { noteCounter [ i ] = Math . floor ( amount / notes [ i ] ) ; amount = amount - noteCounter [ i ] * notes [ i ] ; } } document . write ( " " + " " ) ; for ( let i = 0 ; i < 9 ; i ++ ) { if ( noteCounter [ i ] != 0 ) { document . write ( notes [ i ] + " " + noteCounter [ i ] + " " ) ; } } } let amount = 868 ; countCurrency ( amount ) ;
function minSum ( A , n ) { let min_val = Math . min ( ... A ) ; return ( min_val * ( n - 1 ) ) ; } let A = [ 3 , 6 , 2 , 8 , 7 , 5 ] ; let n = A . length ; document . write ( minSum ( A , n ) ) ;
function NextFit ( blockSize , m , processSize , n ) { let allocation = Array . from ( { length : n } , ( _ , i ) => - 1 ) , j = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( blockSize [ j ] >= processSize [ i ] ) { allocation [ i ] = j ; blockSize [ j ] -= processSize [ i ] ; break ; } j = ( j + 1 ) % m ; } } document . write ( " " + " " ) ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( i + 1 + Array ( 20 ) . fill ( ' \xa0 ' ) . join ( ' ' ) + processSize [ i ] + Array ( 20 ) . fill ( ' \xa0 ' ) . join ( ' ' ) ) ; if ( allocation [ i ] != - 1 ) { document . write ( allocation [ i ] + 1 ) ; } else { document . write ( " " ) ; } document . write ( " " ) ; } } let blockSize = [ 5 , 10 , 20 ] ; let processSize = [ 10 , 20 , 5 ] ; let m = blockSize . length ; let n = processSize . length ; NextFit ( blockSize , m , processSize , n ) ;
function findMinAvgSubarray ( arr , n , k ) { if ( n < k ) return ; let res_index = 0 ; let curr_sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) curr_sum += arr [ i ] ; let min_sum = curr_sum ; for ( let i = k ; i < n ; i ++ ) { curr_sum += arr [ i ] - arr [ i - k ] ; if ( curr_sum < min_sum ) { min_sum = curr_sum ; res_index = ( i - k + 1 ) ; } } document . write ( " " + res_index + " " + ( res_index + k - 1 ) + " " ) ; } let arr = [ 3 , 7 , 90 , 20 , 10 , 50 , 40 ] ; let k = 3 ; let n = arr . length ; findMinAvgSubarray ( arr , n , k ) ;
let seg = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] ; function computeSegment ( x ) { if ( x == 0 ) return seg [ 0 ] ; let count = 0 ; while ( x > 0 ) { count += seg [ x % 10 ] ; x = parseInt ( x / 10 , 10 ) ; } return count ; } function elementMinSegment ( arr , n ) { let minseg = computeSegment ( arr [ 0 ] ) ; let minindex = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let temp = computeSegment ( arr [ i ] ) ; if ( temp < minseg ) { minseg = temp ; minindex = i ; } } return arr [ minindex ] ; } let arr = [ 489 , 206 , 745 , 123 , 756 ] ; let n = arr . length ; document . write ( elementMinSegment ( arr , n ) ) ;
function findLargest ( m , s ) { if ( s == 0 ) { ( m == 1 ) ? document . write ( " " + 0 ) : document . write ( " " ) ; return ; } if ( s > 9 * m ) { document . write ( " " ) ; return ; } let res = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { if ( s >= 9 ) { res [ i ] = 9 ; s -= 9 ; } else { res [ i ] = s ; s = 0 ; } } document . write ( " " ) ; for ( let i = 0 ; i < m ; i ++ ) document . write ( res [ i ] ) ; } let s = 9 , m = 2 ; findLargest ( m , s ) ;
function minJumps ( arr , n ) { if ( n == 1 ) return 0 ; let res = Number . MAX_VALUE ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( i + arr [ i ] >= n - 1 ) { let sub_res = minJumps ( arr , i + 1 ) ; if ( sub_res != Number . MAX_VALUE ) res = Math . min ( res , sub_res + 1 ) ; } } return res ; } let arr = [ 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 ] ; let n = arr . length ; document . write ( " " ) ; document . write ( " " + minJumps ( arr , n ) ) ;
function minJumps ( arr , n ) { var jumps = Array . from ( { length : n } , ( _ , i ) => 0 ) ; var min ; jumps [ n - 1 ] = 0 ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == 0 ) jumps [ i ] = Number . MAX_VALUE ; else if ( arr [ i ] >= n - i - 1 ) jumps [ i ] = 1 ; else { min = Number . MAX_VALUE ; for ( j = i + 1 ; j < n && j <= arr [ i ] + i ; j ++ ) { if ( min > jumps [ j ] ) min = jumps [ j ] ; } if ( min != Number . MAX_VALUE ) jumps [ i ] = min + 1 ; else jumps [ i ] = min ; } } return jumps [ 0 ] ; } var arr = [ 1 , 3 , 6 , 1 , 0 , 9 ] ; var size = arr . length ; document . write ( " " + " " + minJumps ( arr , size ) ) ;
function smallestSubWithSum ( arr , n , x ) { let min_len = n + 1 ; for ( let start = 0 ; start < n ; start ++ ) { let curr_sum = arr [ start ] ; if ( curr_sum > x ) return 1 ; for ( let end = start + 1 ; end < n ; end ++ ) { curr_sum += arr [ end ] ; if ( curr_sum > x && ( end - start + 1 ) < min_len ) min_len = ( end - start + 1 ) ; } } return min_len ; } let arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] ; let x = 51 ; let n1 = arr1 . length ; let res1 = smallestSubWithSum ( arr1 , n1 , x ) ; ( res1 == n1 + 1 ) ? document . write ( " " ) : document . write ( res1 + " " ) ; let arr2 = [ 1 , 10 , 5 , 2 , 7 ] ; let n2 = arr2 . length ; x = 9 ; let res2 = smallestSubWithSum ( arr2 , n2 , x ) ; ( res2 == n2 + 1 ) ? document . write ( " " ) : document . write ( res2 + " " ) ; let arr3 = [ 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ] ; let n3 = arr3 . length ; x = 280 ; let res3 = smallestSubWithSum ( arr3 , n3 , x ) ; ( res3 == n3 + 1 ) ? document . write ( " " ) : document . write ( res3 + " " ) ;
function smallestSubWithSum ( arr , n , x ) { let curr_sum = 0 , min_len = n + 1 ; let start = 0 , end = 0 ; while ( end < n ) { while ( curr_sum <= x && end < n ) curr_sum += arr [ end ++ ] ; while ( curr_sum > x && start < n ) { if ( end - start < min_len ) min_len = end - start ; curr_sum -= arr [ start ++ ] ; } } return min_len ; } let arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] ; let x = 51 ; let n1 = arr1 . length ; let res1 = smallestSubWithSum ( arr1 , n1 , x ) ; ( res1 == n1 + 1 ) ? document . write ( " " ) : document . write ( res1 + " " ) ; let arr2 = [ 1 , 10 , 5 , 2 , 7 ] ; let n2 = arr2 . length ; x = 9 ; let res2 = smallestSubWithSum ( arr2 , n2 , x ) ; ( res2 == n2 + 1 ) ? document . write ( " " ) : document . write ( res2 + " " ) ; let arr3 = [ 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ] ; let n3 = arr3 . length ; x = 280 ; let res3 = smallestSubWithSum ( arr3 , n3 , x ) ; ( res3 == n3 + 1 ) ? document . write ( " " ) : document . write ( res3 + " " ) ;
let arr = [ 16 , 16 , 16 ] ; function countMinOperations ( n ) { let result = 0 ; while ( true ) { let zero_count = 0 ; let i ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) break ; else if ( arr [ i ] == 0 ) zero_count ++ ; } if ( zero_count == n ) return result ; if ( i == n ) { for ( let j = 0 ; j < n ; j ++ ) arr [ j ] = arr [ j ] / 2 ; result ++ ; } for ( let j = i ; j < n ; j ++ ) { if ( arr [ j ] % 2 == 1 ) { arr [ j ] -- ; result ++ ; } } } } document . write ( " " + " " + " " + countMinOperations ( arr . length ) ) ;
function findMinOps ( arr , n ) { let ans = 0 ; for ( let i = 0 , j = n - 1 ; i <= j ; ) { if ( arr [ i ] == arr [ j ] ) { i ++ ; j -- ; } else if ( arr [ i ] > arr [ j ] ) { j -- ; arr [ j ] += arr [ j + 1 ] ; ans ++ ; } else { i ++ ; arr [ i ] += arr [ i - 1 ] ; ans ++ ; } } return ans ; } let arr = [ 1 , 4 , 5 , 9 , 1 ] ; document . write ( " " + findMinOps ( arr , arr . length ) ) ;
function findSmallest ( arr , n ) { var res = 1 ; for ( i = 0 ; i < n && arr [ i ] <= res ; i ++ ) res = res + arr [ i ] ; return res ; } var arr1 = [ 1 , 3 , 4 , 5 ] ; var n1 = arr1 . length ; document . write ( findSmallest ( arr1 , n1 ) + " " ) ; var arr2 = [ 1 , 2 , 6 , 10 , 11 , 15 ] ; var n2 = arr2 . length ; document . write ( findSmallest ( arr2 , n2 ) + " " ) ; var arr3 = [ 1 , 1 , 1 , 1 ] ; var n3 = arr3 . length ; document . write ( findSmallest ( arr3 , n3 ) + " " ) ; var arr4 = [ 1 , 1 , 3 , 4 ] ; var n4 = arr4 . length ; document . write ( findSmallest ( arr4 , n4 ) + " " ) ;
function findMinDiff ( arr , n ) { let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( ( arr [ i ] - arr [ j ] ) ) < diff ) diff = Math . abs ( ( arr [ i ] - arr [ j ] ) ) ; return diff ; } let arr = [ 1 , 5 , 3 , 19 , 18 , 25 ] ; document . write ( " " + findMinDiff ( arr , arr . length ) ) ;
function findMinDiff ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let diff = Number . MAX_VALUE ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i + 1 ] - arr [ i ] < diff ) diff = arr [ i + 1 ] - arr [ i ] ; return diff ; } let arr = [ 1 , 5 , 3 , 19 , 18 , 25 ] ; document . write ( " " + findMinDiff ( arr , arr . length ) ) ;
let a = 2 , b = 10 ; let size = Math . abs ( b - a ) + 1 ; let array = [ ] ; for ( let i = a ; i <= b ; i ++ ) if ( i % 2 == 0 i % 5 == 0 ) array [ i - a ] = 1 ; document . write ( " " + " " + " " ) ; for ( let i = a ; i <= b ; i ++ ) if ( array [ i - a ] == 1 ) document . write ( i + " " ) ;
let arr1 = [ 0 , 1 , 0 , 1 , 1 , 1 , 1 ] ; let arr2 = [ 1 , 1 , 1 , 1 , 1 , 0 , 1 ] ; function longestCommonSum ( n ) { let maxLen = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let sum1 = 0 , sum2 = 0 ; for ( let j = i ; j < n ; j ++ ) { sum1 += arr1 [ j ] ; sum2 += arr2 [ j ] ; if ( sum1 == sum2 ) { let len = j - i + 1 ; if ( len > maxLen ) maxLen = len ; } } } return maxLen ; } document . write ( " " + " " ) ; document . write ( longestCommonSum ( arr1 . length ) ) ;
function moveToEnd ( mPlusN , size ) { let i = 0 ; let j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) { if ( mPlusN [ i ] != - 1 ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } } function merge ( mPlusN , N , m , n ) { let i = n ; let j = 0 ; let k = 0 ; while ( k < ( m + n ) ) { if ( ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) || ( j == n ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } } function printArray ( arr , size ) { let i = 0 ; for ( i = 0 ; i < size ; i ++ ) { document . write ( arr [ i ] + " " ) ; } document . write ( " " ) ; } let mPlusN = [ 2 , 8 , - 1 , - 1 , - 1 , 13 , - 1 , 15 , 20 ] ; let N = [ 5 , 7 , 9 , 25 ] let n = N . length ; let m = mPlusN . length - n ; moveToEnd ( mPlusN , m + n ) ; merge ( mPlusN , N , m , n ) ; printArray ( mPlusN , m + n ) ;
function sortedAfterSwap ( A , B , n ) { let i , j ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] ) { j = i ; while ( B [ j ] ) { j ++ ; } A . sort ( ) ; i = j ; } } for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) { return false ; } } return true ; } let A = [ 1 , 2 , 5 , 3 , 4 , 6 ] ; let B = [ false , true , true , true , false ] ; let n = A . length ; if ( sortedAfterSwap ( A , B , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function sortedAfterSwap ( A , B , n ) { let t = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( B [ i ] != 0 ) { if ( A [ i ] != i + 1 ) t = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = t ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( A [ i ] != i + 1 ) return 0 ; } return 1 ; } let A = [ 1 , 2 , 5 , 3 , 4 , 6 ] ; let B = [ 0 , 1 , 1 , 1 , 0 ] ; let n = A . length ; if ( sortedAfterSwap ( A , B , n ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ;
function segregate0and1 ( arr , n ) { let type0 = 0 ; let type1 = n - 1 ; while ( type0 < type1 ) { if ( arr [ type0 ] == 1 ) { arr [ type0 ] = arr [ type0 ] + arr [ type1 ] ; arr [ type1 ] = arr [ type0 ] - arr [ type1 ] ; arr [ type0 ] = arr [ type0 ] - arr [ type1 ] ; type1 -- ; } else { type0 ++ ; } } } let arr = [ 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 ] ; segregate0and1 ( arr , arr . length ) ; for ( let i = 0 ; i < arr . length ; i ++ ) document . write ( arr [ i ] + " " ) ;
function getInvCount ( arr ) { let inv_count = 0 ; for ( let i = 0 ; i < arr . length - 1 ; i ++ ) { for ( let j = i + 1 ; j < arr . length ; j ++ ) { if ( arr [ i ] > arr [ j ] ) inv_count ++ ; } } return inv_count ; } arr = [ 1 , 20 , 6 , 4 , 5 ] ; document . write ( " " + getInvCount ( arr ) ) ;
function minAbsSumPair ( arr , arr_size ) { var inv_count = 0 ; var l , r , min_sum , sum , min_l , min_r ; if ( arr_size < 2 ) { document . write ( " " ) ; return ; } min_l = 0 ; min_r = 1 ; min_sum = arr [ 0 ] + arr [ 1 ] ; for ( l = 0 ; l < arr_size - 1 ; l ++ ) { for ( r = l + 1 ; r < arr_size ; r ++ ) { sum = arr [ l ] + arr [ r ] ; if ( Math . abs ( min_sum ) > Math . abs ( sum ) ) { min_sum = sum ; min_l = l ; min_r = r ; } } } document . write ( " " + arr [ min_l ] + " " + arr [ min_r ] ) ; } arr = new Array ( 1 , 60 , - 10 , 70 , - 80 , 85 ) ; minAbsSumPair ( arr , 6 ) ;
function increasing ( a , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) if ( a [ i ] >= a [ i + 1 ] ) return false ; return true ; } function decreasing ( arr , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] < arr [ i + 1 ] ) return false ; return true ; } function shortestUnsorted ( a , n ) { if ( increasing ( a , n ) == true || decreasing ( a , n ) == true ) return 0 ; else return 3 ; } let ar = [ 7 , 9 , 10 , 8 , 11 ] ; let n = ar . length ; document . write ( shortestUnsorted ( ar , n ) ) ;
function printUnion ( arr1 , arr2 , m , n ) { if ( m > n ) { let tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; let temp = m ; m = n ; n = temp ; } arr1 . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < m ; i ++ ) document . write ( arr1 [ i ] + " " ) ; for ( let i = 0 ; i < n ; i ++ ) if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == - 1 ) document . write ( arr2 [ i ] + " " ) ; } function printIntersection ( arr1 , arr2 , m , n ) { if ( m > n ) { let tempp = arr1 ; arr1 = arr2 ; arr2 = tempp ; let temp = m ; m = n ; n = temp ; } arr1 . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != - 1 ) document . write ( arr2 [ i ] + " " ) ; } function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } let arr1 = [ 7 , 1 , 5 , 2 , 3 , 6 ] ; let arr2 = [ 3 , 8 , 6 , 20 , 7 ] ; let m = arr1 . length ; let n = arr2 . length ; document . write ( " " ) ; printUnion ( arr1 , arr2 , m , n ) ; document . write ( " " ) ; printIntersection ( arr1 , arr2 , m , n ) ;
function intersection ( a , b , n , m ) { let i = 0 , j = 0 ; while ( i < n && j < m ) { if ( a [ i ] > b [ j ] ) { j ++ ; } else if ( b [ j ] > a [ i ] ) { i ++ ; } else { document . write ( a [ i ] + " " ) ; i ++ ; j ++ ; } } } let a = [ 1 , 3 , 2 , 3 , 4 , 5 , 5 , 6 ] ; let b = [ 3 , 3 , 5 ] let n = a . length ; let m = b . length ; a . sort ( ) ; b . sort ( ) ; intersection ( a , b , n , m ) ;
function sort012 ( a , arr_size ) { let lo = 0 ; let hi = arr_size - 1 ; let mid = 0 ; let temp = 0 ; while ( mid <= hi ) { if ( a [ mid ] == 0 ) { temp = a [ lo ] ; a [ lo ] = a [ mid ] ; a [ mid ] = temp ; lo ++ ; mid ++ ; } else if ( a [ mid ] == 1 ) { mid ++ ; } else { temp = a [ mid ] ; a [ mid ] = a [ hi ] ; a [ hi ] = temp ; hi -- ; } } } function printArray ( arr , arr_size ) { let i ; for ( i = 0 ; i < arr_size ; i ++ ) { document . write ( arr [ i ] + " " ) ; } document . write ( " " ) ; } let arr = [ 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 ] ; let arr_size = arr . length ; sort012 ( arr , arr_size ) ; document . write ( " " ) printArray ( arr , arr_size ) ;
function printUnsorted ( arr , n ) { let s = 0 , e = n - 1 , i , max , min ; for ( s = 0 ; s < n - 1 ; s ++ ) { if ( arr [ s ] > arr [ s + 1 ] ) break ; } if ( s == n - 1 ) { document . write ( " " ) ; return ; } for ( e = n - 1 ; e > 0 ; e -- ) { if ( arr [ e ] < arr [ e - 1 ] ) break ; } max = arr [ s ] ; min = arr [ s ] ; for ( i = s + 1 ; i <= e ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } for ( i = 0 ; i < s ; i ++ ) { if ( arr [ i ] > min ) { s = i ; break ; } } for ( i = n - 1 ; i >= e + 1 ; i -- ) { if ( arr [ i ] < max ) { e = i ; break ; } } document . write ( " " + " " + " " + s + " " + e ) ; return ; } let arr = [ 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 ] ; let arr_size = arr . length ; printUnsorted ( arr , arr_size ) ;
function findNumberOfTriangles ( arr ) { let n = arr . length ; arr . sort ( ( a , b ) => a - b ) ; let count = 0 ; for ( let i = 0 ; i < n - 2 ; ++ i ) { let k = i + 2 ; for ( let j = i + 1 ; j < n ; ++ j ) { while ( k < n && arr [ i ] + arr [ j ] > arr [ k ] ) ++ k ; if ( k > j ) count += k - j - 1 ; } } return count ; } let arr = [ 10 , 21 , 22 , 100 , 101 , 200 , 300 ] ; let size = arr . length ; document . write ( " " + findNumberOfTriangles ( arr , size ) ) ;
function countPairsWithDiffK ( arr , n , k ) { count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] - arr [ j ] == k arr [ j ] - arr [ i ] == k ) count ++ ; } return count ; } arr = new Array ( 1 , 5 , 3 , 4 , 2 ) ; n = arr . length ; k = 3 ; document . write ( " " + countPairsWithDiffK ( arr , n , k ) ) ;
function binarySearch ( arr , low , high , x ) { if ( high >= low ) { let mid = low + Math . floor ( ( high - low ) / 2 ) ; if ( x == arr [ mid ] ) return mid ; if ( x > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , x ) ; else return binarySearch ( arr , low , ( mid - 1 ) , x ) ; } return - 1 ; } function countPairsWithDiffK ( arr , n , k ) { let count = 0 , i ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i < n - 1 ; i ++ ) if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != - 1 ) count ++ ; return count ; } let arr = [ 1 , 5 , 3 , 4 , 2 ] ; let n = arr . length ; let k = 3 ; document . write ( " " + countPairsWithDiffK ( arr , n , k ) ) ;
function countPairsWithDiffK ( arr , n , k ) { let count = 0 ; arr . sort ( ) ; let l = 0 ; let r = 0 ; while ( r < n ) { if ( arr [ r ] - arr [ l ] == k ) { count ++ ; l ++ ; r ++ ; } else if ( arr [ r ] - arr [ l ] > k ) l ++ ; else r ++ ; } return count ; } let arr = [ 1 , 5 , 3 , 4 , 2 ] ; let n = arr . length ; let k = 3 ; document . write ( " " + countPairsWithDiffK ( arr , n , k ) ) ;
function constructArr ( arr , pair , n ) { arr [ 0 ] = Math . floor ( ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) / 2 ) ; for ( let i = 1 ; i < n ; i ++ ) arr [ i ] = pair [ i - 1 ] - arr [ 0 ] ; } let pair = [ 15 , 13 , 11 , 10 , 12 , 10 , 9 , 8 , 7 , 5 ] ; let n = 5 ; let arr = new Array ( n ) ; constructArr ( arr , pair , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ;
let arr1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] ; let arr2 = [ 2 , 3 , 8 , 13 ] ; function merge ( m , n ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { let j , last = arr1 [ m - 1 ] ; for ( j = m - 2 ; j >= 0 && arr1 [ j ] > arr2 [ i ] ; j -- ) arr1 [ j + 1 ] = arr1 [ j ] ; if ( j != m - 2 last > arr2 [ i ] ) { arr1 [ j + 1 ] = arr2 [ i ] ; arr2 [ i ] = last ; } } } merge ( arr1 . length , arr2 . length ) ; document . write ( " " ) ; for ( let i = 0 ; i < arr1 . length ; i ++ ) { document . write ( arr1 [ i ] + " " ) ; } document . write ( " " ) ; for ( let i = 0 ; i < arr2 . length ; i ++ ) { document . write ( arr2 [ i ] + " " ) ; }
function gouldSequence ( n ) { for ( var row_num = 1 ; row_num <= n ; row_num ++ ) { var count = 1 ; var c = 1 ; for ( var i = 1 ; i <= row_num ; i ++ ) { c = c * ( row_num - i ) / i ; if ( c % 2 == 1 ) count ++ ; } document . write ( count + " " ) ; } } var n = 16 ; gouldSequence ( n ) ;
function minMaxProduct ( arr1 , arr2 , n1 , n2 ) { arr1 . sort ( ( a , b ) => a - b ) ; arr2 . sort ( ( a , b ) => a - b ) ; return ( arr1 [ n1 - 1 ] * arr2 [ 0 ] ) ; } let arr1 = [ 10 , 2 , 3 , 6 , 4 , 1 ] ; let arr2 = [ 5 , 1 , 4 , 2 , 6 , 9 ] ; let n1 = arr1 . length ; let n2 = arr2 . length ; document . write ( minMaxProduct ( arr1 , arr2 , n1 , n2 ) ) ;
let M = 100 ; let N = 100 ; function find_min_odd_cost ( given , m , n ) { let floor = new Array ( M ) ; for ( let i = 0 ; i < M ; i ++ ) { floor [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { floor [ i ] [ j ] = 0 ; } } let min_odd_cost = 0 ; let i , j , temp ; for ( j = 0 ; j < n ; j ++ ) floor [ 0 ] [ j ] = given [ 0 ] [ j ] ; for ( i = 1 ; i < m ; i ++ ) for ( j = 0 ; j < n ; j ++ ) { if ( j == 0 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j + 1 ] ) ; } else if ( j == n - 1 ) { floor [ i ] [ j ] = given [ i ] [ j ] ; floor [ i ] [ j ] += Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; } else { temp = Math . min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) ; temp = Math . min ( temp , floor [ i - 1 ] [ j + 1 ] ) ; floor [ i ] [ j ] = given [ i ] [ j ] + temp ; } } min_odd_cost = Number . MAX_VALUE ; for ( j = 0 ; j < n ; j ++ ) { if ( floor [ n - 1 ] [ j ] % 2 == 1 ) { if ( min_odd_cost > floor [ n - 1 ] [ j ] ) min_odd_cost = floor [ n - 1 ] [ j ] ; } } if ( min_odd_cost == Number . MIN_VALUE ) return - 1 ; return min_odd_cost ; } let m = 5 , n = 5 ; let given = [ [ 1 , 2 , 3 , 4 , 6 ] , [ 1 , 2 , 3 , 4 , 5 ] , [ 1 , 2 , 3 , 4 , 5 ] , [ 1 , 2 , 3 , 4 , 5 ] , [ 100 , 2 , 3 , 4 , 5 ] ] ; document . write ( " " + find_min_odd_cost ( given , m , n ) ) ;
function minMaxProduct ( arr1 , arr2 , n1 , n2 ) { let max = arr1 [ 0 ] ; let min = arr2 [ 0 ] ; let i ; for ( i = 1 ; i < n1 && i < n2 ; ++ i ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; if ( arr2 [ i ] < min ) min = arr2 [ i ] ; } while ( i < n1 ) { if ( arr1 [ i ] > max ) max = arr1 [ i ] ; i ++ ; } while ( i < n2 ) { if ( arr2 [ i ] < min ) min = arr2 [ i ] ; i ++ ; } return max * min ; } let arr1 = [ 10 , 2 , 3 , 6 , 4 , 1 ] ; let arr2 = [ 5 , 1 , 4 , 2 , 6 , 9 ] ; let n1 = 6 ; let n2 = 6 ; document . write ( minMaxProduct ( arr1 , arr2 , n1 , n2 ) ) ;
function findElement ( arr , n , key ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } let arr = [ 12 , 34 , 10 , 6 , 40 ] ; let n = arr . length ; let key = 40 ; let position = findElement ( arr , n , key ) ; if ( position == - 1 ) document . write ( " " ) ; else document . write ( " " + ( position + 1 ) ) ;
function insertSorted ( arr , n , key , capacity ) { if ( n >= capacity ) return n ; arr [ n ] = key ; return ( n + 1 ) ; } let arr = new Array ( 20 ) ; arr [ 0 ] = 12 ; arr [ 1 ] = 16 ; arr [ 2 ] = 20 ; arr [ 3 ] = 40 ; arr [ 4 ] = 50 ; arr [ 5 ] = 70 ; let capacity = 20 ; let n = 6 ; let i , key = 26 ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; n = insertSorted ( arr , n , key , capacity ) ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ;
function findElement ( arr , n , key ) { let i ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == key ) return i ; return - 1 ; } function deleteElement ( arr , n , key ) { let pos = findElement ( arr , n , key ) ; if ( pos == - 1 ) { document . write ( " " ) ; return n ; } let i ; for ( i = pos ; i < n - 1 ; i ++ ) arr [ i ] = arr [ i + 1 ] ; return n - 1 ; } let i ; let arr = [ 10 , 50 , 30 , 40 , 20 ] ; let n = arr . length ; let key = 30 ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; n = deleteElement ( arr , n , key ) ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ;
function binarySearch ( arr , low , high , key ) { if ( high < low ) return - 1 ; let mid = Math . trunc ( ( low + high ) / 2 ) ; if ( key == arr [ mid ] ) return mid ; if ( key > arr [ mid ] ) return binarySearch ( arr , ( mid + 1 ) , high , key ) ; return binarySearch ( arr , low , ( mid - 1 ) , key ) ; } let arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] ; let n , key ; n = arr . length ; key = 10 ; document . write ( " " + binarySearch ( arr , 0 , n - 1 , key ) + " " ) ;
function findSDSFunc ( n ) { let DP = [ ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) DP [ i ] = DP [ i / 2 ] ; else DP [ i ] = DP [ ( i - 1 ) / 2 ] + DP [ ( i + 1 ) / 2 ] ; } return DP [ n ] ; } let n = 15 ; document . write ( findSDSFunc ( n ) ) ;
function findCommon ( ar1 , ar2 , ar3 , n1 , n2 , n3 ) { var i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 && k < n3 ) { if ( ar1 [ i ] == ar2 [ j ] && ar2 [ j ] == ar3 [ k ] ) { document . write ( ar1 [ i ] + " " ) ; i ++ ; j ++ ; k ++ ; } else if ( ar1 [ i ] < ar2 [ j ] ) i ++ ; else if ( ar2 [ j ] < ar3 [ k ] ) j ++ ; else k ++ ; } } var ar1 = [ 1 , 5 , 10 , 20 , 40 , 80 ] ; var ar2 = [ 6 , 7 , 20 , 80 , 100 ] ; var ar3 = [ 3 , 4 , 15 , 20 , 30 , 70 , 80 , 120 ] ; var n1 = ar1 . length ; var n2 = ar2 . length ; var n3 = ar3 . length ; document . write ( " " ) ; findCommon ( ar1 , ar2 , ar3 , n1 , n2 , n3 ) ;
function Jacobsthal ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; } function Jacobsthal_Lucas ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 2 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; return dp [ n ] ; } let n = 5 ; document . write ( " " + Jacobsthal ( n ) + " " ) ; document . write ( " " + Jacobsthal_Lucas ( n ) ) ;
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } function findPos ( arr , key ) { let l = 0 , h = 1 ; let val = arr [ 0 ] ; while ( val < key ) { l = h ; h = 2 * h ; val = arr [ h ] ; } return binarySearch ( arr , l , h , key ) ; } let arr = [ 3 , 5 , 7 , 9 , 10 , 90 , 100 , 130 , 140 , 160 , 170 ] ; let ans = findPos ( arr , 10 ) ; if ( ans == - 1 ) document . write ( " " ) ; else document . write ( " " + ans ) ;
function answer ( n ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } if ( n == 1 ) return 10 ; for ( let j = 0 ; j <= 9 ; j ++ ) dp [ 1 ] [ j ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; else if ( j == 9 ) dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } } let sum = 0 ; for ( let j = 1 ; j <= 9 ; j ++ ) sum += dp [ n ] [ j ] ; return sum ; } let n = 2 ; document . write ( answer ( n ) ) ;
function findSingle ( ar , ar_size ) { let res = ar [ 0 ] ; for ( let i = 1 ; i < ar_size ; i ++ ) res = res ^ ar [ i ] ; return res ; } let ar = [ 2 , 3 , 5 , 4 , 5 , 3 , 4 ] ; let n = ar . length ; document . write ( " " + findSingle ( ar , n ) ) ;
function isPresent ( B , m , x ) { for ( let i = 0 ; i < m ; i ++ ) if ( B [ i ] == x ) return true ; return false ; } function findMaxSubarraySumUtil ( A , B , n , m ) { let max_so_far = - 2147483648 , curr_max = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPresent ( B , m , A [ i ] ) ) { curr_max = 0 ; continue ; } curr_max = Math . max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; } function findMaxSubarraySum ( A , B , n , m ) { let maxSubarraySum = findMaxSubarraySumUtil ( A , B , n , m ) ; if ( maxSubarraySum == - 2147483648 ) { document . write ( " " + " " + " " ) ; } else { document . write ( " " + maxSubarraySum ) ; } } let A = [ 3 , 4 , 5 , - 4 , 6 ] ; let B = [ 1 , 8 , 5 ] ; let n = A . length ; let m = B . length ; findMaxSubarraySum ( A , B , n , m ) ;
function nonDecNums ( n ) { let a = new Array ( n + 1 ) for ( let i = 0 ; i < n + 1 ; i ++ ) { a [ i ] = new Array ( 10 ) ; } for ( let i = 0 ; i <= 9 ; i ++ ) a [ 0 ] [ i ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) a [ i ] [ 9 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 8 ; j >= 0 ; j -- ) a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] ; return a [ n ] [ 0 ] ; } let n = 2 ; document . write ( " " + nonDecNums ( n ) ) ;
let MOD = 1000000007 ; function countBT ( h ) { let dp = new Array ( h + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= h ; ++ i ) dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD ; return dp [ h ] ; } let h = 3 ; document . write ( " " + countBT ( h ) ) ;
function equilibrium ( arr , n ) { var i , j ; var leftsum , rightsum ; for ( i = 0 ; i < n ; ++ i ) { leftsum = 0 ; rightsum = 0 ; for ( let j = 0 ; j < i ; j ++ ) leftsum += arr [ j ] ; for ( let j = i + 1 ; j < n ; j ++ ) rightsum += arr [ j ] ; if ( leftsum == rightsum ) return i ; } return - 1 ; } var arr = new Array ( - 7 , 1 , 5 , 2 , - 4 , 3 , 0 ) ; n = arr . length ; document . write ( equilibrium ( arr , n ) ) ;
let MAX = 100 ; function countEndless ( input , n ) { let row = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { row [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { row [ i ] [ j ] = false ; } } let col = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { col [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { col [ i ] [ j ] = false ; } } for ( let j = 0 ; j < n ; j ++ ) { let isEndless = true ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; col [ i ] [ j ] = isEndless ; } } for ( let i = 0 ; i < n ; i ++ ) { let isEndless = true ; for ( let j = n - 1 ; j >= 0 ; j -- ) { if ( input [ i ] [ j ] == false ) isEndless = false ; row [ i ] [ j ] = isEndless ; } } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 1 ; j < n ; j ++ ) if ( row [ i ] [ j ] && col [ i ] [ j ] ) ans ++ ; return ans ; } let input = [ [ true , false , true , true ] , [ false , true , true , true ] , [ true , true , true , true ] , [ false , true , true , false ] ] ; let n = 4 ; document . write ( countEndless ( input , n ) ) ;
function equilibrium ( arr , n ) { sum = 0 ; leftsum = 0 ; for ( let i = 0 ; i < n ; ++ i ) sum += arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) { sum -= arr [ i ] ; if ( leftsum == sum ) return i ; leftsum += arr [ i ] ; } return - 1 ; } arr = new Array ( - 7 , 1 , 5 , 2 , - 4 , 3 , 0 ) ; n = arr . length ; document . write ( " " + equilibrium ( arr , n ) ) ;
function sumOfSubstrings ( num ) { let n = num . length ; let sumofdigit = new Array ( n ) ; sumofdigit [ 0 ] = num [ 0 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; let res = sumofdigit [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { let numi = num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; sumofdigit [ i ] = ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ; res += sumofdigit [ i ] ; } return res ; } let num = " " ; document . write ( sumOfSubstrings ( num ) ) ;
function printLeaders ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) { let j ; for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] <= arr [ j ] ) break ; } if ( j == size ) document . write ( arr [ i ] + " " ) ; } } let arr = [ 16 , 17 , 4 , 3 , 5 , 2 ] ; let n = arr . length ; printLeaders ( arr , n ) ;
function max ( i , j ) { return ( i > j ) ? i : j ; } function unboundedKnapsack ( W , n , val , wt ) { let dp = new Array ( W + 1 ) ; dp . fill ( 0 ) ; for ( let i = 0 ; i <= W ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( wt [ j ] <= i ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) ; } } } return dp [ W ] ; } let W = 100 ; let val = [ 10 , 30 , 20 ] ; let wt = [ 5 , 10 , 15 ] ; let n = val . length ; document . write ( unboundedKnapsack ( W , n , val , wt ) ) ;
function ceilSearch ( arr , low , high , x ) { let i ; if ( x <= arr [ low ] ) return low ; for ( i = low ; i < high ; i ++ ) { if ( arr [ i ] == x ) return i ; if ( arr [ i ] < x && arr [ i + 1 ] >= x ) return i + 1 ; } return - 1 ; } let arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] ; let n = arr . length ; let x = 3 ; let index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) document . write ( " " + x + " " ) ; else document . write ( " " + x + " " + arr [ index ] ) ;
function maxSumSubarrayRemovingOneEle ( arr , n ) { let fw = [ ] ; let bw = [ ] ; let cur_max = arr [ 0 ] , max_so_far = arr [ 0 ] ; fw [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; fw [ i ] = cur_max ; } cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { cur_max = Math . max ( arr [ i ] , cur_max + arr [ i ] ) ; max_so_far = Math . max ( max_so_far , cur_max ) ; bw [ i ] = cur_max ; } let fans = max_so_far ; for ( let i = 1 ; i < n - 1 ; i ++ ) fans = Math . max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) ; return fans ; } let arr = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] ; let n = arr . length ; document . write ( maxSumSubarrayRemovingOneEle ( arr , n ) ) ;
function ceilSearch ( arr , low , high , x ) { let mid ; if ( x <= arr [ low ] ) return low ; if ( x > arr [ high ] ) return - 1 ; mid = ( low + high ) / 2 ; if ( arr [ mid ] == x ) return mid ; else if ( arr [ mid ] < x ) { if ( mid + 1 <= high && x <= arr [ mid + 1 ] ) return mid + 1 ; else return ceilSearch ( arr , mid + 1 , high , x ) ; } else { if ( mid - 1 >= low && x > arr [ mid - 1 ] ) return mid ; else return ceilSearch ( arr , low , mid - 1 , x ) ; } } let arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] ; let n = arr . length ; let x = 20 ; let index = ceilSearch ( arr , 0 , n - 1 , x ) ; if ( index == - 1 ) { document . write ( ` ${ x } ` ) ; } else { document . write ( ` ${ x } ${ arr [ index ] } ` ) ; }
function maxAverageOfPath ( cost , N ) { let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j < N + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( let j = 1 ; j < N ; j ++ ) dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) ; } let cost = [ [ 1 , 2 , 3 ] , [ 6 , 5 , 4 ] , [ 7 , 3 , 9 ] ] ; document . write ( maxAverageOfPath ( cost , 3 ) ) ;
function maxCost ( mat , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j < i + 1 && j < N ; j ++ ) dp [ i ] [ j ] = mat [ i ] [ j ] + Math . max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; let result = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( result < dp [ N - 1 ] [ i ] ) result = dp [ N - 1 ] [ i ] ; return result ; } let mat = [ [ 4 , 1 , 5 , 6 , 1 ] , [ 2 , 9 , 2 , 11 , 10 ] , [ 15 , 1 , 3 , 15 , 2 ] , [ 16 , 92 , 41 , 4 , 3 ] , [ 8 , 142 , 6 , 4 , 8 ] ] ; let N = 5 ; document . write ( " " + maxCost ( mat , N ) ) ;
function maxProfit ( price , n , k ) { var profit = Array ( k + 1 ) . fill ( 0 ) . map ( x => Array ( n + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= k ; i ++ ) profit [ i ] [ 0 ] = 0 ; for ( j = 0 ; j <= n ; j ++ ) profit [ 0 ] [ j ] = 0 ; for ( var i = 1 ; i <= k ; i ++ ) { var prevDiff = - Number . MAX_VALUE ; for ( var j = 1 ; j < n ; j ++ ) { prevDiff = Math . max ( prevDiff , profit [ i - 1 ] [ j - 1 ] - price [ j - 1 ] ) ; profit [ i ] [ j ] = Math . max ( profit [ i ] [ j - 1 ] , price [ j ] + prevDiff ) ; } } return profit [ k ] [ n - 1 ] ; } var k = 3 ; var price = [ 12 , 14 , 17 , 10 , 14 , 13 , 12 , 15 ] ; var n = price . length ; document . write ( " " + maxProfit ( price , n , k ) ) ;
function countSeq ( n , diff ) { if ( Math . abs ( diff ) > n ) return 0 ; if ( n == 1 && diff == 0 ) return 2 ; if ( n == 1 && Math . abs ( diff ) == 1 ) return 1 ; let res = countSeq ( n - 1 , diff + 1 ) + 2 * countSeq ( n - 1 , diff ) + countSeq ( n - 1 , diff - 1 ) ; return res ; } let n = 2 ; document . write ( " " + countSeq ( 2 , 0 ) ) ;
let lookup = new Array ( 1000 ) ; for ( let i = 0 ; i < 1000 ; i ++ ) { lookup [ i ] = new Array ( 1000 ) ; } function countSeqUtil ( n , dif ) { if ( Math . abs ( dif ) > n ) return 0 ; if ( n == 1 && dif == 0 ) return 2 ; if ( n == 1 && Math . abs ( dif ) == 1 ) return 1 ; if ( lookup [ n ] [ n + dif ] != - 1 ) return lookup [ n ] [ n + dif ] ; countSeqUtil ( n - 1 , dif + 1 ) + 2 * countSeqUtil ( n - 1 , dif ) + countSeqUtil ( n - 1 , dif - 1 ) ; return lookup [ n ] [ n + dif ] = res ; } function countSeq ( n ) { for ( let k = 0 ; k < lookup . length ; k ++ ) { for ( let j = 0 ; j < lookup . length ; j ++ ) { lookup [ k ] [ j ] = - 1 ; } } return countSeqUtil ( n , 0 ) ; } let n = 2 ; document . write ( " " + countSeq ( 2 ) ) ;
function min ( arr , l , h ) { let mn = arr [ l ] ; for ( let i = l + 1 ; i <= h ; i ++ ) { if ( mn > arr [ i ] ) mn = arr [ i ] ; } return mn ; } function max ( arr , l , h ) { let mx = arr [ l ] ; for ( let i = l + 1 ; i <= h ; i ++ ) { if ( mx < arr [ i ] ) mx = arr [ i ] ; } return mx ; } function minRemovals ( arr , l , h ) { if ( l >= h ) return 0 ; let mn = min ( arr , l , h ) ; let mx = max ( arr , l , h ) ; if ( 2 * mn > mx ) return 0 ; return Math . min ( minRemovals ( arr , l + 1 , h ) , minRemovals ( arr , l , h - 1 ) ) + 1 ; } let arr = [ 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 ] ; let n = arr . length ; document . write ( minRemovals ( arr , 0 , n - 1 ) ) ;
function numberOfPaths ( m , n ) { var count = Array ( m ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( i = 0 ; i < m ; i ++ ) count [ i ] [ 0 ] = 1 ; for ( j = 0 ; j < n ; j ++ ) count [ 0 ] [ j ] = 1 ; for ( i = 1 ; i < m ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] + count [ i - 1 ] [ j - 1 ] ; ; } return count [ m - 1 ] [ n - 1 ] ; } document . write ( numberOfPaths ( 3 , 3 ) ) ;
function maxProd ( n ) { if ( n == 0 n == 1 ) return 0 ; let max_val = 0 ; for ( let i = 1 ; i < n ; i ++ ) { max_val = Math . max ( max_val , Math . max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) ; } return max_val ; } document . write ( " " + maxProd ( 10 ) ) ;
const NUM_LINE = 2 ; const NUM_STATION = 4 ; function min ( a , b ) { return a < b ? a : b ; } function carAssembly ( a , t , e , x ) { let T1 = new Array ( NUM_STATION ) ; let T2 = new Array ( NUM_STATION ) ; let i ; T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] ; T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] ; for ( i = 1 ; i < NUM_STATION ; ++ i ) { T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) ; T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) ; } return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) ; } let a = [ [ 4 , 5 , 3 , 2 ] , [ 2 , 10 , 1 , 4 ] ] ; let t = [ [ 0 , 7 , 4 , 5 ] , [ 0 , 9 , 2 , 8 ] ] ; let e = [ 10 , 12 ] , x = [ 18 , 7 ] ; document . write ( carAssembly ( a , t , e , x ) ) ;
function LCSubStr ( X , Y , m , n ) { var LCStuff = Array ( m + 1 ) . fill ( ) . map ( ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var result = 0 ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) LCStuff [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) { LCStuff [ i ] [ j ] = LCStuff [ i - 1 ] [ j - 1 ] + 1 ; result = Math . max ( result , LCStuff [ i ] [ j ] ) ; } else LCStuff [ i ] [ j ] = 0 ; } } return result ; } var X = " " ; var Y = " " ; var m = X . length ; var n = Y . length ; document . write ( " " + LCSubStr ( X , Y , m , n ) ) ;
function max ( a , b ) { return ( a > b ) ? a : b ; } function max ( a , b , c ) { return Math . max ( Math . max ( a , b ) , c ) ; } function maxCrossingSum ( arr , l , m , h ) { let sum = 0 ; let left_sum = Number . MIN_VALUE ; for ( let i = m ; i >= l ; i -- ) { sum = sum + arr [ i ] ; if ( sum > left_sum ) left_sum = sum ; } sum = 0 ; let right_sum = Number . MIN_VALUE ; for ( let i = m + 1 ; i <= h ; i ++ ) { sum = sum + arr [ i ] ; if ( sum > right_sum ) right_sum = sum ; } return max ( left_sum + right_sum , left_sum , right_sum ) ; } function maxSubArraySum ( arr , l , h ) { if ( l == h ) return arr [ l ] ; let m = parseInt ( ( l + h ) / 2 , 10 ) ; return max ( maxSubArraySum ( arr , l , m ) , maxSubArraySum ( arr , m + 1 , h ) , maxCrossingSum ( arr , l , m , h ) ) ; } let arr = [ 2 , 3 , 4 , 5 , 7 ] ; let n = arr . length ; let max_sum = maxSubArraySum ( arr , 0 , n - 1 ) ; document . write ( " " + max_sum ) ;
function findWater ( i , j , X ) { if ( j > i ) { document . write ( " " ) ; } var ll = Math . round ( ( i * ( i + 1 ) ) ) ; glass = Array . from ( { length : ll + 2 } , ( _ , i ) => 0.0 ) ; var index = 0 ; glass [ index ] = X ; for ( row = 1 ; row <= i ; ++ row ) { for ( col = 1 ; col <= row ; ++ col , ++ index ) { X = glass [ index ] ; glass [ index ] = ( X >= 1.0 ) ? 1.0 : X ; X = ( X >= 1.0 ) ? ( X - 1 ) : 0.0 ; glass [ index + row ] += X / 2 ; glass [ index + row + 1 ] += X / 2 ; } } return glass [ parseInt ( ( i * ( i - 1 ) / 2 + j - 1 ) ) ] ; } var i = 2 , j = 2 ; var X = 2.0 ; document . write ( " " + " " + findWater ( i , j , X ) ) ;
function doMatch ( A , B ) { for ( i = 0 ; i < A . length ; i ++ ) { if ( A . charAt ( i ) != ' ' && B . charAt ( i ) != ' ' ) { if ( A . charAt ( i ) != B . charAt ( i ) ) return 0 ; } } return 1 ; } var A = " " ; var B = " " ; document . write ( doMatch ( A , B ) ) ;
function nthTerm ( N ) { return parseInt ( ( N + N * ( N - 1 ) ) / 2 ) ; } let N = 5 ; document . write ( nthTerm ( N ) ) ;
function countSubstrs ( s1 , s2 ) { var ans = 0 ; for ( var i = 0 ; i < s1 . length ; i ++ ) { var s3 = " " ; var s4 = s1 ; for ( var j = i ; j < s1 . length ; j ++ ) { s3 += s4 [ j ] ; if ( s2 . indexOf ( s3 ) != - 1 ) ans ++ ; } } return ans ; } var s1 = " " , s2 = " " ; document . write ( countSubstrs ( s1 , s2 ) ) ;
function factorial ( N ) { let fact = 1 ; for ( let i = 1 ; i <= N ; i ++ ) fact = fact * i ; return fact ; } function nthTerm ( N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; } let N = 6 ; document . write ( nthTerm ( N ) ) ;
function regexMatch ( text , pat ) { let lenText = text . length ; let lenPat = pat . length ; let Text = text . split ( " " ) ; let Pat = pat . split ( " " ) ; let i = 0 , j = 0 ; while ( i < lenPat ) { if ( Pat [ i ] != ' ' ) { if ( Pat [ i ] != Text [ j ] ) return false ; i ++ ; j ++ ; } else { j ++ ; while ( Text [ j ] != Pat [ i + 1 ] ) j ++ ; i ++ ; } } return ( j == lenText ) ; } let str = " " ; let pat = " " ; if ( regexMatch ( str , pat ) ) document . write ( " " ) ; else document . write ( " " ) ;
function factorial ( n ) { if ( n <= 1 ) return 1 ; return n * factorial ( n - 1 ) ; } function nCr ( n , r ) { return factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ; } function NumberOfWays ( n , x , y ) { return nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ; } var n = 5 , x = 4 , y = 2 ; document . write ( NumberOfWays ( n , x , y ) ) ;
function count_pairs ( a , b , n , m ) { var odd1 = 0 , even1 = 0 ; var odd2 = 0 , even2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) odd1 ++ ; else even1 ++ ; } for ( i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 == 1 ) odd2 ++ ; else even2 ++ ; } var pairs = Math . min ( odd1 , odd2 ) + Math . min ( even1 , even2 ) ; return pairs ; } var a = [ 9 , 14 , 6 , 2 , 11 ] ; var b = [ 8 , 4 , 7 , 20 ] ; var n = a . length ; var m = b . length ; document . write ( count_pairs ( a , b , n , m ) ) ;
function getValueOfF ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; let cnt = 0 ; while ( n % 2 == 0 ) { cnt += 1 ; n = parseInt ( n / 2 , 10 ) ; } return 2 * cnt ; } let n = 20 ; document . write ( getValueOfF ( n ) ) ;
function A_mod_B ( N , a ) { var len = N . length ; var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) ans = ( ans * 10 + parseInt ( N . charAt ( i ) - ' ' ) ) % a ; return ans % a ; } function findMod ( N ) { var mod = A_mod_B ( N , 4 ) ; var ans = ( 1 + parseInt ( Math . pow ( 2 , mod ) + Math . pow ( 3 , mod ) + Math . pow ( 4 , mod ) ) ) ; return ( ans % 5 ) ; } var N = " " ; document . write ( findMod ( N ) ) ;
function printElements ( arr , n ) { for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) document . write ( arr [ i ] + " " ) ; } } var arr = [ 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ] ; var n = arr . length ; printElements ( arr , n ) ;
function exponent ( A , B ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; let y ; if ( B % 2 == 0 ) { y = exponent ( A , parseInt ( B / 2 , 10 ) ) ; y = ( y * y ) ; } else { y = A ; y = ( y * exponent ( A , B - 1 ) ) ; } return y ; } function sum ( k , n ) { let sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; return sum ; } let n = 3 ; let K = 3 ; document . write ( sum ( K , n ) ) ;
function isPrime ( x ) { for ( let i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return 0 ; } return 1 ; } function minimumCost ( n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 1 && isPrime ( n - 2 ) ) return 2 ; if ( n % 2 == 0 ) return 2 ; return 3 ; } let n = 6 ; document . write ( minimumCost ( n ) ) ;
function wastedWater ( V , M , N ) { let wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; } let V , M , N ; V = 700 ; M = 10 ; N = 3 ; document . write ( wastedWater ( V , M , N ) , " " ) ; V = 1000 ; M = 100 ; N = 50 ; document . write ( wastedWater ( V , M , N ) ) ;
function nDigitPerfectCubes ( n ) { document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n - 1 ) ) ) ) , 3 ) + " " ) ; document . write ( Math . pow ( Math . ceil ( Math . cbrt ( Math . pow ( 10 , ( n ) ) ) ) - 1 , 3 ) ) ; } let n = 3 ; nDigitPerfectCubes ( n ) ;
function countNumbers ( n ) { return ( n / 2520 ) ; } var n = 3000 ; document . write ( Math . round ( countNumbers ( n ) ) ) ;
var MAX = 100001 ; prefix = Array ( MAX ) . fill ( 0 ) function sieve_modified ( ) { for ( var i = 1 ; i < MAX ; i += 2 ) { for ( var j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( var i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; } function sumOddFactors ( L , R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; } sieve_modified ( ) ; var l = 6 , r = 10 ; document . write ( sumOddFactors ( l , r ) ) ;
var n = 3 ; function preComputeXor ( arr , prefix_xor ) { for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) { if ( j == 0 ) prefix_xor [ i ] [ j ] = arr [ i ] [ j ] ; else prefix_xor [ i ] [ j ] = ( prefix_xor [ i ] [ j - 1 ] ^ arr [ i ] [ j ] ) ; } for ( i = 0 ; i < n ; i ++ ) for ( j = 1 ; j < n ; j ++ ) prefix_xor [ j ] [ i ] = ( prefix_xor [ j - 1 ] [ i ] ^ prefix_xor [ j ] [ i ] ) ; } function ansQuerie ( prefix_xor , x1 , y1 , x2 , y2 ) { var xor_1 = 0 , xor_2 = 0 , xor_3 = 0 ; if ( x1 != 0 ) xor_1 = prefix_xor [ x1 - 1 ] [ y2 ] ; if ( y1 != 0 ) xor_2 = prefix_xor [ x2 ] [ y1 - 1 ] ; if ( x1 != 0 && y1 != 0 ) xor_3 = prefix_xor [ x1 - 1 ] [ y1 - 1 ] ; return ( ( prefix_xor [ x2 ] [ y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) ; } var arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; var prefix_xor = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) prefix_xor [ i ] = Array ( n ) . fill ( 0 ) ; preComputeXor ( arr , prefix_xor ) ; document . write ( ansQuerie ( prefix_xor , 1 , 1 , 2 , 2 ) + " " ) ; document . write ( ansQuerie ( prefix_xor , 1 , 2 , 2 , 2 ) ) ;
function isDigitSumOne ( nm ) { if ( nm % 9 == 1 ) return true ; else return false ; } function printValidNums ( n ) { let cbrt_n = Math . ceil ( Math . pow ( n , 1 / 3 ) ) ; for ( let i = 1 ; i <= cbrt_n ; i ++ ) { let cube = Math . pow ( i , 3 ) ; if ( cube >= 1 && cube <= n && isDigitSumOne ( cube ) ) document . write ( cube + " " ) ; } } let n = 1000 ; printValidNums ( n ) ;
function countRhombi ( h , w ) { let ct = 0 ; for ( let i = 2 ; i <= h ; i += 2 ) for ( let j = 2 ; j <= w ; j += 2 ) ct += ( h - i + 1 ) * ( w - j + 1 ) ; return ct ; } let h = 2 , w = 2 ; document . write ( countRhombi ( h , w ) ) ;
function calculateArea ( x , y ) { var pi = 3.1415926536 ; var arx = pi * x * x ; var ary = pi * y * y ; return arx - ary ; } var x = 2 ; var y = 1 ; document . write ( calculateArea ( x , y ) ) ;
function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } function getWinner ( arr , n ) { let gcd = arr [ 0 ] ; let maxEle = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { gcd = __gcd ( gcd , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } let totalMoves = parseInt ( maxEle / gcd , 10 ) - n ; if ( totalMoves % 2 == 1 ) return ' ' ; return ' ' ; } let arr = [ 5 , 6 , 7 ] ; let n = arr . length ; document . write ( getWinner ( arr , n ) ) ;
function countPairs ( n ) { let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { let val = ( ( n % i ) % j ) % n ; if ( val == max ) count ++ ; } } return count ; } let n = 5 ; document . write ( countPairs ( n ) ) ;
function isDivisible ( n ) { temp = n ; while ( n ) { k = n % 10 ; if ( temp % k == 0 ) return " " ; n = Math . floor ( n / 10 ) ; } return " " ; } let n = 9876543 ; document . write ( isDivisible ( n ) ) ;
function sum ( n ) { let i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } let n = 5 ; document . write ( " " + sum ( n ) ) ;
var N = 100005 ; function ABUNDANT ( ) { var v = new Set ( ) ; var i , j ; for ( i = 1 ; i < N ; i ++ ) { var sum = 1 ; for ( j = 2 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { sum += j ; if ( parseInt ( i / j ) != j ) sum += parseInt ( i / j ) ; } } if ( sum > i ) v . add ( i ) ; } return v ; } function SumOfAbundant ( n ) { var v = new Set ( ) ; v = ABUNDANT ( ) ; var i ; for ( i = 1 ; i <= n ; i ++ ) { if ( v . has ( i ) && v . has ( n - i ) ) { document . write ( i + ' ' + ( n - i ) ) return ; } } document . write ( - 1 ) ; } var n = 24 ; SumOfAbundant ( n ) ;
function nthTermOfTheSeries ( n ) { let nthTerm ; if ( n % 2 == 0 ) nthTerm = Math . pow ( n - 1 , 2 ) + n ; else nthTerm = Math . pow ( n + 1 , 2 ) + n ; return nthTerm ; } let n ; n = 8 ; document . write ( nthTermOfTheSeries ( n ) + " " ) ; n = 12 ; document . write ( nthTermOfTheSeries ( n ) + " " ) ; n = 102 ; document . write ( nthTermOfTheSeries ( n ) + " " ) ; n = 999 ; document . write ( nthTermOfTheSeries ( n ) + " " ) ; n = 9999 ; document . write ( nthTermOfTheSeries ( n ) + " " ) ;
function CPwithProfit ( sellingPrice , profit ) { var costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 + profit ) ; return costPrice ; } function CPwithLoss ( sellingPrice , loss ) { var costPrice ; costPrice = ( sellingPrice * 100 ) / ( 100 - loss ) ; return costPrice ; } var SP , profit , loss ; SP = 1020 ; profit = 20 ; document . write ( " " + CPwithProfit ( SP , profit ) + " " ) ; SP = 900 ; loss = 10 ; document . write ( " " + CPwithLoss ( SP , loss ) + " " ) ; SP = 42039 ; profit = 8 ; document . write ( " " + CPwithProfit ( SP , profit ) + " " ) ;
function obtain_str ( n ) { let len = Math . floor ( ( Math . log ( n + 1 ) / Math . log ( 2 ) ) ) ; let rel_ind = n + 1 - Math . pow ( 2 , len ) ; let i = 0 ; let str = [ ] ; for ( i = 0 ; i < len ; i ++ ) { str . push ( ' ' ) ; } i = 0 ; while ( rel_ind > 0 ) { if ( rel_ind % 2 == 1 ) str [ i ] = ' ' ; rel_ind = parseInt ( rel_ind / 2 , 10 ) ; i ++ ; } return reverse ( str . join ( " " ) ) ; } function reverse ( input ) { let a = input . split ( ' ' ) ; let l , r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { let temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return a . join ( " " ) ; } let n = 11 ; document . write ( obtain_str ( n ) ) ;
function Nthterm ( n ) { let numerator = Math . pow ( n , 2 ) - 1 ; let denomenator = 2 * n - 3 ; document . write ( numerator + " " + denomenator ) ; } let n = 3 ; Nthterm ( n ) ;
function getSum ( arr , p ) { return arr . length ; } let arr = [ 5 , 6 , 8 ] ; let p = 7 ; document . write ( getSum ( arr , p ) ) ;
function SquareCube ( N ) { let cnt = 0 , i = 1 ; while ( Math . floor ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; } let N = 100000 ; document . write ( SquareCube ( N ) ) ;
function getSum ( n , d ) { let sum = 0 ; while ( d <= n ) { sum += d ; d += 10 ; } return sum ; } let n = 30 ; let d = 3 ; document . write ( getSum ( n , d ) ) ;
function sum ( N ) { let MOD = 1000000007 ; let val = N * ( N + 1 ) ; val = val % MOD ; return val ; } function sumX ( N , M , K ) { let MOD = 1000000007 ; for ( let i = 0 ; i < M ; i ++ ) { N = sum ( K + N ) ; } N = N % MOD ; return N ; } let N = 1 ; let M = 2 ; let K = 3 ; document . write ( sumX ( N , M , K ) ) ;
function checkIsHP ( arr ) { let n = arr . length ; if ( n == 1 ) { return true ; } let rec = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { rec . push ( ( 1 / arr [ i ] ) ) ; } rec . sort ( ( a , b ) => a - b ) ; let d = ( rec [ 1 ] ) - ( rec [ 0 ] ) ; for ( let i = 2 ; i < n ; i ++ ) { if ( rec [ i ] - rec [ i - 1 ] != d ) { return false ; } } return true ; } let arr = [ 1 / 5 , 1 / 10 , 1 / 15 , 1 / 20 , 1 / 25 ] ; if ( checkIsHP ( arr ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function printAMeans ( A , B , N ) { let d = ( B - A ) / ( N + 1 ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( ( A + i * d ) + " " ) ; } let A = 20 , B = 32 , N = 5 ; printAMeans ( A , B , N ) ;
function primeFactors ( n ) { while ( n % 2 == 0 ) { document . write ( 2 + " " ) ; n = Math . floor ( n / 2 ) ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { document . write ( i + " " ) ; n = Math . floor ( n / i ) ; } } if ( n > 2 ) document . write ( n + " " ) ; } let n = 315 ; primeFactors ( n ) ;
function startingPoint ( Length , Speed1 , Speed2 ) { var result1 = 0 , result2 = 0 ; var time1 = Length / Speed1 ; var time2 = Length / Speed2 ; result1 = __gcd ( time1 , time2 ) ; result2 = time1 * time2 / ( result1 ) ; return result2 ; } function __gcd ( a , b ) { if ( b == 0 ) { return a ; } return __gcd ( b , a % b ) ; } function firstTime ( Length , Speed1 , Speed2 ) { var result = 0 ; var relativeSpeed = Math . abs ( Speed1 - Speed2 ) ; result = ( Length / relativeSpeed ) ; return result ; } var L = 30 , S1 = 5 , S2 = 2 ; var first_Time = firstTime ( L , S1 , S2 ) ; var starting_Povar = startingPoint ( L , S1 , S2 ) ; document . write ( " " + first_Time + " " ) ; document . write ( " " + starting_Povar + " " ) ;
function CheckArray ( arr , n ) { let prod = 1 ; for ( let i = 0 ; i < n ; ++ i ) prod *= arr [ i ] ; for ( let i = 0 ; i < n ; ++ i ) if ( arr [ i ] == prod / arr [ i ] ) return true ; return false ; } let arr = [ 1 , 2 , 12 , 3 , 2 ] ; let n = arr . length ; if ( CheckArray ( arr , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function sum ( a , b ) { var sum = 0 ; for ( var i = 1 ; i <= Math . min ( a , b ) ; i ++ ) if ( a % i == 0 && b % i == 0 ) sum += i ; return sum ; } var A = 10 , B = 15 ; document . write ( " " + sum ( A , B ) + " " ) ;
function findgcd ( a , b ) { if ( b == 0 ) return a ; return findgcd ( b , a % b ) ; } function minimumCuts ( a , n ) { a . sort ( ) ; var gcd = a [ 1 ] - a [ 0 ] ; var s = gcd ; for ( i = 2 ; i < n ; i ++ ) { gcd = findgcd ( gcd , a [ i ] - a [ i - 1 ] ) ; s += a [ i ] - a [ i - 1 ] ; } if ( 360 - s > 0 ) gcd = findgcd ( gcd , 360 - s ) ; return ( 360 / gcd ) - n ; } var arr = [ 30 , 60 , 180 ] ; var n = arr . length ; document . write ( minimumCuts ( arr , n ) ) ;
function SellingPrice ( CP , PP ) { var P_decimal = 1 + ( PP / 100 ) ; var res = P_decimal * CP ; return res . toFixed ( 1 ) ; } var C = 720 , P = 13 ; document . write ( SellingPrice ( C , P ) ) ;
function compositeProduct ( arr , n ) { let max_val = arr . sort ( ( A , B ) => B - A ) [ 0 ] ; let prime = new Array ( max_val + 1 ) . fill ( true ) ; prime [ 0 ] = true ; prime [ 1 ] = true ; for ( let p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( ! prime [ arr [ i ] ] ) { product *= arr [ i ] ; } return product ; } let arr = new Array ( 2 , 3 , 4 , 5 , 6 , 7 ) ; let n = arr . length ; document . write ( compositeProduct ( arr , n ) ) ;
function sum_odd ( n ) { let sum = 0 , pos = 1 ; while ( n ) { if ( pos % 2 == 1 ) sum += n % 10 ; n = Math . floor ( n / 10 ) ; pos ++ ; } return sum ; } function check_prime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } let n = 223 ; let sum = sum_odd ( n ) ; if ( check_prime ( sum ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function findAmount ( X , W , Y ) { return ( X * ( Y - W ) ) / ( 100 - Y ) ; } let X = 100 , W = 50 , Y = 60 ; document . write ( " " + findAmount ( X , W , Y ) . toFixed ( 2 ) ) ;
function reverseNum ( x ) { let s = x . toString ( ) ; let str = " " ; for ( let i = s . length - 1 ; i >= 0 ; i -- ) { str = str + s [ i ] ; } let rev = parseInt ( str ) ; return rev ; } function isMysteryNumber ( n ) { for ( let i = 1 ; i <= Math . floor ( n / 2 ) ; i ++ ) { let j = reverseNum ( i ) ; if ( i + j == n ) { document . write ( i + " " + j + " " ) ; return true ; } } document . write ( " " ) ; return false ; } let n = 121 ; isMysteryNumber ( n ) ;
function ReplaceElements ( arr , n ) { let prod = 1 ; for ( let i = 0 ; i < n ; ++ i ) { prod *= arr [ i ] ; } for ( let i = 0 ; i < n ; ++ i ) { arr [ i ] = parseInt ( prod / arr [ i ] , 10 ) ; } } let arr = [ 2 , 3 , 3 , 5 , 7 ] ; let n = arr . length ; ReplaceElements ( arr , n ) ; for ( let i = 0 ; i < n ; ++ i ) { document . write ( arr [ i ] + " " ) ; }
function Check_is_possible ( l , r , k ) { var count = 0 ; for ( i = l ; i <= r ; i ++ ) { if ( i % k == 0 ) { count ++ ; } } return ( count > 1 ) ; } var l = 4 , r = 12 ; var k = 5 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function sum ( N ) { var S1 , S2 , S3 ; S1 = ( ( ( N / 2 ) ) * parseInt ( 2 * 2 + parseInt ( N / 2 - 1 ) * 2 ) / 2 ) ; S2 = ( parseInt ( parseInt ( N / 7 ) ) * ( 2 * 7 + parseInt ( N / 7 - 1 ) * 7 ) / 2 ) ; S3 = ( parseInt ( parseInt ( N / 14 ) ) * ( 2 * 14 + parseInt ( N / 14 - 1 ) * 14 ) / 2 ) ; return S1 + S2 - S3 ; } var N = 20 ; document . write ( sum ( N ) ) ;
function fastPow ( N , K ) { if ( K == 0 ) return 1 ; let temp = fastPow ( N , Math . floor ( K / 2 ) ) ; if ( K % 2 == 0 ) return temp * temp ; else return N * temp * temp ; } function countWays ( N , K ) { return K * fastPow ( K - 1 , N - 1 ) ; } let N = 3 , K = 3 ; document . write ( countWays ( N , K ) ) ;
function sumNth ( A , B , m , n ) { var res = 0 ; if ( n == 1 ) { for ( let i = 0 ; i < m ; i ++ ) res = res + A [ i ] ; } else if ( n == 2 ) { for ( let i = 0 ; i < m ; i ++ ) res = res + B [ i ] * m ; } else { var f = Array ( n ) . fill ( 0 ) ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( let i = 2 ; i < n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; for ( i = 0 ; i < m ; i ++ ) { res = res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ; } } return res ; } var A = [ 1 , 2 , 3 ] ; var B = [ 4 , 5 , 6 ] ; var n = 3 ; var m = A . length ; document . write ( sumNth ( A , B , m , n ) ) ;
var a = 5 ; var AC = a ; var CE = 2 * a ; var shortestDistace = Math . sqrt ( AC * AC + CE * CE ) ; document . write ( shortestDistace . toFixed ( 4 ) ) ;
function sum_of_series ( n ) { let result = 0 ; if ( n % 2 == 0 ) { result = - ( n * ( n + 1 ) ) / 2 ; } else { result = ( n * ( n + 1 ) ) / 2 ; } return result ; } let n = 3 ; document . write ( sum_of_series ( n ) + " " ) ; n = 10 ; document . write ( sum_of_series ( n ) ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } function isCousinPrime ( n1 , n2 ) { if ( Math . abs ( n1 - n2 ) != 4 ) return false ; else return ( isPrime ( n1 ) && isPrime ( n2 ) ) ; } var n1 = 7 , n2 = 11 ; if ( isCousinPrime ( n1 , n2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isPowerOfTwo ( n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; } function isThabitNumber ( n ) { n = n + 1 ; if ( n % 3 == 0 ) n = n / 3 ; else return false ; if ( isPowerOfTwo ( n ) ) return true ; else return false ; } var n = 47 ; if ( isThabitNumber ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findMinEqualSums ( a , N ) { let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += a [ i ] ; } let sum1 = 0 , sum2 = 0 ; let min = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { sum1 += a [ i ] ; sum2 = sum - sum1 ; if ( Math . abs ( sum1 - sum2 ) < min ) { min = Math . abs ( sum1 - sum2 ) ; } if ( min == 0 ) { break ; } } return min ; } let a = [ 3 , 2 , 1 , 5 , 7 , 8 ] ; let N = a . length ; document . write ( findMinEqualSums ( a , N ) ) ;
function CountDigits ( n ) { if ( n == 1 ) return 1 ; var sum = 0 ; for ( i = 2 ; i <= n ; ++ i ) { sum += ( Math . log ( i ) / Math . log ( 10 ) ) ; } sum *= n ; return Math . ceil ( sum ) ; } var N = 5 ; document . write ( CountDigits ( N ) ) ;
let MAX = 200006 ; let CONS = 32766 ; function calc ( a , b , lr , q , n ) { let M , m , i , j , k , l , r , suma , sumb , cc ; cc = 0 ; for ( i = 0 ; i < n - 1 ; ++ i ) { a [ i + 1 ] += a [ i ] ; b [ i + 1 ] += b [ i ] ; } while ( q != 0 ) { l = lr [ cc ++ ] ; r = lr [ cc ++ ] ; l -= 2 ; r -= 1 ; suma = a [ r ] ; sumb = b [ r ] ; if ( l >= 0 ) { suma -= a [ l ] ; sumb -= b [ l ] ; } M = Math . max ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) ; M = Math . max ( M , Math . max ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) ; m = Math . min ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) ; m = Math . min ( m , Math . min ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) ; document . write ( ( M - m ) + " " ) ; q -- ; } } let n = 5 , q = 2 ; let a = [ 0 , 7 , 3 , 4 , 5 ] ; let b = [ 0 , 3 , 1 , 2 , 3 ] ; let lr = new Array ( q * 2 ) ; lr [ 0 ] = 1 ; lr [ 1 ] = 1 ; lr [ 2 ] = 1 ; lr [ 3 ] = 3 ; calc ( a , b , lr , q , n ) ;
function NthTerm ( n ) { let x = ( 3 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; } let N = 4 ; document . write ( NthTerm ( N ) ) ;
power = Array ( 31 ) . fill ( 0 ) ; pre = Array ( 31 ) . fill ( 0 ) ; function PowerOfTwo ( ) { var x = 1 ; for ( i = 0 ; i < 31 ; i ++ ) { power [ i ] = x ; x *= 2 ; } pre [ 0 ] = 1 ; for ( i = 1 ; i < 31 ; i ++ ) pre [ i ] = pre [ i - 1 ] + power [ i ] ; } function Sum ( n ) { var ans = n * ( n + 1 ) / 2 ; for ( i = 0 ; i < 31 ; i ++ ) { if ( power [ i ] > n ) { ans -= 2 * pre [ i - 1 ] ; break ; } } return ans ; } PowerOfTwo ( ) ; var n = 4 ; document . write ( Sum ( n ) ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } var n = 17 ; if ( isPrime ( n ) && ( n % 16 == 1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function findNumber ( n ) { for ( i = n - 1 ; i >= 0 ; i -- ) { var count = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; var x = i ; var count1 = 0 , count2 = 0 ; while ( x > 0 ) { count [ x % 10 ] ++ ; x = parseInt ( x / 10 ) ; count1 ++ ; } for ( j = 0 ; j < 10 ; j ++ ) { if ( count [ j ] == 1 ) count2 ++ ; } if ( count1 == count2 ) return i ; } return - 1 ; } var n = 8490 ; document . write ( findNumber ( n ) ) ;
function SieveOfEratosthenes ( n , isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( var i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( var p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( var i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } function findPrimePair ( n ) { var flag = 0 ; var isPrime = [ ] SieveOfEratosthenes ( n , isPrime ) ; for ( var i = 2 ; i < n ; i ++ ) { var x = n / i ; if ( isPrime [ i ] && isPrime [ x ] && x != i && x * i == n ) { document . write ( i + " " + x ) ; flag = 1 ; return ; } } if ( flag == 0 ) document . write ( " " ) ; } var n = 39 ; findPrimePair ( n ) ;
function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } function solveProportion ( a , b1 , b2 , c ) { let A = a * b2 ; let B = b1 * b2 ; let C = b1 * c ; let gcd = __gcd ( __gcd ( A , B ) , C ) ; document . write ( A / gcd + " " + B / gcd + " " + C / gcd ) ; } let a , b1 , b2 , c ; a = 3 ; b1 = 4 ; b2 = 8 ; c = 9 ; solveProportion ( a , b1 , b2 , c ) ;
function countDivisors ( n , k ) { var count = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { if ( n % i == 0 && i % k == 0 ) { count ++ ; } } return count ; } var n = 12 , k = 3 ; document . write ( countDivisors ( n , k ) ) ;
const pi = 3.14159 ; function volume ( r , h ) { return ( ( 1 ) / ( 3 ) ) * pi * r * r * h ; } function surface_area ( r , s ) { return pi * r * s + pi * r * r ; } let radius = 5 ; let slant_height = 13 ; let height = 12 ; let vol , sur_area ; document . write ( " " + volume ( radius , height ) . toFixed ( 2 ) + " " ) ; document . write ( " " + surface_area ( radius , slant_height ) . toFixed ( 2 ) + " " ) ;
function nthTerm ( n ) { return 6 * Math . pow ( n , 2 ) - 4 * n - 2 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function nthTerm ( n ) { return Math . pow ( n , 2 ) + 2 * n + 2 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function sum ( n ) { let ans = parseInt ( ( n * ( n - 1 ) ) / 2 ) ; return ans ; } let n = 5 ; document . write ( sum ( n ) ) ;
function getNthTerm ( N ) { return 4 * Math . pow ( N , 2 ) - 3 * N + 2 ; } let N = 10 ; document . write ( getNthTerm ( N ) ) ;
var MOD = 100000007 ; function power ( x , y , p ) { var res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function sumProd ( n , t ) { var dino = power ( t + 1 , MOD - 2 , MOD ) ; var ans = 1 ; for ( var i = n + t + 1 ; i > n ; -- i ) ans = ( ans % MOD * i % MOD ) % MOD ; var tfact = 1 ; for ( var i = 1 ; i <= t ; ++ i ) tfact = ( tfact * i ) % MOD ; ans = ans * dino - tfact + MOD ; return ans % MOD ; } var n = 3 , t = 2 ; document . write ( sumProd ( n , t ) ) ;
function calculateSum ( n ) { return ( n * ( parseInt ( Math . pow ( n , 2 ) + 3 * n + 5 ) ) / 3 ) ; } var n = 25 ; document . write ( calculateSum ( n ) ) ;
var mod = 107 ; function power ( a , b ) { var res = 1 ; while ( b != 0 ) { if ( ( b & 1 ) != 0 ) { res *= a ; res = res % mod ; } b = parseInt ( b / 2 ) ; a *= a ; a %= mod ; } return res ; } function minPlayer ( n , k ) { var num = ( ( power ( k , n ) - 1 ) + mod ) % mod ; var den = ( power ( k - 1 , mod - 2 ) + mod ) % mod ; var ans = ( ( ( num * den ) % mod ) * k ) % mod ; return ans ; } var n = 3 , k = 3 ; document . write ( minPlayer ( n , k ) ) ;
function sieveOfEratosthenes ( N , s ) { let prime = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) prime [ i ] = false ; for ( let i = 2 ; i <= N ; i += 2 ) s [ i ] = 2 ; for ( let i = 3 ; i <= N ; i += 2 ) { if ( prime [ i ] == false ) { s [ i ] = i ; for ( let j = i ; j * i <= N ; j += 2 ) { if ( prime [ i * j ] == false ) { prime [ i * j ] = true ; s [ i * j ] = i ; } } } } } function findSum ( N ) { let s = new Array ( N + 1 ) ; let ans = 1 ; sieveOfEratosthenes ( N , s ) ; let currFactor = s [ N ] ; let power = 1 ; while ( N > 1 ) { N = Math . floor ( N / s [ N ] ) ; if ( currFactor == s [ N ] ) { power ++ ; continue ; } let sum = 0 ; for ( let i = 0 ; i <= power ; i ++ ) sum += Math . pow ( currFactor , i ) ; ans *= sum ; currFactor = s [ N ] ; power = 1 ; } return ans ; } let n = 12 ; document . write ( " " ) ; document . write ( findSum ( n ) ) ;
function count_setbits ( N ) { var cnt = 0 ; while ( N > 0 ) { cnt += ( N & 1 ) ; N = N >> 1 ; } return cnt ; } function countMultiples ( n ) { var multiple = [ 2 , 3 , 5 ] ; var count = 0 , mask = parseInt ( Math . pow ( 2 , 3 ) ) ; for ( i = 1 ; i < mask ; i ++ ) { var prod = 1 ; for ( j = 0 ; j < 3 ; j ++ ) { if ( ( i & 1 << j ) > 0 ) prod = prod * multiple [ j ] ; } if ( count_setbits ( i ) % 2 == 1 ) count = count + parseInt ( n / prod ) ; else count = count - parseInt ( n / prod ) ; } return count ; } var n = 10 ; document . write ( countMultiples ( n ) ) ;
function findN ( k ) { var ans ; if ( k == 0 ) ans = 3 ; if ( k == 1 ) ans = 1 ; else if ( k % 4 == 0 ) ans = k ; else if ( k % 4 == 3 ) ans = k - 1 ; else ans = - 1 ; return ans ; } var k = 7 ; var res = findN ( k ) ; if ( res == - 1 ) document . write ( " " ) ; else document . write ( res ) ;
function Circular ( n ) { var Result = 1 ; while ( n > 0 ) { Result = Result * n ; n -- ; } return Result ; } var n = 4 ; document . write ( Circular ( n - 1 ) ) ;
function calTime ( arr , n ) { var work = 0 ; for ( i = 0 ; i < n ; i ++ ) work += 1 / arr [ i ] ; return 1 / work ; } var arr = [ 6.0 , 3.0 , 4.0 ] ; var n = arr . length ; document . write ( calTime ( arr , n ) . toFixed ( 5 ) + " " ) ;
function printTwins ( low , high ) { let prime = new Array ( high + 1 ) ; let twin = false ; for ( let i = 0 ; i < high + 1 ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( let p = 2 ; p <= Math . floor ( Math . sqrt ( high ) ) + 1 ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= high ; i += p ) prime [ i ] = false ; } } for ( let i = high ; i >= low ; i -- ) { if ( prime [ i ] && ( i - 2 >= low && prime [ i - 2 ] == true ) ) { document . write ( " " + ( i - 2 ) + " " + ( i ) + " " + " " ) ; twin = true ; break ; } } if ( twin == false ) document . write ( " " ) ; } printTwins ( 10 , 100 ) ;
function prevComplement ( n , b ) { var maxDigit , maxNum = 0 , digits = 0 , num = n ; while ( n != 0 ) { digits ++ ; n = parseInt ( n / 10 ) ; } maxDigit = b - 1 ; while ( ( digits -- ) > 0 ) { maxNum = maxNum * 10 + maxDigit ; } return maxNum - num ; } function complement ( n , b ) { return prevComplement ( n , b ) + 1 ; } document . write ( prevComplement ( 25 , 7 ) + " " ) ; document . write ( complement ( 25 , 7 ) ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } var a = 2 ; var b = 4 ; document . write ( gcd ( a , b ) ) ;
function MaximumDivisors ( X , Y ) { let arr = new Array ( Y - X + 1 ) ; for ( let i = 0 ; i < arr . length ; i ++ ) arr [ i ] = 0 ; let mx = 0 ; let cnt = 0 ; for ( let i = 1 ; i * i <= Y ; i ++ ) { let sq = i * i ; let first_divisible ; if ( Math . floor ( X / i ) * i >= X ) first_divisible = Math . floor ( X / i ) * i ; else first_divisible = ( Math . floor ( X / i ) + 1 ) * i ; for ( let j = first_divisible ; j <= Y ; j += i ) { if ( j < sq ) continue ; else if ( j == sq ) arr [ j - X ] ++ ; else arr [ j - X ] += 2 ; } } for ( let i = X ; i <= Y ; i ++ ) { if ( arr [ i - X ] > mx ) { cnt = 1 ; mx = arr [ i - X ] ; } else if ( arr [ i - X ] == mx ) cnt ++ ; } return cnt ; } let X = 1 , Y = 10 ; document . write ( MaximumDivisors ( X , Y ) ) ;
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function NearestElement ( A , D , P ) { if ( A == 0 ) return 0 ; else if ( D == 0 ) return - 1 ; else { let X = power ( D , P - 2 , P ) ; return ( X * ( P - A ) ) % P ; } } let A = 4 , D = 9 , P = 11 ; A %= P ; D %= P ; document . write ( NearestElement ( A , D , P ) ) ;
function print_C ( p0 ) { let p1 = 0 ; let i = 0 ; let x ; let flag ; let k ; while ( 1 ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 + ( x - 1 ) ; for ( let k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( p1 + " " ) ; i ++ ; } } let p0 = 2 ; print_C ( p0 ) ;
function findOddPair ( A , N ) { var i , j ; var oddPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; } var a = [ 5 , 1 , 3 , 2 ] ; var n = a . length ; document . write ( findOddPair ( a , n ) ) ;
function calculateSum ( n ) { sum = 0 ; sum = 1 << n ; return ( sum - 1 ) ; } let n = 10 ; document . write ( " " + calculateSum ( n ) ) ;
function Divide ( a , b ) { var dividend = a ; var divisor = b ; var sign = ( dividend < 0 ) ^ ( divisor < 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; if ( divisor == 0 ) { document . write ( " " ) ; return ; } if ( dividend == 0 ) { document . write ( a + " " + b + " " + 0 + " " ) ; return ; } if ( divisor == 1 ) { System . out . println ( a + " " + b + " " + sign * dividend + " " ) ; return ; } document . write ( a + " " + b + " " + Math . floor ( sign * ( Math . exp ( Math . log ( dividend ) - Math . log ( divisor ) ) ) ) + " " ) ; } var a = 10 , b = 5 ; Divide ( a , b ) ; a = 49 ; b = - 7 ; Divide ( a , b ) ;
function findNature ( a , b , n ) { if ( n == 0 ) return ( a & 1 ) == 1 ? true : false ; if ( n == 1 ) return ( b & 1 ) == 1 ? true : false ; if ( ( a & 1 ) == 0 ) { if ( ( b & 1 ) == 0 ) return false ; else return ( n % 3 != 0 ) ; } else { if ( ( b & 1 ) == 0 ) return ( ( n - 1 ) % 3 != 0 ) ; else return ( ( n + 1 ) % 3 != 0 ) ; } } let a = 2 , b = 4 ; let n = 3 ; if ( findNature ( a , b , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function checkEqual ( S ) { for ( var i = 0 ; i < S . length ; i ++ ) { if ( S [ i ] != ' ' && S [ i ] != ' ' && S [ i ] != ' ' ) { return " " ; } } var start = 0 , end = S . length - 1 ; while ( start < end ) { if ( S [ start ] != S [ end ] ) { return " " ; } start ++ ; end -- ; } return " " ; } var S = " " ; document . write ( checkEqual ( S ) ) ;
function Log2n ( n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; } function isPowerOfd ( n , d ) { var count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % ( Log2n ( d ) ) == 0 ) ; } return false ; } var n = 64 , d = 8 ; if ( isPowerOfd ( n , d ) ) document . write ( n + " " + d ) ; else document . write ( n + " " + d ) ;
function octahedral_num ( n ) { return n * ( 2 * n * n + 1 ) / 3 ; } let n = 5 ; document . write ( n + " " ) ; document . write ( octahedral_num ( n ) ) ;
function centeredTetrahedralNumber ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 3 ) / 3 ; } var n = 6 ; document . write ( centeredTetrahedralNumber ( n ) ) ;
function swap ( a , b , c , d ) { a = a + b ; b = a - b ; a = a - b ; b = b + c ; c = b - c ; b = b - c ; c = c + d ; d = c - d ; c = c - d ; document . write ( " " + " " ) ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; document . write ( " " + c + " " ) ; document . write ( " " + d ) ; } let a = 1 ; let b = 2 ; let c = 3 ; let d = 4 ; document . write ( " " + " " ) ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; document . write ( " " + c + " " ) ; document . write ( " " + d + " " ) ; document . write ( " " + " " ) ; swap ( a , b , c , d ) ;
function seriesSum ( n ) { var sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) sum += i * ( ( i + 1 ) / 2 ) ; return sum ; } var n = 4 ; document . write ( seriesSum ( n ) ) ;
let N = 3 function checkCentrosymmetricted ( n , m ) { let mid_row ; if ( n & 1 ) mid_row = Math . floor ( n / 2 ) + 1 ; else mid_row = n / 2 ; for ( let i = 0 ; i < mid_row ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; } let n = 3 ; let m = [ [ 1 , 3 , 5 ] , [ 6 , 8 , 6 ] , [ 5 , 3 , 1 ] ] ; ( checkCentrosymmetricted ( n , m ) ? ( document . write ( " " ) ) : document . write ( " " ) ) ;
function Centered_Triangular_num ( n ) { return ( 3 * n * n + 3 * n + 2 ) / 2 ; } var n = 3 ; document . write ( Centered_Triangular_num ( n ) + " " ) ; n = 12 ; document . write ( Centered_Triangular_num ( n ) + " " ) ;
function binomialCoeff ( n , k ) { let C = new Array ( n + 1 ) ; let i , j ; for ( i = 0 ; i <= n ; i ++ ) { C [ i ] = new Array ( k + 1 ) ; for ( j = 0 ; j <= k ; j ++ ) { C [ i ] [ j ] = 0 ; } } for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } function k_Leaves ( n , k ) { let ans = parseInt ( ( binomialCoeff ( n , k ) * binomialCoeff ( n , k - 1 ) ) / n , 10 ) ; document . write ( " " + " " + " " + ans + " " ) ; return 0 ; } function numberOfNodes ( n , d ) { let ans = binomialCoeff ( 2 * n - 1 - d , n - 1 ) ; document . write ( " " + " " + " " + ans + " " ) ; return 0 ; } function rootDegreeR ( n , r ) { let ans = r * binomialCoeff ( 2 * n - 1 - r , n - 1 ) ; ans = parseInt ( ans / n , 10 ) ; document . write ( " " + " " + " " + ans + " " ) ; return 0 ; } k_Leaves ( 3 , 2 ) ; numberOfNodes ( 3 , 1 ) ; rootDegreeR ( 3 , 2 ) ;
function repUnitValue ( n ) { if ( n % 2 == 0 n % 5 == 0 ) return 0 ; let rem = 1 ; let power = 1 ; let k = 1 ; while ( rem % n != 0 ) { k ++ ; power = power * 10 % n ; rem = ( rem + power ) % n ; } return k ; } let n = 13 ; document . write ( repUnitValue ( n ) ) ;
function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } function isSplittable ( n , m ) { let total_sum = parseInt ( ( n * ( n + 1 ) ) / 2 ) ; let sum_s1 = parseInt ( ( total_sum + m ) / 2 ) ; let sum_s2 = total_sum - sum_s1 ; if ( total_sum < m ) return false ; if ( sum_s1 + sum_s2 == total_sum && sum_s1 - sum_s2 == m ) return ( __gcd ( sum_s1 , sum_s2 ) == 1 ) ; return false ; } let n = 5 ; let m = 7 ; if ( isSplittable ( n , m ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isPossibleToZero ( a , n ) { let num = 0 ; for ( let i = 0 ; i < n ; i ++ ) num = num * 10 + a [ i ] ; return ( num % 11 == 0 ) ; } let arr = [ 0 , 1 , 1 , 0 ] ; let n = arr . length ; if ( isPossibleToZero ( arr , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isBlumInteger ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( let j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } for ( let i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) { if ( ( n % i == 0 ) && ( ( i - 3 ) % 4 ) == 0 ) { let q = parseInt ( n / i , 10 ) ; return ( q != i && prime [ q ] && ( q - 3 ) % 4 == 0 ) ; } } } return false ; } let n = 249 ; if ( isBlumInteger ( n ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function nCr ( n , r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } var n = 5 , r = 3 ; document . write ( nCr ( n , r ) ) ;
function summingSeries ( n ) { return Math . pow ( n , 2 ) ; } let n = 100 ; document . write ( " " + summingSeries ( n ) + " " ) ;
function find_sum_of_two_squares ( a , b ) { let ab = a * b ; for ( let i = 0 ; i * i <= ab ; i ++ ) { for ( let j = i ; i * i + j * j <= ab ; j ++ ) { if ( i * i + j * j == ab ) document . write ( i + " " + j + " " + ab + " " ) ; } } } let a = 1 * 1 + 2 * 2 ; let b = 3 * 3 + 4 * 4 ; document . write ( " " + " " + " " ) ; find_sum_of_two_squares ( a , b ) ;
function tetrahedralNumber ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } let n = 5 ; document . write ( tetrahedralNumber ( n ) ) ;
function check_euler_four_square_identity ( a , b , ab ) { let s = 0 ; for ( let i = 0 ; i * i <= ab ; i ++ ) { s = i * i ; for ( let j = i ; j * j <= ab ; j ++ ) { s = j * j + i * i ; for ( let k = j ; k * k <= ab ; k ++ ) { s = k * k + j * j + i * i ; for ( let l = k ; l * l <= ab ; l ++ ) { s = l * l + k * k + j * j + i * i ; if ( s == ab ) { document . write ( " " + i + " " ) ; document . write ( " " + j + " " ) ; document . write ( " " + k + " " ) ; document . write ( " " + l + " " ) ; document . write ( " " + a + " " + b ) ; document . write ( " " + " " + " " + " " ) ; document . write ( ab + " " ) ; document . write ( i + " " + i + " " ) ; document . write ( j + " " + j + " " ) ; document . write ( k + " " + k + " " ) ; document . write ( l + " " + l + " " ) ; document . write ( " " ) ; } } } } } } let ab = a * b ; check_euler_four_square_identity ( a , b , ab ) ;
function calculateDivisors ( A , B ) { let N = ( A - B ) ; let noOfDivisors = 0 ; for ( let i = 1 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( ( N % i ) == 0 ) { if ( i > B ) noOfDivisors ++ ; if ( ( N / i ) != i && ( N / i ) > B ) noOfDivisors ++ ; } } return noOfDivisors ; } function numberOfPossibleWaysUtil ( A , B ) { if ( A == B ) return - 1 ; if ( A < B ) return 0 ; let noOfDivisors = 0 ; noOfDivisors = calculateDivisors ( A , B ) ; return noOfDivisors ; } function numberOfPossibleWays ( A , B ) { let noOfSolutions = numberOfPossibleWaysUtil ( A , B ) ; if ( noOfSolutions == - 1 ) { document . write ( " " + A + " " + B + " " + " " + " " + A + " " ) ; } else { document . write ( " " + A + " " + B + " " + noOfSolutions + " " + " " ) ; } } let A = 26 , B = 2 ; numberOfPossibleWays ( A , B ) ; A = 21 , B = 5 ; numberOfPossibleWays ( A , B ) ;
function powerNumbers ( n ) { let v = new Set ( ) ; for ( let i = 2 ; i * i * i <= n ; i ++ ) { let j = i * i ; while ( j * i <= n ) { j *= i ; let s = parseInt ( Math . sqrt ( j ) , 10 ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size + parseInt ( Math . sqrt ( n ) , 10 ) ; } document . write ( powerNumbers ( 50 ) ) ;
function mean ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; } function variance ( a , n , m ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] -= m ; a [ i ] [ j ] *= a [ i ] [ j ] ; } } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) sum += a [ i ] [ j ] ; return sum / ( n * n ) ; } let mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; let m = mean ( mat , 3 ) ; let varr = variance ( mat , 3 , m ) ; let dev = Math . sqrt ( varr ) ; document . write ( " " + Math . floor ( m ) + " " ) ; document . write ( " " + Math . floor ( varr ) + " " ) ; document . write ( " " + Math . floor ( dev ) + " " ) ;
function sumofseries ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) ; } document . write ( sumofseries ( 3 ) ) ;
function isValid ( i , m ) { let sq_i = Math . sqrt ( i ) ; let sq = Math . min ( m , sq_i ) ; for ( let j = 2 ; j <= sq ; j ++ ) if ( i % j == 0 ) return false ; return true ; } function findLargestNum ( n , m ) { for ( let i = n ; i > m ; i -- ) { if ( isValid ( i , m ) ) { document . write ( i ) ; return ; } } document . write ( " " ) ; } let n = 16 , m = 3 ; findLargestNum ( n , m ) ;
function isOrthogonal ( a , m , n ) { if ( m != n ) return false ; let trans = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { trans [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) trans [ i ] [ j ] = a [ j ] [ i ] ; } let prod = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { prod [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { let sum = 0 ; for ( let k = 0 ; k < n ; k ++ ) { sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) ; } prod [ i ] [ j ] = sum ; } } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i != j && prod [ i ] [ j ] != 0 ) return false ; if ( i == j && prod [ i ] [ j ] != 1 ) return false ; } } return true ; } let a = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] ; if ( isOrthogonal ( a , 3 , 3 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isPerfectSquare ( x ) { if ( x >= 0 ) { let sr = Math . sqrt ( x ) ; return ( ( sr * sr ) == x ) ; } return false ; } let x = 2500 ; if ( isPerfectSquare ( x ) ) document . write ( " " ) ; else document . write ( " " ) ;
function printGP ( a , r , n ) { let curr_term ; for ( let i = 0 ; i < n ; i ++ ) { curr_term = a * Math . pow ( r , i ) ; document . write ( curr_term + " " ) ; } } let a = 2 ; let r = 3 ; let n = 5 ; printGP ( a , r , n ) ;
function getMSB ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 2 ) ; } function multiply ( F , M ) { let x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; let y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; let z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; let w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; } function power ( F , n ) { if ( n == 0 n == 1 ) return ; let M = [ [ 1 , 1 ] , [ 1 , 0 ] ] ; for ( let m = getMSB ( n ) ; m > 0 ; m = m >> 1 ) { multiply ( F , F ) ; if ( ( n & m ) > 0 ) { multiply ( F , M ) ; } } } function fib ( n ) { let F = [ [ 1 , 1 ] , [ 1 , 0 ] ] ; if ( n == 0 ) return 0 ; power ( F , n - 1 ) ; return F [ 0 ] [ 0 ] ; } let n = 6 ; document . write ( fib ( n ) ) ;
function SternSequenceFunc ( BrocotSequence , n ) { for ( var i = 1 ; BrocotSequence . length < n ; i ++ ) { var considered_element = BrocotSequence [ i ] ; var precedent = BrocotSequence [ i - 1 ] ; BrocotSequence . push ( considered_element + precedent ) ; BrocotSequence . push ( considered_element ) ; } for ( var i = 0 ; i < 15 ; ++ i ) document . write ( BrocotSequence [ i ] + " " ) ; } var n = 15 ; var BrocotSequence = [ ] ; BrocotSequence . push ( 1 ) ; BrocotSequence . push ( 1 ) ; SternSequenceFunc ( BrocotSequence , n ) ;
function isRevDiffDivisible ( x , k ) { var n = x ; var m = 0 ; var flag ; while ( x > 0 ) { m = m * 10 + x % 10 ; x = parseInt ( x / 10 ) ; } return ( Math . abs ( n - m ) % k == 0 ) ; } function countNumbers ( l , r , k ) { var count = 0 ; for ( i = l ; i <= r ; i ++ ) if ( isRevDiffDivisible ( i , k ) ) count ++ ; return count ; } var l = 35 , r = 45 , k = 5 ; document . write ( countNumbers ( l , r , k ) ) ;
function divSum ( n ) { let result = 0 ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + 1 ) ; } function areAmicable ( x , y ) { if ( divSum ( x ) != y ) return false ; return ( divSum ( y ) == x ) ; } let x = 220 ; let y = 284 ; if ( areAmicable ( x , y ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isPerfectSquare ( n ) { if ( n < 0 ) return false ; let root = Math . round ( ( Math . sqrt ( n ) ) ) ; return n == root * root ; } function printnonsquare ( n ) { let count = 0 ; for ( let i = 1 ; count < n ; ++ i ) { if ( ! isPerfectSquare ( i ) ) { document . write ( i + " " ) ; count ++ ; } } } let n = 10 ; printnonsquare ( n ) ;
function nonsquare ( n ) { return n + parseInt ( 0.5 + Math . sqrt ( n ) ) ; } function printNonSquare ( n ) { for ( let i = 1 ; i <= n ; i ++ ) document . write ( nonsquare ( i ) + " " ) ; } let n = 10 ; printNonSquare ( n ) ;
function maxFraction ( first , sec ) { a = first [ 0 ] ; b = first [ 1 ] c = sec [ 0 ] ; d = sec [ 1 ] Y = a * d - b * c return ( Y > 0 ) ? first : sec ; } first = [ 3 , 2 ] ; sec = [ 3 , 4 ] ; res = maxFraction ( first , sec ) ; document . write ( res [ 0 ] + " " + res [ 1 ] ) ;
function isPentagonal ( N ) { var i = 1 , M ; do { M = ( 3 * i * i - i ) / 2 ; i += 1 ; } while ( M < N ) ; return ( M == N ) ; } var N = 12 ; if ( isPentagonal ( N ) ) document . write ( N + " " ) ; else document . write ( N + " " ) ;
function fourthPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( i * i * i * i ) ; return sum ; } let n = 6 ; document . write ( fourthPowerSum ( n ) ) ;
function fourthPowerSum ( n ) { return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 ; } var n = 6 ; document . write ( fourthPowerSum ( n ) ) ;
function unitnumber ( x , y ) { x = x % 10 ; if ( y != 0 ) y = y % 4 + 4 ; return ( ( parseInt ( Math . pow ( x , y ) ) ) % 10 ) ; } let x = 133 ; let y = 5 ; document . write ( unitnumber ( x , y ) ) ;
function aliquotSum ( n ) { let sum = 0 ; for ( let i = 1 ; i < n ; i ++ ) if ( n % i == 0 ) sum += i ; return sum ; } let n = 12 ; document . write ( aliquotSum ( n ) ) ;
function complexNumberMultiply ( a , b ) { var x = a . split ( ' ' ) ; var y = b . split ( ' ' ) ; var a_real = parseInt ( x [ 0 ] ) ; var a_img = parseInt ( x [ 1 ] ) ; var b_real = parseInt ( y [ 0 ] ) ; var b_img = parseInt ( y [ 1 ] ) ; return ( a_real * b_real - a_img * b_img ) + " " + ( a_real * b_img + a_img * b_real ) + " " ; } var str1 = " " ; var str2 = " " ; document . write ( complexNumberMultiply ( str1 , str2 ) ) ;
function AvgofSquareN ( n ) { return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } var n = 2 ; document . write ( AvgofSquareN ( n ) ) ;
function func ( x ) { return ( 1 / ( 1 + x * x ) ) ; } function calculate ( lower_limit , upper_limit , interval_limit ) { let value ; let interval_size = ( upper_limit - lower_limit ) / interval_limit ; let sum = func ( lower_limit ) + func ( upper_limit ) ; for ( let i = 1 ; i < interval_limit ; i ++ ) { if ( i % 3 == 0 ) sum = sum + 2 * func ( lower_limit + i * interval_size ) ; else sum = sum + 3 * func ( lower_limit + i * interval_size ) ; } return ( 3 * interval_size / 8 ) * sum ; } let interval_limit = 10 ; let lower_limit = 1 ; let upper_limit = 10 ; let integral_res = calculate ( lower_limit , upper_limit , interval_limit ) ; document . write ( integral_res ) ;
function focal_length ( image_distance , object_distance ) { return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) ; } let image_distance = 2 ; let object_distance = 50 ; document . write ( " " + focal_length ( image_distance , object_distance ) + " " ) ;
function check ( n ) { let m = n ; while ( n ) { let r = n % 10 ; if ( r > 0 ) if ( ( n % r ) != 0 ) return false ; n /= 10 ; } return true ; } function countIn ( l , r ) { let ans = 0 ; for ( let i = l ; i <= r ; i ++ ) if ( check ( i ) ) ans += 1 ; return ans ; } let l = 10 ; let r = 20 ; document . write ( countIn ( l , r ) ) ;
function sumOfTheSeries ( n ) { let sum = 0.0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 1.0 / ( i * ( i + 1 ) ) ; return sum ; } let n = 10 ; document . write ( sumOfTheSeries ( n ) ) ;
function sum ( n ) { let root = parseInt ( Math . sqrt ( n ) ) ; let ans = 0 ; for ( let i = 1 ; i <= root ; i ++ ) ans += parseInt ( n / i ) ; ans = ( 2 * ans ) - ( root * root ) ; return ans ; } let n = 35 ; document . write ( sum ( n ) ) ;
function sumOfTheSeries ( n ) { let sum_n = ( n * ( n + 1 ) / 2 ) ; let sum_sq_n = ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; return ( sum_n + sum_sq_n ) ; } let n = 5 ; document . write ( " " + sumOfTheSeries ( n ) ) ;
function sumofsquare ( n ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } let sum = 0 ; for ( i = 0 ; i <= n ; i ++ ) sum += ( C [ n ] [ i ] * C [ n ] [ i ] ) ; return sum ; } let n = 4 ; document . write ( sumofsquare ( n ) ) ;
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum = sum + i ; return sum ; } let n = 10 ; document . write ( sumOfSeries ( n ) ) ;
function evenSum ( n ) { var C = Array . from ( Array ( n + 1 ) , ( ) => Array ( n + 1 ) . fill ( 0 ) ) ; var i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , n ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } var sum = 0 ; for ( var i = 0 ; i <= n ; i += 2 ) sum += C [ n ] [ i ] ; return sum ; } var n = 4 ; document . write ( evenSum ( n ) ) ;
function triangular_series ( n ) { for ( let i = 1 ; i <= n ; i ++ ) document . write ( " " + i * ( i + 1 ) / 2 ) ; } let n = 5 ; triangular_series ( n ) ;
function checksum ( n ) { if ( n % 3 == 0 ) document . write ( n / 3 - 1 + " " + n / 3 + " " + ( n / 3 + 1 ) ) ; else document . write ( " " ) ; } var n = 6 ; checksum ( n ) ;
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) sum += Math . floor ( n / i ) * i ; return sum ; } let n = 4 ; document . write ( divisorSum ( n ) + " " ) ; n = 5 ; document . write ( divisorSum ( n ) + " " ) ;
function polite ( n ) { n += 1 ; let base = 2 ; return n + ( Math . log ( ( n + ( Math . log ( n ) / Math . log ( base ) ) ) ) ) / Math . log ( base ) ; } n = 7 ; document . write ( parseInt ( polite ( n ) ) ) ;
function solve ( low , high , T ) { while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; } let T = 15 ; let ans = solve ( 1 , T , 2 * T ) ; if ( ans != - 1 ) ans -- ; document . write ( " " + ans ) ;
function isOverflow ( a , b ) { if ( a == 0 b == 0 ) return false ; var result = a * b ; if ( result >= 9223372036854775807 result <= - 9223372036854775808 ) result = 0 if ( a == parseInt ( result / b ) ) return false ; else return true ; } var a = 10000000000 , b = - 10000000000 ; if ( isOverflow ( a , b ) ) document . write ( " " ) ; else document . write ( " " ) ;
function oddSum ( n ) { let sum = 0 ; curr = 1 ; for ( let i = 0 ; i < n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; } let n = 20 ; document . write ( " " + n + " " + oddSum ( n ) ) ;
function oddSum ( n ) { return ( n * n ) ; } let n = 20 ; document . write ( " " + n + " " + oddSum ( n ) ) ;
function prletKPFNums ( A , B , K ) { let prime = [ ] ; for ( let i = 0 ; i < B + 1 ; i ++ ) prime [ i ] = true ; let p_factors = [ ] ; for ( let i = 0 ; i < B + 1 ; i ++ ) p_factors [ i ] = 0 ; for ( let p = 2 ; p <= B ; p ++ ) if ( p_factors [ p ] == 0 ) for ( let i = p ; i <= B ; i += p ) p_factors [ i ] ++ ; for ( let i = A ; i <= B ; i ++ ) if ( p_factors [ i ] == K ) document . write ( i + " " ) ; } let A = 14 , B = 18 , K = 2 ; prletKPFNums ( A , B , K ) ;
let MAX = 100005 ; function precompute ( prefix , suffix ) { let prime = [ ] ; for ( let i = 0 ; i < MAX ; i ++ ) { prime [ i ] = true ; } for ( let i = 2 ; i * i < MAX ; i ++ ) { if ( prime [ i ] ) { for ( let j = i * i ; j < MAX ; j += i ) { prime [ j ] = false ; } } } prefix [ 1 ] = 1 ; suffix [ MAX - 1 ] = 1e9 + 7 ; for ( let i = 2 ; i < MAX ; i ++ ) { if ( prime [ i ] ) { prefix [ i ] = i ; } else { prefix [ i ] = prefix [ i - 1 ] ; } } for ( let i = MAX - 2 ; i > 1 ; i -- ) { if ( prime [ i ] ) { suffix [ i ] = i ; } else { suffix [ i ] = suffix [ i + 1 ] ; } } } function query ( prefix , suffix , L , R ) { if ( prefix [ R ] < L suffix [ L ] > R ) { return 0 ; } else { return prefix [ R ] - suffix [ L ] ; } } let q = 3 ; let L = [ 2 , 2 , 24 ] ; let R = [ 5 , 2 , 28 ] ; let prefix = [ ] , suffix = [ ] ; precompute ( prefix , suffix ) ; for ( let i = 0 ; i < q ; i ++ ) { document . write ( query ( prefix , suffix , L [ i ] , R [ i ] ) + " " ) ; }
function sum ( x , n ) { let i , total = 1.0 ; for ( i = 1 ; i <= n ; i ++ ) total = total + ( Math . pow ( x , i ) / i ) ; return total ; } let g ; let x = 2 ; let n = 5 ; document . write ( sum ( x , n ) . toFixed ( 2 ) ) ;
function isMember ( a , d , x ) { if ( d == 0 ) return ( x == a ) ; return ( ( x - a ) % d == 0 && ( x - a ) / d >= 0 ) ; } let a = 1 , x = 7 , d = 3 ; if ( isMember ( a , d , x ) ) document . write ( " " ) ; else document . write ( " " ) ;
function sumSquare ( n ) { for ( i = 1 ; i * i <= n ; i ++ ) for ( j = 1 ; j * j <= n ; j ++ ) if ( i * i + j * j == n ) { document . write ( i + " " + j + " " + " " ) ; return true ; } return false ; } var n = 25 ; if ( sumSquare ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function check ( a , b ) { var c = 0 ; while ( a != 0 ) { c = c + a % 10 ; a = parseInt ( a / 10 ) ; } return ( c == b ) ; } function root ( n ) { var found = false ; var mx = 1E18 ; for ( i = 0 ; i <= 90 ; i ++ ) { var s = i * i + 4 * n ; var sq = Math . sqrt ( s ) ; if ( sq * sq == s && check ( ( sq - i ) / 2 , i ) ) { found = true ; mx = Math . min ( mx , ( sq - i ) / 2 ) ; } } if ( found ) return mx ; else return - 1 ; } var n = 110 ; document . write ( root ( n ) ) ;
function calculate ( n , power ) { sum = 0 ; bp = Math . pow ( n , power ) ; while ( bp != 0 ) { d = bp % 10 ; sum = sum + d ; bp = Math . floor ( bp / 10 ) ; } return sum ; } n = 5 ; power = 4 ; document . write ( calculate ( n , power ) ) ;
function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } function coprime ( a , b ) { return ( __gcd ( a , b ) == 1 ) ; } function pairSum ( n ) { let mid = Math . floor ( n / 2 ) ; for ( let i = mid ; i >= 1 ; i -- ) { if ( coprime ( i , n - i ) == true ) { document . write ( i + " " + ( n - i ) ) ; break ; } } } let n = 11 ; pairSum ( n ) ;
function modBigNumber ( num , m ) { let vec = [ ] ; let x = 0 ; let mod = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) { digit = num [ i ] - ' ' ; mod = mod * 10 + digit ; quo = parseInt ( mod / m ) ; vec [ x ++ ] = quo ; mod = mod % m ; } document . write ( " " + mod + " " ) ; document . write ( " " ) ; let zeroflag = 0 ; for ( let i = 0 ; i < x ; i ++ ) { if ( vec [ i ] == 0 && zeroflag == 0 ) continue ; zeroflag = 1 ; document . write ( vec [ i ] ) ; } return ; } let num = " " ; let m = 487 ; modBigNumber ( num , m ) ;
var N = 1000000 ; var fourDiv = Array ( N + 1 ) . fill ( false ) ; function fourDistinctFactors ( ) { var primeAll = Array ( N + 1 ) . fill ( false ) ; for ( var p = 2 ; p * p <= N ; p ++ ) { if ( primeAll [ p ] == false ) { for ( var i = p * 2 ; i <= N ; i += p ) primeAll [ i ] = true ; } } var prime = [ ] ; for ( var p = 2 ; p <= N ; p ++ ) if ( ! primeAll [ p ] ) prime . push ( p ) ; for ( var i = 0 ; i < prime . length ; ++ i ) { var p = prime [ i ] ; if ( p * p * p <= N ) fourDiv [ p * p * p ] = true ; for ( var j = i + 1 ; j < prime . length ; ++ j ) { var q = prime [ j ] ; if ( p * q > N ) break ; fourDiv [ p * q ] = true ; } } } fourDistinctFactors ( ) ; var num = 10 ; if ( fourDiv [ num ] ) document . write ( " " ) ; else document . write ( " " ) ; num = 12 ; if ( fourDiv [ num ] ) document . write ( " " ) ; else document . write ( " " ) ;
function Cholesky_Decomposition ( matrix , n ) { var lower = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) { var sum = 0 ; if ( j == i ) { for ( var k = 0 ; k < j ; k ++ ) sum += parseInt ( Math . pow ( lower [ j ] [ k ] , 2 ) ) ; lower [ j ] [ j ] = parseInt ( Math . sqrt ( matrix [ j ] [ j ] - sum ) ) ; } else { for ( var k = 0 ; k < j ; k ++ ) sum += ( lower [ i ] [ k ] * lower [ j ] [ k ] ) ; lower [ i ] [ j ] = ( matrix [ i ] [ j ] - sum ) / lower [ j ] [ j ] ; } } } document . write ( " " ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) document . write ( lower [ i ] [ j ] + " " ) ; for ( var j = 0 ; j < n ; j ++ ) document . write ( lower [ j ] [ i ] + " " ) ; document . write ( ' ' ) ; } } var n = 3 ; var matrix = [ [ 4 , 12 , - 16 ] , [ 12 , 37 , - 43 ] , [ - 16 , - 43 , 98 ] ] ; Cholesky_Decomposition ( matrix , n ) ;
function sumOfAP ( a , d , n ) { let sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) ; return sum ; } let n = 20 ; let a = 2.5 , d = 1.5 ; document . write ( sumOfAP ( a , d , n ) ) ;
function sumOfSeries ( n ) { x = 0 if ( n % 2 == 0 ) x = ( n / 2 ) * ( n + 1 ) else x = ( ( n + 1 ) / 2 ) * n return ( x * x ) } let n = 5 ; document . write ( sumOfSeries ( n ) ) ;
var MAX = 10 ; function findValue ( arr , n ) { var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = 0 ; j < n ; j ++ ) ans = Math . max ( ans , Math . abs ( arr [ i ] - arr [ j ] ) + Math . abs ( i - j ) ) ; return ans ; } var arr = [ 1 , 2 , 3 , 1 ] ; var n = arr . length ; document . write ( findValue ( arr , n ) ) ;
function findValue ( arr , n ) { let a = new Array ( n ) ; let b = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { a [ i ] = ( arr [ i ] + i ) ; b [ i ] = ( arr [ i ] - i ) ; } let x = a [ 0 ] , y = a [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) x = a [ i ] ; if ( a [ i ] < y ) y = a [ i ] ; } let ans1 = ( x - y ) ; x = b [ 0 ] ; y = b [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( b [ i ] > x ) x = b [ i ] ; if ( b [ i ] < y ) y = b [ i ] ; } let ans2 = ( x - y ) ; return Math . max ( ans1 , ans2 ) ; } let arr = [ 1 , 2 , 3 , 1 ] ; let n = arr . length ; document . write ( findValue ( arr , n ) ) ;
function countsubarray ( array , n , k ) { var count = 0 ; var i , j , mul ; for ( i = 0 ; i < n ; i ++ ) { if ( array [ i ] < k ) count ++ ; mul = array [ i ] ; for ( j = i + 1 ; j < n ; j ++ ) { mul = mul * array [ j ] ; if ( mul < k ) count ++ ; else break ; } } return count ; } var array = [ 1 , 2 , 3 , 4 ] ; var k = 10 ; var size = array . length ; var count = countsubarray ( array , size , k ) ; document . write ( count ) ;
var MAX = 1000001 ; var factor = [ ] ; function generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } function calculateNoOFactors ( n ) { if ( n == 1 ) return 1 ; var ans = 1 ; var dup = factor [ n ] ; var c = 1 ; var j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; } factor = Array ( MAX ) . fill ( 0 ) ; factor [ 0 ] = 0 ; generatePrimeFactors ( ) ; var a = [ 10 , 30 , 100 , 450 , 987 ] ; var q = a . length ; for ( i = 0 ; i < q ; i ++ ) document . write ( calculateNoOFactors ( a [ i ] ) + " " ) ;
function digit_product_Sum ( N ) { var a = [ ... Array ( N ) ] ; var product = 1 ; a [ 0 ] = 1 ; for ( var i = 1 ; i <= N ; i ++ ) { product = parseInt ( a [ i - 1 ] / 10 ) ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; var val = parseInt ( a [ i - 1 ] / 10 ) ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + val * product ; } for ( var i = 0 ; i < N ; i ++ ) document . write ( a [ i ] + " " ) ; } var N = 10 ; digit_product_Sum ( N ) ;
function geometricMean ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) product = product * arr [ i ] ; let gm = Math . pow ( product , 1 / n ) ; return gm ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ; let n = arr . length ; document . write ( geometricMean ( arr , n ) ) ;
const SIZE = 4 ; function productOfSingelDgt ( n ) { if ( n >= 0 && n <= 9 ) return true ; var prime = [ 2 , 3 , 5 , 7 ] ; for ( i = 0 ; i < SIZE && n > 1 ; i ++ ) while ( n % prime [ i ] == 0 ) n = n / prime [ i ] ; return ( n == 1 ) ; } var n = 24 ; if ( productOfSingelDgt ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findSum ( n ) { if ( n % 2 == 0 ) return ( n / 2 ) * ( n + 1 ) else return ( ( n + 1 ) / 2 ) * n } var n = 5 ; document . write ( findSum ( n ) ) ;
function maxPrimefactorNum ( N ) { if ( N < 2 ) return 0 ; arr = Array . from ( { length : N + 1 } , ( _ , i ) => false ) ; var prod = 1 , res = 0 ; for ( var p = 2 ; p * p <= N ; p ++ ) { if ( arr [ p ] == false ) { for ( var i = p * 2 ; i <= N ; i += p ) arr [ i ] = true ; prod *= p ; if ( prod > N ) return res ; res ++ ; } } return res ; } var N = 500 ; document . write ( maxPrimefactorNum ( N ) ) ;
let n = 8 ; let range = 12 ; for ( let i = 1 ; i <= range ; ++ i ) document . write ( n + " " + i + " " + n * i + " " ) ;
function isPalindrome ( n ) { var divisor = 1 ; while ( parseInt ( n / divisor ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { var leading = parseInt ( n / divisor ) ; var trailing = n % 10 ; if ( leading != trailing ) return false ; n = parseInt ( ( n % divisor ) / 10 ) ; divisor = divisor / 100 ; } return true ; } if ( isPalindrome ( 1001 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function check ( n ) { return 1162261467 % n == 0 ; } let n = 9 ; if ( check ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function printDemlo ( str ) { let len = str . length ; let res = " " ; for ( let i = 1 ; i <= len ; i ++ ) res += i . toString ( ) ; for ( let i = len - 1 ; i >= 1 ; i -- ) res += i . toString ( ) ; return res ; } let str = " " ; document . write ( printDemlo ( str ) ) ;
function NumberofTimes ( str ) { var temporary_sum = 0 , count = 0 ; while ( str . length > 1 ) { temporary_sum = 0 ; for ( i = 0 ; i < str . length ; i ++ ) temporary_sum += ( str . charAt ( i ) - ' ' ) ; str = temporary_sum + " " ; count ++ ; } return count ; } var s = " " ; document . write ( NumberofTimes ( s ) ) ;
function calculateLeaps ( n ) { if ( n == 0 n == 1 ) { return 1 ; } else { let leaps = 0 ; for ( let i = 0 ; i < n ; i ++ ) leaps += calculateLeaps ( i ) ; return leaps ; } } document . write ( calculateLeaps ( 4 ) ) ;
function power ( x , y , p ) { var res = 1 ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return parseInt ( res ) ; } function printLastKDigits ( a , b , k ) { document . write ( " " + k + " " + a + " " + b + " " ) ; var temp = 1 ; for ( i = 1 ; i <= k ; i ++ ) temp *= 10 ; temp = power ( a , b , temp ) ; for ( i = 0 ; i < k - temp . toString ( ) . length ; i ++ ) document . write ( 0 ) ; if ( temp != 0 ) document . write ( temp ) ; } var a = 11 ; var b = 3 ; var k = 2 ; printLastKDigits ( a , b , k ) ;
function reverseDigits ( num ) { let rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num = parseInt ( num / 10 , 10 ) ; } return rev ; } function square ( num ) { return ( num * num ) ; } function checkAdamNumber ( num ) { let a = square ( num ) ; let b = square ( reverseDigits ( num ) ) ; if ( a == reverseDigits ( b ) ) return true ; return false ; } let num = 12 ; if ( checkAdamNumber ( num ) ) document . write ( " " ) ; else document . write ( " " ) ;
function totalDigits ( n ) { var number_of_digits = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) number_of_digits += ( n - i + 1 ) ; return number_of_digits ; } var n = 13 ; document . write ( totalDigits ( n ) ) ;
function numbersWith3Divisors ( n ) { let prime = new Array ( n + 1 ) ; prime . fill ( true ) ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } document . write ( " " + " " ) ; for ( let i = 0 ; i * i <= n ; i ++ ) if ( prime [ i ] ) document . write ( i * i + " " ) ; } let n = 96 ; numbersWith3Divisors ( n ) ;
function decToHexa ( n ) { var hexaDeciNum = Array . from ( { length : 100 } , ( _ , i ) => 0 ) ; var i = 0 ; while ( n != 0 ) { var temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = String . fromCharCode ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = String . fromCharCode ( temp + 55 ) ; i ++ ; } n = parseInt ( n / 16 ) ; } for ( j = i - 1 ; j >= 0 ; j -- ) document . write ( hexaDeciNum [ j ] ) ; } var n = 2545 ; decToHexa ( n ) ;
function decToBinary ( n ) { let binaryNum = new Array ( 32 ) ; let i = 0 ; while ( n > 0 ) { binaryNum [ i ] = n % 2 ; n = Math . floor ( n / 2 ) ; i ++ ; } for ( let j = i - 1 ; j >= 0 ; j -- ) document . write ( binaryNum [ j ] ) ; } let n = 17 ; decToBinary ( n ) ;
function count_of_ways ( n ) { var count = 0 ; count = ( n + 1 ) * ( n + 2 ) / 2 ; return count ; } var n = 3 ; document . write ( count_of_ways ( n ) ) ;
function flipSign ( a ) { var neg = 0 ; var tmp = a < 0 ? 1 : - 1 ; while ( a != 0 ) { neg += tmp ; a += tmp ; } return neg ; } function areDifferentSign ( a , b ) { return ( ( a < 0 && b > 0 ) || ( a > 0 && b < 0 ) ) ; } function sub ( a , b ) { return a + flipSign ( b ) ; } function mul ( a , b ) { if ( a < b ) return mul ( b , a ) ; var sum = 0 ; for ( i = Math . abs ( b ) ; i > 0 ; i -- ) sum += a ; if ( b < 0 ) sum = flipSign ( sum ) ; return sum ; } function division ( a , b ) { if ( b == 0 ) throw new ArithmeticException ( ) ; var quotient = 0 , dividend ; var divisor = flipSign ( Math . abs ( b ) ) ; for ( dividend = Math . abs ( a ) ; dividend >= Math . abs ( divisor ) ; dividend += divisor ) quotient ++ ; if ( areDifferentSign ( a , b ) ) quotient = flipSign ( quotient ) ; return quotient ; } document . write ( " " + sub ( 4 , - 2 ) ) ; document . write ( " " + mul ( - 9 , 6 ) ) ; try { document . write ( " " + division ( 8 , 2 ) ) ; } catch ( e ) { document . write ( " " ) ; }
function numOfCombinations ( arr , N ) { let C = [ 0 , 0 , 0 ] ; for ( let i = 0 ; i < N ; ++ i ) ++ C [ arr [ i ] % 3 ] ; return C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ; } let arr1 = [ 1 , 5 , 7 , 2 , 9 , 14 ] ; document . write ( numOfCombinations ( arr1 , 6 ) + " " ) ; let arr2 = [ 3 , 6 , 9 , 12 ] ; document . write ( numOfCombinations ( arr2 , 4 ) + " " ) ;
function isprime ( x ) { for ( i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; } function isSumOfKprimes ( N , K ) { if ( N < 2 * K ) return false ; if ( K == 1 ) return isprime ( N ) ; if ( K == 2 ) { if ( N % 2 == 0 ) return true ; return isprime ( N - 2 ) ; } return true ; } var n = 10 , k = 2 ; if ( isSumOfKprimes ( n , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
function GCD ( num1 , num2 ) { let Remainder ; while ( num2 != 0 ) { Remainder = num1 % num2 ; num1 = num2 ; num2 = Remainder ; } return num1 ; } function FindLCM ( a , b ) { return parseInt ( ( a * b ) / GCD ( a , b ) , 10 ) ; } function rangeDivisor ( m , n , a , b ) { let lcm = FindLCM ( a , b ) ; let a_divisor = parseInt ( n / a , 10 ) - parseInt ( ( m - 1 ) / a , 10 ) ; let b_divisor = parseInt ( n / b , 10 ) - parseInt ( ( m - 1 ) / b , 10 ) ; let common_divisor = parseInt ( n / lcm , 10 ) - parseInt ( ( m - 1 ) / lcm , 10 ) ; let ans = a_divisor + b_divisor - common_divisor ; return ans ; } let m = 3 , n = 11 , a = 2 , b = 3 ; document . write ( rangeDivisor ( m , n , a , b ) + " " ) ; m = 11 ; n = 1000000 ; a = 6 ; b = 35 ; document . write ( rangeDivisor ( m , n , a , b ) ) ;
function printUnique ( l , r ) { for ( let i = l ; i <= r ; i ++ ) { let num = i ; let visited = new Array ( 10 ) ; while ( num ) { if ( visited [ num % 10 ] ) break ; visited [ num % 10 ] = true ; num = Math . floor ( num / 10 ) ; } if ( num == 0 ) document . write ( i + " " ) ; } } let l = 1 , r = 20 ; printUnique ( l , r ) ;
function findMinZero ( p ) { let first = 1 ; let second = 1 ; let number = 2 ; let next = 1 ; while ( next ) { next = ( first + second ) % p ; first = second ; second = next ; number ++ ; } return number ; } let p = 7 ; document . write ( " " , findMinZero ( p ) + " " ) ;
function printCubes ( a , b ) { for ( let i = a ; i <= b ; i ++ ) { for ( let j = 1 ; j * j * j <= i ; j ++ ) { if ( j * j * j == i ) { document . write ( j * j * j + " " ) ; break ; } } } } let a = 1 ; let b = 100 ; document . write ( " " ) ; printCubes ( a , b ) ;
function printBinary ( num ) { if ( num >= 1 num <= 0 ) return " " ; let binary = " " ; let frac = 0.5 ; binary += " " ; while ( num > 0 ) { if ( binary . length >= 32 ) return " " ; if ( num >= frac ) { binary += " " ; num -= frac ; } else binary += " " ; frac = frac / 2 ; } return binary ; } let num1 = 0.625 ; let output = printBinary ( num1 ) ; document . write ( " " + output + " " + " " ) ; let num2 = 0.72 ; output = printBinary ( num2 ) ; document . write ( " " + output + " " ) ;
function firstkdigits ( n , k ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) product *= n ; while ( Math . floor ( product / Math . pow ( 10 , k ) ) != 0 ) product = Math . floor ( product / 10 ) ; return product ; } let n = 15 ; let k = 4 ; document . write ( firstkdigits ( n , k ) ) ;
function check ( str ) { let n = str . length ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 9 == 0 ) ; } let str = " " ; let x = check ( str ) ? " " : " " ; document . write ( x ) ;
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = i ; j < N ; j ++ ) for ( let k = i ; k <= j ; k ++ ) res = res ^ arr [ k ] ; return res ; } let arr = [ 3 , 5 , 2 , 4 , 6 ] ; let N = arr . length ; document . write ( getTotalXorOfSubarrayXors ( arr , N ) ) ;
function getTotalXorOfSubarrayXors ( arr , N ) { let res = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let freq = ( i + 1 ) * ( N - i ) ; if ( freq % 2 == 1 ) res = res ^ arr [ i ] ; } return res ; } let arr = [ 3 , 5 , 2 , 4 , 6 ] ; let N = arr . length ; document . write ( getTotalXorOfSubarrayXors ( arr , N ) ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function findGCD ( arr , n ) { let result = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { result = gcd ( arr [ i ] , result ) ; if ( result == 1 ) { return 1 ; } } return result ; } let arr = [ 2 , 4 , 6 , 8 , 16 ] ; let n = arr . length ; document . write ( findGCD ( arr , n ) + " " ) ;
function divSum ( num ) { let result = 0 ; for ( let i = 1 ; i * i <= num ; ++ i ) { if ( num % i == 0 ) { if ( i == ( num / i ) ) result += i ; else result += ( i + num / i ) ; } } return result ; } function isSuperPerfect ( n ) { let n1 = divSum ( n ) ; return ( 2 * n == divSum ( n1 ) ) ; } let n = 16 ; document . write ( ( isSuperPerfect ( n ) ? " " : " " ) + " " ) ; n = 6 ; document . write ( ( isSuperPerfect ( n ) ? " " : " " ) + " " ) ;
function isRefactorableNumber ( n ) { let divCount = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; ++ i ) { if ( n % i == 0 ) { if ( n / i == i ) ++ divCount ; else divCount += 2 ; } } return n % divCount == 0 ; } let n = 8 ; if ( isRefactorableNumber ( n ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; n = 14 ; if ( isRefactorableNumber ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isPerfectSquare ( n ) { let sq = Math . sqrt ( n ) ; return ( n == sq * sq ) ; } function countPerfectDivisors ( n ) { let count = 0 ; for ( let i = 1 ; i * i <= n ; ++ i ) { if ( n % i == 0 ) { if ( isPerfectSquare ( i ) ) ++ count ; if ( n / i != i && isPerfectSquare ( n / i ) ) ++ count ; } } return count ; } let n = 16 ; document . write ( " " + " " + n ) ; document . write ( " " + countPerfectDivisors ( n ) + " " ) ; n = 12 ; document . write ( " " + " " + n ) ; document . write ( " " + countPerfectDivisors ( n ) ) ;
function nearestGcd ( arr , n ) { for ( let i = 0 ; i < n ; ++ i ) { let closest = - 1 ; for ( let j = i - 1 , k = i + 1 ; j > 0 k <= n ; -- j , ++ k ) { if ( j >= 0 && __gcd ( arr [ i ] , arr [ j ] ) > 1 ) { closest = j + 1 ; break ; } if ( k < n && __gcd ( arr [ i ] , arr [ k ] ) > 1 ) { closest = k + 1 ; break ; } } document . write ( closest + " " ) ; } } function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } let arr = [ 2 , 9 , 4 , 3 , 13 ] ; let n = arr . length ; nearestGcd ( arr , n ) ;
let MAX = 100001 ; let prime = new Array ( MAX + 1 ) ; let countdiv = new Array ( MAX + 1 ) ; for ( let i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = 0 ; countdiv [ i ] = 0 ; } function SieveOfEratosthenes ( ) { for ( let i = 2 ; i * i <= MAX ; ++ i ) { if ( prime [ i ] == 0 ) for ( let j = i * 2 ; j <= MAX ; j += i ) prime [ j ] = i ; } for ( let i = 1 ; i < MAX ; ++ i ) if ( prime [ i ] == 0 ) prime [ i ] = i ; } function largestGCDSubsequence ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; ++ i ) { let element = arr [ i ] ; while ( element > 1 ) { let div = prime [ element ] ; ++ countdiv [ div ] ; ans = Math . max ( ans , countdiv [ div ] ) ; while ( element % div == 0 ) element /= div ; } } return ans ; } SieveOfEratosthenes ( ) ; let arr = [ 10 , 15 , 7 , 25 , 9 , 35 ] ; let size = arr . length ; document . write ( largestGCDSubsequence ( arr , size ) ) ;
function countOfBinaryNumberLessThanN ( N ) { var q = [ ] ; q . push ( 1 ) ; var cnt = 0 ; var t ; while ( q . length > 0 ) { t = q . pop ( ) ; if ( t <= N ) { cnt ++ ; q . push ( t * 10 ) ; q . push ( t * 10 + 1 ) ; } } return cnt ; } var N = 200 ; document . write ( countOfBinaryNumberLessThanN ( N ) + " " ) ;
function sumofproduct ( n ) { var ans = 0 ; for ( x = 1 ; x <= n ; x ++ ) { var y = parseInt ( n / x ) ; ans += ( y * x ) ; } return ans ; } var n = 10 ; document . write ( sumofproduct ( n ) ) ;
function per ( n ) { let a = 3 ; let b = 0 ; let c = 2 ; let i ; let m ; if ( n == 0 ) return a ; if ( n == 1 ) return b ; if ( n == 2 ) return c ; while ( n > 2 ) { m = a + b ; a = b ; b = c ; c = m ; n -- ; } return m ; } n = 9 ; document . write ( per ( n ) ) ;
function fact ( n ) { let num = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { num = num * i ; } return num ; } function Special_Factorial_Number ( k ) { for ( let i = 1 ; i <= k ; i ++ ) { if ( fact ( i ) % k == 0 ) { return i ; } } return 0 ; } let k = 16 ; document . write ( Special_Factorial_Number ( k ) ) ;
function countMaxChoco ( money , price , wrap ) { if ( money < price ) return 0 ; let choc = parseInt ( money / price , 10 ) ; choc = choc + parseInt ( ( choc - 1 ) / ( wrap - 1 ) , 10 ) ; return choc ; } let money = 15 ; let price = 1 ; let wrap = 3 ; document . write ( countMaxChoco ( money , price , wrap ) ) ;
function gcd ( i , j ) { if ( i == j ) return i ; if ( i > j ) return gcd ( i - j , j ) ; return gcd ( i , j - i ) ; } function ispossible ( x , y , a , b ) { x = Math . abs ( x ) ; y = Math . abs ( y ) ; a = Math . abs ( a ) ; b = Math . abs ( b ) ; return ( gcd ( x , y ) == gcd ( a , b ) ) ; } var x = 35 , y = 15 ; var a = 20 , b = 25 ; if ( ispossible ( x , y , a , b ) ) document . write ( " " ) ; else document . write ( " " ) ;
function getMaximumSumWithLCMN ( N ) { let sum = 0 ; let LIM = Math . sqrt ( N ) ; for ( let i = 1 ; i <= LIM ; i ++ ) { if ( N % i == 0 ) { if ( i == ( N / i ) ) sum += i ; else sum += ( i + N / i ) ; } } return sum ; } let N = 12 ; document . write ( getMaximumSumWithLCMN ( N ) + " " ) ;
function gcd ( a , b ) { if ( a % b != 0 ) return gcd ( b , a % b ) ; else return b ; } function lcm ( n ) { let ans = 1 ; for ( let i = 1 ; i <= n ; i ++ ) ans = ( ans * i ) / ( gcd ( ans , i ) ) ; return ans ; } let n = 20 ; document . write ( lcm ( n ) ) ;
function y ( x ) { return 1 / ( 1 + x * x ) ; } function trapezoidal ( a , b , n ) { let h = ( b - a ) / n ; let s = y ( a ) + y ( b ) ; for ( let i = 1 ; i < n ; i ++ ) s += 2 * y ( a + i * h ) ; return ( h / 2 ) * s ; } let x0 = 0 ; let xn = 1 ; let n = 6 ; document . write ( " " + Math . round ( trapezoidal ( x0 , xn , n ) * 10000.0 ) / 10000.0 ) ;
function numberOfDigits ( n ) { if ( n == 1 ) return 1 ; let d = ( n * Math . log10 ( 1.6180339887498948 ) ) - ( ( Math . log10 ( 5 ) ) / 2 ) ; return Math . ceil ( d ) ; } let i ; for ( let i = 1 ; i <= 10 ; i ++ ) document . write ( ` ${ i } ${ numberOfDigits ( i ) } ` ) ;
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; } let n = 5 , m = 100 ; document . write ( " " + countOddSquares ( n , m ) ) ;
function isPower ( x , y ) { if ( x == 1 ) return ( y == 1 ) ; let pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; } document . write ( ( isPower ( 10 , 1 ) ? 1 : 0 ) + " " ) ; document . write ( ( isPower ( 1 , 20 ) ? 1 : 0 ) + " " ) ; document . write ( ( isPower ( 2 , 128 ) ? 1 : 0 ) + " " ) ; document . write ( ( isPower ( 2 , 30 ) ? 1 : 0 ) + " " ) ;
function countSquares ( a , b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; } let a = 9 ; let b = 25 ; document . write ( " " , countSquares ( a , b ) ) ;
function findCountUpto ( d ) { let GP1_Sum = 9 * ( ( Math . pow ( 10 , d ) - 1 ) / 9 ) ; let GP2_Sum = 9 * ( ( Math . pow ( 9 , d ) - 1 ) / 8 ) ; return GP1_Sum - GP2_Sum ; } let d = 1 ; document . write ( findCountUpto ( d ) + " " ) ; d = 2 ; document . write ( findCountUpto ( d ) + " " ) ; d = 4 ; document . write ( findCountUpto ( d ) + " " ) ;
function countDivisors ( n ) { let count = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) + 1 ; i ++ ) { if ( n % i == 0 ) count += ( Math . floor ( n / i ) == i ) ? 1 : 2 ; } if ( count % 2 == 0 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; } document . write ( " " ) ; countDivisors ( 10 ) ;
function largestPower ( n , p ) { let x = 0 ; while ( n > 0 ) { n = parseInt ( n / p , 10 ) ; x += n ; } return x ; } function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } function modFact ( n , p ) { if ( n >= p ) { return 0 ; } let res = 1 ; let isPrime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) isPrime [ i ] = true ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( isPrime [ i ] ) { for ( let j = 2 * i ; j <= n ; j += i ) { isPrime [ j ] = false ; } } } for ( let i = 2 ; i <= n ; i ++ ) { if ( isPrime [ i ] ) { let k = largestPower ( n , i ) ; res = ( res * power ( i , k , p ) ) % p ; } } return res ; } let n = 25 , p = 29 ; document . write ( modFact ( n , p ) ) ;
function countSquares ( m , n ) { if ( n < m ) [ m , n ] = [ n , m ] ; return m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ; } let m = 4 ; let n = 3 ; document . write ( " " + countSquares ( n , m ) ) ;
function add ( x , y ) { while ( y > 0 && y != 0 ) { x ++ ; y -- ; } while ( y < 0 && y != 0 ) { x -- ; y ++ ; } return x ; } document . write ( add ( 43 , 23 ) + " " ) ; document . write ( add ( 43 , - 23 ) + " " ) ;
function countFact ( low , high ) { let fact = 1 ; let x = 1 ; while ( fact < low ) { fact = fact * x ; x ++ ; } let res = 0 ; while ( fact <= high ) { res ++ ; fact = fact * x ; x ++ ; } return res ; } document . write ( " " + countFact ( 2 , 720 ) ) ;
function getPeriod ( n ) { let rem = 1 ; for ( let i = 1 ; i <= n + 1 ; i ++ ) rem = ( 10 * rem ) % n ; let d = rem ; let count = 0 ; do { rem = ( 10 * rem ) % n ; count ++ ; } while ( rem != d ) ; return count ; } document . write ( getPeriod ( 3 ) + " " ) document . write ( getPeriod ( 7 ) + " " )
function getRemainder ( num , divisor ) { let t = ( num - divisor * parseInt ( num / divisor ) ) ; return t ; } document . write ( getRemainder ( 100 , 7 ) ) ;
function sum ( n ) { let sum = 0 ; let fact = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { fact *= i ; sum += 1.0 / fact ; } return sum . toFixed ( 5 ) ; } let n = 5 ; document . write ( sum ( n ) ) ;
function print ( n , k ) { let rem = 1 ; let ans = ' ' ; for ( let i = 0 ; i < k ; i ++ ) { ans += Math . floor ( ( ( 10 * rem ) / n ) ) ; rem = ( 10 * rem ) % n ; } document . write ( ans ) } let n = 7 ; let k = 3 ; print ( n , k ) ; document . write ( " " ) ; n = 21 ; k = 4 ; print ( n , k ) ;
function sum ( n ) { var i , s = 0.0 ; for ( i = 1 ; i <= n ; i ++ ) s = s + 1 / i ; return s ; } var n = 5 ; document . write ( sum ( n ) . toFixed ( 5 ) ) ;
function gcd ( a , b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } let a = 98 ; let b = 56 ; document . write ( ` ${ a } ${ b } ${ gcd ( a , b ) } ` ) ;
function rearrange ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] += ( arr [ arr [ i ] ] % n ) * n ; for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = Math . floor ( arr [ i ] / n ) ; } function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; } let arr = [ 3 , 2 , 0 , 1 ] ; let n = arr . length ; document . write ( " " ) ; printArr ( arr , n ) ; rearrange ( arr , n ) ; document . write ( " " ) ; printArr ( arr , n ) ;
function printArray ( arr , size ) { for ( i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; return ; } function printSequencesRecur ( arr , n , k , index ) { var i ; if ( k == 0 ) { printArray ( arr , index ) ; } if ( k > 0 ) { for ( i = 1 ; i <= n ; ++ i ) { arr [ index ] = i ; printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; } } } function printSequences ( n , k ) { var arr = Array . from ( { length : k } , ( _ , i ) => 0 ) ; printSequencesRecur ( arr , n , k , 0 ) ; return ; } var n = 3 ; var k = 2 ; printSequences ( n , k ) ;
function isMultipleof5 ( n ) { while ( n > 0 ) n = n - 5 ; if ( n == 0 ) return true ; return false ; } let n = 19 ; if ( isMultipleof5 ( n ) == true ) document . write ( n + " " ) ; else document . write ( n + " " ) ;
function CalculatePairs ( a , n ) { let cnt_zero = 0 ; let cnt_one = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } let total_XOR_pairs = cnt_zero * cnt_one ; let total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; let total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; document . write ( " " + total_XOR_pairs + " " ) ; document . write ( " " + total_AND_pairs + " " ) ; document . write ( " " + total_OR_pairs + " " ) ; } let a = [ 1 , 3 , 4 , 2 ] ; let n = a . length ; CalculatePairs ( a , n ) ;
function alternate ( a , b , x ) { x = a + b - x ; document . write ( " " + " " + " " + x ) ; } var a = - 10 ; var b = 15 ; var x = a ; document . write ( " " + x + " " ) ; alternate ( a , b , x ) ;
function highestPowerOf2 ( n ) { return ( n & ( ~ ( n - 1 ) ) ) ; } var n = 48 ; document . write ( highestPowerOf2 ( n ) ) ;
function isSubsetAndZero ( array , len , N ) { var arrAnd = array [ 0 ] ; for ( var i = 1 ; i < len ; i ++ ) { arrAnd = arrAnd & array [ i ] ; } if ( ( arrAnd & N ) == 0 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; } var array = [ 1 , 2 , 4 ] ; var len = array . length ; var N = 3 ; isSubsetAndZero ( array , len , N ) ;
function findParity ( x ) { let y = x ^ ( x >> 1 ) ; y = y ^ ( y >> 2 ) ; y = y ^ ( y >> 4 ) ; y = y ^ ( y >> 8 ) ; y = y ^ ( y >> 16 ) ; if ( y & 1 ) return 1 ; return 0 ; } ( findParity ( 9 ) == 0 ) ? document . write ( " " ) : document . write ( " " ) ; ( findParity ( 13 ) == 0 ) ? document . write ( " " ) : document . write ( " " ) ;
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( num == new_num ) return true ; return false ; } function bitsAreComplement ( a , b , l , r ) { var xor_value = a ^ b ; return allBitsSetInTheGivenRange ( xor_value , l , r ) ; } var a = 10 , b = 5 ; var l = 1 , r = 3 ; if ( bitsAreComplement ( a , b , l , r ) ) document . write ( " " ) ; else document . write ( " " ) ;
function calculateSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( 1 << i ) ; } return sum ; } let n = 10 ; document . write ( " " + calculateSum ( n ) )
function printCombinations ( a , n , m ) { for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { let sum = 0 ; let num = 1 << ( n - 1 ) ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( i & num ) > 0 ) sum += a [ j ] ; else sum += ( - 1 * a [ j ] ) ; num = num >> 1 ; } if ( sum % m == 0 ) { num = 1 << ( n - 1 ) ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( i & num ) > 0 ) document . write ( " " + a [ j ] + " " ) ; else document . write ( " " + a [ j ] + " " ) ; num = num >> 1 ; } document . write ( " " ) ; } } } let a = [ 3 , 5 , 6 , 8 ] ; let n = a . length ; let m = 5 ; printCombinations ( a , n , m ) ;
function __builtin_popcount ( n ) { var d , t = 0 ; while ( n > 0 ) { d = n % 2 ; n = parseInt ( n / 2 ) ; if ( d == 1 ) t ++ ; } return t ; } function smallerNumsWithSameSetBits ( n ) { var temp = __builtin_popcount ( n ) ; var count = 0 ; for ( var i = n - 1 ; i > 0 ; i -- ) { if ( temp == __builtin_popcount ( i ) ) count ++ ; } return count ; } var n = 4 ; document . write ( smallerNumsWithSameSetBits ( n ) ) ;
function multiplyWith4 ( n ) { return ( n << 2 ) ; } var n = 4 ; document . write ( multiplyWith4 ( n ) ) ;
function evenbitsetnumber ( n ) { let count = 0 , res = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; } let n = 10 ; document . write ( evenbitsetnumber ( n ) ) ;
function getmsb ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; } function getevenbits ( n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 1 ) n = n >> 1 ; return n ; } function setallevenbits ( n ) { return n | getevenbits ( n ) ; } let n = 10 ; document . write ( setallevenbits ( n ) ) ;
function oddbitsetnumber ( n ) { let count = 0 ; let res = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( n res ) ; } let n = 10 ; document . write ( oddbitsetnumber ( n ) ) ;
function getmsb ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( n + 1 ) >> 1 ; } function getevenbits ( n ) { n = getmsb ( n ) ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; if ( ( n & 1 ) == 0 ) n = n >> 1 ; return n ; } function setalloddbits ( n ) { return n | getevenbits ( n ) ; } let n = 10 ; document . write ( setalloddbits ( n ) ) ;
function printNumHavingAltBitPatrn ( n ) { var curr_num = 1 ; document . write ( curr_num + " " ) ; while ( true ) { curr_num <<= 1 ; if ( n < curr_num ) break ; document . write ( curr_num + " " ) ; curr_num = ( ( curr_num ) << 1 ) ^ 1 ; if ( n < curr_num ) break ; document . write ( curr_num + " " ) ; } } var n = 50 ; printNumHavingAltBitPatrn ( n ) ;
function perfectPowerOf2 ( n ) { let per_pow = 1 ; while ( n > 0 ) { per_pow = per_pow << 1 ; n = n >> 1 ; } return per_pow ; } let n = 128 ; document . write ( " " + n + " " + perfectPowerOf2 ( n ) ) ;
function findUniquePair ( arr , n ) { let XOR = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) XOR = XOR ^ arr [ i ] ; let set_bit_no = XOR & ~ ( XOR - 1 ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( " " + x + " " + y + " " + " " ) ; } let a = [ 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 ] ; let n = a . length ; findUniquePair ( a , n ) ;
function countUnsetBits ( n ) { let x = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return BitCount ( x ^ n ) ; } function BitCount ( x ) { let setBits = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; setBits ++ ; } return setBits ; } let n = 17 ; document . write ( countUnsetBits ( n ) ) ;
function countBits ( n ) { var count = 0 ; while ( n != 0 ) { count ++ ; n >>= 1 ; } return count ; } var i = 65 ; document . write ( countBits ( i ) ) ;
function toggle ( n ) { let temp = 1 ; while ( temp <= n ) { n = n ^ temp ; temp = temp << 1 ; } return n ; } let n = 10 ; n = toggle ( n ) ; document . write ( n ) ;
let INT_MAX = 2147483647 ; function isKthBitSet ( x , k ) { return ( ( x & ( 1 << ( k - 1 ) ) ) > 0 ) ? 1 : 0 ; } function leftmostSetBit ( x ) { let count = 0 ; while ( x > 0 ) { count ++ ; x = x >> 1 ; } return count ; } function isBinPalindrome ( x ) { let l = leftmostSetBit ( x ) ; let r = 1 ; while ( l > r ) { if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) return 0 ; l -- ; r ++ ; } return 1 ; } function findNthPalindrome ( n ) { let pal_count = 0 ; let i = 0 ; for ( i = 1 ; i <= INT_MAX ; i ++ ) { if ( isBinPalindrome ( i ) > 0 ) { pal_count ++ ; } if ( pal_count == n ) break ; } return i ; } let n = 9 ; document . write ( findNthPalindrome ( n ) ) ;
function LSB ( num , K ) { let x = ( num & ( 1 << ( K - 1 ) ) ) != 0 ; return ( x ) ; } let num = 10 , K = 4 ; if ( LSB ( num , K ) ) document . write ( " " ) ; else document . write ( " " ) ;
function areSame ( a , b ) { if ( ( a - b ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ; } areSame ( 10 , 20 ) ;
function toggleBitsFromLToR ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( n ^ num ) ; } var n = 50 ; var l = 2 , r = 5 ; document . write ( toggleBitsFromLToR ( n , l , r ) ) ;
function getRightMostSetBit ( n ) { if ( n == 0 ) return 0 ; return Math . log2 ( n & - n ) + 1 ; } function posOfRightMostDiffBit ( m , n ) { return getRightMostSetBit ( m ^ n ) ; } let m = 52 , n = 24 ; document . write ( " " + posOfRightMostDiffBit ( m , n ) + " " ) ;
function getNext ( n ) { let c = n ; let c0 = 0 ; let c1 = 0 ; while ( ( ( c & 1 ) == 0 ) && ( c != 0 ) ) { c0 ++ ; c >>= 1 ; } while ( ( c & 1 ) == 1 ) { c1 ++ ; c >>= 1 ; } if ( c0 + c1 == 31 c0 + c1 == 0 ) return - 1 ; return n + ( 1 << c0 ) + ( 1 << ( c1 - 1 ) ) - 1 ; } let n = 5 ; document . write ( getNext ( n ) + " " ) ; n = 8 ; document . write ( getNext ( n ) ) ;
function totalFlips ( A , B , C , N ) { let count = 0 ; for ( let i = 0 ; i < N ; ++ i ) { if ( A [ i ] == B [ i ] && C [ i ] == ' ' ) ++ count ; else if ( A [ i ] != B [ i ] && C [ i ] == ' ' ) ++ count ; } return count ; } let N = 5 ; let a = " " ; let b = " " ; let c = " " ; document . write ( totalFlips ( a , b , c , N ) ) ;
var a , b , c ; function swapThree ( ) { a = a ^ b ^ c ; b = a ^ b ^ c ; c = a ^ b ^ c ; a = a ^ b ^ c ; } a = 10 ; b = 20 ; c = 30 ; document . write ( " " + a + " " + b + " " + c ) ; swapThree ( ) ; document . write ( " " ) document . write ( " " + a + " " + b + " " + c ) ;
function findTwoMissingNumbers ( arr , n ) { let XOR = arr [ 0 ] ; for ( let i = 1 ; i < n - 2 ; i ++ ) XOR ^= arr [ i ] ; for ( let i = 1 ; i <= n ; i ++ ) XOR ^= i ; let set_bit_no = XOR & ~ ( XOR - 1 ) ; for ( let i = 0 ; i < n - 2 ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( let i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ; else y = y ^ i ; } document . write ( ` ${ x } ${ y } ` ) ; } let arr = [ 1 , 3 , 5 , 6 ] ; n = 2 + arr . length ; findTwoMissingNumbers ( arr , n ) ;
function countSetBits ( n ) { let count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } function findProffesion ( level , pos ) { let c = countSetBits ( pos - 1 ) ; return ( c % 2 != 0 ) ? ' ' : ' ' ; } let level = 3 , pos = 4 ; let prof = ( findProffesion ( level , pos ) == ' ' ) ? " " : " " ; document . write ( prof ) ; }
function findpair ( l , r ) { let ans1 = l ; let ans2 = 2 * l ; document . write ( ans1 + " " + ans2 ) ; } let l = 1 , r = 10 ; findpair ( l , r ) ;
function ElementsCalculationFunc ( pre , maxx , x , k , n ) { for ( let i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; } function MaxNumberOfElements ( a , n , k ) { a . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i <= n ; ++ i ) { pre [ i ] = 0 ; maxx [ i ] = 0 ; } for ( let i = 1 ; i <= n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] ; maxx [ i ] = Math . max ( maxx [ i - 1 ] , a [ i - 1 ] ) ; } let l = 1 , r = n , ans = 0 ; while ( l < r ) { let mid = Math . floor ( ( l + r ) / 2 ) ; if ( ElementsCalculationFunc ( pre , maxx , mid - 1 , k , n ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } document . write ( ans + " " ) ; } let arr = [ 2 , 4 , 9 ] ; let n = arr . length ; let k = 3 ; MaxNumberOfElements ( arr , n , k ) ;
function countCountries ( ans , N ) { let total_countries = 0 , i = 0 ; let invalid = false ; while ( i < N ) { let curr_size = ans [ i ] ; let num = ans [ i ] ; while ( num > 0 ) { if ( ans [ i ] != curr_size ) { document . write ( " " ) ; return ; } else num -- ; i ++ ; } total_countries ++ ; } document . write ( " " + total_countries + " " ) ; } let ans = [ 1 , 1 , 2 , 2 , 4 , 4 , 4 , 4 ] ; let n = 8 ; countCountries ( ans , n ) ;
function check_elements ( arr , n , A , B ) { let range = B - A ; for ( let i = 0 ; i < n ; i ++ ) { if ( Math . abs ( arr [ i ] ) >= A && Math . abs ( arr [ i ] ) <= B ) { let z = Math . abs ( arr [ i ] ) - A ; if ( arr [ z ] > 0 ) { arr [ z ] = arr [ z ] * - 1 ; } } } let count = 0 ; for ( let i = 0 ; i <= range && i < n ; i ++ ) { if ( arr [ i ] > 0 ) return false ; else count ++ ; } if ( count != ( range + 1 ) ) return false ; return true ; } let arr = [ 1 , 4 , 5 , 2 , 7 , 8 , 3 ] ; let n = arr . length ; let A = 2 , B = 5 ; if ( check_elements ( arr , n , A , B ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findMinRec ( A , n ) { if ( n == 1 ) return A [ 0 ] ; return Math . min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) ; } let A = [ 1 , 4 , 45 , 6 , - 50 , 10 , 2 ] ; let n = A . length ; document . write ( findMinRec ( A , n ) ) ;
function isPossible ( arr , n , m , curr_min ) { let studentsRequired = 1 ; let curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > curr_min ) return false ; if ( curr_sum + arr [ i ] > curr_min ) { studentsRequired ++ ; curr_sum = arr [ i ] ; if ( studentsRequired > m ) return false ; } else curr_sum += arr [ i ] ; } return true ; } function findPages ( arr , n , m ) { let sum = 0 ; if ( n < m ) return - 1 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; let start = 0 , end = sum ; let result = Number . MAX_VALUE ; while ( start <= end ) { let mid = Math . floor ( ( start + end ) / 2 ) ; if ( isPossible ( arr , n , m , mid ) ) { result = Math . min ( result , mid ) ; end = mid - 1 ; } else start = mid + 1 ; } return result ; } let arr = [ 12 , 34 , 67 , 90 ] ; document . write ( " " + findPages ( arr , arr . length , m ) ) ;
function countDistinct ( arr , n ) { let hs = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { hs . add ( arr [ i ] ) ; } return hs . size ; } let arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] ; document . write ( countDistinct ( arr , arr . length ) ) ;
function findOptimalSolution ( a , N ) { a . sort ( function ( a , b ) { return a - b } ) ; let points = 0 ; for ( let i = 0 ; i < N ; i ++ ) { points += a [ i ] * i ; } return points ; } let a = [ 1 , 4 , 2 , 3 , 9 ] ; let N = a . length ; document . write ( findOptimalSolution ( a , N ) ) ;
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; } let house = [ 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ] ; let range = 2 ; let n = house . length ; document . write ( number_of_tower ( house , range , n ) ) ;
function isAlphabaticOrder ( s ) { var n = s . length ; var c = new Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { c [ i ] = s [ i ] ; } c . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) if ( c [ i ] != s [ i ] ) return false ; return true ; } s = " " ; if ( isAlphabaticOrder ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function printOrder ( arr , k ) { let n = arr . length ; arr = arr . slice ( 0 , k ) . sort ( function ( a , b ) { return a - b ; } ) . concat ( arr . slice ( k , n ) . sort ( function ( a , b ) { return b - a ; } ) ) ; return arr ; } let arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; let k = 4 ; arr = printOrder ( arr , k ) ; document . write ( arr . join ( " " ) ) ;
function descOrder ( s ) { s . sort ( ) . reverse ( ) ; str1 = s . join ( " " ) ; document . write ( str1 ) ; } var s = " " ; s = s . split ( " " ) ; descOrder ( s ) ;
var MAX = 1000 ; function findDuplicate ( arr , n , k ) { var freq = Array . from ( { length : MAX } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { document . write ( " " ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( var i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; } var arr = [ 2 , 2 , 1 , 3 , 1 ] ; var k = 2 ; var n = arr . length ; document . write ( findDuplicate ( arr , n , k ) ) ;
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; var op = [ ... Array ( n ) ] ; var mid = parseInt ( ( n - 1 ) / 2 ) ; var j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( op [ i ] + " " ) ; document . write ( " " ) ; } var arr = [ 14 , 6 , 19 , 21 , 12 ] ; var n = arr . length ; pendulumArrangement ( arr , n ) ;
function minValue ( A , B , n ) { A . sort ( ) ; B . sort ( ) ; let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) result += ( A [ i ] * B [ n - i - 1 ] ) ; return result ; } let A = [ 3 , 1 , 1 ] ; let B = [ 6 , 5 , 4 ] ; let n = A . length ; document . write ( minValue ( A , B , n ) ) ;
function printMaxNumber ( n ) { if ( n & 1 ) { document . write ( " " ) ; for ( var i = 0 ; i < ( n - 3 ) / 2 ; i ++ ) document . write ( " " ) ; } else { for ( var i = 0 ; i < n / 2 ; i ++ ) document . write ( " " ) ; } } var n = 5 ; printMaxNumber ( n ) ;
function sorted_partitions ( arr ) { let n = arr . length ; let right_min = new Array ( n + 1 ) ; right_min . fill ( 0 ) ; right_min [ n ] = Number . MAX_VALUE ; for ( let i = n - 1 ; i >= 0 ; i -- ) { right_min [ i ] = Math . min ( right_min [ i + 1 ] , arr [ i ] ) ; } let partitions = 0 ; for ( let current_max = arr [ 0 ] , i = 0 ; i < n ; i ++ ) { current_max = Math . max ( current_max , arr [ i ] ) ; if ( current_max <= right_min [ i + 1 ] ) partitions ++ ; } return partitions ; } let arr = [ 3 , 1 , 2 , 4 , 100 , 7 , 9 ] ; let ans = sorted_partitions ( arr ) ; document . write ( ans ) ;
function getMinCost ( arr , n ) { let min_ele = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { min_ele = Math . min ( min_ele , arr [ i ] ) ; } return min_ele * ( n - 1 ) ; } let arr = [ 4 , 2 , 5 ] ; let n = arr . length ; document . write ( getMinCost ( arr , n ) ) ;
let st = " " ; let len = st . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( st [ i ] == ' ' ) n += 1 ; if ( st [ i ] == ' ' ) s += 1 ; if ( st [ i ] == ' ' ) w += 1 ; if ( st [ i ] == ' ' ) e += 1 ; } if ( n == s && w == e ) document . write ( " " ) ; else document . write ( " " ) ;
function cost ( a , n ) { let min = a [ 0 ] ; for ( let i = 1 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return ( n - 1 ) * min ; } let a = [ 4 , 3 , 2 ] ; let n = a . length ; document . write ( cost ( a , n ) ) ;
function minCost ( coin , n , k ) { coin . sort ( function ( a , b ) { return a - b } ) var coins_needed = Math . ceil ( n / ( k + 1 ) ) ; var ans = 0 ; for ( var i = 0 ; i <= coins_needed - 1 ; i ++ ) ans += coin [ i ] ; return ans ; } var coin = [ 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ] var n = coin . length ; var k = 3 ; document . write ( minCost ( coin , n , k ) ) ;
/ *	Utility function to count odd numbers in ith row of Pascals '
function sequence ( n ) { if ( n == 1 n == 2 ) return 1 ; else return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; } let n = 10 ; document . write ( sequence ( n ) ) ;
function numberOfWays ( x ) { if ( x == 0 x == 1 ) return 1 ; else return numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ; } var x = 3 ; document . write ( numberOfWays ( x ) ) ;
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; } let x = 3 ; document . write ( numberOfWays ( x ) ) ;
function findLongestRepeatingSubSeq ( str ) { let n = str . length ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; }
function waysToArrange ( N , K , k ) { let C = new Array ( N + 1 ) ; for ( let i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } let i , j ; for ( i = 0 ; i <= N ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) { C [ i ] [ j ] = 1 ; } else { C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) ; } } } let dp = Array . from ( { length : K + 1 } , ( _ , i ) => 0 ) ; let count = 0 ; dp [ 0 ] = 1 ; for ( i = 0 ; i < K ; i ++ ) { dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) ; count += k [ i ] ; } return dp [ K ] ; } let N = 4 ; let k = [ 2 , 2 ] ; let K = k . length ; document . write ( waysToArrange ( N , K , k ) ) ;
let SIZE = 100 ; function minCells ( mat , m , n ) { let dp = new Array ( m ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < m ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = Number . MAX_VALUE ; dp [ 0 ] [ 0 ] = 1 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] != Number . MAX_VALUE && ( j + mat [ i ] [ j ] ) < n && ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 ; if ( dp [ i ] [ j ] != Number . MAX_VALUE && ( i + mat [ i ] [ j ] ) < m && ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 ; } } if ( dp [ m - 1 ] [ n - 1 ] != Number . MAX_VALUE ) return dp [ m - 1 ] [ n - 1 ] ; return - 1 ; } let mat = [ [ 2 , 3 , 2 , 1 , 4 ] , [ 3 , 2 , 5 , 8 , 2 ] , [ 1 , 1 , 2 , 2 , 1 ] ] ; let m = 3 , n = 5 ; document . write ( " " + " " + minCells ( mat , m , n ) ) ;
let R = 3 ; let C = 3 ; function cal ( ones , x , y , k ) { return ones [ x + k - 1 ] [ y + k - 1 ] - ones [ x - 1 ] [ y + k - 1 ] - ones [ x + k - 1 ] [ y - 1 ] + ones [ x - 1 ] [ y - 1 ] ; } function sol ( mat ) { let ans = 0 ; let val = 0 ; let ones = new Array ( R + 1 ) ; for ( var i = 0 ; i < ones . length ; i ++ ) { ones [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < ones . length ; i ++ ) { for ( var j = 0 ; j < ones . length ; j ++ ) { ones [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= R ; i ++ ) for ( let j = 1 ; j <= C ; j ++ ) { if ( mat [ i - 1 ] [ j - 1 ] == 1 ) val = 1 ; ones [ i ] [ j ] = ones [ i - 1 ] [ j ] + ones [ i ] [ j - 1 ] - ones [ i - 1 ] [ j - 1 ] + ( val ) ; } for ( let k = 1 ; k <= Math . min ( R , C ) ; k ++ ) for ( let i = 1 ; i + k - 1 <= R ; i ++ ) for ( let j = 1 ; j + k - 1 <= C ; j ++ ) ans = Math . max ( ans , ( ones [ R ] [ C ] + k * k - 2 * cal ( ones , i , j , k ) ) ) ; return ans ; } let mat = [ [ 0 , 0 , 1 ] , [ 0 , 0 , 1 ] , [ 1 , 0 , 1 ] ] ; document . write ( sol ( mat ) ) ;
function getMinSteps ( n ) { let table = new Array ( n + 1 ) ; table . fill ( 0 ) ; table [ 1 ] = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ! ( i % 2 ) && ( i % 3 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , table [ i / 2 ] ) ; else if ( ! ( i % 3 ) && ( i % 2 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , table [ i / 3 ] ) ; else if ( ! ( i % 2 ) && ! ( i % 3 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , Math . min ( table [ i / 2 ] , table [ i / 3 ] ) ) ; else table [ i ] = 1 + table [ i - 1 ] ; } return table [ n ] + 1 ; } let n = 10 ; document . write ( getMinSteps ( n ) ) ;
function longestSubseqWithDiffOne ( arr , n ) { let dp = [ ] ; for ( let i = 0 ; i < n ; i ++ ) dp [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] == arr [ j ] + 1 ) || ( arr [ i ] == arr [ j ] - 1 ) ) dp [ i ] = Math . max ( dp [ i ] , dp [ j ] + 1 ) ; } } let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( result < dp [ i ] ) result = dp [ i ] ; return result ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ] ; let n = arr . length ; document . write ( longestSubseqWithDiffOne ( arr , n ) ) ;
function catalanDP ( n ) { let catalan = [ ] catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( let j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; } function countWays ( n ) { if ( n & 1 ) { document . write ( " " ) ; return 0 ; } return catalanDP ( n / 2 ) ; } document . write ( countWays ( 6 ) + " " ) ;
var MAX = 100 ; var dp = Array ( MAX ) . fill ( - 1 ) . map ( x => Array ( MAX ) . fill ( - 1 ) . map ( x => Array ( MAX ) . fill ( - 1 ) . map ( x => Array ( 3 ) . fill ( - 1 ) ) ) ) ; function countWays ( p , q , r , last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( dp [ p ] [ q ] [ r ] [ last ] != - 1 ) return dp [ p ] [ q ] [ r ] [ last ] ; if ( last == 0 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; else if ( last == 1 ) dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; else dp [ p ] [ q ] [ r ] [ last ] = countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return dp [ p ] [ q ] [ r ] [ last ] ; } function countUtil ( p , q , r ) { } var p = 1 , q = 1 , r = 1 ; document . write ( countUtil ( p , q , r ) ) ;
function countDer ( n ) { if ( n == 1 ) return 0 ; if ( n == 2 ) return 1 ; return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) ; } let n = 4 ; document . write ( " " + countDer ( n ) ) ;
function countDer ( n ) { let der = new Array ( n + 1 ) ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; ++ i ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; } let n = 4 ; document . write ( " " + countDer ( n ) ) ;
function countSol ( coeff , n , rhs ) { let dp = new Array ( rhs + 1 ) ; dp . fill ( 0 ) ; dp [ 0 ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = coeff [ i ] ; j <= rhs ; j ++ ) dp [ j ] += dp [ j - coeff [ i ] ] ; return dp [ rhs ] ; } let coeff = [ 2 , 2 , 5 ] ; let rhs = 4 ; let n = coeff . length ; document . write ( countSol ( coeff , n , rhs ) ) ;
function maxProd ( n ) { if ( n == 2 n == 3 ) { return ( n - 1 ) ; } let res = 1 ; while ( n > 4 ) { n -= 3 ; res *= 3 ; } return ( n * res ) ; } document . write ( " " + maxProd ( 10 ) ) ;
function findWays ( m , n , x ) { let table = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { table [ i ] = new Array ( x + 1 ) ; for ( let j = 0 ; j < ( x + 1 ) ; j ++ ) { table [ i ] [ j ] = 0 ; } } for ( let j = 1 ; j <= m && j <= x ; j ++ ) table [ 1 ] [ j ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= x ; j ++ ) { for ( let k = 1 ; k < j && k <= m ; k ++ ) table [ i ] [ j ] += table [ i - 1 ] [ j - k ] ; } } return table [ n ] [ x ] ; } document . write ( findWays ( 4 , 2 , 1 ) + " " ) ; document . write ( findWays ( 2 , 2 , 3 ) + " " ) ; document . write ( findWays ( 6 , 3 , 8 ) + " " ) ; document . write ( findWays ( 4 , 2 , 5 ) + " " ) ; document . write ( findWays ( 4 , 3 , 5 ) + " " ) ;
function max ( x , y ) { return ( x > y ) ? x : y ; } function lps ( seq , i , j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } let seq = " " ; let n = seq . length ; document . write ( " " , lps ( seq . split ( " " ) , 0 , n - 1 ) ) ;
function findCount ( str1 , str2 ) { var len = str1 . length ; var len2 = str2 . length ; var ans = 21474836473 ; var hash1 = new Array ( 26 ) . fill ( 0 ) ; var hash2 = new Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < len ; i ++ ) hash1 [ str1 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < len2 ; i ++ ) hash2 [ str2 [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( hash2 [ i ] ) ans = Math . min ( ans , hash1 [ i ] / hash2 [ i ] ) ; return ans ; } var str1 = " " ; var str2 = " " ; document . write ( findCount ( str1 , str2 ) ) ;
function isVowel ( c ) { let vowel = " " ; for ( let i = 0 ; i < vowel . length ; ++ i ) { if ( vowel [ i ] == c ) { return true ; } } return false ; } function printRLE ( str , typed ) { let n = str . length , m = typed . length ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] != typed [ j ] ) { return false ; } if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; } let count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; } let count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) { return false ; } } return true ; } let name = " " , typed = " " ; if ( printRLE ( name , typed ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function censor ( text , word ) { var word_list = text . split ( " " ) ; var result = " " ; var stars = " " ; for ( var i = 0 ; i < word . length ; i ++ ) stars += " " ; var index = 0 ; for ( const i of word_list ) { if ( i === word ) word_list [ index ] = stars ; index ++ ; } for ( const i of word_list ) { result += i + " " ; } return result ; } var extract = " " + " " + " " ; var cen = " " ; document . write ( censor ( extract , cen ) + " " ) ;
function getTime ( s , n ) { let res = " " ; let h = parseInt ( s . substring ( 0 , 0 + 2 ) ) ; let m = parseInt ( s . substring ( 3 , 3 + 2 ) ) ; let rev_h = ( h % 10 ) * 10 + ( ( h % 100 ) - ( h % 10 ) ) / 10 ; let rev_hs = ( rev_h ) . toString ( ) ; if ( h == 23 && m >= 32 ) { res = " " ; } else if ( m < rev_h ) { let temp = " " ; if ( h < 10 ) temp = " " ; temp = temp + h . toString ( ) ; if ( rev_h < 10 ) res = res + temp + " " + rev_hs ; else res = res + temp + " " + rev_hs ; } else { h ++ ; rev_h = ( h % 10 ) * 10 + ( ( h % 100 ) - ( h % 10 ) ) / 10 ; rev_hs = ( rev_h ) . toString ( ) ; let temp = " " ; if ( h < 10 ) temp = " " ; temp = temp + h . toString ( ) ; if ( rev_h < 10 ) res = res + temp + " " + rev_hs ; else res = res + temp + " " + rev_hs ; } return res ; } let s = " " ; let n = s . length ; document . write ( getTime ( s , n ) ) ;
function CountSubstring ( str , n ) { var ans = parseInt ( ( n * ( n + 1 ) ) / 2 ) ; var a_index = 0 ; var b_index = 0 ; var c_index = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] === " " ) { a_index = i + 1 ; ans -= Math . min ( b_index , c_index ) ; } else if ( str [ i ] === " " ) { b_index = i + 1 ; ans -= Math . min ( a_index , c_index ) ; } else { c_index = i + 1 ; ans -= Math . min ( a_index , b_index ) ; } } return ans ; } var str = " " . split ( " " ) ; var n = str . length ; document . write ( CountSubstring ( str , n ) ) ;
function isValid ( str , len ) { for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] == str [ i - 1 ] ) return false ; } return true ; } let str = " " ; let len = str . length ; if ( isValid ( str , len ) ) document . write ( " " ) ; else document . write ( " " ) ;
function check ( s , K ) { for ( var ch = 0 ; ch < 26 ; ch ++ ) { var c = String . fromCharCode ( ' ' . charCodeAt ( 0 ) + ch ) ; var last = - 1 ; var found = true ; for ( var i = 0 ; i < K ; i ++ ) if ( s [ i ] == c ) last = i ; if ( last == - 1 ) continue ; for ( var i = K ; i < s . length ; i ++ ) { if ( s [ i ] == c ) last = i ; if ( last <= ( i - K ) ) { found = false ; break ; } } if ( found ) return 1 ; } return 0 ; } function binarySearch ( s ) { var low = 1 , high = s . length ; var ans ; while ( low <= high ) { var mid = ( high + low ) >> 1 ; if ( check ( s , mid ) ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; } var s = " " ; document . write ( binarySearch ( s ) + " " ) ; s = " " ; document . write ( binarySearch ( s ) ) ;
const seg = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] ; function LedRequired ( s , led ) { var count = 0 ; for ( var i = 0 ; i < s . length ; ++ i ) { count += seg [ ( s [ i ] ) - 48 ] ; } if ( count <= led ) return " " ; else return " " ; } var S = " " ; var led = 20 ; document . write ( LedRequired ( S , led ) + " " ) ;
function vowel_calc ( s ) { var n = s . length ; var arr = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( i == 0 ) arr . push ( n ) ; else arr . push ( ( n - i ) + arr [ i - 1 ] - i ) ; } var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) sum += arr [ i ] ; return sum ; } var s = " " ; document . write ( vowel_calc ( s ) ) ;
function solve ( s , k ) { var count = 0 , length = 0 , pos = 0 ; var m = new Map ( ) ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! m . has ( s [ i ] ) ) { m . set ( s [ i ] , 0 ) ; } m . set ( s [ i ] , m . get ( s [ i ] ) + 1 ) ; length ++ ; if ( length > k ) { if ( ! m . has ( s [ pos ] ) ) { m . set ( s [ pos ] , 0 ) ; } m . set ( s [ pos ] , m [ s [ pos ] ] - 1 ) ; pos += 1 ; length -- ; } if ( length == k && m . get ( s [ i ] ) == length ) count ++ ; } document . write ( count ) ; } var s = " " ; var k = 4 ; solve ( s , k ) ;
var str = " " ; var newStr = str . split ( " " ) ; for ( var i = 0 ; i < newStr . length ; ++ i ) { if ( newStr [ i ] === " " ) { newStr [ i ] = " " ; } } document . write ( newStr . join ( " " ) + " " ) ;
function solve ( n , l ) { if ( l < 3 ) { if ( parseInt ( n ) % 8 === 0 ) return true ; n = reverse ( n ) ; if ( parseInt ( n ) % 8 === 0 ) return true ; return false ; } var hash = new Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < l ; i ++ ) hash [ parseInt ( n [ i ] ) - 0 ] ++ ; for ( var i = 104 ; i < 1000 ; i += 8 ) { var dup = i ; var freq = new Array ( 10 ) . fill ( 0 ) ; freq [ parseInt ( dup % 10 ) ] ++ ; dup = dup / 10 ; freq [ parseInt ( dup % 10 ) ] ++ ; dup = dup / 10 ; freq [ parseInt ( dup % 10 ) ] ++ ; dup = i ; if ( freq [ parseInt ( dup % 10 ) ] > hash [ parseInt ( dup % 10 ) ] ) continue ; dup = dup / 10 ; if ( freq [ parseInt ( dup % 10 ) ] > hash [ parseInt ( dup % 10 ) ] ) continue ; dup = dup / 10 ; if ( freq [ parseInt ( dup % 10 ) ] > hash [ parseInt ( dup % 10 ) ] ) continue ; return true ; } return false ; } function reverse ( input ) { var a = input . split ( " " ) ; var l , r = 0 ; r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { var temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return a . join ( " " ) ; } var number = " " ; var l = number . length ; if ( solve ( number , l ) ) document . write ( " " ) ; else document . write ( " " ) ;
function newString ( s , k ) { var X = " " ; while ( s . length > 0 ) { var temp = s [ 0 ] ; for ( var i = 1 ; i < k && i < s . length ; i ++ ) { if ( s [ i ] < temp ) { temp = s [ i ] ; } } X = X + temp ; for ( var i = 0 ; i < k ; i ++ ) { if ( s [ i ] === temp ) { s = s . substring ( 0 , i ) + s . substring ( i + 1 ) ; break ; } } } return X ; } var s = " " ; var k = 3 ; document . write ( newString ( s , k ) ) ;
function strToBinary ( s ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { let val = ( s [ i ] ) . charCodeAt ( 0 ) ; let bin = " " ; while ( val > 0 ) { if ( val % 2 == 1 ) { bin += ' ' ; } else bin += ' ' ; val = Math . floor ( val / 2 ) ; } bin = reverse ( bin ) ; document . write ( bin + " " ) ; } } function reverse ( input ) { a = input . split ( " " ) ; let l , r = 0 ; r = a . length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { let temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return ( a ) . join ( " " ) ; } let s = " " ; strToBinary ( s ) ;
function printSequence ( arr , input ) { let output = " " ; let n = input . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( input [ i ] == ' ' ) output = output + " " . charCodeAt ( 0 ) ; else { let position = input [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; output = output + arr [ position ] ; } } return output ; } let str = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] let input = " " ; document . write ( printSequence ( str , input ) ) ;
function isEven ( s ) { let l = s . length ; let dotSeen = false ; for ( let i = l - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' && dotSeen == false ) continue ; if ( s [ i ] == ' ' ) { dotSeen = true ; continue ; } if ( ( s [ i ] - ' ' ) % 2 == 0 ) return true ; return false ; } } let s = " " ; if ( isEven ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
let NO_OF_CHARS = 256 ; function max_distinct_char ( str , n ) { let count = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { count [ str [ i ] . charCodeAt ( 0 ) ] ++ ; } let max_distinct = 0 ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; } function smallesteSubstr_maxDistictChar ( str ) { let n = str . length ; let max_distinct = max_distinct_char ( str , n ) ; let minl = n ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let subs = null ; if ( i < j ) subs = str . substring ( i , j ) ; else subs = str . substring ( j , i ) ; let subs_lenght = subs . length ; let sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; } let str = " " ; let len = smallesteSubstr_maxDistictChar ( str ) ; document . write ( " " + " " + " " + len ) ;
function evaluateBoolExpr ( s ) { let n = s . length ; for ( let i = 0 ; i < n ; i += 2 ) { if ( i + 1 < n && i + 2 < n ) { if ( s [ i + 1 ] == ' ' ) { if ( s [ i + 2 ] == ' ' s [ i ] == 0 ) { s [ i + 2 ] = ' ' ; } else { s [ i + 2 ] = ' ' ; } } else if ( ( i + 1 ) < n && s [ i + 1 ] == ' ' ) { if ( s [ i + 2 ] == ' ' s [ i ] == ' ' ) { s [ i + 2 ] = ' ' ; } else { s [ i + 2 ] = ' ' ; } } else { if ( s [ i + 2 ] == s [ i ] ) { s [ i + 2 ] = ' ' ; } else { s [ i + 2 ] = ' ' ; } } } } return ( s [ n - 1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; } let s = " " ; let sb = s . split ( ' ' ) ; document . write ( evaluateBoolExpr ( sb ) + " " ) ;
function FirstRepeated ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return i ; checker |= ( 1 << val ) ; } return - 1 ; } let s = " " ; let i = FirstRepeated ( s ) ; if ( i != - 1 ) document . write ( " " + s [ i ] + " " + i ) ; else document . write ( " " ) ;
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; } let str = " " ; document . write ( evenNumSubstring ( str ) ) ;
function isSubSequence ( str1 , str2 ) { var m = str1 . length , n = str2 . length ; for ( var i = 0 ; i < n && j < m ; i ++ ) if ( str1 [ j ] == str2 [ i ] ) j ++ ; return ( j == m ) ; } function findLongestString ( dict , str ) { var result = " " ; var length = 0 ; dict . forEach ( word => { if ( length < word . length && isSubSequence ( word , str ) ) { result = word ; length = word . length ; } } ) ; return result ; } var dict = [ " " , " " , " " , " " ] ; var str = " " ; document . write ( findLongestString ( dict , str ) ) ;
function isEditDistanceOne ( s1 , s2 ) { let m = s1 . length , n = s2 . length ; if ( Math . abs ( m - n ) > 1 ) return false ; let count = 0 ; let i = 0 , j = 0 ; while ( i < m && j < n ) { if ( s1 [ i ] != s2 [ j ] ) { if ( count == 1 ) return false ; if ( m > n ) i ++ ; else if ( m < n ) j ++ ; else { i ++ ; j ++ ; } count ++ ; } else { i ++ ; j ++ ; } } if ( i < m j < n ) count ++ ; return count == 1 ; } let s1 = " " ; let s2 = " " ; if ( isEditDistanceOne ( s1 , s2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countSubStr ( str , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( str [ j ] == ' ' ) res ++ ; } } } return res ; } let string = " " ; let n = string . length ; document . write ( countSubStr ( string , n ) ) ;
function exponentMod ( A , B , C ) { if ( A == 0 ) return 0 ; if ( B == 0 ) return 1 ; var y ; if ( B % 2 == 0 ) { y = exponentMod ( A , B / 2 , C ) ; y = ( y * y ) % C ; } else { y = A % C ; y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C ; } return parseInt ( ( ( y + C ) % C ) ) ; } var A = 2 , B = 5 , C = 13 ; document . write ( " " + exponentMod ( A , B , C ) ) ;
function power ( x , y , p ) { let res = 1 ; x = x % p ; if ( x == 0 ) return 0 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; y = $y / 2 y = y >> 1 ; x = ( x * x ) % p ; } return res ; } let x = 2 ; let y = 5 ; let p = 13 ; document . write ( " " + power ( x , y , p ) ) ;
function trianglearea ( a ) { if ( a < 0 ) return - 1 ; var area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / 4 ; return area . toFixed ( 4 ) ; } var a = 6 ; document . write ( trianglearea ( a ) ) ;
function equation_ellipse ( x1 , y1 , a , b , c , e ) { var t = a * a + b * b ; var a1 = t - e * ( a * a ) ; var b1 = t - e * ( b * b ) ; var c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) ; var d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) ; var e1 = - 2 * e * a * b ; var f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) ; document . write ( " " + " " ) ; document . write ( a1 + " " + b1 + " " + c1 + " " + d1 + " " + e1 + " " + f1 + " " ) ; } var x1 = 1 , y1 = 1 , a = 1 , b = - 1 , c = 3 , e = 0.5 * 0.5 ; equation_ellipse ( x1 , y1 , a , b , c , e ) ;
let PI = 3.14 ; function circle_inscribed ( a ) { return PI * ( a * a ) / 12 ; } let a = 4 ; document . write ( circle_inscribed ( a ) . toFixed ( 5 ) ) ;
function findVolume ( u , v , w , U , V , W , b ) { let uPow = Math . pow ( u , 2 ) ; let vPow = Math . pow ( v , 2 ) ; let wPow = Math . pow ( w , 2 ) ; let UPow = Math . pow ( U , 2 ) ; let VPow = Math . pow ( V , 2 ) ; let WPow = Math . pow ( W , 2 ) ; let a = 4 * ( uPow * vPow * wPow ) - uPow * Math . pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * Math . pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * Math . pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ; let vol = Math . sqrt ( a ) ; vol /= b ; document . write ( vol . toFixed ( 4 ) ) ; } let u = 1000 , v = 1000 , w = 1000 ; let U = 3 , V = 4 , W = 5 ; let b = 12 ; findVolume ( u , v , w , U , V , W , b ) ;
function makePolygon ( a ) { var n = parseFloat ( 360 / ( 180 - a ) ) ; if ( n === parseInt ( n ) ) document . write ( " " ) ; else document . write ( " " ) ; } var a = 90 ; makePolygon ( a ) ;
function getQuadrant ( X , Y , R , PX , PY ) { if ( PX == X && PY == Y ) return 0 ; let val = Math . pow ( ( PX - X ) , 2 ) + Math . pow ( ( PY - Y ) , 2 ) ; if ( val > Math . pow ( R , 2 ) ) return - 1 ; if ( PX > X && PY >= Y ) return 1 ; if ( PX <= X && PY > Y ) return 2 ; if ( PX < X && PY <= Y ) return 3 ; if ( PX >= X && PY < Y ) return 4 ; } let X = 0 , Y = 3 ; let R = 2 ; let PX = 1 , PY = 4 ; let ans = getQuadrant ( X , Y , R , PX , PY ) ; if ( ans == - 1 ) document . write ( " " + " " ) ; else if ( ans == 0 ) document . write ( " " + " " ) ; else document . write ( ans + " " + " " ) ;
function hexadecagonalNum ( n ) { return ( ( 14 * n * n ) - 12 * n ) / 2 ; } var n = 5 ; document . write ( n + " " + " " + hexadecagonalNum ( n ) + " " ) ; n = 9 ; document . write ( n + " " + " " + hexadecagonalNum ( n ) ) ;
function perimeter ( diameter , height ) { return 2 * ( diameter + height ) ; } let diameter = 5 ; let height = 10 ; document . write ( " " + perimeter ( diameter , height ) + " " ) ;
let ax = 5 , ay = 0 ; let bx = 1 , by = 1 ; let cx = 2 , cy = 5 ; document . write ( ax + bx - cx + " " + ( ay + by - cy ) + " " ) ; document . write ( ax + cx - bx + " " + ( ay + cy - by ) + " " ) ; document . write ( cx + bx - ax + " " + ( cy + by - ax ) + " " ) ;
function area ( x1 , y1 , x2 , y2 , x3 , y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } function check ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 , x , y ) { let A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ; let A1 = area ( x , y , x1 , y1 , x2 , y2 ) ; let A2 = area ( x , y , x2 , y2 , x3 , y3 ) ; let A3 = area ( x , y , x3 , y3 , x4 , y4 ) ; let A4 = area ( x , y , x1 , y1 , x4 , y4 ) ; return ( A == A1 + A2 + A3 + A4 ) ; } if ( check ( 0 , 10 , 10 , 0 , 0 , - 10 , - 10 , 0 , 10 , 15 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; } document . write ( findMaximumPieces ( 3 ) ) ;
function KnapSack ( val , wt , n , W ) { let mat = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { mat [ i ] = new Array ( W + 1 ) ; } for ( let i = 0 ; i < 2 ; i ++ ) { for ( let j = 0 ; j < W + 1 ; j ++ ) { mat [ i ] [ j ] = 0 ; } } let i = 0 ; { if ( i % 2 != 0 ) { { { mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; { mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; } else { mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; } let val = [ 7 , 8 , 4 ] ; let wt = [ 3 , 8 , 6 ] ; let W = 10 , n = 3 ; document . write ( KnapSack ( val , wt , n , W ) ) ;
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + " " ) ; } } function findNumbers ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; reverse ( arr ) ; let freq = new Array ( arr [ 0 ] + 1 ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } let size = parseInt ( Math . sqrt ( n ) , 10 ) ; let brr = new Array ( size ) ; brr . fill ( 0 ) ; let x , l = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( freq [ arr [ i ] ] > 0 && l < size ) { brr [ l ] = arr [ i ] ; freq [ brr [ l ] ] -- ; l ++ ; for ( let j = 0 ; j < l ; j ++ ) { if ( i != j ) { x = __gcd ( arr [ i ] , brr [ j ] ) ; freq [ x ] -= 2 ; } } } } printArr ( brr , size ) ; } function reverse ( input ) { let last = input . length - 1 ; let middle = parseInt ( input . length / 2 , 10 ) ; for ( let i = 0 ; i <= middle ; i ++ ) { let temp = input [ i ] ; input [ i ] = input [ last - i ] ; input [ last - i ] = temp ; } } function __gcd ( a , b ) { if ( b == 0 ) { return a ; } return __gcd ( b , a % b ) ; } let arr = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5 , 5 , 5 , 7 , 10 , 12 , 2 , 2 ] ; let n = arr . length ; findNumbers ( arr , n ) ;
function AlternateRearrange ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 0 ) v1 . push ( arr [ i ] ) ; else v2 . push ( arr [ i ] ) ; var index = 0 , i = 0 , j = 0 ; var flag = false ; if ( arr [ 0 ] % 2 == 0 ) flag = true ; while ( index < n ) { if ( flag == true ) { arr [ index ++ ] = v1 [ i ++ ] ; flag = ! flag ; } else { arr [ index ++ ] = v2 [ j ++ ] ; flag = ! flag ; } } for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; } var arr = [ 9 , 8 , 13 , 2 , 19 , 14 ] ; var n = arr . length ; AlternateRearrange ( arr , n ) ;
function getNumToAdd ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; var d = arr [ 1 ] - arr [ 0 ] ; var numToAdd = - 1 ; var numAdded = false ; for ( var i = 2 ; i < n ; i ++ ) { var diff = arr [ i ] - arr [ i - 1 ] ; if ( diff != d ) { if ( numAdded ) return - 1 ; if ( diff == 2 * d ) { numToAdd = arr [ i ] - d ; numAdded = true ; } else return - 1 ; } } if ( numToAdd == - 1 ) return ( arr [ n - 1 ] + d ) ; return numToAdd ; } var arr = [ 1 , 3 , 5 , 7 , 11 , 13 , 15 ] ; var n = arr . length ; document . write ( getNumToAdd ( arr , n ) ) ;
function items ( n , a ) { a . sort ( function ( a , b ) { return a - b } ) ; let z = a [ n - 1 ] ; let x = 1 ; let s = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { s += a [ i ] ; if ( s <= z ) x += 1 ; else break ; } return x ; } let n = 5 ; let a = [ 5 , 3 , 1 , 5 , 6 ] ; document . write ( items ( n , a ) ) ;
function numBoxes ( A , n , K ) { A . sort ( function ( a , b ) { return a - b } ) ; let i = 0 , j = ( n - 1 ) ; let ans = 0 ; while ( i <= j ) { ans ++ ; if ( A [ i ] + A [ j ] <= K ) i ++ ; j -- ; } return ans ; } let A = [ 3 , 2 , 2 , 1 ] ; let K = 3 ; let n = A . length ; document . write ( numBoxes ( A , n , K ) ) ;
function solve ( N , M , cp , sp ) { let profit = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) profit [ i ] = sp [ i ] - cp [ i ] ; profit . sort ( function ( a , b ) { return b - a ; } ) ; let sum = 0 ; for ( let i = 0 ; i < M ; i ++ ) { if ( profit [ i ] > 0 ) sum += profit [ i ] ; else break ; } return sum ; } let N = 5 , M = 3 ; let CP = [ 5 , 10 , 35 , 7 , 23 ] ; let SP = [ 11 , 10 , 0 , 9 , 19 ] ; document . write ( solve ( N , M , CP , SP ) ) ;
function findMaxNum ( arr , n ) { arr . sort ( function ( a , b ) { return b - a ; } ) ; var num = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { num = num * 10 + arr [ i ] ; } return num ; } var arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] ; var n = arr . length ; document . write ( findMaxNum ( arr , n ) ) ;
function minimumSets ( arr , n , key ) { var i , j ; arr . sort ( ( a , b ) => a - b ) for ( i = 0 , j = n - 1 ; i <= j ; ++ i ) if ( arr [ i ] + arr [ j ] <= key ) j -- ; return i ; } var arr = [ 3 , 5 , 3 , 4 ] ; var n = arr . length ; var key = 5 ; document . write ( minimumSets ( arr , n , key ) ) ;
function minimumBox ( arr , n ) { var q = [ ] ; arr . sort ( ( a , b ) => a - b ) q . push ( arr [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { var now = q [ 0 ] ; if ( arr [ i ] >= 2 * now ) q . pop ( 0 ) ; q . push ( arr [ i ] ) ; } return q . length ; } var arr = [ 4 , 1 , 2 , 8 ] ; var n = arr . length ; document . write ( minimumBox ( arr , n ) ) ;
function sortBinaryArray ( a , n ) { let j = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] < 1 ) { j ++ ; let temp = a [ j ] ; a [ j ] = a [ i ] ; a [ i ] = temp ; } } } let a = [ 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 ] ; let n = a . length ; sortBinaryArray ( a , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + " " ) ;
function findDuplicate ( arr , n , k ) { arr . sort ( ) ; let i = 0 ; while ( i < n ) { let j , count = 1 ; for ( j = i + 1 ; j < n && arr [ j ] == arr [ i ] ; j ++ ) count ++ ; if ( count == k ) return arr [ i ] ; i = j ; } return - 1 ; } let arr = [ 2 , 2 , 1 , 3 , 1 ] ; let k = 2 ; let n = arr . length ; document . write ( findDuplicate ( arr , n , k ) ) ;
function checkForSorting ( arr , n ) { let temp = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] > arr [ i + 1 ] ) { if ( arr [ i ] - arr [ i + 1 ] == 1 ) { temp = arr [ i ] ; arr [ i ] = arr [ i + 1 ] ; arr [ i + 1 ] = temp ; } else return false ; } } return true ; } let arr = new Array ( 1 , 0 , 3 , 2 ) ; let n = arr . length ; if ( checkForSorting ( arr , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function ksmallest ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( let i = 1 ; i < n ; i ++ ) { let c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; } let k = 1 ; let arr = [ 1 ] ; let n = arr . length ; document . write ( ksmallest ( arr , n , k ) ) ;
function isEven ( n ) { return ( ! ( n & 1 ) ) ; } let n = 101 ; isEven ( n ) ? document . write ( " " ) : document . write ( " " ) ;
function findSubsequenceCount ( S , T ) { let m = T . length ; let n = S . length ; if ( m > n ) return 0 ; let mat = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { mat [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { mat [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) mat [ i ] [ 0 ] = 0 ; for ( let j = 0 ; j <= n ; j ++ ) mat [ 0 ] [ j ] = 1 ; for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( T [ i - 1 ] != S [ j - 1 ] ) mat [ i ] [ j ] = mat [ i ] [ j - 1 ] ; else mat [ i ] [ j ] = mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ; } } return mat [ m ] [ n ] ; } let T = " " ; let S = " " ; document . write ( findSubsequenceCount ( S , T ) ) ;
using System ; using System . Collections ; class GfG { function Check ( a , b , n , m ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( a [ i ] [ j ] > b [ i ] [ j ] ) { let temp = a [ i ] [ j ] ; a [ i ] [ j ] = b [ i ] [ j ] ; b [ i ] [ j ] = temp ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m - 1 ; j ++ ) if ( a [ i ] [ j ] >= a [ i ] [ j + 1 ] b [ i ] [ j ] >= b [ i ] [ j + 1 ] ) return " " ; for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( a [ i ] [ j ] >= a [ i + 1 ] [ j ] b [ i ] [ j ] >= b [ i + 1 ] [ j ] ) return " " ; return " " ; } let n = 2 , m = 2 ; let a = [ [ 2 , 10 ] , [ 11 , 5 ] ] ; let b = [ [ 9 , 4 ] , [ 3 , 12 ] ] ; document . write ( Check ( a , b , n , m ) ) ;
function smallestString ( N , A ) { let ch = ' ' ; let S = " " ; if ( N < 1 A [ 0 ] != 1 ) { S = " " ; return S ; } S += ch ; ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; for ( let i = 1 ; i < N ; i ++ ) { let diff = A [ i ] - A [ i - 1 ] ; if ( diff > 1 diff < 0 A [ i ] > 26 ) { S = " " ; return S ; } else if ( diff == 0 ) S += ' ' ; else { S += ch ; ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; } } return S ; } let arr = [ 1 , 1 , 2 , 3 , 3 ] ; let n = arr . length ; document . write ( smallestString ( n , arr ) ) ;
function canBePicked ( digits , num ) { var copyDigits = new Array ( 10 ) ; ; for ( var i = 0 ; i < 10 ; i ++ ) copyDigits [ i ] = digits [ i ] ; while ( num > 0 ) { var digit = num % 10 ; if ( copyDigits [ digit ] == 0 ) return false ; else copyDigits [ digit ] -= 1 ; num = Math . floor ( num / 10 ) ; } return true ; } function countAlphabets ( n ) { var count = 0 ; var digits = new Array ( 10 ) ; digits . fill ( 0 ) ; while ( n > 0 ) { var digit = n % 10 ; digits [ digit ] += 1 ; n = Math . floor ( n / 10 ) ; } for ( var i = 97 ; i <= 122 ; i ++ ) if ( canBePicked ( digits , i ) ) count += 1 ; for ( var i = 65 ; i < 91 ; i ++ ) if ( canBePicked ( digits , i ) ) count += 1 ; return count ; } var n = 1623455078 ; document . write ( countAlphabets ( n ) ) ;
function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } function findTwoNumbers ( sum , gcd ) { if ( __gcd ( gcd , sum - gcd ) == gcd && sum != gcd ) document . write ( " " + Math . min ( gcd , sum - gcd ) + " " + ( sum - Math . min ( gcd , sum - gcd ) ) ) ; else document . write ( - 1 ) ; } let sum = 8 ; let gcd = 2 ; findTwoNumbers ( sum , gcd ) ;
function findMaxDistance ( numOfCities , station , n ) { var hasStation = Array ( numOfCities + 1 ) . fill ( false ) ; for ( var city = 0 ; city < n ; city ++ ) { hasStation [ station [ city ] ] = true ; } var dist = 0 ; var maxDist = 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { maxDist = Math . min ( station [ i ] , maxDist ) ; } for ( var city = 0 ; city < numOfCities ; city ++ ) { if ( hasStation [ city ] == true ) { maxDist = Math . max ( ( dist + 1 ) / 2 , maxDist ) ; dist = 0 ; } else dist += 1 ; } return Math . max ( maxDist , dist ) ; } var numOfCities = 6 ; var station = [ 3 , 1 ] ; var n = station . length ; document . write ( " " + findMaxDistance ( numOfCities , station , n ) ) ;
function split ( x , n ) { if ( x < n ) document . write ( " " ) ; else if ( x % n == 0 ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( ( x / n ) + " " ) ; } else { let zp = n - ( x % n ) ; let pp = Math . floor ( x / n ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i >= zp ) document . write ( ( pp + 1 ) + " " ) ; else document . write ( pp + " " ) ; } } } let x = 5 ; let n = 3 ; split ( x , n ) ;
function cal_minimum_time ( X ) { let t = 0 ; let sum = 0 ; while ( sum < X ) { t ++ ; sum = sum + t ; } return t ; } let n = 6 ; let ans = cal_minimum_time ( n ) ; document . write ( " " + ans ) ;
function solve ( v , n ) { let ans , ul , ll ; let first = 0 ; let second = 1 ; ll = v [ 0 ] [ first ] ; ul = v [ 0 ] [ second ] ; ans = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( ( v [ i ] [ first ] <= ul && v [ i ] [ first ] >= ll ) || ( v [ i ] [ second ] >= ll && v [ i ] [ second ] <= ul ) ) { if ( v [ i ] [ first ] > ll ) { ll = v [ i ] [ first ] ; } if ( v [ i ] [ second ] < ul ) { ul = v [ i ] [ second ] ; } } else if ( v [ i ] [ first ] > ul ) { ans += Math . abs ( ul - v [ i ] [ first ] ) ; ul = v [ i ] [ first ] ; ll = v [ i ] [ first ] ; } else if ( v [ i ] [ second ] < ll ) { ans += Math . abs ( ll - v [ i ] [ second ] ) ; ul = v [ i ] [ second ] ; ll = v [ i ] [ second ] ; } } return ans ; } let v = [ [ 1 , 3 ] , [ 2 , 5 ] , [ 6 , 8 ] , [ 1 , 2 ] , [ 2 , 3 ] ] ; let n = 5 ; document . write ( solve ( v , n ) ) ;
function preProcess ( n ) { let preProcessedCubes = [ ] ; for ( let i = 1 ; i * i * i <= n ; i ++ ) { let iThCube = i * i * i ; let cubeString = ( iThCube ) . toString ( ) ; preProcessedCubes . push ( cubeString ) ; } return preProcessedCubes ; } function findLargestCubeUtil ( num , preProcessedCubes ) { ( preProcessedCubes ) . reverse ( ) ; let totalCubes = preProcessedCubes . length ; for ( let i = 0 ; i < totalCubes ; i ++ ) { let currCube = preProcessedCubes [ i ] ; let digitsInCube = currCube . length ; let index = 0 ; let digitsInNumber = num . length ; for ( let j = 0 ; j < digitsInNumber ; j ++ ) { if ( num [ j ] == currCube [ index ] ) { index ++ ; } if ( digitsInCube == index ) { return currCube ; } } } return " " ; } function findLargestCube ( n ) { let preProcessedCubes = preProcess ( n ) ; let num = ( n ) . toString ( ) ; let ans = findLargestCubeUtil ( num , preProcessedCubes ) ; document . write ( " " + n + " " + ans + " " ) ; } let n ; n = 4125 ; findLargestCube ( n ) ; n = 876 ; findLargestCube ( n ) ;
function noAdjacentDup ( s1 ) { let n = s1 . length ; let s = s1 . split ( ' ' ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { s [ i ] = ' ' ; while ( s [ i ] == s [ i - 1 ] || ( i + 1 < n && s [ i ] == s [ i + 1 ] ) ) s [ i ] ++ ; i ++ ; } } return ( s ) ; } let s = " " ; document . write ( noAdjacentDup ( s ) ) ;
function winner ( a , n , k ) { if ( k >= n - 1 ) return n ; let best = 0 , times = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > best ) { best = a [ i ] ; if ( i ) times = 1 ; } else times += 1 ; if ( times >= k ) return best ; } return best ; } let a = [ 2 , 1 , 3 , 4 , 5 ] ; let n = a . length ; let k = 2 ; document . write ( winner ( a , n , k ) ) ;
let MAX = 100000 ; let bitscount = 32 ; let prefix_count = new Array ( bitscount ) ; for ( let i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) { prefix_count [ i ] [ j ] = 0 ; } } function findPrefixCount ( arr , n ) { for ( let i = 0 ; i < bitscount ; i ++ ) { prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; for ( let j = 1 ; j < n ; j ++ ) { prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] ; } } } function rangeOr ( l , r ) { let ans = 0 ; for ( let i = 0 ; i < bitscount ; i ++ ) { let x ; if ( l == 0 ) x = prefix_count [ i ] [ r ] ; else x = prefix_count [ i ] [ r ] - prefix_count [ i ] [ l - 1 ] ; if ( x != 0 ) ans = ( ans | ( 1 << i ) ) ; } return ans ; } let arr = [ 7 , 5 , 3 , 5 , 2 , 3 ] ; let n = arr . length ; findPrefixCount ( arr , n ) ; let queries = [ [ 1 , 3 ] , [ 4 , 5 ] ] ; let q = queries . length ; for ( let i = 0 ; i < q ; i ++ ) document . write ( rangeOr ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) + " " ) ;
function BellmanFord ( graph , V , E , src ) { var dis = Array ( V ) . fill ( 1000000000 ) ; dis [ src ] = 0 ; for ( var i = 0 ; i < V - 1 ; i ++ ) { for ( var j = 0 ; j < E ; j ++ ) { if ( ( dis [ graph [ j ] [ 0 ] ] + graph [ j ] [ 2 ] ) < dis [ graph [ j ] [ 1 ] ] ) dis [ graph [ j ] [ 1 ] ] = dis [ graph [ j ] [ 0 ] ] + graph [ j ] [ 2 ] ; } } for ( var i = 0 ; i < E ; i ++ ) { var x = graph [ i ] [ 0 ] ; var y = graph [ i ] [ 1 ] ; var weight = graph [ i ] [ 2 ] ; if ( ( dis [ x ] != 1000000000 ) && ( dis [ x ] + weight < dis [ y ] ) ) document . write ( " " + " " ) ; } document . write ( " " ) ; for ( var i = 0 ; i < V ; i ++ ) document . write ( i + " " + dis [ i ] + " " ) ; } var graph = [ [ 0 , 1 , - 1 ] , [ 0 , 2 , 4 ] , [ 1 , 2 , 3 ] , [ 1 , 3 , 2 ] , [ 1 , 4 , 2 ] , [ 3 , 2 , 5 ] , [ 3 , 1 , 1 ] , [ 4 , 3 , - 3 ] ] ; BellmanFord ( graph , V , E , 0 ) ;
let maxn = 16 ; function precompute ( ) { let dp = new Array ( maxn ) ; let arr = [ 4 , 6 , 9 ] ; for ( let i = 0 ; i < maxn ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let i = 1 ; i < maxn ; ++ i ) { for ( let k = 0 ; k < 3 ; k ++ ) { let j = arr [ k ] ; if ( i >= j && dp [ i - j ] != - 1 ) { dp [ i ] = Math . max ( dp [ i ] , dp [ i - j ] + 1 ) ; } } } return dp ; } function Maximum_Summands ( dp , n ) { if ( n < maxn ) return dp [ n ] ; else { let t = parseInt ( ( n - maxn ) / 4 , 10 ) + 1 ; return t + dp [ n - 4 * t ] ; } } let n = 12 ; $n = 12 ; let dp = precompute ( ) ; document . write ( Maximum_Summands ( dp , n ) ) ;
var N = 4 function getSum ( r1 , r2 , c1 , c2 , dp ) { return dp [ r2 ] [ c2 ] - dp [ r2 ] [ c1 ] - dp [ r1 ] [ c2 ] + dp [ r1 ] [ c1 ] ; } function sumFound ( K , S , grid ) { var dp = Array . from ( Array ( N + 1 ) , ( ) => Array ( N + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < N ; i ++ ) for ( var j = 0 ; j < N ; j ++ ) dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] - dp [ i ] [ j ] + grid [ i ] [ j ] ; for ( var i = 0 ; i < N ; i ++ ) for ( var j = 0 ; j < N ; j ++ ) { var sum = getSum ( i , i + K , j , j + K , dp ) ; if ( sum == S ) return true ; } return false ; } var grid = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 ] ] ; var K = 2 ; var S = 14 ; if ( sumFound ( K , S , grid ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findMinOperations ( S ) { S = reverse ( S ) ; let n = S . length ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } if ( S [ 0 ] == ' ' ) { dp [ 0 ] [ 0 ] = 0 ; } else { dp [ 0 ] [ 0 ] = 1 ; } dp [ 0 ] [ 1 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( S [ i ] == ' ' ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] ; dp [ i ] [ 1 ] = 1 + Math . min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] ) ; } else { dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 0 ] = 1 + Math . min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; } } return dp [ n - 1 ] [ 0 ] ; } function reverse ( input ) { let temparray = input . split ( " " ) ; let left , right = 0 ; right = temparray . length - 1 ; for ( left = 0 ; left < right ; left ++ , right -- ) { let temp = temparray [ left ] ; temparray [ left ] = temparray [ right ] ; temparray [ right ] = temp ; } return ( temparray ) . join ( " " ) ; } let S = " " ; document . write ( findMinOperations ( S ) + " " ) ; S = " " ; document . write ( findMinOperations ( S ) + " " ) ;
function solve ( N , K ) { var Arr = new Array ( N + 1 ) ; if ( N <= K ) { document . write ( " " + " " ) ; return ; } var i = 0 , sum = K ; for ( i = 1 ; i <= K ; ++ i ) { Arr [ i ] = 1 ; } Arr [ i ] = sum ; for ( var i = K + 2 ; i <= N ; ++ i ) { Arr [ i ] = sum - Arr [ i - K - 1 ] + Arr [ i - 1 ] ; sum = Arr [ i ] ; } document . write ( Arr [ N ] + " " ) ; } var N = 4 , K = 2 ; solve ( N , K ) ;
let MAX_VAL = 10000000 ; let dp = new Array ( 100 ) ; for ( let i = 0 ; i < 100 ; i ++ ) { dp [ i ] = new Array ( 100 ) ; for ( let j = 0 ; j < 100 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } function find ( index , openbrk , n , adj ) { if ( openbrk < 0 ) return MAX_VAL ; if ( index == n ) { if ( openbrk == 0 ) { return 0 ; } return MAX_VAL ; } if ( dp [ index ] [ openbrk ] != - 1 ) return dp [ index ] [ openbrk ] ; dp [ index ] [ openbrk ] = Math . min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) ; return dp [ index ] [ openbrk ] ; } let n = 4 ; let adj = [ [ 5000 , 3000 ] , [ 6000 , 2000 ] , [ 8000 , 1000 ] , [ 9000 , 6000 ] ] ; for ( let i = 0 ; i < dp . length ; i ++ ) for ( let j = 0 ; j < dp . length ; j ++ ) dp [ i ] [ j ] = - 1 ; document . write ( find ( 1 , 1 , n , adj ) + adj [ 0 ] [ 1 ] ) ;
function find ( start , adj , n , dp ) { if ( start == n ) return 0 ; if ( dp [ start ] != - 1 ) return dp [ start ] ; dp [ start ] = 0 ; var one = 0 , zero = 0 , k ; for ( k = start ; k < n ; k ++ ) { if ( adj [ k ] == ' ' ) one ++ ; else zero ++ ; if ( one > zero ) dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) ; else dp [ start ] = Math . max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) ; } return dp [ start ] ; } var adj = " " ; var n = adj . length ; var dp = Array ( n + 1 ) . fill ( - 1 ) ; document . write ( find ( 0 , adj , n , dp ) ) ;
function isVowel ( ch ) { if ( ch == ' ' ch == ' ' ch == ' ' ch == ' ' ch == ' ' ) return true ; return false ; } function lcs ( X , Y , m , n ) { let L = new Array ( m + 1 ) ; let i , j ; for ( i = 0 ; i <= m ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( ( X [ i - 1 ] == Y [ j - 1 ] ) && isVowel ( X [ i - 1 ] ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } let X = " " ; let Y = " " ; let m = X . length ; let n = Y . length ; document . write ( " " + lcs ( X , Y , m , n ) ) ;
function check ( i , val ) { if ( i - val < 0 ) return false ; return true ; } function MinimumPrimes ( n ) { let dp = new Array ( n + 1 ) for ( let i = 1 ; i <= n ; i ++ ) dp [ i ] = 1e9 ; dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( check ( i , 2 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 2 ] ) ; if ( check ( i , 3 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 3 ] ) ; if ( check ( i , 5 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 5 ] ) ; if ( check ( i , 7 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 7 ] ) ; } if ( dp [ n ] == ( 1e9 ) ) return - 1 ; else return dp [ n ] ; } let n = 12 ; let minimal = MinimumPrimes ( n ) ; if ( minimal != - 1 ) { document . write ( " " + " " ) ; document . write ( minimal ) ; } else { document . write ( " " ) ; }
var MAX = 100 function summation ( n ) { return n << ( n - 1 ) ; } var n = 2 ; document . write ( summation ( n ) ) ;
function findMaxProduct ( arr , n ) { let i ; let ans = - 1 ; let maxval = 1 ; let minval = 1 ; let prevMax ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { maxval = maxval * arr [ i ] ; minval = Math . min ( 1 , minval * arr [ i ] ) ; } else if ( arr [ i ] == 0 ) { minval = 1 ; maxval = 0 ; } else if ( arr [ i ] < 0 ) { prevMax = maxval ; maxval = minval * arr [ i ] ; minval = prevMax * arr [ i ] ; } ans = Math . max ( ans , maxval ) ; if ( maxval <= 0 ) { maxval = 1 ; } } return ans ; } let arr = [ 0 , - 4 , 0 , - 2 ] ; let n = arr . length ; document . write ( findMaxProduct ( arr , n ) ) ;
var INF = 1000000000 var MAX = 50 function minMaxValues ( arr , n , m ) { var sum = 0 ; for ( var i = 0 ; i < ( n + m ) ; i ++ ) { sum += arr [ i ] ; arr [ i ] += 50 ; } var dp = Array . from ( Array ( MAX + 1 ) , ( ) => Array ( MAX * MAX + 1 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 1 ; for ( var i = 0 ; i < ( n + m ) ; i ++ ) { for ( var k = Math . min ( n , i + 1 ) ; k >= 1 ; k -- ) { for ( var j = 0 ; j < MAX * MAX + 1 ; j ++ ) { if ( dp [ k - 1 ] [ j ] ) dp [ k ] [ j + arr [ i ] ] = 1 ; } } } var max_value = - INF , min_value = INF ; for ( var i = 0 ; i < MAX * MAX + 1 ; i ++ ) { if ( dp [ n ] [ i ] ) { var temp = i - 50 * n ; max_value = Math . max ( max_value , temp * ( sum - temp ) ) ; min_value = Math . min ( min_value , temp * ( sum - temp ) ) ; } } document . write ( " " + max_value + " " + " " + min_value ) ; } var n = 2 , m = 2 ; var arr = [ 1 , 2 , 3 , 4 ] ; minMaxValues ( arr , n , m ) ;
function findGolomb ( n ) { if ( n == 1 ) return 1 ; return 1 + findGolomb ( n - findGolomb ( findGolomb ( n - 1 ) ) ) ; } function printGolomb ( n ) { for ( let i = 1 ; i <= n ; i ++ ) document . write ( findGolomb ( i ) + " " ) ; } var n = 9 ; printGolomb ( n ) ;
function max ( a , b ) { return ( a > b ) ? a : b ; } function printknapSack ( W , wt , val , n ) { let i , w ; let K = new Array ( n + 1 ) ; for ( i = 0 ; i < K . length ; i ++ ) { K [ i ] = new Array ( W + 1 ) ; for ( let j = 0 ; j < W + 1 ; j ++ ) { K [ i ] [ j ] = 0 ; } } for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } let res = K [ n ] [ W ] ; document . write ( res + " " ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { document . write ( wt [ i - 1 ] + " " ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } } let val = [ 60 , 100 , 120 ] ; let wt = [ 10 , 20 , 30 ] ; let W = 50 ; let n = val . length ; printknapSack ( W , wt , val , n ) ;
function maximumSegments ( n , a , b , c ) { let dp = [ ] ; for ( let i = 0 ; i < n + 10 ; i ++ ) dp [ i ] = - 1 ; dp [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( dp [ i ] != - 1 ) { dp [ i + a ] = Math . max ( dp [ i ] + 1 , dp [ i + a ] ) ; dp [ i + b ] = Math . max ( dp [ i ] + 1 , dp [ i + b ] ) ; dp [ i + c ] = Math . max ( dp [ i ] + 1 , dp [ i + c ] ) ; } } return dp [ n ] ; } let n = 7 , a = 5 , b = 2 , c = 5 ; document . write ( maximumSegments ( n , a , b , c ) ) ;
function sequence ( n ) { let f = [ ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; document . write ( f [ 1 ] + " " + f [ 2 ] + " " ) ; for ( let i = 3 ; i <= n ; i ++ ) { f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; document . write ( f [ i ] + " " ) ; } } let n = 13 ; sequence ( n ) ;
function zigzag ( n , k ) { let dp = new Array ( n + 1 ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= Math . min ( i , k ) ; j ++ ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ; } return dp [ n ] [ k ] ; } let n = 4 , k = 3 ; document . write ( zigzag ( n , k ) ) ;
function binomialCoeff ( n , k ) { let C = new Array ( n + 1 ) ; for ( var i = 0 ; i < C . length ; i ++ ) { C [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } function lobb ( n , m ) { return ( ( 2 * m + 1 ) * binomialCoeff ( 2 * n , m + n ) ) / ( m + n + 1 ) ; } let n = 5 , m = 3 ; document . write ( lobb ( n , m ) ) ;
let MAXN = 109 ; function countarray ( n , k , x ) { let dp = [ ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i < n ; i ++ ) dp [ i ] = ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ; return ( x == 1 ? ( k - 1 ) * dp [ n - 2 ] : dp [ n - 1 ] ) ; } let n = 4 , k = 3 , x = 2 ; document . write ( countarray ( n , k , x ) ) ;
let MAX = 100 ; let MAX_CHAR = 26 ; function precompute ( s , n , l , r ) { l [ s [ 0 ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < MAX_CHAR ; j ++ ) l [ j ] [ i ] += l [ j ] [ i - 1 ] ; l [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] [ i ] ++ ; } r [ s [ n - 1 ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < MAX_CHAR ; j ++ ) r [ j ] [ i ] += r [ j ] [ i + 1 ] ; r [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] [ i ] ++ ; } } function countPalindromes ( k , n , l , r ) { let ans = 0 ; if ( k == 1 ) { for ( let i = 0 ; i < MAX_CHAR ; i ++ ) ans += l [ i ] [ n - 1 ] ; return ans ; } if ( k == 2 ) { for ( let i = 0 ; i < MAX_CHAR ; i ++ ) ans += ( ( l [ i ] [ n - 1 ] * ( l [ i ] [ n - 1 ] - 1 ) ) / 2 ) ; return ans ; } for ( let i = 1 ; i < n - 1 ; i ++ ) for ( let j = 0 ; j < MAX_CHAR ; j ++ ) ans += l [ j ] [ i - 1 ] * r [ j ] [ i + 1 ] ; return ans ; } let s = " " ; let k = 2 ; let n = s . length ; let l = new Array ( MAX_CHAR ) ; let r = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) { l [ i ] = new Array ( MAX ) ; r [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) { l [ i ] [ j ] = 0 ; r [ i ] [ j ] = 0 ; } } precompute ( s , n , l , r ) ; document . write ( countPalindromes ( k , n , l , r ) ) ;
function maxSum ( mat , n ) { if ( n == 1 ) return mat [ 0 ] [ 0 ] ; let dp = new Array ( n ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } let maxSum = Number . MIN_VALUE , max ; for ( let j = 0 ; j < n ; j ++ ) dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { for ( let j = 0 ; j < n ; j ++ ) { max = Number . MIN_VALUE ; if ( ( ( j - 1 ) >= 0 ) && ( max < dp [ i + 1 ] [ j - 1 ] ) ) max = dp [ i + 1 ] [ j - 1 ] ; if ( ( ( j + 1 ) < n ) && ( max < dp [ i + 1 ] [ j + 1 ] ) ) max = dp [ i + 1 ] [ j + 1 ] ; dp [ i ] [ j ] = mat [ i ] [ j ] + max ; } } for ( let j = 0 ; j < n ; j ++ ) if ( maxSum < dp [ 0 ] [ j ] ) maxSum = dp [ 0 ] [ j ] ; return maxSum ; } let mat = [ [ 5 , 6 , 1 , 7 ] , [ - 2 , 10 , 8 , - 1 ] , [ 3 , - 7 , - 9 , 11 ] , [ 12 , - 4 , 2 , 6 ] ] ; let n = 4 ; document . write ( " " + maxSum ( mat , n ) ) ;
function longestRepeatedSubSeq ( str ) { subsequence / let n = str . length ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= n ; j ++ ) if ( str [ i - 1 ] == str [ j - 1 ] && i != j ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; let res = " " ; let i = n , j = n ; while ( i > 0 && j > 0 ) { if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) { res = res + str [ i - 1 ] ; i -- ; j -- ; } else if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) i -- ; else j -- ; } let reverse = " " ; for ( let k = res . length - 1 ; k >= 0 ; k -- ) { reverse = reverse + res [ k ] ; } return reverse ; } let str = " " ; document . write ( longestRepeatedSubSeq ( str ) ) ;
function ElementsCalculationFunc ( pre , maxx , x , k , n ) { for ( let i = 0 , j = x ; j <= n ; j ++ , i ++ ) { if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) return true ; } return false ; } function MaxNumberOfElements ( a , n , k ) { a . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i <= n ; ++ i ) { pre [ i ] = 0 ; maxx [ i ] = 0 ; } for ( let i = 1 ; i <= n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] ; maxx [ i ] = Math . max ( maxx [ i - 1 ] , a [ i - 1 ] ) ; } let l = 1 , r = n , ans = 0 ; while ( l < r ) { let mid = Math . floor ( ( l + r ) / 2 ) ; if ( ElementsCalculationFunc ( pre , maxx , mid - 1 , k , n ) ) { ans = mid ; l = mid + 1 ; } else r = mid - 1 ; } document . write ( ans + " " ) ; } let arr = [ 2 , 4 , 9 ] ; let n = arr . length ; let k = 3 ; MaxNumberOfElements ( arr , n , k ) ;
let MAX = 50 ; function solve ( dp , a , low , high , turn ) { if ( low == high ) { return Math . floor ( a [ low ] * turn ) ; } if ( dp [ low ] [ high ] != 0 ) { return dp [ low ] [ high ] ; } dp [ low ] [ high ] = Math . max ( Math . floor ( a [ low ] * turn ) + solve ( dp , a , low + 1 , high , turn + 1 ) , Math . floor ( a [ high ] * turn ) + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; return dp [ low ] [ high ] ; } let arr = [ 1 , 3 , 1 , 5 , 2 ] ; let n = arr . length ; let dp = new Array ( MAX ) ; for ( var i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 2 ) ; } for ( var i = 0 ; i < dp . length ; i ++ ) { for ( var j = 0 ; j < dp . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } document . write ( solve ( dp , arr , 0 , n - 1 , 1 ) ) ;
function maxSumBitonicSubArr ( arr , n ) { let msis = new Array ( n ) ; msis . fill ( 0 ) ; let msds = new Array ( n ) ; msds . fill ( 0 ) ; let max_sum = Number . MIN_VALUE ; msis [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) msis [ i ] = msis [ i - 1 ] + arr [ i ] ; else msis [ i ] = arr [ i ] ; msds [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) if ( arr [ i ] > arr [ i + 1 ] ) msds [ i ] = msds [ i + 1 ] + arr [ i ] ; else msds [ i ] = arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) max_sum = msis [ i ] + msds [ i ] - arr [ i ] ; return max_sum ; } let arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] ; let n = arr . length ; document . write ( " " + maxSumBitonicSubArr ( arr , n ) ) ;
function countWays ( n , m ) { let count = new Array ( n + 1 ) ; count [ 0 ] = 0 ; let i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > m ) count [ i ] = count [ i - 1 ] + count [ i - m ] ; else if ( i < m i == 1 ) count [ i ] = 1 ; else count [ i ] = 2 ; } return count [ n ] ; } let n = 7 ; let m = 4 ; document . write ( " " + countWays ( n , m ) ) ;
let MAX = 100 ; function largestZigZagSumRec ( mat , i , j , n ) { if ( i == n - 1 ) return mat [ i ] [ j ] ; let zzs = 0 ; for ( let k = 0 ; k < n ; k ++ ) if ( k != j ) zzs = Math . max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) ; return zzs + mat [ i ] [ j ] ; } function largestZigZag ( mat , n ) { let res = 0 ; for ( let j = 0 ; j < n ; j ++ ) res = Math . max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) ; return res ; } let n = 3 ; let mat = [ [ 4 , 2 , 1 ] , [ 3 , 9 , 6 ] , [ 11 , 3 , 15 ] ] ; document . write ( " " + largestZigZag ( mat , n ) )
function countStr ( n , bCount , cCount ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; let res = countStr ( n - 1 , bCount , cCount ) ; res += countStr ( n - 1 , bCount - 1 , cCount ) ; res += countStr ( n - 1 , bCount , cCount - 1 ) ; return res ; } let n = 3 ; document . write ( countStr ( n , 1 , 2 ) ) ;
let N = 4 ; function MaximumPath ( Mat ) { let result = 0 ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N + 2 ) ; for ( let j = 0 ; j < N + 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ 0 ] [ i + 1 ] = Mat [ 0 ] [ i ] ; for ( let i = 1 ; i < N ; i ++ ) for ( let j = 1 ; j <= N ; j ++ ) dp [ i ] [ j ] = Math . max ( dp [ i - 1 ] [ j - 1 ] , Math . max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] ; for ( let i = 0 ; i <= N ; i ++ ) result = Math . max ( result , dp [ N - 1 ] [ i ] ) ; return result ; } let Mat = [ [ 4 , 2 , 3 , 4 ] , [ 2 , 9 , 1 , 10 ] , [ 15 , 1 , 3 , 0 ] , [ 16 , 92 , 41 , 44 ] ] document . write ( MaximumPath ( Mat ) )
let MAX = 100001 ; let dp = new Array ( MAX ) . fill ( 0 ) ; function probability ( k , n ) { var ans = 0.0 ; for ( let i = k ; i <= n ; ++ i ) { var res = dp [ n ] - dp [ i ] - dp [ n - i ] - n ; ans += Math . pow ( 2.0 , res ) ; } return ans ; } function precompute ( ) { for ( let i = 2 ; i < MAX ; ++ i ) dp [ i ] = ( Math . log ( i ) / Math . log ( 2 ) ) + dp [ i - 1 ] ; } precompute ( ) ; document . write ( probability ( 2 , 3 ) . toFixed ( 2 ) + " " ) ; document . write ( probability ( 3 , 6 ) . toFixed ( 5 ) + " " ) ; document . write ( probability ( 500 , 1000 ) . toFixed ( 6 ) + " " ) ;
function printMaxSum ( arr , n ) { let dp = new Array ( n ) ; dp . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = arr [ i ] ; let maxi = 0 ; for ( let j = 1 ; j <= Math . sqrt ( i + 1 ) ; j ++ ) { if ( ( ( i + 1 ) % j == 0 ) && ( i + 1 ) != j ) { if ( dp [ j - 1 ] > maxi ) maxi = dp [ j - 1 ] ; if ( dp [ parseInt ( ( i + 1 ) / j , 10 ) - 1 ] > maxi && j != 1 ) maxi = dp [ parseInt ( ( i + 1 ) / j , 10 ) - 1 ] ; } } dp [ i ] += maxi ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( dp [ i ] + " " ) ; } let arr = [ 2 , 3 , 1 , 4 , 6 , 5 ] ; let n = arr . length ; printMaxSum ( arr , n ) ;
function maxAlternateSum ( arr , n ) { if ( n == 1 ) return arr [ 0 ] ; int min = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( min > arr [ i ] ) min = arr [ i ] ; } if ( min == arr [ 0 ] ) { return arr [ 0 ] ; } let dec = new Array ( n ) ; dec . fill ( 0 ) ; let inc = new Array ( n ) ; inc . fill ( 0 ) ; dec [ 0 ] = inc [ 0 ] = arr [ 0 ] ; let flag = 0 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { dec [ i ] = Math . max ( dec [ i ] , inc [ j ] + arr [ i ] ) ; flag = 1 ; } else if ( arr [ j ] < arr [ i ] && flag == 1 ) inc [ i ] = Math . max ( inc [ i ] , dec [ j ] + arr [ i ] ) ; } } let result = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( result < inc [ i ] ) result = inc [ i ] ; if ( result < dec [ i ] ) result = dec [ i ] ; } return result ; } let arr = [ 8 , 2 , 3 , 5 , 7 , 9 , 10 ] ; document . write ( " " + maxAlternateSum ( arr , arr . length ) ) ;
function pad ( n ) { let pPrevPrev = 1 ; let pPrev = 1 ; let pCurr = 1 ; let pNext = 1 ; for ( let i = 3 ; i <= n ; i ++ ) { pNext = pPrevPrev + pPrev ; pPrevPrev = pPrev ; pPrev = pCurr ; pCurr = pNext ; } return pNext ; } let n = 12 ; document . write ( pad ( n ) ) ;
function lucas ( n ) { let a = 2 , b = 1 , c , i ; if ( n == 0 ) return a ; for ( i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return b ; } let n = 9 ; document . write ( lucas ( n ) ) ;
let MAX = 1000000 ; function breakSum ( n ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < dp ; i ++ ) { dp [ i ] = 0 ; } dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = Math . max ( dp [ Math . floor ( i / 2 ) ] + dp [ Math . floor ( i / 3 ) ] + dp [ Math . floor ( i / 4 ) ] , i ) ; return dp [ n ] ; } let n = 24 ; document . write ( breakSum ( n ) ) ;
function minTime ( arr , n ) { if ( n <= 0 ) return 0 ; let incl = arr [ 0 ] ; let excl = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let incl_new = arr [ i ] + Math . min ( excl , incl ) ; let excl_new = incl ; incl = incl_new ; excl = excl_new ; } return Math . min ( incl , excl ) ; } let arr1 = [ 10 , 5 , 2 , 7 , 10 ] ; let n1 = arr1 . length ; document . write ( minTime ( arr1 , n1 ) + " " ) ; let arr2 = [ 10 , 5 , 7 , 10 ] ; let n2 = arr2 . length ; document . write ( minTime ( arr2 , n2 ) + " " ) ; let arr3 = [ 10 , 5 , 2 , 4 , 8 , 6 , 7 , 10 ] ; let n3 = arr3 . length ; document . write ( minTime ( arr3 , n3 ) + " " ) ;
function multiply ( a , b ) { var mul = Array ( 3 ) . fill ( 0 ) . map ( x => Array ( 3 ) . fill ( 0 ) ) ; for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { mul [ i ] [ j ] = 0 ; for ( k = 0 ; k < 3 ; k ++ ) mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; } } for ( i = 0 ; i < 3 ; i ++ ) for ( j = 0 ; j < 3 ; j ++ ) a [ i ] [ j ] = mul [ i ] [ j ] ; } function power ( F , n ) { var M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; if ( n == 1 ) return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; power ( F , parseInt ( n / 2 ) ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) multiply ( F , M ) ; return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; } function findNthTerm ( n ) { var F = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; return power ( F , n - 2 ) ; } var n = 5 ; document . write ( " " + findNthTerm ( n ) ) ;
function count ( n ) { let dp = [ ] ; dp [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i >= 1 && i <= 3 ) dp [ i ] = 1 ; else if ( i == 4 ) dp [ i ] = 2 ; else { dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] ; } } return dp [ n ] ; } let n = 5 ; document . write ( " " + count ( n ) ) ;
function nCrModp ( n , r , p ) { if ( r > n - r ) r = n - r ; let C = new Array ( r + 1 ) ; for ( let i = 0 ; i < r + 1 ; i ++ ) C [ i ] = 0 ; C [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; } let n = 10 , r = 2 , p = 13 ; document . write ( " " + nCrModp ( n , r , p ) ) ;
function bellNumber ( n ) { let bell = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { bell [ i ] = new Array ( n + 1 ) ; } bell [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] ; for ( let j = 1 ; j <= i ; j ++ ) bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] ; } return bell [ n ] [ 0 ] ; } for ( let n = 0 ; n <= 5 ; n ++ ) document . write ( " " + n + " " + bellNumber ( n ) + " " ) ;
function printCountDP ( dist ) { let count = new Array ( dist + 1 ) ; count [ 0 ] = 1 ; if ( dist >= 1 ) count [ 1 ] = 1 ; if ( dist >= 2 ) count [ 2 ] = 2 ; for ( let i = 3 ; i <= dist ; i ++ ) count [ i ] = count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ; return count [ dist ] ; } let dist = 4 ; document . write ( printCountDP ( dist ) ) ;
function countSeq ( n ) { let nCr = 1 , res = 1 ; for ( let r = 1 ; r <= n ; r ++ ) { nCr = ( nCr * ( n + 1 - r ) ) / r ; res += nCr * nCr ; } return res ; } let n = 2 ; document . write ( " " ) ; document . write ( countSeq ( n ) ) ;
function minq ( a , b ) { return ( a < b ) ? a : b ; } function min ( arr , l , h ) { var mn = arr [ l ] ; for ( i = l + 1 ; i <= h ; i ++ ) { if ( mn > arr [ i ] ) { mn = arr [ i ] ; } } return parseInt ( mn ) ; } function max ( arr , l , h ) { var mx = arr [ l ] ; for ( i = l + 1 ; i <= h ; i ++ ) { if ( mx < arr [ i ] ) { mx = arr [ i ] ; } } return parseInt ( mx ) ; } function minRemovalsDP ( arr , n ) { var table = Array ( n ) ; var gap , i , j , mn , mx ; for ( i = 0 ; i < n ; i ++ ) table [ i ] = Array ( n ) . fill ( 0 ) ; for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { mn = min ( arr , i , j ) ; mx = max ( arr , i , j ) ; table [ i ] [ j ] = parseInt ( ( 2 * mn > mx ) ? 0 : minq ( table [ i ] [ j - 1 ] + 1 , table [ i + 1 ] [ j ] + 1 ) ) ; } } return table [ 0 ] [ n - 1 ] ; } var arr = [ 20 , 4 , 1 , 3 ] ; var n = arr . length ; document . write ( minRemovalsDP ( arr , n ) ) ;
function numberOfPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; } document . write ( numberOfPaths ( 3 , 3 ) + " " ) ;
function numberOfPaths ( m , n ) { var path = 1 ; for ( i = n ; i < ( m + n - 1 ) ; i ++ ) { path *= i ; path = parseInt ( path / ( i - n + 1 ) ) ; } return path ; } document . write ( numberOfPaths ( 3 , 3 ) ) ;
function lenghtOfLongestAP ( set , n ) { if ( n <= 2 ) return n ; let L = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { L [ i ] = new Array ( n ) ; } let llap = 2 ; for ( let i = 0 ; i < n ; i ++ ) { L [ i ] [ n - 1 ] = 2 ; } for ( let j = n - 2 ; j >= 1 ; j -- ) { let i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] + set [ k ] < 2 * set [ j ] ) k ++ ; else if ( set [ i ] + set [ k ] > 2 * set [ j ] ) { L [ i ] [ j ] = 2 ; i -- ; } else { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; llap = Math . max ( llap , L [ i ] [ j ] ) ; i -- ; k ++ ; } } while ( i >= 0 ) { L [ i ] [ j ] = 2 ; i -- ; } } return llap ; } let set1 = [ 1 , 7 , 10 , 13 , 14 , 19 ] ; let n1 = set1 . length ; document . write ( lenghtOfLongestAP ( set1 , n1 ) + " " ) ; let set2 = [ 1 , 7 , 10 , 15 , 27 , 29 ] ; let n2 = set2 . length ; document . write ( lenghtOfLongestAP ( set2 , n2 ) + " " ) ; let set3 = [ 2 , 4 , 6 , 8 , 10 ] ; let n3 = set3 . length ; document . write ( lenghtOfLongestAP ( set3 , n3 ) + " " ) ;
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; } let arr = [ 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 ] let n = arr . length ; document . write ( " " + lbs ( arr , n ) ) ;
function max ( a , b ) { return ( a > b ) ? a : b ; } function eggDrop ( n , k ) { let eggFloor = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { eggFloor [ i ] = new Array ( k + 1 ) ; } let res ; let i , j , x ; for ( i = 1 ; i <= n ; i ++ ) { eggFloor [ i ] [ 1 ] = 1 ; eggFloor [ i ] [ 0 ] = 0 ; } for ( j = 1 ; j <= k ; j ++ ) eggFloor [ 1 ] [ j ] = j ; for ( i = 2 ; i <= n ; i ++ ) { for ( j = 2 ; j <= k ; j ++ ) { eggFloor [ i ] [ j ] = Number . MAX_VALUE ; for ( x = 1 ; x <= j ; x ++ ) { res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) ; if ( res < eggFloor [ i ] [ j ] ) eggFloor [ i ] [ j ] = res ; } } } return eggFloor [ n ] [ k ] ; } let n = 2 , k = 36 ; document . write ( " " + " " + n + " " + k + " " + eggDrop ( n , k ) ) ;
function max ( a , b ) { return ( a > b ) ? a : b ; } function knapSack ( W , wt , val , n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } let val = [ 60 , 100 , 120 ] ; let wt = [ 10 , 20 , 30 ] ; let W = 50 ; let n = val . length ; document . write ( knapSack ( W , wt , val , n ) ) ;
function factorial ( n ) { let res = 1 ; for ( let i = 1 ; i <= n ; ++ i ) { res *= i ; } return res ; } function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function catalan ( n ) { let c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } function countBST ( n ) { let count = catalan ( n ) ; return count ; } function countBT ( n ) { let count = catalan ( n ) ; return count * factorial ( n ) ; } let count1 , count2 , n = 5 ; count1 = countBST ( n ) ; count2 = countBT ( n ) ; document . write ( " " + n + " " + count1 + " " ) ; document . write ( " " + " " + n + " " + count2 ) ;
function printPermutation ( N , K ) { var res = [ ] ; var l = 1 , r = N , flag = 0 ; for ( var i = 0 ; i < K ; i ++ ) { if ( ! flag ) { res . push ( l ) ; l ++ ; } else { res . push ( r ) ; r -- ; } flag ^= 1 ; } if ( ! flag ) { for ( var i = r ; i >= l ; i -- ) res . push ( i ) ; } else { for ( var i = l ; i <= r ; i ++ ) res . push ( i ) ; } for ( var i = 0 ; i < res . length ; i ++ ) { document . write ( res [ i ] + " " ) ; } } var N = 10 , K = 4 ; printPermutation ( N , K ) ;
function fact ( N ) { let i , product = 1 ; for ( i = 1 ; i <= N ; i ++ ) product = product * i ; return product ; } function nthTerm ( N ) { return ( N * N ) * fact ( N ) ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
let d = 256 ; function search ( pat , txt , q ) { let M = pat . length ; let N = txt . length ; let i , j ; let p = 0 ; let t = 0 ; let h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] . charCodeAt ( ) ) % q ; t = ( d * t + txt [ i ] . charCodeAt ( ) ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; } if ( j == M ) document . write ( " " + i + " " ) ; } if ( i < N - M ) { t = ( d * ( t - txt [ i ] . charCodeAt ( ) * h ) + txt [ i + M ] . charCodeAt ( ) ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } let txt = " " ; let pat = " " ; let q = 101 ; search ( pat , txt , q ) ;
function number_of_tower ( house , range , n ) { house . sort ( function ( a , b ) { return a - b ; } ) ; let numOfTower = 0 ; let i = 0 ; while ( i < n ) { numOfTower ++ ; let loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; -- i ; loc = house [ i ] + range ; while ( i < n && house [ i ] <= loc ) i ++ ; } return numOfTower ; } let house = [ 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ] ; let range = 2 ; let n = house . length ; document . write ( number_of_tower ( house , range , n ) ) ;
var MAX = 1000 ; function findDuplicate ( arr , n , k ) { var freq = Array . from ( { length : MAX } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < 1 && arr [ i ] > MAX ) { document . write ( " " ) ; return - 1 ; } freq [ arr [ i ] ] += 1 ; } for ( var i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == k ) return i ; } return - 1 ; } var arr = [ 2 , 2 , 1 , 3 , 1 ] ; var k = 2 ; var n = arr . length ; document . write ( findDuplicate ( arr , n , k ) ) ;
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; var op = [ ... Array ( n ) ] ; var mid = parseInt ( ( n - 1 ) / 2 ) ; var j = 1 , i = 1 ; op [ mid ] = arr [ 0 ] ; for ( i = 1 ; i <= mid ; i ++ ) { op [ mid + i ] = arr [ j ++ ] ; op [ mid - i ] = arr [ j ++ ] ; } if ( n % 2 == 0 ) op [ mid + i ] = arr [ j ] ; document . write ( " " ) ; for ( i = 0 ; i < n ; i ++ ) document . write ( op [ i ] + " " ) ; document . write ( " " ) ; } var arr = [ 14 , 6 , 19 , 21 , 12 ] ; var n = arr . length ; pendulumArrangement ( arr , n ) ;
let MAX = 256 ; let freq ; function preCalculate ( str , n ) { freq [ str [ 0 ] . charCodeAt ( 0 ) ] [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { let ch = str [ i ] ; for ( let j = 0 ; j < MAX ; j ++ ) { let charToUpdate = String . fromCharCode ( j ) ; if ( charToUpdate == ch ) freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 ; else freq [ j ] [ i ] = freq [ j ] [ i - 1 ] ; } } } function getFrequency ( ch , l , r ) { if ( l == 0 ) return freq [ ch . charCodeAt ( 0 ) ] [ r ] ; else return ( freq [ ch . charCodeAt ( 0 ) ] [ r ] - freq [ ch . charCodeAt ( 0 ) ] [ l - 1 ] ) ; } function lastNonRepeating ( str , n , l , r ) { for ( let i = r ; i >= l ; i -- ) { let ch = str [ i ] ; if ( getFrequency ( ch , l , r ) == 1 ) return ( " " + ch ) ; } return " " ; } let str = " " ; let n = str . length ; let queries = [ [ 2 , 9 ] , [ 2 , 3 ] , [ 0 , 12 ] ] ; let q = queries . length ; freq = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { freq [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { freq [ i ] [ j ] = 0 ; } } preCalculate ( str , n ) ; for ( let i = 0 ; i < q ; i ++ ) { document . write ( lastNonRepeating ( str , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) + " " ) ; }
function minCost ( str , K ) { var n = str . length ; var res = 999999999 , count = 0 , a , b ; var cnt = Array ( 27 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) cnt [ str [ i ] . charCodeAt ( 0 ) - 97 + 1 ] ++ ; for ( var i = 1 ; i < ( 26 - K + 1 ) ; i ++ ) { a = i ; b = i + K ; count = 0 ; for ( var j = 1 ; j <= 26 ; j ++ ) { if ( cnt [ j ] > 0 ) { if ( j >= a && j >= b ) count = count + ( Math . min ( j - b , 25 - j + a + 1 ) ) * cnt [ j ] ; else if ( j <= a && j <= b ) count = count + ( Math . min ( a - j , 25 + j - b + 1 ) ) * cnt [ j ] ; } } res = Math . min ( res , count ) ; } for ( var i = 26 - K + 1 ; i <= 26 ; i ++ ) { a = i ; b = ( i + K ) % 26 ; count = 0 ; for ( var j = 1 ; j <= 26 ; j ++ ) { if ( cnt [ j ] > 0 ) { if ( j >= b && j <= a ) count = count + ( Math . min ( j - b , a - j ) ) * cnt [ j ] ; } } res = Math . min ( res , count ) ; } return res ; } var str = " " ; var K = 2 ; document . write ( minCost ( str , K ) ) ;
function printLastChar ( str ) { str = str + " " ; for ( var i = 1 ; i < str . length ; i ++ ) { if ( str [ i ] === " " ) document . write ( str [ i - 1 ] + " " ) ; } } var str = " " ; printLastChar ( str ) ;
function maxBalancedStr ( s ) { var open1 = 0 , close1 = 0 ; var open2 = 0 , close2 = 0 ; var open3 = 0 , close3 = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { switch ( s . charAt ( i ) ) { case ' ' : open1 ++ ; break ; case ' ' : close1 ++ ; break ; case ' ' : open2 ++ ; break ; case ' ' : close2 ++ ; break ; case ' ' : open3 ++ ; break ; case ' ' : close3 ++ ; break ; } } var maxLen = 2 * Math . min ( open1 , close1 ) + 2 * Math . min ( open2 , close2 ) + 2 * Math . min ( open3 , close3 ) ; return maxLen ; } var s = " " ; document . write ( maxBalancedStr ( s ) ) ;
function binarySearch ( arr , x ) { let l = 0 , r = arr . length - 1 ; while ( l <= r ) { let m = l + Math . floor ( ( r - l ) / 2 ) ; let res = x . localeCompare ( arr [ m ] ) ; if ( res == 0 ) return m ; if ( res > 0 ) l = m + 1 ; else r = m - 1 ; } return - 1 ; } let arr = [ " " , " " , " " , " " ] ; let x = " " ; let result = binarySearch ( arr , x ) ; if ( result == - 1 ) document . write ( " " ) ; else document . write ( " " + " " + result + " " ) ;
function getStudentsList ( file , n ) { let avgScore ; let maxAvgScore = Number . MIN_SAFE_INTEGER ; let names = [ ] ; for ( let i = 0 ; i < n ; i += 4 ) { avgScore = Math . floor ( ( Number ( file [ i + 1 ] ) + Number ( file [ i + 2 ] ) + Number ( file [ i + 3 ] ) ) / 3 ) ; if ( avgScore > maxAvgScore ) { maxAvgScore = avgScore ; names = [ ] ; names . push ( file [ i ] ) ; } else if ( avgScore == maxAvgScore ) names . push ( file [ i ] ) ; } for ( let i = 0 ; i < names . length ; i ++ ) { document . write ( names [ i ] + " " ) ; } document . write ( maxAvgScore ) ; } let file = [ " " , " " , " " , " " , " " , " " , " " , " " ] ; let n = file . length ; getStudentsList ( file , n ) ;
function strScore ( str , s , n ) { var score = 0 , index = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == s ) { for ( j = 0 ; j < s . length ; j ++ ) { score += s . charAt ( j ) . charCodeAt ( 0 ) - ( ' ' ) . charCodeAt ( 0 ) + 1 ; } index = i + 1 ; break ; } } score = score * index ; return score ; } str = [ " " , " " , " " , " " , " " ] ; s = " " ; var n = str . length ; var score = strScore ( str , s , n ) ; document . write ( score ) ;
function minParentheses ( p ) { var bal = 0 ; var ans = 0 ; for ( var i = 0 ; i < p . length ; ++ i ) { bal += p [ i ] == ' ' ? 1 : - 1 ; if ( bal == - 1 ) { ans += 1 ; bal += 1 ; } } return bal + ans ; } var p = " " ; document . write ( minParentheses ( p ) ) ;
function isPalindrome ( r ) { var p = r ; p . split ( ' ' ) . reverse ( ) . join ( ' ' ) ; return ( r == p ) ; } function CheckStr ( s ) { var l = s . length ; var i ; for ( i = 2 ; i <= l ; i ++ ) { if ( isPalindrome ( s . substring ( 0 , i ) ) ) break ; } if ( i == ( l + 1 ) ) return false ; i = 2 ; for ( i = 2 ; i <= l ; i ++ ) { if ( isPalindrome ( s . substring ( l - i , l ) ) ) return true ; } return false ; } var s = " " ; if ( CheckStr ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function oddEquivalent ( s , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) count ++ ; } return count ; } var s = " " ; var n = s . length ; document . write ( oddEquivalent ( s , n ) ) ;
function findNumberOfTimes ( str1 , str2 ) { let freq = new Array ( 26 ) ; let freq2 = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; freq2 [ i ] = 0 ; } let l1 = str1 . length ; for ( let i = 0 ; i < l1 ; i ++ ) { freq [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] += 1 ; } let l2 = str2 . length ; for ( let i = 0 ; i < l2 ; i ++ ) { freq2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] += 1 ; } let count = Number . MAX_VALUE ; for ( let i = 0 ; i < l2 ; i ++ ) { if ( freq2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] != 0 ) count = Math . min ( count , freq [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] / freq2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ) ; } return count ; } let str1 = " " ; let str2 = " " ; document . write ( findNumberOfTimes ( str1 , str2 ) ) ;
function solve ( s1 , s2 ) { let flag1 = 0 , flag2 = 0 ; if ( s1 . length != s2 . length ) return false ; let l = s1 . length ; for ( let i = 0 ; i < l ; i ++ ) { if ( s1 [ i ] == ' ' ) flag1 = 1 ; if ( s2 [ i ] == ' ' ) flag2 = 1 ; if ( flag1 && flag2 ) return true ; } if ( ! flag1 && ! flag2 ) return true ; return false ; } let s1 = " " ; let s2 = " " ; if ( solve ( s1 , s2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function subzero ( s , k ) { let ans = 0 , curr = 0 ; let len = s . length ; let str = s . split ( " " ) ; for ( let i = 0 ; i < len ; ++ i ) { if ( str [ i ] == ' ' ) curr ++ ; else curr = 0 ; ans = Math . max ( ans , curr ) ; } if ( ans == len ) return len * k ; else { let pre = 0 , suff = 0 ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) pre ++ ; else break ; } for ( let i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) suff ++ ; else break ; } if ( k > 1 ) ans = Math . max ( ans , pre + suff ) ; return ans ; } } let str = " " ; let k = 5 ; document . write ( subzero ( str , k ) ) ;
function Dragon_Curve_Sequence ( n ) { let s = " " ; for ( let i = 2 ; i <= n ; i ++ ) { let temp = " " ; let prev = ' ' ; let zero = ' ' ; let one = ' ' ; for ( let j = 0 ; j < s . length ; j ++ ) { temp = temp + s [ j ] ; if ( prev == ' ' ) { temp += one ; prev = one ; } else { temp += zero ; prev = zero ; } } s = temp ; } return s ; } let n = 4 ; let s = Dragon_Curve_Sequence ( n ) ; document . write ( s + " " ) ;
function countNonEmptySubstr ( str ) { let n = str . length ; return n * ( n + 1 ) / 2 ; } let s = " " ; document . write ( countNonEmptySubstr ( s ) ) ;
let MAX = 26 ; function targetstring ( str1 , str2 ) { let l1 = str1 . length ; let l2 = str2 . length ; if ( l1 != l2 ) return false ; let map = new Array ( MAX ) ; for ( let i = 0 ; i < map . length ; i ++ ) { map [ i ] = 0 ; } for ( let i = 0 ; i < l1 ; i ++ ) map [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < l2 ; i ++ ) { map [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] -- ; if ( map [ str2 [ i ] - ' ' . charCodeAt ( 0 ) ] < 0 ) return false ; } return true ; } let str1 = " " ; let str2 = " " ; if ( targetstring ( str1 , str2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isDigitPresent ( x , d ) { while ( x > 0 ) { if ( x % 10 == d ) break ; x = x / 10 ; } return ( x > 0 ) ; } function printNumbers ( n , d ) { for ( let i = 0 ; i <= n ; i ++ ) if ( i == d || isDigitPresent ( i , d ) ) document . write ( i + " " ) ; } let n = 47 , d = 7 ; printNumbers ( n , d ) ;
function findExtraCharcter ( strA , strB ) { let res = 0 ; for ( let i = 0 ; i < strA . length ; i ++ ) { res ^= strA . charCodeAt ( i ) ; } for ( let i = 0 ; i < strB . length ; i ++ ) { res ^= strB . charCodeAt ( i ) ; } return res ; } let strA = " " ; let strB = " " ; document . write ( String . fromCharCode ( findExtraCharcter ( strA , strB ) ) ) ;
function calculateSum ( arr , n ) { if ( n == 0 ) return 0 ; let s = arr [ 0 ] ; let value = parseInt ( s ) ; let sum = value ; for ( let i = 2 ; i < n ; i = i + 2 ) { s = arr [ i ] ; value = parseInt ( s ) ; let operation = arr [ i - 1 ] [ 0 ] ; if ( operation == ' ' ) sum += value ; else sum -= value ; } return sum ; } let arr = [ " " , " " , " " , " " , " " , " " , " " ] ; let n = arr . length ; document . write ( calculateSum ( arr , n ) ) ;
function LargestString ( na ) { let N = na . length ; let c = new Array ( N ) ; let m = 1 ; for ( let j = 0 ; j < N ; j ++ ) { let character = new Array ( 26 , 0 ) ; for ( let k = 0 ; k < na [ j ] . length ; k ++ ) { let x = na [ j ] [ k ] . charCodeAt ( 0 ) - 65 ; if ( ( na [ j ] [ k ] != ' ' ) && ( character [ x ] == 0 ) ) { c [ j ] ++ ; character [ x ] = 1 ; } } if ( c [ j ] > c [ m ] ) m = j ; } document . write ( na [ m ] ) ; } let na = [ " " , " " , " " , " " , " " ] ; LargestString ( na ) ;
var MAX_CHAR = 26 function minRemoval ( str ) { var hash = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; str [ i ] ; i ++ ) hash [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; var count = 0 ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) if ( hash [ i ] % 2 ) count ++ ; return ( count == 0 ) ? 0 : count - 1 ; } var str = " " ; document . write ( minRemoval ( str ) ) ;
function findLUSlength ( a , b ) { if ( a === b ) return 0 ; return Math . max ( a . length , b . length ) ; } var a = " " , b = " " ; document . write ( findLUSlength ( a , b ) ) ;
function swapTwoHalves ( a , b ) { var la = a . length ; var lb = b . length ; var c = a . substring ( 0 , la / 2 ) + b . substring ( lb / 2 , lb ) ; var d = b . substring ( 0 , lb / 2 ) + a . substring ( la / 2 , la ) ; document . write ( c + " " + " " + d ) ; } var a = " " ; var b = " " ; swapTwoHalves ( a , b ) ;
var SIZE = 26 ; function longSubstring ( str , k ) { var freq = Array ( SIZE ) . fill ( 0 ) ; var start = 0 ; var maxLen = 0 ; var ch ; var n = str . length ; for ( var i = 0 ; i < n ; i ++ ) { ch = str [ i ] ; freq [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; if ( freq [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] > k ) { if ( maxLen < ( i - start ) ) maxLen = i - start ; while ( freq [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] > k ) { freq [ str [ start ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] -- ; start ++ ; } } } if ( maxLen < ( n - start ) ) maxLen = n - start ; return maxLen ; } var str = " " ; var k = 1 ; document . write ( " " + longSubstring ( str , k ) ) ;
let NO_OF_CHARS = 256 ; function max_distinct_char ( str , n ) { let count = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { count [ str [ i ] . charCodeAt ( 0 ) ] ++ ; } let max_distinct = 0 ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] != 0 ) { max_distinct ++ ; } } return max_distinct ; } function smallesteSubstr_maxDistictChar ( str ) { let n = str . length ; let max_distinct = max_distinct_char ( str , n ) ; let minl = n ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let subs = null ; if ( i < j ) subs = str . substring ( i , j ) ; else subs = str . substring ( j , i ) ; let subs_lenght = subs . length ; let sub_distinct_char = max_distinct_char ( subs , subs_lenght ) ; if ( subs_lenght < minl && max_distinct == sub_distinct_char ) { minl = subs_lenght ; } } } return minl ; } let str = " " ; let len = smallesteSubstr_maxDistictChar ( str ) ; document . write ( " " + " " + " " + len ) ;
function evenNumSubstring ( str ) { let len = str . length ; let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let temp = str [ i ] - ' ' ; if ( temp % 2 == 0 ) count += ( i + 1 ) ; } return count ; } let str = " " ; document . write ( evenNumSubstring ( str ) ) ;
function findIndex ( a , n ) { let res = 0 ; let min_diff = Number . MAX_VALUE ; let prod = new Array ( n ) ; prod [ 0 ] = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prod [ i ] = prod [ i - 1 ] * a [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let curr_diff = Math . abs ( parseInt ( prod [ n - 1 ] / prod [ i ] , 10 ) - prod [ i ] ) ; if ( curr_diff < min_diff ) { min_diff = curr_diff ; res = i ; } } return res ; } let arr = [ 3 , 2 , 5 , 7 , 2 , 9 ] ; let N = arr . length ; document . write ( findIndex ( arr , N ) ) ;
function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } function printNumbers ( a , n , x ) { let flag = false ; for ( let i = 0 ; i < n ; i ++ ) { let num = a [ i ] ; let g = __gcd ( num , x ) ; while ( g != 1 ) { num = parseInt ( num / g ) ; g = __gcd ( num , x ) ; } if ( num == 1 ) { flag = true ; document . write ( a [ i ] + " " ) ; } } if ( ! flag ) document . write ( " " ) ; } let x = 60 ; let a = [ 2 , 5 , 10 , 7 , 17 ] ; let n = a . length ; printNumbers ( a , n , x ) ;
function print ( rStation , n ) { for ( var i = 1 ; i <= n ; i ++ ) document . write ( rStation [ i ] + " " ) ; document . write ( " " ) ; } function radiated_Station ( station , n ) { var rStation = [ ] ; rStation . length = 6 ; rStation . fill ( 0 ) for ( var i = 1 ; i <= n ; i ++ ) { var li = i - 1 , ri = i + 1 ; var lRad = station [ i ] - 1 , rRad = station [ i ] - 1 ; rStation [ i ] += station [ i ] ; while ( li >= 1 && lRad >= 1 ) { rStation [ li -- ] += lRad -- ; } while ( ri <= n && rRad >= 1 ) { rStation [ ri ++ ] += rRad -- ; } } print ( rStation , n ) ; } var station = [ 0 , 7 , 9 , 12 , 2 , 5 ] var n = station . length - 1 ; radiated_Station ( station , n ) ;
function findMaximumDiff ( a , n ) { var ind1 = 0 ; for ( i = n - 1 ; i > 0 ; i -- ) { if ( a [ 0 ] != a [ i ] ) { ind1 = i ; break ; } } var ind2 = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { if ( a [ n - 1 ] != a [ i ] ) { ind2 = ( n - 1 - i ) ; break ; } } return Math . max ( ind1 , ind2 ) ; } var a = [ 1 , 2 , 3 , 2 , 3 ] ; var n = a . length ; document . write ( findMaximumDiff ( a , n ) ) ;
function sum ( k , n ) { let sum = 0 ; for ( let i = 0 ; i <= n ; i ++ ) { let p = 1 ; for ( let j = 0 ; j < n - i ; j ++ ) { p = p * k ; } for ( let j = 0 ; j < i ; j ++ ) { p = p * ( k - 1 ) ; } sum = sum + p ; } return sum ; } let n = 3 ; let K = 3 ; document . write ( sum ( K , n ) ) ;
function is_prime ( num ) { var count = 0 ; for ( i = 1 ; i * i <= ( num ) ; i ++ ) { if ( ( num ) % i == 0 ) { if ( i * i != ( num ) ) count += 2 ; else count ++ ; } } if ( count == 2 ) return true ; else return false ; } function is_divisible ( n ) { if ( n == 1 ) { return " " ; } else { if ( is_prime ( n + 1 ) ) return " " ; else return " " ; } } var n ; n = 3 ; document . write ( is_divisible ( n ) + " " ) ; n = 4 ; document . write ( is_divisible ( n ) ) ;
let mod = ( 1e9 + 7 ) ; function BitOperations ( a , n , b , m ) { let ch1 = a . split ( ' ' ) ; ch1 . reverse ( ) ; a = ch1 . join ( " " ) ; let ch2 = b . split ( ' ' ) ; ch2 . reverse ( ) ; b = ch2 . join ( " " ) ; let c = 0 ; for ( let i = 0 ; i < m ; i ++ ) if ( b [ i ] == ' ' ) c ++ ; let power = new Array ( n ) ; power [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) power [ i ] = ( power [ i - 1 ] * 2 ) % mod ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ' ' ) { ans += c * power [ i ] ; if ( ans >= mod ) ans %= mod ; } if ( b [ i ] == ' ' ) c -- ; if ( c == 0 ) break ; } return ans ; } let a = " " , b = " " ; let n = a . length , m = b . length ; document . write ( BitOperations ( a , n , b , m ) ) ;
function sieve ( maxEle , prime ) { prime [ 0 ] = prime [ 1 ] = 1 ; for ( var i = 2 ; i * i <= maxEle ; i ++ ) { if ( ! prime [ i ] ) { for ( var j = 2 * i ; j <= maxEle ; j += i ) prime [ j ] = 1 ; } } } function digitSum ( n ) { var sum = 0 ; while ( n ) { sum += n % 10 ; n = parseInt ( n / 10 ) ; } return sum ; } function printAdditivePrime ( arr , n ) { var maxEle = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var prime = Array ( maxEle + 1 ) . fill ( 0 ) ; sieve ( maxEle , prime ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == 0 ) { var sum = digitSum ( arr [ i ] ) ; if ( prime [ sum ] == 0 ) document . write ( arr [ i ] + " " ) ; } } } var a = [ 2 , 4 , 6 , 11 , 12 , 18 , 7 ] ; var n = a . length ; printAdditivePrime ( a , n ) ;
using System ; class GFG { function nthTerm ( n ) { let nth ; if ( n % 2 == 0 ) nth = 2 * ( ( n * n ) - n ) ; else nth = ( 2 * n * n ) - n ; return nth ; } let n = 5 ; document . write ( nthTerm ( n ) + " " ) ; n = 25 ; document . write ( nthTerm ( n ) + " " ) ; n = 25000000 ; document . write ( nthTerm ( n ) + " " ) ; n = 250000007 ; document . write ( nthTerm ( n ) + " " ) ;
function nthterm ( n ) { let An = ( Math . pow ( 1 , n ) + Math . pow ( 2 , n ) ) * Math . pow ( 3 , n ) ; return An ; } let n = 3 ; document . write ( nthterm ( n ) ) ;
function countDivisors ( n ) { var x = 0 , ans = 1 ; while ( n % 2 == 0 ) { x ++ ; n = n / 2 ; } ans = ans * ( x + 1 ) ; for ( var i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { x = 0 ; while ( n % i == 0 ) { x ++ ; n = n / i ; } ans = ans * ( x + 1 ) ; } if ( n > 2 ) ans = ans * 2 ; return ans ; } function getTotalCount ( n , k ) { var k_count = countDivisors ( k ) ; var count = 0 ; for ( var i = 1 ; i < n ; i ++ ) if ( k_count == countDivisors ( i ) ) count ++ ; if ( k < n ) count = count - 1 ; return count ; } var n = 500 , k = 6 ; document . write ( getTotalCount ( n , k ) ) ;
function term ( n ) { let d = 2 ; let a1 = 0 ; An = a1 + ( n - 1 ) * d ; return Math . pow ( An , 3 ) ; } let n = 5 ; document . write ( term ( n ) ) ;
let MAX_VAL = 200000 ; function countIntervals ( arr , V , N ) { let min = Number . MAX_VALUE , max = Number . MIN_VALUE ; let li , ri ; let freq = new Array ( MAX_VAL ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { li = arr [ i ] [ 0 ] ; freq [ li ] = freq [ li ] + 1 ; ri = arr [ i ] [ 1 ] ; freq [ ri + 1 ] = freq [ ri + 1 ] - 1 ; if ( li < min ) min = li ; if ( ri > max ) max = ri ; } for ( let i = min ; i <= max ; i ++ ) freq [ i ] = freq [ i ] + freq [ i - 1 ] ; return freq [ V ] ; } let arr = [ [ 1 , 10 ] , [ 5 , 10 ] , [ 15 , 25 ] , [ 7 , 12 ] , [ 20 , 25 ] ] ; let V = 7 ; let N = arr . length ; document . write ( countIntervals ( arr , V , N ) ) ;
function prletGroups ( n ) { let x = 1 ; let y = n * n ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= n / 2 ; j ++ ) { document . write ( " " + x + " " + y + " " ) ; x ++ ; y -- ; } document . write ( " " ) ; } } let n = 4 ; prletGroups ( n ) ;
function breakEvenPoint ( exp , S , M ) { var earn = S - M ; var res = Math . ceil ( exp / earn ) ; return res ; } var exp = 3550 , S = 90 , M = 65 ; document . write ( breakEvenPoint ( exp , S , M ) ) ;
function minimum ( n ) { let product = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { while ( n % i == 0 ) n = n / i ; product = product * i ; } } if ( n >= 2 ) product = product * n ; return product ; } let n = 20 ; document . write ( minimum ( n ) ) ;
function numbers ( n , arr , m ) { let isZero = 0 , isFive = 0 ; let result = 0 ; if ( m < n ) { return - 1 ; } for ( let i = 0 ; i < m ; i ++ ) { if ( arr [ i ] == 0 ) { isZero = 1 ; } if ( arr [ i ] == 5 ) { isFive = 1 ; } } if ( isZero == 1 && isFive == 1 ) { result = 2 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else if ( isZero == 1 isFive == 1 ) { result = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else { result = - 1 ; } return result ; } let n = 3 , m = 6 ; let arr = [ 2 , 3 , 5 , 6 , 7 , 9 ] ; document . write ( numbers ( n , arr , m ) ) ;
let a = 5 , b = 7 , c = 10 ; if ( a <= b && a <= c ) document . write ( a + " " ) ; else if ( b <= a && b <= c ) document . write ( b + " " ) ; else document . write ( c + " " ) ;
function maxSum ( a , n ) { var maxAnd = Math . max ( ... a ) ; var maxOR = 0 ; for ( var i = 0 ; i < n ; i ++ ) { maxOR |= a [ i ] ; } document . write ( ( maxAnd + maxOR ) ) ; } var n = 4 ; var a = [ 3 , 5 , 6 , 1 ] ; maxSum ( a , n ) ;
function getMin ( arr , n , k ) { let res = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) res = Math . min ( res , arr [ i ] ) ; } return res ; } function getMax ( arr , n , k ) { let res = Number . MIN_VALUE ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) res = Math . max ( res , arr [ i ] ) ; } return res ; } let arr = [ 10 , 1230 , 45 , 67 , 1 ] ; let k = 10 ; let n = arr . length ; document . write ( " " + getMin ( arr , n , k ) + " " ) ; document . write ( " " + getMax ( arr , n , k ) ) ;
function printNumberWithDR ( k , d ) { if ( d == 0 && k != 1 ) document . write ( " " ) ; else { document . write ( d ) ; k -- ; while ( k -- > 0 ) document . write ( " " ) ; } } var k = 4 , d = 4 ; printNumberWithDR ( k , d ) ;
function countNumbers ( n ) { let c = 0 ; let limit = parseInt ( Math . sqrt ( n ) , 10 ) ; let prime = new Array ( limit + 1 ) ; prime . fill ( 0 ) ; for ( let i = 1 ; i <= limit ; i ++ ) { prime [ i ] = i ; } for ( let i = 2 ; i * i <= limit ; i ++ ) { if ( prime [ i ] == i ) { for ( let j = i * i ; j <= limit ; j += i ) { if ( prime [ j ] == j ) { prime [ j ] = i ; } } } } for ( let i = 2 ; i <= limit ; i ++ ) { let p = prime [ i ] ; let q = prime [ parseInt ( i / prime [ i ] , 10 ) ] ; if ( p * q == i && q != 1 && p != q ) { c += 1 ; } else if ( prime [ i ] == i ) { if ( Math . pow ( i , 8 ) <= n ) { c += 1 ; } } } return c ; } let n = 1000 ; document . write ( countNumbers ( n ) ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } function isInterprime ( n ) { if ( n < 4 ) return false ; var prev_prime = n ; var next_prime = n ; while ( ! isPrime ( prev_prime ) ) { prev_prime -- ; } while ( ! isPrime ( next_prime ) ) { next_prime ++ ; } if ( ( prev_prime + next_prime ) == 2 * n ) return true ; else return false ; } var n = 9 ; if ( isInterprime ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function get_unit_digit ( N ) { if ( N == 0 N == 1 ) return 1 ; else if ( N == 2 ) return 3 ; else if ( N == 3 ) return 9 ; return 3 ; } var N = 1 ; for ( N = 0 ; N <= 10 ; N ++ ) document . write ( " " + N + " " + get_unit_digit ( N ) + " " )
let f = new Array ( 1000 ) ; f . fill ( 0 ) ; function fib ( n ) { if ( n == 0 ) { return 0 ; } if ( n == 1 n == 2 ) { return ( f [ n ] = 1 ) ; } if ( f [ n ] > 0 ) { return f [ n ] ; } let k = ( ( n & 1 ) > 0 ) ? ( n + 1 ) / 2 : n / 2 ; f [ n ] = ( ( n & 1 ) > 0 ) ? ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) : ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } function calculateSumOfSquares ( n ) { return fib ( n ) * fib ( n + 1 ) ; } let n = 6 ; document . write ( " " + calculateSumOfSquares ( n ) ) ;
function NumberOfSolutions ( x , y , z , n ) { var ans = 0 ; for ( var i = 0 ; i <= x ; i ++ ) { for ( var j = 0 ; j <= y ; j ++ ) { var temp = n - i - j ; if ( temp >= 0 ) { temp = Math . min ( temp , z ) ; ans += temp + 1 ; } } } return ans ; } var x = 1 , y = 2 , z = 3 , n = 4 ; document . write ( NumberOfSolutions ( x , y , z , n ) ) ;
function nthTerm ( n ) { return Math . pow ( n , 2 ) + 4 * n ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function isPerfectSquare ( x ) { sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } function isProduct ( num ) { var cnt = 0 ; for ( var i = 2 ; cnt < 2 && ( i * i ) <= num ; ++ i ) { while ( num % i == 0 ) { num = parseInt ( num / i ) ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; } function findNumbers ( N ) { vec = [ ] ; for ( var i = 1 ; i <= N ; i ++ ) { if ( isProduct ( i ) && ! isPerfectSquare ( i ) ) { vec . push ( i ) ; } } for ( var i = 0 ; i < vec . length ; i ++ ) { document . write ( vec [ i ] + " " ) ; } } var N = 30 ; findNumbers ( N ) ;
function nthTerm ( n ) { return 2 * Math . pow ( n , 3 ) + Math . pow ( n , 2 ) ; } let N = 3 ; document . write ( nthTerm ( N ) ) ;
function NthTerm ( n ) { var x = ( 2 * n * n ) % 1000000009 ; return ( x - n + 1000000009 ) % 1000000009 ; } var N = 4 ; document . write ( NthTerm ( N ) ) ;
function findSum ( N ) { return ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ; } var N = 3 ; document . write ( findSum ( N ) ) ;
function nthTerm ( N ) { return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; } let N = 3 ; document . write ( nthTerm ( N ) ) ;
MAX = 16 var nCr = Array . from ( Array ( MAX ) , ( ) => new Array ( MAX ) ) ; function binomial ( ) { for ( var i = 0 ; i < MAX ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } } function findTanNTheta ( tanTheta , n ) { ans = 0 , numerator = 0 , denominator = 0 ; toggle = 1 ; for ( var i = 1 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * Math . pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } denominator = 1 ; toggle = - 1 ; for ( var i = 2 ; i <= n ; i += 2 ) { numerator = numerator + nCr [ n ] [ i ] * Math . pow ( tanTheta , i ) * toggle ; toggle = toggle * - 1 ; } ans = numerator / denominator ; return ans . toFixed ( 5 ) ; } binomial ( ) ; var tanTheta = 0.3 ; var n = 10 ; document . write ( findTanNTheta ( tanTheta , n ) ) ;
function findMaximumPieces ( n ) { return 1 + n * ( n + 1 ) / 2 ; } document . write ( findMaximumPieces ( 3 ) ) ;
function isDivisible ( n ) { while ( parseInt ( n / 100 ) > 0 ) { var d = n % 10 ; n = parseInt ( n / 10 ) ; n += d * 2 ; } return ( n % 19 == 0 ) ; } var n = 101156 ; if ( isDivisible ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function calculateSum ( n ) { return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; } let n = 4 ; document . write ( " " + calculateSum ( n ) ) ;
function printCombination ( n ) { for ( let i = 1 ; i < n ; i ++ ) { if ( i % 3 != 0 ) { for ( let j = 1 ; j < n ; j ++ ) { if ( j % 3 != 0 ) { for ( let k = 1 ; k < n ; k ++ ) { if ( k % 3 != 0 && ( i + j + k ) == n ) { document . write ( i + " " + j + " " + k ) ; return ; } } } } } } } let n = 233 ; printCombination ( n ) ;
function percent ( a , b ) { var result = 0 ; result = ( ( b - a ) * 100 ) / a ; return result ; } var a = 20 , b = 25 ; document . write ( percent ( a , b ) + " " ) ;
function calculate ( ar , size ) { var count = 0 ; for ( i = 0 ; i < size ; i ++ ) if ( ar [ i ] % 2 == 0 && ar [ i ] != 0 && ar [ i ] != 2 ) count ++ ; return count ; } var a = [ 1 , 3 , 4 , 6 ] ; var size = a . length ; document . write ( calculate ( a , size ) ) ;
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } var a = 98 , b = 56 ; document . write ( " " + a + " " + b + " " + gcd ( a , b ) ) ;
function dig ( a ) { var count = 0 ; while ( a > 0 ) { a /= 10 ; count ++ ; } return count ; } function required_number ( num , n , d ) { var i , j , power = 1 , a , flag = 0 ; for ( i = num ; i >= 1 ; i -- ) { power = Math . pow ( 10 , i ) ; a = n % power ; if ( d > a ) { flag = 1 ; break ; } } if ( flag > 0 ) { var t = 0 ; for ( j = 0 ; j < i ; j ++ ) { t += 9 * Math . pow ( 10 , j ) ; } if ( n % power == t ) document . write ( n ) ; else { document . write ( n - ( n % power ) - 1 ) ; } } else document . write ( n ) ; } var n = 1029 , d = 102 ; var num = dig ( n ) ; required_number ( num , n , d ) ;
function twoEggDrop ( k ) { return Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8 * k ) ) / 2.0 ) ; } var k = 100 ; document . write ( twoEggDrop ( k ) ) ;
function findArea ( a ) { let area ; area = 5 * Math . sqrt ( 3 ) * a * a ; return area ; } function findVolume ( a ) { let volume ; volume = ( 5 / 12 ) * ( 3 + Math . sqrt ( 5 ) ) * a * a * a ; return volume ; } let a = 5 ; document . write ( " " + findArea ( a ) . toFixed ( 3 ) + " " ) ; document . write ( " " + findVolume ( a ) . toFixed ( 3 ) ) ;
function ways ( n ) { var first = 2 ; var second = 3 ; var res = 0 ; for ( i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; } var n = 7 ; document . write ( " " + ways ( n ) ) ;
function countDigits ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + Math . floor ( ans ) ; } let n = 4 ; document . write ( countDigits ( n ) + " " ) ;
let cm , meter , kilometer ; cm = 1000 ; meter = cm / 100.0 ; kilometer = cm / 100000.0 ; document . write ( " " + meter + " " + " " ) ; document . write ( " " + kilometer + " " + " " ) ;
function everMeet ( x1 , x2 , v1 , v2 ) { if ( x1 < x2 && v1 <= v2 ) { return false ; } if ( x1 > x2 && v1 >= v2 ) { return false ; } if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } return ( ( x1 - x2 ) % ( v1 - v2 ) == 0 ) ; } function swap ( a , b ) { let t = a ; a = b ; b = t ; } let x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
var a = 4 ; var b = 3 ; var val = ( a + b - 1 ) / b ; document . write ( " " + val + " " ) ; a = 6 ; b = 3 ; val = parseInt ( ( a + b - 1 ) / b ) ; document . write ( " " + val ) ;
function sumTillX ( x , n ) { let odd = Math . ceil ( n / 2.0 ) ; if ( x <= odd ) return x * x ; let even = x - odd ; return ( ( odd * odd ) + ( even * even ) + even ) ; } function rangeSum ( N , L , R ) { return sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ; } let N = 10 , L = 1 , R = 6 ; document . write ( rangeSum ( N , L , R ) ) ;
function printTwinPrime ( n ) { let prime = [ ] ; for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let i = 2 ; i <= n - 2 ; i ++ ) { if ( prime [ i ] == true && prime [ i + 2 ] == true ) document . write ( " " + i + " " + ( i + 2 ) + " " ) ; } } let n = 25 ; printTwinPrime ( n ) ;
function isCubeFree ( n ) { if ( n == 1 ) return false ; for ( let i = 2 ; i * i * i <= n ; i ++ ) if ( n % ( i * i * i ) == 0 ) return false ; return true ; } function prletCubeFree ( n ) { for ( let i = 2 ; i <= n ; i ++ ) { if ( isCubeFree ( i ) ) { document . write ( i + " " ) ; } } } let N = 20 ; prletCubeFree ( N ) ;
function inversegrayCode ( n ) { let inv = 0 ; for ( ; n ; n = n >> 1 ) inv ^= n ; return inv ; } let n = 15 ; document . write ( inversegrayCode ( n ) ) ;
function productPrimeFactors ( n ) { var product = 1 ; if ( n % 2 == 0 ) { product *= 2 ; while ( n % 2 == 0 ) n = n / 2 ; } for ( i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { product = product * i ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) product = product * n ; return product ; } var n = 44 ; document . write ( productPrimeFactors ( n ) ) ;
function calculateProbability ( N ) { let probability = N / ( N + 1 ) ; return probability ; } let N ; let probabilityMax ; N = 1 ; probabilityMax = calculateProbability ( N ) ; document . write ( " " + " " + N + " " + Math . round ( probabilityMax * 10000.0 ) / 10000.0 + " " ) ; N = 2 ; probabilityMax = calculateProbability ( N ) ; document . write ( " " + N + " " + Math . round ( probabilityMax * 10000.0 ) / 10000.0 + " " ) ; N = 10 ; probabilityMax = calculateProbability ( N ) ; document . write ( " " + N + " " + Math . round ( probabilityMax * 10000.0 ) / 10000.0 + " " ) ;
function mean ( mid , freq , n ) { let sum = 0 , freqSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + mid [ i ] * freq [ i ] ; freqSum = freqSum + freq [ i ] ; } return sum / freqSum ; } function groupedSD ( lower_limit , upper_limit , freq , n ) { let mid = [ ] ; let sum = 0 , freqSum = 0 , sd ; for ( let i = 0 ; i < n ; i ++ ) { mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 ; sum = sum + freq [ i ] * mid [ i ] * mid [ i ] ; freqSum = freqSum + freq [ i ] ; } sd = Math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) ; return sd ; } let lower_limit = [ 50 , 61 , 71 , 86 , 96 ] ; let upper_limit = [ 60 , 70 , 85 , 95 , 100 ] ; let freq = [ 9 , 7 , 9 , 12 , 8 ] ; let n = lower_limit . length ; document . write ( groupedSD ( lower_limit , upper_limit , freq , n ) ) ;
function avg_of_even_num ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 2 * i ; return sum / n ; } let n = 9 ; document . write ( avg_of_even_num ( n ) ) ;
function avg_of_even_num ( n ) { return n + 1 ; } var n = 8 ; document . write ( avg_of_even_num ( n ) ) ;
function squareSum ( n ) { return n * ( 4 * n * n - 1 ) / 3 ; } document . write ( squareSum ( 8 ) ) ;
function isPrime ( n ) { if ( n % 2 == 0 ) return false ; for ( let i = 3 ; i * i <= n ; i += 2 ) if ( n % i == 0 ) return false ; return true ; } function nextPrime ( start ) { let next = start + 1 ; while ( ! isPrime ( next ) ) next ++ ; return next ; } function areAdjacentPrimes ( a , b , c ) { if ( ! isPrime ( a ) || ! isPrime ( b ) || ! isPrime ( c ) ) return false ; let next = nextPrime ( a ) ; if ( next != b ) return false ; if ( nextPrime ( b ) != c ) return false ; return true ; } if ( areAdjacentPrimes ( 11 , 13 , 19 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function checkSemiprime ( num ) { let cnt = 0 ; for ( let i = 2 ; cnt < 2 && i * i <= num ; ++ i ) while ( num % i == 0 ) { num /= i ; ++ cnt ; } if ( num > 1 ) ++ cnt ; return cnt == 2 ? 1 : 0 ; } function semiprime ( n ) { if ( checkSemiprime ( n ) != 0 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; } let n = 6 ; semiprime ( n ) ; n = 8 ; semiprime ( n ) ;
function sumOfSeries ( n ) { var sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * i ; return sum ; } var n = 10 ; document . write ( sumOfSeries ( n ) ) ;
function sumOfSeries ( n ) { return ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; } var n = 10 ; document . write ( sumOfSeries ( n ) ) ;
function binomialCoeff ( n , k ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { C [ i ] = new Array ( k + 1 ) ; } for ( let i = 0 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } function maxcoefficientvalue ( n ) { if ( n % 2 == 0 ) return binomialCoeff ( n , n / 2 ) ; else return binomialCoeff ( n , ( n + 1 ) / 2 ) ; } let n = 4 ; document . write ( maxcoefficientvalue ( n ) ) ;
function __gcd ( a , b ) { if ( b == 0 ) { return a ; } else { return __gcd ( b , a % b ) ; } } function LCM ( x , y , z ) { let ans = ( ( x * y ) / ( __gcd ( x , y ) ) ) ; return ( ( z * ans ) / ( __gcd ( ans , z ) ) ) ; } function findDivisible ( n , x , y , z ) { let lcm = LCM ( x , y , z ) ; let ndigitnumber = Math . pow ( 10 , n - 1 ) ; let reminder = ndigitnumber % lcm ; if ( reminder == 0 ) return ndigitnumber ; ndigitnumber += lcm - reminder ; if ( ndigitnumber < Math . pow ( 10 , n ) ) return ndigitnumber ; else return 0 ; } let n = 4 , x = 2 , y = 3 , z = 5 ; let res = findDivisible ( n , x , y , z ) ; if ( res != 0 ) document . write ( res ) ; else document . write ( " " ) ;
function squaresum ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } let n = 4 ; document . write ( squaresum ( n ) ) ;
function distance ( x1 , y1 , x2 , y2 ) { return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; } document . write ( distance ( 3 , 4 , 4 , 3 ) ) ;
function accumulate ( s ) { let acc = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { acc += s [ i ] - ' ' ; } return acc ; } function isDivisible ( s ) { let n = s . length ; if ( s [ n - 1 ] != ' ' && s [ n - 1 ] != ' ' ) return false ; let sum = accumulate ( s ) ; return ( sum % 3 == 0 ) ; } let s = " " ; isDivisible ( s ) ? document . write ( " " ) : document . write ( " " ) ; s = " " ; isDivisible ( s ) ? document . write ( " " ) : document . write ( " " ) ;
function checkPerfectSquare ( n ) { let d = Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } function largestPerfectSquareNumber ( a , n ) { let maxi = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( checkPerfectSquare ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } let a = [ 16 , 20 , 25 , 2 , 3 , 10 ] ; let n = a . length ; document . write ( largestPerfectSquareNumber ( a , n ) ) ;
function gcd ( a , b ) { return b == 0 ? a : gcd ( b , a % b ) ; } function find_LCM ( x , y ) { return Math . floor ( ( x * y ) / gcd ( x , y ) ) ; } function CountPairs ( n , m , A , B ) { let cnt = 0 ; let lcm = find_LCM ( A , B ) ; for ( let i = 1 ; i <= n ; i ++ ) cnt += Math . floor ( ( m + ( i % lcm ) ) / lcm ) ; return cnt ; } let n = 60 , m = 90 , A = 5 , B = 10 ; document . write ( CountPairs ( n , m , A , B ) ) ;
let MAX = 101 ; let prefix = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { prefix [ i ] = new Array ( MAX ) . fill ( 0 ) } let ar = new Array ( MAX ) . fill ( 0 ) ; function cal_prefix ( n , arr ) { for ( let i = 0 ; i < n ; i ++ ) ar [ i + 1 ] = arr [ i ] ; for ( let i = 1 ; i < MAX ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) prefix [ i ] [ j ] = 0 ; for ( let j = 1 ; j <= n ; j ++ ) { prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + ( ar [ j ] <= i ? 1 : 0 ) ; } } } function ksub ( l , r , n , k ) { let lo = 1 ; let hi = MAX - 1 ; while ( lo + 1 < hi ) { let mid = Math . floor ( ( lo + hi ) / 2 ) ; if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) hi = mid ; else lo = mid + 1 ; } if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) hi = lo ; return hi ; } let arr = new Array ( 1 , 4 , 2 , 3 , 5 , 7 , 6 ) ; let n = arr . length ; let k = 4 ; cal_prefix ( n , arr ) ; let queries = new Array ( new Array ( 1 , n , 1 ) , new Array ( 2 , n - 2 , 2 ) , new Array ( 3 , n - 1 , 3 ) ) ; let q = queries . length ; for ( let i = 0 ; i < q ; i ++ ) document . write ( ksub ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , n , queries [ i ] [ 2 ] ) + " " ) ;
function max_min ( a , n ) { if ( n <= 1 ) return Number . MAX_VALUE ; let f_min = a [ 0 ] , s_min = Number . MAX_VALUE ; let f_max = a [ 0 ] , s_max = Number . MIN_VALUE ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= f_min ) { s_min = f_min ; f_min = a [ i ] ; } else if ( a [ i ] < s_min ) { s_min = a [ i ] ; } if ( a [ i ] >= f_max ) { s_max = f_max ; f_max = a [ i ] ; } else if ( a [ i ] > s_max ) { s_max = a [ i ] ; } } return Math . min ( ( f_max - s_min ) , ( s_max - f_min ) ) ; } let a = [ 1 , 3 , 3 , 7 ] ; let n = a . length ; document . write ( max_min ( a , n ) ) ;
function minimal ( a , n ) { let lo = 0 , hi = n - 1 ; while ( lo < hi ) { let mid = ( lo + hi ) >> 1 ; if ( a [ mid ] < a [ mid + 1 ] ) { hi = mid ; } else { lo = mid + 1 ; } } return lo ; } let a = [ 8 , 5 , 4 , 3 , 4 , 10 ] ; let n = a . length ; let ind = minimal ( a , n ) ; document . write ( a [ ind ] ) ;
function findIndices ( arr , n ) { let leftMin = 0 , rightMin = 0 ; let leftMax = 0 , rightMax = 0 ; let min = arr [ 0 ] , max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) { leftMin = rightMin = i ; min = arr [ i ] ; } else if ( arr [ i ] == min ) rightMin = i ; if ( arr [ i ] > max ) { leftMax = rightMax = i ; max = arr [ i ] ; } else if ( arr [ i ] == max ) rightMax = i ; } document . write ( " " + leftMin + " " ) ; document . write ( " " + rightMin + " " ) ; document . write ( " " + leftMax + " " ) ; document . write ( " " + rightMax + " " ) ; } let arr = [ 2 , 1 , 1 , 2 , 1 , 5 , 6 , 5 ] ; let n = arr . length ; findIndices ( arr , n ) ;
function diagonalsMinMax ( mat ) { let n = mat . length ; if ( n == 0 ) return ; let principalMin = mat [ 0 ] [ 0 ] , principalMax = mat [ 0 ] [ 0 ] ; let secondaryMin = mat [ n - 1 ] [ 0 ] , secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 1 ; j < n ; j ++ ) { if ( i == j ) { if ( mat [ i ] [ j ] < principalMin ) { principalMin = mat [ i ] [ j ] ; } if ( mat [ i ] [ j ] > principalMax ) { principalMax = mat [ i ] [ j ] ; } } if ( ( i + j ) == ( n - 1 ) ) { if ( mat [ i ] [ j ] < secondaryMin ) { secondaryMin = mat [ i ] [ j ] ; } if ( mat [ i ] [ j ] > secondaryMax ) { secondaryMax = mat [ i ] [ j ] ; } } } } document . write ( " " + principalMin + " " ) ; document . write ( " " + principalMax + " " ) ; document . write ( " " + secondaryMin + " " ) ; document . write ( " " + secondaryMax + " " ) ; } let matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] ; diagonalsMinMax ( matrix ) ;
function countSegments ( a , n , x ) { let flag = false ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; } let a = [ 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 ] ; let n = a . length ; let x = 13 ; document . write ( countSegments ( a , n , x ) ) ;
function count_triples ( n , k ) { var i = 0 , j = 0 , l = 0 ; var count = 0 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { for ( l = 1 ; l <= n ; l ++ ) { if ( ( i + j ) % k == 0 && ( i + l ) % k == 0 && ( j + l ) % k == 0 ) count ++ ; } } } return count ; } var n = 3 ; var k = 2 ; var ans = count_triples ( n , k ) ; document . write ( ans ) ;
let maxs = 1000001 ; function kthSmallestLargest ( arr , n , k ) { let max_val = Math . max ( ... arr ) ; let hash = new Array ( max_val + 1 ) ; for ( let i = 0 ; i < hash . length ; i ++ ) { hash [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } let count = 0 ; for ( let i = 0 ; i <= max_val ; i ++ ) { while ( hash [ i ] > 0 ) { count ++ ; if ( count == k ) { return i ; } hash [ i ] -- ; } } return - 1 ; } let arr = [ 11 , 6 , 2 , 9 , 4 , 3 , 16 ] ; let n = arr . length , k = 3 ; document . write ( " " + kthSmallestLargest ( arr , n , k ) ) ;
function bsearch ( A , key_to_search ) { let n = A . length ; let lg = parseInt ( Math . log ( n - 1 ) / Math . log ( 2 ) ) + 1 ; let pos = 0 ; for ( let i = lg ; i >= 0 ; i -- ) { if ( A [ pos ] == key_to_search ) return pos ; let new_pos = pos | ( 1 << i ) ; if ( ( new_pos < n ) && ( A [ new_pos ] <= key_to_search ) ) pos = new_pos ; } return ( ( A [ pos ] == key_to_search ) ? pos : - 1 ) ; } let A = [ - 2 , 10 , 100 , 250 , 32315 ] ; document . write ( bsearch ( A , 10 ) ) ;
function findmedian ( a , n1 , b , n2 ) { let i = 0 ; let j = 0 ; let k ; let m1 = - 1 , m2 = - 1 ; for ( k = 0 ; k <= ( n1 + n2 ) / 2 ; k ++ ) { if ( i < n1 && j < n2 ) { if ( a [ i ] < b [ j ] ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } else { m2 = m1 ; m1 = b [ j ] ; j ++ ; } } else if ( i == n1 ) { m2 = m1 ; m1 = b [ j ] ; j ++ ; } else if ( j == n2 ) { m2 = m1 ; m1 = a [ i ] ; i ++ ; } } if ( ( n1 + n2 ) % 2 == 0 ) { return ( m1 + m2 ) * 1.0 / 2 ; } return m1 ; } let a = [ 1 , 12 , 15 , 26 , 38 ] ; let b = [ 2 , 13 , 24 ] ; let n1 = a . length ; let n2 = b . length ; document . write ( findmedian ( a , n1 , b , n2 ) ) ;
function printNSE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + " " + next + " " ) ; } } var arr = [ 11 , 13 , 21 , 3 ] ; var n = arr . length ; printNSE ( arr , n ) ;
function longestSubarray ( input ) { let prev = - 1 ; let current , next ; let prevCount = 0 , currentCount = 1 ; let longest = 1 ; current = input [ 0 ] ; for ( let i = 1 ; i < input . length ; i ++ ) { next = input [ i ] ; if ( next == current ) { currentCount ++ ; } else if ( next == prev ) { prevCount += currentCount ; prev = current ; current = next ; currentCount = 1 ; } else { longest = Math . max ( longest , currentCount + prevCount ) ; prev = current ; prevCount = currentCount ; current = next ; currentCount = 1 ; } } return Math . max ( longest , currentCount + prevCount ) ; } let input = [ 5 , 5 , 6 , 7 , 6 ] ; document . write ( longestSubarray ( input ) ) ;
function binarySearch ( searchSpace , s , e , num ) { let ans = 0 ; while ( s <= e ) { let mid = Math . floor ( ( s + e ) / 2 ) ; if ( searchSpace [ mid ] >= num ) { ans = mid ; e = mid - 1 ; } else s = mid + 1 ; } return ans ; } function longestSubArr ( arr , n ) { let searchSpace = new Array ( n ) ; let index = new Array ( n ) ; let j = 0 ; let ans = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( j == 0 searchSpace [ j - 1 ] < arr [ i ] ) { searchSpace [ j ] = arr [ i ] ; index [ j ] = i ; j ++ ; } let idx = binarySearch ( searchSpace , 0 , j - 1 , arr [ i ] ) ; ans = Math . max ( ans , i - index [ idx ] + 1 ) ; } return ans ; } let arr = [ - 5 , - 1 , 7 , 5 , 1 , - 2 ] ; let n = arr . length ; document . write ( longestSubArr ( arr , n ) ) ;
function isSuffix ( s1 , s2 ) { let n1 = s1 . length , n2 = s2 . length ; if ( n1 > n2 ) return false ; for ( let i = 0 ; i < n1 ; i ++ ) if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) return false ; return true ; } let s1 = " " , s2 = " " ; let result = isSuffix ( s1 , s2 ) ; if ( result ) document . write ( " " ) ; else document . write ( " " ) ;
function checkIfAllTogether ( s , c ) { function checkIfAllTogether ( s , c ) { let oneSeen = false ; let i = 0 , n = s . length ; while ( i < n ) { if ( s [ i ] == c ) { if ( oneSeen == true ) return false ; while ( i < n && s [ i ] == c ) i ++ ; oneSeen = true ; } else i ++ ; } return true ; } let s = " " ; if ( checkIfAllTogether ( s , ' ' ) ) document . write ( " " ) ; else document . write ( " " ) ;
function search ( arr , n , x ) { let front = 0 , back = n - 1 ; while ( front <= back ) { if ( arr [ front ] == x arr [ back ] == x ) return true ; front ++ ; back -- ; } return false ; } let arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] ; let x = 130 ; let n = arr . length ; if ( search ( arr , n , x ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findValue ( X , Y , P ) { if ( P % 2 == 0 ) return parseInt ( ( Math . max ( X , Y ) / Math . min ( X , Y ) ) , 10 ) ; else return parseInt ( ( Math . max ( 2 * X , Y ) / Math . min ( 2 * X , Y ) ) , 10 ) ; } let X = 1 , Y = 2 , P = 1 ; document . write ( findValue ( X , Y , P ) + " " ) ; X = 3 , Y = 7 , P = 2 ; document . write ( findValue ( X , Y , P ) ) ;
function sum ( arr , from , to ) { let total = 0 ; for ( let i = from ; i <= to ; i ++ ) total += arr [ i ] ; return total ; } function findMax ( arr , n , k ) { let dp = new Array ( k + 1 ) ; for ( let i = 0 ; i < k + 1 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } for ( let i = 1 ; i <= n ; i ++ ) dp [ 1 ] [ i ] = sum ( arr , 0 , i - 1 ) ; for ( let i = 1 ; i <= k ; i ++ ) dp [ i ] [ 1 ] = arr [ 0 ] ; for ( let j = 2 ; j <= n ; j ++ ) { let best = Number . MAX_VALUE ; for ( let p = 1 ; p <= j ; p ++ ) best = Math . min ( best , Math . max ( dp [ i - 1 ] [ p ] , sum ( arr , p , j - 1 ) ) ) ; dp [ i ] [ j ] = best ; } } return dp [ k ] [ n ] ; } let arr = [ 10 , 20 , 60 , 50 , 30 , 40 ] ; let n = arr . length ; let k = 3 ; document . write ( findMax ( arr , n , k ) ) ;
function countCrossLine ( arr , n ) { let count_crossline = 0 ; let i , key , j ; for ( i = 1 ; i < n ; i ++ ) { key = arr [ i ] ; j = i - 1 ; while ( j >= 0 && arr [ j ] > key ) { arr [ j + 1 ] = arr [ j ] ; j = j - 1 ; count_crossline ++ ; } arr [ j + 1 ] = key ; } return count_crossline ; } let arr = [ 4 , 3 , 1 , 2 ] ; let n = arr . length ; document . write ( countCrossLine ( arr , n ) + " " ) ;
function findMaxRec ( A , n ) { if ( n == 1 ) return A [ 0 ] ; return Math . max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) ; } let A = [ 1 , 4 , 45 , 6 , - 50 , 10 , 2 ] ; let n = A . length ; document . write ( findMaxRec ( A , n ) ) ;
function mod ( x ) { if ( x >= 0 ) return x ; return - x ; } function findSquare ( n ) { let points = [ [ 1 , 2 ] , [ - 3 , 4 ] , [ 1 , 78 ] , [ - 3 , - 7 ] ] ; let a = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { let x , y ; x = points [ i ] [ 0 ] ; y = points [ i ] [ 1 ] ; a [ i ] = Math . max ( mod ( x ) , mod ( y ) ) ; } a . sort ( function ( a , b ) { return a - b } ) ; let index = ( Math . floor ( n / 2 ) - 1 ) ; document . write ( " " + a [ index ] ) ; } let N ; N = 4 ; findSquare ( N ) ;
function odd_even ( arr , n ) { var odd_indexes = [ ] ; var even_indexes = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) odd_indexes . push ( arr [ i ] ) ; else even_indexes . push ( arr [ i ] ) ; } odd_indexes . sort ( ) ; even_indexes . sort ( ) ; for ( var i = 0 ; i < odd_indexes . length ; i ++ ) document . write ( odd_indexes [ i ] + " " ) ; for ( var i = 0 ; i < even_indexes . length ; i ++ ) document . write ( even_indexes [ i ] + " " ) ; } var arr = [ 3 , 2 , 7 , 6 , 8 ] ; var n = arr . length ; odd_even ( arr , n ) ;
function minimumIncrease ( a , b , c ) { var arr = [ a , b , c ] ; arr . sort ( ( a , b ) => a - b ) ; if ( arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] ) return 0 ; else return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) ; } var a = 3 , b = 5 , c = 10 ; document . write ( minimumIncrease ( a , b , c ) ) ;
function absSumDidd ( a ) { a . sort ( ( a , b ) => a - b ) ; var midValue = a [ a . length / 2 ] ; var sum = 0 ; for ( var i = 0 ; i < a . length ; i ++ ) { sum = sum + Math . abs ( a [ i ] - midValue ) ; } return sum ; } var arr = [ 5 , 11 , 14 , 10 , 17 , 15 ] ; document . write ( absSumDidd ( arr ) ) ;
var SIZE = 26 function binomialCoeff ( n , k ) { var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function countSubsequences ( str1 , str2 ) { var freq1 = Array ( SIZE ) . fill ( 0 ) , freq2 = Array ( SIZE ) . fill ( 0 ) ; var n1 = str1 . length ; var n2 = str2 . length ; for ( var i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; var count = 1 ; for ( var i = 0 ; i < SIZE ; i ++ ) if ( freq2 [ i ] != 0 ) { if ( freq2 [ i ] <= freq1 [ i ] ) count = count * binomialCoeff ( freq1 [ i ] , freq2 [ i ] ) ; else return 0 ; } return count ; } var str1 = " " ; var str2 = " " ; document . write ( " " + countSubsequences ( str1 , str2 ) ) ;
function findOccurrences ( str1 , substr1 ) { let counter = 0 ; for ( let i = 0 ; i < str1 . length ; i ++ ) { if ( str1 [ i ] == substr1 [ 0 ] ) { for ( let j = i + 1 ; j < str1 . length ; j ++ ) { if ( str1 [ j ] == substr1 [ 1 ] ) { for ( let k = j + 1 ; k < str1 . length ; k ++ ) { if ( str1 [ k ] == substr1 [ 2 ] ) counter ++ ; } } } } } return counter ; } let str1 = " " ; let substr1 = " " ; document . write ( findOccurrences ( str1 , substr1 ) ) ;
function findOccurrences ( str , substr ) { let n = str . length ; let preLeft = new Array ( n ) ; preLeft . fill ( 0 ) ; let preRight = new Array ( n ) ; preRight . fill ( 0 ) ; if ( str [ 0 ] == substr [ 0 ] ) preLeft [ 0 ] ++ ; for ( let i = 1 ; i < n ; i ++ ) { if ( str [ i ] == substr [ 0 ] ) preLeft [ i ] = preLeft [ i - 1 ] + 1 ; else preLeft [ i ] = preLeft [ i - 1 ] ; } if ( str [ n - 1 ] == substr [ 2 ] ) preRight [ n - 1 ] ++ ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == substr [ 2 ] ) preRight [ i ] = preRight [ i + 1 ] + 1 ; else preRight [ i ] = preRight [ i + 1 ] ; } let counter = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ 1 ] ) { let total = preLeft [ i - 1 ] * preRight [ i + 1 ] ; counter += total ; } } return counter ; } let str = " " ; let substr = " " ; document . write ( findOccurrences ( str , substr ) ) ;
function findString ( str , n , k ) { if ( k == 0 ) { document . write ( str ) ; ; return ; } var str2 = str ; var p = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str2 . charAt ( i ) != ' ' ) { str2 = str2 . substring ( 0 , i ) + ' ' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } if ( p < k ) { for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == ' ' ) { str2 = str2 . substring ( 0 , i ) + ' ' + str2 . substring ( i + 1 ) ; p ++ ; if ( p == k ) break ; } } document . write ( str2 ) ; } var str = " " ; var n = str . length ; var k = 2 ; findString ( str , n , k ) ;
function printSubsequences ( s ) { let str = s . split ( ' ' ) ; let n = str . length ; let opsize = Math . pow ( 2 , n - 1 ) ; for ( let counter = 0 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { document . write ( str [ j ] ) ; if ( ( counter & ( 1 << j ) ) > 0 ) document . write ( " " ) ; } document . write ( " " ) ; } } let str = " " ; printSubsequences ( str ) ;
function countDeletions ( s ) { var ans = 0 ; var str = s ; for ( var i = 0 ; i < str . length - 1 ; i ++ ) if ( str [ i ] == str [ i + 1 ] ) ans ++ ; return ans ; } var str = " " ; document . write ( countDeletions ( str ) ) ;
function evenlength ( n ) { let res = n ; for ( let j = n . length - 1 ; j >= 0 ; -- j ) res += n [ j ] ; return res ; } let n = " " ; document . write ( evenlength ( n ) ) ;
function uniqueCharacters ( str ) { for ( let i = 0 ; i < str . length ; i ++ ) for ( let j = i + 1 ; j < str . length ; j ++ ) if ( str [ i ] == str [ j ] ) return false ; return true ; } let input = " " ; if ( uniqueCharacters ( input ) == true ) document . write ( " " + input + " " + " " ) ; else document . write ( " " + input + " " ) ;
function findIndex ( str ) { let len = str . length ; let open = new Array ( len + 1 ) ; let close = new Array ( len + 1 ) ; for ( let i = 0 ; i < len + 1 ; i ++ ) { open [ i ] = 0 ; close [ i ] = 0 ; } let index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str [ 0 ] == ' ' ) open [ 1 ] = 1 ; if ( str [ len - 1 ] == ' ' ) close [ len - 1 ] = 1 ; for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( let i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( let i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; } let str = " " ; document . write ( findIndex ( str ) ) ;
function decimalToBinary ( num , k_prec ) { let binary = " " ; let Integral = parseInt ( num , 10 ) ; let fractional = num - Integral ; while ( Integral > 0 ) { let rem = Integral % 2 ; binary += ( String . fromCharCode ( rem + ' ' . charCodeAt ( ) ) ) ; Integral = parseInt ( Integral / 2 , 10 ) ; } binary = reverse ( binary ) ; binary += ( ' ' ) ; while ( k_prec -- > 0 ) { fractional *= 2 ; let fract_bit = parseInt ( fractional , 10 ) ; if ( fract_bit == 1 ) { fractional -= fract_bit ; binary += String . fromCharCode ( 1 + ' ' . charCodeAt ( ) ) ; } else { binary += String . fromCharCode ( 0 + ' ' . charCodeAt ( ) ) ; } } return binary ; } function reverse ( input ) { let temparray = input . split ( ' ' ) ; let left , right = 0 ; right = temparray . length - 1 ; for ( left = 0 ; left < right ; left ++ , right -- ) { let temp = temparray [ left ] ; temparray [ left ] = temparray [ right ] ; temparray [ right ] = temp ; } return temparray . join ( " " ) ; } let n = 4.47 ; let k = 3 ; document . write ( decimalToBinary ( n , k ) + " " ) ; n = 6.986 ; k = 5 ; document . write ( decimalToBinary ( n , k ) ) ;
function isSmaller ( str1 , str2 ) { let n1 = str1 . length , n2 = str2 . length ; if ( n1 < n2 ) return true ; if ( n2 < n1 ) return false ; for ( let i = 0 ; i < n1 ; i ++ ) { if ( str1 [ i ] . charCodeAt ( ) < str2 [ i ] . charCodeAt ( ) ) return true ; else if ( str1 [ i ] . charCodeAt ( ) > str2 [ i ] . charCodeAt ( ) ) return false ; } return false ; } function findDiff ( str1 , str2 ) { if ( isSmaller ( str1 , str2 ) ) { let t = str1 ; str1 = str2 ; str2 = t ; } let str = " " ; let n1 = str1 . length , n2 = str2 . length ; let diff = n1 - n2 ; let carry = 0 ; for ( let i = n2 - 1 ; i >= 0 ; i -- ) { let sub = ( ( str1 [ i + diff ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) - ( str2 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) - carry ) ; if ( sub < 0 ) { sub = sub + 10 ; carry = 1 ; } else carry = 0 ; str += sub . toString ( ) ; } for ( let i = n1 - n2 - 1 ; i >= 0 ; i -- ) { if ( str1 [ i ] == ' ' && carry > 0 ) { str += " " ; continue ; } let sub = ( ( str1 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) - carry ) ; str += sub . toString ( ) ; carry = 0 ; } let aa = str . split ( ' ' ) ; aa . reverse ( ) ; return aa . join ( " " ) ; } let str1 = " " ; let str2 = " " ; document . write ( findDiff ( str1 , str2 ) ) ;
let MAX_CHAR = 26 ; function areKAnagrams ( str1 , str2 , k ) { let n = str1 . length ; if ( str2 . length != n ) return false ; let hash_str1 = Array ( MAX_CHAR ) ; hash_str1 . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) hash_str1 [ str1 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( hash_str1 [ str2 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] > 0 ) hash_str1 [ str2 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] -- ; else count ++ ; if ( count > k ) return false ; } return true ; } let str1 = " " ; let str2 = " " ; let k = 2 ; if ( areKAnagrams ( str1 , str2 , k ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function getDigit ( N , d ) { let str = N . toString ( ) ; return str [ d - 1 ] ; } function getNthChar ( N ) { let sum = 0 , nine = 9 ; let dist = 0 , len ; for ( len = 1 ; ; len ++ ) { sum += nine * len ; dist += nine ; if ( sum >= N ) { sum -= nine * len ; dist -= nine ; N -= sum ; break ; } nine *= 10 ; } let diff = ( Math . ceil ( ( N ) / ( len ) ) ) ; let d = N % len ; if ( d == 0 ) d = len ; return getDigit ( dist + diff , d ) ; } let N = 251 ; document . write ( getNthChar ( N ) ) ;
function findCount ( str ) { var result = 0 ; function findCount ( $str ) { $result = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) if ( i === str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) || i === str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) ) result ++ ; return result ; } var str = " " ; document . write ( findCount ( str ) ) ;
function print ( str , index ) { if ( index === str . length ) { document . write ( str . join ( " " ) + " " ) ; return ; } if ( str [ index ] === " " ) { str [ index ] = " " ; print ( str , index + 1 ) ; str [ index ] = " " ; print ( str , index + 1 ) ; str [ index ] = " " ; } else print ( str , index + 1 ) ; } var input = " " ; var str = input . split ( " " ) ; print ( str , 0 ) ;
function countOccurrences ( x , d ) { var count = 0 ; while ( x > 0 ) { if ( x % 10 == d ) count ++ ; x = parseInt ( x / 10 ) ; } return count ; } function maxOccurring ( x ) { if ( x < 0 ) x = - x ; var result = 0 ; var max_count = 1 ; for ( d = 0 ; d <= 9 ; d ++ ) { var count = countOccurrences ( x , d ) ; if ( count >= max_count ) { max_count = count ; result = d ; } } return result ; } var x = 1223355 ; document . write ( " " + maxOccurring ( x ) ) ;
function maxSubarrayXOR ( arr , n ) { let ans = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let curr_xor = 0 ; for ( let j = i ; j < n ; j ++ ) { curr_xor = curr_xor ^ arr [ j ] ; ans = Math . max ( ans , curr_xor ) ; } } return ans ; } let arr = [ 8 , 1 , 2 , 12 ] ; let n = arr . length ; document . write ( " " + maxSubarrayXOR ( arr , n ) ) ;
function divideString ( str , n ) { let str_size = str . length ; let part_size ; if ( str_size % n != 0 ) { document . write ( " " + " " ) ; return ; } part_size = parseInt ( str_size / n , 10 ) ; for ( let i = 0 ; i < str_size ; i ++ ) { if ( i % part_size == 0 ) document . write ( " " ) ; document . write ( str [ i ] ) ; } } let str = " " ; divideString ( str , 4 ) ;
var MOD = 1000000009 ; function power ( n ) { if ( n <= 1 ) return 1 ; n -- ; var res = [ [ 1 , 0 , ] , [ 0 , 1 ] ] ; var tMat = [ [ 2 , 3 ] , [ 1 , 0 ] ] ; while ( n ) { if ( n & 1 ) { var tmp = Array . from ( Array ( 2 ) , ( ) => Array ( 2 ) ) ; tmp [ 0 ] [ 0 ] = ( res [ 0 ] [ 0 ] * tMat [ 0 ] [ 0 ] + res [ 0 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 0 ] [ 1 ] = ( res [ 0 ] [ 0 ] * tMat [ 0 ] [ 1 ] + res [ 0 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; tmp [ 1 ] [ 0 ] = ( res [ 1 ] [ 0 ] * tMat [ 0 ] [ 0 ] + res [ 1 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 1 ] [ 1 ] = ( res [ 1 ] [ 0 ] * tMat [ 0 ] [ 1 ] + res [ 1 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; res [ 0 ] [ 0 ] = tmp [ 0 ] [ 0 ] ; res [ 0 ] [ 1 ] = tmp [ 0 ] [ 1 ] ; res [ 1 ] [ 0 ] = tmp [ 1 ] [ 0 ] ; res [ 1 ] [ 1 ] = tmp [ 1 ] [ 1 ] ; } n = parseInt ( n / 2 ) ; var tmp = Array . from ( Array ( 2 ) , ( ) => Array ( 2 ) ) ; tmp [ 0 ] [ 0 ] = ( tMat [ 0 ] [ 0 ] * tMat [ 0 ] [ 0 ] + tMat [ 0 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 0 ] [ 1 ] = ( tMat [ 0 ] [ 0 ] * tMat [ 0 ] [ 1 ] + tMat [ 0 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; tmp [ 1 ] [ 0 ] = ( tMat [ 1 ] [ 0 ] * tMat [ 0 ] [ 0 ] + tMat [ 1 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; tmp [ 1 ] [ 1 ] = ( tMat [ 1 ] [ 0 ] * tMat [ 0 ] [ 1 ] + tMat [ 1 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; tMat [ 0 ] [ 0 ] = tmp [ 0 ] [ 0 ] ; tMat [ 0 ] [ 1 ] = tmp [ 0 ] [ 1 ] ; tMat [ 1 ] [ 0 ] = tmp [ 1 ] [ 0 ] ; tMat [ 1 ] [ 1 ] = tmp [ 1 ] [ 1 ] ; } return ( res [ 0 ] [ 0 ] * 1 + res [ 0 ] [ 1 ] * 1 ) % MOD ; } var n = 3 ; document . write ( power ( n ) ) ;
function isFeasible ( mid , arr , n , k ) { let pos = arr [ 0 ] ; let elements = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] - pos >= mid ) { pos = arr [ i ] ; elements ++ ; if ( elements == k ) return true ; } } return false ; } function largestMinDist ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; let res = - 1 ; let left = 1 , right = arr [ n - 1 ] ; while ( left < right ) { let mid = parseInt ( ( left + right ) / 2 , 10 ) ; if ( isFeasible ( mid , arr , n , k ) ) { res = Math . max ( res , mid ) ; left = mid + 1 ; } else right = mid ; } return res ; } let arr = [ 1 , 2 , 8 , 4 , 9 ] ; let n = arr . length ; let k = 3 ; document . write ( largestMinDist ( arr , n , k ) ) ;
function floorSqrt ( x ) { if ( x == 0 x == 1 ) return x ; let start = 1 ; let end = x ; let ans ; while ( start <= end ) { let mid = ( start + end ) / 2 ; if ( mid * mid == x ) return mid ; if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else end = mid - 1 ; } return ans ; } let x = 11 ; document . write ( floorSqrt ( x ) + " " ) ;
function countOdd ( n ) { let coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = parseInt ( ( n - i ) / 2 , 10 ) ; j = parseInt ( ( i * ( i + 1 ) ) / 2 , 10 ) ; coun += j * m ; } else { m = parseInt ( ( ( n - 1 ) - i ) / 2 , 10 ) ; j = parseInt ( ( i * ( i + 1 ) ) / 2 , 10 ) ; coun += j * m ; } } return coun ; } function countEven ( n ) { let coun = 0 , m , j , i ; for ( i = n - 2 ; i >= 1 ; i -- ) { if ( i >= 1 ) { m = parseInt ( ( ( n - 1 ) - i ) / 2 , 10 ) ; j = parseInt ( ( i * ( i + 1 ) ) / 2 , 10 ) ; coun += j * m ; } else { m = parseInt ( ( n - i ) / 2 , 10 ) ; j = parseInt ( ( i * ( i + 1 ) ) / 2 , 10 ) ; coun += j * m ; } } return coun ; } let n = 5 ; if ( n >= 1 ) document . write ( countOdd ( n ) ) ; else document . write ( countEven ( n ) ) ;
function ellipse ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var x = ( 3.14 * l * b ) / 4 ; return x ; } var a = 5 , b = 3 ; document . write ( ellipse ( a , b ) ) ;
function noOfSquares ( x1 , y1 , x2 , y2 ) { var dx = Math . abs ( x2 - x1 ) ; var dy = Math . abs ( y2 - y1 ) ; var ans = dx + dy - __gcd ( dx , dy ) ; document . write ( ans ) ; } function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } var x1 = 1 , y1 = 1 , x2 = 4 , y2 = 3 ; noOfSquares ( x1 , y1 , x2 , y2 ) ;
function binomialCoeff ( n , k ) { var res = 1 ; var i ; if ( k > n - k ) k = n - k ; for ( i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function countPaths ( x1 , y1 , x2 , y2 ) { var m = Math . abs ( x1 - x2 ) ; var n = Math . abs ( y1 - y2 ) ; return ( binomialCoeff ( m + n , n ) ) ; } var x1 = 2 , y1 = 3 , x2 = 4 , y2 = 5 ; document . write ( countPaths ( x1 , y1 , x2 , y2 ) ) ;
function areaCircle ( b ) { let area = 3.1415926 * b * b ; return area ; } let a = 10 , b = 8 ; document . write ( areaCircle ( b ) ) ;
function section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) { let x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) ; let y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) ; let z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) ; document . write ( " " + x + " " ) ; document . write ( y + " " ) ; document . write ( z + " " ) ; } let x1 = 2 , x2 = 4 , y1 = - 1 , y2 = 3 , z1 = 4 , z2 = 2 , m = 2 , n = 3 ; section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) ;
function findRadiusOfcircumcircle ( n , a ) { if ( n < 0 a < 0 ) return - 1 ; var radius = ( a / Math . sqrt ( 2 - ( 2 * Math . cos ( 360 / n ) ) ) ) ; return radius ; } var n = 5 , a = 6 ; document . write ( findRadiusOfcircumcircle ( n , a ) . toFixed ( 5 ) ) ;
function findRadiusOfIncircle ( a , b , c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; var p = ( a + b + c ) / 2 ; var area = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; var radius = area / p ; return radius ; } var a = 2 , b = 2 , c = 3 ; document . write ( findRadiusOfIncircle ( a , b , c ) . toFixed ( 6 ) ) ;
function area ( x1 , y1 , z1 , x2 , y2 , z2 ) { let area = Math . sqrt ( Math . pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; area = area / 2 ; return area ; } let x1 = - 2 ; let y1 = 0 ; let z1 = - 5 ; let x2 = 1 ; let y2 = - 2 ; let z2 = - 1 ; let a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) ; document . write ( " " + a ) ;
function trapezoidarea ( r ) { if ( r < 0 ) return - 1 ; var a = ( 3 * Math . sqrt ( 3 ) * Math . pow ( r , 2 ) ) / 4 ; return a ; } var r = 5 ; document . write ( trapezoidarea ( r ) . toFixed ( 3 ) ) ;
function rectanglearea ( r ) { if ( r < 0 ) return - 1 ; var a = r * r ; return a ; } var r = 5 ; document . write ( parseInt ( rectanglearea ( r ) ) ) ;
function maxLines ( n , x1 , y1 , x2 , y2 ) { var s = [ ] ; var slope = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x1 [ i ] === x2 [ i ] ) slope = 2147483647 ; else slope = ( ( ( y2 [ i ] - y1 [ i ] ) * 1.0 ) / ( x2 [ i ] - x1 [ i ] ) ) * 1.0 ; s . push ( slope ) ; } return s . length ; } var n = 2 ; var x1 = [ 1 , 2 ] ; var y1 = [ 1 , 2 ] ; var x2 = [ 2 , 4 ] ; var y2 = [ 2 , 10 ] ; document . write ( maxLines ( n , x1 , y1 , x2 , y2 ) ) ;
function area ( x1 , y1 , z1 , x2 , y2 , z2 ) { area = Math . sqrt ( Math . pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ) ; return area ; } let x1 = 3 ; let y1 = 1 ; let z1 = - 2 ; let x2 = 1 ; let y2 = - 3 ; let z2 = 4 ; a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) ; document . write ( " " ) ; document . write ( a ) ;
function max_intersection ( center , length , k ) { center . sort ( ) ; if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) { return 0 ; } else if ( center [ 2 ] - center [ 0 ] >= 2 * k ) { return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; } else return length ; } let center = [ 1 , 2 , 3 ] ; let L = 1 ; let K = 1 ; document . write ( max_intersection ( center , L , K ) ) ;
function haversine ( lat1 , lon1 , lat2 , lon2 ) { let dLat = ( lat2 - lat1 ) * Math . PI / 180.0 ; let dLon = ( lon2 - lon1 ) * Math . PI / 180.0 ; lat1 = ( lat1 ) * Math . PI / 180.0 ; lat2 = ( lat2 ) * Math . PI / 180.0 ; let a = Math . pow ( Math . sin ( dLat / 2 ) , 2 ) + Math . pow ( Math . sin ( dLon / 2 ) , 2 ) * Math . cos ( lat1 ) * Math . cos ( lat2 ) ; let rad = 6371 ; let c = 2 * Math . asin ( Math . sqrt ( a ) ) ; return rad * c ; } let lat1 = 51.5007 ; let lon1 = 0.1246 ; let lat2 = 40.6892 ; let lon2 = 74.0445 ; document . write ( haversine ( lat1 , lon1 , lat2 , lon2 ) + " " ) ;
function pentatopeNum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) ) / 24 ; } let n = 5 ; document . write ( pentatopeNum ( n ) + " " ) ; n = 11 ; document . write ( pentatopeNum ( n ) ) ;
function heptagonalNumber ( n ) { return parseInt ( ( ( 5 * n * n ) - ( 3 * n ) ) / 2 ) ; } let n = 2 ; document . write ( heptagonalNumber ( n ) + " " ) ; n = 15 ; document . write ( heptagonalNumber ( n ) + " " ) ;
function icosidigonal_num ( n ) { return parseInt ( ( 20 * n * n - 18 * n ) / 2 ) ; } let n = 4 ; document . write ( n + " " + icosidigonal_num ( n ) ) ; document . write ( " " ) ; n = 8 ; document . write ( n + " " + icosidigonal_num ( n ) ) ;
function power ( n ) { if ( n == 1 ) return 2 ; return 2 * power ( n - 1 ) ; } var n = 4 ; document . write ( power ( n ) ) ;
function findPoint ( x1 , y1 , x2 , y2 ) { document . write ( " " + 2 * ( x2 - x1 ) + " " + 2 * ( y2 - y1 ) + " " ) ; } let x1 = 0 , y1 = 0 , x2 = 1 , y2 = 1 ; findPoint ( x1 , y1 , x2 , y2 ) ;
function parallel ( n , a ) { let x = true , y = true ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) x = false ; if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) y = false ; } if ( x ) document . write ( " " + " " ) ; else if ( y ) document . write ( " " + " " ) ; else document . write ( " " + " " + " " ) ; } let a = [ [ 1 , 2 ] , [ 1 , 4 ] , [ 1 , 6 ] , [ 1 , 0 ] ] ; let n = a . length ; parallel ( n , a ) ;
function numberOfSticks ( x ) { return ( 3 * x * ( x + 1 ) ) / 2 ; } document . write ( numberOfSticks ( 7 ) ) ;
function find_Area ( r ) { return ( 2 * r * r ) ; } let r = 3 ; document . write ( " " + find_Area ( r ) ) ;
function checkValidity ( a , b , c ) { if ( a + b <= c a + c <= b b + c <= a ) return false ; else return true ; } let a = 7 , b = 10 , c = 5 ; if ( checkValidity ( a , b , c ) ) document . write ( " " ) ; else document . write ( " " ) ;
let M = 3 ; let N = 3 ; function contribution_height ( current , previous ) { return Math . abs ( current - previous ) ; } function surfaceArea ( A ) { let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { let up = 0 ; let left = 0 ; if ( i > 0 ) up = A [ i - 1 ] [ j ] ; if ( j > 0 ) left = A [ i ] [ j - 1 ] ; ans += contribution_height ( A [ i ] [ j ] , up ) + contribution_height ( A [ i ] [ j ] , left ) ; if ( i == N - 1 ) ans += A [ i ] [ j ] ; if ( j == M - 1 ) ans += A [ i ] [ j ] ; } } ans += N * M * 2 ; return ans ; } let A = [ [ 1 , 3 , 4 ] , [ 2 , 2 , 3 ] , [ 1 , 2 , 4 ] ] ; document . write ( surfaceArea ( A ) ) ;
function area_of_tetrahedron ( side ) { return ( Math . sqrt ( 3 ) * ( side * side ) ) ; } let side = 3 ; document . write ( " " + area_of_tetrahedron ( side ) . toFixed ( 4 ) ) ; < / script
function vol_tetra ( side ) { let volume = ( Math . pow ( side , 3 ) / ( 6 * Math . sqrt ( 2 ) ) ) ; return volume ; } let side = 3 ; let vol = vol_tetra ( side ) ; vol = Math . round ( vol * 100 ) / 100 ; document . write ( vol ) ;
function numberOfWays ( x ) { let dp = Array ( x + 1 ) . fill ( 0 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; } let x = 3 ; document . write ( numberOfWays ( x ) ) ;
function areaCuboid ( l , h , w ) { return ( l * h * w ) ; } function surfaceAreaCuboid ( l , h , w ) { return ( 2 * l * w + 2 * w * h + 2 * l * h ) ; } let l = 1 ; let h = 5 ; let w = 7 ; document . write ( " " + areaCuboid ( l , h , w ) + " " ) ; document . write ( " " + surfaceAreaCuboid ( l , h , w ) + " " ) ;
function circumference ( r ) { let cir = 2 * 3.1415 * r ; return cir ; } let r = 5 ; document . write ( " " + circumference ( r ) ) ;
function cool_line ( x1 , y1 , x2 , y2 , x3 , y3 ) { if ( ( y3 - y2 ) * ( x2 - x1 ) == ( y2 - y1 ) * ( x3 - x2 ) ) document . write ( " " ) ; else document . write ( " " ) ; } var a1 = 1 , a2 = 1 , a3 = 0 , b1 = 1 , b2 = 6 , b3 = 9 ; cool_line ( a1 , b1 , a2 , b2 , a3 , b3 ) ;
function rectCount ( n , m ) { return parseInt ( ( m * n * ( n + 1 ) * ( m + 1 ) ) / 4 , 10 ) ; } let n = 5 , m = 4 ; document . write ( rectCount ( n , m ) ) ;
function countRect ( n ) { let ans = 0 ; for ( let length = 1 ; length <= parseInt ( Math . sqrt ( n ) , 10 ) ; ++ length ) for ( let height = length ; height * length <= n ; ++ height ) ans ++ ; return ans ; } let n = 5 ; document . write ( countRect ( n ) ) ;
let ax = 5 , ay = 0 ; let bx = 1 , by = 1 ; let cx = 2 , cy = 5 ; document . write ( ( ax + ( cx - bx ) ) + " " + ( ay + ( cy - by ) ) ) ;
function bestApproximate ( x , y , n ) { let m , c , sum_x = 0 , sum_y = 0 , sum_xy = 0 , sum_x2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_x += x [ i ] ; sum_y += y [ i ] ; sum_xy += x [ i ] * y [ i ] ; sum_x2 += Math . pow ( x [ i ] , 2 ) ; } m = ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - Math . pow ( sum_x , 2 ) ) ; c = ( sum_y - m * sum_x ) / n ; document . write ( " " + m ) ; document . write ( " " + c ) ; } let x = [ 1 , 2 , 3 , 4 , 5 ] ; let y = [ 14 , 27 , 40 , 55 , 68 ] ; let n = x . length ; bestApproximate ( x , y , n ) ;
var size = 4 ; function checkStar ( mat ) { var vertexD1 = 0 , vertexDn_1 = 0 ; if ( size == 1 ) return ( mat [ 0 ] [ 0 ] == 0 ) ; if ( size == 2 ) return ( mat [ 0 ] [ 0 ] == 0 && mat [ 0 ] [ 1 ] == 1 && mat [ 1 ] [ 0 ] == 1 && mat [ 1 ] [ 1 ] == 0 ) ; for ( var i = 0 ; i < size ; i ++ ) { var degreeI = 0 ; for ( var j = 0 ; j < size ; j ++ ) if ( mat [ i ] [ j ] ) degreeI ++ ; if ( degreeI == 1 ) vertexD1 ++ ; else if ( degreeI == size - 1 ) vertexDn_1 ++ ; } return ( vertexD1 == ( size - 1 ) && vertexDn_1 == 1 ) ; } var mat = [ [ 0 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] ; checkStar ( mat ) ? document . write ( " " ) : document . write ( " " ) ;
function getMinSteps ( n ) { let table = new Array ( n + 1 ) ; table . fill ( 0 ) ; table [ 1 ] = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ! ( i % 2 ) && ( i % 3 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , table [ i / 2 ] ) ; else if ( ! ( i % 3 ) && ( i % 2 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , table [ i / 3 ] ) ; else if ( ! ( i % 2 ) && ! ( i % 3 ) ) table [ i ] = 1 + Math . min ( table [ i - 1 ] , Math . min ( table [ i / 2 ] , table [ i / 3 ] ) ) ; else table [ i ] = 1 + table [ i - 1 ] ; } return table [ n ] + 1 ; } ' ' ' ' ' ' let n = 10 ; document . write ( getMinSteps ( n ) ) ;
function isVowel ( c ) { let vowel = " " ; for ( let i = 0 ; i < vowel . length ; ++ i ) { if ( vowel [ i ] == c ) { return true ; } } return false ; } function printRLE ( str , typed ) { let n = str . length , m = typed . length ; let j = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] != typed [ j ] ) { return false ; } if ( isVowel ( str [ i ] ) == false ) { j ++ ; continue ; } let count1 = 1 ; while ( i < n - 1 && str [ i ] == str [ i + 1 ] ) { count1 ++ ; i ++ ; } let count2 = 1 ; while ( j < m - 1 && typed [ j ] == str [ i ] ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) { return false ; } } return true ; } let name = " " , typed = " " ; if ( printRLE ( name , typed ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function isInorder ( arr , n ) { if ( n == 0 n == 1 ) { return true ; } for ( i = 1 ; i < n ; i ++ ) { if ( arr [ i - 1 ] > arr [ i ] ) { return false ; } } return true ; } var arr = [ 19 , 23 , 25 , 30 , 45 ] ; var n = arr . length ; if ( isInorder ( arr , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function printSorted ( arr , start , end ) { if ( start > end ) return ; printSorted ( arr , start * 2 + 1 , end ) ; document . write ( arr [ start ] + " " ) ; printSorted ( arr , start * 2 + 2 , end ) ; } var arr = [ 4 , 2 , 5 , 1 , 3 ] ; printSorted ( arr , 0 , arr . length - 1 ) ;
let i = 0 ; function isLeaf ( pre , n , min , max ) { if ( i >= n ) { return false ; } if ( pre [ i ] > min && pre [ i ] < max ) { i ++ ; let left = isLeaf ( pre , n , min , pre [ i - 1 ] ) ; let right = isLeaf ( pre , n , pre [ i - 1 ] , max ) ; if ( ! left && ! right ) { document . write ( pre [ i - 1 ] + " " ) ; } return true ; } return false ; } function printLeaves ( preorder , n ) { isLeaf ( preorder , n , Number . MIN_VALUE , Number . MAX_VALUE ) ; } let preorder = [ 890 , 325 , 290 , 530 , 965 ] ; let n = preorder . length ; printLeaves ( preorder , n ) ;
function pairs ( arr , n , k ) { var smallest = 1000000000 ; var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) { if ( Math . abs ( arr [ i ] + arr [ j ] - k ) < smallest ) { smallest = Math . abs ( arr [ i ] + arr [ j ] - k ) ; count = 1 ; } else if ( Math . abs ( arr [ i ] + arr [ j ] - k ) == smallest ) count ++ ; } document . write ( " " + smallest + " " ) ; document . write ( " " + count + " " ) ; } var arr = [ 3 , 5 , 7 , 5 , 1 , 9 , 9 ] ; var k = 12 ; var n = arr . length ; pairs ( arr , n , k ) ;
var a = [ 5 , 1 , 14 , 4 , 15 , 9 , 7 , 20 , 11 ] ; var key = 20 ; var arraySize = a . length ; var count = 0 ; for ( i = 0 ; i < arraySize ; i ++ ) { if ( a [ i ] <= key ) { count += 1 ; } } document . write ( " " + key + " " + ( count - 1 ) ) ;
var MAX = 100 ; function middlesum ( mat , n ) { var row_sum = 0 , col_sum = 0 ; for ( i = 0 ; i < n ; i ++ ) row_sum += mat [ parseInt ( n / 2 ) ] [ i ] ; document . write ( " " + row_sum + " " ) ; for ( i = 0 ; i < n ; i ++ ) col_sum += mat [ i ] [ parseInt ( n / 2 ) ] ; document . write ( " " + col_sum ) ; } var mat = [ [ 2 , 5 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 6 , 9 ] ] ; middlesum ( mat , 3 ) ;
var M = 3 ; var N = 3 ; function rotateMatrix ( matrix , k ) { var temp = Array ( M ) . fill ( 0 ) ; k = k % M ; for ( i = 0 ; i < N ; i ++ ) { for ( t = 0 ; t < M - k ; t ++ ) temp [ t ] = matrix [ i ] [ t ] ; for ( j = M - k ; j < M ; j ++ ) matrix [ i ] [ j - M + k ] = matrix [ i ] [ j ] ; for ( j = k ; j < M ; j ++ ) matrix [ i ] [ j ] = temp [ j - k ] ; } } function displayMatrix ( matrix ) { for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) document . write ( matrix [ i ] [ j ] + " " ) ; document . write ( " " ) ; } } var matrix = [ [ 12 , 23 , 34 ] , [ 45 , 56 , 67 ] , [ 78 , 89 , 91 ] ] ; var k = 2 ; rotateMatrix ( matrix , k ) ; displayMatrix ( matrix ) ;
function interchangeFirstLast ( m ) { let rows = m . length ; for ( let i = 0 ; i < m [ 0 ] . length ; i ++ ) { let t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } let m = [ [ 8 , 9 , 7 , 6 ] , [ 4 , 7 , 6 , 5 ] , [ 3 , 2 , 1 , 8 ] , [ 9 , 9 , 7 , 7 ] ] interchangeFirstLast ( m ) ; for ( let i = 0 ; i < m . length ; i ++ ) { for ( let j = 0 ; j < m [ 0 ] . length ; j ++ ) document . write ( m [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
let n = 3 function checkMarkov ( m ) { for ( let i = 0 ; i < n ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < n ; j ++ ) sum = sum + m [ i ] [ j ] ; if ( sum != 1 ) return false ; } return true ; } let m = [ [ 0 , 0 , 1 ] , [ 0.5 , 0 , 0.5 ] , [ 1 , 0 , 0 ] ] ; if ( checkMarkov ( m ) ) document . write ( " " ) ; else document . write ( " " ) ;
let N = 4 ; function isDiagonalMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; return true ; } let mat = [ [ 4 , 0 , 0 , 0 ] , [ 0 , 7 , 0 , 0 ] , [ 0 , 0 , 5 , 0 ] , [ 0 , 0 , 0 , 1 ] ] ; if ( isDiagonalMatrix ( mat ) ) document . write ( " " ) ; else document . write ( " " ) ;
let N = 4 ; function isScalarMatrix ( mat ) { for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( ( i != j ) && ( mat [ i ] [ j ] != 0 ) ) return false ; for ( let i = 0 ; i < N - 1 ; i ++ ) if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) return false ; return true ; } let mat = [ [ 2 , 0 , 0 , 0 ] , [ 0 , 2 , 0 , 0 ] , [ 0 , 0 , 2 , 0 ] , [ 0 , 0 , 0 , 2 ] ] ; if ( isScalarMatrix ( mat ) ) document . write ( " " ) ; else document . write ( " " ) ;
var N = 3 function isMagicSquare ( mat ) { var sum = 0 , sum2 = 0 ; for ( var i = 0 ; i < N ; i ++ ) sum = sum + mat [ i ] [ i ] ; for ( var i = 0 ; i < N ; i ++ ) sum2 = sum2 + mat [ i ] [ N - 1 - i ] ; if ( sum != sum2 ) return false ; for ( var i = 0 ; i < N ; i ++ ) { var rowSum = 0 ; for ( var j = 0 ; j < N ; j ++ ) rowSum += mat [ i ] [ j ] ; if ( rowSum != sum ) return false ; } for ( var i = 0 ; i < N ; i ++ ) { var colSum = 0 ; for ( var j = 0 ; j < N ; j ++ ) colSum += mat [ j ] [ i ] ; if ( sum != colSum ) return false ; } return true ; } var mat = [ [ 2 , 7 , 6 ] , [ 9 , 5 , 1 ] , [ 4 , 3 , 8 ] ] ; if ( isMagicSquare ( mat ) ) document . write ( " " ) ; else document . write ( " " ) ;
var SIZE = 10 ; function subCount ( arr , n , k ) { var mod = Array ( k ) . fill ( 0 ) ; var cumSum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { cumSum += arr [ i ] ; mod [ ( ( cumSum % k ) + k ) % k ] ++ ; } var result = 0 ; for ( var i = 0 ; i < k ; i ++ ) if ( mod [ i ] > 1 ) result += ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ; result += mod [ 0 ] ; return result ; } function countSubmatrix ( mat , n , k ) { var tot_count = 0 ; var left , right , i ; var temp = Array ( n ) ; for ( left = 0 ; left < n ; left ++ ) { temp = Array ( n ) . fill ( 0 ) ; for ( right = left ; right < n ; right ++ ) { for ( i = 0 ; i < n ; ++ i ) temp [ i ] += mat [ i ] [ right ] ; tot_count += subCount ( temp , n , k ) ; } } return tot_count ; } var mat = [ [ 5 , - 1 , 6 ] , [ - 2 , 3 , 8 ] , [ 7 , 4 , - 9 ] ] ; var n = 3 , k = 4 ; document . write ( " " + countSubmatrix ( mat , n , k ) ) ;
function find ( n , k ) { if ( n + 1 >= k ) return ( k - 1 ) ; else return ( 2 * n + 1 - k ) ; } var n = 4 , k = 7 ; var freq = find ( n , k ) ; if ( freq < 0 ) document . write ( " " ) ; else document . write ( " " + k + " " + freq + " " ) ;
function ZigZag ( rows , columns , numbers ) { let k = 0 ; let arr = new Array ( rows ) ; for ( let i = 0 ; i < rows ; i ++ ) { arr [ i ] = new Array ( rows ) ; for ( let j = 0 ; j < columns ; j ++ ) { arr [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < rows ; i ++ ) { if ( i % 2 == 0 ) { for ( let j = 0 ; j < columns && numbers [ k ] > 0 ; j ++ ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } else { for ( let j = columns - 1 ; j >= 0 && numbers [ k ] > 0 ; j -- ) { arr [ i ] [ j ] = k + 1 ; numbers [ k ] -- ; if ( numbers [ k ] == 0 ) k ++ ; } } } for ( let i = 0 ; i < rows ; i ++ ) { for ( let j = 0 ; j < columns ; j ++ ) document . write ( arr [ i ] [ j ] + " " ) ; document . write ( " " ) ; } } let rows = 4 ; let columns = 5 ; let Numbers = [ 3 , 4 , 2 , 2 , 3 , 1 , 5 ] ; ZigZag ( rows , columns , Numbers ) ;
function numberofPosition ( n , k , x , y , obstPosx , obstPosy ) { let d11 , d12 , d21 , d22 , r1 , r2 , c1 , c2 ; d11 = Math . min ( x - 1 , y - 1 ) ; d12 = Math . min ( n - x , n - y ) ; d21 = Math . min ( n - x , y - 1 ) ; d22 = Math . min ( x - 1 , n - y ) ; r1 = y - 1 ; r2 = n - y ; c1 = x - 1 ; c2 = n - x ; for ( let i = 0 ; i < k ; i ++ ) { if ( x > obstPosx [ i ] && y > obstPosy [ i ] && x - obstPosx [ i ] == y - obstPosy [ i ] ) d11 = Math . min ( d11 , x - obstPosx [ i ] - 1 ) ; if ( obstPosx [ i ] > x && obstPosy [ i ] > y && obstPosx [ i ] - x == obstPosy [ i ] - y ) d12 = Math . min ( d12 , obstPosx [ i ] - x - 1 ) ; if ( obstPosx [ i ] > x && y > obstPosy [ i ] && obstPosx [ i ] - x == y - obstPosy [ i ] ) d21 = Math . min ( d21 , obstPosx [ i ] - x - 1 ) ; if ( x > obstPosx [ i ] && obstPosy [ i ] > y && x - obstPosx [ i ] == obstPosy [ i ] - y ) d22 = Math . min ( d22 , x - obstPosx [ i ] - 1 ) ; if ( x == obstPosx [ i ] && obstPosy [ i ] < y ) r1 = min ( r1 , y - obstPosy [ i ] - 1 ) ; if ( x == obstPosx [ i ] && obstPosy [ i ] > y ) r2 = Math . min ( r2 , obstPosy [ i ] - y - 1 ) ; if ( y == obstPosy [ i ] && obstPosx [ i ] < x ) c1 = Math . min ( c1 , x - obstPosx [ i ] - 1 ) ; if ( y == obstPosy [ i ] && obstPosx [ i ] > x ) c2 = Math . min ( c2 , obstPosx [ i ] - x - 1 ) ; } return d11 + d12 + d21 + d22 + r1 + r2 + c1 + c2 ; } let n = 8 ; let k = 1 ; let Qposx = 4 ; let Qposy = 4 ; let obstPosx = [ 3 ] ; let obstPosy = [ 5 ] ; document . write ( numberofPosition ( n , k , Qposx , Qposy , obstPosx , obstPosy ) ) ;
let n = 5 ; function FindMaxProduct ( arr , n ) { let max = 0 , result ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 3 ) >= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ; if ( max < result ) max = result ; } if ( ( i - 3 ) >= 0 && ( j - 1 ) <= 0 ) { result = arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ; if ( max < result ) max = result ; } } } return max ; } let arr = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 6 , 7 , 8 , 9 , 1 ] , [ 2 , 3 , 4 , 5 , 6 ] , [ 7 , 8 , 9 , 1 , 0 ] , [ 9 , 6 , 4 , 2 , 3 ] ] ; document . write ( FindMaxProduct ( arr , n ) ) ;
/ *JavaScript Program to find minimum flip required to make Binary Matrix symmetric along main diagonal function minimumflip ( mat , n ) { let transpose = new Array ( n ) ; for ( var i = 0 ; i < transpose . length ; i ++ ) { transpose [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) transpose [ i ] [ j ] = mat [ j ] [ i ] ; let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( transpose [ i ] [ j ] != mat [ i ] [ j ] ) flip ++ ; return flip / 2 ; } let n = 3 ; let mat = [ [ 0 , 0 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] ] ; document . write ( minimumflip ( mat , n ) ) ;
function minimumflip ( mat , n ) { let flip = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( mat [ i ] [ j ] != mat [ j ] [ i ] ) flip ++ ; return flip ; } let n = 3 ; let mat = [ [ 0 , 0 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] ] ; document . write ( minimumflip ( mat , n ) ) ;
let MAX = 100 ; function freq ( ar , m , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < m ; ++ i ) { for ( let j = 0 ; j < n ; ++ j ) { if ( ( ar [ i ] [ j ] % 2 ) == 0 ) ++ even ; else ++ odd ; } } document . write ( " " + odd + " " ) ; document . write ( " " + even + " " ) ; } let m = 3 , n = 3 ; let array = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; freq ( array , m , n ) ;
const MAX = 100 ; function HalfDiagonalSums ( mat , n ) { let diag1_left = 0 , diag1_right = 0 ; let diag2_left = 0 , diag2_right = 0 ; for ( let i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { if ( i < parseInt ( n / 2 ) ) { diag1_left += mat [ i ] [ i ] ; diag2_left += mat [ j ] [ i ] ; } else if ( i > parseInt ( n / 2 ) ) { diag1_right += mat [ i ] [ i ] ; diag2_right += mat [ j ] [ i ] ; } } return ( diag1_left == diag2_right && diag2_right == diag2_left && diag1_right == diag2_left && diag2_right == mat [ parseInt ( n / 2 ) ] [ parseInt ( n / 2 ) ] ) ; } let a = [ [ 2 , 9 , 1 , 4 , - 2 ] , [ 6 , 7 , 2 , 11 , 4 ] , [ 4 , 2 , 9 , 2 , 4 ] , [ 1 , 9 , 2 , 4 , 4 ] , [ 0 , 2 , 4 , 2 , 5 ] ] ; document . write ( HalfDiagonalSums ( a , 5 ) ? " " : " " ) ;
function Identity ( num ) { var row ; var col ; for ( row = 0 ; row < num ; row ++ ) { for ( col = 0 ; col < num ; col ++ ) { if ( row == col ) document . write ( 1 + " " ) ; else document . write ( 0 + " " ) ; } document . write ( " " + " " ) ; } return 0 ; } size = 5 ; Identity ( size ) ;
let MAX = 100 ; function isIdentity ( mat , N ) { for ( let row = 0 ; row < N ; row ++ ) { for ( let col = 0 ; col < N ; col ++ ) { if ( row == col && mat [ row ] [ col ] != 1 ) return false ; else if ( row != col && mat [ row ] [ col ] != 0 ) return false ; } } return true ; } let N = 4 ; let mat = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 1 ] ] ; if ( isIdentity ( mat , N ) ) document . write ( " " ) ; else document . write ( " " ) ;
let mod = 100000007 ; function modPower ( a , t , mod ) { let now = a , ret = 1 ; while ( t > 0 ) { if ( t % 2 == 1 ) ret = now * ( ret % mod ) ; now = now * ( now % mod ) ; t >>= 1 ; } return ret ; } function countWays ( n , m , k ) { if ( n == 1 m == 1 ) return 1 ; else if ( ( n + m ) % 2 == 1 && k == - 1 ) return 0 ; return ( modPower ( modPower ( 2 , n - 1 , mod ) , m - 1 , mod ) % mod ) ; } let n = 2 , m = 7 , k = 1 ; document . write ( countWays ( n , m , k ) ) ;
let MAX = 100 ; function imageSwap ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j <= i ; j ++ ) mat [ i ] [ j ] = mat [ i ] [ j ] + mat [ j ] [ i ] - ( mat [ j ] [ i ] = mat [ i ] [ j ] ) ; } function printMatrix ( mat , n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) document . write ( mat [ i ] [ j ] + " " ) ; document . write ( " " ) ; } } let mat = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 ] ] ; let n = 4 ; imageSwap ( mat , n ) ; printMatrix ( mat , n ) ;
function search ( mat , n , x ) { let i = 0 , j = n - 1 ; while ( i < n && j >= 0 ) { if ( mat [ i ] [ j ] == x ) { document . write ( " " + i + " " + j ) ; return ; } if ( mat [ i ] [ j ] > x ) j -- ; else i ++ ; } document . write ( " " ) ; return ; } let mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] ] ; search ( mat , 4 , 29 ) ;
function fill0X ( m , n ) { let i , k = 0 , l = 0 ; let r = m , c = n ; let a = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { a [ i ] = new Array ( n ) ; } let x = ' ' ; while ( k < m && l < n ) { for ( i = l ; i < n ; ++ i ) { a [ k ] [ i ] = x ; } k ++ ; for ( i = k ; i < m ; ++ i ) { a [ i ] [ n - 1 ] = x ; } n -- ; if ( k < m ) { for ( i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = x ; m -- ; } if ( l < n ) { for ( i = m - 1 ; i >= k ; -- i ) { a [ i ] [ l ] = x ; } l ++ ; } x = ( x == ' ' ) ? ' ' : ' ' ; } for ( i = 0 ; i < r ; i ++ ) { for ( let j = 0 ; j < c ; j ++ ) { document . write ( a [ i ] [ j ] + " " ) ; } document . write ( " " ) ; } } document . write ( " " ) ; fill0X ( 5 , 6 ) ; document . write ( " " ) ; fill0X ( 4 , 4 ) ; document . write ( " " ) ; fill0X ( 3 , 4 ) ;
let SIZE = 100 ; function calculateEnergy ( mat , n ) { let i_des , j_des , q ; let tot_energy = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { q = Math . floor ( mat [ i ] [ j ] / n ) ; i_des = q ; j_des = mat [ i ] [ j ] - ( n * q ) ; tot_energy += Math . abs ( i_des - i ) + Math . abs ( j_des - j ) ; } } return tot_energy ; } let mat = [ [ 4 , 7 , 0 , 3 ] , [ 8 , 5 , 6 , 1 ] , [ 9 , 11 , 10 , 2 ] , [ 15 , 13 , 14 , 12 ] ] ; let n = 4 ; document . write ( " " + calculateEnergy ( mat , n ) + " " ) ;
let MAX = 100 ; function isUnique ( mat , i , j , n , m ) { let sumrow = 0 ; for ( let k = 0 ; k < m ; k ++ ) { sumrow += mat [ i ] [ k ] ; if ( sumrow > 1 ) return false ; } let sumcol = 0 ; for ( let k = 0 ; k < n ; k ++ ) { sumcol += mat [ k ] [ j ] ; if ( sumcol > 1 ) return false ; } return true ; } function countUnique ( mat , n , m ) { let uniquecount = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < m ; j ++ ) if ( mat [ i ] [ j ] != 0 && isUnique ( mat , i , j , n , m ) ) uniquecount ++ ; return uniquecount ; } let mat = [ [ 0 , 1 , 0 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] ] ; document . write ( countUnique ( mat , 3 , 4 ) ) ;
for ( let i = 0 ; i < m ; ++ i ) for ( let j = 0 ; j < n ; ++ j ) if ( array [ i ] [ j ] == 0 ) ++ counter ; return ( counter > parseInt ( ( m * n ) / 2 ) , 10 ) ; } let array = [ [ 1 , 0 , 3 ] , [ 0 , 0 , 4 ] , [ 6 , 0 , 0 ] ] ; let m = 3 , n = 3 ; if ( isSparse ( array , m , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
let MAX = 100 ; function countCommon ( mat , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] ) res ++ ; return res ; } let mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; document . write ( countCommon ( mat , 3 ) ) ;
function areSumSame ( a , n , m ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 = 0 ; sum2 = 0 ; for ( let j = 0 ; j < m ; j ++ ) { sum1 += a [ i ] [ j ] ; sum2 += a [ j ] [ i ] ; } if ( sum1 == sum2 ) return true ; } return false ; } let n = 4 ; let m = 4 ; let M = [ [ 1 , 2 , 3 , 4 ] , [ 9 , 5 , 3 , 1 ] , [ 0 , 3 , 5 , 6 ] , [ 0 , 4 , 5 , 6 ] ] ; if ( areSumSame ( M , n , m ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
var N = 4 function findMax ( arr ) { var row = 0 , i , j ; for ( i = 0 , j = N - 1 ; i < N ; i ++ ) { while ( arr [ i ] [ j ] == 1 && j >= 0 ) { row = i ; j -- ; } } document . write ( " " + ( row + 1 ) ) ; document . write ( " " + ( N - 1 - j ) ) ; } var arr = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 1 , 1 , 1 ] ] ; findMax ( arr ) ;
let n = 4 ; let m = 4 ; function findPossibleMoves ( mat , p , q ) { let X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] ; let Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] ; let count = 0 ; for ( let i = 0 ; i < 8 ; i ++ ) { let x = p + X [ i ] ; let y = q + Y [ i ] ; if ( x >= 0 && y >= 0 && x < n && y < m && mat [ x ] [ y ] == 0 ) count ++ ; } return count ; } let mat = [ [ 1 , 0 , 1 , 0 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 1 ] ] ; let p = 2 , q = 2 ; document . write ( findPossibleMoves ( mat , p , q ) ) ;
const MAX = 100 ; void printDiagonalSums ( mat , n ) { let principal = 0 , secondary = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) principal += mat [ i ] [ j ] ; if ( ( i + j ) == ( n - 1 ) ) secondary += mat [ i ] [ j ] ; } } document . write ( " " + principal + " " ) ; document . write ( " " + secondary + " " ) ; } let a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] ; printDiagonalSums ( a , 4 ) ;
function printDiagonalSums ( mat , n ) { let principal = 0 , secondary = 0 ; for ( let i = 0 ; i < n ; i ++ ) { principal += mat [ i ] [ i ] ; secondary += mat [ i ] [ n - i - 1 ] ; } document . write ( " " + principal + " " ) ; document . write ( " " + secondary ) ; } let a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] ; printDiagonalSums ( a , 4 ) ;
function getBoundarySum ( a , m , n ) { let sum = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == 0 ) sum += a [ i ] [ j ] ; else if ( i == m - 1 ) sum += a [ i ] [ j ] ; else if ( j == 0 ) sum += a [ i ] [ j ] ; else if ( j == n - 1 ) sum += a [ i ] [ j ] ; } } return sum ; } let a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] ; let sum = getBoundarySum ( a , 4 , 4 ) ; document . write ( " " + " " + sum ) ;
const MAX = 100 ; function printSpiral ( mat , r , c ) { let i , a = 0 , b = 2 ; let low_row = ( 0 > a ) ? 0 : a ; let low_column = ( 0 > b ) ? 0 : b - 1 ; let high_row = ( ( a + 1 ) >= r ) ? r - 1 : a + 1 ; let high_column = ( ( b + 1 ) >= c ) ? c - 1 : b + 1 ; while ( ( low_row > 0 - r && low_column > 0 - c ) ) { for ( i = low_column + 1 ; i <= high_column && i < c && low_row >= 0 ; ++ i ) document . write ( mat [ low_row ] [ i ] + " " ) ; low_row -= 1 ; for ( i = low_row + 2 ; i <= high_row && i < r && high_column < c ; ++ i ) document . write ( mat [ i ] [ high_column ] + " " ) ; high_column += 1 ; for ( i = high_column - 2 ; i >= low_column && i >= 0 && high_row < r ; -- i ) document . write ( mat [ high_row ] [ i ] + " " ) ; high_row += 1 ; for ( i = high_row - 2 ; i > low_row && i >= 0 && low_column >= 0 ; -- i ) document . write ( mat [ i ] [ low_column ] + " " ) ; low_column -= 1 ; } document . write ( " " ) ; } let mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; let r = 3 , c = 3 ; printSpiral ( mat , r , c ) ;
function difference ( arr , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) d1 += arr [ i ] [ j ] ; if ( i == n - j - 1 ) d2 += arr [ i ] [ j ] ; } } return Math . abs ( d1 - d2 ) ; } let n = 3 ; let arr = [ [ 11 , 2 , 4 ] , [ 4 , 5 , 6 ] , [ 10 , 8 , - 12 ] ] ; document . write ( difference ( arr , n ) ) ;
function difference ( arr , n ) { let d1 = 0 , d2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { d1 += arr [ i ] [ i ] ; d2 += arr [ i ] [ n - i - 1 ] ; } return Math . abs ( d1 - d2 ) ; } let n = 3 ; let arr = [ [ 11 , 2 , 4 ] , [ 4 , 5 , 6 ] , [ 10 , 8 , - 12 ] ] ; document . write ( difference ( arr , n ) ) ;
const MAX = 100 ; function spiralFill ( m , n , a ) { let val = 1 ; let k = 0 , l = 0 ; while ( k < m && l < n ) { for ( let i = l ; i < n ; ++ i ) a [ k ] [ i ] = val ++ ; k ++ ; for ( let i = k ; i < m ; ++ i ) a [ i ] [ n - 1 ] = val ++ ; n -- ; if ( k < m ) { for ( let i = n - 1 ; i >= l ; -- i ) a [ m - 1 ] [ i ] = val ++ ; m -- ; } if ( l < n ) { for ( let i = m - 1 ; i >= k ; -- i ) a [ i ] [ l ] = val ++ ; l ++ ; } } } let m = 4 , n = 4 ; let a = Array . from ( Array ( MAX ) , ( ) => new Array ( MAX ) ) ; spiralFill ( m , n , a ) ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) document . write ( a [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
let MAX = 100 ; function maxMin ( arr , n ) { let min = + 2147483647 ; let max = - 2147483648 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j <= n / 2 ; j ++ ) { if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) { if ( min > arr [ i ] [ n - j - 1 ] ) min = arr [ i ] [ n - j - 1 ] ; if ( max < arr [ i ] [ j ] ) max = arr [ i ] [ j ] ; } else { if ( min > arr [ i ] [ j ] ) min = arr [ i ] [ j ] ; if ( max < arr [ i ] [ n - j - 1 ] ) max = arr [ i ] [ n - j - 1 ] ; } } } document . write ( " " + max + " " + min ) ; } let arr = [ [ 5 , 9 , 11 ] , [ 25 , 0 , 14 ] , [ 21 , 6 , 4 ] ] ; maxMin ( arr , 3 ) ;
let N = 5 ; let M = 5 ; function minOperation ( arr ) { let ans = 0 ; for ( let i = N - 1 ; i >= 0 ; i -- ) { for ( let j = M - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] [ j ] == false ) { ans ++ ; for ( let k = 0 ; k <= i ; k ++ ) { for ( let h = 0 ; h <= j ; h ++ ) { if ( arr [ k ] [ h ] == true ) { arr [ k ] [ h ] = false ; } else { arr [ k ] [ h ] = true ; } } } } } } return ans ; } let mat = [ [ 0 , 0 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] ] document . write ( minOperation ( mat ) )
function findSum ( n ) { let ans = 0 , temp = 0 , num ; for ( let i = 1 ; i <= n && temp < n ; i ++ ) { temp = i - 1 ; num = 1 ; while ( temp < n ) { if ( temp + i <= n ) ans += ( i * num ) ; else ans += ( ( n - temp ) * num ) ; temp += i ; num ++ ; } } return ans ; } let N = 2 ; document . write ( findSum ( N ) ) ;
function printCoils ( n ) { let m = 8 * n * n ; let coil1 = new Array ( m ) ; coil1 . fill ( 0 ) ; coil1 [ 0 ] = 8 * n * n + 2 * n ; let curr = coil1 [ 0 ] ; let nflg = 1 , step = 2 ; let index = 1 ; while ( index < m ) { for ( let i = 0 ; i < step ; i ++ ) { curr = coil1 [ index ++ ] = ( curr - 4 * n * nflg ) ; if ( index >= m ) break ; } if ( index >= m ) break ; for ( let i = 0 ; i < step ; i ++ ) { curr = coil1 [ index ++ ] = curr + nflg ; if ( index >= m ) break ; } nflg = nflg * ( - 1 ) ; step += 2 ; } let coil2 = new Array ( m ) ; coil2 . fill ( 0 ) ; for ( let i = 0 ; i < 8 * n * n ; i ++ ) coil2 [ i ] = 16 * n * n + 1 - coil1 [ i ] ; document . write ( " " ) ; for ( let i = 0 ; i < 8 * n * n ; i ++ ) document . write ( coil1 [ i ] + " " ) ; document . write ( " " + " " ) ; for ( let i = 0 ; i < 8 * n * n ; i ++ ) document . write ( coil2 [ i ] + " " ) ; } let n = 1 ; printCoils ( n ) ;
function findSum ( n ) { let arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { arr [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) arr [ i ] [ j ] = Math . abs ( i - j ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) sum += arr [ i ] [ j ] ; return sum ; } let n = 3 ; document . write ( findSum ( n ) ) ;
function findSum ( n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += i * ( n - i ) ; return 2 * sum ; } let n = 3 ; document . write ( findSum ( n ) ) ;
function findSum ( n ) { n -- ; let sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; } let n = 3 ; document . write ( findSum ( n ) ) ;
function spiralDiaSum ( n ) { if ( n == 1 ) return 1 ; return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) ; } let n = 7 ; document . write ( spiralDiaSum ( n ) ) ;
let R = 3 ; let C = 5 ; function numofneighbour ( mat , i , j ) { let count = 0 ; if ( i > 0 && mat [ i - 1 ] [ j ] == 1 ) count ++ ; if ( j > 0 && mat [ i ] [ j - 1 ] == 1 ) count ++ ; if ( i < R - 1 && mat [ i + 1 ] [ j ] == 1 ) count ++ ; if ( j < C - 1 && mat [ i ] [ j + 1 ] == 1 ) count ++ ; return count ; } function findperimeter ( mat ) { let perimeter = 0 ; for ( let i = 0 ; i < R ; i ++ ) for ( let j = 0 ; j < C ; j ++ ) if ( mat [ i ] [ j ] == 1 ) perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; return perimeter ; } let mat = [ [ 0 , 1 , 0 , 0 , 0 ] , [ 1 , 1 , 1 , 0 , 0 ] , [ 1 , 0 , 0 , 0 , 0 ] ] ; document . write ( findperimeter ( mat ) ) ;
function printMatrixDiagonal ( arr , len ) { let i = 0 , j = 0 ; let isUp = true ; for ( let k = 0 ; k < len * len ; ) { if ( isUp ) { for ( ; i >= 0 && j < len ; i -- , j ++ ) { document . write ( arr [ i ] [ j ] + ' ' ) ; k ++ ; } if ( i < 0 && j < len ) i = 0 ; if ( j === len ) i = i + 2 , j -- ; } else { for ( ; j >= 0 && i < len ; i ++ , j -- ) { document . write ( arr [ i ] [ j ] + ' ' ) ; k ++ ; } if ( j < 0 && i < len ) j = 0 ; if ( i === len ) j = j + 2 , i -- ; } isUp = ! isUp } } let arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; let arrLength = arr . length ; printMatrixDiagonal ( arr , arrLength ) ;
function maxRowDiff ( mat , m , n ) { let rowSum = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { let sum = 0 ; for ( let j = 0 ; j < n ; j ++ ) sum += mat [ i ] [ j ] ; rowSum [ i ] = sum ; } let max_diff = rowSum [ 1 ] - rowSum [ 0 ] ; let min_element = rowSum [ 0 ] ; for ( let i = 1 ; i < m ; i ++ ) { if ( rowSum [ i ] - min_element > max_diff ) max_diff = rowSum [ i ] - min_element ; if ( rowSum [ i ] < min_element ) min_element = rowSum [ i ] ; } return max_diff ; } let m = 5 , n = 4 ; let mat = [ [ - 1 , 2 , 3 , 4 ] , [ 5 , 3 , - 2 , 1 ] , [ 6 , 7 , 2 , - 3 ] , [ 2 , 9 , 1 , 4 ] , [ 2 , 1 , - 2 , 0 ] ] ; document . write ( maxRowDiff ( mat , m , n ) ) ;
let MAX = 100 ; function sortedCount ( mat , r , c ) { let result = 0 ; for ( let i = 0 ; i < r ; i ++ ) { let j ; for ( j = 0 ; j < c - 1 ; j ++ ) if ( mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] ) break ; if ( j == c - 1 ) result ++ ; } for ( let i = 0 ; i < r ; i ++ ) { let j ; for ( j = c - 1 ; j > 0 ; j -- ) if ( mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] ) break ; if ( c > 1 && j == 0 ) result ++ ; } return result ; } let m = 4 , n = 5 ; let mat = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 4 , 3 , 1 , 2 , 6 ] , [ 8 , 7 , 6 , 5 , 4 ] , [ 5 , 7 , 8 , 9 , 10 ] ] document . write ( sortedCount ( mat , m , n ) )
const MAX = 1000 ; function maxXOR ( mat , N ) { let r_xor , c_xor ; let max_xor = 0 ; for ( let i = 0 ; i < N ; i ++ ) { r_xor = 0 , c_xor = 0 ; for ( let j = 0 ; j < N ; j ++ ) { r_xor = r_xor ^ mat [ i ] [ j ] ; c_xor = c_xor ^ mat [ j ] [ i ] ; } if ( max_xor < Math . max ( r_xor , c_xor ) ) max_xor = Math . max ( r_xor , c_xor ) ; } return max_xor ; } let N = 3 ; let mat = [ [ 1 , 5 , 4 ] , [ 3 , 7 , 2 ] , [ 5 , 9 , 10 ] ] ; document . write ( " " + maxXOR ( mat , N ) ) ;
function direction ( R , C ) { if ( R != C && R % 2 == 0 && C % 2 != 0 && R < C ) { document . write ( " " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R > C ) { document . write ( " " ) ; return ; } if ( R == C && R % 2 != 0 && C % 2 != 0 ) { document . write ( " " ) ; return ; } if ( R == C && R % 2 == 0 && C % 2 == 0 ) { document . write ( " " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R < C ) { document . write ( " " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 != 0 && R > C ) { document . write ( " " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R < C ) { document . write ( " " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 == 0 && R > C ) { document . write ( " " ) ; return ; } if ( R != C && R % 2 == 0 && C % 2 != 0 && R > C ) { document . write ( " " ) ; return ; } if ( R != C && R % 2 != 0 && C % 2 == 0 && R < C ) { document . write ( " " ) ; return ; } } let R = 3 , C = 1 ; direction ( R , C ) ;
let N = 5 ; let M = 4 ; function checkDiagonal ( mat , i , j ) { let res = mat [ i ] [ j ] ; while ( ++ i < N && ++ j < M ) { if ( mat [ i ] [ j ] != res ) return false ; } return true ; } function isToepliz ( mat ) { for ( let i = 0 ; i < M ; i ++ ) { if ( ! checkDiagonal ( mat , 0 , i ) ) return false ; } for ( let i = 1 ; i < N ; i ++ ) { if ( ! checkDiagonal ( mat , i , 0 ) ) return false ; } return true ; } let mat = [ [ 6 , 7 , 8 , 9 ] , [ 4 , 6 , 7 , 8 ] , [ 1 , 4 , 6 , 7 ] , [ 0 , 1 , 4 , 6 ] , [ 2 , 0 , 1 , 4 ] ] ; if ( isToepliz ( mat ) ) document . write ( " " ) ; else document . write ( " " ) ;
let N = 5 ; function countZeroes ( mat ) { let row = N - 1 , col = 0 ; let count = 0 ; while ( col < N ) { while ( mat [ row ] [ col ] > 0 ) if ( -- row < 0 ) return count ; count += ( row + 1 ) ; col ++ ; } return count ; } let mat = [ [ 0 , 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 0 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] ] ; document . write ( countZeroes ( mat ) ) ;
let N = 10 ; function findLargestPlus ( mat ) { let left = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { left [ i ] = new Array ( N ) ; } let right = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { right [ i ] = new Array ( N ) ; } let top = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { top [ i ] = new Array ( N ) ; } let bottom = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { bottom [ i ] = new Array ( N ) ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { left [ i ] [ j ] = 0 ; right [ i ] [ j ] = 0 ; top [ i ] [ j ] = 0 ; bottom [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) { top [ 0 ] [ i ] = mat [ 0 ] [ i ] ; bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] ; left [ i ] [ 0 ] = mat [ i ] [ 0 ] ; right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] ; } for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 1 ; j < N ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 ; else left [ i ] [ j ] = 0 ; if ( mat [ j ] [ i ] == 1 ) top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 ; else top [ j ] [ i ] = 0 ; j = N - 1 - j ; if ( mat [ j ] [ i ] == 1 ) bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 ; else bottom [ j ] [ i ] = 0 ; if ( mat [ i ] [ j ] == 1 ) right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 ; else right [ i ] [ j ] = 0 ; j = N - 1 - j ; } } let n = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { let len = Math . min ( Math . min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , Math . min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) ; if ( len > n ) n = len ; } } if ( n > 0 ) return 4 * ( n - 1 ) + 1 ; return 0 ; } let mat = [ [ 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ] , [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 ] , [ 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 ] , [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ] , [ 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ] ] document . write ( findLargestPlus ( mat ) ) ;
String . prototype . replaceAt = function ( index , replacement ) { return this . substr ( 0 , index ) + replacement + this . substr ( index + replacement . length ) ; } function findLeft ( str ) { let n = str . length ; while ( n > 0 ) { n -- ; if ( str [ n ] == ' ' ) { str = str . replaceAt ( n , ' ' ) ; break ; } if ( str [ n ] == ' ' ) { str = str . replaceAt ( n , ' ' ) ; break ; } if ( str [ n ] == ' ' ) str = str . replaceAt ( n , ' ' ) ; else if ( str [ n ] == ' ' ) str = str . replaceAt ( n , ' ' ) ; } return str ; } let str = " " ; document . write ( " " + str + " " + findLeft ( str ) ) ;
function printSpiral ( n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let x ; x = Math . min ( Math . min ( i , j ) , Math . min ( n - 1 - i , n - 1 - j ) ) ; if ( i <= j ) document . write ( ` ${ ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) } ` ) ; else document . write ( ` ${ ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) } ` ) ; } document . write ( " " ) ; } } let n = 5 ; printSpiral ( n ) ;
function modifyMatrix ( mat , R , C ) { let row = new Array ( R ) ; let col = new Array ( C ) ; for ( i = 0 ; i < R ; i ++ ) { row [ i ] = 0 ; } for ( i = 0 ; i < C ; i ++ ) { col [ i ] = 0 ; } for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) { row [ i ] = 1 ; col [ j ] = 1 ; } } } for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { if ( row [ i ] == 1 col [ j ] == 1 ) { mat [ i ] [ j ] = 1 ; } } } } function printMatrix ( mat , R , C ) { let i , j ; for ( i = 0 ; i < R ; i ++ ) { for ( j = 0 ; j < C ; j ++ ) { document . write ( mat [ i ] [ j ] + " " ) ; } document . write ( " " ) ; } } let mat = [ [ 1 , 0 , 0 , 1 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 ] ] ; document . write ( " " ) printMatrix ( mat , 3 , 4 ) ; modifyMatrix ( mat , 3 , 4 ) ; document . write ( " " ) ; printMatrix ( mat , 3 , 4 ) ;
var R = 3 ; var C = 3 ; function swap ( mat , row1 , row2 , col ) { for ( i = 0 ; i < col ; i ++ ) { var temp = mat [ row1 ] [ i ] ; mat [ row1 ] [ i ] = mat [ row2 ] [ i ] ; mat [ row2 ] [ i ] = temp ; } } function rankOfMatrix ( mat ) { var rank = C ; for ( row = 0 ; row < rank ; row ++ ) { if ( mat [ row ] [ row ] != 0 ) { for ( col = 0 ; col < R ; col ++ ) { if ( col != row ) { var mult = mat [ col ] [ row ] / mat [ row ] [ row ] ; for ( i = 0 ; i < rank ; i ++ ) mat [ col ] [ i ] -= mult * mat [ row ] [ i ] ; } } } else { reduce = true ; for ( var i = row + 1 ; i < R ; i ++ ) { if ( mat [ i ] [ row ] != 0 ) { swap ( mat , row , i , rank ) ; reduce = false ; break ; } } if ( reduce ) { rank -- ; for ( i = 0 ; i < R ; i ++ ) mat [ i ] [ row ] = mat [ i ] [ rank ] ; } row -- ; } } return rank ; } function display ( mat , row , col ) { for ( i = 0 ; i < row ; i ++ ) { for ( j = 0 ; j < col ; j ++ ) document . write ( " " + mat [ i ] [ j ] ) ; document . write ( ' ' ) ; } } var mat = [ [ 10 , 20 , 10 ] , [ - 20 , - 30 , 10 ] , [ 30 , 50 , 0 ] ] ; document . write ( " " + rankOfMatrix ( mat ) ) ;
function countIslands ( mat , m , n ) { let count = 0 ; for ( let i = 0 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( mat [ i ] [ j ] == ' ' ) { if ( ( i == 0 mat [ i - 1 ] [ j ] == ' ' ) && ( j == 0 mat [ i ] [ j - 1 ] == ' ' ) ) count ++ ; } } } return count ; } let m = 6 ; let n = 3 ; let mat = [ [ ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' ] ] ; document . write ( " " + countIslands ( mat , m , n ) ) ;
let M = 6 ; let N = 6 ; function floodFillUtil ( mat , x , y , prevV , newV ) { if ( x < 0 x >= M y < 0 y >= N ) return ; if ( mat [ x ] [ y ] != prevV ) return ; mat [ x ] [ y ] = newV ; floodFillUtil ( mat , x + 1 , y , prevV , newV ) ; floodFillUtil ( mat , x - 1 , y , prevV , newV ) ; floodFillUtil ( mat , x , y + 1 , prevV , newV ) ; floodFillUtil ( mat , x , y - 1 , prevV , newV ) ; } function replaceSurrounded ( mat ) { for ( let i = 0 ; i < M ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == ' ' ) mat [ i ] [ j ] = ' ' ; for ( let i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ 0 ] == ' ' ) floodFillUtil ( mat , i , 0 , ' ' , ' ' ) ; for ( let i = 0 ; i < M ; i ++ ) if ( mat [ i ] [ N - 1 ] == ' ' ) floodFillUtil ( mat , i , N - 1 , ' ' , ' ' ) ; for ( let i = 0 ; i < N ; i ++ ) if ( mat [ 0 ] [ i ] == ' ' ) floodFillUtil ( mat , 0 , i , ' ' , ' ' ) ; for ( let i = 0 ; i < N ; i ++ ) if ( mat [ M - 1 ] [ i ] == ' ' ) floodFillUtil ( mat , M - 1 , i , ' ' , ' ' ) ; for ( let i = 0 ; i < M ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) if ( mat [ i ] [ j ] == ' ' ) mat [ i ] [ j ] = ' ' ; } let mat = [ [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' ] ] ; replaceSurrounded ( mat ) ; for ( let i = 0 ; i < M ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) document . write ( mat [ i ] [ j ] + " " ) ; document . write ( " " ) ; }
let x = [ 0 , 1 , 1 , - 1 , 1 , 0 , - 1 , - 1 ] ; let y = [ 1 , 0 , 1 , 1 , - 1 , - 1 , 0 , - 1 ] ; let R = 3 ; let C = 3 ; let dp = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { dp [ i ] = new Array ( C ) ; for ( let j = 0 ; j < C ; j ++ ) { dp [ i ] [ j ] = 0 ; } } function isvalid ( i , j ) { if ( i < 0 j < 0 i >= R j >= C ) return false ; return true ; } function isadjacent ( prev , curr ) { return ( ( curr . charCodeAt ( ) - prev . charCodeAt ( ) ) == 1 ) ; } function getLenUtil ( mat , i , j , prev ) { if ( ! isvalid ( i , j ) || ! isadjacent ( prev , mat [ i ] [ j ] ) ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; let ans = 0 ; for ( let k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) ; return dp [ i ] [ j ] = ans ; } function getLen ( mat , s ) { for ( let i = 0 ; i < R ; ++ i ) for ( let j = 0 ; j < C ; ++ j ) dp [ i ] [ j ] = - 1 ; let ans = 0 ; for ( let i = 0 ; i < R ; i ++ ) { for ( let j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == s ) { for ( let k = 0 ; k < 8 ; k ++ ) ans = Math . max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; } } } return ans ; } let mat = [ [ ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' ] ] ; document . write ( getLen ( mat , ' ' ) + " " ) ; document . write ( getLen ( mat , ' ' ) + " " ) ; document . write ( getLen ( mat , ' ' ) + " " ) ; document . write ( getLen ( mat , ' ' ) ) ;
function findPeakUtil ( arr , low , high , n ) { var mid = low + parseInt ( ( high - low ) / 2 ) ; if ( ( mid == 0 arr [ mid - 1 ] <= arr [ mid ] ) && ( mid == n - 1 arr [ mid + 1 ] <= arr [ mid ] ) ) return mid ; else if ( mid > 0 && arr [ mid - 1 ] > arr [ mid ] ) return findPeakUtil ( arr , low , ( mid - 1 ) , n ) ; else return findPeakUtil ( arr , ( mid + 1 ) , high , n ) ; } function findPeak ( arr , n ) { return findPeakUtil ( arr , 0 , n - 1 , n ) ; } var arr = [ 1 , 3 , 20 , 4 , 1 , 0 ] ; var n = arr . length ; document . write ( " " + findPeak ( arr , n ) ) ;
function printRepeating ( arr , size ) { var i , j ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { for ( j = i + 1 ; j < size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) document . write ( arr [ i ] + " " ) ; } } } var arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] ; var arr_size = arr . length ; printRepeating ( arr , arr_size ) ;
function printRepeating ( arr , size ) { let count = new Array ( size ) ; count . fill ( 0 ) ; let i ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( count [ arr [ i ] ] == 1 ) document . write ( arr [ i ] + " " ) ; else count [ arr [ i ] ] ++ ; } } let arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] ; let arr_size = arr . length ; printRepeating ( arr , arr_size ) ;
function printRepeating ( arr , size ) { var S = 0 ; var P = 1 ; var x , y ; var D ; var n = size - 2 , i ; for ( i = 0 ; i < size ; i ++ ) { S = S + arr [ i ] ; P = P * arr [ i ] ; } S = S - n * parseInt ( ( n + 1 ) / 2 ) ; P = parseInt ( P / fact ( n ) ) ; D = parseInt ( Math . sqrt ( S * S - 4 * P ) ) ; x = parseInt ( ( D + S ) / 2 ) ; y = parseInt ( ( S - D ) / 2 ) ; document . write ( " " ) ; document . write ( x + " " + y ) ; } function fact ( n ) { var ans = false ; if ( n == 0 ) return 1 ; else return ( n * fact ( n - 1 ) ) ; } var arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] ; var arr_size = arr . length ; printRepeating ( arr , arr_size ) ;
function printRepeating ( arr , size ) { let Xor = arr [ 0 ] ; let set_bit_no ; let i ; let n = size - 2 ; let x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) Xor ^= arr [ i ] ; for ( i = 1 ; i <= n ; i ++ ) Xor ^= i ; set_bit_no = Xor & ~ ( Xor - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] & set_bit_no ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i & set_bit_no ) x = x ^ i ; else y = y ^ i ; } document . write ( " " + y + " " + x ) ; } let arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] ; let arr_size = arr . length ; printRepeating ( arr , arr_size ) ;
function printRepeating ( arr , size ) { var i ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ Math . abs ( arr [ i ] ) ] > 0 ) arr [ Math . abs ( arr [ i ] ) ] = - arr [ Math . abs ( arr [ i ] ) ] ; else document . write ( Math . abs ( arr [ i ] ) + " " ) ; } } var arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] ; var arr_size = arr . length ; printRepeating ( arr , arr_size ) ;
function subArraySum ( arr , n , sum ) { let curr_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { curr_sum = arr [ i ] ; for ( let j = i + 1 ; j <= n ; j ++ ) { if ( curr_sum == sum ) { document . write ( " " + i + " " + ( j - 1 ) ) ; return ; } if ( curr_sum > sum j == n ) break ; curr_sum = curr_sum + arr [ j ] ; } } document . write ( " " ) ; return ; } let arr = [ 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 ] ; let n = arr . length ; let sum = 23 ; subArraySum ( arr , n , sum ) ;
function subArraySum ( arr , n , sum ) { let curr_sum = arr [ 0 ] , start = 0 , i ; for ( i = 1 ; i <= n ; i ++ ) { while ( curr_sum > sum && start < i - 1 ) { curr_sum = curr_sum - arr [ start ] ; start ++ ; } if ( curr_sum == sum ) { let p = i - 1 ; document . write ( " " + start + " " + p + " " ) ; return 1 ; } if ( i < n ) curr_sum = curr_sum + arr [ i ] ; } document . write ( " " ) ; return 0 ; } let arr = [ 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 ] ; let n = arr . length ; let sum = 23 ; subArraySum ( arr , n , sum ) ;
function maximum ( a , b , c ) { return Math . max ( Math . max ( a , b ) , c ) ; } function minimum ( a , b , c ) { return Math . min ( Math . min ( a , b ) , c ) ; } function smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) { arr1 . sort ( function ( a , b ) { return a - b } ) ; arr2 . sort ( function ( a , b ) { return a - b } ) ; arr3 . sort ( function ( a , b ) { return a - b } ) ; let res_min = 0 , res_max = 0 , res_mid = 0 ; let i = 0 , j = 0 , k = 0 ; let diff = 2147483647 ; while ( i < n && j < n && k < n ) { let sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] ; let max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; let min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) ; if ( min == arr1 [ i ] ) i ++ ; else if ( min == arr2 [ j ] ) j ++ ; else k ++ ; if ( diff > ( max - min ) ) { diff = max - min ; res_max = max ; res_mid = sum - ( max + min ) ; res_min = min ; } } document . write ( res_max + " " + res_mid + " " + res_min ) ; } let arr1 = [ 5 , 2 , 8 ] ; let arr2 = [ 10 , 7 , 12 ] ; let arr3 = [ 9 , 14 , 6 ] ; let n = arr1 . length ; smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) ;
function find3Numbers ( A , arr_size , sum ) { let l , r ; for ( let i = 0 ; i < arr_size - 2 ; i ++ ) { for ( let j = i + 1 ; j < arr_size - 1 ; j ++ ) { for ( let k = j + 1 ; k < arr_size ; k ++ ) { if ( A [ i ] + A [ j ] + A [ k ] == sum ) { document . write ( " " + A [ i ] + " " + A [ j ] + " " + A [ k ] ) ; return true ; } } } } return false ; } let A = [ 1 , 4 , 45 , 6 , 10 , 8 ] ; let sum = 22 ; let arr_size = A . length ; find3Numbers ( A , arr_size , sum ) ;
function find3Numbers ( A , arr_size , sum ) { let l , r ; A . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < arr_size - 2 ; i ++ ) { l = i + 1 ; r = arr_size - 1 ; while ( l < r ) { if ( A [ i ] + A [ l ] + A [ r ] == sum ) { document . write ( " " + A [ i ] + " " + A [ l ] + " " + A [ r ] ) ; return true ; } else if ( A [ i ] + A [ l ] + A [ r ] < sum ) l ++ ; else r -- ; } } return false ; } let A = [ 1 , 4 , 45 , 6 , 10 , 8 ] ; let sum = 22 ; let arr_size = A . length ; find3Numbers ( A , arr_size , sum ) ;
let arr = [ 1 , 2 , 3 , 4 ] ; function subArray ( n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { for ( let k = i ; k <= j ; k ++ ) document . write ( arr [ k ] + " " ) ; document . write ( " " ) ; } } } document . write ( " " + " " ) ; subArray ( arr . length ) ;
function printSubsequences ( arr , n ) { let opsize = parseInt ( Math . pow ( 2 , n ) , 10 ) ; for ( let counter = 1 ; counter < opsize ; counter ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) document . write ( arr [ j ] + " " ) ; } document . write ( " " ) ; } } let arr = [ 1 , 2 , 3 , 4 ] ; let n = arr . length ; document . write ( " " + " " ) ; printSubsequences ( arr , n ) ;
function productArray ( arr , n ) { if ( n == 1 ) { document . write ( " " ) ; return ; } var i , temp = 1 ; var prod = Array ( n ) . fill ( 0 ) ; for ( j = 0 ; j < n ; j ++ ) prod [ j ] = 1 ; for ( i = 0 ; i < n ; i ++ ) { prod [ i ] = temp ; temp *= arr [ i ] ; } temp = 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { prod [ i ] *= temp ; temp *= arr [ i ] ; } for ( i = 0 ; i < n ; i ++ ) document . write ( prod [ i ] + " " ) ; return ; } var arr = [ 10 , 3 , 5 , 6 , 2 ] ; var n = arr . length ; document . write ( " " ) ; productArray ( arr , n ) ;
function areConsecutive ( arr , n ) { if ( n < 1 ) return false ; let min = getMin ( arr , n ) ; let max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { let visited = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { visited [ i ] = false ; } let i ; for ( i = 0 ; i < n ; i ++ ) { if ( visited [ arr [ i ] - min ] != false ) { return false ; } visited [ arr [ i ] - min ] = true ; } return true ; } return false ; } function getMin ( arr , n ) { let min = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; } function getMax ( arr , n ) { let max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } let arr = [ 5 , 4 , 2 , 3 , 1 , 6 ] let n = arr . length ; if ( areConsecutive ( arr , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function areConsecutive ( arr , n ) { if ( n < 1 ) return false ; let min = getMin ( arr , n ) ; let max = getMax ( arr , n ) ; if ( max - min + 1 == n ) { let i ; for ( i = 0 ; i < n ; i ++ ) { let j ; if ( arr [ i ] < 0 ) j = - arr [ i ] - min ; else j = arr [ i ] - min ; if ( arr [ j ] > 0 ) arr [ j ] = - arr [ j ] ; else return false ; } return true ; } return false ; } function getMin ( arr , n ) { let min = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } return min ; } function getMax ( arr , n ) { let max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } return max ; } let arr = [ 5 , 4 , 2 , 3 , 1 , 6 ] ; let n = arr . length ; if ( areConsecutive ( arr , n ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function relativeComplement ( arr1 , arr2 , n , m ) { let i = 0 , j = 0 ; while ( i < n && j < m ) { if ( arr1 [ i ] < arr2 [ j ] ) { document . write ( arr1 [ i ] + " " ) ; i ++ ; } else if ( arr1 [ i ] > arr2 [ j ] ) { j ++ ; } else if ( arr1 [ i ] == arr2 [ j ] ) { i ++ ; j ++ ; } } while ( i < n ) document . write ( arr1 [ i ] + " " ) ; } let arr1 = [ 3 , 6 , 10 , 12 , 15 ] ; let arr2 = [ 1 , 3 , 5 , 10 , 16 ] ; let n = arr1 . length ; let m = arr2 . length ; relativeComplement ( arr1 , arr2 , n , m ) ;
function minOps ( arr , n , k ) { var max = arr [ 0 ] ; for ( var i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; } var arr = [ 21 , 33 , 9 , 45 , 63 ] ; var n = arr . length ; var k = 6 ; document . write ( minOps ( arr , n , k ) ) ;
function solve ( A , B , C ) { let i , j , k ; i = A . length - 1 ; j = B . length - 1 ; k = C . length - 1 ; let min_diff , current_diff , max_term ; min_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; while ( i != - 1 && j != - 1 && k != - 1 ) { current_diff = Math . abs ( Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) - Math . min ( A [ i ] , Math . min ( B [ j ] , C [ k ] ) ) ) ; if ( current_diff < min_diff ) min_diff = current_diff ; max_term = Math . max ( A [ i ] , Math . max ( B [ j ] , C [ k ] ) ) ; if ( A [ i ] == max_term ) i -= 1 ; else if ( B [ j ] == max_term ) j -= 1 ; else k -= 1 ; } return min_diff ; } let D = [ 5 , 8 , 10 , 15 ] ; let E = [ 6 , 9 , 15 , 78 , 89 ] ; let F = [ 2 , 3 , 6 , 6 , 8 , 8 , 10 ] ; document . write ( solve ( D , E , F ) ) ;
function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + Math . floor ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } let arr = [ 2 , 3 , 4 , 10 , 40 ] ; let x = 10 ; let n = arr . length let result = binarySearch ( arr , 0 , n - 1 , x ) ; ( result == - 1 ) ? document . write ( " " ) : document . write ( " " + result ) ;
function jumpSearch ( arr , x , n ) { let step = Math . sqrt ( n ) ; let prev = 0 ; while ( arr [ Math . min ( step , n ) - 1 ] < x ) { prev = step ; step += Math . sqrt ( n ) ; if ( prev >= n ) return - 1 ; } while ( arr [ prev ] < x ) { prev ++ ; if ( prev == Math . min ( step , n ) ) return - 1 ; } if ( arr [ prev ] == x ) return prev ; return - 1 ; } let arr = [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 ] ; let x = 55 ; let n = arr . length ; let index = jumpSearch ( arr , x , n ) ; document . write ( ` ${ x } ${ index } ` ) ;
function exponentialSearch ( arr , n , x ) { if ( arr [ 0 ] == x ) return 0 ; let i = 1 ; while ( i < n && arr [ i ] <= x ) i = i * 2 ; return binarySearch ( arr , i / 2 , Math . min ( i , n - 1 ) , x ) ; } function binarySearch ( arr , l , r , x ) { if ( r >= l ) { let mid = l + ( r - l ) / 2 ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } return - 1 ; } let arr = [ 2 , 3 , 4 , 10 , 40 ] ; let n = arr . length ; let x = 10 ; let result = exponentialSearch ( arr , n , x ) ; if ( result == - 1 ) document . write ( " " ) ; else document . write ( " " + result ) ;
function printClosest ( ar1 , ar2 , m , n , x ) { let diff = Number . MAX_VALUE ; let res_l , res_r ; let l = 0 , r = n - 1 ; while ( l < m && r >= 0 ) { if ( Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( ar1 [ l ] + ar2 [ r ] - x ) ; } if ( ar1 [ l ] + ar2 [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + ar1 [ res_l ] + " " + ar2 [ res_r ] + " " ) ; } let ar1 = [ 1 , 4 , 5 , 7 ] ; let ar2 = [ 10 , 20 , 30 , 40 ] ; let m = ar1 . length ; let n = ar2 . length ; let x = 38 ; printClosest ( ar1 , ar2 , m , n , x ) ;
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; } let arr = [ 10 , 22 , 28 , 29 , 30 , 40 ] , x = 54 ; let n = arr . length ; printClosest ( arr , n , x ) ;
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; } let arr = [ 1 , 1 , 1 , 1 , 0 , 0 , 0 ] ; let n = arr . length ; document . write ( " " + countOnes ( arr , 0 , n - 1 ) ) ;
function solve ( a , n ) { let maxx = - 1 , minn = a [ 0 ] , l = 0 , r = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > maxx ) { maxx = a [ i ] ; l = i ; } if ( a [ i ] <= minn ) { minn = a [ i ] ; r = i ; } } if ( r < l ) document . write ( l + ( n - r - 2 ) ) ; else document . write ( l + ( n - r - 1 ) ) ; } let a = [ 5 , 6 , 1 , 3 ] ; let n = a . length ; solve ( a , n ) ;
function printMaxActivities ( s , f , n ) { let i , j ; document . write ( " " ) ; i = 0 ; document . write ( i + " " ) ; for ( j = 1 ; j < n ; j ++ ) { if ( s [ j ] >= f [ i ] ) { document . write ( j + " " ) ; i = j ; } } } let s = [ 1 , 3 , 0 , 5 , 8 , 5 ] let f = [ 2 , 4 , 6 , 7 , 9 , 9 ] let n = s . length ; printMaxActivities ( s , f , n ) ;
function min ( x , y , z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } function minCost ( cost , m , n ) { if ( n < 0 m < 0 ) return Number . MAX_VALUE ; else if ( m == 0 && n == 0 ) return cost [ m ] [ n ] ; else return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) ; } var cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] ; document . write ( minCost ( cost , 2 , 2 ) ) ;
function minCost ( cost , m , n ) { let i , j ; let tc = new Array ( m + 1 ) ; for ( let k = 0 ; k < m + 1 ; k ++ ) { tc [ k ] = new Array ( n + 1 ) ; } tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] ; for ( i = 1 ; i <= m ; i ++ ) tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] ; for ( j = 1 ; j <= n ; j ++ ) tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] ; for ( i = 1 ; i <= m ; i ++ ) for ( j = 1 ; j <= n ; j ++ ) tc [ i ] [ j ] = Math . min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] ; return tc [ m ] [ n ] ; } function min ( x , y , z ) { if ( x < y ) return ( x < z ) ? x : z ; else return ( y < z ) ? y : z ; } let cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] ; document . write ( minCost ( cost , 2 , 2 ) ) ;
function max ( a , b ) { return ( a > b ) ? a : b ; } function knapSack ( W , wt , val , n ) { if ( n == 0 W == 0 ) return 0 ; if ( wt [ n - 1 ] > W ) return knapSack ( W , wt , val , n - 1 ) ; else return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) ; } let val = [ 60 , 100 , 120 ] ; let wt = [ 10 , 20 , 30 ] ; let W = 50 ; let n = val . length ; document . write ( knapSack ( W , wt , val , n ) ) ;
function max ( a , b ) { return ( a > b ) ? a : b ; } function knapSack ( W , wt , val , n ) { let i , w ; let K = new Array ( n + 1 ) ; for ( i = 0 ; i <= n ; i ++ ) { K [ i ] = new Array ( W + 1 ) ; for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } return K [ n ] [ W ] ; } let val = [ 60 , 100 , 120 ] ; let wt = [ 10 , 20 , 30 ] ; let W = 50 ; let n = val . length ; document . write ( knapSack ( W , wt , val , n ) ) ;
function max ( x , y ) { return ( x > y ) ? x : y ; } function lps ( seq , i , j ) { if ( i == j ) { return 1 ; } if ( seq [ i ] == seq [ j ] && i + 1 == j ) { return 2 ; } if ( seq [ i ] == seq [ j ] ) { return lps ( seq , i + 1 , j - 1 ) + 2 ; } return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) ; } let seq = " " ; let n = seq . length ; document . write ( " " , lps ( seq . split ( " " ) , 0 , n - 1 ) ) ;
function lbs ( arr , n ) { let i , j ; let lis = new Array ( n ) for ( i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; let lds = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) for ( j = n - 1 ; j > i ; j -- ) if ( arr [ i ] > arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; let max = lis [ 0 ] + lds [ 0 ] - 1 ; for ( i = 1 ; i < n ; i ++ ) if ( lis [ i ] + lds [ i ] - 1 > max ) max = lis [ i ] + lds [ i ] - 1 ; return max ; } let arr = [ 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 ] let n = arr . length ; document . write ( " " + lbs ( arr , n ) ) ;
function maxDivide ( a , b ) { while ( a % b == 0 ) a = a / b ; return a ; } function isUgly ( no ) { no = maxDivide ( no , 2 ) ; no = maxDivide ( no , 3 ) ; no = maxDivide ( no , 5 ) ; return ( no == 1 ) ? 1 : 0 ; } function getNthUglyNo ( n ) { var i = 1 ; var count = 1 ; while ( n > count ) { i ++ ; if ( isUgly ( i ) == 1 ) count ++ ; } return i ; } var no = getNthUglyNo ( 150 ) ; document . write ( " " + " " + no ) ;
function countRec ( n , sum ) { if ( n == 0 ) return sum == 0 ; if ( sum == 0 ) return 1 ; let ans = 0 ; for ( let i = 0 ; i <= 9 ; i ++ ) { if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; } return ans ; } function finalCount ( n , sum ) { let ans = 0 ; for ( let i = 1 ; i <= 9 ; i ++ ) { if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; } return ans ; } let n = 2 , sum = 5 ; document . write ( finalCount ( n , sum ) ) ;
let lookup = new Array ( 101 ) ; function countRec ( n , sum ) { if ( n == 0 ) return sum == 0 ? 1 : 0 ; if ( lookup [ n ] [ sum ] != - 1 ) return lookup [ n ] [ sum ] ; let ans = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return lookup [ n ] [ sum ] = ans ; } function finalCount ( n , sum ) { for ( let i = 0 ; i < 101 ; i ++ ) { lookup [ i ] = new Array ( 501 ) ; for ( let j = 0 ; j < 501 ; j ++ ) { lookup [ i ] [ j ] = - 1 ; } } let ans = 0 ; for ( let i = 1 ; i <= 9 ; i ++ ) if ( sum - i >= 0 ) ans += countRec ( n - 1 , sum - i ) ; return ans ; } let n = 3 , sum = 5 ; document . write ( finalCount ( n , sum ) ) ;
function findCount ( n , sum ) { let start = Math . pow ( 10 , n - 1 ) ; let end = Math . pow ( 10 , n ) - 1 ; let count = 0 ; let i = start ; while ( i <= end ) { let cur = 0 ; let temp = i ; while ( temp != 0 ) { cur += temp % 10 ; temp = parseInt ( temp / 10 ) ; } if ( cur == sum ) { count ++ ; i += 9 ; } else i ++ ; } document . write ( count ) ; } let n = 3 ; let sum = 5 ; findCount ( n , sum ) ;
function countNonDecreasing ( n ) { let dp = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } for ( let i = 0 ; i < 10 ; i ++ ) { for ( let j = 0 ; j < n + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < 10 ; i ++ ) dp [ i ] [ 1 ] = 1 ; for ( let digit = 0 ; digit <= 9 ; digit ++ ) { for ( let len = 2 ; len <= n ; len ++ ) { for ( let x = 0 ; x <= digit ; x ++ ) dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] ; } } let count = 0 ; for ( let i = 0 ; i < 10 ; i ++ ) count += dp [ i ] [ n ] ; return count ; } let n = 3 ; document . write ( countNonDecreasing ( n ) ) ;
function countNonDecreasing ( n ) { let N = 10 ; let count = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count = Math . floor ( count / i ) ; } return count ; } let n = 3 ; document . write ( countNonDecreasing ( n ) ) ;
function getMinSquares ( n ) { if ( n <= 3 ) return n ; let res = n ; for ( let x = 1 ; x <= n ; x ++ ) { let temp = x * x ; if ( temp > n ) break ; else res = Math . min ( res , 1 + getMinSquares ( n - temp ) ) ; } return res ; } document . write ( getMinSquares ( 6 ) ) ;
function getMinSquares ( n ) { if ( n <= 3 ) return n ; var dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; dp [ 3 ] = 3 ; for ( var i = 4 ; i <= n ; i ++ ) { dp [ i ] = i ; for ( var x = 1 ; x <= Math . ceil ( Math . sqrt ( i ) ) ; x ++ ) { var temp = x * x ; if ( temp > i ) break ; else dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - temp ] ) ; } } var res = dp [ n ] ; return res ; } document . write ( getMinSquares ( 6 ) ) ;
function minCoins ( coins , m , V ) { if ( V == 0 ) return 0 ; let res = Number . MAX_VALUE ; for ( let i = 0 ; i < m ; i ++ ) { if ( coins [ i ] <= V ) { let sub_res = minCoins ( coins , m , V - coins [ i ] ) ; if ( sub_res != Number . MAX_VALUE && sub_res + 1 < res ) res = sub_res + 1 ; } } return res ; } let coins = [ 9 , 6 , 5 , 1 ] ; let m = coins . length ; let V = 11 ; document . write ( " " + minCoins ( coins , m , V ) ) ;
function minCoins ( coins , m , v ) { let table = new Array ( V + 1 ) ; for ( let i = 0 ; i < V + 1 ; i ++ ) { table [ i ] = 0 ; } for ( let i = 1 ; i <= V ; i ++ ) { table [ i ] = Number . MAX_VALUE ; } for ( let i = 1 ; i <= V ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) if ( coins [ j ] <= i ) { let sub_res = table [ i - coins [ j ] ] ; if ( sub_res != Number . MAX_VALUE && sub_res + 1 < table [ i ] ) table [ i ] = sub_res + 1 ; } } if ( table [ V ] == Number . MAX_VALUE ) return - 1 ; return table [ V ] ; } let coins = [ 9 , 6 , 5 , 1 ] ; let m = coins . length ; let V = 11 ; document . write ( " " + minCoins ( coins , m , V ) )
function superSeq ( X , Y , m , n ) { if ( m == 0 ) return n ; if ( n == 0 ) return m ; if ( X . charAt ( m - 1 ) == Y . charAt ( n - 1 ) ) return 1 + superSeq ( X , Y , m - 1 , n - 1 ) ; return 1 + Math . min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) ; } var X = " " ; var Y = " " ; document . write ( " " + " " + superSeq ( X , Y , X . length , Y . length ) ) ;
function superSeq ( X , Y , m , n ) { var dp = Array ( m + 1 ) . fill ( 0 ) . map ( x => Array ( n + 1 ) . fill ( 0 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ] [ j ] = j ; else if ( j == 0 ) dp [ i ] [ j ] = i ; else if ( X . charAt ( i - 1 ) == Y . charAt ( j - 1 ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = 1 + Math . min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) ; } } return dp [ m ] [ n ] ; } var X = " " ; var Y = " " ; document . write ( " " + superSeq ( X , Y , X . length , Y . length ) ) ;
function sumOfDigitsFrom1ToN ( n ) { let result = 0 ; for ( let x = 1 ; x <= n ; x ++ ) result += sumOfDigits ( x ) ; return result ; } function sumOfDigits ( x ) { let sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = parseInt ( x / 10 , 10 ) ; } return sum ; } let n = 328 ; document . write ( " " + " " + n + " " + sumOfDigitsFrom1ToN ( n ) ) ;
function sumOfDigitsFrom1ToN ( n ) { if ( n < 10 ) return ( n * ( n + 1 ) / 2 ) ; let d = parseInt ( Math . log ( n ) / Math . log ( 10 ) , 10 ) ; let a = new Array ( d + 1 ) ; a [ 0 ] = 0 ; a [ 1 ] = 45 ; for ( let i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 10 + 45 * parseInt ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) , 10 ) ; let p = parseInt ( Math . ceil ( Math . pow ( 10 , d ) ) , 10 ) ; let msd = parseInt ( n / p , 10 ) ; return ( msd * a [ d ] + ( msd * ( msd - 1 ) / 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) ; } let n = 328 ; document . write ( " " + n + " " + sumOfDigitsFrom1ToN ( n ) ) ;
function countWays ( N ) { if ( N == 1 ) return 4 ; let countB = 1 , countS = 1 , prev_countB , prev_countS ; for ( let i = 2 ; i <= N ; i ++ ) { prev_countB = countB ; prev_countS = countS ; countS = prev_countB + prev_countS ; countB = prev_countS ; } let result = countS + countB ; return ( result * result ) ; } N = 3 ; document . write ( " " + N + " " + countWays ( N ) ) ;
function count ( n ) { let table = new Array ( n + 1 ) , i ; for ( let j = 0 ; j < n + 1 ; j ++ ) table [ j ] = 0 ; table [ 0 ] = 1 ; for ( i = 3 ; i <= n ; i ++ ) table [ i ] += table [ i - 3 ] ; for ( i = 5 ; i <= n ; i ++ ) table [ i ] += table [ i - 5 ] ; for ( i = 10 ; i <= n ; i ++ ) table [ i ] += table [ i - 10 ] ; return table [ n ] ; } let n = 20 ; document . write ( " " + n + " " + count ( n ) + " " ) ; n = 13 ; document . write ( " " + n + " " + count ( n ) + " " ) ;
function search ( txt , pat ) { let M = pat . length ; let N = txt . length ; for ( let i = 0 ; i <= N - M ; i ++ ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) document . write ( " " + i + " " ) ; } } let txt = " " ; let pat = " " ; search ( txt , pat ) ;
let d = 256 ; function search ( pat , txt , q ) { let M = pat . length ; let N = txt . length ; let i , j ; let p = 0 ; let t = 0 ; let h = 1 ; for ( i = 0 ; i < M - 1 ; i ++ ) h = ( h * d ) % q ; for ( i = 0 ; i < M ; i ++ ) { p = ( d * p + pat [ i ] . charCodeAt ( ) ) % q ; t = ( d * t + txt [ i ] . charCodeAt ( ) ) % q ; } for ( i = 0 ; i <= N - M ; i ++ ) { if ( p == t ) { for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) break ; } if ( j == M ) document . write ( " " + i + " " ) ; } if ( i < N - M ) { t = ( d * ( t - txt [ i ] . charCodeAt ( ) * h ) + txt [ i + M ] . charCodeAt ( ) ) % q ; if ( t < 0 ) t = ( t + q ) ; } } } let txt = " " ; let pat = " " ; let q = 101 ; search ( pat , txt , q ) ;
function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { document . write ( " " + i + " " ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } let txt = " " ; let pat = " " ; search ( pat , txt ) ;
function getMedian ( ar1 , ar2 , n ) { var i = 0 ; var j = 0 ; var count ; var m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] <= ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } var ar1 = [ 1 , 12 , 15 , 26 , 38 ] ; var ar2 = [ 2 , 13 , 17 , 30 , 45 ] ; var n1 = ar1 . length ; var n2 = ar2 . length ; if ( n1 == n2 ) document . write ( " " + getMedian ( ar1 , ar2 , n1 ) ) ; else document . write ( " " ) ;
function area ( x1 , y1 , x2 , y2 , x3 , y3 ) { return Math . abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) ; } function isInside ( x1 , y1 , x2 , y2 , x3 , y3 , x , y ) { let A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) ; let A1 = area ( x , y , x2 , y2 , x3 , y3 ) ; let A2 = area ( x1 , y1 , x , y , x3 , y3 ) ; let A3 = area ( x1 , y1 , x2 , y2 , x , y ) ; return ( A == A1 + A2 + A3 ) ; } if ( isInside ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isLucky ( n ) { let counter = 2 ; let next_position = n ; if ( counter > n ) return 1 ; if ( n % counter == 0 ) return 0 ; next_position -= Math . floor ( next_position / counter ) ; counter ++ ; return isLucky ( next_position ) ; } let x = 5 ; if ( isLucky ( x ) ) document . write ( x + " " ) ; else document . write ( x + " " ) ;
function pow ( a , b ) { if ( b == 0 ) return 1 ; var answer = a ; var increment = a ; var i , j ; for ( i = 1 ; i < b ; i ++ ) { for ( j = 1 ; j < a ; j ++ ) { answer += increment ; } increment = answer ; } return answer ; } document . write ( pow ( 5 , 3 ) ) ;
function multiply ( x , y ) { if ( y > 0 ) return ( x + multiply ( x , y - 1 ) ) ; else return 0 ; } function pow ( a , b ) { if ( b > 0 ) return multiply ( a , pow ( a , b - 1 ) ) ; else return 1 ; } document . write ( pow ( 5 , 3 ) ) ;
function count ( n ) { if ( n < 3 ) return n ; if ( n >= 3 && n < 10 ) return n - 1 ; var po = 1 ; while ( parseInt ( n / po ) > 9 ) po = po * 10 ; var msd = parseInt ( n / po ) ; if ( msd != 3 ) return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) ; else return count ( msd * po - 1 ) ; } var n = 578 ; document . write ( count ( n ) ) ;
function maximumNumberDistinctPrimeRange ( m , n ) { let factorCount = new Array ( n + 1 ) ; let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( let i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( let j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } let max = factorCount [ m ] ; let num = m ; for ( let i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = factorCount [ i ] ; num = i ; } } return num ; } let m = 4 , n = 6 ; document . write ( maximumNumberDistinctPrimeRange ( m , n ) ) ;
function fact ( n ) { return ( n <= 1 ) ? 1 : n * fact ( n - 1 ) ; } function findSmallerInRight ( str , low , high ) { let countRight = 0 ; let i ; for ( i = low + 1 ; i <= high ; ++ i ) if ( str [ i ] < str [ low ] ) ++ countRight ; return countRight ; } function findRank ( str ) { let len = ( str ) . length ; let mul = fact ( len ) ; let rank = 1 ; let countRight ; let i ; for ( i = 0 ; i < len ; ++ i ) { mul /= len - i ; countRight = findSmallerInRight ( str , i , len - 1 ) ; rank += countRight * mul ; } return rank ; } let str = " " ; document . write ( findRank ( str ) ) ;
function exponential ( n , x ) { var sum = 1 ; for ( i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; } var n = 10 ; var x = 1 ; document . write ( " " + exponential ( n , x ) . toFixed ( 6 ) ) ;
function isPerfectSquare ( x ) { let s = parseInt ( Math . sqrt ( x ) ) ; return ( s * s == x ) ; } function isFibonacci ( n ) { return isPerfectSquare ( 5 * n * n + 4 ) || isPerfectSquare ( 5 * n * n - 4 ) ; } for ( let i = 1 ; i <= 10 ; i ++ ) isFibonacci ( i ) ? document . write ( i + " " ) : document . write ( i + " " ) ;
function findTrailingZeros ( n ) { let count = 0 ; for ( let i = 5 ; Math . floor ( n / i ) >= 1 ; i *= 5 ) count += Math . floor ( n / i ) ; return count ; } let n = 100 ; document . write ( " " + 100 + " " + findTrailingZeros ( n ) ) ;
function catalan ( n ) { if ( n <= 1 ) return 1 ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res += catalan ( i ) * catalan ( n - i - 1 ) ; return res ; } for ( let i = 0 ; i < 10 ; i ++ ) document . write ( catalan ( i ) + " " ) ;
function catalanDP ( n ) { let catalan = [ ] ; catalan [ 0 ] = catalan [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { catalan [ i ] = 0 ; for ( let j = 0 ; j < i ; j ++ ) catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] ; } return catalan [ n ] ; } for ( let i = 0 ; i < 10 ; i ++ ) document . write ( catalanDP ( i ) + " " ) ;
function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res = Math . floor ( res / ( i + 1 ) ) ; } return res ; } function catalan ( n ) { c = binomialCoeff ( 2 * ( n ) , n ) ; return Math . floor ( c / ( n + 1 ) ) ; } for ( let i = 0 ; i < 10 ; i ++ ) document . write ( catalan ( i ) + " " ) ;
function min ( x , y ) { return ( x < y ) ? x : y ; } function calcAngle ( h , m ) { if ( h < 0 m < 0 h > 12 m > 60 ) document . write ( " " ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) { m = 0 ; h += 1 ; if ( h > 12 ) h = h - 12 ; } let hour_angle = 0.5 * ( h * 60 + m ) ; let minute_angle = 6 * m ; let angle = Math . abs ( hour_angle - minute_angle ) ; angle = min ( 360 - angle , angle ) ; return angle ; } document . write ( calcAngle ( 9 , 60 ) + " " ) ; document . write ( calcAngle ( 3 , 30 ) + " " ) ;
function getInvCount ( arr ) { let inv_count = 0 ; for ( let i = 0 ; i < 2 ; i ++ ) { for ( let j = i + 1 ; j < 3 ; j ++ ) { if ( arr [ j ] [ i ] > 0 && arr [ j ] [ i ] > arr [ i ] [ j ] ) inv_count += 1 ; } } return inv_count ; } function isSolvable ( puzzle ) { let invCount = getInvCount ( puzzle ) ; return ( invCount % 2 == 0 ) ; } puzzle = [ [ 1 , 8 , 2 ] , [ 0 , 4 , 3 ] , [ 7 , 6 , 5 ] ] ; if ( isSolvable ( puzzle ) ) document . write ( " " ) ; else document . write ( " " ) ;
function find ( p ) { return Math . ceil ( Math . sqrt ( 2 * 365 * Math . log ( 1 / ( 1 - p ) ) ) ) ; } document . write ( find ( 0.70 ) ) ;
function countSolutions ( n ) { let res = 0 ; for ( let x = 0 ; x * x < n ; x ++ ) { for ( let y = 0 ; x * x + y * y < n ; y ++ ) { res ++ ; } } return res ; } document . write ( " " + countSolutions ( 6 ) ) ;
function countSolutions ( n ) { let x = 0 , yCount , res = 0 ; for ( yCount = 0 ; yCount * yCount < n ; yCount ++ ) ; while ( yCount != 0 ) { res += yCount ; x ++ ; while ( yCount != 0 && ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) yCount -- ; } return res ; } document . write ( " " + " " + countSolutions ( 6 ) ) ;
let EPSILON = 0.001 ; function func ( x ) { return x * x * x - x * x + 2 ; } function derivFunc ( x ) { return 3 * x * x - 2 * x ; } function newtonRaphson ( x ) { let h = func ( x ) / derivFunc ( x ) ; while ( Math . abs ( h ) >= EPSILON ) { h = func ( x ) / derivFunc ( x ) ; x = x - h ; } document . write ( " " + " " + Math . round ( x * 100.0 ) / 100.0 ) ; } let x0 = - 20 ; newtonRaphson ( x0 ) ;
function getSingle ( arr , n ) { let ones = 0 , twos = 0 ; let common_bit_mask ; for ( let i = 0 ; i < n ; i ++ ) { twos = twos | ( ones & arr [ i ] ) ; ones = ones ^ arr [ i ] ; common_bit_mask = ~ ( ones & twos ) ; ones &= common_bit_mask ; twos &= common_bit_mask ; } return ones ; } let arr = [ 3 , 3 , 2 , 3 ] ; let n = arr . length ; document . write ( " " + getSingle ( arr , n ) ) ;
let INT_SIZE = 32 ; function getSingle ( arr , n ) { let result = 0 ; let x , sum ; for ( let i = 0 ; i < INT_SIZE ; i ++ ) { sum = 0 ; x = ( 1 << i ) ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & x ) sum ++ ; } if ( ( sum % 3 ) != 0 ) result |= x ; } return result ; } let arr = [ 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ] ; let n = arr . length ; document . write ( " " + getSingle ( arr , n ) ) ;
function oppositeSigns ( x , y ) { return ( ( x ^ y ) < 0 ) ; } let x = 100 , y = - 100 ; if ( oppositeSigns ( x , y ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function countSetBits ( n ) { let bitCount = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { bitCount += countSetBitsUtil ( i ) ; } return bitCount ; } function countSetBitsUtil ( x ) { if ( x <= 0 ) { return 0 ; } return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( Math . floor ( x / 2 ) ) ; } let n = 4 ; document . write ( " " ) ; document . write ( countSetBits ( n ) ) ;
function countSetBits ( n ) { let i = 0 ; let ans = 0 ; while ( ( 1 << i ) <= n ) { let k = 0 ; let change = 1 << i ; for ( let j = 0 ; j <= n ; j ++ ) { ans += k ; if ( change == 1 ) { k = ! k ; change = 1 << i ; } else { change -- ; } } i ++ ; } return ans ; } let n = 17 ; document . write ( countSetBits ( n ) ) ;
function swapBits ( x , p1 , p2 , n ) { let set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) ; let set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) ; let xor = ( set1 ^ set2 ) ; xor = ( xor << p1 ) | ( xor << p2 ) ; let result = x ^ xor ; return result ; } let res = swapBits ( 28 , 0 , 3 , 2 ) ; document . write ( " " + res ) ;
function smallest ( x , y , z ) { let c = 0 ; while ( x && y && z ) { x -- ; y -- ; z -- ; c ++ ; } return c ; } let x = 12 , y = 15 , z = 5 ; document . write ( " " + smallest ( x , y , z ) ) ;
function snoob ( x ) { let rightOne , nextHigherOneBit , rightOnesPattern , next = 0 ; if ( x > 0 ) { rightOne = x & - x ; nextHigherOneBit = x + rightOne ; rightOnesPattern = x ^ nextHigherOneBit ; rightOnesPattern = ( rightOnesPattern ) / rightOne ; rightOnesPattern >>= 2 ; next = nextHigherOneBit | rightOnesPattern ; } return next ; } let x = 156 ; document . write ( " " + " " + snoob ( x ) ) ;
function addOne ( x ) { let m = 1 ; while ( x & m ) { x = x ^ m ; m <<= 1 ; } x = x ^ m ; return x ; } document . write ( addOne ( 13 ) ) ;
function addOne ( x ) { return ( - ( ~ x ) ) ; } document . write ( addOne ( 13 ) ) ;
function multiplyWith3Point5 ( x ) { return ( x << 1 ) + x + ( x >> 1 ) ; } var x = 4 ; document . write ( multiplyWith3Point5 ( x ) ) ;
function fun ( n ) { return n & ( n - 1 ) ; } let n = 7 ; document . write ( " " + " " + fun ( n ) ) ;
function isPowerOfFour ( n ) { if ( n == 0 ) return false ; while ( n != 1 ) { if ( n % 4 != 0 ) return false ; n = n / 4 ; } return true ; } let test_no = 64 ; if ( isPowerOfFour ( test_no ) ) document . write ( test_no + " " ) ; else document . write ( test_no + " " ) ;
function isPowerOfFour ( n ) { let count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % 2 == 0 ) ? 1 : 0 ; } return 0 ; } let test_no = 64 ; if ( isPowerOfFour ( test_no ) ) document . write ( test_no + " " ) ; else document . write ( test_no + " " ) ;
function min ( x , y ) { return y ^ ( ( x ^ y ) & - ( x << y ) ) ; } function max ( x , y ) { return x ^ ( ( x ^ y ) & - ( x << y ) ) ; } let x = 15 let y = 6 document . write ( " " + x + " " + y + " " ) ; document . write ( min ( x , y ) + " " ) ; document . write ( " " + x + " " + y + " " ) ; document . write ( max ( x , y ) + " " ) ;
function getOddOccurrence ( arr , arr_size ) { for ( let i = 0 ; i < arr_size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; } let arr = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ] ; let n = arr . length ; document . write ( getOddOccurrence ( arr , n ) ) ;
function countSetBits ( n ) { var count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; } function FlippedCount ( a , b ) { return countSetBits ( a ^ b ) ; } var a = 10 ; var b = 20 ; document . write ( FlippedCount ( a , b ) ) ;
function getFirstSetBitPos ( n ) { return Math . log2 ( n & - n ) + 1 ; } let g ; let n = 12 ; document . write ( getFirstSetBitPos ( n ) ) ;
function PositionRightmostSetbit ( n ) { let position = 1 ; let m = 1 ; while ( ( n & m ) == 0 ) { m = m << 1 ; position ++ ; } return position ; } let n = 16 ; document . write ( PositionRightmostSetbit ( n ) ) ;
let INT_SIZE = 32 ; function Right_most_setbit ( num ) { let pos = 1 ; for ( let i = 0 ; i < INT_SIZE ; i ++ ) { if ( ( num & ( 1 << i ) ) == 0 ) pos ++ ; else break ; } return pos ; } let num = 18 ; let pos = Right_most_setbit ( num ) ; document . write ( pos ) ;
function bin ( n ) { if ( n > 1 ) bin ( n >> 1 ) ; document . write ( n & 1 ) ; } bin ( 131 ) ; document . write ( " " ) ; bin ( 3 ) ;
function swapBits ( x ) { even_bits = x & 0xAAAAAAAA ; odd_bits = x & 0x55555555 ; even_bits >>= 1 ; odd_bits <<= 1 ; return ( even_bits odd_bits ) ; } let x = 23 ; document . write ( swapBits ( x ) ) ;
function isPowerOfTwo ( n ) { return ( n > 0 && ( ( n & ( n - 1 ) ) == 0 ) ) ? true : false ; } function findPosition ( n ) { if ( isPowerOfTwo ( n ) == false ) return - 1 ; var i = 1 ; var pos = 1 ; while ( ( i & n ) == 0 ) { i = i << 1 ; pos += 1 ; } return pos ; } var n = 16 ; var pos = findPosition ( n ) ; if ( pos == - 1 ) document . write ( " " + n + " " ) ; else document . write ( " " + n + " " + pos ) ; document . write ( " " ) ; n = 12 ; pos = findPosition ( n ) ; if ( pos == - 1 ) document . write ( " " + n + " " ) ; else document . write ( " " + n + " " , pos ) ; document . write ( " " ) ; n = 128 ; pos = findPosition ( n ) ; if ( pos == - 1 ) document . write ( " " + n + " " ) ; else document . write ( " " + n + " " + pos ) ;
function isPowerOfTwo ( n ) { return ( n && ( ! ( n & ( n - 1 ) ) ) ) } function findPosition ( n ) { if ( ! isPowerOfTwo ( n ) ) return - 1 var count = 0 while ( n ) { n = n >> 1 count += 1 } return count } var n = 0 var pos = findPosition ( n ) if ( pos == - 1 ) document . write ( " " , n , " " ) else document . write ( " " , n , " " , pos ) document . write ( " " ) n = 12 pos = findPosition ( n ) if ( pos == - 1 ) document . write ( " " , n , " " ) else document . write ( " " , n , " " , pos ) document . write ( " " ) n = 128 pos = findPosition ( n ) if ( pos == - 1 ) document . write ( " " , n , " " ) else document . write ( " " , n , " " , pos ) document . write ( " " )
var x = 10 ; var y = 5 ; x = x * y ; y = x / y ; x = x / y ; document . write ( " " + " " + x + " " + y ) ;
let x = 10 , y = 5 ; x = x ^ y ; y = x ^ y ; x = x ^ y ; document . write ( " " + x + " " + y ) ;
function swap ( xp , yp ) { xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] ; } let x = [ 10 ] ; swap ( x , x ) ; document . write ( " " + x [ 0 ] ) ;
function maxOnesIndex ( arr , n ) { let max_count = 0 ; let max_index = 0 ; let prev_zero = - 1 ; let prev_prev_zero = - 1 ; for ( let curr = 0 ; curr < n ; ++ curr ) { if ( arr [ curr ] == 0 ) { if ( curr - prev_prev_zero > max_count ) { max_count = curr - prev_prev_zero ; max_index = prev_zero ; } prev_prev_zero = prev_zero ; prev_zero = curr ; } } if ( n - prev_prev_zero > max_count ) max_index = prev_zero ; return max_index ; } let arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ] ; let n = arr . length ; document . write ( " " + maxOnesIndex ( arr , n ) ) ;
function min ( x , y ) { return ( x < y ) ? x : y ; } function max ( x , y ) { return ( x > y ) ? x : y ; } function findLength ( arr , n ) { let max_len = 1 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let mn = arr [ i ] , mx = arr [ i ] ; for ( let j = i + 1 ; j < n ; j ++ ) { mn = min ( mn , arr [ j ] ) ; mx = max ( mx , arr [ j ] ) ; if ( ( mx - mn ) == j - i ) max_len = Math . max ( max_len , mx - mn + 1 ) ; } } return max_len ; } let arr = [ 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 ] ; let n = arr . length ; document . write ( " " + findLength ( arr , n ) ) ;
function printArr ( arr , k ) { for ( let i = 0 ; i < k ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; } function printSeqUtil ( n , k , len , arr ) { if ( len == k ) { printArr ( arr , k ) ; return ; } let i = ( len == 0 ) ? 1 : arr [ len - 1 ] + 1 ; len ++ ; while ( i <= n ) { arr [ len - 1 ] = i ; printSeqUtil ( n , k , len , arr ) ; i ++ ; } len -- ; } function printSeq ( n , k ) { let arr = new Array ( k ) ; let len = 0 ; printSeqUtil ( n , k , len , arr ) ; } let k = 3 , n = 7 ; printSeq ( n , k ) ;
function isSubSequence ( str1 , str2 , m , n ) { if ( m == 0 ) return true ; if ( n == 0 ) return false ; if ( str1 [ m - 1 ] == str2 [ n - 1 ] ) return isSubSequence ( str1 , str2 , m - 1 , n - 1 ) ; return isSubSequence ( str1 , str2 , m , n - 1 ) ; } let str1 = " " ; let str2 = " " ; let m = str1 . length ; let n = str2 . length ; let res = isSubSequence ( str1 , str2 , m , n ) ; if ( res ) document . write ( " " ) ; else document . write ( " " ) ;
function nextGreatest ( arr , size ) { max_from_right = arr [ size - 1 ] ; arr [ size - 1 ] = - 1 ; for ( let i = size - 2 ; i >= 0 ; i -- ) { temp = arr [ i ] ; arr [ i ] = max_from_right ; if ( max_from_right < temp ) max_from_right = temp ; } } function printArray ( arr , size ) { var i ; for ( let i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + " " ) ; } arr = new Array ( 16 , 17 , 4 , 3 , 5 , 2 ) ; size = arr . length ; nextGreatest ( arr , size ) ; document . write ( " " + " " + " " ) ; printArray ( arr , size ) ;
function GetCeilIndex ( arr , T , l , r , key ) { while ( r - l > 1 ) { let m = l + parseInt ( ( r - l ) / 2 , 10 ) ; if ( arr [ T [ m ] ] >= key ) r = m ; else l = m ; } return r ; } function LongestIncreasingSubsequence ( arr , n ) { let tailIndices = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) tailIndices [ i ] = 0 ; let prevIndices = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) prevIndices [ i ] = - 1 ; let len = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) tailIndices [ 0 ] = i ; else if ( arr [ i ] > arr [ tailIndices [ len - 1 ] ] ) { prevIndices [ i ] = tailIndices [ len - 1 ] ; tailIndices [ len ++ ] = i ; } else { let pos = GetCeilIndex ( arr , tailIndices , - 1 , len - 1 , arr [ i ] ) ; prevIndices [ i ] = tailIndices [ pos - 1 ] ; tailIndices [ pos ] = i ; } } document . write ( " " + " " ) ; for ( let i = tailIndices [ len - 1 ] ; i >= 0 ; i = prevIndices [ i ] ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; return len ; } let arr = [ 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 ] ; let n = arr . length ; document . write ( " " + LongestIncreasingSubsequence ( arr , n ) ) ;
function generateUtil ( A , B , C , i , j , m , n , len , flag ) { if ( flag ) { if ( len != 0 ) printArr ( C , len + 1 ) ; for ( var k = i ; k < m ; k ++ ) { if ( len == 0 ) { C [ len ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len , ! flag ) ; } else if ( A [ k ] > C [ len ] ) { C [ len + 1 ] = A [ k ] ; generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , ! flag ) ; } } } else { for ( var l = j ; l < n ; l ++ ) { if ( B [ l ] > C [ len ] ) { C [ len + 1 ] = B [ l ] ; generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , ! flag ) ; } } } } function generate ( A , B , m , n ) { var C = Array ( m + n ) . fill ( 0 ) ; generateUtil ( A , B , C , 0 , 0 , m , n , 0 , true ) ; } function printArr ( arr , n ) { for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; } var A = [ 10 , 15 , 25 ] ; var B = [ 5 , 20 , 30 ] ; var n = A . length ; var m = B . length ; generate ( A , B , n , m ) ;
function replace_elements ( arr , n ) { let pos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { arr [ pos ++ ] = arr [ i ] ; while ( pos > 1 && arr [ pos - 2 ] == arr [ pos - 1 ] ) { pos -- ; arr [ pos - 1 ] ++ ; } } for ( let i = 0 ; i < pos ; i ++ ) document . write ( arr [ i ] + " " ) ; } let arr = [ 6 , 4 , 3 , 4 , 3 , 3 , 5 ] ; let n = arr . length replace_elements ( arr , n ) ;
function arrangeString ( str , x , y ) { let count_0 = 0 ; let count_1 = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) count_0 ++ ; else count_1 ++ ; } while ( count_0 > 0 count_1 > 0 ) { for ( let j = 0 ; j < x && count_0 > 0 ; j ++ ) { if ( count_0 > 0 ) { document . write ( " " ) ; count_0 -- ; } } for ( let j = 0 ; j < y && count_1 > 0 ; j ++ ) { if ( count_1 > 0 ) { document . write ( " " ) ; count_1 -- ; } } } } let str = " " ; let x = 1 ; let y = 2 ; arrangeString ( str , x , y ) ;
function rearrange ( arr , n ) { if ( arr == null n % 2 == 1 ) return ; let currIdx = Math . floor ( ( n - 1 ) / 2 ) ; while ( currIdx > 0 ) { let count = currIdx , swapIdx = currIdx ; while ( count -- > 0 ) { let temp = arr [ swapIdx + 1 ] ; arr [ swapIdx + 1 ] = arr [ swapIdx ] ; arr [ swapIdx ] = temp ; swapIdx ++ ; } currIdx -- ; } } let arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] ; let n = arr . length ; rearrange ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( " " + arr [ i ] ) ;
function maxDiff ( arr , arr_size ) { let max_diff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 0 ; i < arr_size ; i ++ ) { for ( let j = i + 1 ; j < arr_size ; j ++ ) { if ( arr [ j ] - arr [ i ] > max_diff ) max_diff = arr [ j ] - arr [ i ] ; } } return max_diff ; } let arr = [ 1 , 2 , 90 , 10 , 110 ] ; let n = arr . length ; document . write ( " " + maxDiff ( arr , n ) ) ;
function maxDiff ( arr , n ) { let maxDiff = - 1 ; let maxRight = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > maxRight ) maxRight = arr [ i ] ; else { let diff = maxRight - arr [ i ] ; if ( diff > maxDiff ) { maxDiff = diff ; } } } return maxDiff ; } let arr = [ 1 , 2 , 90 , 10 , 110 ] ; let n = arr . length ; document . write ( " " + maxDiff ( arr , n ) ) ;
function maxDiff ( arr , n ) { let diff = arr [ 1 ] - arr [ 0 ] ; let curr_sum = diff ; let max_sum = curr_sum ; for ( let i = 1 ; i < n - 1 ; i ++ ) { diff = arr [ i + 1 ] - arr [ i ] ; if ( curr_sum > 0 ) curr_sum += diff ; else curr_sum = diff ; if ( curr_sum > max_sum ) max_sum = curr_sum ; } return max_sum ; } let arr = [ 80 , 2 , 6 , 3 , 100 ] ; let n = arr . length ; document . write ( " " + maxDiff ( arr , n ) ) ;
function findMaximum ( arr , low , high ) { var max = arr [ low ] ; var i ; for ( i = low + 1 ; i <= high ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; else break ; } return max ; } var arr = [ 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 ] ; var n = arr . length ; document . write ( " " + findMaximum ( arr , 0 , n - 1 ) ) ;
function findMaximum ( arr , low , high ) { if ( low == high ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] >= arr [ high ] ) return arr [ low ] ; if ( ( high == low + 1 ) && arr [ low ] < arr [ high ] ) return arr [ high ] ; mid = ( low + high ) / 2 ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] > arr [ mid - 1 ] ) return arr [ mid ] ; if ( arr [ mid ] > arr [ mid + 1 ] && arr [ mid ] < arr [ mid - 1 ] ) return findMaximum ( arr , low , mid - 1 ) ; return findMaximum ( arr , mid + 1 , high ) ; } arr = new Array ( 1 , 3 , 50 , 10 , 9 , 7 , 6 ) ; n = arr . length ; document . write ( " " + " " + findMaximum ( arr , 0 , n - 1 ) ) ;
function max ( x , y ) { return ( x > y ) ? x : y ; } function maxPathSum ( ar1 , ar2 , m , n ) { let i = 0 , j = 0 ; let result = 0 , sum1 = 0 , sum2 = 0 ; while ( i < m && j < n ) { if ( ar1 [ i ] < ar2 [ j ] ) sum1 += ar1 [ i ++ ] ; else if ( ar1 [ i ] > ar2 [ j ] ) sum2 += ar2 [ j ++ ] ; else { result += Math . max ( sum1 , sum2 ) + ar1 [ i ] ; sum1 = 0 ; sum2 = 0 ; i ++ ; j ++ ; } } while ( i < m ) sum1 += ar1 [ i ++ ] ; while ( j < n ) sum2 += ar2 [ j ++ ] ; result += Math . max ( sum1 , sum2 ) ; return result ; } let ar1 = [ 2 , 3 , 7 , 10 , 12 , 15 , 30 , 34 ] ; let ar2 = [ 1 , 5 , 7 , 8 , 10 , 15 , 16 , 19 ] ; let m = ar1 . length ; let n = ar2 . length ; document . write ( " " + maxPathSum ( ar1 , ar2 , m , n ) ) ;
function smallestGreater ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let diff = Number . MAX_VALUE ; let closest = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] && arr [ j ] - arr [ i ] < diff ) { diff = arr [ j ] - arr [ i ] ; closest = j ; } } if ( closest == - 1 ) document . write ( " " ) ; else document . write ( arr [ closest ] + " " ) ; } } let ar = [ 6 , 3 , 9 , 8 , 10 , 2 , 1 , 15 , 7 ] ; let n = ar . length ; smallestGreater ( ar , n ) ;
function findZeroes ( arr , n , m ) { let wL = 0 ; let wR = 0 ; let bestL = 0 ; let bestWindow = 0 ; let zeroCount = 0 ; while ( wR < n ) { if ( zeroCount <= m ) { if ( arr [ wR ] == 0 ) zeroCount ++ ; wR ++ ; } if ( zeroCount > m ) { if ( arr [ wL ] == 0 ) zeroCount -- ; wL ++ ; } if ( ( wR - wL > bestWindow ) && ( zeroCount <= m ) ) { bestWindow = wR - wL ; bestL = wL ; } } for ( let i = 0 ; i < bestWindow ; i ++ ) { if ( arr [ bestL + i ] == 0 ) document . write ( bestL + i + " " ) ; } } let arr = new Array ( 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 ) ; let m = 2 ; let n = arr . length ; document . write ( " " ) ; findZeroes ( arr , n , m ) ;
function countIncreasing ( arr , n ) { let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; } let arr = [ 1 , 2 , 2 , 4 ] ; let n = arr . length ; document . write ( " " + " " + countIncreasing ( arr , n ) ) ;
let arr = [ 1 , 2 , 2 , 4 ] ; function countIncreasing ( n ) { let cnt = 0 ; let len = 1 ; for ( let i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] > arr [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } document . write ( " " + " " + countIncreasing ( arr . length ) ) ;
function arraySum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; } function maxDiff ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) ; var arraysum = arraySum ( arr , n ) ; var diff1 = Math . abs ( arraysum - 2 * arraySum ( arr , k ) ) ; arr . reverse ( ) ; var diff2 = Math . abs ( arraysum - 2 * arraySum ( arr , k ) ) ; return ( Math . max ( diff1 , diff2 ) ) ; } var arr = [ 1 , 7 , 4 , 8 , - 1 , 5 , 2 , 1 ] ; var n = arr . length ; var k = 3 ; document . write ( " " + maxDiff ( arr , n , k ) ) ;
function minNumber ( a , n , x ) { a . sort ( ) ; let k ; for ( k = 0 ; a [ parseInt ( ( n - 1 ) / 2 , 10 ) ] != x ; k ++ ) { a [ n ++ ] = x ; a . sort ( ) ; } return k ; } let x = 10 ; let a = [ 10 , 20 , 30 ] ; let n = 3 ; document . write ( minNumber ( a , n , x ) ) ;
function minNumber ( a , n , x ) { let l = 0 , h = 0 , e = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == x ) e ++ ; else if ( a [ i ] > x ) h ++ ; else if ( a [ i ] < x ) l ++ ; } let ans = 0 ; if ( l > h ) ans = l - h ; else if ( l < h ) ans = h - l - 1 ; return ans + 1 - e ; } let x = 10 ; let a = [ 10 , 20 , 30 ] ; let n = a . length ; document . write ( minNumber ( a , n , x ) ) ;
function checkEVENodd ( arr , n , l , r ) { if ( arr [ r ] == 1 ) document . write ( " " ) ; else document . write ( " " ) ; } let arr = [ 1 , 1 , 0 , 1 ] ; let n = arr . length ; checkEVENodd ( arr , n , 1 , 3 ) ;
function findMean ( arr , l , r ) { let sum = 0 , count = 0 ; for ( let i = l ; i <= r ; i ++ ) { sum += arr [ i ] ; count ++ ; } let mean = Math . floor ( sum / count ) ; return mean ; } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; document . write ( findMean ( arr , 0 , 2 ) + " " ) ; document . write ( findMean ( arr , 1 , 3 ) + " " ) ; document . write ( findMean ( arr , 0 , 4 ) + " " ) ;
function calculateProduct ( A , L , R , P ) { L = L - 1 ; R = R - 1 ; let ans = 1 ; for ( let i = L ; i <= R ; i ++ ) { ans = ans * A [ i ] ; ans = ans % P ; } return ans ; } let A = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; let P = 229 ; let L = 2 , R = 5 ; document . write ( calculateProduct ( A , L , R , P ) + " " ) ; L = 1 ; R = 3 ; document . write ( calculateProduct ( A , L , R , P ) + " " ) ;
let MAX = 10000 ; let prefix = [ ] ; function buildPrefix ( ) { let prime = [ ] ; for ( let p = 1 ; p <= MAX + 1 ; p ++ ) { prime [ p ] = true ; } for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( let p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] ++ ; } } function query ( L , R ) { return prefix [ R ] - prefix [ L - 1 ] ; } buildPrefix ( ) ; let L = 5 , R = 10 ; document . write ( query ( L , R ) + " " ) ; L = 1 ; R = 10 ; document . write ( query ( L , R ) ) ;
function command ( arr , a , b ) { arr [ a ] ^= 1 ; arr [ b + 1 ] ^= 1 ; } function process ( arr , n ) { for ( var k = 1 ; k <= n ; k ++ ) arr [ k ] ^= arr [ k - 1 ] ; } function result ( arr , n ) { for ( var k = 1 ; k <= n ; k ++ ) document . write ( arr [ k ] + " " ) ; } var n = 5 , m = 3 ; var arr = Array ( n + 2 ) . fill ( 0 ) ; command ( arr , 1 , 5 ) ; command ( arr , 2 , 5 ) ; command ( arr , 3 , 5 ) ; process ( arr , n ) ; result ( arr , n ) ;
function probability ( a , b , size1 , size2 ) { let max1 = Number . MIN_VALUE , count1 = 0 ; for ( let i = 0 ; i < size1 ; i ++ ) { if ( a [ i ] > max1 ) { max1 = a [ i ] ; count1 = 1 ; } else if ( a [ i ] == max1 ) { count1 ++ ; } } let max2 = Number . MIN_VALUE , count2 = 0 ; for ( let i = 0 ; i < size2 ; i ++ ) { if ( b [ i ] > max2 ) { max2 = b [ i ] ; count2 = 1 ; } else if ( b [ i ] == max2 ) { count2 ++ ; } } return ( count1 * count2 ) / ( size1 * size2 ) ; } let a = [ 1 , 2 , 3 ] ; let b = [ 1 , 3 , 3 ] ; let size1 = a . length ; let size2 = b . length ; document . write ( probability ( a , b , size1 , size2 ) ) ;
function countDe ( arr , n ) { let v = [ ] ; for ( let i = 0 ; i < n ; i ++ ) v [ i ] = arr [ i ] ; arr . sort ( ) ; let count1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count1 ++ ; arr . reverse ( ) ; let count2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] != v [ i ] ) count2 ++ ; return ( Math . min ( count1 , count2 ) ) ; } let arr = [ 5 , 9 , 21 , 17 , 13 ] ; let n = 5 ; document . write ( " " + countDe ( arr , n ) ) ;
function maxOfSegmentMins ( a , n , k ) { if ( k == 1 ) { a . sort ( ) ; return a [ 0 ] ; } if ( k == 2 ) return Math . max ( a [ 0 ] , a [ n - 1 ] ) ; return a [ n - 1 ] ; } var a = [ - 10 , - 9 , - 8 , 2 , 7 , - 6 , - 5 ] ; var n = a . length ; var k = 2 ; document . write ( maxOfSegmentMins ( a , n , k ) ) ;
function printMinimumProduct ( arr , n ) { let first_min = Math . min ( arr [ 0 ] , arr [ 1 ] ) ; let second_min = Math . max ( arr [ 0 ] , arr [ 1 ] ) ; for ( let i = 2 ; i < n ; i ++ ) { if ( arr [ i ] < first_min ) { second_min = first_min ; first_min = arr [ i ] ; } else if ( arr [ i ] < second_min ) second_min = arr [ i ] ; } return first_min * second_min ; } let a = [ 11 , 8 , 5 , 7 , 5 , 100 ] ; let n = a . length ; document . write ( printMinimumProduct ( a , n ) ) ;
function noOfTriples ( arr , n ) { arr . sort ( ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == arr [ 2 ] ) count ++ ; if ( arr [ 0 ] == arr [ 2 ] ) return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 ; else if ( arr [ 1 ] == arr [ 2 ] ) return ( count - 1 ) * ( count ) / 2 ; return count ; } let arr = [ 1 , 3 , 3 , 4 ] ; let n = arr . length ; document . write ( noOfTriples ( arr , n ) ) ;
function checkReverse ( arr , n ) { let temp = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { temp [ i ] = arr [ i ] ; } temp . sort ( ) ; let front ; for ( front = 0 ; front < n ; front ++ ) { if ( temp [ front ] != arr [ front ] ) { break ; } } let back ; for ( back = n - 1 ; back >= 0 ; back -- ) { if ( temp [ back ] != arr [ back ] ) { break ; } } if ( front >= back ) { return true ; } do { front ++ ; if ( arr [ front - 1 ] < arr [ front ] ) { return false ; } } while ( front != back ) ; return true ; } let arr = [ 1 , 2 , 5 , 4 , 3 ] ; let n = arr . length ; if ( checkReverse ( arr , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function checkReverse ( arr , n ) { if ( n == 1 ) return true ; let i ; for ( i = 1 ; i < n && arr [ i - 1 ] < arr [ i ] ; i ++ ) ; if ( i == n ) return true ; let j = i ; while ( j < n && arr [ j ] < arr [ j - 1 ] ) { if ( i > 1 && arr [ j ] < arr [ i - 2 ] ) return false ; j ++ ; } if ( j == n ) return true ; let k = j ; if ( arr [ k ] < arr [ i - 1 ] ) return false ; while ( k > 1 && k < n ) { if ( arr [ k ] < arr [ k - 1 ] ) return false ; k ++ ; } return true ; } let arr = [ 1 , 3 , 4 , 10 , 9 , 8 ] ; let n = arr . length ; if ( checkReverse ( arr , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function MinOperation ( a , b , n ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] > b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; else if ( a [ i ] < b [ i ] ) result = result + Math . abs ( a [ i ] - b [ i ] ) ; } return result ; } let a = [ 3 , 1 , 1 ] ; let b = [ 1 , 2 , 2 ] ; let n = a . length ; document . write ( MinOperation ( a , b , n ) ) ;
function sortExceptUandL ( a , l , u , n ) { let b = [ ] ; for ( let i = 0 ; i < l ; i ++ ) b [ i ] = a [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) b [ l + ( i - ( u + 1 ) ) ] = a [ i ] ; b . sort ( ) ; for ( let i = 0 ; i < l ; i ++ ) a [ i ] = b [ i ] ; for ( let i = u + 1 ; i < n ; i ++ ) a [ i ] = b [ l + ( i - ( u + 1 ) ) ] ; } let a = [ 5 , 4 , 3 , 12 , 14 , 9 ] ; let n = a . length ; let l = 2 , u = 4 ; sortExceptUandL ( a , l , u , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + " " ) ;
function sortExceptK ( arr , k , n ) { let temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; arr . sort ( function ( a , b ) { return a - b } ) ; let last = arr [ n - 1 ] ; for ( let i = n - 1 ; i > k ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ k ] = last ; temp = arr [ k ] ; arr [ k ] = arr [ n - 1 ] ; arr [ n - 1 ] = temp ; return 0 ; } let a = [ 10 , 4 , 11 , 7 , 6 , 20 ] ; let k = 2 ; let n = a . length ; sortExceptK ( a , k , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + " " ) ;
function maxPartitions ( arr , n ) { let ans = 0 , max_so_far = 0 ; for ( let i = 0 ; i < n ; ++ i ) { max_so_far = Math . max ( max_so_far , arr [ i ] ) ; if ( max_so_far == i ) ans ++ ; } return ans ; } let arr = [ 1 , 0 , 2 , 3 , 4 ] ; let n = arr . length ; document . write ( maxPartitions ( arr , n ) ) ;
function cuttringRopes ( Ropes , n ) { Ropes . sort ( ) ; let singleOperation = 0 ; let cuttingLenght = Ropes [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( Ropes [ i ] - cuttingLenght > 0 ) { document . write ( n - i + " " ) ; cuttingLenght = Ropes [ i ] ; singleOperation ++ ; } } if ( singleOperation == 0 ) document . write ( " " ) ; } let Ropes = [ 5 , 1 , 1 , 2 , 3 , 5 ] ; let n = Ropes . length ; cuttringRopes ( Ropes , n ) ;
function rankify ( A , n ) { var R = [ ... Array ( n ) ] ; for ( var i = 0 ; i < n ; i ++ ) { var r = 1 , s = 1 ; for ( var j = 0 ; j < n ; j ++ ) { if ( j != i && A [ j ] < A [ i ] ) r += 1 ; if ( j != i && A [ j ] == A [ i ] ) s += 1 ; } R [ i ] = parseFloat ( r + parseFloat ( s - 1 ) / parseFloat ( 2 ) ) ; } for ( var i = 0 ; i < n ; i ++ ) document . write ( parseFloat ( R [ i ] ) . toFixed ( 1 ) + " " ) ; } var A = [ 1 , 2 , 5 , 2 , 1 , 25 , 2 ] ; var n = A . length ; for ( var i = 0 ; i < n ; i ++ ) document . write ( A [ i ] + " " ) ; document . write ( " " ) ; rankify ( A , n ) ;
function min_noOf_operation ( arr , n , k ) { let noOfSubtraction ; let res = 0 ; for ( let i = 1 ; i < n ; i ++ ) { noOfSubtraction = 0 ; if ( arr [ i ] > arr [ i - 1 ] ) { noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) noOfSubtraction ++ ; arr [ i ] = arr [ i ] - k * noOfSubtraction ; } res = res + noOfSubtraction ; } return res ; } let arr = [ 1 , 1 , 2 , 3 ] ; let N = 4 ; let k = 5 ; document . write ( Math . floor ( min_noOf_operation ( arr , N , k ) ) ) ;
function maxSum ( arr , n ) { arr . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( arr [ i ] * i ) ; return sum ; } let arr = [ 3 , 5 , 6 , 1 ] ; let n = arr . length ; document . write ( maxSum ( arr , n ) ) ;
function countPairs ( a , n , k ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( a [ j ] - a [ i ] ) < k ) res ++ ; return res ; } var a = [ 1 , 10 , 4 , 2 ] ; var k = 3 ; var n = a . length ; document . write ( countPairs ( a , n , k ) ) ;
function countPairs ( a , n , k ) { a . sort ( ( a , b ) => a - b ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let j = i + 1 ; while ( j < n && a [ j ] - a [ i ] < k ) { res ++ ; j ++ ; } } return res ; } let a = [ 1 , 10 , 4 , 2 ] ; let k = 3 ; let n = a . length ; document . write ( countPairs ( a , n , k ) + " " ) ;
function sumOfMinAbsDifferences ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let sum = 0 ; sum += Math . abs ( arr [ 0 ] - arr [ 1 ] ) ; sum += Math . abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) sum += Math . min ( Math . abs ( arr [ i ] - arr [ i - 1 ] ) , Math . abs ( arr [ i ] - arr [ i + 1 ] ) ) ; return sum ; } let arr = [ 5 , 10 , 1 , 4 , 8 , 7 ] ; let n = arr . length ; document . write ( " " + sumOfMinAbsDifferences ( arr , n ) ) ;
function findSmallestDifference ( A , B , m , n ) { A . sort ( ( a , b ) => a - b ) ; B . sort ( ( a , b ) => a - b ) ; let a = 0 , b = 0 ; let result = Number . MAX_SAFE_INTEGER ; while ( a < m && b < n ) { if ( Math . abs ( A [ a ] - B [ b ] ) < result ) result = Math . abs ( A [ a ] - B [ b ] ) ; if ( A [ a ] < B [ b ] ) a ++ ; else b ++ ; } return result ; } let A = [ 1 , 2 , 11 , 5 ] ; let B = [ 4 , 12 , 19 , 23 , 127 , 235 ] ; let m = A . length ; let n = B . length ; document . write ( findSmallestDifference ( A , B , m , n ) ) ;
function findLarger ( arr , n ) { arr . sort ( ) ; for ( let i = n - 1 ; i >= n / 2 ; i -- ) document . write ( arr [ i ] + " " ) ; } let arr = [ 1 , 3 , 6 , 1 , 0 , 9 ] ; let n = arr . length ; findLarger ( arr , n ) ;
function getMissingNo ( a , n ) { let total = Math . floor ( ( n + 1 ) * ( n + 2 ) / 2 ) ; for ( let i = 0 ; i < n ; i ++ ) total -= a [ i ] ; return total ; } let arr = [ 1 , 2 , 4 , 5 , 6 ] ; let n = arr . length ; let miss = getMissingNo ( arr , n ) ; document . write ( miss ) ;
function countOccurrences ( arr , n , x ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( x == arr [ i ] ) res ++ ; } return res ; } arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] let n = arr . length ; let x = 2 ; document . write ( countOccurrences ( arr , n , x ) ) ;
function binarySearch ( arr , l , r , x ) { if ( r < l ) return - 1 ; var mid = l + parseInt ( ( r - l ) / 2 ) ; if ( arr [ mid ] == x ) return mid ; if ( arr [ mid ] > x ) return binarySearch ( arr , l , mid - 1 , x ) ; return binarySearch ( arr , mid + 1 , r , x ) ; } function countOccurrences ( arr , n , x ) { var ind = binarySearch ( arr , 0 , n - 1 , x ) ; if ( ind == - 1 ) return 0 ; var count = 1 ; var left = ind - 1 ; while ( left >= 0 && arr [ left ] == x ) count ++ , left -- ; var right = ind + 1 ; while ( right < n && arr [ right ] == x ) count ++ , right ++ ; return count ; } var arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] ; var n = arr . length ; var x = 2 ; document . write ( countOccurrences ( arr , n , x ) ) ;
function printClosest ( arr , n , x ) { let res_l = 0 , res_r = 0 ; let l = 0 , r = n - 1 , diff = Number . MAX_VALUE ; while ( r > l ) { if ( Math . abs ( arr [ l ] + arr [ r ] - x ) < diff ) { res_l = l ; res_r = r ; diff = Math . abs ( arr [ l ] + arr [ r ] - x ) ; } if ( arr [ l ] + arr [ r ] > x ) r -- ; else l ++ ; } document . write ( " " + arr [ res_l ] + " " + arr [ res_r ] ) ; } let arr = [ 10 , 22 , 28 , 29 , 30 , 40 ] , x = 54 ; let n = arr . length ; printClosest ( arr , n , x ) ;
function countOnes ( arr , low , high ) { if ( high >= low ) { let mid = Math . trunc ( low + ( high - low ) / 2 ) ; if ( ( mid == high arr [ mid + 1 ] == 0 ) && ( arr [ mid ] == 1 ) ) return mid + 1 ; if ( arr [ mid ] == 1 ) return countOnes ( arr , ( mid + 1 ) , high ) ; return countOnes ( arr , low , ( mid - 1 ) ) ; } return 0 ; } let arr = [ 1 , 1 , 1 , 1 , 0 , 0 , 0 ] ; let n = arr . length ; document . write ( " " + countOnes ( arr , 0 , n - 1 ) ) ;
function findMissingUtil ( arr1 , arr2 , N ) { if ( N == 1 ) return arr1 [ 0 ] ; if ( arr1 [ 0 ] != arr2 [ 0 ] ) return arr1 [ 0 ] ; let lo = 0 , hi = N - 1 ; while ( lo < hi ) { let mid = parseInt ( ( lo + hi ) / 2 , 10 ) ; if ( arr1 [ mid ] == arr2 [ mid ] ) lo = mid ; else hi = mid ; if ( lo == hi - 1 ) break ; } return arr1 [ hi ] ; } function findMissing ( arr1 , arr2 , M , N ) { if ( N == M - 1 ) document . write ( " " + findMissingUtil ( arr1 , arr2 , M ) + " " ) ; else if ( M == N - 1 ) document . write ( " " + findMissingUtil ( arr2 , arr1 , N ) + " " ) ; else document . write ( " " + " " ) ; } let arr1 = [ 1 , 4 , 5 , 7 , 9 ] ; let arr2 = [ 4 , 5 , 7 , 9 ] ; let M = arr1 . length ; let N = arr2 . length ; findMissing ( arr1 , arr2 , M , N ) ;
function findMissing ( arr1 , arr2 , M , N ) { if ( M != N - 1 && N != M - 1 ) { document . write ( " " ) ; return ; } let res = 0 ; for ( let i = 0 ; i < M ; i ++ ) res = res ^ arr1 [ i ] ; for ( let i = 0 ; i < N ; i ++ ) res = res ^ arr2 [ i ] ; document . write ( " " + res ) ; } let arr1 = [ 4 , 1 , 5 , 9 , 7 ] ; let arr2 = [ 7 , 5 , 9 , 4 ] ; let M = arr1 . length ; let N = arr2 . length ; findMissing ( arr1 , arr2 , M , N ) ;
function printTwoElements ( arr , size ) { var i ; document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { var abs_value = Math . abs ( arr [ i ] ) ; if ( arr [ abs_value - 1 ] > 0 ) arr [ abs_value - 1 ] = - arr [ abs_value - 1 ] ; else document . write ( abs_value ) ; } document . write ( " " ) ; for ( i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > 0 ) document . write ( i + 1 ) ; } } arr = new Array ( 7 , 3 , 4 , 5 , 5 , 6 , 2 ) ; n = arr . length ; printTwoElements ( arr , n ) ;
function findFourElements ( A , n , X ) { for ( let i = 0 ; i < n - 3 ; i ++ ) { for ( let j = i + 1 ; j < n - 2 ; j ++ ) { for ( let k = j + 1 ; k < n - 1 ; k ++ ) { for ( let l = k + 1 ; l < n ; l ++ ) if ( A [ i ] + A [ j ] + A [ k ] + A [ l ] == X ) document . write ( A [ i ] + " " + A [ j ] + " " + A [ k ] + " " + A [ l ] ) ; } } } } let A = [ 10 , 20 , 30 , 40 , 1 , 2 ] ; let n = A . length ; let X = 91 ; findFourElements ( A , n , X ) ;
function search ( arr , n , x ) { let i = 0 ; while ( i < n ) { if ( arr [ i ] == x ) return i ; i = i + Math . abs ( arr [ i ] - x ) ; } document . write ( " " ) ; return - 1 ; } let arr = [ 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 ] ; let n = arr . length ; let x = 3 ; document . write ( " " + x + " " + search ( arr , n , 3 ) ) ;
function thirdLargest ( arr , arr_size ) { if ( arr_size < 3 ) { document . write ( " " ) ; return ; } let first = arr [ 0 ] ; for ( let i = 1 ; i < arr_size ; i ++ ) if ( arr [ i ] > first ) first = arr [ i ] ; let second = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > second && arr [ i ] < first ) second = arr [ i ] ; let third = Number . MIN_VALUE ; for ( let i = 0 ; i < arr_size ; i ++ ) if ( arr [ i ] > third && arr [ i ] < second ) third = arr [ i ] ; document . write ( " " + " " , third ) ; } let arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] ; let n = arr . length ; thirdLargest ( arr , n ) ;
function thirdLargest ( arr , arr_size ) { if ( arr_size < 3 ) { document . write ( " " ) ; return ; } var first = arr [ 0 ] , second = - 1000000000 , third = - 1000000000 ; for ( var i = 1 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { third = second ; second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second ) { third = second ; second = arr [ i ] ; } else if ( arr [ i ] > third ) third = arr [ i ] ; } document . write ( " " + third ) ; } var arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] ; var n = arr . length ; thirdLargest ( arr , n ) ;
function checkPair ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } if ( sum % 2 != 0 ) { return false ; } sum = Math . floor ( sum / 2 ) ; let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let val = sum - arr [ i ] ; if ( ! s . has ( arr [ i ] ) ) { s . add ( arr [ i ] ) } if ( s . has ( val ) ) { document . write ( " " + arr [ i ] + " " + val + " " ) ; return true ; } s . add ( arr [ i ] ) ; } return false ; } let arr = [ 2 , 11 , 5 , 1 , 4 , 7 ] ; let n = arr . length ; if ( checkPair ( arr , n ) == false ) { document . write ( " " ) ; }
function search ( arr , n , x ) { if ( arr [ n - 1 ] == x ) return " " ; let backup = arr [ n - 1 ] ; arr [ n - 1 ] = x ; for ( let i = 0 ; ; i ++ ) { if ( arr [ i ] == x ) { arr [ n - 1 ] = backup ; if ( i < n - 1 ) return " " ; return " " ; } } } let arr = [ 4 , 6 , 1 , 5 , 8 ] ; let n = arr . length ; let x = 1 ; document . write ( search ( arr , n , x ) ) ;
function findMajority ( arr , n ) { return arr [ Math . floor ( n / 2 ) ] ; } let arr = [ 1 , 2 , 2 , 3 ] ; let n = arr . length ; document . write ( findMajority ( arr , n ) ) ;
function minAdjDifference ( arr , n ) { if ( n < 2 ) return ; let res = Math . abs ( arr [ 1 ] - arr [ 0 ] ) ; for ( let i = 2 ; i < n ; i ++ ) res = Math . min ( res , Math . abs ( arr [ i ] - arr [ i - 1 ] ) ) ; res = Math . min ( res , Math . abs ( arr [ n - 1 ] - arr [ 0 ] ) ) ; document . write ( " " + res ) ; } let a = [ 10 , 12 , 13 , 15 , 10 ] ; let n = a . length ; minAdjDifference ( a , n ) ;
let MAX = 100000 function Print3Smallest ( array , n ) { let firstmin = MAX , secmin = MAX , thirdmin = MAX ; for ( let i = 0 ; i < n ; i ++ ) { if ( array [ i ] < firstmin ) { thirdmin = secmin ; secmin = firstmin ; firstmin = array [ i ] ; } else if ( array [ i ] < secmin ) { thirdmin = secmin ; secmin = array [ i ] ; } else if ( array [ i ] < thirdmin ) thirdmin = array [ i ] ; } document . write ( " " + firstmin + " " ) ; document . write ( " " + secmin + " " ) ; document . write ( " " + thirdmin + " " ) ; } let array = [ 4 , 9 , 1 , 32 , 12 ] ; let n = array . length ; Print3Smallest ( array , n ) ;
function getMin ( arr , n ) { return Math . min . apply ( Math , arr ) ; } function getMax ( arr , n ) { return Math . max . apply ( Math , arr ) ; } var arr = [ 12 , 1234 , 45 , 67 , 1 ] ; var n = arr . length ; document . write ( " " + getMin ( arr , n ) + " " ) ; document . write ( " " + getMax ( arr , n ) ) ;
function printfrequency ( arr , n ) { for ( let j = 0 ; j < n ; j ++ ) arr [ j ] = arr [ j ] - 1 ; for ( let i = 0 ; i < n ; i ++ ) arr [ arr [ i ] % n ] = arr [ arr [ i ] % n ] + n ; for ( let i = 0 ; i < n ; i ++ ) document . write ( ( i + 1 ) + " " + parseInt ( arr [ i ] / n , 10 ) + " " ) ; } let arr = [ 2 , 3 , 3 , 2 , 5 ] ; let n = arr . length ; printfrequency ( arr , n ) ;
function getInvCount ( arr , n ) { let invcount = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let small = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] > arr [ j ] ) small ++ ; let great = 0 ; for ( let j = i - 1 ; j >= 0 ; j -- ) if ( arr [ i ] < arr [ j ] ) great ++ ; invcount += great * small ; } return invcount ; } let arr = [ 8 , 4 , 2 , 1 ] ; let n = arr . length ; document . write ( " " + getInvCount ( arr , n ) ) ;
let arr = [ 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 ] ; function findWater ( n ) { let left = new Array ( n ) ; let right = new Array ( n ) ; let water = 0 ; left [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) left [ i ] = Math . max ( left [ i - 1 ] , arr [ i ] ) ; right [ n - 1 ] = arr [ n - 1 ] ; for ( let i = n - 2 ; i >= 0 ; i -- ) right [ i ] = Math . max ( right [ i + 1 ] , arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) water += Math . min ( left [ i ] , right [ i ] ) - arr [ i ] ; return water ; } document . write ( " " + findWater ( arr . length ) ) ;
function findWater ( arr , n ) { let result = 0 ; let left_max = 0 , right_max = 0 ; let lo = 0 , hi = n - 1 ; while ( lo <= hi ) { if ( arr [ lo ] < arr [ hi ] ) { if ( arr [ lo ] > left_max ) left_max = arr [ lo ] ; else result += left_max - arr [ lo ] ; lo ++ ; } else { if ( arr [ hi ] > right_max ) right_max = arr [ hi ] ; else result += right_max - arr [ hi ] ; hi -- ; } } return result ; } let arr = [ 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 ] ; let n = arr . length ; document . write ( " " + " " + findWater ( arr , n ) ) ;
let a = [ 900 ] ; let b = [ 10 , 13 , 14 ] ; function maximum ( a , b ) { return a > b ? a : b ; } function minimum ( a , b ) { return a < b ? a : b ; } function findMedianSortedArrays ( n , m ) { let min_index = 0 , max_index = n , i = 0 , j = 0 , median = 0 ; while ( min_index <= max_index ) { i = Math . floor ( ( min_index + max_index ) / 2 ) ; j = Math . floor ( ( n + m + 1 ) / 2 ) - i ; if ( i < n && j > 0 && b [ j - 1 ] > a [ i ] ) min_index = i + 1 ; else if ( i > 0 && j < m && b [ j ] < a [ i - 1 ] ) max_index = i - 1 ; else { if ( i == 0 ) median = b [ j - 1 ] ; else if ( j == 0 ) median = a [ i - 1 ] ; else median = maximum ( a [ i - 1 ] , b [ j - 1 ] ) ; break ; } } if ( ( n + m ) % 2 == 1 ) return median ; if ( i == n ) return ( median + b [ j ] ) / 2.0 ; if ( j == m ) return ( median + a [ i ] ) / 2.0 ; return ( median + minimum ( a [ i ] , b [ j ] ) ) / 2.0 ; } let n = a . length ; let m = b . length ; if ( n < m ) document . write ( " " + findMedianSortedArrays ( n , m ) ) ; else document . write ( " " + findMedianSortedArrays ( m , n ) ) ;
function prletUncommon ( arr1 , arr2 , n1 , n2 ) { let i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) { document . write ( arr1 [ i ] + " " ) ; i ++ ; k ++ ; } else if ( arr2 [ j ] < arr1 [ i ] ) { document . write ( arr2 [ j ] + " " ) ; k ++ ; j ++ ; } else { i ++ ; j ++ ; } } while ( i < n1 ) { document . write ( arr1 [ i ] + " " ) ; i ++ ; k ++ ; } while ( j < n2 ) { document . write ( arr2 [ j ] + " " ) ; j ++ ; k ++ ; } } let arr1 = [ 10 , 20 , 30 ] ; let arr2 = [ 20 , 25 , 30 , 40 , 50 ] ; let n1 = arr1 . length ; let n2 = arr2 . length ; prletUncommon ( arr1 , arr2 , n1 , n2 ) ;
function leastFrequent ( arr , n ) { arr . sort ( ) ; let min_count = n + 1 , res = - 1 ; let curr_count = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) curr_count ++ ; else { if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ i - 1 ] ; } curr_count = 1 ; } } if ( curr_count < min_count ) { min_count = curr_count ; res = arr [ n - 1 ] ; } return res ; } let arr = [ 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 ] ; let n = arr . length ; document . write ( leastFrequent ( arr , n ) ) ;
let M = 4 ; function maximumSum ( a , n ) { let prev = Math . max ( a [ n - 1 ] [ 0 ] , a [ n - 1 ] [ M - 1 ] + 1 ) ; let sum = prev ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let max_smaller = Number . MIN_VALUE ; for ( let j = M - 1 ; j >= 0 ; j -- ) { if ( a [ i ] [ j ] < prev && a [ i ] [ j ] > max_smaller ) max_smaller = a [ i ] [ j ] ; } if ( max_smaller == Number . MIN_VALUE ) return 0 ; prev = max_smaller ; sum += max_smaller ; } return sum ; } let arr = [ [ 1 , 7 , 3 , 4 ] , [ 4 , 2 , 5 , 1 ] , [ 9 , 5 , 1 , 8 ] ] ; let n = arr . length ; document . write ( maximumSum ( arr , n ) ) ;
function countPairs ( A , n , k ) { var ans = 0 ; A . sort ( ( a , b ) => a - b ) for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i + 1 ; j < n ; j ++ ) { var x = 0 ; while ( ( A [ i ] * Math . pow ( k , x ) ) <= A [ j ] ) { if ( ( A [ i ] * Math . pow ( k , x ) ) == A [ j ] ) { ans ++ ; break ; } x ++ ; } } } return ans ; } var A = [ 3 , 8 , 9 , 12 , 18 , 4 , 24 , 2 , 6 ] ; var n = A . length ; var k = 3 ; document . write ( countPairs ( A , n , k ) ) ;
function minDistance ( arr , n ) { let maximum_element = arr [ 0 ] ; let min_dis = n ; let index = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( maximum_element == arr [ i ] ) { min_dis = Math . min ( min_dis , ( i - index ) ) ; index = i ; } else if ( maximum_element < arr [ i ] ) { maximum_element = arr [ i ] ; min_dis = n ; index = i ; } else continue ; } return min_dis ; } let arr = [ 6 , 3 , 1 , 3 , 6 , 4 , 6 ] ; let n = arr . length ; document . write ( " " + minDistance ( arr , n ) ) ;
function findValue ( arr , n , k ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == k ) k *= 2 ; return k ; } let arr = [ 2 , 3 , 4 , 10 , 8 , 1 ] , k = 2 ; let n = arr . length ; document . write ( findValue ( arr , n , k ) ) ;
function dupLastIndex ( arr , n ) { if ( arr == null n <= 0 ) return ; for ( let i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] == arr [ i - 1 ] ) { document . write ( " " + i + " " ) ; document . write ( " " + arr [ i ] + " " ) ; return ; } } document . write ( " " ) ; } let arr = [ 1 , 5 , 5 , 6 , 6 , 7 , 9 ] ; let n = arr . length ; dupLastIndex ( arr , n ) ;
function findSmallest ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < n ; j ++ ) if ( a [ j ] % a [ i ] >= 1 ) break ; if ( j == n ) return a [ i ] ; } return - 1 ; } let a = [ 25 , 20 , 5 , 10 , 100 ] ; let n = a . length ; document . write ( findSmallest ( a , n ) ) ;
function min_element ( a ) { let min = Number . MAX_VALUE ; let i ; for ( i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return min ; } function findSmallest ( a , n ) { let smallest = min_element ( a ) ; for ( let i = 1 ; i < n ; i ++ ) if ( a [ i ] % smallest >= 1 ) return - 1 ; return smallest ; } let a = [ 25 , 20 , 5 , 10 , 100 ] ; let n = a . length ; document . write ( findSmallest ( a , n ) ) ;
function findIndex ( arr , len ) { let maxIndex = 0 ; for ( let i = 0 ; i < len ; ++ i ) if ( arr [ i ] > arr [ maxIndex ] ) maxIndex = i ; for ( let i = 0 ; i < len ; ++ i ) if ( maxIndex != i && arr [ maxIndex ] < 2 * arr [ i ] ) return - 1 ; return maxIndex ; } let arr = [ 3 , 6 , 1 , 0 ] ; let len = arr . length ; document . write ( findIndex ( arr , len ) ) ;
function find_consecutive_steps ( arr , len ) { let count = 0 ; let maximum = 0 ; for ( let index = 1 ; index < len ; index ++ ) { if ( arr [ index ] > arr [ index - 1 ] ) count ++ ; else { maximum = Math . max ( maximum , count ) ; count = 0 ; } } return Math . max ( maximum , count ) ; } let arr = [ 1 , 2 , 3 , 4 ] ; let len = arr . length ; document . write ( find_consecutive_steps ( arr , len ) ) ;
function CalculateMax ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let min_sum = arr [ 0 ] + arr [ 1 ] ; let max_sum = arr [ n - 1 ] + arr [ n - 2 ] ; return ( Math . abs ( max_sum - min_sum ) ) ; } let arr = [ 6 , 7 , 1 , 11 ] ; let n = arr . length ; document . write ( CalculateMax ( arr , n ) ) ;
function calculate ( a , n ) { a . sort ( ) ; let i , j ; let s = [ ] ; for ( i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) s . push ( ( a [ i ] + a [ j ] ) ) ; let mini = Math . min ( ... s ) ; let maxi = Math . max ( ... s ) ; return Math . abs ( maxi - mini ) ; } let a = [ 2 , 6 , 4 , 3 ] ; let n = a . length ; document . write ( calculate ( a , n ) ) ;
function printMinDiffPairs ( arr , n ) { if ( n <= 1 ) return ; arr . sort ( ) ; let minDiff = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) minDiff = Math . min ( minDiff , arr [ i ] - arr [ i - 1 ] ) ; for ( let i = 1 ; i < n ; i ++ ) { if ( ( arr [ i ] - arr [ i - 1 ] ) == minDiff ) { document . write ( " " + arr [ i - 1 ] + " " + arr [ i ] + " " ) ; } } } let arr = [ 5 , 3 , 2 , 4 , 1 ] ; let n = arr . length ; printMinDiffPairs ( arr , n ) ;
let MAX = 256 ; function calculateDiff ( i , j , array ) { return Math . abs ( array [ i ] - array [ j ] ) + Math . abs ( i - j ) ; } function maxDistance ( array ) { let result = 0 ; for ( let i = 0 ; i < array . length ; i ++ ) { for ( let j = i ; j < array . length ; j ++ ) { result = Math . max ( result , calculateDiff ( i , j , array ) ) ; } } return result ; } let array = [ - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 ] ; document . write ( maxDistance ( array ) ) ;
function maxDistance ( array ) { let max1 = Number . MIN_VALUE ; let min1 = Number . MAX_VALUE ; let max2 = Number . MIN_VALUE ; let min2 = Number . MAX_VALUE ; for ( let i = 0 ; i < array . length ; i ++ ) { max1 = Math . max ( max1 , array [ i ] + i ) ; min1 = Math . min ( min1 , array [ i ] + i ) ; max2 = Math . max ( max2 , array [ i ] - i ) ; min2 = Math . min ( min2 , array [ i ] - i ) ; } return Math . max ( max1 - min1 , max2 - min2 ) ; } let array = [ - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 ] ; document . write ( maxDistance ( array ) ) ;
function extrema ( a , n ) { let count = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( a [ i ] > a [ i - 1 ] && a [ i ] > a [ i + 1 ] ) count += 1 ; if ( a [ i ] < a [ i - 1 ] && a [ i ] < a [ i + 1 ] ) count += 1 ; } return count ; } let a = [ 1 , 0 , 2 , 1 ] ; let n = a . length ; document . write ( extrema ( a , n ) ) ;
function findClosest ( arr , target ) { let n = arr . length ; if ( target <= arr [ 0 ] ) return arr [ 0 ] ; if ( target >= arr [ n - 1 ] ) return arr [ n - 1 ] ; let i = 0 , j = n , mid = 0 ; while ( i < j ) { mid = ( i + j ) / 2 ; if ( arr [ mid ] == target ) return arr [ mid ] ; if ( target < arr [ mid ] ) { if ( mid > 0 && target > arr [ mid - 1 ] ) return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) ; j = mid ; } else { if ( mid < n - 1 && target < arr [ mid + 1 ] ) return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) ; i = mid + 1 ; } } return arr [ mid ] ; } function getClosest ( val1 , val2 , target ) { if ( target - val1 >= val2 - target ) return val2 ; else return val1 ; } let arr = [ 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 ] ; let target = 11 ; document . write ( findClosest ( arr , target ) ) ;
function sum ( a , n ) { let maxSum = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) maxSum = Math . max ( maxSum , a [ i ] + a [ j ] ) ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( a [ i ] + a [ j ] == maxSum ) c ++ ; return c ; } let array = [ 1 , 1 , 1 , 2 , 2 , 2 ] ; let n = array . length ; document . write ( sum ( array , n ) ) ;
function sum ( a , n ) { let maxVal = a [ 0 ] , maxCount = 1 ; let secondMax = Number . MIN_VALUE ; let secondMaxCount = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == maxVal ) maxCount ++ ; else if ( a [ i ] > maxVal ) { secondMax = maxVal ; secondMaxCount = maxCount ; maxVal = a [ i ] ; maxCount = 1 ; } else if ( a [ i ] == secondMax ) { secondMax = a [ i ] ; secondMaxCount ++ ; } else if ( a [ i ] > secondMax ) { secondMax = a [ i ] ; secondMaxCount = 1 ; } } if ( maxCount > 1 ) return maxCount * parseInt ( ( maxCount - 1 ) / 2 , 10 ) ; return secondMaxCount ; } let array = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 ] ; let n = array . length ; document . write ( sum ( array , n ) ) ;
function printKMissing ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) ; let i = 0 ; while ( i < n && arr [ i ] <= 0 ) i ++ ; let count = 0 , curr = 1 ; while ( count < k && i < n ) { if ( arr [ i ] != curr ) { document . write ( curr + " " ) ; count ++ ; } else i ++ ; curr ++ ; } while ( count < k ) { document . write ( curr , " " ) ; curr ++ ; count ++ ; } } let arr = new Array ( 2 , 3 , 4 ) ; let n = arr . length ; let k = 3 ; printKMissing ( arr , n , k ) ;
function nobleInteger ( arr ) { let size = arr . length ; for ( let i = 0 ; i < size ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < size ; j ++ ) if ( arr [ i ] < arr [ j ] ) count ++ ; if ( count == arr [ i ] ) return arr [ i ] ; } return - 1 ; } let arr = [ 10 , 3 , 20 , 40 , 2 ] ; let res = nobleInteger ( arr ) ; if ( res != - 1 ) document . write ( " " + " " + res ) ; else document . write ( " " + " " ) ;
function nobleInteger ( arr ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let n = arr . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( arr [ i ] == arr [ i + 1 ] ) continue ; if ( arr [ i ] == n - i - 1 ) return arr [ i ] ; } if ( arr [ n - 1 ] == 0 ) return arr [ n - 1 ] ; return - 1 ; } let arr = [ 10 , 3 , 20 , 40 , 2 ] ; let res = nobleInteger ( arr ) ; if ( res != - 1 ) document . write ( " " + res ) ; else document . write ( " " ) ;
function findMinSum ( a , b , n ) { a . sort ( ) ; b . sort ( ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + Math . abs ( a [ i ] - b [ i ] ) ; return sum ; } let a = [ 4 , 1 , 8 , 7 ] ; let b = [ 2 , 3 , 6 , 5 ] ; let n = a . length ; document . write ( findMinSum ( a , b , n ) ) ;
function minProductSubset ( a , n ) { if ( n == 1 ) return a [ 0 ] ; let negmax = Number . MIN_VALUE ; let posmin = Number . MIN_VALUE ; let count_neg = 0 , count_zero = 0 ; let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; negmax = Math . max ( negmax , a [ i ] ) ; } if ( a [ i ] > 0 && a [ i ] < posmin ) { posmin = a [ i ] ; } product *= a [ i ] ; } if ( count_zero == n || ( count_neg == 0 && count_zero > 0 ) ) return 0 ; if ( count_neg == 0 ) return posmin ; if ( count_neg % 2 == 0 && count_neg != 0 ) { product = parseInt ( product / negmax , 10 ) ; } return product ; } let a = [ - 1 , - 1 , - 2 , 4 , 3 ] ; let n = 5 ; document . write ( minProductSubset ( a , n ) ) ;
function binary_search ( a , x , lo = 0 , hi = null ) { if ( hi == null ) hi = a . length ; while ( lo < hi ) { mid = Math . floor ( ( lo + hi ) / 2 ) ; midval = a [ mid ] ; if ( midval < x ) lo = mid + 1 ; else if ( midval > x ) hi = mid ; else return mid ; } return - 1 ; } function findElement ( a , n , b ) { a . sort ( ( a , b ) => a - b ) ; let max = a [ n - 1 ] ; while ( b < max ) { if ( binary_search ( a , a + n , b ) ) b *= 2 ; else return b ; } return b ; } let a = [ 1 , 2 , 3 ] ; let n = a . length ; let b = 1 ; document . write ( findElement ( a , n , b ) ) ;
let Mod = 1000000007 ; function findSum ( arr , n ) { let sum = 0 ; arr . sort ( ) ; let i = 0 ; while ( i < n && arr [ i ] < 0 ) { if ( i != n - 1 && arr [ i + 1 ] <= 0 ) { sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod ; i += 2 ; } else break ; } let j = n - 1 ; while ( j >= 0 && arr [ j ] > 0 ) { if ( j != 0 && arr [ j - 1 ] > 0 ) { sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod ; j -= 2 ; } else break ; } if ( j > i ) sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod ; else if ( i == j ) sum = ( sum + arr [ i ] ) % Mod ; return sum ; } let arr = [ - 1 , 9 , 4 , 5 , - 4 , 7 ] ; let n = arr . length ; document . write ( findSum ( arr , n ) ) ;
function countOddRotations ( n ) { var odd_count = 0 , even_count = 0 ; do { var digit = n % 10 ; if ( digit % 2 == 1 ) odd_count ++ ; else even_count ++ ; n = parseInt ( n / 10 ) ; } while ( n != 0 ) ; document . write ( " " + odd_count + " " ) ; document . write ( " " + even_count + " " ) ; } var n = 1234 ; countOddRotations ( n ) ;
function numberOfDigits ( n ) { let cnt = 0 ; while ( n > 0 ) { cnt ++ ; n = parseInt ( n / 10 , 10 ) ; } return cnt ; } function cal ( num ) { let digits = numberOfDigits ( num ) ; let powTen = Math . pow ( 10 , digits - 1 ) ; for ( let i = 0 ; i < digits - 1 ; i ++ ) { let firstDigit = parseInt ( num / powTen , 10 ) ; let left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; document . write ( left + " " ) ; num = left ; } } let num = 1445 ; cal ( num ) ;
function CheckKCycles ( n , s ) { var ff = true ; var x = 0 ; for ( i = 1 ; i < n ; i ++ ) { x = ( s . substring ( i ) + s . substring ( 0 , i ) ) . length ; if ( x >= s . length ) { continue ; } ff = false ; break ; } if ( ff ) { document . write ( " " ) ; } else { document . write ( " " ) ; } } var n = 3 ; var s = " " ; CheckKCycles ( n , s ) ;
function rightRotationDivisor ( N ) { let lastDigit = N % 10 ; let rightRotation = ( lastDigit * Math . pow ( 10 , Math . floor ( ( Math . log10 ( N ) ) ) ) + Math . floor ( N / 10 ) ) ; return ( rightRotation % N == 0 ) ; } function generateNumbers ( m ) { for ( let i = Math . floor ( Math . pow ( 10 , ( m - 1 ) ) ) ; i < Math . floor ( Math . pow ( 10 , m ) ) ; i ++ ) if ( rightRotationDivisor ( i ) ) document . write ( i + " " ) ; } let m = 3 ; generateNumbers ( m ) ;
let minIndex = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < minEle ) { minEle = arr [ i ] ; minIndex = i ; } } let flag1 = true ; for ( let i = 1 ; i < minIndex ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag1 = false ; break ; } } let flag2 = true ; for ( let i = minIndex + 1 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] ) { flag2 = false ; break ; } } if ( flag1 && flag2 && ( arr [ n - 1 ] < arr [ 0 ] ) ) document . write ( " " ) ; else document . write ( " " ) ; } let arr = [ 3 , 4 , 5 , 1 , 2 ] ; let n = arr . length ; checkIfSortRotated ( arr , n ) ;
function occurredOnce ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; if ( arr [ 0 ] != arr [ 1 ] ) document . write ( arr [ 0 ] + " " ) ; for ( let i = 1 ; i < n - 1 ; i ++ ) if ( arr [ i ] != arr [ i + 1 ] && arr [ i ] != arr [ i - 1 ] ) document . write ( arr [ i ] + " " ) ; if ( arr [ n - 2 ] != arr [ n - 1 ] ) document . write ( arr [ n - 1 ] + " " ) ; } let arr = [ 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 ] ; let n = arr . length ; occurredOnce ( arr , n ) ;
function occurredOnce ( arr , n ) { var i = 1 , len = n ; if ( arr [ 0 ] == arr [ len - 1 ] ) { i = 2 ; len -- ; } for ( ; i < n ; i ++ ) if ( arr [ i ] == arr [ i - 1 ] ) i ++ ; else document . write ( arr [ i - 1 ] + " " ) ; if ( arr [ n - 1 ] != arr [ 0 ] && arr [ n - 1 ] != arr [ n - 2 ] ) document . write ( arr [ n - 1 ] ) ; } var arr = [ 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 ] ; var n = arr . length ; occurredOnce ( arr , n ) ;
function rvereseArray ( arr , start , end ) { while ( start < end ) { let temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; start ++ ; end -- ; } } function printArray ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + " " ) ; } function splitArr ( arr , k , n ) { rvereseArray ( arr , 0 , n - 1 ) ; rvereseArray ( arr , 0 , n - k - 1 ) ; rvereseArray ( arr , n - k , n - 1 ) ; } let arr = new Array ( 12 , 10 , 5 , 6 , 52 , 36 ) ; let n = arr . length ; let k = 2 ; splitArr ( arr , k , n ) ; printArray ( arr , n ) ;
function countRotationsDivBy8 ( n ) { let len = n . length ; let count = 0 ; if ( len == 1 ) { let oneDigit = n [ 0 ] - ' ' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { let first = ( n [ 0 ] - ' ' ) * 10 + ( n [ 1 ] - ' ' ) ; let second = ( n [ 1 ] - ' ' ) * 10 + ( n [ 0 ] - ' ' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } let threeDigit ; for ( let i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n [ i ] - ' ' ) * 100 + ( n [ i + 1 ] - ' ' ) * 10 + ( n [ i + 2 ] - ' ' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n [ len - 1 ] - ' ' ) * 100 + ( n [ 0 ] - ' ' ) * 10 + ( n [ 1 ] - ' ' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n [ len - 2 ] - ' ' ) * 100 + ( n [ len - 1 ] - ' ' ) * 10 + ( n [ 0 ] - ' ' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; } let n = " " ; document . write ( " " + countRotationsDivBy8 ( n ) ) ;
function isRotation ( x , y ) { var x64 = x | ( x << 32 ) ; while ( x64 >= y ) { if ( x64 == y ) { return true ; } x64 >>= 1 ; } return false ; } var x = 122 ; var y = 2147483678 ; if ( isRotation ( x , y ) == false ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function countRotations ( n ) { let len = n . length ; if ( len == 1 ) { let oneDigit = n [ 0 ] - ' ' ; if ( oneDigit % 4 == 0 ) return 1 ; return 0 ; } let twoDigit ; let count = 0 ; for ( let i = 0 ; i < ( len - 1 ) ; i ++ ) { twoDigit = ( n [ i ] - ' ' ) * 10 + ( n [ i + 1 ] - ' ' ) ; if ( twoDigit % 4 == 0 ) count ++ ; } twoDigit = ( n [ len - 1 ] - ' ' ) * 10 + ( n [ 0 ] - ' ' ) ; if ( twoDigit % 4 == 0 ) count ++ ; return count ; } let n = " " ; document . write ( " " + countRotations ( n ) ) ;
function maxLength ( a , n ) { let sum = 0 , len = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; return n ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) len = Math . max ( len , Math . max ( n - i - 1 , i ) ) ; } return len ; } let a = [ 1 , 2 , 3 , 2 ] ; let n = a . length ; document . write ( maxLength ( a , n ) + " " ) ;
function solve ( n ) { let initial_array = new Array ( n - 1 ) ; for ( var i = 0 ; i < initial_array . length ; i ++ ) { initial_array [ i ] = new Array ( 2 ) ; } let final_array = new Array ( n ) ; for ( var i = 0 ; i < final_array . length ; i ++ ) { final_array [ i ] = new Array ( 2 ) ; } for ( let i = 0 ; i < n - 1 ; ++ i ) initial_array [ 0 ] [ i ] = i + 1 ; for ( let i = 1 ; i < n - 1 ; ++ i ) for ( let j = 0 ; j < n - 1 ; ++ j ) initial_array [ i ] [ j ] = initial_array [ i - 1 ] [ ( j + 1 ) % ( n - 1 ) ] ; for ( let i = 0 ; i < n - 1 ; ++ i ) for ( let j = 0 ; j < n - 1 ; ++ j ) final_array [ i ] [ j ] = initial_array [ i ] [ j ] ; for ( let i = 0 ; i < n ; ++ i ) final_array [ i ] [ n - 1 ] = final_array [ n - 1 ] [ i ] = 0 ; for ( let i = 0 ; i < n ; ++ i ) { let t0 = final_array [ i ] [ i ] ; let t1 = final_array [ i ] [ n - 1 ] ; let s = final_array [ i ] [ i ] ; final_array [ i ] [ i ] = final_array [ i ] [ n - 1 ] ; final_array [ i ] [ n - 1 ] = s ; final_array [ n - 1 ] [ i ] = t0 ; } for ( let i = 0 ; i < n ; ++ i ) { for ( let j = 0 ; j < n ; ++ j ) document . write ( final_array [ i ] [ j ] + " " ) ; document . write ( " " ) ; } } let n = 5 ; solve ( n ) ;
function getMinVal ( p , q ) { if ( q % p == 0 ) return p ; return - 1 ; } let p = 24 , q = 48 ; document . write ( getMinVal ( p , q ) ) ;
function isPalindrome ( str , i , j ) { while ( i < j ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; j -- ; } return true ; } function countPrimePalindrome ( str , len ) { var prime = Array ( len + 1 ) . fill ( true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( var p = 2 ; p * p <= len ; p ++ ) { if ( prime [ p ] ) { for ( var i = p * p ; i <= len ; i += p ) prime [ i ] = false ; } } var count = 0 ; for ( var j = 2 ; j <= len ; j ++ ) { if ( prime [ j ] ) { for ( var i = 0 ; i + j - 1 < len ; i ++ ) { if ( isPalindrome ( str , i , i + j - 1 ) ) count ++ ; } } } return count ; } var s = " " ; var len = s . length ; document . write ( countPrimePalindrome ( s , len ) ) ;
function minOperations ( N ) { var x = Math . log ( N ) / Math . log ( 2 ) ; var ans = parseInt ( ( Math . ceil ( x ) ) ) ; return ans ; } var N = 10 ; document . write ( minOperations ( N ) ) ;
function find_greatest_divisor ( l , r ) { if ( l == r ) return l ; return 1 ; } let l = 2 ; let r = 12 ; document . write ( find_greatest_divisor ( l , r ) ) ;
function getProbability ( p , q ) { p /= 100 ; q /= 100 ; let probability = ( p * p + q * q ) / ( p + q ) ; return probability ; } let p = 80.0 ; let q = 40.0 ; document . write ( getProbability ( p , q ) . toPrecision ( 15 ) ) ;
function check ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & 1 ) return true ; } return false ; } let arr = [ 3 , 9 , 12 , 13 , 15 ] ; let n = arr . length ; if ( check ( arr , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function _log ( x , base ) { return ( Math . log ( x ) / Math . log ( base ) ) ; } function recursiveLogStar ( n , b ) { if ( n > 1.0 ) return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) ; else return 0 ; } let n = 100 , base = 5 ; document . write ( " " + n + " " + recursiveLogStar ( n , base ) ) ;
function isPossible ( box , truck , n , m , min_time ) { let temp = 0 ; let count = 0 ; while ( count < m ) { for ( let j = 0 ; j < min_time && temp < n && truck [ count ] >= box [ temp ] ; j += 2 ) temp ++ ; count ++ ; } if ( temp == n ) return true ; return false ; } function minTime ( box , truck , n , m ) { box . sort ( function ( a , b ) { return a - b } ) ; truck . sort ( function ( a , b ) { return a - b } ) ; let l = 0 ; let h = 2 * n ; let min_time = 0 ; while ( l <= h ) { let mid = Math . floor ( ( l + h ) / 2 ) ; if ( isPossible ( box , truck , n , m , mid ) ) { min_time = mid ; h = mid - 1 ; } else l = mid + 1 ; } return min_time ; } let box = [ 10 , 2 , 16 , 19 ] ; let truck = [ 29 , 25 ] ; let n = box . length ; let m = truck . length ; document . write ( minTime ( box , truck , n , m ) ) ;
function isPossible ( arr , n , dist , k ) { let req = 0 ; let curr = 0 ; let prev = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( curr != n && arr [ curr ] - arr [ prev ] <= dist ) { curr ++ ; } req ++ ; if ( curr == n ) { break ; } prev = curr - 1 ; } if ( curr != n ) { return false ; } if ( req <= k ) { return true ; } return false ; } function minDistance ( arr , n , k ) { let l = 0 ; let h = arr [ n - 1 ] ; let ans = 0 ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( isPossible ( arr , n , m , k ) ) { ans = m ; h = m - 1 ; } else { l = m + 1 ; } } return ans ; } let arr = [ 2 , 15 , 36 , 43 ] ; let n = arr . length ; let k = 2 ; document . write ( minDistance ( arr , n , k ) ) ;
function getKthElement ( n , k , L , R ) { let l = 1 ; let h = n ; let total = new Array ( n + 1 ) ; total [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) { total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 ; } let index = - 1 ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( total [ m ] > k ) { index = m ; h = m - 1 ; } else if ( total [ m ] < k ) l = m + 1 ; else { index = m ; break ; } } l = L [ index - 1 ] ; h = R [ index - 1 ] ; let x = k - total [ index - 1 ] ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( ( m - L [ index - 1 ] ) + 1 == x ) { return m ; } else if ( ( m - L [ index - 1 ] ) + 1 > x ) h = m - 1 ; else l = m + 1 ; } return k ; } let L = [ 1 , 8 , 21 ] ; let R = [ 4 , 10 , 23 ] ; let n = L . length ; let k = 6 ; document . write ( getKthElement ( n , k , L , R ) ) ;
function MinimumX ( a , b , c , k ) { let x = Number . MAX_VALUE ; if ( k <= c ) return 0 ; let h = k - c ; let l = 0 ; while ( l <= h ) { let m = Math . floor ( ( l + h ) / 2 ) ; if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) { x = Math . min ( x , m ) ; h = m - 1 ; } else if ( ( a * m * m ) + ( b * m ) < ( k - c ) ) l = m + 1 ; else return m ; } return x ; } let a = 3 , b = 2 , c = 4 , k = 15 ; document . write ( MinimumX ( a , b , c , k ) ) ;
function findMissing ( arr , n ) { let l = 0 , h = n - 1 ; let mid ; while ( h > l ) { mid = l + Math . floor ( ( h - l ) / 2 ) ; if ( arr [ mid ] - mid == arr [ 0 ] ) { if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) return arr [ mid ] + 1 ; else { l = mid + 1 ; } } else { if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) return arr [ mid ] - 1 ; else { h = mid - 1 ; } } } return - 1 ; } let arr = [ - 9 , - 8 , - 7 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ] ; let n = arr . length ; document . write ( findMissing ( arr , n ) ) ;
function maxSum ( arr , n , K ) { var maximum = - 1000000000 ; for ( var i = 0 ; i < n ; i ++ ) { var sumk = 0 ; for ( var j = i ; j < n ; j += K ) sumk = sumk + arr [ j ] ; maximum = Math . max ( maximum , sumk ) ; } return maximum ; } var arr = [ 3 , 6 , 4 , 7 , 2 ] ; var n = arr . length ; var K = 2 ; document . write ( maxSum ( arr , n , K ) ) ;
function countGreater ( arr , n , k ) { var l = 0 ; var r = n - 1 ; var leftGreater = n ; while ( l <= r ) { var m = l + parseInt ( ( r - l ) / 2 ) ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; } var arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ] ; var n = arr . length ; var k = 7 ; document . write ( countGreater ( arr , n , k ) ) ;
function operations ( op , n , k ) { let i , count = 0 ; let nVal = 0 ; let min = Number . MAX_VALUE ; for ( i = 0 ; i < n ; i ++ ) { nVal += op [ i ] ; min = Math . min ( min , nVal ) ; if ( ( k + nVal ) <= 0 ) return ( i + 1 ) ; } if ( nVal >= 0 ) return - 1 ; let times = Math . floor ( ( k - Math . abs ( min ) ) / Math . abs ( nVal ) ) ; k = ( k - ( times * Math . abs ( nVal ) ) ) ; count = ( times * n ) ; while ( k > 0 ) { for ( i = 0 ; i < n ; i ++ ) { k = k + op [ i ] ; count ++ ; if ( k <= 0 ) break ; } } return count ; } let op = [ - 60 , 65 , - 1 , 14 , - 25 ] ; let n = op . length ; let k = 100000 ; document . write ( operations ( op , n , k ) ) ;
function countFactor ( P , X ) { if ( X < P ) return 0 ; return ( parseInt ( X / P ) + countFactor ( P , parseInt ( X / P ) ) ) ; } function findSmallestX ( Y ) { let low = 0 , high = 5 * Y ; let N = 0 ; while ( low <= high ) { let mid = parseInt ( ( high + low ) / 2 ) ; if ( countFactor ( 5 , mid ) < Y ) { low = mid + 1 ; } else { N = mid ; high = mid - 1 ; } } return N ; } let Y = 10 ; document . write ( findSmallestX ( Y ) ) ;
function squareSum ( N ) { var sum = parseInt ( ( N * ( N + 1 ) * ( 2 * N + 1 ) ) / 6 ) ; return sum ; } function findMaxN ( X ) { var low = 1 , high = 100000 ; var N = 0 ; while ( low <= high ) { var mid = ( high + low ) / 2 ; if ( squareSum ( mid ) <= X ) { N = parseInt ( mid ) ; low = mid + 1 ; } else high = mid - 1 ; } return N ; } var X = 25 ; document . write ( findMaxN ( X ) ) ;
var n = 4 ; function findRing ( arr , x ) { if ( arr [ 0 ] [ 0 ] > x ) return - 1 ; var l = 0 , r = parseInt ( ( n + 1 ) / 2 ) - 1 ; if ( n % 2 == 1 && arr [ r ] [ r ] < x ) return - 1 ; if ( n % 2 == 0 && arr [ r + 1 ] [ r ] < x ) return - 1 ; while ( l < r ) { var mid = parseInt ( ( l + r ) / 2 ) ; if ( arr [ mid ] [ mid ] <= x ) if ( mid == ( n + 1 ) / 2 - 1 arr [ mid + 1 ] [ mid + 1 ] > x ) return mid ; else l = mid + 1 ; else r = mid - 1 ; } return r ; } function binarySearchRowInc ( arr , row , l , r , x ) { while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) l = mid + 1 ; else r = mid - 1 ; } return - 1 ; } function binarySearchColumnInc ( arr , col , t , b , x ) { while ( t <= b ) { var mid = parseInt ( ( t + b ) / 2 ) ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) t = mid + 1 ; else b = mid - 1 ; } return - 1 ; } function binarySearchRowDec ( arr , row , l , r , x ) { while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; if ( arr [ row ] [ mid ] == x ) return mid ; if ( arr [ row ] [ mid ] < x ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } function binarySearchColumnDec ( arr , col , t , b , x ) { while ( t <= b ) { var mid = parseInt ( ( t + b ) / 2 ) ; if ( arr [ mid ] [ col ] == x ) return mid ; if ( arr [ mid ] [ col ] < x ) b = mid - 1 ; else t = mid + 1 ; } return - 1 ; } function spiralBinary ( arr , x ) { var f1 = findRing ( arr , x ) ; var r , c ; if ( f1 == - 1 ) { document . write ( " " ) ; return ; } if ( n % 2 == 1 && f1 == ( n + 1 ) / 2 - 1 ) { document . write ( f1 + " " + f1 + " " ) ; return ; } if ( x < arr [ f1 ] [ n - f1 - 1 ] ) { c = binarySearchRowInc ( arr , f1 , f1 , n - f1 - 2 , x ) ; r = f1 ; } else if ( x < arr [ n - f1 - 1 ] [ n - f1 - 1 ] ) { c = n - f1 - 1 ; r = binarySearchColumnInc ( arr , n - f1 - 1 , f1 , n - f1 - 2 , x ) ; } else if ( x < arr [ n - f1 - 1 ] [ f1 ] ) { c = binarySearchRowDec ( arr , n - f1 - 1 , f1 + 1 , n - f1 - 1 , x ) ; r = n - f1 - 1 ; } else { r = binarySearchColumnDec ( arr , f1 , f1 + 1 , n - f1 - 1 , x ) ; c = f1 ; } if ( c == - 1 r == - 1 ) document . write ( " " ) ; else document . write ( r + " " + c ) ; return ; } var arr = [ [ 1 , 2 , 3 , 4 ] , [ 12 , 13 , 14 , 5 ] , [ 11 , 16 , 15 , 6 ] , [ 10 , 9 , 8 , 7 ] ] ; spiralBinary ( arr , 7 ) ;
function countSubArrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let bitwise_or = 0 ; for ( let k = i ; k <= j ; k ++ ) { bitwise_or = bitwise_or | arr [ k ] ; } if ( bitwise_or >= K ) count ++ ; } } return count ; } let arr = [ 3 , 4 , 5 ] ; let n = arr . length ; let k = 6 ; document . write ( countSubArrays ( arr , n , k ) ) ;
function countPattern ( n , pat ) { let pattern_int = 0 ; let power_two = 1 ; let all_ones = 0 ; for ( let i = pat . length - 1 ; i >= 0 ; i -- ) { let current_bit = pat . charAt ( i ) - ' ' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } let count = 0 ; while ( n != 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; } let n = 500 ; let pat = " " ; document . write ( countPattern ( n , pat ) ) ;
function max_min ( a , n ) { a . sort ( ) ; return Math . min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) ; } let a = [ 1 , 3 , 3 , 7 ] ; let n = a . length ; document . write ( max_min ( a , n ) ) ;
var MAX = 1000001 ; var primeUpto = Array ( MAX ) . fill ( 0 ) ; function SieveOfEratosthenes ( ) { var isPrime = Array ( MAX ) . fill ( 1 ) ; isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( var i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] ) { for ( var j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } } for ( var i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] ) primeUpto [ i ] ++ ; } } function countOfNumbers ( N , K ) { SieveOfEratosthenes ( ) ; var low = 1 , high = N , ans = 0 ; while ( low <= high ) { var mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } return ( ans ? N - ans + 1 : 0 ) ; } var N = 10 , K = 3 ; document . write ( countOfNumbers ( N , K ) ) ;
function minIndex ( arr , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) { if ( 2 * arr [ i ] == sum ) return ( i + 1 ) ; } return - 1 ; } var arr = [ 1 , 3 , - 5 , 3 , 4 ] ; var n = arr . length ; document . write ( minIndex ( arr , n ) ) ;
var N = 4 var M = 4 function printIntersection ( A , B ) { for ( var i = 0 ; i < M ; i ++ ) { for ( var j = 0 ; j < N ; j ++ ) { if ( A [ i ] [ j ] == B [ i ] [ j ] ) document . write ( A [ i ] [ j ] + " " ) ; else document . write ( " " ) ; } document . write ( " " ) ; } } var A = [ [ 2 , 4 , 6 , 8 ] , [ 1 , 3 , 5 , 7 ] , [ 8 , 6 , 4 , 2 ] , [ 7 , 5 , 3 , 1 ] ] ; var B = [ [ 2 , 3 , 6 , 8 ] , [ 1 , 3 , 5 , 2 ] , [ 8 , 1 , 4 , 2 ] , [ 3 , 5 , 4 , 1 ] ] ; printIntersection ( A , B ) ;
function countWays ( arr , n ) { let max_val = 0 ; for ( let i = 0 ; i < n ; i ++ ) max_val = Math . max ( max_val , arr [ i ] ) ; let freq = new Array ( max_val + 1 ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) freq [ arr [ i ] ] ++ ; ans += freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) / 6 ; for ( let i = 1 ; i <= max_val ; i ++ ) ans += freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) / 2 ; for ( let i = 1 ; 2 * i <= max_val ; i ++ ) ans += freq [ i ] * ( freq [ i ] - 1 ) / 2 * freq [ 2 * i ] ; for ( let i = 1 ; i <= max_val ; i ++ ) { for ( let j = i + 1 ; i + j <= max_val ; j ++ ) ans += freq [ i ] * freq [ j ] * freq [ i + j ] ; } return ans ; } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let n = arr . length ; document . write ( countWays ( arr , n ) ) ;
function LongestSubarray ( arr , n , k ) { let count = 1 ; let max_length = 1 ; let prev_mod = arr [ 0 ] % k ; for ( let i = 1 ; i < n ; i ++ ) { let curr_mod = arr [ i ] % k ; if ( curr_mod == prev_mod ) { count ++ ; } else { max_length = Math . max ( max_length , count ) ; count = 1 ; prev_mod = curr_mod ; } } return Math . max ( max_length , count ) ; } let arr = [ 4 , 9 , 7 , 18 , 29 , 11 ] ; let n = arr . length ; let k = 11 ; document . write ( LongestSubarray ( arr , n , k ) ) ;
var M = 3 ; var N = 4 ; function binarySearch1D ( arr , K ) { var low = 0 ; var high = N - 1 ; while ( low <= high ) { var mid = low + parseInt ( ( high - low ) / 2 ) ; if ( arr [ mid ] == K ) return true ; if ( arr [ mid ] < K ) low = mid + 1 ; else high = mid - 1 ; } return false ; } function searchMatrix ( matrix , K ) { var low = 0 ; var high = M - 1 ; while ( low <= high ) { var mid = low + parseInt ( ( high - low ) / 2 ) ; if ( K >= matrix [ mid ] [ 0 ] && K <= matrix [ mid ] [ N - 1 ] ) return binarySearch1D ( matrix [ mid ] , K ) ; if ( K < matrix [ mid ] [ 0 ] ) high = mid - 1 ; else low = mid + 1 ; } return false ; } var matrix = [ [ 1 , 3 , 5 , 7 ] , [ 10 , 11 , 16 , 20 ] , [ 23 , 30 , 34 , 50 ] ] ; var K = 3 ; if ( searchMatrix ( matrix , K ) ) document . write ( " " ) ; else document . write ( " " ) ;
function numberOfElements ( height , n ) { var max_so_far = 0 ; var coun = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( height [ i ] > max_so_far ) { max_so_far = height [ i ] ; coun ++ ; } } return coun ; } var n = 6 ; var height = [ 4 , 8 , 2 , 0 , 0 , 5 ] ; document . write ( numberOfElements ( height , n ) ) ;
function solve ( arr , n , k ) { arr . sort ( ( a , b ) => a - b ) if ( k == 1 && arr [ n - 2 ] != arr [ n - 1 ] ) { cout << arr [ n - 1 ] << endl ; return ; } var count = 1 ; for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] == arr [ i + 1 ] ) count ++ ; else count = 1 ; if ( count == k && ( i == 0 || ( arr [ i - 1 ] != arr [ i ] ) ) ) { document . write ( arr [ i ] + " " ) ; return ; } } document . write ( " " ) ; } var arr = [ 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 ] ; var k = 2 ; var n = arr . length ; solve ( arr , n , k ) ;
function getMin ( arr , n ) { let res = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) res = Math . min ( res , arr [ i ] ) ; return res ; } function getMax ( arr , n ) { let res = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; } function findSum ( arr , n ) { let min = getMin ( arr , n ) ; let max = getMax ( arr , n ) ; return min + max ; } function findProduct ( arr , n ) { let min = getMin ( arr , n ) ; let max = getMax ( arr , n ) ; return min * max ; } let arr = [ 12 , 1234 , 45 , 67 , 1 ] ; let n = arr . length ; document . write ( " " + findSum ( arr , n ) + " " ) ; document . write ( " " + findProduct ( arr , n ) + " " ) ;
function countChar ( str ) { var n = str . length ; if ( n <= 2 ) return n ; var count = 2 ; for ( var i = 1 ; i < n - 1 ; i ++ ) if ( str [ i - 1 ] == str [ i + 1 ] ) count ++ ; return count ; } var str = " " ; document . write ( countChar ( str ) ) ;
function next ( arr , target ) { let start = 0 , end = arr . length - 1 ; let ans = - 1 ; while ( start <= end ) { let mid = parseInt ( ( start + end ) / 2 , 10 ) ; if ( arr [ mid ] <= target ) { start = mid + 1 ; } else { ans = mid ; end = mid - 1 ; } } return ans ; } let arr = [ 1 , 2 , 3 , 5 , 8 , 12 ] ; document . write ( next ( arr , 8 ) ) ;
function search ( arr , n , x ) { let res = - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( x == arr [ i ] ) res = i ; if ( res == - 1 ) return false ; let temp = arr [ res ] ; for ( let i = res ; i > 0 ; i -- ) arr [ i ] = arr [ i - 1 ] ; arr [ 0 ] = temp ; return true ; } let arr = [ 12 , 25 , 36 , 85 , 98 , 75 , 89 , 15 , 63 , 66 , 64 , 74 , 27 , 83 , 97 ] ; let q = [ 63 , 63 , 86 , 63 , 78 ] ; let n = arr . length ; let m = q . length ; for ( let i = 0 ; i < m ; i ++ ) search ( arr , n , q [ i ] ) ? document . write ( " " ) : document . write ( " " ) ;
function kPresentProbability ( a , n , k ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( a [ i ] == k ) count += 1 ; return count / n ; } let A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] ; let K = 3 ; let N = A . length ; document . write ( kPresentProbability ( A , N , K ) ) ;
function slopeOfNum ( num , n ) { let slope = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( num [ i ] > num [ i - 1 ] && num [ i ] > num [ i + 1 ] ) slope ++ ; else if ( num [ i ] < num [ i - 1 ] && num [ i ] < num [ i + 1 ] ) slope ++ ; } return slope ; } let num = " " ; let n = num . length ; document . write ( " " + slopeOfNum ( num , n ) ) ;
function prevGreater ( arr , n ) { document . write ( " " ) ; for ( let i = 1 ; i < n ; i ++ ) { let j ; for ( j = i - 1 ; j >= 0 ; j -- ) { if ( arr [ i ] < arr [ j ] ) { document . write ( arr [ j ] + " " ) ; break ; } } if ( j == - 1 ) document . write ( " " ) ; } } let arr = [ 10 , 4 , 2 , 20 , 40 , 12 , 30 ] ; let n = arr . length ; prevGreater ( arr , n ) ;
function printDuplicates ( arr , n ) { let i ; let fl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ arr [ i ] % n ] >= n ) { if ( arr [ arr [ i ] % n ] < 2 * n ) { document . write ( arr [ i ] % n + " " ) ; fl = 1 ; } } arr [ arr [ i ] % n ] += n ; } if ( ! fl ) document . write ( " " ) ; } let arr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ] ; let arr_size = arr . length ; printDuplicates ( arr , arr_size ) ;
function findMissingNo ( arr , n ) { var val ; var nextval ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] <= 0 arr [ i ] > n ) continue ; val = arr [ i ] ; while ( arr [ val - 1 ] != val ) { nextval = arr [ val - 1 ] ; arr [ val - 1 ] = val ; val = nextval ; if ( val <= 0 val > n ) break ; } } for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != i + 1 ) { return i + 1 ; } } return n + 1 ; } var arr = [ 2 , 3 , 7 , 6 , 8 , - 1 , - 10 , 15 ] ; var arr_size = arr . length ; var missing = findMissingNo ( arr , arr_size ) ; document . write ( " " + missing ) ;
function findTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) { document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] + " " ) ; } } } } } let arr = [ 0 , - 1 , 2 , - 3 , 1 ] ; let n = arr . length ; findTriplets ( arr , n , - 2 ) ;
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 3 ; i ++ ) for ( let j = i + 1 ; j < n - 2 ; j ++ ) for ( let k = j + 1 ; k < n - 1 ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; return max_product ; } let arr = [ 10 , 3 , 5 , 6 , 20 ] ; let n = arr . length ; let max = maxProduct ( arr , n ) ; if ( max == - 1 ) document . write ( " " ) ; else document . write ( " " + max ) ;
function maxProduct ( arr , n ) { if ( n < 4 ) return - 1 ; arr . sort ( function ( a , b ) { return a - b ; } ) ; let x = arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ; let y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] ; let z = arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ; return Math . max ( x , Math . max ( y , z ) ) ; } let arr = [ - 10 , - 3 , 5 , 6 , - 20 ] ; let n = arr . length ; let max = maxProduct ( arr , n ) ; if ( max == - 1 ) document . write ( " " ) ; else document . write ( " " + max ) ;
function maxSum ( arr , n ) { if ( n < 2 ) return - 1 ; let ans = arr [ 0 ] + arr [ 1 ] ; for ( let i = 1 ; i + 1 < n ; i ++ ) ans = Math . min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) ; return ans ; } let arr = [ 1 , 12 , 2 , 2 ] ; let n = arr . length ; document . write ( maxSum ( arr , n ) ) ;
let N = 3 ; function getGreatestSum ( a ) { let prev_max = 0 ; for ( let j = 0 ; j < N ; j ++ ) if ( prev_max < a [ N - 1 ] [ j ] ) prev_max = a [ N - 1 ] [ j ] ; let sum = prev_max ; for ( let i = N - 2 ; i >= 0 ; i -- ) { let curr_max = - 2147483648 ; for ( let j = 0 ; j < N ; j ++ ) if ( prev_max > a [ i ] [ j ] && a [ i ] [ j ] > curr_max ) curr_max = a [ i ] [ j ] ; if ( curr_max == - 2147483648 ) return - 1 ; prev_max = curr_max ; sum += prev_max ; } return sum ; } let a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; document . write ( getGreatestSum ( a ) + " " ) ; let b = [ [ 4 , 5 , 6 ] , [ 4 , 5 , 6 ] , [ 4 , 5 , 6 ] ] ; document . write ( getGreatestSum ( b ) ) ;
function findElement ( n , k ) { let ans = n ; let left = 1 ; let right = ( Math . pow ( 2 , n ) - 1 ) ; while ( true ) { let mid = ( left + right ) / 2 ; if ( k == mid ) { document . write ( ans ) ; break ; } ans -- ; if ( k < mid ) { right = mid - 1 ; } else { left = mid + 1 ; } } } let n = 4 , k = 8 ; findElement ( n , k ) ;
function checkBit ( pattern , arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; } function maxAND ( arr , n ) { let res = 0 , count ; for ( let bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } if ( res == 0 ) System . out . prletln ( " " ) ; else { document . write ( " " ) ; count = 0 ; for ( let i = 0 ; i < n && count < 2 ; i ++ ) { if ( ( arr [ i ] & res ) == res ) { count ++ ; document . write ( arr [ i ] + " " ) ; } } document . write ( " " ) ; } return res ; } let arr = [ 4 , 8 , 6 , 2 ] ; let n = arr . length ; document . write ( " " + maxAND ( arr , n ) ) ;
function countMaxSumPairs ( a , n ) { let first = Number . MIN_VALUE , second = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > first ) { second = first ; first = a [ i ] ; } else if ( a [ i ] > second && a [ i ] != first ) second = a [ i ] ; } let cnt1 = 0 , cnt2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == first ) cnt1 ++ ; if ( a [ i ] == second ) cnt2 ++ ; } if ( cnt1 == 1 ) return cnt2 ; if ( cnt1 > 1 ) return cnt1 * ( cnt1 - 1 ) / 2 ; return 0 ; } function findMaxSumProbability ( a , n ) { let total = n * ( n - 1 ) / 2 ; let max_sum_pairs = countMaxSumPairs ( a , n ) ; return max_sum_pairs / total ; } let a = [ 1 , 2 , 2 , 3 ] ; let n = a . length ; ; document . write ( findMaxSumProbability ( a , n ) ) ;
function findS ( s ) { var sum = 0 ; for ( n = 1 ; sum < s ; n ++ ) { sum += n ; if ( sum == s ) return n ; } return - 1 ; } var s = 15 ; var n = findS ( s ) ; if ( n == - 1 ) document . write ( " " ) ; else document . write ( n ) ;
function calcSafe ( pos ) { let j = pos % 10 ; let i = Math . floor ( pos / 10 ) ; let dis_11 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 1 - j ) ) ; let dis_18 = Math . min ( Math . abs ( 1 - i ) , Math . abs ( 8 - j ) ) ; let dis_81 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 1 - j ) ) ; let dis_88 = Math . min ( Math . abs ( 8 - i ) , Math . abs ( 8 - j ) ) ; let sum = dis_11 + dis_18 + dis_81 + dis_88 + 1 ; return ( 64 - sum ) ; } let pos = 34 ; document . write ( " " + calcSafe ( pos ) ) ;
function getCount ( arr , n , num1 , num2 ) { let i = 0 ; for ( i = 0 ; i < n ; i ++ ) if ( arr [ i ] == num1 ) break ; if ( i >= n - 1 ) return 0 ; let j ; for ( j = n - 1 ; j >= i + 1 ; j -- ) if ( arr [ j ] == num2 ) break ; if ( j == i ) return 0 ; return ( j - i - 1 ) ; } let arr = [ 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 ] ; let n = arr . length ; let num1 = 5 , num2 = 4 ; document . write ( getCount ( arr , n , num1 , num2 ) ) ;
function sumOfDigit ( K ) { let sod = 0 ; while ( K ) { sod += K % 10 ; K /= 10 ; } return sod ; } function totalNumbersWithSpecificDifference ( N , diff ) { let low = 1 ; let high = N ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( mid - sumOfDigit ( mid ) < diff ) low = mid + 1 ; else high = mid - 1 ; } return ( N - high ) ; } let N = 13 ; let diff = 2 ; document . write ( totalNumbersWithSpecificDifference ( N , diff ) ) ;
function countBuildings ( arr , n ) { let count = 1 ; let curr_max = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > curr_max arr [ i ] == curr_max ) { count ++ ; curr_max = arr [ i ] ; } } return count ; } let arr = [ 7 , 4 , 8 , 2 , 9 ] ; let n = arr . length ; document . write ( countBuildings ( arr , n ) ) ;
function findExtra ( arr1 , arr2 , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] != arr2 [ i ] ) return i ; return n ; } let arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] ; let arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] ; let n = arr2 . length ; document . write ( findExtra ( arr1 , arr2 , n ) ) ;
function findExtra ( arr1 , arr2 , n ) { let index = n ; let left = 0 , right = n - 1 ; while ( left <= right ) { let mid = Math . floor ( ( left + right ) / 2 ) ; if ( arr2 [ mid ] == arr1 [ mid ] ) left = mid + 1 ; else { index = mid ; right = mid - 1 ; } } return index ; } let arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] ; let arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] ; let n = arr2 . length ; document . write ( findExtra ( arr1 , arr2 , n ) ) ;
function computeCost ( arr , N , X ) { let cost = 0 ; for ( let i = 0 ; i < N ; i ++ ) cost += Math . abs ( arr [ i ] - X ) ; return cost ; } function minCostToMakeElementEqual ( arr , N ) { let low , high ; low = high = arr [ 0 ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( low > arr [ i ] ) low = arr [ i ] ; if ( high < arr [ i ] ) high = arr [ i ] ; } while ( ( high - low ) > 2 ) { let mid1 = low + ( high - low ) / 3 ; let mid2 = high - ( high - low ) / 3 ; let cost1 = computeCost ( arr , N , mid1 ) ; let cost2 = computeCost ( arr , N , mid2 ) ; if ( cost1 < cost2 ) high = mid2 ; else low = mid1 ; } return Math . round ( computeCost ( arr , N , ( low + high ) / 2 ) ) ; } let arr = [ 1 , 100 , 101 ] ; let N = arr . length ; document . write ( minCostToMakeElementEqual ( arr , N ) ) ;
function Next_greater ( a , n , x ) { a . sort ( function ( aa , bb ) { return aa - bb } ) ; let low = 0 , high = n - 1 , ans = x + 1 ; while ( low <= high ) { let mid = Math . floor ( ( low + high ) / 2 ) ; if ( a [ mid ] <= ans ) { if ( a [ mid ] == ans ) { ans ++ ; high = n - 1 ; } low = mid + 1 ; } else high = mid - 1 ; } return ans ; } let a = [ 1 , 5 , 10 , 4 , 7 ] let x = 4 ; let n = a . length ; document . write ( Next_greater ( a , n , x ) ) ;
const mod = 1000000007 ; function fact ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } function nCr ( n , r ) { return parseInt ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) ; } function powmod ( a , n ) { if ( ! n ) return 1 ; let pt = powmod ( a , parseInt ( n / 2 ) ) ; pt = ( pt * pt ) % mod ; if ( n % 2 ) return ( pt * a ) % mod ; else return pt ; } function CountSubset ( arr , n ) { let ans = powmod ( 2 , n - 1 ) ; arr . sort ( ) ; for ( let i = 0 ; i < n ; ++ i ) { let j = i + 1 ; while ( j < n && arr [ j ] == arr [ i ] ) { let r = n - 1 - j ; let l = i ; ans = ( ans + nCr ( l + r , l ) ) % mod ; j ++ ; } } return ans ; } let arr = [ 2 , 3 , 2 ] ; let n = arr . length ; document . write ( CountSubset ( arr , n ) ) ;
function reArrange ( words , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) mp . set ( words [ i ] , i + 1 ) ; words . sort ( ) ; for ( var i = 0 ; i < n ; i ++ ) { document . write ( mp . get ( words [ i ] ) + " " ) ; } } var words = [ " " , " " , " " , " " , " " ] ; var n = words . length ; reArrange ( words , n ) ;
function findSumofEle ( arr1 , m , arr2 , n ) { let MAX = 100000 ; let hash = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) hash [ i ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) hash [ arr2 [ i ] ] ++ ; for ( let i = 1 ; i < MAX ; i ++ ) hash [ i ] = hash [ i ] + hash [ i - 1 ] ; let maximumFreq = 0 ; for ( let i = 0 ; i < m ; i ++ ) { maximumFreq = Math . max ( maximumFreq , hash [ arr1 [ i ] ] ) ; } let sumOfElements = 0 ; for ( let i = 0 ; i < m ; i ++ ) { if ( maximumFreq == hash [ arr1 [ i ] ] ) sumOfElements += arr1 [ i ] ; } return sumOfElements ; } let arr1 = [ 2 , 5 , 6 , 8 ] ; let arr2 = [ 4 , 10 ] ; let m = arr1 . length ; let n = arr2 . length ; document . write ( findSumofEle ( arr1 , m , arr2 , n ) ) ;
function printNumbers ( arr , n ) { arr . sort ( ( a , b ) => { return a - b ; } ) ; var A = arr [ n - 1 ] , B = - 1 ; for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( ( A % arr [ i ] ) != 0 ) { B = arr [ i ] ; break ; } if ( i - 1 >= 0 && arr [ i ] == arr [ i - 1 ] ) { B = arr [ i ] ; break ; } } document . write ( " " + A + " " + B ) ; } var arr = [ 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 ] ; var n = arr . length ; printNumbers ( arr , n ) ;
function printArray ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; } function removeMin ( arr , n ) { var i , minVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minVal = Math . min ( minVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = arr [ i ] - minVal ; } function removeFromMax ( arr , n ) { var i , maxVal = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) maxVal = Math . max ( maxVal , arr [ i ] ) ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = maxVal - arr [ i ] ; } function modifyArray ( arr , n , k ) { if ( k % 2 == 0 ) removeMin ( arr , n ) ; else removeFromMax ( arr , n ) ; printArray ( arr , n ) ; } arr = [ 4 , 8 , 12 , 16 ] var n = arr . length ; var k = 2 ; modifyArray ( arr , n , k ) ;
function findAnswer ( n , arr ) { arr . sort ( ( a , b ) => a - b ) ; let sum = 0 ; for ( let i = 0 ; i < Math . floor ( n / 2 ) ; ++ i ) { sum += ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ; } return sum ; } let arr = new Array ( 53 , 28 , 143 , 5 ) ; let n = arr . length ; document . write ( findAnswer ( n , arr ) ) ;
var n = 4 ; function merge ( l , r , output ) { var l_in = l * n , r_in = ( parseInt ( ( l + r ) / 2 ) + 1 ) * n ; var l_c = ( parseInt ( ( l + r ) / 2 ) - l + 1 ) * n ; var r_c = ( r - parseInt ( ( l + r ) / 2 ) ) * n ; var l_arr = Array ( l_c ) , r_arr = Array ( r_c ) ; for ( var i = 0 ; i < l_c ; i ++ ) l_arr [ i ] = output [ l_in + i ] ; for ( var i = 0 ; i < r_c ; i ++ ) r_arr [ i ] = output [ r_in + i ] ; var l_curr = 0 , r_curr = 0 ; var par = l_in ; while ( l_curr + r_curr < l_c + r_c ) { if ( r_curr == r_c || ( l_curr != l_c && l_arr [ l_curr ] < r_arr [ r_curr ] ) ) { output [ par ] = l_arr [ l_curr ] ; l_curr ++ , par ++ ; } else { output [ par ] = r_arr [ r_curr ] ; r_curr ++ , par ++ ; } } } function divide ( l , r , output , arr ) { if ( l == r ) { for ( var i = 0 ; i < n ; i ++ ) output [ l * n + i ] = arr [ l ] [ i ] ; return ; } divide ( l , parseInt ( ( l + r ) / 2 ) , output , arr ) ; divide ( parseInt ( ( l + r ) / 2 ) + 1 , r , output , arr ) ; merge ( l , r , output ) ; } var arr = [ [ 5 , 7 , 15 , 18 ] , [ 1 , 8 , 9 , 17 ] , [ 1 , 4 , 7 , 7 ] ] ; var k = arr . length ; var output = Array ( n * k ) ; divide ( 0 , k - 1 , output , arr ) ; for ( var i = 0 ; i < n * k ; i ++ ) document . write ( output [ i ] + " " ) ;
function countDistinct ( arr , n ) { let res = 1 ; for ( let i = 1 ; i < n ; i ++ ) { let j = 0 ; for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] === arr [ j ] ) break ; if ( i === j ) res ++ ; } return res ; } let arr = [ 12 , 10 , 9 , 45 , 2 , 10 , 10 , 45 ] ; let n = arr . length ; document . write ( countDistinct ( arr , n ) ) ;
function countDistinct ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( i < n - 1 && arr [ i ] == arr [ i + 1 ] ) { i ++ ; } res ++ ; } return res ; } let arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] ; let n = arr . length ; document . write ( countDistinct ( arr , n ) ) ;
function printArray ( arr , n ) { for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; } function printMaxMean ( arr , n ) { var newArr = Array ( n ) . fill ( 0 ) ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i < n ; i ++ ) newArr [ i ] = arr [ i + n ] ; printArray ( newArr , n ) ; } var arr = [ 4 , 8 , 3 , 1 , 3 , 7 , 0 , 4 ] ; var n = arr . length ; printMaxMean ( arr , n / 2 ) ;
function average ( arr , n , k ) { var total = 0 ; if ( 2 * k >= n ) return 0 ; arr . sort ( ) ; var start = k , end = n - k - 1 ; for ( i = start ; i <= end ; i ++ ) total += arr [ i ] ; return ( total / ( n - 2 * k ) ) ; } var arr = [ 1 , 2 , 4 , 4 , 5 , 6 ] ; var n = arr . length ; var k = 2 ; document . write ( average ( arr , n , k ) ) ;
function min_sum ( n , k , a ) { a . sort ( ) ; if ( a [ 0 ] < 0 ) return - 1 ; if ( k == 0 ) { if ( a [ 0 ] == a [ n - 1 ] ) return ( n * a [ 0 ] ) ; else return - 1 ; } else { let f = 0 ; for ( let i = 1 ; i < n ; i ++ ) { let p = a [ i ] - a [ 0 ] ; if ( p % k == 0 ) continue ; else { f = 1 ; break ; } } if ( f > 0 ) return - 1 ; else { if ( k == 1 ) return n ; else return ( n * ( a [ 0 ] % k ) ) ; } } } let arr = [ 2 , 3 , 4 , 5 ] ; let K = 1 ; let N = arr . length ; document . write ( min_sum ( N , K , arr ) ) ;
function minCost ( A , n ) { var cost = 0 ; A . sort ( ) ; var K = A [ parseInt ( n / 2 ) ] ; var i ; for ( i = 0 ; i < n ; ++ i ) cost += Math . abs ( A [ i ] - K ) ; if ( n % 2 == 0 ) { var tempCost = 0 ; K = A [ parseInt ( n / 2 ) - 1 ] ; for ( i = 0 ; i < n ; ++ i ) tempCost += Math . abs ( A [ i ] - K ) ; cost = Math . min ( cost , tempCost ) ; } return cost ; } var A = [ 1 , 6 , 7 , 10 ] ; var n = A . length ; document . write ( minCost ( A , n ) ) ;
function printArray ( arr , n ) { arr . sort ( ) ; let l = 0 , r = n - 1 , flag = 0 , i ; let k = 2 ; while ( l <= r ) { if ( flag == 0 ) { for ( i = l ; i < l + k && i <= r ; i ++ ) document . write ( arr [ i ] + " " ) ; flag = 1 ; l = i ; } else { for ( i = r ; i > r - k && i >= l ; i -- ) document . write ( arr [ i ] + " " ) ; flag = 0 ; r = i ; } k ++ ; } } let n = 6 ; let arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; printArray ( arr , n ) ;
function isAlphabaticOrder ( s ) { let n = s . length ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] < s [ i - 1 ] ) return false ; } return true ; } let s = " " ; if ( isAlphabaticOrder ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function rotateRec ( n , L , B ) { var m = Number . MAX_VALUE for ( var i = 0 ; i < n ; i ++ ) { if ( Math . max ( L [ i ] , B [ i ] ) <= m ) m = Math . max ( L [ i ] , B [ i ] ) ; else if ( Math . min ( L [ i ] , B [ i ] ) <= m ) m = Math . min ( L [ i ] , B [ i ] ) ; else { return 0 ; } } return 1 ; } var n = 3 ; var L = [ 5 , 5 , 6 ] ; var B = [ 6 , 7 , 8 ] ; if ( rotateRec ( n , L , B ) == 1 ) document . write ( " " ) ; else document . write ( " " ) ;
function minDistance ( n , k , points ) { for ( let i = 0 ; i < k ; i ++ ) ( point [ i ] ) . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < k ; i ++ ) document . write ( point [ i ] [ Math . ceil ( ( n / 2 ) - 1 ) ] + " " ) ; } let n = 4 ; let k = 4 ; let point = [ [ 1 , 5 , 2 , 4 ] , [ 6 , 2 , 0 , 6 ] , [ 9 , 5 , 1 , 3 ] , [ 6 , 7 , 5 , 9 ] ] ; minDistance ( n , k , point ) ;
function printOrder ( arr , n , k ) { let len1 = k , len2 = n - k ; let arr1 = new Array ( k ) ; let arr2 = new Array ( n - k ) ; for ( let i = 0 ; i < k ; i ++ ) arr1 [ i ] = arr [ i ] ; for ( let i = k ; i < n ; i ++ ) arr2 [ i - k ] = arr [ i ] ; arr1 . sort ( function ( a , b ) { return a - b ; } ) ; arr2 . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( i < k ) arr [ i ] = arr1 [ i ] ; else { arr [ i ] = arr2 [ len2 - 1 ] ; len2 -- ; } } for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + " " ) ; } } let arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; let k = 4 ; let n = arr . length ; printOrder ( arr , n , k ) ;
function findMaxNum ( arr , n ) { var hash = Array ( 10 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { hash [ arr [ i ] ] ++ ; } for ( var i = 9 ; i >= 0 ; i -- ) { for ( var j = 0 ; j < hash [ i ] ; j ++ ) document . write ( i ) ; } } var arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] ; var n = arr . length ; findMaxNum ( arr , n ) ;
function distribution ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; var count = 1 ; for ( var i = 1 ; i < n ; i ++ ) if ( arr [ i ] > arr [ i - 1 ] ) count ++ ; return Math . min ( count , parseInt ( n / 2 ) ) ; } var arr = [ 1 , 1 , 2 , 1 , 3 , 4 ] ; var n = arr . length ; document . write ( distribution ( arr , n ) ) ;
let arr = [ 10 , 12 , 5 ] ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < 3 ; i ++ ) document . write ( arr [ i ] + " " ) ;
function printTriplets ( arr , n , sum ) { for ( let i = 0 ; i < n - 2 ; i ++ ) { for ( let j = i + 1 ; j < n - 1 ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ k ] + " " ) ; } } } let arr = [ 5 , 1 , 3 , 4 , 7 ] ; let n = arr . length ; let sum = 12 ; printTriplets ( arr , n , sum ) ;
function countTriplets ( arr , n , a , b ) { var ans = 0 ; for ( var i = 0 ; i < n - 2 ; i ++ ) { for ( var j = i + 1 ; j < n - 1 ; j ++ ) { for ( var k = j + 1 ; k < n ; k ++ ) if ( arr [ i ] + arr [ j ] + arr [ k ] >= a && arr [ i ] + arr [ j ] + arr [ k ] <= b ) ans ++ ; } } return ans ; } var arr = [ 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 ] ; var n = arr . length ; var a = 8 , b = 16 ; document . write ( countTriplets ( arr , n , a , b ) ) ;
function countTripletsLessThan ( arr , n , val ) { arr . sort ( ) ; var ans = 0 ; var j , k ; var sum ; for ( var i = 0 ; i < n - 2 ; i ++ ) { j = i + 1 ; k = n - 1 ; while ( j != k ) { sum = arr [ i ] + arr [ j ] + arr [ k ] ; if ( sum > val ) k -- ; else { ans += k - j ; j ++ ; } } } return ans ; } function countTriplets ( arr , n , a , b ) { var res ; res = countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ; return res ; } var arr = [ 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 ] ; var n = arr . length ; var a = 8 , b = 16 ; document . write ( " " + countTriplets ( arr , n , a , b ) ) ;
function MaxTotalRectangleArea ( a , n ) { a . sort ( ) ; a . reverse ( ) ; let sum = 0 ; let flag = false ; let len ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( ! flag ) ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; } let a = [ 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ] ; let n = a . length ; document . write ( MaxTotalRectangleArea ( a , n ) ) ;
function print ( a , n ) { for ( let i = 0 ; i <= n ; i ++ ) document . write ( a [ i ] + " " ) ; document . write ( " " ) ; } function sort ( a , n ) { for ( let i = n ; i >= 0 ; i -- ) for ( let j = n ; j > n - i ; j -- ) if ( a [ j ] > a [ j - 1 ] ) { let tempswap = a [ j ] ; a [ j ] = a [ j - 1 ] ; a [ j - 1 ] = tempswap ; } print ( a , n ) ; } let n = 6 ; let a = [ ] ; a . push ( 2 ) ; a . push ( 4 ) ; a . push ( 3 ) ; a . push ( 2 ) ; a . push ( 4 ) ; a . push ( 5 ) ; a . push ( 3 ) ; sort ( a , n ) ;
function distancesum ( x , y , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) sum += ( Math . abs ( x [ i ] - x [ j ] ) + Math . abs ( y [ i ] - y [ j ] ) ) ; return sum ; } let x = [ - 1 , 1 , 3 , 2 ] ; let y = [ 5 , 6 , 5 , 3 ] ; let n = x . length ; document . write ( distancesum ( x , y , n ) ) ;
function distancesum ( arr , n ) { arr . sort ( ) ; let res = 0 , sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { res += ( arr [ i ] * i - sum ) ; sum += arr [ i ] ; } return res ; } function totaldistancesum ( x , y , n ) { return distancesum ( x , n ) + distancesum ( y , n ) ; } let x = [ - 1 , 1 , 3 , 2 ] ; let y = [ 5 , 6 , 5 , 3 ] ; let n = x . length ; document . write ( totaldistancesum ( x , y , n ) ) ;
function printMedian ( arr , n , K ) { arr . sort ( ) ; document . write ( arr [ Math . floor ( ( n + K ) / 2 ) ] ) ; } let arr = [ 5 , 3 , 2 , 8 ] ; let k = 3 ; let n = arr . length ; printMedian ( arr , n , k ) ;
function arrange ( arr , n , x ) { for ( let i = 1 ; i < n ; i ++ ) { let diff = Math . abs ( arr [ i ] - x ) ; let j = i - 1 ; if ( Math . abs ( arr [ j ] - x ) > diff ) { let temp = arr [ i ] ; while ( j >= 0 && Math . abs ( arr [ j ] - x ) > diff ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } } } function print ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; } let arr = [ 10 , 5 , 3 , 9 , 2 ] ; let n = arr . length ; let x = 7 ; arrange ( arr , n , x ) ; print ( arr , n ) ;
function printOrder ( arr , n ) { arr . sort ( ) ; for ( i = 0 ; i < parseInt ( n / 2 ) ; i ++ ) { document . write ( arr [ i ] + " " ) ; } for ( j = n - 1 ; j >= parseInt ( n / 2 ) ; j -- ) { document . write ( arr [ j ] + " " ) ; } } var arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , - 1 ] ; var n = arr . length ; printOrder ( arr , n ) ;
function findMinimum ( arr , n , k ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { res += arr [ i ] ; n = n - k ; } return res ; } function findMaximum ( arr , n , k ) { let res = 0 , index = 0 ; for ( let i = n - 1 ; i >= index ; i -- ) { res += arr [ i ] ; index += k ; } return res ; } let arr = [ 3 , 2 , 1 , 4 ] ; let n = arr . length ; let k = 2 ; arr . sort ( function ( a , b ) { return a - b ; } ) ; document . write ( findMinimum ( arr , n , k ) + " " + findMaximum ( arr , n , k ) ) ;
function maxLevel ( boxes , n ) { boxes . sort ( ) ; let prev_width = boxes [ 0 ] ; let prev_count = 1 ; let curr_count = 0 ; let curr_width = 0 ; for ( let i = 1 ; i < n ; i ++ ) { curr_width += boxes [ i ] ; curr_count += 1 ; if ( curr_width > prev_width && curr_count > prev_count ) { prev_width = curr_width ; prev_count = curr_count ; curr_count = 0 ; curr_width = 0 ; ans ++ ; } } return ans ; } let boxes = [ 10 , 20 , 30 , 50 , 60 , 70 ] ; let n = boxes . length ; document . write ( maxLevel ( boxes , n ) ) ;
function twoWaySort ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] *= - 1 ; arr . sort ( ( a , b ) => a - b ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] & 1 ) arr [ i ] *= - 1 ; } let arr = [ 1 , 3 , 2 , 7 , 5 , 4 ] ; let n = arr . length ; twoWaySort ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ;
function isPossibleTriangle ( arr , N ) { if ( N < 3 ) return false ; arr . sort ( ) ; for ( let i = 0 ; i < N - 2 ; i ++ ) if ( arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] ) return true ; return false ; } let arr = [ 5 , 4 , 3 , 1 , 2 ] ; let N = arr . length ; if ( isPossibleTriangle ( arr , N ) ) document . write ( " " ) ; else document . write ( " " ) ;
let MAX = 1000000 ; function ksmallest ( arr , n , k ) { let b = [ ] ; for ( let i = 0 ; i < n ; i ++ ) { b [ arr [ i ] ] = 1 ; } for ( let j = 1 ; j < MAX ; j ++ ) { if ( b [ j ] != 1 ) { k -- ; } if ( k != 1 ) { return j ; } } return Number . MAX_VALUE ; } let k = 1 ; let arr = [ 1 ] ; let n = arr . length ; document . write ( ksmallest ( arr , n , k ) ) ;
function mergeTwoHalf ( A , n ) { A . sort ( ( a , b ) => a - b ) ; } var A = [ 2 , 3 , 8 , - 1 , 7 , 10 ] ; var n = A . length ; mergeTwoHalf ( A , n ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( A [ i ] + " " ) ;
function minDiff ( arr , n , k ) { var result = Number . MAX_VALUE ; arr . sort ( ( a , b ) => a - b ) ; for ( i = 0 ; i <= n - k ; i ++ ) result = Math . min ( result , arr [ i + k - 1 ] - arr [ i ] ) ; return result ; } var arr = [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ] ; var n = arr . length ; var k = 3 ; document . write ( minDiff ( arr , n , k ) ) ;
function merge ( arr , temp , left , mid , right ) { let inv_count = 0 ; let i = left ; let j = mid ; let k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; } function _mergeSort ( arr , temp , left , right ) { let mid , inv_count = 0 ; if ( right > left ) { mid = Math . floor ( ( right + left ) / 2 ) ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; } function countSwaps ( arr , n ) { let temp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { temp [ i ] = 0 ; } return _mergeSort ( arr , temp , 0 , n - 1 ) ; } let arr = [ 1 , 20 , 6 , 4 , 5 ] ; let n = arr . length ; document . write ( " " + countSwaps ( arr , n ) ) ;
function isEven ( n ) { return ( n % 2 == 0 ) ; } let n = 101 ; isEven ( n ) ? document . write ( " " ) : document . write ( " " ) ;
function findSurpasser ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { let count = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ j ] > arr [ i ] ) count ++ ; document . write ( count + " " ) ; } } function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( ) ; } let arr = [ 2 , 7 , 5 , 3 , 0 , 8 , 1 ] ; let n = arr . length ; document . write ( " " + " " ) ; printArray ( arr , n ) ; document . write ( " " ) ; document . write ( " " + " " + " " ) ; findSurpasser ( arr , n ) ;
function solve ( arr , n ) { arr . sort ( ) ; let a = 0 , b = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 != 0 ) a = a * 10 + arr [ i ] ; else b = b * 10 + arr [ i ] ; } return a + b ; } let arr = [ 6 , 8 , 4 , 5 , 2 , 3 ] ; let n = arr . length ; document . write ( " " + solve ( arr , n ) ) ;
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; let max_product = Number . MIN_VALUE ; for ( let i = 0 ; i < n - 2 ; i ++ ) for ( let j = i + 1 ; j < n - 1 ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) max_product = Math . max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) ; return max_product ; } let arr = [ 10 , 3 , 5 , 6 , 20 ] ; let n = arr . length ; ; let max = maxProduct ( arr , n ) ; if ( max == - 1 ) document . write ( " " ) ; else document . write ( " " + max ) ;
function maxProduct ( arr , n ) { if ( n < 3 ) return - 1 ; leftMin = Array . from ( { length : n } , ( _ , i ) => - 1 ) ; rightMin = Array . from ( { length : n } , ( _ , i ) => - 1 ) ; leftMax = Array . from ( { length : n } , ( _ , i ) => - 1 ) ; rightMax = Array . from ( { length : n } , ( _ , i ) => - 1 ) ; var max_product = Number . MIN_VALUE ; var max_sum = arr [ 0 ] ; var min_sum = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { leftMax [ i ] = max_sum ; if ( arr [ i ] > max_sum ) max_sum = arr [ i ] ; leftMin [ i ] = min_sum ; if ( arr [ i ] < min_sum ) min_sum = arr [ i ] ; } max_sum = arr [ n - 1 ] ; min_sum = arr [ n - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) { rightMax [ j ] = max_sum ; if ( arr [ j ] > max_sum ) max_sum = arr [ j ] ; rightMin [ j ] = min_sum ; if ( arr [ j ] < min_sum ) min_sum = arr [ j ] ; } for ( i = 1 ; i < n - 1 ; i ++ ) { var max1 = Math . max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) ; var max2 = Math . max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) ; max_product = Math . max ( max_product , Math . max ( max1 , max2 ) ) ; } return max_product ; } var arr = [ 1 , 4 , 3 , - 6 , - 7 , 0 ] ; var n = arr . length ; var max = maxProduct ( arr , n ) ; if ( max == - 1 ) document . write ( " " ) ; else document . write ( " " + max ) ;
function maxProduct ( arr , n ) { if ( n < 3 ) { return - 1 ; } arr . sort ( ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; } var arr = [ - 10 , - 3 , 5 , 6 , - 20 ] ; var n = arr . length ; var max = maxProduct ( arr , n ) ; if ( max == - 1 ) { document . write ( " " ) ; } else { document . write ( " " + max ) ; }
function Substring ( s ) { var ans = 1 , temp = 1 ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i - 1 ] ) { ++ temp ; } else { ans = Math . max ( ans , temp ) ; temp = 1 ; } } ans = Math . max ( ans , temp ) ; return ans ; } var s = " " ; document . write ( Substring ( s ) ) ;
function solve ( n , k ) { let mini = 0 ; let x1 = 1 ; let a = new Array ( k ) ; for ( let i = 1 ; i <= k ; i ++ ) { mini += x1 ; a [ i - 1 ] = x1 ; x1 += 1 ; } if ( n < mini ) { document . write ( " " ) ; return ; } let rem = n - mini ; let cnt = parseInt ( rem / k ) ; rem = rem % k ; for ( let i = 0 ; i < k ; i ++ ) a [ i ] += cnt ; for ( let i = k - 1 ; i > 0 && rem > 0 ; i -- ) { let xx = a [ i - 1 ] * 2 ; let left = xx - a [ i ] ; if ( rem >= left ) { a [ i ] = xx ; rem -= left ; } else { a [ i ] += rem ; rem = 0 ; } } let sum = a [ 0 ] ; for ( let i = 1 ; i < k ; i ++ ) { if ( a [ i ] > 2 * a [ i - 1 ] ) { document . write ( " " ) ; return ; } sum += a [ i ] ; } if ( sum != n ) { document . write ( " " ) ; return ; } for ( let i = 0 ; i < k ; i ++ ) document . write ( a [ i ] + " " ) ; } let n = 26 , k = 6 ; solve ( n , k ) ;
function maxCoins ( X , Y ) { if ( X < Y ) { let temp = X ; X = Y ; Y = temp ; } let coins = X ; X -- ; coins += Math . max ( X , Y ) ; return coins ; } let X = 7 , Y = 5 ; document . write ( maxCoins ( X , Y ) ) ;
function findElementsCrossed ( arr , a , b , n ) { var aa = a ; var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a == 0 && b == 0 ) break ; else if ( a == 0 ) { if ( arr [ i ] == 1 ) { b -= 1 ; a = Math . min ( aa , a + 1 ) ; } else b -= 1 ; } else if ( b == 0 ) a -- ; else if ( arr [ i ] == 1 && a < aa ) { b -= 1 ; a = Math . min ( aa , a + 1 ) ; } else a -- ; ans ++ ; } return ans ; } var arr = [ 1 , 0 , 0 , 1 , 0 , 1 ] ; var n = arr . length ; var a = 1 ; var b = 2 ; document . write ( findElementsCrossed ( arr , a , b , n ) ) ;
function isVowel ( ch ) { switch ( ch ) { case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : return true ; default : return false ; } } function vowelPairs ( s , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( isVowel ( s [ i ] ) && isVowel ( s [ i + 1 ] ) ) cnt ++ ; } return cnt ; } let s = " " ; let n = s . length ; document . write ( vowelPairs ( s , n ) ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function solve ( health , n ) { let currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) ; for ( let i = 2 ; i < n ; ++ i ) { currentgcd = gcd ( currentgcd , health [ i ] ) ; } return currentgcd ; } let health = [ 4 , 6 , 8 , 12 ] ; let n = health . length ; document . write ( solve ( health , n ) ) ;
function Find_Sequence ( arr , n ) { let inc_arr = [ ] , dec_arr = [ ] ; let flag = 0 ; let inc = - 1 , dec = 1e7 ; for ( let i = 0 ; i < n ; i ++ ) { if ( inc < arr [ i ] && arr [ i ] < dec ) { if ( arr [ i ] < arr [ i + 1 ] ) { inc = arr [ i ] ; inc_arr . push ( arr [ i ] ) ; } else { dec = arr [ i ] ; dec_arr . push ( arr [ i ] ) ; } } else if ( inc < arr [ i ] ) { inc = arr [ i ] ; inc_arr . push ( arr [ i ] ) ; } else if ( dec > arr [ i ] ) { dec = arr [ i ] ; dec_arr . push ( arr [ i ] ) ; } else { document . write ( - 1 ) ; flag = 1 ; break ; } } if ( flag == 0 ) { document . write ( " " ) ; for ( let i in inc_arr ) document . write ( inc_arr [ i ] + " " ) ; document . write ( " " ) ; document . write ( " " ) ; for ( let i in dec_arr ) document . write ( dec_arr [ i ] + " " ) ; document . write ( " " ) ; } } let arr = [ 5 , 1 , 3 , 6 , 8 , 2 , 9 , 0 , 10 ] ; let n = arr . length ; Find_Sequence ( arr , n ) ;
function reverse ( n ) { let rev = 0 ; while ( n != 0 ) { rev = ( rev * 10 ) + ( n % 10 ) ; n = Math . floor ( n / 10 ) ; } return rev ; } function getSum ( n ) { n = reverse ( n ) ; let sumOdd = 0 , sumEven = 0 , c = 1 ; while ( n != 0 ) { if ( c % 2 == 0 ) sumEven += n % 10 ; else sumOdd += n % 10 ; n = Math . floor ( n / 10 ) ; c ++ ; } document . write ( " " + sumOdd ) ; document . write ( " " ) ; document . write ( " " + sumEven ) ; } let n = 457892 ; getSum ( n ) ;
function bankNotes ( A , B , S , N ) { let numerator = S - ( B * N ) ; let denominator = A - B ; if ( numerator % denominator == 0 ) return ( Math . floor ( numerator / denominator ) ) ; return - 1 ; } let A = 1 , B = 2 , S = 7 , N = 5 ; document . write ( bankNotes ( A , B , S , N ) + " " ) ;
function twoParts ( str ) { var flag = 0 ; var a = " " ; var gfg = str . split ( ' ' ) ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( gfg [ i ] == ' ' ) { gfg [ i ] = ' ' ; a += ' ' ; flag = 1 ; } else if ( flag != 0 ) a += ' ' ; } document . write ( gfg . join ( ' ' ) + " " + a ) ; } var str = " " ; twoParts ( str ) ;
function longestSubstring ( s ) { var cnt = 1 , maxi = 1 ; var n = s . length ; for ( i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( i - 1 ) ) cnt ++ ; else { maxi = Math . max ( cnt , maxi ) ; cnt = 1 ; } } maxi = Math . max ( cnt , maxi ) ; return maxi ; } var s = " " ; document . write ( longestSubstring ( s ) ) ;
function Minimum_Operations ( a , n ) { let np = Array ( n + 1 ) . fill ( 0 ) ; np [ n ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { np [ i ] = np [ i + 1 ] ; if ( a [ i ] <= 0 ) np [ i ] ++ ; } let pos = 0 ; let ans = n ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) pos ++ ; ans = Math . min ( ans , pos + np [ i + 1 ] ) ; } return ans ; } let a = [ - 1 , 0 , 1 , 2 ] ; let n = a . length ; document . write ( Minimum_Operations ( a , n ) ) ;
function findSumofEle ( arr1 , m , arr2 , n , k ) { var arraySum = 0 ; for ( var i = 0 ; i < n ; i ++ ) arraySum += arr2 [ i ] ; var mean = ( arraySum / n ) ; var sumOfElements = 0 ; var difference ; for ( var i = 0 ; i < m ; i ++ ) { difference = arr1 [ i ] - mean ; if ( ( difference < 0 ) && ( k > ( - 1 ) * difference ) ) { sumOfElements += arr1 [ i ] ; } if ( ( difference >= 0 ) && ( k > difference ) ) { sumOfElements += arr1 [ i ] ; } } return sumOfElements ; } var arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] ; var arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] ; var k = 2 ; var m , n ; m = arr1 . length ; n = arr2 . length ; document . write ( findSumofEle ( arr1 , m , arr2 , n , k ) ) ;
function findIntegers ( n , x , y ) { let ans = [ ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) ans . push ( 1 ) ; if ( y - ( n - 1 ) <= 0 ) { document . write ( " " ) ; return ; } ans . push ( y - ( n - 1 ) ) ; let store = 0 ; for ( let i = 0 ; i < n ; i ++ ) store += ans [ i ] * ans [ i ] ; if ( store < x ) { document . write ( " " ) ; return ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( ans [ ( i ) ] + " " ) ; } let n = 3 , x = 254 , y = 18 ; findIntegers ( n , x , y ) ;
function Minsteps ( n , m ) { let ans = 0 ; while ( m > n ) { if ( m & 1 ) { m ++ ; ans ++ ; } m = Math . floor ( m / 2 ) ; ans ++ ; } return ans + n - m ; } let n = 4 , m = 6 ; document . write ( Minsteps ( n , m ) ) ;
function getsum ( x ) { return ( x * ( x + 1 ) ) / 2 ; } function countJumps ( n ) { n = Math . abs ( n ) ; let ans = 0 ; while ( getsum ( ans ) < n || ( ( getsum ( ans ) - n ) & 1 ) > 0 ) ans ++ ; return ans ; } let n = 9 ; document . write ( countJumps ( n ) ) ;
function maxCandies ( arr , n ) { let prevBought = arr [ n - 1 ] ; let candies = prevBought ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let x = Math . min ( prevBought - 1 , arr [ i ] ) ; if ( x >= 0 ) { candies += x ; prevBought = x ; } } return candies ; } let arr = [ 1 , 2 , 1 , 3 , 6 ] ; let n = arr . length ; document . write ( maxCandies ( arr , n ) ) ;
function minChanges ( str , n ) { let count = 0 , zeros = 0 , ones = 0 ; if ( str [ 0 ] != ' ' ) { count ++ ; ones ++ ; } for ( let i = 1 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) zeros ++ ; else ones ++ ; if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; } let str = " " . split ( ' ' ) ; let n = str . length ; document . write ( minChanges ( str , n ) ) ;
function steps ( cur , x , n ) { if ( x == 0 ) return Number . MAX_VALUE ; if ( x > 0 ) return Math . abs ( ( n - cur ) / x ) ; else return Math . abs ( ( cur - 1 ) / x ) ; } function countSteps ( curx , cury , n , m , moves ) { let count = 0 ; let k = moves . length ; for ( let i = 0 ; i < k ; i ++ ) { let x = moves [ i ] [ 0 ] ; let y = moves [ i ] [ 1 ] ; let stepct = Math . min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) ; count += stepct ; curx += stepct * x ; cury += stepct * y ; } return Math . floor ( count ) ; } let n = 4 , m = 5 , x = 1 , y = 1 ; let moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] ; document . write ( countSteps ( x , y , n , m , moves ) ) ;
function min_elimination ( n , arr ) { let count = 0 ; let prev_val = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { let curr_val = arr [ i ] ; if ( curr_val % 2 == prev_val % 2 ) count ++ ; prev_val = curr_val ; } return count ; } let arr = [ 1 , 2 , 3 , 7 , 9 ] ; let n = arr . length ; document . write ( min_elimination ( n , arr ) ) ;
function getCount ( N ) { if ( N % 2 == 1 ) return " " ; let result = " " ; for ( let i = 1 ; i <= N / 2 - 1 ; i ++ ) result += " " ; return result ; } let N = 4 ; document . write ( getCount ( N ) ) ;
function canFormTeam ( n , m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; } function maxTeams ( n , m ) { var count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; } var n = 4 , m = 5 ; document . write ( maxTeams ( n , m ) ) ;
function max ( a , b ) { if ( a > b ) return a ; else return b ; } function smallestSide ( a ) { a . sort ( ) ; var side1 , side2 , side3 , side4 , side11 , side12 , sideOfSquare ; side1 = a [ 0 ] + a [ 3 ] ; side2 = a [ 1 ] + a [ 2 ] ; side3 = a [ 0 ] + a [ 1 ] ; side4 = a [ 2 ] + a [ 3 ] ; side11 = max ( side1 , side2 ) ; side12 = max ( side3 , side4 ) ; sideOfSquare = max ( side11 , side12 ) ; return sideOfSquare ; } var side = Array . from ( { length : 4 } , ( _ , i ) => 0 ) ; document . write ( " " ) ; side [ 0 ] = 2 ; side [ 1 ] = 2 ; side [ 2 ] = 2 ; side [ 3 ] = 2 ; document . write ( smallestSide ( side ) ) ; document . write ( " " ) ; side [ 0 ] = 100000000000000 ; side [ 1 ] = 123450000000000 ; side [ 2 ] = 987650000000000 ; side [ 3 ] = 987654321000000 ; document . write ( smallestSide ( side ) ) ;
function find_rectangle ( area ) { let l = 0 , b = 0 ; let M = Math . floor ( Math . sqrt ( area ) ) , ans ; for ( let i = M ; i >= 1 ; i -- ) { if ( area % i == 0 ) { l = Math . floor ( area / i ) ; b = i ; break ; } } document . write ( " " + l + " " + b ) ; } let area = 99 ; find_rectangle ( area ) ;
function sizeSubSet ( a , k , n ) { a . sort ( function ( a , b ) { return a - b ; } ) ; let s = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % k != 0 || s . get ( a [ i ] / k ) == null ) s . set ( a [ i ] , s . get ( a [ i ] ) == null ? 1 : s . get ( a [ i ] ) + 1 ) ; } return s . size ; } let a = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ; let n = a . length ; let k = 2 ; document . write ( sizeSubSet ( a , k , n ) ) ;
function minimumSets ( s , y ) { let cnt = 0 ; let num = 0 ; let l = s . length ; let f = false ; for ( let i = 0 ; i < l ; i ++ ) { num = num * 10 + ( s [ i ] - ' ' ) ; if ( num <= y ) f = true ; { if ( f ) cnt += 1 ; num = s [ i ] - ' ' ; f = false ; if ( num <= y ) f = true ; else num = 0 ; } } if ( f == true ) cnt += 1 ; return cnt ; } let s = " " ; let y = 30 ; document . write ( minimumSets ( s , y ) ) ;
function printArr ( b , n ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( " " + b [ i ] + " " ) ; } } function ModifiedArray ( a , n ) { let l = 0 , r = Number . MAX_VALUE ; let b = Array ( n ) . fill ( 0 ) ; for ( let i = 0 ; i < n / 2 ; i ++ ) { b [ i ] = Math . max ( l , a [ i ] - r ) ; b [ n - i - 1 ] = a [ i ] - b [ i ] ; l = b [ i ] ; r = b [ n - i - 1 ] ; } printArr ( b , n ) ; } let a = [ 5 , 6 ] ; let n = a . length ; ModifiedArray ( a , 2 * n ) ;
function maxSubArraySum ( a , size ) { var max_so_far = Number . MIN_VALUE , max_ending_here = 0 ; for ( i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } function maxSum ( a , n ) { var S = 0 ; var S1 = maxSubArraySum ( a , n ) ; for ( i = 0 ; i < n ; i ++ ) S += a [ i ] ; return ( 2 * S1 - S ) ; } var a = [ - 35 , 32 , - 24 , 0 , 27 , - 10 , 0 , - 19 ] ; var n = a . length ; document . write ( maxSum ( a , n ) ) ;
function minimizeDiff ( arr , n , k ) { let max = Math . max ( ... arr ) ; let min = Math . min ( ... arr ) ; if ( ( max - min ) <= k ) { return ( max - min ) ; } let avg = Math . floor ( ( max + min ) / 2 ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > avg ) { arr [ i ] -= k ; } else { arr [ i ] += k ; } } max = Math . max ( ... arr ) ; min = Math . min ( ... arr ) ; return ( max - min ) ; } let arr = [ 3 , 16 , 12 , 9 , 20 ] ; let n = 5 ; let k = 3 ; document . write ( " " + minimizeDiff ( arr , n , k ) ) ;
function maxLitres ( budget , plastic , glass , refund ) { if ( glass - refund < plastic ) { let ans = Math . max ( ( budget - refund ) / ( glass - refund ) , 0 ) ; budget -= ans * ( glass - refund ) ; ans += Math . floor ( budget / plastic ) ; document . write ( ans ) ; } else { document . write ( Math . floor ( budget / plastic ) ) ; } } let budget = 10 , plastic = 11 , glass = 9 , refund = 8 ; maxLitres ( budget , plastic , glass , refund ) ;
function leastValue ( P , A , N , a ) { let ans = - 1 ; let tmp = Number . MAX_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let t = ( P - a [ i ] * 0.006 ) ; if ( Math . abs ( t - A ) < tmp ) { tmp = Math . abs ( t - A ) ; ans = i ; } } return a [ ans ] ; } let N = 2 , P = 12 , A = 2005 ; let a = [ 1000 , 2000 ] ; document . write ( leastValue ( P , A , N , a ) )
function findPermutation ( n ) { let len = Math . ceil ( Math . log10 ( n ) ) ; for ( let i = 0 ; i < len ; i ++ ) { if ( n % 2 != 0 ) { return parseInt ( n ) ; } else { n = ( n / 10 ) + ( n % 10 ) * Math . pow ( 10 , len - i - 1 ) ; continue ; } } return - 1 ; } let n = 132 ; document . write ( findPermutation ( n ) ) ;
function isSellingPossible ( n , a ) { let i , c25 = 0 , c50 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 25 ) c25 ++ ; else if ( a [ i ] == 50 ) { c50 ++ ; if ( c25 == 0 ) break ; c25 -- ; } else { if ( c50 > 0 && c25 > 0 ) { c50 -- ; c25 -- ; } else if ( c25 >= 3 ) c25 -= 3 ; else break ; } } if ( i == n ) return true ; else return false ; } let a = [ 25 , 25 , 50 , 100 ] ; let n = a . length ; if ( isSellingPossible ( n , a ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function checkIfOverlap ( str ) { let len = str . length ; let visited = new Array ( len + 1 ) ; for ( let i = 0 ; i < visited . length ; i ++ ) { visited [ i ] = 0 ; } for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] == ' ' ) continue ; for ( let j = Math . max ( 0 , i - str [ i ] ) ; j <= Math . min ( len , i + str [ i ] ) ; j ++ ) visited [ j ] ++ ; } for ( let i = 0 ; i < len ; i ++ ) { if ( visited [ i ] > 1 ) { return true ; } } return false ; } let str = " " ; if ( checkIfOverlap ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isCorrectOrder ( n ) { let flag = true ; let prev = - 1 ; let type = - 1 ; while ( n != 0 ) { if ( type === - 1 ) { if ( prev === - 1 ) { prev = n % 10 ; n = Math . floor ( n / 10 ) ; continue ; } if ( prev == n % 10 ) { flag = false ; break ; } if ( prev > n % 10 ) { type = 1 ; prev = n % 10 ; n = Math . floor ( n / 10 ) ; continue ; } prev = n % 10 ; n = Math . floor ( n / 10 ) ; } else { if ( prev == n % 10 ) { flag = false ; break ; } if ( prev < n % 10 ) { flag = false ; break ; } prev = n % 10 ; n = Math . floor ( n / 10 ) ; } } return flag ; } let n = 123454321 ; if ( isCorrectOrder ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function printCoins ( arr , n ) { var oddSum = 0 ; for ( var i = 0 ; i < n ; i += 2 ) oddSum += arr [ i ] ; var evenSum = 0 ; for ( var i = 1 ; i < n ; i += 2 ) evenSum += arr [ i ] ; var start = ( ( oddSum > evenSum ) ? 0 : 1 ) ; for ( var i = start ; i < n ; i += 2 ) document . write ( arr [ i ] + " " ) ; } var arr1 = [ 8 , 15 , 3 , 7 ] var n = arr1 . length ; printCoins ( arr1 , n ) ; document . write ( " " ) ; var arr2 = [ 2 , 2 , 2 , 2 ] var n = arr2 . length ; printCoins ( arr2 , n ) ; document . write ( " " ) ; var arr3 = [ 20 , 30 , 2 , 2 , 2 , 10 ] n = arr3 . length ; printCoins ( arr3 , n ) ;
function finalPos ( command , n , x , y ) { let cup , cdown , cleft , cright ; let final_x , final_y ; cup = cdown = cleft = cright = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( command [ i ] == ' ' ) cup ++ ; else if ( command [ i ] == ' ' ) cdown ++ ; else if ( command [ i ] == ' ' ) cleft ++ ; else if ( command [ i ] == ' ' ) cright ++ ; } final_x = x + ( cright - cleft ) ; final_y = y + ( cdown - cup ) ; document . write ( " " + " " + final_x + " " + final_y + " " ) ; } let command = " " ; let n = command . length ; let x = 3 , y = 4 ; finalPos ( command , n , x , y ) ;
function smallestSumSubarr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) arr [ i ] = - arr [ i ] ; let sum_here = arr [ 0 ] , max_sum = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum_here = Math . max ( sum_here + arr [ i ] , arr [ i ] ) ; max_sum = Math . max ( max_sum , sum_here ) ; } return ( - 1 ) * max_sum ; } let arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] ; let n = arr . length ; document . write ( " " + smallestSumSubarr ( arr , n ) ) ;
function printLargest ( a , n ) { let max = - 1 ; let ind = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let num = a [ i ] ; while ( num > 0 ) { let r = num % 10 ; num = Math . floor ( num / 10 ) ; if ( num == 0 ) { if ( max < r ) { max = r ; ind = i ; } } } } for ( let i = ind ; i < n ; i ++ ) document . write ( a [ i ] ) ; for ( let i = 0 ; i < ind ; i ++ ) document . write ( a [ i ] ) ; } let a = [ 54 , 546 , 548 , 60 ] ; let n = a . length ; printLargest ( a , n ) ;
function MinOperation ( a , n , k ) { let result = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( a [ i ] != 1 && a [ i ] > k ) { result = result + Math . min ( a [ i ] % k , k - a [ i ] % k ) ; } else { result = result + k - a [ i ] ; } } return result ; } let arr = [ 4 , 5 , 6 ] ; let n = arr . length ; let k = 5 ; document . write ( MinOperation ( arr , n , k ) ) ;
function maxProductSubset ( a , n ) { if ( n == 1 ) return a [ 0 ] ; let max_neg = Number . MIN_SAFE_INTEGER ; let count_neg = 0 ; count_zero = 0 ; let prod = 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 0 ) { count_zero ++ ; continue ; } if ( a [ i ] < 0 ) { count_neg ++ ; max_neg = Math . max ( max_neg , a [ i ] ) ; } prod = prod * a [ i ] ; } if ( count_zero == n ) return 0 ; if ( count_neg & 1 ) { if ( count_neg == 1 && count_zero > 0 && count_zero + count_neg == n ) return 0 ; prod = prod / max_neg ; } return prod ; } let a = [ - 1 , - 1 , - 2 , 4 , 3 ] ; let n = a . length ; document . write ( maxProductSubset ( a , n ) ) ;
function digitsNum ( N ) { if ( N == 0 ) document . write ( " " ) ; if ( N % 9 != 0 ) document . write ( N % 9 ) ; for ( var i = 1 ; i <= N / 9 ; ++ i ) document . write ( " " ) ; for ( var i = 1 ; i <= N ; ++ i ) document . write ( " " ) ; document . write ( " " ) ; } var N = 5 ; document . write ( " " ) ; digitsNum ( N ) ;
function printVector ( v ) { document . write ( v . length + " " ) ; for ( var i = 0 ; i < v . length ; i ++ ) document . write ( v [ i ] + " " ) ; document . write ( " " ) ; } function findTwoGroup ( n ) { var sum = n * ( n + 1 ) / 2 ; var group1Sum = parseInt ( sum / 2 ) ; var group1 = [ ] , group2 = [ ] ; for ( var i = n ; i > 0 ; i -- ) { if ( group1Sum - i >= 0 ) { group1 . push ( i ) ; group1Sum -= i ; } else { group2 . push ( i ) ; } } printVector ( group1 ) ; printVector ( group2 ) ; } var n = 5 ; findTwoGroup ( n ) ;
function maxDifference ( arr , N , k ) { let M , S = 0 , S1 = 0 , max_difference = 0 ; for ( let i = 0 ; i < N ; i ++ ) S += arr [ i ] ; let temp ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; } } } M = Math . max ( k , N - k ) ; for ( let i = 0 ; i < M ; i ++ ) S1 += arr [ i ] ; max_difference = S1 - ( S - S1 ) ; return max_difference ; } let arr = [ 8 , 4 , 5 , 2 , 10 ] ; let N = arr . length ; let k = 2 ; document . write ( maxDifference ( arr , N , k ) ) ;
function minproduct ( a , b , n , k ) { let diff = 0 , res = 0 ; let temp = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let pro = a [ i ] * b [ i ] ; res = res + pro ; if ( pro < 0 && b [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro < 0 && a [ i ] < 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] < 0 ) temp = ( a [ i ] + 2 * k ) * b [ i ] ; else if ( pro > 0 && a [ i ] > 0 ) temp = ( a [ i ] - 2 * k ) * b [ i ] ; let d = Math . abs ( pro - temp ) ; if ( d > diff ) diff = d ; } return res - diff ; } let a = [ 2 , 3 , 4 , 5 , 4 ] ; let b = [ 3 , 4 , 2 , 3 , 2 ] ; let n = 5 , k = 3 ; document . write ( minproduct ( a , b , n , k ) ) ;
function c_ount ( n ) { if ( n < 4 ) return - 1 ; let rem = n % 4 ; if ( rem == 0 ) return n / 4 ; if ( rem == 1 ) { if ( n < 9 ) return - 1 ; return ( n - 9 ) / 4 + 1 ; } if ( rem == 2 ) return ( n - 6 ) / 4 + 1 ; if ( rem == 3 ) { if ( n < 15 ) return - 1 ; return ( n - 15 ) / 4 + 2 ; } } let n = 90 ; document . write ( c_ount ( n ) + " " ) ; n = 143 ; document . write ( c_ount ( n ) ) ;
function minRotation ( input , unlock_code ) { let rotation = 0 ; let input_digit , code_digit ; while ( input > 0 unlock_code > 0 ) { input_digit = input % 10 ; code_digit = unlock_code % 10 ; rotation += Math . min ( Math . abs ( input_digit - code_digit ) , 10 - Math . abs ( input_digit - code_digit ) ) ; input = Math . floor ( input / 10 ) ; unlock_code = Math . floor ( unlock_code / 10 ) ; } return rotation ; } let input = 28756 ; let unlock_code = 98234 ; document . write ( " " + minRotation ( input , unlock_code ) ) ;
function preprocess ( coin , n ) { coin . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 1 ; i <= n - 1 ; i ++ ) coin [ i ] += coin [ i - 1 ] ; } function minCost ( coin , n , k ) { let coins_needed = Math . ceil ( 1.0 * n / ( k + 1 ) ) ; return coin [ coins_needed - 1 ] ; } let coin = [ 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ] ; let n = coin . length ; preprocess ( coin , n ) ; let k = 3 ; document . write ( minCost ( coin , n , k ) + " " ) ; k = 7 ; document . write ( minCost ( coin , n , k ) ) ;
function maximumSum ( arr , n , k ) { for ( let i = 1 ; i <= k ; i ++ ) { let min = + 2147483647 ; let index = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( arr [ j ] < min ) { min = arr [ j ] ; index = j ; } } if ( min == 0 ) break ; arr [ index ] = - arr [ index ] ; } let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } let arr = [ - 2 , 0 , 5 , - 1 , 2 ] ; let k = 4 ; let n = arr . length ; document . write ( maximumSum ( arr , n , k ) ) ;
var maxLen = 10 ; var dp = Array ( maxLen ) ; var v = Array ( maxLen ) ; function maxSum ( arr , i , n ) { if ( i >= n ) return 0 ; if ( v [ i ] ) return dp [ i ] ; v [ i ] = 1 ; dp [ i ] = Math . max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) ; return dp [ i ] ; } var arr = [ 12 , 9 , 7 , 33 ] ; var n = arr . length ; document . write ( maxSum ( arr , 0 , n ) ) ;
var N = 5 ; function func ( idx , cur , a , dp , n , x ) { if ( idx == n ) { return 0 ; } if ( dp [ idx ] [ cur ] != - 1 ) { return dp [ idx ] [ cur ] ; } var ans = 0 ; if ( cur == 0 ) { ans = Math . max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) ; ans = Math . max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) ; } else if ( cur == 1 ) { ans = Math . max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) ; ans = Math . max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) ; { ans = Math . max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) ; } return dp [ idx ] [ cur ] = ans ; } function getMaximumSum ( a , n , x ) { var dp = Array ( n ) . fill ( ) . map ( ( ) => Array ( 3 ) . fill ( 0 ) ) ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } var maxi = 0 ; for ( i = 0 ; i < n ; i ++ ) { maxi = Math . max ( maxi , func ( i , 0 , a , dp , n , x ) ) ; } return maxi ; } var a = [ - 3 , 8 , - 2 , 1 , - 6 ] ; var n = a . length ; var x = - 1 ; document . write ( getMaximumSum ( a , n , x ) ) ;
var N = 100 ; function pre_process ( dp , s ) { var n = s . length ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = false ; } } for ( j = 1 ; j <= n ; j ++ ) { for ( i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } } } function countPairs ( s ) { var dp = Array ( N ) . fill ( ) . map ( ( ) => Array ( N ) . fill ( false ) ) ; pre_process ( dp , s ) ; var n = s . length ; var left = Array ( n ) . fill ( 0 ) ; var right = Array ( n ) . fill ( 0 ) ; left [ 0 ] = 1 ; for ( i = 1 ; i < n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) { if ( dp [ j ] [ i ] == true ) { left [ i ] ++ ; } } } right [ n - 1 ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { right [ i ] = right [ i + 1 ] ; for ( j = n - 1 ; j >= i ; j -- ) { if ( dp [ i ] [ j ] == true ) { right [ i ] ++ ; } } } var ans = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { ans += left [ i ] * right [ i + 1 ] ; } return ans ; } var s = " " ; document . write ( countPairs ( s ) ) ;
var N = 100 ; function pre_process ( dp , s ) { var n = s . length ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = false ; } } for ( j = 1 ; j <= n ; j ++ ) { for ( i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } } } function answerQuery ( l , r , dp ) { if ( dp [ l ] [ r ] ) { document . write ( " " ) ; } else { document . write ( " " ) ; } } var s = " " ; var dp = Array ( N ) . fill ( ) . map ( ( ) => Array ( N ) . fill ( ) ) ; pre_process ( dp , s ) ; var queries = [ [ 0 , 1 ] , [ 1 , 5 ] ] ; var q = queries . length ; for ( i = 0 ; i < q ; i ++ ) { answerQuery ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , dp ) ; }
let N = 100005 ; function LIS ( a , n ) { let dp = new Array ( ) ; let d = new Array ( ) ; let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { dp [ a [ i ] ] = 1 ; for ( j = 2 ; j * j <= a [ i ] ; j ++ ) { if ( a [ i ] % j == 0 ) { dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) ; dp [ a [ i ] ] = Math . max ( dp [ a [ i ] ] , dp [ d [ a [ i ] / j ] ] + 1 ) ; d [ j ] = a [ i ] ; d [ a [ i ] / j ] = a [ i ] ; } } ans = Math . max ( ans , dp [ a [ i ] ] ) ; d [ a [ i ] ] = a [ i ] ; } return ans ; } let a = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; let n = a . length ; document . write ( LIS ( a , n ) ) ;
let findSum ( n ) { let dp = new Array ( n + 1 ) ; dp [ 1 ] = 1 ; dp [ 0 ] = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( 4 * ( i * i ) ) - 6 * ( i - 1 ) + dp [ i - 2 ] ; } return dp [ n ] ; } let n = 4 ; document . write ( findSum ( n ) ) ;
var n = 3 ; var MAX = 30 ; var dp = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { dp [ i ] = Array ( n ) ; for ( var j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = Array ( MAX ) ; } } var v = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { v [ i ] = Array ( n ) ; for ( var j = 0 ; j < n ; j ++ ) { v [ i ] [ j ] = Array ( MAX ) ; } } function findCount ( mat , i , j , m ) { if ( i == 0 && j == 0 ) { if ( m == mat [ 0 ] [ 0 ] ) return 1 ; else return 0 ; } if ( m < 0 ) return 0 ; if ( i < 0 j < 0 ) return 0 ; if ( v [ i ] [ j ] [ m ] ) return dp [ i ] [ j ] [ m ] ; v [ i ] [ j ] [ m ] = true ; dp [ i ] [ j ] [ m ] = findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ; return dp [ i ] [ j ] [ m ] ; } var mat = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; var m = 5 ; document . write ( findCount ( mat , n - 1 , n - 1 , m ) ) ;
var N = 10 ; function findMinimumDeletion ( l , r , dp , s ) { if ( l > r ) return 0 ; if ( l == r ) return 1 ; if ( dp [ l ] [ r ] != - 1 ) return dp [ l ] [ r ] ; var res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) ; for ( var i = l + 1 ; i <= r ; ++ i ) { if ( s [ l ] == s [ i ] ) res = Math . min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) ; } return dp [ l ] [ r ] = res ; } var s = " " ; var n = s . length ; var dp = Array . from ( Array ( N ) , ( ) => Array ( N ) . fill ( - 1 ) ) ; document . write ( findMinimumDeletion ( 0 , n - 1 , dp , s ) ) ;
let N = 5005 ; let n , k ; let gr = new Array ( N ) ; let d = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { d [ i ] = new Array ( 505 ) ; for ( let j = 0 ; j < 505 ; j ++ ) { d [ i ] [ j ] = 0 ; } } let ans = 0 ; function Add_edge ( x , y ) { gr [ x ] . push ( y ) ; gr [ y ] . push ( x ) ; } function dfs ( v , par ) { d [ v ] [ 0 ] = 1 ; for ( let i = 0 ; i < gr [ v ] . length ; i ++ ) { if ( gr [ v ] [ i ] != par ) { dfs ( gr [ v ] [ i ] , v ) ; for ( let j = 1 ; j <= k ; j ++ ) ans += d [ gr [ v ] [ i ] ] [ j - 1 ] * d [ v ] [ k - j ] ; for ( let j = 1 ; j <= k ; j ++ ) d [ v ] [ j ] += d [ gr [ v ] [ i ] ] [ j - 1 ] ; } } } n = 5 ; k = 2 ; for ( let i = 0 ; i < N ; i ++ ) gr [ i ] = [ ] ; Add_edge ( 1 , 2 ) ; Add_edge ( 2 , 3 ) ; Add_edge ( 3 , 4 ) ; Add_edge ( 2 , 5 ) ; dfs ( 1 , 0 ) ; document . write ( ans ) ;
function findXorSum ( arr , n ) { let sum = 0 ; let mul = 1 ; for ( let i = 0 ; i < 30 ; i ++ ) { let c_odd = 0 ; let odd = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) odd = ( ! odd ) ; if ( odd ) c_odd ++ ; } for ( let j = 0 ; j < n ; j ++ ) { sum += ( mul * c_odd ) ; if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) c_odd = ( n - j - c_odd ) ; } mul *= 2 ; } return sum ; } let arr = [ 3 , 8 , 13 ] ; let n = arr . length ; document . write ( findXorSum ( arr , n ) ) ;
function checkCombinations ( a , n ) { var pow_set_size = parseInt ( Math . pow ( 2 , n ) ) ; var counter , j ; for ( counter = 0 ; counter < pow_set_size ; counter ++ ) { var sum = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( counter & ( 1 << j ) ) != 0 ) else } if ( sum % ( 24 * 60 ) == 0 ) return true ; } return false ; } var a = [ 60 , 60 , 120 ] ; var n = a . length ; if ( checkCombinations ( a , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
let n = 4 ; let m = 4 ; function calcProbability ( M , k ) { let dp = new Array ( m ) ; let sum = new Array ( n ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { sum [ i ] = 0 ; } for ( let j = 0 ; j < n ; j ++ ) { dp [ 0 ] [ j ] = M [ 0 ] [ j ] ; sum [ 0 ] = sum [ 0 ] + dp [ 0 ] [ j ] ; } for ( let i = 1 ; i < m ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] += dp [ i - 1 ] [ j ] / sum [ i - 1 ] + M [ i ] [ j ] ; sum [ i ] += dp [ i ] [ j ] ; } } return dp [ n - 1 ] [ k - 1 ] / sum [ n - 1 ] ; } let M = [ [ 1 , 1 , 0 , 3 ] , [ 2 , 3 , 2 , 3 ] , [ 9 , 3 , 0 , 2 ] , [ 2 , 3 , 2 , 2 ] ] ; let k = 3 ; document . write ( calcProbability ( M , k ) ) ;
function MaximumNumbers ( s ) { let n = s . length ; let remIndex = [ - 1 , - 1 , - 1 ] ; remIndex [ 0 ] = 0 ; let res = new Array ( n + 1 ) ; for ( let i = 0 ; i < res . length ; i ++ ) { res [ i ] = 0 ; } let r = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { r = ( r + s [ i - 1 ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) % 3 ; res [ i ] = res [ i - 1 ] ; if ( remIndex [ r ] != - 1 ) res [ i ] = Math . max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) ; remIndex [ r ] = i + 1 ; } return res [ n ] ; } let s = " " ; document . write ( MaximumNumbers ( s ) ) ;
let max = 4 ; let c = 2 ; function countPaths ( sum , get , m , n , dp ) { if ( sum < 0 ) return 0 ; if ( sum == 0 ) return get ; if ( dp [ sum ] [ get ] != - 1 ) return dp [ sum ] [ get ] ; let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i == m ) res += countPaths ( sum - i , 1 , m , n , dp ) ; else res += countPaths ( sum - i , get , m , n , dp ) ; } dp [ sum ] [ get ] = res ; return dp [ sum ] [ get ] ; } let n = 3 , m = 2 , x = 3 ; let dp = new Array ( max + 1 ) ; for ( let i = 0 ; i <= max ; i ++ ) { dp [ i ] = new Array ( 2 ) for ( let j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = - 1 ; } document . write ( countPaths ( x , 0 , m , n , dp ) ) ;
var MAX_K = 15 ; var fac = Array ( MAX_K ) . fill ( 0 ) ; function factorial ( k ) { fac [ 0 ] = 1 ; for ( i = 1 ; i <= k + 1 ; i ++ ) { fac [ i ] = ( i * fac [ i - 1 ] ) ; } } function bin ( a , b ) { var ans = ( ( fac [ a ] ) / ( fac [ a - b ] * fac [ b ] ) ) ; return ans ; } function sumofn ( n , k ) { var p = 0 ; var num1 , temp ; var arr = Array ( 1000 ) . fill ( 0 ) ; for ( j = 1 ; j <= k ; j ++ ) { if ( j == 1 ) { num1 = ( n * ( n + 1 ) ) / 2 ; arr [ p ++ ] = num1 ; temp = num1 ; } else { temp = ( parseInt ( Math . pow ( n + 1 , j + 1 ) - 1 - n ) ) ; for ( s = 1 ; s < j ; s ++ ) { temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) ; } temp = temp / ( j + 1 ) ; arr [ p ++ ] = temp ; } } temp = arr [ p - 1 ] ; return temp ; } var n = 5 , k = 2 ; factorial ( k ) ; document . write ( sumofn ( n , k ) ) ;
let max = 4 ; function countWays ( index , cnt , dp , n , m , k ) { if ( index == n ) { if ( cnt == k ) return 1 ; else return 0 ; } if ( dp [ index ] [ cnt ] != - 1 ) return dp [ index ] [ cnt ] ; let ans = 0 ; ans += countWays ( index + 1 , cnt , dp , n , m , k ) ; ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) ; return dp [ index ] [ cnt ] = ans ; } let n = 3 , m = 3 , k = 2 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( max ) ; for ( let j = 0 ; j < max ; j ++ ) dp [ i ] [ j ] = - 1 ; } document . write ( m * countWays ( 1 , 0 , dp , n , m , k ) ) ;
function calculateEvenSum ( n ) { if ( n <= 0 ) return 0 ; let fibo = Array ( 2 * n + 1 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = 0 ; for ( i = 2 ; i <= 2 * n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; if ( i % 2 == 0 ) sum += fibo [ i ] ; } return sum ; } let n = 8 ; document . write ( " " + n + " " + + calculateEvenSum ( n ) ) ;
var MAX = 32768 ; var arr = Array ( 2 * MAX ) ; function gouldSequence ( ) { arr [ 0 ] = 1 ; var i = 1 ; var p = 1 ; while ( i <= MAX ) { var j = 0 ; while ( j < i ) { arr [ i + j ] = 2 * arr [ j ] ; j ++ ; } i = ( 1 << p ) ; p ++ ; } } function printSequence ( n ) { for ( var i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + " " ) ; } } gouldSequence ( ) ; var n = 16 ; printSequence ( n ) ;
function MatrixChainOrder ( p , n ) { var dp = Array . from ( Array ( n ) , ( ) => Array ( n ) ) ; for ( var i = 1 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; for ( var L = 1 ; L < n - 1 ; L ++ ) for ( var i = 1 ; i < n - L ; i ++ ) dp [ i ] [ i + L ] = Math . min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) ; return dp [ 1 ] [ n - 1 ] ; } var arr = [ 10 , 20 , 30 , 40 , 30 ] ; var size = arr . length ; document . write ( " " + MatrixChainOrder ( arr , size ) ) ;
function CommomSubsequencesCount ( s , t ) { var n1 = s . length ; var n2 = t . length ; var dp = Array . from ( Array ( n1 + 1 ) , ( ) => Array ( n2 + 1 ) ) ; for ( var i = 0 ; i <= n1 ; i ++ ) { for ( var j = 0 ; j <= n2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( var i = 1 ; i <= n1 ; i ++ ) { for ( var j = 1 ; j <= n2 ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] ; } } return dp [ n1 ] [ n2 ] ; } var s = " " ; var t = " " ; document . write ( CommomSubsequencesCount ( s , t ) ) ;
let fib = new Array ( 43 ) ; function fibonacci ( ) { fib [ 0 ] = 1 ; fib [ 1 ] = 2 ; for ( let i = 2 ; i < 43 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; } function rec ( x , y , last ) { if ( y == 0 ) { if ( x == 0 ) return 1 ; return 0 ; } let sum = 0 ; for ( let i = last ; i >= 0 && fib [ i ] * y >= x ; i -- ) { if ( fib [ i ] > x ) continue ; sum += rec ( x - fib [ i ] , y - 1 , i ) ; } return sum ; } fibonacci ( ) ; let n = 13 , k = 3 ; document . write ( " " + rec ( n , k , 42 ) ) ;
function minimumCost ( cost , n ) { let dp = new Array ( n ) ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( let i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; } let a = [ 16 , 19 , 10 , 12 , 18 ] ; let n = a . length ; document . write ( minimumCost ( a , n ) ) ;
function minimumCost ( cost , n ) { let dp1 = 0 , dp2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let dp0 = cost [ i ] + Math . min ( dp1 , dp2 ) ; dp2 = dp1 ; dp1 = dp0 ; } return Math . min ( dp1 , dp2 ) ; } let a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] ; let n = a . length ; document . write ( minimumCost ( a , n ) ) ;
function editDistanceWith2Ops ( X , Y ) { let m = X . length , n = Y . length ; let L = new Array ( m + 1 ) ; for ( let i = 0 ; i < L . length ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < L [ i ] . length ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { L [ i ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; } else { L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } } let lcs = L [ m ] [ n ] ; return ( m - lcs ) + ( n - lcs ) ; } let X = " " , Y = " " ; document . write ( editDistanceWith2Ops ( X , Y ) ) ;
function lcs ( X , Y , m , n ) { if ( m == 0 n == 0 ) { return 0 ; } if ( X [ m - 1 ] == Y [ n - 1 ] ) { return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; } else { return Math . max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } } let X = " " ; let Y = " " ; let m = X . length ; let n = Y . length ; document . write ( " " + lcs ( X , Y , m , n ) ) ;
function countPaths ( n ) { let zB = 1 ; let zADC = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let nzB = zADC * 3 ; let nzADC = ( zADC * 2 + zB ) ; zB = nzB ; zADC = nzADC ; } return zB ; } let n = 3 ; document . write ( countPaths ( n ) ) ;
function lds ( arr , n ) { let lds = new Array ( n ) ; let i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; } let arr = [ 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 ] ; let n = arr . length ; document . write ( " " + lds ( arr , n ) ) ;
var MAX = 100 ; function binomialCoeff ( C , n ) { for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = Math . min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } } function sumOfproduct ( n ) { var sum = 0 ; var C = Array ( MAX ) . fill ( 0 ) ; binomialCoeff ( C , n ) ; for ( var i = 0 ; i <= n ; i ++ ) sum += C [ i ] * C [ i + 1 ] ; return sum ; } var n = 3 ; document . write ( sumOfproduct ( n ) ) ;
MAX = 100 function binomialCoeff ( n , C ) { for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = Math . min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } } function summation ( n ) { C = Array ( MAX ) . fill ( 0 ) ; binomialCoeff ( n , C ) ; var sum = 0 ; for ( var i = 0 ; i <= n ; i ++ ) sum += ( i * C [ i ] ) ; return sum ; } var n = 2 ; document . write ( summation ( n ) ) ;
function binomialCoeff ( n , k ) { var C = Array ( k + 1 ) . fill ( 0 ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } function countArray ( N , K ) { return binomialCoeff ( K - 1 , N - 1 ) ; } var N = 2 , K = 3 ; document . write ( countArray ( N , K ) ) ;
function findMaxVal ( arr , n , num , maxLimit ) { var ind ; var val ; var dp = Array . from ( Array ( n ) , ( ) => Array ( maxLimit + 1 ) ) ; for ( ind = 0 ; ind < n ; ind ++ ) { for ( val = 0 ; val <= maxLimit ; val ++ ) { if ( ind == 0 ) { if ( num - arr [ ind ] == val num + arr [ ind ] == val ) { dp [ ind ] [ val ] = 1 ; } else { dp [ ind ] [ val ] = 0 ; } } else { if ( val - arr [ ind ] >= 0 && val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] || dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else if ( val - arr [ ind ] >= 0 ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; } else if ( val + arr [ ind ] <= maxLimit ) { dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; } else { dp [ ind ] [ val ] = 0 ; } } } } for ( val = maxLimit ; val >= 0 ; val -- ) { if ( dp [ n - 1 ] [ val ] ) { return val ; } } return - 1 ; } var num = 1 ; var arr = [ 3 , 10 , 6 , 4 , 5 ] ; var n = arr . length ; var maxLimit = 15 ; document . write ( findMaxVal ( arr , n , num , maxLimit ) ) ;
function gen ( n ) { if ( n == 0 ) return 0 ; else if ( n == 1 ) return 1 ; else if ( n % 2 == 0 ) return 4 * gen ( parseInt ( n / 2 , 10 ) ) ; else if ( n % 2 == 1 ) return 4 * gen ( parseInt ( n / 2 , 10 ) ) + 1 ; return 0 ; } function moserDeBruijn ( n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( gen ( i ) + " " ) ; document . write ( " " ) ; } let n = 15 ; document . write ( " " + n + " " + " " + " " ) ; moserDeBruijn ( n ) ;
let A = [ [ 2 ] , [ 3 , 9 ] , [ 1 , 6 , 7 ] ] ; function minSumPath ( ) { let memo = [ ] ; let n = A . length - 1 ; for ( let i = 0 ; i < A [ n ] . length ; i ++ ) memo [ i ] = A [ n ] [ i ] ; for ( let i = A . length - 2 ; i >= 0 ; i -- ) for ( let j = 0 ; j < A [ i ] . length ; j ++ ) memo [ j ] = A [ i ] [ j ] + Math . min ( memo [ j ] , memo [ j + 1 ] ) ; return memo [ 0 ] ; } document . write ( minSumPath ( ) ) ;
let MAX = 100 ; let dp = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new Array ( MAX ) ; } function countRemovals ( a , i , j , k ) { if ( i >= j ) return 0 ; else if ( ( a [ j ] - a [ i ] ) <= k ) return 0 ; else if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; else if ( ( a [ j ] - a [ i ] ) > k ) { dp [ i ] [ j ] = 1 + Math . min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) ; } return dp [ i ] [ j ] ; } function removals ( a , n , k ) { a . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < MAX ; i ++ ) { for ( let j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } if ( n == 1 ) return 0 ; else return countRemovals ( a , 0 , n - 1 , k ) ; } let a = [ 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 ] ; let n = a . length ; let k = 4 ; document . write ( removals ( a , n , k ) ) ;
var dp = Array . from ( Array ( 1000 ) , ( ) => Array ( 1000 ) ) ; function sum ( a , i , j ) { var ans = 0 ; for ( var m = i ; m <= j ; m ++ ) ans = ( ans + a [ m ] ) % 100 ; return ans ; } function solve ( a , i , j ) { if ( i == j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; dp [ i ] [ j ] = 1000000000 ; for ( var k = i ; k < j ; k ++ ) { dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) ; } return dp [ i ] [ j ] ; } function initialize ( n ) { for ( var i = 0 ; i <= n ; i ++ ) for ( var j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = - 1 ; } var a = [ 40 , 60 , 20 ] ; var n = a . length ; initialize ( n ) ; document . write ( solve ( a , 0 , n - 1 ) ) ;
function reverseFibonacci ( n ) { let a = [ ] ; a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( let i = 2 ; i < n ; i ++ ) { a [ i ] = a [ i - 2 ] + a [ i - 1 ] ; } for ( let i = n - 1 ; i >= 0 ; i -- ) { document . write ( a [ i ] + " " ) ; } } let n = 5 ; reverseFibonacci ( n ) ;
function find_prob ( N , P ) { let dp = [ ] ; dp [ 0 ] = 1 ; dp [ 1 ] = 0 ; dp [ 2 ] = P ; dp [ 3 ] = 1 - P ; for ( let i = 4 ; i <= N ; ++ i ) dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] ; return ( dp [ N ] ) ; } let n = 5 ; let p = 0.2 ; document . write ( find_prob ( n , p ) ) ;
var N = 5 function printHosoya ( n ) { var dp = Array . from ( Array ( N ) , ( ) => Array ( N ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 ; for ( var i = 2 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { if ( i > j ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ; } } for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) document . write ( dp [ i ] [ j ] + " " ) ; document . write ( " " ) ; } } var n = 5 ; printHosoya ( n ) ;
function numberofways ( n , m ) { let dp = new Array ( n + 2 ) ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( n + 2 ) ; for ( let j = 0 ; j < dp [ i ] . length ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ n + 1 ] = 1 ; for ( let k = n ; k >= m ; k -- ) { for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] [ k ] = dp [ i ] [ k + 1 ] ; if ( i - k >= 0 ) dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) ; } } return dp [ n ] [ m ] ; } let n = 3 , m = 1 ; document . write ( numberofways ( n , m ) ) ;
function zigzag ( n , k ) { if ( n == 0 && k == 0 ) return 1 ; if ( k == 0 ) return 0 ; return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; } n = 4 ; k = 3 ; document . write ( zigzag ( n , k ) ) ;
function eulerian ( n , m ) { var dp = Array . from ( Array ( n + 1 ) , ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 0 ; j <= m ; j ++ ) { if ( i > j ) { if ( j == 0 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ; } } } return dp [ n ] [ m ] ; } var n = 3 , m = 1 ; document . write ( eulerian ( n , m ) ) ;
function dealnnoy ( n , m ) { if ( m == 0 n == 0 ) return 1 ; return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) ; } let n = 3 , m = 4 ; document . write ( dealnnoy ( n , m ) ) ;
function dealnnoy ( n , m ) { var dp = Array . from ( Array ( m + 1 ) , ( ) => Array ( n + 1 ) ) ; for ( var i = 0 ; i <= m ; i ++ ) dp [ i ] [ 0 ] = 1 ; for ( var i = 0 ; i <= m ; i ++ ) dp [ 0 ] [ i ] = 1 ; for ( var i = 1 ; i <= m ; i ++ ) for ( var j = 1 ; j <= n ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; return dp [ m ] [ n ] ; } var n = 3 , m = 4 ; document . write ( dealnnoy ( n , m ) ) ;
function longestAlternating ( arr , n ) { let count = new Array ( n ) ; count [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] * arr [ i + 1 ] < 0 ) count [ i ] = count [ i + 1 ] + 1 ; else count [ i ] = 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count [ i ] + " " ) ; } let a = [ - 5 , - 1 , - 1 , 2 , - 2 , - 3 ] ; let n = a . length ; longestAlternating ( a , n ) ;
function maxDP ( n ) { let res = [ ] ; res [ 0 ] = 0 ; res [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { res [ i ] = Math . max ( i , ( res [ Math . floor ( i / 2 ) ] + res [ Math . floor ( i / 3 ) ] + res [ Math . floor ( i / 4 ) ] + res [ Math . floor ( i / 5 ) ] ) ) ; } return res [ n ] ; } let n = 60 ; document . write ( " " + maxDP ( n ) ) ;
R = 4 C = 3 function isSafe ( x , y ) { return ( x < R && y < C ) ; } function minJump ( height , x , y ) { if ( x == R - 1 && y == C - 1 ) return 0 ; var diag = 1000000000 ; if ( isSafe ( x + 1 , y + 1 ) ) diag = minJump ( height , x + 1 , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ; var down = 1000000000 ; if ( isSafe ( x + 1 , y ) ) down = minJump ( height , x + 1 , y ) + Math . abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ; var right = 1000000000 ; if ( isSafe ( x , y + 1 ) ) right = minJump ( height , x , y + 1 ) + Math . abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ; return Math . min ( down , Math . min ( right , diag ) ) ; } var height = [ [ 5 , 4 , 2 ] , [ 9 , 2 , 1 ] , [ 2 , 5 , 9 ] , [ 1 , 3 , 11 ] ] ; document . write ( minJump ( height , 0 , 0 ) ) ;
function alternateSubarray ( arr , n ) { let len = new Array ( n ) ; len [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; -- i ) { if ( arr [ i ] ^ arr [ i + 1 ] == 1 ) len [ i ] = len [ i + 1 ] + 1 ; else len [ i ] = 1 ; } for ( let i = 0 ; i < n ; ++ i ) document . write ( len [ i ] + " " ) ; } let arr = [ 1 , 0 , 1 , 0 , 0 , 1 ] ; let n = arr . length ; alternateSubarray ( arr , n ) ;
function alternateSubarray ( arr , n ) { let count = 1 ; let prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; ++ i ) { if ( ( arr [ i ] ^ prev ) == false ) { while ( count > 0 ) { document . write ( count -- + " " ) ; } } ++ count ; prev = arr [ i ] ; } while ( count != 0 ) { document . write ( count -- + " " ) ; } } let arr = [ true , false , true , false , false , true ] ; let n = arr . length ; alternateSubarray ( arr , n ) ;
function countWays ( n ) { let dp = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; } dp [ 0 ] [ 1 ] = 1 ; dp [ 1 ] [ 1 ] = 2 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] ; dp [ 1 ] [ i ] = dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ; } return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] ; } let n = 5 ; document . write ( " " + n + " " + countWays ( n ) ) ;
function maxLenSub ( arr , n ) { let mls = new Array ( n ) . fill ( 1 ) , max = 0 ; for ( let i = 0 ; i < n ; i ++ ) mls [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( Math . abs ( arr [ i ] - arr [ j ] ) <= 1 && mls [ i ] < mls [ j ] + 1 ) mls [ i ] = mls [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( max < mls [ i ] ) max = mls [ i ] ; return max ; } let arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] ; let n = arr . length ; document . write ( " " + maxLenSub ( arr , n ) ) ;
function findWinner ( x , y , n ) { var dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 0 ] = false ; dp [ 1 ] = true ; for ( var i = 2 ; i <= n ; i ++ ) { if ( i - 1 >= 0 && ! dp [ i - 1 ] ) dp [ i ] = true ; else if ( i - x >= 0 && ! dp [ i - x ] ) dp [ i ] = true ; else if ( i - y >= 0 && ! dp [ i - y ] ) dp [ i ] = true ; else dp [ i ] = false ; } return dp [ n ] ; } var x = 3 , y = 4 , n = 5 ; if ( findWinner ( x , y , n ) ) document . write ( ' ' ) ; else document . write ( ' ' ) ;
function maxGameByWinner ( N ) { let dp = new Array ( N ) . fill ( 0 ) ; dp [ 0 ] = 1 ; dp [ 1 ] = 2 ; let i = 2 ; do { dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; } while ( dp [ i ++ ] <= N ) ; return ( i - 2 ) ; } let N = 10 ; document . write ( maxGameByWinner ( N ) ) ;
function minRemove ( arr , n ) { let LIS = new Array ( n ) . fill ( 0 ) ; let len = 0 ; for ( let i = 0 ; i < n ; i ++ ) LIS [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] > arr [ j ] && ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) LIS [ i ] = Math . max ( LIS [ i ] , LIS [ j ] + 1 ) ; } len = Math . max ( len , LIS [ i ] ) ; } return n - len ; } let arr = [ 1 , 2 , 6 , 5 , 4 ] ; let n = arr . length ; document . write ( minRemove ( arr , n ) ) ;
var MAX = 1000 ; function maxSubsequenceSubstring ( x , y , n , m ) { var dp = Array . from ( Array ( MAX ) , ( ) => Array ( MAX ) ) ; for ( var i = 0 ; i <= m ; i ++ ) for ( var j = 0 ; j <= n ; j ++ ) dp [ i ] [ j ] = 0 ; for ( var i = 1 ; i <= m ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( x [ j - 1 ] == y [ i - 1 ] ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] ; } } var ans = 0 ; for ( var i = 1 ; i <= m ; i ++ ) ans = Math . max ( ans , dp [ i ] [ n ] ) ; return ans ; } var x = " " ; var y = " " ; var n = x . length , m = y . length ; document . write ( maxSubsequenceSubstring ( x , y , n , m ) ) ;
function maxSum ( grid , n ) { let incl = Math . max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) ; let excl = 0 , excl_new ; for ( let i = 1 ; i < n ; i ++ ) { excl_new = Math . max ( excl , incl ) ; incl = excl + Math . max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) ; excl = excl_new ; } return Math . max ( excl , incl ) ; } let grid = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 6 , 7 , 8 , 9 , 10 ] ] ; let n = 5 ; document . write ( maxSum ( grid , n ) ) ;
function minInsertionStepToSortArray ( arr , N ) { let lis = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { lis [ i ] = 1 ; } for ( let i = 1 ; i < N ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { if ( arr [ i ] >= arr [ j ] && lis [ i ] < lis [ j ] + 1 ) { lis [ i ] = lis [ j ] + 1 ; } } } let max = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( max < lis [ i ] ) { max = lis [ i ] ; } } return ( N - max ) ; } let arr = new Array ( 2 , 3 , 5 , 1 , 4 , 7 , 6 ) ; let N = arr . length ; document . write ( minInsertionStepToSortArray ( arr , N ) ) ;
function countWaysToJump ( arr , n ) { let count_jump = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { count_jump [ i ] = 0 ; } for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] >= n - i - 1 ) count_jump [ i ] ++ ; for ( let j = i + 1 ; j < n - 1 && j <= arr [ i ] + i ; j ++ ) if ( count_jump [ j ] != - 1 ) count_jump [ i ] += count_jump [ j ] ; if ( count_jump [ i ] == 0 ) count_jump [ i ] = - 1 ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( count_jump [ i ] + " " ) ; } let arr = [ 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 ] ; let n = arr . length ; countWaysToJump ( arr , n ) ;
function minStepToDeleteString ( str ) { let N = str . length ; let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i <= N ; i ++ ) { dp [ i ] = new Array ( N + 1 ) ; for ( let j = 0 ; j <= N ; j ++ ) dp [ i ] [ j ] = 0 ; } for ( let len = 1 ; len <= N ; len ++ ) { for ( let i = 0 , j = len - 1 ; j < N ; i ++ , j ++ ) { if ( len == 1 ) dp [ i ] [ j ] = 1 ; else { dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] ; if ( str [ i ] == str [ i + 1 ] ) dp [ i ] [ j ] = Math . min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) ; for ( let K = i + 2 ; K <= j ; K ++ ) if ( str [ i ] == str [ K ] ) dp [ i ] [ j ] = Math . min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) ; } } } return dp [ 0 ] [ N - 1 ] ; } let str = " " ; document . write ( minStepToDeleteString ( str ) ) ;
let inf = 1000000000 ; let ans = inf ; function solve ( i , par , a , n , k , current_ans ) { if ( par > k ) return ; if ( par == k && i == n - 1 ) { ans = Math . min ( ans , current_ans ) ; return ; } for ( let j = i + 1 ; j < n ; j ++ ) solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) ; } let k = 2 ; let a = [ 1 , 5 , 8 , 10 ] ; let n = a . length ; solve ( - 1 , 0 , a , n , k , 0 ) ; document . write ( ans ) ;
function stringReduction ( str ) { var n = str . length ; var count = Array . from ( { length : 3 } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; ++ i ) { count [ str . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } if ( count [ 0 ] == n count [ 1 ] == n count [ 2 ] == n ) { return n ; } if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) && ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) { return 2 ; } return 1 ; } var str = " " ; document . write ( stringReduction ( str ) ) ;
function countSubsequences ( s ) { let aCount = 0 ; let bCount = 0 ; let cCount = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) aCount = ( 1 + 2 * aCount ) ; else if ( s [ i ] == ' ' ) bCount = ( aCount + 2 * bCount ) ; else if ( s [ i ] == ' ' ) cCount = ( bCount + 2 * cCount ) ; } return cCount ; } let s = " " ; document . write ( countSubsequences ( s ) ) ;
function maxRevenue ( m , x , revenue , n , t ) { let maxRev = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) maxRev [ i ] = 0 ; let nxtbb = 0 ; for ( let i = 1 ; i <= m ; i ++ ) { if ( nxtbb < n ) { if ( x [ nxtbb ] != i ) maxRev [ i ] = maxRev [ i - 1 ] ; else { if ( i <= t ) maxRev [ i ] = Math . max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) ; else maxRev [ i ] = Math . max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; nxtbb ++ ; } } else maxRev [ i ] = maxRev [ i - 1 ] ; } return maxRev [ m ] ; } let m = 20 ; let x = [ 6 , 7 , 12 , 13 , 14 ] ; let revenue = [ 5 , 6 , 5 , 3 , 1 ] ; let n = x . length ; let t = 5 ; document . write ( maxRevenue ( m , x , revenue , n , t ) ) ;
let Row = 6 , Col = 6 ; function largestKSubmatrix ( a ) { let dp = new Array ( Row ) ; for ( let i = 0 ; i < Row ; i ++ ) { dp [ i ] = new Array ( Col ) ; for ( let j = 0 ; j < Col ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let result = 0 ; for ( let i = 0 ; i < Row ; i ++ ) { for ( let j = 0 ; j < Col ; j ++ ) { if ( i == 0 j == 0 ) dp [ i ] [ j ] = 1 ; else { if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] && a [ i ] [ j ] == a [ i ] [ j - 1 ] && a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) { dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] > dp [ i ] [ j - 1 ] && dp [ i - 1 ] [ j ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i - 1 ] [ j ] : ( dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j ] && dp [ i ] [ j - 1 ] > dp [ i - 1 ] [ j - 1 ] + 1 ) ? dp [ i ] [ j - 1 ] : dp [ i - 1 ] [ j - 1 ] + 1 ; } else dp [ i ] [ j ] = 1 ; } result = result > dp [ i ] [ j ] ? result : dp [ i ] [ j ] ; } } return result ; } let a = [ [ 2 , 2 , 3 , 3 , 4 , 4 ] , [ 5 , 5 , 7 , 7 , 7 , 4 ] , [ 1 , 2 , 7 , 7 , 7 , 4 ] , [ 4 , 4 , 7 , 7 , 7 , 4 ] , [ 5 , 5 , 5 , 1 , 2 , 7 ] , [ 8 , 7 , 9 , 4 , 4 , 4 ] ] ; document . write ( largestKSubmatrix ( a ) ) ;
let fact ; function probability ( k , n ) { let ans = 0 , i ; for ( i = k ; i <= n ; ++ i ) ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) ; ans = ans / ( 1 << n ) ; return ans ; } function precompute ( ) { fact [ 0 ] = fact [ 1 ] = 1 ; for ( let i = 2 ; i < 20 ; ++ i ) fact [ i ] = fact [ i - 1 ] * i ; } fact = Array ( 100 ) . fill ( 0 ) ; precompute ( ) ; document . write ( probability ( 2 , 3 ) + " " ) ; document . write ( probability ( 3 , 6 ) + " " ) ; document . write ( probability ( 12 , 18 ) . toFixed ( 6 ) + " " ) ;
function countStrings ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = new Array ( 2 ) ; for ( let l = 0 ; l < 2 ; l ++ ) { dp [ i ] [ j ] [ l ] = 0 ; } } } dp [ 1 ] [ 0 ] [ 0 ] = 1 ; dp [ 1 ] [ 0 ] [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { for ( let j = 0 ; j < i && j < k + 1 ; j ++ ) { dp [ i ] [ j ] [ 0 ] = dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ; dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] ; if ( j - 1 >= 0 ) { dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] ; } } } return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] ; } let n = 5 , k = 2 ; document . write ( countStrings ( n , k ) ) ;
let dp = new Array ( 1000 ) ; function countFriendsPairings ( n ) { if ( dp [ n ] != - 1 ) return dp [ n ] ; if ( n > 2 ) return dp [ n ] = countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ; else return dp [ n ] = n ; } for ( let i = 0 ; i < 1000 ; i ++ ) dp [ i ] = - 1 ; let n = 4 ; document . write ( countFriendsPairings ( n ) ) ;
let N = 3 ; function maxPathSum ( tri , m , n ) { for ( let i = m - 1 ; i >= 0 ; i -- ) { for ( let j = 0 ; j <= i ; j ++ ) { if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] ; } } return tri [ 0 ] [ 0 ] ; } let tri = [ [ 1 , 0 , 0 ] , [ 4 , 8 , 0 ] , [ 1 , 5 , 3 ] ] ; document . write ( maxPathSum ( tri , 2 , 2 ) ) ;
let X = " " ; let Y = " " ; let Z = " " ; let dp = new Array ( 100 ) ; for ( let i = 0 ; i < 100 ; i ++ ) { dp [ i ] = new Array ( 100 ) ; for ( let j = 0 ; j < 100 ; j ++ ) { dp [ i ] [ j ] = new Array ( 100 ) ; for ( let k = 0 ; k < 100 ; k ++ ) { dp [ i ] [ j ] [ k ] = - 1 ; } } } function lcsOf3 ( i , j , k ) { if ( i == - 1 j == - 1 k == - 1 ) { return 0 ; } if ( dp [ i ] [ j ] [ k ] != - 1 ) { return dp [ i ] [ j ] [ k ] ; } if ( X [ i ] == Y [ j ] && Y [ j ] == Z [ k ] ) { return dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) ; } else { return dp [ i ] [ j ] [ k ] = Math . max ( Math . max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) ; } } let m = X . length ; let n = Y . length ; let o = Z . length ; document . write ( " " + lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) ;
let R = 4 ; let C = 4 ; function countPaths ( maze ) { if ( maze [ 0 ] [ 0 ] == - 1 ) return 0 ; for ( let i = 0 ; i < R ; i ++ ) { if ( maze [ i ] [ 0 ] == 0 ) maze [ i ] [ 0 ] = 1 ; else break ; } for ( let i = 1 ; i < C ; i ++ ) { if ( maze [ 0 ] [ i ] == 0 ) maze [ 0 ] [ i ] = 1 ; else break ; } for ( let i = 1 ; i < R ; i ++ ) { for ( let j = 1 ; j < C ; j ++ ) { if ( maze [ i ] [ j ] == - 1 ) continue ; if ( maze [ i - 1 ] [ j ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) ; if ( maze [ i ] [ j - 1 ] > 0 ) maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) ; } } return ( maze [ R - 1 ] [ C - 1 ] > 0 ) ? maze [ R - 1 ] [ C - 1 ] : 0 ; } let maze = [ [ 0 , 0 , 0 , 0 ] , [ 0 , - 1 , 0 , 0 ] , [ - 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] ; document . write ( countPaths ( maze ) ) ;
let N = 4 ; function maxDecimalValue ( mat , i , j , p ) { if ( i >= N j >= N ) { return 0 ; } let result = Math . max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) ; if ( mat [ i ] [ j ] == 1 ) { return ( Math . pow ( 2 , p ) + result ) ; } else { return result ; } } let mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] ; document . write ( maxDecimalValue ( mat , 0 , 0 , 0 ) ) ;
function CountPS ( str , n ) { let dp = new Array ( n ) ; let P = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; P [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; P [ i ] [ j ] = false ; } } for ( let i = 0 ; i < n ; i ++ ) P [ i ] [ i ] = true ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] == str [ i + 1 ] ) { P [ i ] [ i + 1 ] = true ; dp [ i ] [ i + 1 ] = 1 ; } } for ( let gap = 2 ; gap < n ; gap ++ ) { for ( let i = 0 ; i < n - gap ; i ++ ) { let j = gap + i ; if ( str [ i ] == str [ j ] && P [ i + 1 ] [ j - 1 ] ) P [ i ] [ j ] = true ; if ( P [ i ] [ j ] == true ) dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ; } } return dp [ 0 ] [ n - 1 ] ; } let str = " " ; document . write ( CountPS ( str . split ( " " ) , str . length ) ) ;
function maxSumWO3Consec ( arr , n ) { let sum = [ ] ; if ( n >= 1 ) sum [ 0 ] = arr [ 0 ] ; if ( n >= 2 ) sum [ 1 ] = arr [ 0 ] + arr [ 1 ] ; if ( n > 2 ) sum [ 2 ] = Math . max ( sum [ 1 ] , Math . max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) ; for ( let i = 3 ; i < n ; i ++ ) sum [ i ] = Math . max ( Math . max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) ; return sum [ n - 1 ] ; } let arr = [ 100 , 1000 , 100 , 1000 , 1 ] ; let n = arr . length ; document . write ( maxSumWO3Consec ( arr , n ) ) ;
function maxSumPairWithDifferenceLessThanK ( arr , N , K ) { arr . sort ( ) ; let dp = [ ] ; dp [ 0 ] = 0 ; for ( let i = 1 ; i < N ; i ++ ) { dp [ i ] = dp [ i - 1 ] ; if ( arr [ i ] - arr [ i - 1 ] < K ) { if ( i >= 2 ) dp [ i ] = Math . max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; else dp [ i ] = Math . max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; } } return dp [ N - 1 ] ; } let arr = [ 3 , 5 , 10 , 15 , 17 , 12 , 9 ] ; let N = arr . length ; let K = 4 ; document . write ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) ;
function lucas ( n ) { if ( n == 0 ) return 2 ; if ( n == 1 ) return 1 ; return lucas ( n - 1 ) + lucas ( n - 2 ) ; } let n = 9 ; document . write ( lucas ( n ) ) ;
function breakSum ( n ) { if ( n == 0 n == 1 ) return n ; return Math . max ( ( breakSum ( Math . floor ( n / 2 ) ) + breakSum ( Math . floor ( n / 3 ) ) + breakSum ( Math . floor ( n / 4 ) ) ) , n ) ; } let n = 12 ; document . write ( breakSum ( n ) ) ;
function countPS ( str ) { let N = str . length ; let cps = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { cps [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { cps [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) cps [ i ] [ i ] = 1 ; for ( let L = 2 ; L <= N ; L ++ ) { for ( let i = 0 ; i <= N - L ; i ++ ) { let k = L + i - 1 ; if ( str [ i ] == str [ k ] ) { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ; } else { cps [ i ] [ k ] = cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ; } } } return cps [ 0 ] [ N - 1 ] ; } let str = " " ; document . write ( " " + " " + countPS ( str ) ) ;
let n ; let dp = new Array ( 1000 ) ; for ( let i = 0 ; i < 1000 ; i ++ ) { dp [ i ] = new Array ( 1000 ) ; for ( let j = 0 ; j < 1000 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } let str = " " ; function countPS ( i , j ) { if ( i > j ) return 0 ; if ( dp [ i ] [ j ] != - 1 ) return dp [ i ] [ j ] ; if ( i == j ) return dp [ i ] [ j ] = 1 ; else if ( str [ i ] == str [ j ] ) return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ; else return dp [ i ] [ j ] = countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ; } n = str . length ; document . write ( " " + " " + countPS ( 0 , n - 1 ) ) ;
function minimum ( a , b , c ) { return Math . min ( Math . min ( a , b ) , c ) ; } function findMinSum ( arr , n ) { var sum = Array ( n ) . fill ( 0 ) ; sum [ 0 ] = arr [ 0 ] ; sum [ 1 ] = arr [ 1 ] ; sum [ 2 ] = arr [ 2 ] ; for ( var i = 3 ; i < n ; i ++ ) sum [ i ] = arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ; return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) ; } var arr = [ 1 , 2 , 3 , 20 , 2 , 10 , 1 ] ; var n = arr . length ; document . write ( " " + findMinSum ( arr , n ) ) ;
let INF = 1000000 ; function MinimumCost ( cost , n , W ) { let val = [ ] , wt = [ ] ; let size = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( cost [ i ] != - 1 ) { val . push ( cost [ i ] ) ; wt . push ( i + 1 ) ; size ++ ; } } n = size ; let min_cost = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { min_cost [ i ] = new Array ( W + 1 ) ; } for ( let i = 0 ; i <= W ; i ++ ) min_cost [ 0 ] [ i ] = INF ; for ( let i = 1 ; i <= n ; i ++ ) min_cost [ i ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= W ; j ++ ) { if ( wt [ i - 1 ] > j ) min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] ; else min_cost [ i ] [ j ] = Math . min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) ; } } return ( min_cost [ n ] [ W ] == INF ) ? - 1 : min_cost [ n ] [ W ] ; } let cost = [ 1 , 2 , 3 , 4 , 5 ] , W = 5 ; let n = cost . length ; document . write ( MinimumCost ( cost , n , W ) ) ;
function count ( a , b , m , n ) { if ( ( m == 0 && n == 0 ) n == 0 ) return 1 ; if ( m == 0 ) return 0 ; if ( a [ m - 1 ] == b [ n - 1 ] ) return count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ; else return count ( a , b , m - 1 , n ) ; } var a = " " ; var b = " " ; document . write ( count ( a , b , a . length , b . length ) ) ;
function lcs ( X , Y , m , n ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; } for ( let i = 0 ; i < m + 1 ; i ++ ) { for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } function findMinCost ( X , Y , costX , costY ) { let m = X . length ; let n = Y . length ; let len_LCS ; len_LCS = lcs ( X , Y , m , n ) ; return costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ; } let X = " " ; let Y = " " ; document . write ( " " + " " + findMinCost ( X , Y , 10 , 20 ) ) ;
function countIntegralSolutions ( n ) { let result = 0 ; for ( let i = 0 ; i <= n ; i ++ ) for ( let j = 0 ; j <= n - i ; j ++ ) for ( let k = 0 ; k <= ( n - i - j ) ; k ++ ) if ( i + j + k == n ) result ++ ; return result ; } let n = 3 ; document . write ( countIntegralSolutions ( n ) ) ;
function countIntegralSolutions ( n ) { return Math . floor ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) ; } let n = 3 ; document . write ( countIntegralSolutions ( n ) ) ;
function countWays ( p , q , r , last ) { if ( p < 0 q < 0 r < 0 ) return 0 ; if ( p == 1 && q == 0 && r == 0 && last == 0 ) return 1 ; if ( p == 0 && q == 1 && r == 0 && last == 1 ) return 1 ; if ( p == 0 && q == 0 && r == 1 && last == 2 ) return 1 ; if ( last == 0 ) return countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ; if ( last == 1 ) return countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ; if ( last == 2 ) return countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ; return 0 ; } function countUtil ( p , q , r ) { } let p = 1 , q = 1 , r = 1 ; document . write ( countUtil ( p , q , r ) ) ;
function countP ( n , k ) { if ( n == 0 k == 0 k > n ) return 0 ; if ( k == 1 k == n ) return 1 ; return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) ; } document . write ( countP ( 3 , 2 ) ) ;
function countP ( n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = 0 ; for ( let i = 0 ; i <= k ; i ++ ) dp [ 0 ] [ k ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) if ( j == 1 i == j ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ; return dp [ n ] [ k ] ; } document . write ( countP ( 5 , 2 ) )
function printCountRec ( dist ) { if ( dist < 0 ) return 0 ; if ( dist == 0 ) return 1 ; return printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ; } var dist = 4 ; document . write ( printCountRec ( dist ) ) ;
function countNumbersWith4 ( n ) { let result = 0 ; for ( let x = 1 ; x <= n ; x ++ ) result += has4 ( x ) ? 1 : 0 ; return result ; } function has4 ( x ) { while ( x != 0 ) { if ( x % 10 == 4 ) return true ; x = Math . floor ( x / 10 ) ; } return false ; } let n = 328 ; document . write ( " " + n + " " + countNumbersWith4 ( n ) ) ;
function countNumbersWith4 ( n ) { if ( n < 4 ) return 0 ; let d = Math . floor ( Math . log10 ( n ) ) ; let a = new Array ( d + 2 ) ; for ( let i = 0 ; i < d + 2 ; i ++ ) { a [ i ] = 0 ; } a [ 0 ] = 0 ; a [ 1 ] = 1 ; for ( let i = 2 ; i <= d ; i ++ ) a [ i ] = a [ i - 1 ] * 9 + Math . floor ( Math . ceil ( Math . pow ( 10 , i - 1 ) ) ) ; let p = Math . floor ( Math . ceil ( Math . pow ( 10 , d ) ) ) ; let msd = Math . floor ( n / p ) ; if ( msd == 4 ) return ( msd ) * a [ d ] + ( n % p ) + 1 ; if ( msd > 4 ) return ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ; return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) ; } let n = 328 ; document . write ( " " + n + " " + countNumbersWith4 ( n ) ) ;
function minRemovalsDP ( arr , n ) { let longest_start = - 1 , longest_end = 0 ; for ( let start = 0 ; start < n ; start ++ ) { let min = Number . MAX_VALUE , max = Number . MIN_VALUE ; for ( let end = start ; end < n ; end ++ ) { let val = arr [ end ] ; if ( val < min ) { min = val ; } if ( val > max ) { max = val ; } if ( 2 * min <= max ) { break ; } if ( end - start > longest_end - longest_start longest_start == - 1 ) { longest_start = start ; longest_end = end ; } } } if ( longest_start == - 1 ) { return n ; } return ( n - ( longest_end - longest_start + 1 ) ) ; } let arr = [ 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 ] ; let n = arr . length ; document . write ( minRemovalsDP ( arr , n ) ) ;
function optimalStrategyOfGame ( arr , n ) { let table = new Array ( n ) ; let gap , i , j , x , y , z ; for ( let d = 0 ; d < n ; d ++ ) { table [ d ] = new Array ( n ) ; } for ( gap = 0 ; gap < n ; ++ gap ) { for ( i = 0 , j = gap ; j < n ; ++ i , ++ j ) { x = ( ( i + 2 ) <= j ) ? table [ i + 2 ] [ j ] : 0 ; y = ( ( i + 1 ) <= ( j - 1 ) ) ? table [ i + 1 ] [ j - 1 ] : 0 ; z = ( i <= ( j - 2 ) ) ? table [ i ] [ j - 2 ] : 0 ; table [ i ] [ j ] = Math . max ( arr [ i ] + Math . min ( x , y ) , arr [ j ] + Math . min ( y , z ) ) ; } } return table [ 0 ] [ n - 1 ] ; } let arr1 = [ 8 , 15 , 3 , 7 ] ; let n = arr1 . length ; document . write ( " " + optimalStrategyOfGame ( arr1 , n ) + " " ) ; let arr2 = [ 2 , 2 , 2 , 2 ] ; n = arr2 . length ; document . write ( " " + optimalStrategyOfGame ( arr2 , n ) + " " ) ; let arr3 = [ 20 , 30 , 2 , 2 , 2 , 10 ] ; n = arr3 . length ; document . write ( " " + optimalStrategyOfGame ( arr3 , n ) ) ;
function maxSumIS ( arr , n ) { let i , j , max = 0 ; let msis = new Array ( n ) ; for ( i = 0 ; i < n ; i ++ ) msis [ i ] = arr [ i ] ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && msis [ i ] < msis [ j ] + arr [ i ] ) msis [ i ] = msis [ j ] + arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( max < msis [ i ] ) max = msis [ i ] ; return max ; } let arr = [ 1 , 101 , 2 , 3 , 100 , 4 , 5 ] ; let n = arr . length ; document . write ( " " + " " + maxSumIS ( arr , n ) ) ;
function endsWith ( str , pat ) { let patLen = pat . length ; let strLen = str . length ; if ( patLen > strLen ) return false ; patLen -- ; strLen -- ; while ( patLen >= 0 ) { if ( pat [ patLen ] != str [ strLen ] ) return false ; patLen -- ; strLen -- ; } return true ; } function countOfStrings ( pat , n , sArr ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( endsWith ( sArr [ i ] , pat ) ) count ++ ; } return count ; } let pat = " " ; let n = 4 ; let sArr = [ " " , " " , " " , " " ] ; document . write ( countOfStrings ( pat , n , sArr ) ) ;
function getEndingIndex ( str , n , i ) { i ++ ; while ( i < n ) { let curr = str [ i ] ; let prev = str [ i - 1 ] ; if ( ( curr == ' ' && prev == ' ' ) || ( curr . charCodeAt ( 0 ) - prev . charCodeAt ( 0 ) == 1 ) ) i ++ ; else break ; } return i - 1 ; } function largestSubStr ( str , n ) { let len = 0 ; let i = 0 ; while ( i < n ) { let end = getEndingIndex ( str , n , i ) ; len = Math . max ( end - i + 1 , len ) ; i = end + 1 ; } return len ; } let str = " " ; let n = str . length ; document . write ( largestSubStr ( str , n ) ) ;
function getSum ( n , d ) { if ( n < d ) return 0 ; while ( n % 10 != d ) n -- ; k = parseInt ( n / 10 ) ; return ( k + 1 ) * d + ( k * 10 + 10 * k * k ) / 2 ; } let n = 30 ; let d = 3 ; document . write ( getSum ( n , d ) ) ;
function isSubstring ( s1 , s2 ) { var M = s1 . length ; var N = s2 . length ; for ( var i = 0 ; i <= N - M ; i ++ ) { var j ; for ( j = 0 ; j < M ; j ++ ) if ( s2 [ i + j ] != s1 [ j ] ) break ; if ( j == M ) return i ; } return - 1 ; } var s1 = " " ; var s2 = " " ; var res = isSubstring ( s1 , s2 ) ; if ( res == - 1 ) document . write ( " " ) ; else document . write ( " " + res ) ;
function patternCount ( str ) { var last = str . charAt ( 0 ) ; var i = 1 , counter = 0 ; while ( i < str . length ) { if ( str . charAt ( i ) == ' ' && last == ' ' ) { while ( str . charAt ( i ) == ' ' ) i ++ ; if ( str . charAt ( i ) == ' ' ) counter ++ ; } last = str . charAt ( i ) ; i ++ ; } return counter ; } var str = " " ; document . write ( patternCount ( str ) ) ;
function maxPrefix ( s , t ) { let count = 0 ; for ( let i = 0 ; i < t . length ; i ++ ) { if ( count == s . length ) break ; if ( t [ i ] == s [ count ] ) count ++ ; } return count ; } let S = " " ; let T = " " ; document . write ( maxPrefix ( S , T ) ) ;
function translate ( str ) { for ( let i = 1 ; i < str . length ; i ++ ) { if ( str [ i - 1 ] == ' ' && str [ i ] == ' ' ) { str [ i - 1 ] = ' ' ; let j ; for ( j = i ; j < str . length - 1 ; j ++ ) str [ j ] = str [ j + 1 ] ; str [ j ] = ' ' ; } } return ; } let st = " " ; let str = st . split ( " " ) ; translate ( str ) ; document . write ( " " ) ; document . write ( str . join ( " " ) ) ;
const NUM = 31 ; function positions ( str , n ) { for ( i = 0 ; i < n ; i ++ ) { document . write ( ( str [ i ] . charCodeAt ( 0 ) & NUM ) + " " ) ; } } var str = " " ; var n = str . length ; positions ( str , n ) ;
function lenoflongestnonpalindrome ( s ) { let max1 = 1 , len = 0 ; for ( let i = 0 ; i < s . length - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) len = 0 ; else if ( s [ i + 1 ] == s [ i - 1 ] && i > 0 ) len = 1 ; len ++ ; } if ( max1 == 1 ) return 0 ; else return max1 ; } let s = " " ; document . write ( lenoflongestnonpalindrome ( s ) + " " ) ;
function makePalindrome ( str ) { var i = 0 , j = str . length - 1 ; while ( i <= j ) { if ( str [ i ] == ' ' && str [ j ] == ' ' ) { str [ i ] = ' ' ; str [ j ] = ' ' ; } else if ( str [ j ] == ' ' ) str [ j ] = str [ i ] ; else if ( str [ i ] == ' ' ) str [ i ] = str [ j ] ; else if ( str [ i ] != str [ j ] ) return " " ; i ++ ; j -- ; } return str . join ( " " ) ; } var str = " " . split ( ' ' ) ; document . write ( makePalindrome ( str ) ) ;
function calcScore ( str ) { var score = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; ) { var chunkSize = 1 ; var currentChar = str [ i ++ ] ; while ( i < len && str [ i ] == currentChar ) { chunkSize ++ ; i ++ ; } if ( currentChar == ' ' ) score += Math . pow ( chunkSize , 2 ) ; else score -= Math . pow ( chunkSize , 2 ) ; } return score ; } var str = " " ; document . write ( calcScore ( str ) ) ;
function countSubString ( s , c , k ) { var leftCount = 0 , rightCount = 0 ; var left = 0 , right = 0 ; var freq = 0 ; var result = 0 , len = s . length ; while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } right = left + 1 ; while ( freq != ( k - 1 ) && ( right - 1 ) < len ) { if ( s [ right ] == c ) freq ++ ; right ++ ; } while ( left < len && ( right - 1 ) < len ) { while ( s [ left ] != c && left < len ) { left ++ ; leftCount ++ ; } while ( right < len && s [ right ] != c ) { if ( s [ right ] == c ) freq ++ ; right ++ ; rightCount ++ ; } result = result + ( leftCount + 1 ) * ( rightCount + 1 ) ; freq = k - 1 ; leftCount = 0 ; rightCount = 0 ; left ++ ; right ++ ; } return result ; } var s = " " ; var c = ' ' ; var k = 2 ; document . write ( countSubString ( s , c , k ) + " " ) ;
function isValid ( str , n ) { if ( ! ( ( str [ 0 ] >= ' ' && str [ 0 ] <= ' ' ) || ( str [ 0 ] >= ' ' && str [ 0 ] <= ' ' ) str [ 0 ] == ' ' ) ) return false ; for ( let i = 1 ; i < str . length ; i ++ ) { if ( ! ( ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) || ( str [ i ] >= ' ' && str [ i ] <= ' ' ) str [ i ] == ' ' ) ) return false ; } return true ; } let str = " " ; let n = str . length ; if ( isValid ( str , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function FirstAndLast ( str ) { var ch = str . split ( ' ' ) ; for ( var i = 0 ; i < ch . length ; i ++ ) { var k = i ; while ( i < ch . length && ch [ i ] != ' ' ) i ++ ; ch [ k ] = String . fromCharCode ( ch [ k ] >= ' ' && ch [ k ] <= ' ' ? ( ch [ k ] . charCodeAt ( 0 ) - 32 ) : ch [ k ] . charCodeAt ( 0 ) ) ; ch [ i - 1 ] = String . fromCharCode ( ch [ i - 1 ] >= ' ' && ch [ i - 1 ] <= ' ' ? ( ch [ i - 1 ] . charCodeAt ( 0 ) - 32 ) : ch [ i - 1 ] . charCodeAt ( 0 ) ) ; } return ch . join ( ' ' ) ; } var str = " " ; document . write ( str + " " ) ; document . write ( FirstAndLast ( str ) ) ;
function findM ( s , x ) { var cnt = 0 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( s . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) != x ) cnt ++ ; } return cnt ; } var s = " " ; var x = 6 ; document . write ( findM ( s , x ) ) ;
function compute_lps ( s ) { var n = s . length ; var lps = Array ( n ) ; var len = 0 ; lps [ 0 ] = 0 ; var i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) len = lps [ len - 1 ] ; else { lps [ i ] = 0 ; i ++ ; } } } return lps ; } function Longestsubstring ( s ) { var lps = compute_lps ( s ) ; var n = s . length ; if ( lps [ n - 1 ] == 0 ) { document . write ( - 1 ) ; return ; } for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( lps [ i ] == lps [ n - 1 ] ) { document . write ( s . substring ( 0 , lps [ i ] ) ) ; return ; } } if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) document . write ( - 1 ) ; else document . write ( s . substr ( 0 , lps [ lps [ n - 1 ] - 1 ] ) ) ; } var s = " " ; Longestsubstring ( s ) ;
const MAX = 64 ; function getBitmask ( s ) { var temp = 0 ; for ( var j = 0 ; j < s . length ; j ++ ) { switch ( s [ j ] ) { case " " : temp = temp | 1 ; break ; case " " : temp = temp | 2 ; break ; case " " : temp = temp | 4 ; break ; case " " : temp = temp | 8 ; break ; case " " : temp = temp | 16 ; break ; case " " : temp = temp | 32 ; break ; default : break ; } } return temp ; } function countPairs ( arr , n ) { var bitMask = new Array ( MAX ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) bitMask [ getBitmask ( arr [ i ] . split ( " " ) ) ] ++ ; var cnt = 0 ; for ( var i = 0 ; i < MAX ; i ++ ) { for ( var j = i ; j < MAX ; j ++ ) { if ( ( i j ) === MAX - 1 ) { if ( i === j ) cnt += parseInt ( ( bitMask [ i ] * bitMask [ i ] - 1 ) / 2 ) ; else cnt += bitMask [ i ] * bitMask [ j ] ; } } } return cnt ; } var arr = [ " " , " " , " " ] ; var n = arr . length ; document . write ( countPairs ( arr , n ) ) ;
function countOcc ( s ) { var cnt = 0 ; for ( var i = 0 ; i < s . length - 3 ; i ++ ) { var c = 0 , l = 0 , a = 0 , p = 0 ; for ( var j = i ; j < i + 4 ; j ++ ) { switch ( s [ j ] ) { case ' ' : c ++ ; break ; case ' ' : l ++ ; break ; case ' ' : a ++ ; break ; case ' ' : p ++ ; break ; } } if ( c == 1 && l == 1 && a == 1 && p == 1 ) cnt ++ ; } return cnt ; } var s = " " ; s = s . toLowerCase ( ) ; document . write ( countOcc ( s ) ) ;
function calculateWays ( s , n , l , r ) { var freq = Array ( 26 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i < l i > r ) freq [ s . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ++ ; } var ways = 1 ; for ( i = l ; i <= r ; i ++ ) { if ( freq [ s . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] != 0 ) { ways = ways * freq [ s . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ; freq [ s . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] -- ; } else { ways = 0 ; break ; } } return ways ; } var s = " " ; var n = s . length ; var l = 1 , r = 3 ; document . write ( calculateWays ( s , n , l , r ) ) ;
function asciiToSentence ( str , len ) { var num = 0 ; for ( var i = 0 ; i < len ; i ++ ) { num = num * 10 + ( str [ i ] - ' ' ) ; if ( num >= 32 && num <= 122 ) { var ch = String . fromCharCode ( num ) ; document . write ( ch ) ; num = 0 ; } } } var str = " " ; var len = str . length ; asciiToSentence ( str , len ) ;
var arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ] function countKeyPressed ( str , len ) { var count = 0 ; for ( var i = 0 ; i < len ; i ++ ) count = count + arr [ str . charCodeAt ( i ) - 97 ] ; return count ; } var str = " " ; var len = str . length ; document . write ( countKeyPressed ( str , len ) ) ;
function isReverseEqual ( s1 , s2 ) { if ( s1 . length != s2 . length ) return false ; let len = s1 . length ; for ( let i = 0 ; i < len ; i ++ ) if ( s1 [ i ] != s2 [ len - i - 1 ] ) return false ; return true ; } function getWord ( str , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( isReverseEqual ( str [ i ] , str [ j ] ) ) return str [ i ] ; return " " ; } let str = [ " " , " " , " " ] ; document . write ( getWord ( str , 3 ) ) ;
function isPrefix ( str , len , i , k ) { if ( i + k > len ) return false ; for ( let j = 0 ; j < k ; j ++ ) { if ( str [ i ] != str [ j ] ) return false ; i ++ ; } return true ; } function isKPeriodic ( str , len , k ) { for ( let i = k ; i < len ; i += k ) if ( ! isPrefix ( str , len , i , k ) ) return false ; return true ; } let str = " " ; let len = str . length ; let k = 5 ; if ( isKPeriodic ( str , len , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
function minLettersNeeded ( n ) { if ( n % 26 == 0 ) return parseInt ( n / 26 ) ; else return ( parseInt ( n / 26 ) + 1 ) ; } var n = 52 ; document . write ( minLettersNeeded ( n ) ) ;
function minReplacement ( s , len ) { var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( i % 2 == 0 && s [ i ] == ' ' ) ans ++ ; if ( i % 2 == 1 && s [ i ] == ' ' ) ans ++ ; } return Math . min ( ans , len - ans ) ; } var s = " " ; var len = s . length ; document . write ( minReplacement ( s , len ) ) ;
function groupCharacters ( s , len ) { let temp = " " ; for ( let i = 0 ; i < len ; i ++ ) if ( s [ i ] != ' ' ) temp = temp + s [ i ] ; len = temp . length ; let ans = " " ; let i = 0 ; while ( i < len ) { if ( temp [ i ] >= ( ' ' ) && temp [ i ] <= ( ' ' ) ) { while ( i < len && temp [ i ] >= ( ' ' ) && temp [ i ] <= ( ' ' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " " ; } else if ( temp [ i ] >= ( ' ' ) && temp [ i ] <= ( ' ' ) ) { while ( i < len && temp [ i ] >= ( ' ' ) && temp [ i ] <= ( ' ' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " " ; } else { while ( i < len && temp [ i ] >= ( ' ' ) && temp [ i ] <= ( ' ' ) ) { ans = ans + temp [ i ] ; i ++ ; } ans = ans + " " ; } } return ans ; } let s = " " ; let len = s . length ; document . write ( groupCharacters ( s . split ( " " ) , len ) ) ;
function Preprocess ( A , B ) { let n = A . length ; let ans = 0 ; for ( let i = 0 ; i < n / 2 ; i ++ ) { let mp = new Map ( ) ; if ( mp . has ( A [ i ] ) ) mp . set ( A [ i ] , mp . get ( A [ i ] ) + 1 ) ; else mp . set ( A [ i ] , 1 ) ; if ( mp . has ( A [ n - i - 1 ] ) ) mp . set ( A [ n - i - 1 ] , mp . get ( A [ n - i - 1 ] ) + 1 ) ; else mp . set ( A [ n - i - 1 ] , 1 ) ; if ( mp . has ( B [ i ] ) ) mp . set ( B [ i ] , mp . get ( B [ i ] ) + 1 ) ; else mp . set ( B [ i ] , 1 ) ; if ( mp . has ( B [ n - i - 1 ] ) ) mp . set ( B [ n - i - 1 ] , mp . get ( B [ n - i - 1 ] ) + 1 ) ; else mp . set ( B [ n - i - 1 ] , 1 ) ; let sz = mp . size ; if ( sz == 4 ) ans += 2 ; else if ( sz == 3 ) ans += 1 + ( A [ i ] == A [ n - i - 1 ] ? 1 : 0 ) ; else if ( sz == 2 ) ans += mp . get ( A [ i ] ) != 2 ? 1 : 0 ; } if ( n % 2 == 1 && A [ Math . floor ( n / 2 ) ] != B [ Math . floor ( n / 2 ) ] ) ans ++ ; return ans ; } let A = " " , B = " " ; document . write ( Preprocess ( A , B ) ) ;
function generateString ( A , B ) { let rt = " " ; while ( 0 < A 0 < B ) { if ( A < B ) { if ( 0 < B -- ) { rt += ( ' ' ) ; } if ( 0 < B -- ) { rt += ( ' ' ) ; } if ( 0 < A -- ) { rt += ( ' ' ) ; } } else if ( B < A ) { if ( 0 < A -- ) { rt += ( ' ' ) ; } if ( 0 < A -- ) { rt += ( ' ' ) ; } if ( 0 < B -- ) { rt += ( ' ' ) ; } } else { if ( 0 < A -- ) { rt += ( ' ' ) ; } if ( 0 < B -- ) { rt += ( ' ' ) ; } } } document . write ( rt ) ; } let A = 2 , B = 6 ; generateString ( A , B ) ;
function getSubSeq ( s , n ) { var res = " " ; var cr = 0 ; while ( cr < n ) { var mx = s [ cr ] . charCodeAt ( 0 ) ; for ( var i = cr + 1 ; i < n ; i ++ ) mx = Math . max ( mx , s [ i ] . charCodeAt ( 0 ) ) ; var lst = cr ; for ( var i = cr ; i < n ; i ++ ) if ( s [ i ] . charCodeAt ( 0 ) == mx ) { res += s [ i ] ; lst = i ; } cr = lst + 1 ; } return res ; } var s = " " ; var n = s . length ; document . write ( getSubSeq ( s , n ) ) ;
function countSubStr ( str , len , k ) { let count = 0 ; for ( let i = 0 ; i < len ; i ++ ) { let n = 0 ; for ( let j = i ; j < len ; j ++ ) { n = n * 10 + ( str [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( n % k == 0 ) count ++ ; } } return count ; } let str = " " ; let len = str . length ; let k = 11 ; document . write ( countSubStr ( str , len , k ) ) ;
function Colour_Combination ( s ) { let temp = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( temp != s [ i ] ) { if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else if ( ( temp == ' ' temp == ' ' ) && ( s [ i ] == ' ' s [ i ] == ' ' ) ) temp = ' ' ; else temp = ' ' ; } } return temp ; } let s = " " ; document . write ( Colour_Combination ( s ) ) ;
function reverse ( str , x ) { var n = ( str . length - x ) / 2 ; for ( i = 0 ; i < n ; i ++ ) document . write ( str . charAt ( i ) ) ; for ( i = n + x - 1 ; i >= n ; i -- ) document . write ( str . charAt ( i ) ) ; for ( i = n + x ; i < str . length ; i ++ ) document . write ( str . charAt ( i ) ) ; } var str = " " ; var x = 3 ; reverse ( str , x ) ;
function removeChars ( s ) { let modifiedStr = " " ; modifiedStr += s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] == ( s [ i ] ) . toUpperCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toLowerCase ( ) || s [ i ] == s [ i ] . toLowerCase ( ) && ( s [ i - 1 ] ) == ( s [ i - 1 ] ) . toUpperCase ( ) ) modifiedStr += s [ i ] ; } return modifiedStr ; } let s = " " ; document . write ( removeChars ( s ) ) ;
function pangramCost ( arr , str ) { var cost = 0 ; var occurred = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) occurred [ i ] = false ; for ( let i = 0 ; i < str . length ; i ++ ) occurred [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] = true ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( occurred [ i ] == false ) cost += arr [ i ] ; } return cost ; } var arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 ] ; var str = " " ; document . write ( pangramCost ( arr , str ) ) ;
let output = " " ; function pairStar ( input , i ) { output = output + input [ i ] ; if ( i == input . length - 1 ) return ; if ( input [ i ] == input [ i + 1 ] ) output = output + ' ' ; pairStar ( input , i + 1 ) ; } let input = " " ; pairStar ( input , 0 ) ; document . write ( output ) ;
function maxOperations ( str ) { let i , g , gk , gks ; i = g = gk = gks = 0 ; for ( i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ' ' ) { g ++ ; } else if ( str [ i ] == ' ' ) { if ( g > 0 ) { g -- ; gk ++ ; } } else if ( str [ i ] == ' ' ) { if ( gk > 0 ) { gk -- ; gks ++ ; } } } return gks ; } let a = " " ; document . write ( maxOperations ( a ) ) ;
function printFinalString ( s ) { var i , n ; n = s . length ; var x = 0 , y = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) x ++ ; else y ++ ; } var finalString = " " ; if ( x > y ) for ( i = 0 ; i < x - y ; i ++ ) finalString += " " ; else for ( i = 0 ; i < y - x ; i ++ ) finalString += " " ; return finalString ; } var s = " " ; document . write ( printFinalString ( s ) ) ;
function K_String ( s , k ) { let n = s . length ; let fre = new Array ( 26 ) ; for ( let i = 0 ; i < fre . length ; i ++ ) { fre [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) fre [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; let str = " " ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( fre [ i ] % k == 0 ) { let x = Math . floor ( fre [ i ] / k ) ; while ( x != 0 ) { str += String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; x -- ; } } else { return " " ; } } return str ; } let s = " " ; let k = 2 ; document . write ( K_String ( s , k ) ) ;
function CountCharacters ( str , l , r ) { let cnt = 0 ; let m = new Map ( ) ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( ! ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) ) { cnt ++ ; if ( ! m . has ( str [ i ] ) ) { m . set ( str [ i ] , 0 ) ; document . write ( str [ i ] + " " ) ; } m . set ( str [ i ] , m . get ( str [ i ] + 1 ) ) ; } } return cnt ; } let str = " " ; let l = 102 , r = 111 ; document . write ( " " + " " ) ; document . write ( " " + CountCharacters ( str , l , r ) ) ;
function CountWords ( str , k ) { let sum = 0 ; let NumberOfWords = 0 ; let counter = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; ++ i ) { if ( str [ i ] == " " ) { if ( sum < k ) { counter ++ ; } sum = 0 ; NumberOfWords ++ ; } else { sum += str . charCodeAt ( i ) ; } } NumberOfWords ++ ; if ( sum < k ) { counter ++ ; } document . write ( " " + " " + counter + " " ) ; document . write ( " " + " " + ( NumberOfWords - counter ) + " " ) ; } let str = " " ; let k = 400 ; CountWords ( str , k ) ;
var MAX_CHAR = 26 ; function countPalindrome ( str ) { var n = str . length ; var sum = 0 ; var hashTable = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) hashTable [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) { if ( hashTable [ i ] ) sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) / 2 ) ; } return sum ; } var str = " " ; document . write ( countPalindrome ( str ) ) ;
function countConsecutive ( s ) { let count = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) i ++ ; else count ++ ; } return count ; } let str = " " ; document . write ( countConsecutive ( str ) ) ;
function check_digits ( n ) { while ( n > 1 ) { if ( ( n % 10 ) % 2 == 0 ) return 0 ; n = parseInt ( n / 10 ) ; } return 1 ; } function smallest_number ( n ) { for ( i = n ; ; i ++ ) if ( check_digits ( i ) ) return i ; } let N = 2397 ; document . write ( smallest_number ( N ) ) ;
function CountCharacters ( str , l , r ) { let cnt = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( l <= str [ i ] . charCodeAt ( 0 ) && str [ i ] . charCodeAt ( 0 ) <= r ) { cnt ++ ; document . write ( str [ i ] + " " ) ; } } return cnt ; } let str = " " ; let l = 102 , r = 111 ; document . write ( " " + " " ) ; document . write ( " " + CountCharacters ( str , l , r ) ) ;
function minSteps ( str ) { let count = 0 ; for ( let i = 0 ; i < str . length - 2 ; i ++ ) { if ( ( str [ i ] ) == ' ' ) { if ( str [ i + 1 ] == ' ' ) { if ( str [ i + 2 ] == ' ' ) { count ++ ; i += 2 ; } } } } return count ; } let str = " " ; document . write ( minSteps ( str ) ) ;
function CountCharacters ( str , k ) { let cnt = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] . charCodeAt ( 0 ) < k ) cnt ++ ; } return cnt ; } let str = " " ; let k = 90 ; let count = CountCharacters ( str , k ) ; document . write ( " " + count + " " ) ; document . write ( " " + ( str . length - count ) ) ;
function fact ( n ) { let f = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { f = f * i ; } return f ; } function npr ( n , r ) { return fact ( n ) / fact ( n - r ) ; } function countPermutations ( str ) { let even = Math . floor ( str . length / 2 ) ; let odd = str . length - even ; let ways = 0 ; let freq = new Array ( 26 ) . fill ( 0 ) ; for ( let i = 0 ; i < str . length ; i ++ ) { ++ freq [ str . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ; } let nvowels = freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ; let nconsonants = str . length - nvowels ; ways = npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ; return ways ; } let str = " " ; document . write ( countPermutations ( str ) ) ;
function isVowel ( ch ) { if ( ch != ' ' && ch != ' ' && ch != ' ' && ch != ' ' && ch != ' ' ) return false ; return true ; } function replaceConsonants ( s ) { for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! isVowel ( s [ i ] ) ) { if ( s [ i ] == ' ' ) s [ i ] = ' ' ; else { s [ i ] = String . fromCharCode ( s [ i ] . charCodeAt ( 0 ) + 1 ) ; if ( isVowel ( s [ i ] ) ) s [ i ] = String . fromCharCode ( s [ i ] . charCodeAt ( 0 ) + 1 ) ; } } } return s . join ( ' ' ) ; } var s = " " . split ( ' ' ) ; document . write ( replaceConsonants ( s ) ) ;
function countOnOff ( n ) { var Led = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 ] ; var len = n . length ; var sum = Led [ n . charAt ( 0 ) - ' ' ] ; for ( i = 1 ; i < len ; i ++ ) { sum = sum + Math . abs ( Led [ n . charAt ( i ) - ' ' ] - Led [ n . charAt ( i - 1 ) - ' ' ] ) ; } return sum ; } n = " " ; document . write ( countOnOff ( n ) ) ;
function count ( S , X ) { var count = 0 ; var N = S . length ; for ( var i = 0 ; i < N ; ++ i ) { if ( S [ i ] != ' ' ) { for ( var len = 1 ; ( i + len ) <= N ; ++ len ) { if ( parseInt ( S . substring ( i , i + len ) ) > X ) count ++ ; } } } return count ; } var S = " " ; var X = 97 ; document . write ( count ( S , X ) ) ;
function isBinary ( n ) { while ( n != 0 ) { var temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = parseInt ( n / 10 ) ; } return true ; } function formBinaryStr ( n , a ) { var flag = true ; var s = " " ; for ( i = 0 ; i < n ; i ++ ) { if ( isBinary ( a [ i ] ) ) s += " " + a [ i ] ; else { flag = false ; break ; } } if ( flag ) document . write ( s + " " ) ; else document . write ( " " ) ; } var a = [ 10 , 1 , 0 , 11 , 10 ] ; var N = a . length ; formBinaryStr ( N , a ) ;
function checkPalindrome ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] != s [ s . length - i - 1 ] ) return false ; } return true ; } function CheckOdd ( s ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { let x = " " ; for ( let j = i ; j < n ; j ++ ) { x += s [ j ] ; if ( x . length % 2 == 0 && checkPalindrome ( x ) == true ) return false ; } } return true ; } let s = " " ; if ( CheckOdd ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function fact ( n ) { let result = 1 ; for ( let i = 1 ; i <= n ; i ++ ) result *= i ; return result ; } function getResult ( str , ch ) { let has = new Array ( 26 ) . fill ( null ) ; for ( let i = 0 ; i < str . length ; i ++ ) has [ str . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ++ ; particular = has [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ; if ( particular == 0 ) return 0 ; has [ ch . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = 0 ; let total = str . length ; total = total - particular + 1 ; let result = fact ( total ) ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( has [ i ] > 1 ) { result = result / fact ( has [ i ] ) ; } } return result ; } let str = " " ; document . write ( getResult ( str , ' ' ) + " " ) ;
function factorial ( n ) { let res = 1 ; for ( let i = 1 ; i <= n ; i ++ ) res = res * i ; return res ; } function count1 ( word ) { let freq = new Array ( 27 ) . fill ( 0 ) ; for ( let i = 0 ; i < 27 ; i ++ ) freq [ i ] = 0 ; let vowel = 0 ; let consonant = 0 ; for ( let i = 0 ; i < word . length ; i ++ ) { freq [ word . charCodeAt ( i ) - 65 ] ++ ; if ( word [ i ] == ' ' word [ i ] == ' ' word [ i ] == ' ' word [ i ] == ' ' word [ i ] == ' ' ) { vowel ++ ; } else consonant ++ ; } vowelArrange = factorial ( vowel ) ; vowelArrange /= factorial ( freq [ 0 ] ) ; vowelArrange /= factorial ( freq [ 4 ] ) ; vowelArrange /= factorial ( freq [ 8 ] ) ; vowelArrange /= factorial ( freq [ 14 ] ) ; vowelArrange /= factorial ( freq [ 20 ] ) ; consonantArrange = factorial ( consonant ) ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 ) consonantArrange /= factorial ( freq [ i ] ) ; } let total = vowelArrange * consonantArrange ; return total ; } let word = " " ; let ans = count1 ( word ) ; document . write ( ans ) ;
function productAscii ( str ) { var prod = 1 ; for ( i = 0 ; i < str . length ; i ++ ) { prod *= str . charAt ( i ) . charCodeAt ( 0 ) ; } return prod ; } str = " " ; document . write ( productAscii ( str ) ) ;
function balancedString ( str ) { var count = 0 , i ; var n = str . length ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { document . write ( str [ i ] ) ; count ++ ; } else if ( str [ i ] == ' ' && count != 0 ) { document . write ( str [ i ] ) ; count -- ; } else if ( str [ i ] != ' ' ) document . write ( str [ i ] ) ; } if ( count != 0 ) for ( i = 0 ; i < count ; i ++ ) document . write ( " " ) ; } var str = " " ; balancedString ( str ) ;
function countStrings ( s ) { let sum = 1 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( i % 2 == 0 && s [ i ] == ' ' ) sum *= 21 ; else if ( s [ i ] == ' ' ) sum *= 5 ; } return sum ; } let str = " " ; document . write ( countStrings ( str ) ) ;
function removeDuplicatesFromString ( string ) { let counter = 0 ; let str = string . split ( " " ) ; let i = 0 ; let size = str . length ; let x ; let length = 0 ; while ( i < size ) { x = str [ i ] . charCodeAt ( 0 ) - 97 ; if ( ( counter & ( 1 << x ) ) == 0 ) { str [ length ] = String . fromCharCode ( ' ' . charCodeAt ( 0 ) + x ) ; counter = counter | ( 1 << x ) ; length ++ ; } i ++ ; } return str . join ( " " ) . slice ( 0 , length ) ; } let str = " " ; document . write ( removeDuplicatesFromString ( str ) ) ;
function firstPos ( str , start , end ) { let firstChar = - 1 ; for ( let i = start ; i <= end ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) { firstChar = i ; break ; } } return firstChar ; } function lastPos ( str , start , end ) { let lastChar = - 1 ; for ( let i = start ; i >= end ; i -- ) { if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) { lastChar = i ; break ; } } return lastChar ; } function isPalindrome ( str ) { let firstChar = 0 , lastChar = str . length - 1 ; let ch = true ; for ( let i = 0 ; i < str . length ; i ++ ) { firstChar = firstPos ( str , firstChar , lastChar ) ; lastChar = lastPos ( str , lastChar , firstChar ) ; if ( lastChar < 0 firstChar < 0 ) break ; if ( str [ firstChar ] == str [ lastChar ] ) { firstChar ++ ; lastChar -- ; continue ; } ch = false ; break ; } return ch ; } let str = " " ; if ( isPalindrome ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function powerOfJump ( s ) { let count = 1 ; let max_so_far = Number . MIN_VALUE ; let ch = s [ s . length - 1 ] ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ch ) { if ( count > max_so_far ) { max_so_far = count ; } count = 1 ; } else count ++ ; } return max_so_far ; } let st = " " ; document . write ( powerOfJump ( st ) ) ;
function averageValue ( s ) { let sum_char = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { sum_char += ( s [ i ] ) . charCodeAt ( 0 ) ; } return Math . floor ( sum_char / s . length ) ; } let s = " " ; document . write ( averageValue ( s ) ) ;
function commonPrefixUtil ( str1 , str2 ) { let result = " " ; let n1 = str1 . length , n2 = str2 . length ; for ( let i = 0 , j = 0 ; i <= n1 - 1 && j <= n2 - 1 ; i ++ , j ++ ) { if ( str1 [ i ] != str2 [ j ] ) { break ; } result += str1 [ i ] ; } return ( result ) ; } function commonPrefix ( arr , n ) { arr . sort ( ) ; document . write ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) + " " ) ; } let arr = [ " " , " " , " " , " " ] ; let n = arr . length ; commonPrefix ( arr , n ) ;
function addBinaryUtil ( a , b ) { var result = " " ; var s = 0 ; var i = a . length - 1 , j = b . length - 1 ; while ( i >= 0 j >= 0 s == 1 ) { s += ( ( i >= 0 ) ? a . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) : 0 ) ; s += ( ( j >= 0 ) ? b . charCodeAt ( j ) - ' ' . charCodeAt ( 0 ) : 0 ) ; result = String . fromCharCode ( ( s % 2 == 1 ? 1 : 0 ) + ' ' . charCodeAt ( 0 ) ) + result ; s = parseInt ( s / 2 ) ; i -- ; j -- ; } return result ; } function addBinary ( arr , n ) { var result = " " ; for ( var i = 0 ; i < n ; i ++ ) result = addBinaryUtil ( result , arr [ i ] ) ; return result ; } var arr = [ " " , " " , " " ] ; var n = arr . length ; document . write ( addBinary ( arr , n ) ) ;
function prefix ( k , n ) { let a = 0 , b = 0 , count = 0 ; let i = 0 ; let len = k . length ; for ( i = 0 ; i < len ; i ++ ) { if ( k [ i ] == ' ' ) a ++ ; if ( k [ i ] == ' ' ) b ++ ; if ( a > b ) { count ++ ; } } if ( count == 0 n == 1 ) { document . write ( count + " " ) ; return 0 ; } if ( count == len a - b == 0 ) { document . write ( ( count * n ) + " " ) ; return 0 ; } let n2 = n - 1 , count2 = 0 ; while ( n2 != 0 ) { for ( i = 0 ; i < len ; i ++ ) { if ( k [ i ] == ' ' ) a ++ ; if ( k [ i ] == ' ' ) b ++ ; if ( a > b ) { count2 ++ ; } } count += count2 ; n2 -- ; if ( count2 == 0 ) break ; if ( count2 == len ) { count += ( n2 * count2 ) ; break ; } count2 = 0 ; } return count ; } let S = " " ; let N = 2 ; document . write ( prefix ( S , N ) + " " ) ; S = " " ; N = 3 ; document . write ( prefix ( S , N ) + " " ) ;
function isCommonBase ( base , s1 , s2 ) { for ( let j = 0 ; j < s1 . length ; ++ j ) { if ( base [ j % base . length ] != s1 [ j ] ) { return false ; } } for ( let j = 0 ; j < s2 . length ; ++ j ) { if ( base [ j % base . length ] != s2 [ j ] ) { return false ; } } return true ; } function countCommonBases ( s1 , s2 ) { let n1 = s1 . length , n2 = s2 . length ; let count = 0 ; for ( let i = 1 ; i <= Math . min ( n1 , n2 ) ; i ++ ) { let base = s1 . substring ( 0 , i ) ; if ( isCommonBase ( base , s1 , s2 ) ) { count ++ ; } } return count ; } let s1 = " " ; let s2 = " " ; document . write ( countCommonBases ( s1 , s2 ) ) ;
function isPerfectSquareString ( str ) { var sum = 0 ; var len = str . length ; for ( var i = 0 ; i < len ; i ++ ) sum += str . charCodeAt ( i ) ; var squareRoot = Math . sqrt ( sum ) ; return squareRoot - Math . floor ( squareRoot ) == 0 ; } var str = " " ; if ( isPerfectSquareString ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function transformString ( ) { var ch = ' ' ; if ( s . length < 26 ) return false ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ch . charCodeAt ( 0 ) > 122 ) break ; if ( s [ i ] . charCodeAt ( 0 ) <= ch . charCodeAt ( 0 ) ) { s [ i ] = ch ; ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; } } s = s . join ( ' ' ) if ( ch . charCodeAt ( 0 ) <= ' ' . charCodeAt ( 0 ) ) return false ; return true ; } var s = " " . split ( ' ' ) ; if ( transformString ( s ) ) document . write ( s ) ; else document . write ( " " ) ;
function isPanDigital ( s ) { let digits = new Array ( 10 ) . fill ( false ) ; for ( let i = 0 ; i < s . length ; i ++ ) digits [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = true ; for ( let i = 0 ; i <= 9 ; i ++ ) if ( digits [ i ] == false ) return false ; return true ; } function countPandigitalPairs ( v ) { let pairs = 0 ; for ( let i = 0 ; i < v . length ; i ++ ) { for ( let j = i + 1 ; j < v . length ; j ++ ) { if ( isPanDigital ( v [ i ] + v [ j ] ) ) { pairs ++ ; } } } return pairs ; } let v = [ " " , " " , " " , " " ] ; document . write ( countPandigitalPairs ( v ) ) ;
var MAX_CHAR = 26 ; function minChanges ( str ) { var n = str . length ; if ( n > MAX_CHAR ) return - 1 ; var dist_count = 0 ; var count = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) count [ i ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( count [ str . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] == 0 ) dist_count ++ ; count [ str . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } return ( n - dist_count ) ; } var str = " " ; document . write ( minChanges ( str ) ) ;
function numofstring ( n , m ) { if ( n == 1 ) return m ; if ( n == 2 ) return m * ( m - 1 ) ; return m * ( m - 1 ) * Math . pow ( m - 2 , n - 2 ) ; } let n = 2 , m = 3 ; document . write ( numofstring ( n , m ) ) ;
function CountSpecialPalindrome ( str ) { var n = str . length ; var result = 0 ; var sameChar = [ ... Array ( n ) ] ; var i = 0 ; while ( i < n ) { var sameCharCount = 1 ; var j = i + 1 ; while ( str [ i ] == str [ j ] && j < n ) sameCharCount ++ , j ++ ; result += ( sameCharCount * ( sameCharCount + 1 ) ) / 2 ; sameChar [ i ] = sameCharCount ; i = j ; } for ( var j = 1 ; j < n ; j ++ ) { if ( str [ j ] == str [ j - 1 ] ) sameChar [ j ] = sameChar [ j - 1 ] ; if ( j > 0 && j < n - 1 && str [ j - 1 ] == str [ j + 1 ] && str [ j ] != str [ j - 1 ] ) result += Math . min ( sameChar [ j - 1 ] , sameChar [ j + 1 ] ) ; } return result - n ; } var str = " " ; document . write ( CountSpecialPalindrome ( str ) + " " ) ;
function printBracketNumber ( exp , n ) { var left_bnum = 1 ; var right_bnum = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( exp [ i ] == ' ' ) { document . write ( left_bnum + " " ) ; right_bnum . push ( left_bnum ) ; left_bnum ++ ; } else if ( exp [ i ] == ' ' ) { document . write ( right_bnum [ right_bnum . length - 1 ] + " " ) ; right_bnum . pop ( ) ; } } } var exp = " " ; var n = exp . length ; printBracketNumber ( exp , n ) ;
function isCornerPresent ( str , corner ) { var n = str . length ; var cl = corner . length ; if ( n < cl ) return false ; return ( str . substring ( 0 , cl ) . localeCompare ( corner ) === 0 && str . substring ( n - cl , n ) . localeCompare ( corner ) === 0 ) ; } var str = " " ; var corner = " " ; if ( isCornerPresent ( str , corner ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isConvertible ( str1 , str2 , k ) { if ( ( str1 . length + str2 . length ) < k ) return true ; var commonLength = 0 ; for ( var i = 0 ; i < Math . min ( str1 . length , str2 . length ) ; i ++ ) { if ( str1 [ i ] == str2 [ i ] ) commonLength ++ ; else break ; } if ( ( k - str1 . length - str2 . length + 2 * commonLength ) % 2 == 0 ) return true ; return false ; } var str1 = " " , str2 = " " ; var k = 7 ; if ( isConvertible ( str1 , str2 , k ) ) document . write ( " " ) ; else document . write ( " " ) ; str1 = " " , str2 = " " ; k = 5 ; document . write ( " " ) ; if ( isConvertible ( str1 , str2 , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
let MAX_CHAR = 26 ; function maxLower ( str ) { let n = str . length ; let i = 0 ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) { i ++ ; break ; } } let maxCount = 0 ; let count = new Array ( MAX_CHAR ) ; for ( ; i < n ; i ++ ) { if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) { let currCount = 0 ; for ( let j = 0 ; j < MAX_CHAR ; j ++ ) { if ( count [ j ] > 0 ) { currCount ++ ; } } maxCount = Math . max ( maxCount , currCount ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } } if ( str [ i ] >= ' ' && str [ i ] <= ' ' ) { count [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } } return maxCount ; } let str = " " ; document . write ( maxLower ( str ) ) ;
function first ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) if ( str [ i ] === str [ i ] . toUpperCase ( ) ) return str [ i ] ; return 0 ; } var str = " " ; var res = first ( str ) ; if ( res == 0 ) document . write ( " " ) ; else { document . write ( res ) ; document . write ( " " ) ; }
function evenDecimalValue ( str , n ) { var result = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = i ; j < n ; j ++ ) { var decimalValue = 0 ; var powerOf2 = 1 ; for ( var k = i ; k <= j ; k ++ ) { decimalValue += ( ( str [ k ] - ' ' ) * powerOf2 ) ; powerOf2 *= 2 ; } if ( decimalValue % 2 == 0 ) result ++ ; } } return result ; } var str = " " ; var n = 5 ; document . write ( evenDecimalValue ( str , n ) ) ;
function solve ( s ) { var l = s . length ; var x = l / 2 ; var y = l ; var p = " " ; while ( x > 0 && y > l / 2 ) { var ch = s . charAt ( x - 1 ) ; p += ch ; x -- ; ch = s . charAt ( y - 1 ) ; p += ch ; y -- ; } if ( y > l / 2 ) { var ch = s . charAt ( x - 1 ) ; p += ch ; y -- ; } document . write ( p ) ; } var s = " " ; solve ( s ) ;
function recLen ( str ) { if ( str == " " ) return 0 ; else return recLen ( str . substring ( 1 ) ) + 1 ; } let str = " " ; document . write ( recLen ( str ) ) ;
function isConsonant ( ch ) { ch = ch . toUpperCase ( ) ; console . log ( ch ) ; return ( ! ( ch == " " ch == " " ch == " " ch == " " ch == " " ) && ch . match ( / [A-Z] / i ) ) ; } function totalConsonants ( str ) { var count = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) if ( isConsonant ( str [ i ] ) ) ++ count ; return count ; } var str = " " ; document . write ( totalConsonants ( str ) ) ;
function reverseBits ( n ) { let rev = 0 ; while ( n > 0 ) { rev <<= 1 ; if ( ( n & 1 ) == 1 ) rev ^= 1 ; n >>= 1 ; } return rev ; } function isPalindrome ( n ) { let rev = reverseBits ( n ) ; return ( n == rev ) ; } let n = 9 ; if ( isPalindrome ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function calSumUtil ( a , b , n , m ) { let sum = new Array ( n ) ; let i = n - 1 , j = m - 1 , k = n - 1 ; let carry = 0 , s = 0 ; while ( j >= 0 ) { s = a [ i ] + b [ j ] + carry ; sum [ k ] = ( s % 10 ) ; carry = Math . floor ( s / 10 ) ; k -- ; i -- ; j -- ; } while ( i >= 0 ) { s = a [ i ] + carry ; sum [ k ] = ( s % 10 ) ; carry = Math . floor ( s / 10 ) ; i -- ; k -- ; } let ans = 0 ; if ( carry ) ans = 10 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { ans += sum [ i ] ; ans *= 10 ; } return ans / 10 ; } function calSum ( a , b , n , m ) { if ( n >= m ) return calSumUtil ( a , b , n , m ) ; else return calSumUtil ( b , a , m , n ) ; } let a = [ 9 , 3 , 9 ] ; let b = [ 6 , 1 ] ; let n = a . length ; let m = b . length ; document . write ( calSum ( a , b , n , m ) + " " ) ;
let SIZE = 26 ; function longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) { let freq1 = new Array ( SIZE ) ; let freq2 = new Array ( SIZE ) ; for ( let i = 0 ; i < SIZE ; i ++ ) { freq1 [ i ] = 0 ; freq2 [ i ] = 0 ; } let len = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) freq1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n2 ; i ++ ) freq2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < SIZE ; i ++ ) len += Math . min ( freq1 [ i ] , freq2 [ i ] ) ; return len ; } let str1 = " " ; let str2 = " " ; let n1 = str1 . length ; let n2 = str2 . length ; document . write ( " " + longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) ) ;
function isPanalphabeticWindow ( s , n ) { var ch = ' ' ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ch ) ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; if ( ch == String . fromCharCode ( ' ' . charCodeAt ( 0 ) + 1 ) ) return true ; } return false ; } var s = " " + " " ; var n = ( s . length ) ; ( isPanalphabeticWindow ( s , n ) ) ? ( document . write ( " " ) ) : ( document . write ( " " ) ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } function prime_index ( input ) { let n = input . length ; for ( let i = 2 ; i <= n ; i ++ ) if ( isPrime ( i ) ) document . write ( input [ i - 1 ] ) ; } let input = " " ; prime_index ( input ) ;
function isHeterogram ( s , n ) { var hash = Array ( 26 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] != ' ' ) { if ( hash [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] == 0 ) hash [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = 1 ; else return false ; } } return true ; } var s = " " ; var n = s . length ; ( isHeterogram ( s , n ) ) ? ( document . write ( " " ) ) : ( document . write ( " " ) ) ;
function ASCIISentence ( str ) { let l = str . length ; let convert ; for ( let i = 0 ; i < l ; i ++ ) { convert = str [ i ] . charCodeAt ( 0 ) ; document . write ( convert ) ; } } let str = " " ; document . write ( " " ) ; ASCIISentence ( str ) ;
function convert ( str ) { let n = str . length ; let str1 = " " ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) str1 = str1 + ' ' ; else str1 = str1 + ( str [ i ] ) . toLowerCase ( ) ; } document . write ( str1 ) ; } let str = " " ; convert ( str ) ;
function replace ( s , c1 , c2 ) { let l = s . length ; let arr = s . split ( " " ) ; for ( let i = 0 ; i < l ; i ++ ) { if ( arr [ i ] == c1 ) arr [ i ] = c2 ; else if ( arr [ i ] == c2 ) arr [ i ] = c1 ; } return arr . join ( " " ) ; } let s = " " ; let c1 = ' ' , c2 = ' ' ; document . write ( replace ( s , c1 , c2 ) ) ;
function constructPalin ( str , len ) { var i = 0 , j = len - 1 ; for ( ; i < j ; i ++ , j -- ) { if ( str [ i ] == str [ j ] && str [ i ] != ' ' ) continue ; else if ( str [ i ] == str [ j ] && str [ i ] == ' ' ) { str [ i ] = ' ' ; str [ j ] = ' ' ; continue ; } else if ( str [ i ] == ' ' ) { str [ i ] = str [ j ] ; continue ; } else if ( str [ j ] == ' ' ) { str [ j ] = str [ i ] ; continue ; } document . write ( " " ) ; return " " ; } return str . join ( " " ) ; } var str = " " . split ( " " ) ; var len = str . length ; document . write ( constructPalin ( str , len ) ) ;
function remainder ( str ) { let len = str . length ; let num ; let rem = 0 ; for ( let i = 0 ; i < len ; i ++ ) { num = rem * 10 + ( str [ i ] - ' ' ) ; rem = num % 11 ; } return rem ; } let str = " " ; document . write ( remainder ( str ) ) ;
function findPermutations ( str , index , n ) { if ( index >= n index + 1 >= n ) { document . write ( str . join ( " " ) + " " ) ; return ; } findPermutations ( str , index + 1 , n ) ; swap ( str , index ) ; findPermutations ( str , index + 2 , n ) ; swap ( str , index ) ; } function swap ( arr , index ) { var temp = arr [ index ] ; arr [ index ] = arr [ index + 1 ] ; arr [ index + 1 ] = temp ; } var str = " " . split ( " " ) ; var n = str . length ; findPermutations ( str , 0 , n ) ;
function isUnique ( a , n , k ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += a [ i ] ; sum += n - 1 ; return ( sum == k ) ; } var a = [ 3 , 3 , 3 ] ; var n = a . length ; var k = 12 ; if ( isUnique ( a , n , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isPalindrome ( s , i , j ) { let p = j ; for ( let k = i ; k <= p ; k ++ ) { if ( s [ k ] != s [ p ] ) return false ; p -- ; } return true ; } function countWays ( s ) { let n = s . length ; let count = 0 ; if ( isPalindrome ( s , 0 , n - 1 ) ) { for ( let i = n / 2 ; i < n ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) count ++ ; else break ; } { count ++ ; } else } else { for ( let i = 0 ; i < n / 2 ; i ++ ) { if ( s [ i ] != s [ n - 1 - i ] ) { let j = n - 1 - i ; if ( isPalindrome ( s , i , n - 2 - i ) ) { for ( let k = i - 1 ; k >= 0 ; k -- ) { if ( s [ k ] != s [ j ] ) break ; count ++ ; } count ++ ; } if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) { for ( let k = n - i ; k < n ; k ++ ) { if ( s [ k ] != s [ i ] ) break ; count ++ ; } count ++ ; } break ; } } } return count ; } let s = " " ; document . write ( countWays ( s ) ) ;
function countOfSubstringWithKOnes ( s , K ) { let N = s . length ; let res = 0 ; let countOfOne = 0 ; let freq = new Array ( N + 1 ) ; freq . fill ( 0 ) ; freq [ 0 ] = 1 ; for ( let i = 0 ; i < N ; i ++ ) { countOfOne += ( s [ i ] - ' ' ) ; if ( countOfOne >= K ) { res += freq [ countOfOne - K ] ; } freq [ countOfOne ] ++ ; } return res ; } let s = " " ; let K = 1 ; document . write ( countOfSubstringWithKOnes ( s , K ) ) ;
function reverse ( num , i , j ) { while ( i < j ) { var temp = num [ i ] ; num [ i ] = num [ j ] ; num [ j ] = temp ; i ++ ; j -- ; } } function nextPalin ( num , n ) { if ( n <= 3 ) { document . write ( " " ) ; return ; } var temp ; var mid = n / 2 - 1 ; var i , j ; for ( i = mid - 1 ; i >= 0 ; i -- ) if ( num [ i ] < num [ i + 1 ] ) break ; if ( i < 0 ) { document . write ( " " ) ; return ; } var smallest = i + 1 ; for ( j = i + 2 ; j <= mid ; j ++ ) if ( num [ j ] > num [ i ] && num [ j ] <= num [ smallest ] ) smallest = j ; temp = num [ i ] ; num [ i ] = num [ smallest ] ; num [ smallest ] = temp ; temp = num [ n - i - 1 ] ; num [ n - i - 1 ] = num [ n - smallest - 1 ] ; num [ n - smallest - 1 ] = temp ; reverse ( num , i + 1 , mid ) ; if ( n % 2 == 0 ) reverse ( num , mid + 1 , n - i - 2 ) ; else reverse ( num , mid + 2 , n - i - 2 ) ; var result = num . join ( ' ' ) ; document . write ( " " + result ) ; } var str = " " ; var num = str . split ( ' ' ) ; var n = str . length ; nextPalin ( num , n ) ;
function printRec ( number , extraOnes , remainingPlaces ) { if ( 0 == remainingPlaces ) { document . write ( number + " " ) ; return ; } printRec ( number + " " , extraOnes + 1 , remainingPlaces - 1 ) ; if ( 0 < extraOnes ) printRec ( number + " " , extraOnes - 1 , remainingPlaces - 1 ) ; } function printNums ( n ) { let str = " " ; printRec ( str , 0 , n ) ; } let n = 4 ; printNums ( n ) ;
function nextHighUsingAtMostOneSwap ( st ) { var num = st . split ( ' ' ) ; var l = num . length ; var posRMax = l - 1 ; var index = - 1 ; for ( var i = l - 2 ; i >= 0 ; i -- ) { if ( num [ i ] >= num [ posRMax ] ) posRMax = i ; else { index = i ; break ; } } if ( index == - 1 ) return " " ; var greatSmallDgt = - 1 ; for ( var i = l - 1 ; i > index ; i -- ) { if ( num [ i ] > num [ index ] ) { if ( greatSmallDgt == - 1 ) greatSmallDgt = i ; else if ( num [ i ] <= num [ greatSmallDgt ] ) greatSmallDgt = i ; } } var temp = num [ index ] ; num [ index ] = num [ greatSmallDgt ] ; num [ greatSmallDgt ] = temp ; return ( num . join ( ' ' ) ) ; } var num = " " ; document . write ( " " + num ) ; document . write ( " " + nextHighUsingAtMostOneSwap ( num ) ) ;
function isVowel ( c ) { return ( c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' ) ; } function longestVowel ( str ) { let count = 0 , res = 0 ; let s = str . split ( " " ) ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( isVowel ( s [ i ] ) ) count ++ ; else { res = Math . max ( res , count ) ; count = 0 ; } } return Math . max ( res , count ) ; } let s = " " ; document . write ( longestVowel ( s ) ) ;
let MAX_CHAR = 26 ; function check ( freq , k ) { for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( freq [ i ] != 0 && freq [ i ] != k ) return false ; return true ; } function substrings ( s , k ) { let res = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { let freq = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } for ( let j = i ; j < s . length ; j ++ ) { let index = s [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; freq [ index ] ++ ; if ( freq [ index ] > k ) break ; else if ( freq [ index ] == k && check ( freq , k ) == true ) res ++ ; } } return res ; } let s = " " ; let k = 2 ; document . write ( substrings ( s , k ) + " " ) ; s = " " ; k = 2 ; document . write ( substrings ( s , k ) + " " ) ;
function countSubstrs ( str , i , j , n ) { if ( n == 1 ) return 1 ; if ( n <= 0 ) return 0 ; let res = countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ; if ( str [ i ] == str [ j ] ) res ++ ; return res ; } let str = " " ; let n = str . length ; document . write ( countSubstrs ( str , 0 , n - 1 , n ) ) ;
function countManipulations ( s1 , s2 ) { let count = 0 ; let char_count = new Array ( 26 ) ; for ( let i = 0 ; i < char_count . length ; i ++ ) { char_count [ i ] = 0 ; } for ( let i = 0 ; i < s1 . length ; i ++ ) char_count [ s1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < s2 . length ; i ++ ) { char_count [ s2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] -- ; } for ( let i = 0 ; i < 26 ; ++ i ) { if ( char_count [ i ] != 0 ) { count += Math . abs ( char_count [ i ] ) ; } } return count ; } let s1 = " " ; let s2 = " " ; document . write ( countManipulations ( s1 , s2 ) ) ;
var MAX_CHAR = 26 ; function stringPalindrome ( A , B ) { var countA = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; var countB = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; var l1 = A . length ; var l2 = B . length ; for ( var i = 0 ; i < l1 ; i ++ ) countA [ A . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < l2 ; i ++ ) countB [ B . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < 26 ; i ++ ) if ( ( countA [ i ] > 1 && countB [ i ] == 0 ) ) return ' ' ; return ' ' ; } var a = " " ; var b = " " ; document . write ( stringPalindrome ( a , b ) ) ;
var MAX_CHAR = 256 ; function countBalance ( str ) { var leftVisited = Array ( MAX_CHAR ) . fill ( 0 ) ; var rightVisited = Array ( MAX_CHAR ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) rightVisited [ str [ i ] . charCodeAt ( 0 ) ] ++ ; var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { leftVisited [ str [ i ] . charCodeAt ( 0 ) ] ++ ; rightVisited [ str [ i ] . charCodeAt ( 0 ) ] -- ; var j ; for ( j = 0 ; j < MAX_CHAR ; j ++ ) { if ( ( leftVisited [ j ] == 0 && rightVisited [ j ] != 0 ) || ( leftVisited [ j ] != 0 && rightVisited [ j ] == 0 ) ) break ; } if ( j == MAX_CHAR ) res ++ ; } return res ; } var str = " " ; document . write ( countBalance ( str ) ) ;
function findFlips ( str , n ) { var last = ' ' ; var res = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( last != str . charAt ( i ) ) res ++ ; last = str . charAt ( i ) ; } return parseInt ( res / 2 ) ; } var str = " " ; var n = str . length ; document . write ( findFlips ( str , n ) ) ;
function findLen ( A , n , k , ch ) { let maxlen = 1 ; let cnt = 0 ; let l = 0 , r = 0 ; while ( r < n ) { if ( A [ r ] != ch ) ++ cnt ; while ( cnt > k ) { if ( A [ l ] != ch ) -- cnt ; ++ l ; } maxlen = Math . max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; } function answer ( A , n , k ) { let maxlen = 1 ; for ( let i = 0 ; i < 26 ; ++ i ) { maxlen = Math . max ( maxlen , findLen ( A , n , k , String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ) ) ; maxlen = Math . max ( maxlen , findLen ( A , n , k , String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ) ) ; } return maxlen ; } let n = 5 , k = 2 ; let A = " " ; document . write ( " " + answer ( A , n , k ) + " " ) ; n = 6 ; k = 4 ; let B = " " ; document . write ( " " + answer ( B , n , k ) ) ;
let MAX_CHAR = 26 ; function checkCorrectOrNot ( s ) { let count1 = new Array ( MAX_CHAR ) ; let count2 = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) { count1 [ i ] = 0 ; count2 [ i ] = 0 ; } let n = s . length ; if ( n == 1 ) return true ; for ( let i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count1 [ s [ i ] - ' ' ] ++ ; count2 [ s [ j ] - ' ' ] ++ ; } for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] != count2 [ i ] ) return false ; return true ; } let s = " " ; if ( checkCorrectOrNot ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function maximumNum ( curr_num , res ) { let len1 = curr_num . length ; let len2 = res . length ; if ( len1 == len2 ) { let i = 0 ; while ( curr_num [ i ] == res [ i ] ) i ++ ; if ( curr_num [ i ] < res [ i ] ) return res ; else return curr_num ; } return len1 < len2 ? res : curr_num ; } function extractMaximum ( str ) { let n = str . length ; let curr_num = " " ; let res = " " ; for ( let i = 0 ; i < n ; i ++ ) { while ( i < n && str [ i ] == ' ' ) i ++ ; while ( i < n && ! isNaN ( String ( str [ i ] ) * 1 ) ) { curr_num = curr_num + str [ i ] ; i ++ ; } if ( i == n ) break ; if ( curr_num . length > 0 ) i -- ; res = maximumNum ( curr_num , res ) ; curr_num = " " ; } if ( curr_num . length == 0 && res . length == 0 ) res = res + ' ' ; return maximumNum ( curr_num , res ) ; } let str = " " ; document . write ( extractMaximum ( str ) ) ;
function isDivisible999 ( num ) { let n = num . length ; if ( n == 0 && num [ 0 ] == ' ' ) return true ; if ( n % 3 == 1 ) num = " " + num ; if ( n % 3 == 2 ) num = " " + num ; let gSum = 0 ; for ( let i = 0 ; i < n ; i += 3 ) { group = 0 ; group += ( num . charCodeAt ( i ) - 48 ) * 100 ; group += ( num . charCodeAt ( i + 1 ) - 48 ) * 10 ; group += ( num . charCodeAt ( i + 2 ) - 48 ) ; gSum += group ; } if ( gSum > 1000 ) { num = String ( gSum ) ; n = strlen ( num ) ; gSum = isDivisible999 ( num ) ; } return ( gSum == 999 ) ; } let num = " " ; if ( isDivisible999 ( num ) ) document . write ( " " ) ; else document . write ( " " ) ;
let MAX_CHAR = 26 ; function arrangeString ( str ) { let char_count = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) { char_count [ i ] = 0 ; } let sum = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] >= " " && str [ i ] <= " " ) char_count [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; else sum = sum + ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; } let res = " " ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) { let ch = String . fromCharCode ( ' ' . charCodeAt ( 0 ) + i ) ; while ( char_count [ i ] -- != 0 ) res = res + ch ; } if ( sum > 0 ) res = res + sum ; return res ; } let str = " " ; document . write ( arrangeString ( str ) ) ;
function subString ( str , n ) { for ( let len = 1 ; len <= n ; len ++ ) { for ( let i = 0 ; i <= n - len ; i ++ ) { let j = i + len - 1 ; for ( let k = i ; k <= j ; k ++ ) { document . write ( str [ k ] ) ; } document . write ( " " ) ; } } } let str = [ ' ' , ' ' , ' ' ] ; subString ( str , str . length ) ;
function isVowel ( ch ) { ch = ch . toUpperCase ( ) ; return ch == " " || ch == " " || ch == " " || ch == " " || ch == " " ; } function countVowels ( str ) { var count = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) if ( isVowel ( str [ i ] ) ) ++ count ; return count ; } var str = " " ; document . write ( countVowels ( str ) ) ; document . write ( " " ) ;
function printRotatedString ( str ) { var len = str . length ; var sb ; for ( i = 0 ; i < len ; i ++ ) { sb = [ ] ; var j = i ; var k = 0 ; for ( k2 = j ; k2 < str . length ; k2 ++ ) { sb . push ( str . charAt ( j ) ) ; k ++ ; j ++ ; } j = 0 ; while ( j < i ) { sb . push ( str . charAt ( j ) ) ; j ++ ; k ++ ; } document . write ( sb . join ( " " ) + " " ) ; } } var str = " " ; printRotatedString ( str ) ;
function isPalindrome ( str ) { let n = str . length ; for ( let i = 0 ; i < n / 2 ; i ++ ) { if ( str [ i ] != str [ n - i - 1 ] ) return false ; } return true ; } function maxLengthNonPalinSubstring ( str ) { let n = str . length ; let ch = str [ 0 ] ; let i = 1 ; for ( i = 1 ; i < n ; i ++ ) { if ( str [ i ] != ch ) { break ; } } if ( i == n ) return 0 ; if ( isPalindrome ( str ) ) return n - 1 ; return n ; } let str = " " ; document . write ( " " + maxLengthNonPalinSubstring ( str ) ) ;
function isKthBitSet ( n , k ) { if ( ( ( n >> ( k - 1 ) ) & 1 ) > 0 ) document . write ( " " ) ; else document . write ( " " ) ; } let n = 5 , k = 1 ; isKthBitSet ( n , k ) ;
function checkEquality ( s ) { return ( s . charAt ( 0 ) == s . charAt ( s . length - 1 ) ) ; } function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; for ( var i = 0 ; i < n ; i ++ ) for ( var len = 1 ; len <= n - i ; len ++ ) if ( checkEquality ( s . substring ( i , i + len ) ) ) result ++ ; return result ; } var s = " " ; document . write ( countSubstringWithEqualEnds ( s ) ) ;
function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; for ( i = 0 ; i < n ; i ++ ) for ( j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; } var s = " " ; document . write ( countSubstringWithEqualEnds ( s ) ) ;
function maxRepeating ( str ) { let len = str . length ; let count = 0 ; let res = str [ 0 ] ; for ( let i = 0 ; i < len ; i ++ ) { let cur_count = 1 ; for ( let j = i + 1 ; j < len ; j ++ ) { if ( str [ i ] != str [ j ] ) break ; cur_count ++ ; } if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } } return res ; } let str = " " ; document . write ( maxRepeating ( str ) ) ;
function findSum ( str1 , str2 ) { if ( str1 . length > str2 . length ) { let t = str1 ; str1 = str2 ; str2 = t ; } let str = " " ; let n1 = str1 . length , n2 = str2 . length ; str1 = str1 . split ( " " ) . reverse ( ) . join ( " " ) ; str2 = str2 . split ( " " ) . reverse ( ) . join ( " " ) ; let carry = 0 ; for ( let i = 0 ; i < n1 ; i ++ ) { let sum = ( ( str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) + ( str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) + carry ) ; str += String . fromCharCode ( sum % 10 + ' ' . charCodeAt ( 0 ) ) ; carry = Math . floor ( sum / 10 ) ; } for ( let i = n1 ; i < n2 ; i ++ ) { let sum = ( ( str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) + carry ) ; str += String . fromCharCode ( sum % 10 + ' ' . charCodeAt ( 0 ) ) ; carry = Math . floor ( sum / 10 ) ; } if ( carry > 0 ) str += String . fromCharCode ( carry + ' ' . charCodeAt ( 0 ) ) ; str = str . split ( " " ) . reverse ( ) . join ( " " ) ; return str ; } let str1 = " " ; let str2 = " " ; document . write ( findSum ( str1 , str2 ) )
function areChractersUnique ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { let val = ( str [ i ] - ' ' ) ; if ( ( checker & ( 1 << val ) ) > 0 ) return false ; checker |= ( 1 << val ) ; } return true ; } var s = " " ; if ( areChractersUnique ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countWords ( str , len ) { let count = 1 ; if ( len == 1 ) return count ; if ( str [ 0 ] == str [ 1 ] ) count *= 1 ; else count *= 2 ; for ( let j = 1 ; j < len - 1 ; j ++ ) { if ( str [ j ] == str [ j - 1 ] && str [ j ] == str [ j + 1 ] ) count *= 1 ; else if ( str [ j ] == str [ j - 1 ] str [ j ] == str [ j + 1 ] str [ j - 1 ] == str [ j + 1 ] ) count *= 2 ; else count *= 3 ; } if ( str [ len - 1 ] == str [ len - 2 ] ) count *= 1 ; else count *= 2 ; return count ; } let str = " " ; let len = str . length ; document . write ( countWords ( str , len ) ) ;
function replaceDig ( x , from , to ) { var result = 0 ; var multiply = 1 ; while ( x > 0 ) { var reminder = x % 10 ; if ( reminder == from ) result = result + to * multiply ; else result = result + reminder * multiply ; multiply *= 10 ; x = parseInt ( x / 10 ) ; } return result ; } function calculateMinMaxSum ( x1 , x2 ) { var minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) ; var maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) ; document . write ( " " + minSum ) ; document . write ( " " + maxSum ) ; } var x1 = 5466 , x2 = 4555 ; calculateMinMaxSum ( x1 , x2 ) ;
function qType1 ( l , x , str1 ) { str1 [ l - 1 ] = x ; } function qType2 ( l , r , str1 ) { let freq = new Array ( 27 ) ; for ( let i = 0 ; i < 27 ; i ++ ) { freq [ i ] = 0 ; } for ( let i = l - 1 ; i <= r - 1 ; i ++ ) { freq [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } let count = 0 ; for ( let j = 0 ; j < 26 ; j ++ ) { if ( freq [ j ] % 2 != 0 ) { count ++ ; } } if ( count <= 1 ) { document . write ( " " ) ; } else { document . write ( " " ) ; } } let str = " " . split ( " " ) ; let n = str . length ; qType1 ( 4 , ' ' , str ) ; qType2 ( 1 , 4 , str ) ; qType2 ( 2 , 3 , str ) ; qType1 ( 10 , ' ' , str ) ; qType2 ( 10 , 11 , str ) ;
function findTwoscomplement ( str ) { var n = str . length ; var i ; for ( i = n - 1 ; i >= 0 ; i -- ) if ( str . charAt ( i ) == ' ' ) break ; if ( i == - 1 ) return " " + str ; for ( k = i - 1 ; k >= 0 ; k -- ) { if ( str . charAt ( k ) == ' ' ) str = str . substring ( 0 , k ) + " " + str . substring ( k + 1 , str . length ) ; else str = str . substring ( 0 , k ) + " " + str . substring ( k + 1 , str . length ) ; } return str . toString ( ) ; } var str = " " ; document . write ( findTwoscomplement ( str ) ) ;
function isequal ( str ) { let n = str . length ; let num = 0 , x = 1 , i = n - 1 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( ' ' <= str [ i ] && str [ i ] <= ' ' ) { num = ( str [ i ] - ' ' ) * x + num ; x = x * 10 ; if ( num >= n ) return false ; } else break ; } return num == i + 1 ; } let str = " " ; if ( isequal ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countToMake0lternate ( s ) { let result = 0 ; for ( let i = 0 ; i < ( s . length - 1 ) ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return result ; } document . write ( countToMake0lternate ( " " ) + " " ) ; document . write ( countToMake0lternate ( " " ) + " " ) ; document . write ( countToMake0lternate ( " " ) + " " ) ;
function isPossiblePalindrome ( str ) { let n = str . length ; for ( let i = 0 ; i < Math . floor ( n / 2 ) ; i ++ ) { if ( str [ i ] != ' ' && str [ n - i - 1 ] != ' ' && str [ i ] != str [ n - i - 1 ] ) return false ; } return true ; } function smallestPalindrome ( str ) { if ( ! isPossiblePalindrome ( str ) ) document . write ( " " ) ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { if ( str [ n - i - 1 ] != ' ' ) str [ i ] = str [ n - i - 1 ] ; else str [ i ] = str [ n - i - 1 ] = ' ' ; } } for ( let i = 0 ; i < n ; i ++ ) document . write ( str [ i ] + " " ) ; } let str = " " ; let s = str . split ( " " ) ; smallestPalindrome ( s ) ;
function flip ( ch ) { return ( ch == ' ' ) ? ' ' : ' ' ; } function getFlipWithStartingCharcter ( str , expected ) { let flipCount = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str . charAt ( i ) != expected ) flipCount ++ ; expected = flip ( expected ) ; } return flipCount ; } function minFlipToMakeStringAlternate ( str ) { return Math . min ( getFlipWithStartingCharcter ( str , ' ' ) , getFlipWithStartingCharcter ( str , ' ' ) ) ; } let str = " " ; document . write ( minFlipToMakeStringAlternate ( str ) ) ;
function remainderWith7 ( num ) { series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] var series_index = 0 ; for ( var i = num . length - 1 ; i >= 0 ; i -- ) { var digit = num [ i ] - ' ' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; } var str = " " ; document . write ( " " + remainderWith7 ( str ) ) ;
function intToRoman ( num ) { let m = [ " " , " " , " " , " " ] ; let c = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; let x = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; let i = [ " " , " " , " " , " " , " " , " " , " " , " " , " " , " " ] ; let thousands = m [ Math . floor ( num / 1000 ) ] ; let hundereds = c [ Math . floor ( ( num % 1000 ) / 100 ) ] ; let tens = x [ Math . floor ( ( num % 100 ) / 10 ) ] ; let ones = i [ num % 10 ] ; let ans = thousands + hundereds + tens + ones ; return ans ; } let number = 3549 ; document . write ( intToRoman ( number ) ) ;
function pattern ( str , len ) { for ( var i = 0 ; i < len ; i ++ ) { var j = len - 1 - i ; for ( var k = 0 ; k < len ; k ++ ) { if ( k == i k == j ) document . write ( str . charAt ( k ) ) ; else document . write ( " " ) ; } document . write ( ' ' ) ; } } var str = " " ; var len = str . length ; pattern ( str , len ) ;
var no_of_chars = 256 ; function findSubString ( str , pat ) { var len1 = str . length ; var len2 = pat . length ; if ( len1 < len2 ) { document . write ( " " ) ; return " " ; } var hash_pat = Array . from ( { length : no_of_chars } , ( _ , i ) => 0 ) ; var hash_str = Array . from ( { length : no_of_chars } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < len2 ; i ++ ) hash_pat [ pat . charAt ( i ) . charCodeAt ( 0 ) ] ++ ; var start = 0 , start_index = - 1 , min_len = Number . MAX_VALUE ; var count = 0 ; for ( var j = 0 ; j < len1 ; j ++ ) { hash_str [ str . charAt ( j ) . charCodeAt ( 0 ) ] ++ ; if ( hash_str [ str . charAt ( j ) . charCodeAt ( 0 ) ] <= hash_pat [ str . charAt ( j ) . charCodeAt ( 0 ) ] ) count ++ ; if ( count == len2 ) { while ( hash_str [ str . charAt ( start ) . charCodeAt ( 0 ) ] > hash_pat [ str . charAt ( start ) . charCodeAt ( 0 ) ] || hash_pat [ str . charAt ( start ) . charCodeAt ( 0 ) ] == 0 ) { if ( hash_str [ str . charAt ( start ) . charCodeAt ( 0 ) ] > hash_pat [ str . charAt ( start ) . charCodeAt ( 0 ) ] ) hash_str [ str . charAt ( start ) . charCodeAt ( 0 ) ] -- ; start ++ ; } var len_window = j - start + 1 ; if ( min_len > len_window ) { min_len = len_window ; start_index = start ; } } } if ( start_index == - 1 ) { document . write ( " " ) ; return " " ; } return str . substring ( start_index , start_index + min_len ) ; } var str = " " ; var pat = " " ; document . write ( " " + findSubString ( str , pat ) ) ;
var set = [ ] ; var prime = [ ] ; function isPrime ( x ) { var sqroot = Math . sqrt ( x ) ; var flag = true ; if ( x == 1 ) return false ; for ( var i = 2 ; i <= sqroot ; i ++ ) if ( x % i == 0 ) return false ; return true ; } function display ( ) { var length = set . length ; for ( var i = 0 ; i < length ; i ++ ) document . write ( set [ i ] + " " ) ; document . write ( " " ) ; } function primeSum ( total , N , S , index ) { if ( total == S && set . length == N ) { display ( ) ; return ; } if ( total > S index == prime . length ) return ; set . push ( prime [ index ] ) ; primeSum ( total + prime [ index ] , N , S , index + 1 ) ; set . pop ( ) ; primeSum ( total , N , S , index + 1 ) ; } function allPrime ( N , S , P ) { for ( var i = P + 1 ; i <= S ; i ++ ) { if ( isPrime ( i ) ) prime . push ( i ) ; } if ( prime . length < N ) return ; primeSum ( 0 , N , S , 0 ) ; } var S = 54 , N = 2 , P = 3 ; allPrime ( N , S , P ) ;
function F ( A , B ) { if ( A == 1 ) return ( 4 % B ) ; else { var temp = F ( A - 1 , B ) ; return ( temp * temp ) % B ; } } var A = 25 , B = 50 ; document . write ( F ( A , B ) ) ;
MOD = 1000000007 function rangeSum ( l , r ) { var a = 1 , b = 9 , res = 0 ; for ( var i = 1 ; i <= 10 ; i ++ ) { var L = Math . max ( l , a ) ; var R = Math . min ( r , b ) ; if ( L <= R ) { var sum = ( L + R ) * ( R - L + 1 ) / 2 ; res += ( i * i ) * ( sum % MOD ) ; res %= MOD ; } a = a * 10 ; b = b * 10 + 9 ; } return res ; } var l = 98 , r = 102 ; document . write ( rangeSum ( l , r ) ) ;
const INF = 99999 ; const size = 10 ; function getSetBitsFromOneToN ( N ) { let two = 2 , ans = 0 ; let n = N ; while ( n ) { ans += parseInt ( N / two ) * ( two >> 1 ) ; if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 ; two <<= 1 ; n >>= 1 ; } return ans ; } function findMinimum ( x ) { let low = 0 , high = 100000 ; let ans = high ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( getSetBitsFromOneToN ( mid ) >= x ) { ans = Math . min ( ans , mid ) ; high = mid - 1 ; } else low = mid + 1 ; } return ans ; } let x = 20 ; document . write ( findMinimum ( x ) ) ;
function trailingZeroes ( n ) { var cnt = 0 ; while ( n > 0 ) { n = parseInt ( n / 5 ) ; cnt += n ; } return cnt ; } function binarySearch ( n ) { var low = 0 ; while ( low < high ) { var mid = parseInt ( ( low + high ) / 2 ) ; var count = trailingZeroes ( mid ) ; if ( count < n ) low = mid + 1 ; else high = mid ; } var result = [ ] ; while ( trailingZeroes ( low ) == n ) { result . push ( low ) ; low ++ ; } for ( var i = 0 ; i < result . length ; i ++ ) document . write ( result [ i ] + " " ) ; } var n = 2 ; binarySearch ( n ) ;
function minDaysToEmpty ( C , l ) { if ( l >= C ) return C ; let eq_root = ( Math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 ; return ( Math . ceil ( eq_root ) + l ) ; } document . write ( minDaysToEmpty ( 5 , 2 ) + " " ) ; document . write ( minDaysToEmpty ( 6514683 , 4965 ) ) ;
function kth ( arr1 , arr2 , m , n , k ) { var sorted1 = Array ( m + n ) . fill ( 0 ) ; var i = 0 , j = 0 , d = 0 ; while ( i < m && j < n ) { if ( arr1 [ i ] < arr2 [ j ] ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; else sorted1 [ d ++ ] = arr2 [ j ++ ] ; } while ( i < m ) sorted1 [ d ++ ] = arr1 [ i ++ ] ; while ( j < n ) sorted1 [ d ++ ] = arr2 [ j ++ ] ; return sorted1 [ k - 1 ] ; } var arr1 = [ 2 , 3 , 6 , 7 , 9 ] ; var arr2 = [ 1 , 4 , 8 , 10 ] ; var k = 5 ; document . write ( kth ( arr1 , arr2 , 5 , 4 , k ) ) ;
let R = 2 ; let C = 2 ; function bsearch ( low , high , n , arr ) { let mid = ( low + high ) / 2 ; if ( low <= high ) { if ( arr [ mid ] < n ) return bsearch ( mid + 1 , high , n , arr ) ; return bsearch ( low , mid - 1 , n , arr ) ; } return low ; } function mindiff ( arr , n , m ) { for ( let i = 0 ; i < n ; i ++ ) arr . sort ( ) ; let ans = + 2147483647 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { let p = bsearch ( 0 , m - 1 , arr [ i ] [ j ] , arr [ i + 1 ] ) ; ans = Math . min ( ans , Math . abs ( arr [ i + 1 ] [ p ] - arr [ i ] [ j ] ) ) ; if ( p - 1 >= 0 ) ans = Math . min ( ans , Math . abs ( arr [ i + 1 ] [ p - 1 ] - arr [ i ] [ j ] ) ) ; } } return ans ; } let m = [ [ 8 , 5 ] , [ 6 , 8 ] ] ; document . write ( mindiff ( m , R , C ) ) ;
function binarySearch ( arr , left , right ) { if ( left <= right ) { var mid = parseInt ( ( left + right ) / 2 ) ; if ( arr [ mid - 1 ] < arr [ mid ] && arr [ mid ] > arr [ mid + 1 ] ) return mid ; if ( arr [ mid ] < arr [ mid + 1 ] ) return binarySearch ( arr , mid + 1 , right ) ; else return binarySearch ( arr , left , mid - 1 ) ; } return - 1 ; } var arr = [ 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 ] ; var n = arr . length ; var index = binarySearch ( arr , 1 , n - 2 ) ; if ( index != - 1 ) document . write ( arr [ index ] ) ;
function findRepeatingElement ( arr , low , high ) { if ( low > high ) return - 1 ; var mid = parseInt ( ( low + high ) / 2 ) ; if ( arr [ mid ] != mid + 1 ) { if ( mid > 0 && arr [ mid ] == arr [ mid - 1 ] ) return mid ; return findRepeatingElement ( arr , low , mid - 1 ) ; } return findRepeatingElement ( arr , mid + 1 , high ) ; } var arr = [ 1 , 2 , 3 , 3 , 4 , 5 ] ; var n = arr . length ; var index = findRepeatingElement ( arr , 0 , n - 1 ) ; if ( index != - 1 ) document . write ( arr [ index ] ) ;
function diff ( n , mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; } function cubicRoot ( n ) { let start = 0 , end = n ; let e = 0.0000001 ; while ( true ) { let mid = ( start + end ) / 2 ; let error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } } let n = 3 ; document . write ( " " + n + " " + cubicRoot ( n ) ) ;
function floorSqrt ( x ) { if ( x == 0 x == 1 ) return x ; let i = 1 ; let result = 1 ; while ( result <= x ) { i ++ ; result = i * i ; } return i - 1 ; } let x = 11 ; document . write ( floorSqrt ( x ) ) ;
function sumOfInternalAngles ( n ) { if ( n < 3 ) return 0 ; return ( n - 2 ) * 180 ; } let n = 5 ; document . write ( sumOfInternalAngles ( n ) ) ;
function diagonal_length ( a ) { let L ; L = a * Math . sqrt ( 3 ) ; return L ; } let a = 5 ; document . write ( diagonal_length ( a ) . toFixed ( 5 ) ) ;
let PI = 3.14 ; function find_area ( r , d ) { let R = d / PI ; R += Math . pow ( r , 2 ) ; R = Math . sqrt ( R ) ; let area = PI * Math . pow ( R , 2 ) ; return area ; } let r = 4 , d = 5 ; document . write ( find_area ( r , d ) . toFixed ( 2 ) ) ;
function Valid ( a , b , c , d ) { if ( a + b + c + d == 360 ) return 1 ; return 0 ; } var a = 80 , b = 70 , c = 100 , d = 110 ; if ( Valid ( a , b , c , d ) == 1 ) document . write ( " " ) ; else document . write ( " " ) ;
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { var distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; var radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; } var x1 = - 10 , y1 = 8 ; var x2 = 14 , y2 = - 24 ; var r1 = 30 , r2 = 10 ; var t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) document . write ( " " ) ; else if ( t < 0 ) document . write ( " " ) ; else document . write ( " " ) ;
function GCD ( a , b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; } function ratiotang ( r1 , r2 ) { document . write ( " " + r1 / GCD ( r1 , r2 ) + " " + r2 / GCD ( r1 , r2 ) ) ; } var r1 = 4 , r2 = 8 ; ratiotang ( r1 , r2 ) ;
function Regions ( Vertices , Edges ) { var R = Edges + 2 - Vertices ; return R ; } var V = 5 , E = 7 ; document . write ( Regions ( V , E ) ) ;
function GCD ( a , b ) { return ( b != 0 ? GCD ( b , a % b ) : a ) ; } function ratiotang ( r1 , r2 ) { document . write ( " " + r1 / GCD ( r1 , r2 ) + " " + r2 / GCD ( r1 , r2 ) ) ; } var r1 = 4 , r2 = 6 ; ratiotang ( r1 , r2 ) ;
function lengthOfTangent ( r1 , r2 , d ) { document . write ( " " + " " + Math . sqrt ( Math . pow ( d , 2 ) - Math . pow ( ( r1 + r2 ) , 2 ) ) ) ; } var r1 = 4 , r2 = 6 , d = 12 ; lengthOfTangent ( r1 , r2 , d ) ;
function remainingArea ( N , M , K ) { while ( K -- && N && M ) { if ( N > M ) N = N - M ; else M = M - N ; } if ( N > 0 && M > 0 ) return N * M ; else return 0 ; } var N = 5 , M = 3 , K = 2 ; document . write ( remainingArea ( N , M , K ) ) ;
function lengtang ( r1 , r2 ) { document . write ( " " + " " + ( 2 * Math . sqrt ( r1 * r2 ) ) . toFixed ( 5 ) ) ; } var r1 = 5 , r2 = 9 ; lengtang ( r1 , r2 ) ;
function dist ( x1 , y1 , x2 , y2 , r ) { document . write ( " " + " " + ( Math . sqrt ( ( Math . pow ( ( x2 - x1 ) , 2 ) ) + ( Math . pow ( ( y2 - y1 ) , 2 ) ) ) - r ) . toFixed ( 5 ) ) ; } var x1 = 4 , y1 = 6 , x2 = 35 , y2 = 42 , r = 5 ; dist ( x1 , y1 , x2 , y2 , r ) ;
function dist ( m , b1 , b2 ) { var d = Math . abs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; return d ; } var m = 2 , b1 = 4 , b2 = 3 ; document . write ( dist ( m , b1 , b2 ) . toFixed ( 5 ) ) ;
function normal ( m , n ) { var N = ( ( Math . abs ( m ) * Math . abs ( n ) ) / Math . sqrt ( ( Math . abs ( m ) * Math . abs ( m ) ) + ( Math . abs ( n ) * Math . abs ( n ) ) ) ) ; return N ; } var m = - 5 , n = 3 ; document . write ( normal ( m , n ) . toFixed ( 5 ) ) ;
function isPossible ( a , n ) { let sum = 0 , maxS = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; maxS = Math . max ( a [ i ] , maxS ) ; } if ( ( sum - maxS ) > maxS ) return true ; return false ; } let a = [ 2 , 3 , 4 ] ; let n = a . length ; if ( isPossible ( a , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findAreaShaded ( a ) { let sqArea = a * a ; let semiCircleArea = ( 3.14 * ( a * a ) / 8 ) ; let ShadedArea = 4 * semiCircleArea - sqArea ; return ShadedArea ; } let a = 10 ; document . write ( findAreaShaded ( a ) ) ;
function countSteps ( x , y ) { if ( x < y ) { return x + y + 2 * parseInt ( ( y - x ) / 2 ) ; } else { return x + y + 2 * parseInt ( ( ( x - y ) + 1 ) / 2 ) ; } } var x = 4 , y = 3 ; document . write ( countSteps ( x , y ) ) ;
function isSlopeGood ( slope , arr , n ) { var setOfLines = new Set ( ) ; for ( var i = 0 ; i < n ; i ++ ) setOfLines . add ( arr [ i ] - slope * ( i ) ) ; return setOfLines . size == 2 ; } function checkForParallel ( arr , n ) { var slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) ; var slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) ; var slope3 = isSlopeGood ( parseInt ( ( arr [ 2 ] - arr [ 0 ] ) / 2 ) , arr , n ) ; if ( slope1 slope2 slope3 ) { return 1 ; } return 0 ; } var arr = [ 1 , 6 , 3 , 8 , 5 ] ; var n = arr . length ; document . write ( checkForParallel ( arr , n ) ) ;
function pointIsOnLine ( m , c , x , y ) { if ( y == ( ( m * x ) + c ) ) return true ; return false ; } var m = 3 , c = 2 ; var x = 1 , y = 5 ; if ( pointIsOnLine ( m , c , x , y ) ) document . write ( " " ) ; else document . write ( " " ) ;
function Area ( a , b ) { if ( a < 0 && b < 0 ) return - 1 ; let h = Math . sqrt ( ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ) ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; } let a = 5 , b = 4 ; document . write ( Area ( a , b ) + " " ) ;
function maxRectangles ( L , B , l , b ) { var horizontal = 0 , vertical = 0 ; if ( l <= L && b <= B ) { var columns = parseInt ( B / b ) ; var rows = parseInt ( L / l ) ; horizontal = rows * columns ; } if ( l <= B && b <= L ) { var columns = parseInt ( L / b ) ; var rows = parseInt ( B / l ) ; vertical = rows * columns ; } return Math . max ( horizontal , vertical ) ; } var L = 10 , B = 7 , l = 4 , b = 3 ; document . write ( maxRectangles ( L , B , l , b ) ) ;
function cone ( a ) { if ( a < 0 ) return - 1 ; var r = ( a * Math . sqrt ( 2 ) ) / 3 ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * Math . pow ( r , 2 ) * h ) ; return V ; } var a = 5 ; document . write ( cone ( a ) . toFixed ( 5 ) ) ;
function Area ( a ) { if ( a < 0 ) return - 1 ; let h = 1.268 * a ; let A = 0.70477 * Math . pow ( h , 2 ) ; return A ; } let a = 5 ; document . write ( Area ( a ) + " " ) ;
function Area ( r ) { if ( r < 0 ) return - 1 ; var x = ( 2 * r ) / ( Math . sqrt ( 5 ) ) ; var A = 0.70477 * ( Math . pow ( x , 2 ) ) ; return A ; } var r = 5 ; document . write ( Area ( r ) . toFixed ( 4 ) ) ;
function Area ( a ) { if ( a < 0 ) return - 1 ; let x = 0.464 * a ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; } let a = 5 ; document . write ( Area ( a ) . toFixed ( 5 ) ) ;
function areaSquare ( side , fold ) { var area = side * side ; return ( area * 1.0 ) / ( Math . pow ( 2 , fold ) ) ; } var side = 4 , fold = 2 ; document . write ( areaSquare ( side , fold ) ) ;
function ReuleauxArea ( r ) { if ( r < 0 ) return - 1 ; var A = 0.70477 * 2 * Math . pow ( r , 2 ) ; return A ; } var r = 6 ; document . write ( ReuleauxArea ( r ) ) ;
function cyl ( a ) { if ( a < 0 ) return - 1 ; var r = ( 2 * a * ( Math . sqrt ( 2 ) ) / 3 ) ; var h = ( 2 * a ) / 3 ; var V = ( 3.14 * ( Math . pow ( r , 2 ) * h ) ) ; return V ; } var a = 5 ; document . write ( cyl ( a ) . toFixed ( 5 ) ) ;
function Area ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; let x = ( l * b ) / ( l + b ) ; let A = 0.70477 * Math . pow ( x , 2 ) ; return A ; } let l = 5 , b = 12 , h = 13 ; document . write ( Area ( l , b , h ) . toFixed ( 5 ) ) ;
function squareSide ( a ) { if ( a < 0 ) return - 1 ; var x = ( 0.423 * a ) ; return x ; } var a = 8 ; document . write ( squareSide ( a ) ) ;
function isPossible ( x , y , z ) { let a = Math . round ( x * x + y * y + z * z ) ; if ( Math . ceil ( a ) == 1 && Math . floor ( a ) == 1 ) return true ; return false ; } let l = 0.70710678 , m = 0.5 , n = 0.5 ; if ( isPossible ( l , m , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function polydiagonal ( n , a ) { if ( a < 0 && n < 0 ) { return - 1 ; } return ( 2 * a * Math . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) ; } var a = 9 , n = 10 ; document . write ( polydiagonal ( n , a ) . toFixed ( 3 ) ) ;
function decdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.902 * a ; return d ; } var a = 9 ; document . write ( decdiagonal ( a ) ) ;
function heptdiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.802 * a ; return d ; } var a = 6 ; document . write ( heptdiagonal ( a ) . toFixed ( 5 ) ) ;
function hexDiagonal ( a ) { if ( a < 0 ) return - 1 ; var d = 1.73 * a ; return d ; } var a = 9 ; document . write ( hexDiagonal ( a ) ) ;
function ReuleauxArea ( a ) { if ( a < 0 ) return - 1 ; var A = 0.70477 * Math . pow ( a , 2 ) ; return A ; } var a = 6 ; document . write ( ReuleauxArea ( a ) ) ;
function squareArea ( a ) { if ( a < 0 ) return - 1 ; var area = ( Math . pow ( 1.268 , 2 ) * Math . pow ( a , 2 ) ) ; return area ; } var a = 6 ; document . write ( squareArea ( a ) . toFixed ( 5 ) ) ;
function CubeVolume ( d ) { let Volume ; Volume = ( Math . sqrt ( 3 ) * Math . pow ( d , 3 ) ) / 9 ; return Volume ; } let d = 5 ; document . write ( " " + CubeVolume ( d ) . toFixed ( 4 ) ) ;
function per ( a , b ) { return ( a + b ) ; } function area ( s ) { return ( s / 2 ) ; } var a = 7 , b = 8 , s = 10 ; document . write ( per ( a , b ) ) ; document . write ( area ( s ) ) ;
const PI = 3.14159265 ; function area_leaf ( a ) { return ( a * a * ( PI / 2 - 1 ) ) ; } let a = 7 ; document . write ( Math . round ( area_leaf ( a ) ) ) ;
const PI = 3.14159265 ; function length_rope ( r ) { return ( ( 2 * PI * r ) + 6 * r ) ; } let r = 7 ; document . write ( Math . ceil ( length_rope ( r ) ) ) ;
let PI = 3.14159265 ; function area_inscribed ( P , B , H ) { return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) ; } var P = 3 , B = 4 , H = 5 ; document . write ( area_inscribed ( P , B , H ) . toFixed ( 6 ) ) ;
let PI = 3.14159265 ; function area_cicumscribed ( c ) { return ( c * c * ( PI / 4 ) ) ; } var c = 8.0 ; document . write ( area_cicumscribed ( c ) . toFixed ( 6 ) ) ;
function cyl ( r , h ) { if ( r < 0 && h < 0 ) return - 1 ; var R = ( 2 * r ) / 3 ; var H = ( 2 * h ) / 3 ; var V = 3.14 * Math . pow ( R , 2 ) * H ; return V ; } var r = 4 , h = 8 ; document . write ( cyl ( r , h ) . toFixed ( 5 ) ) ;
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = Math . pow ( h , 3 ) ; return a ; } var h = 5 , r = 4 ; document . write ( cube ( h , r ) ) ;
function sph ( r , h ) { if ( r < 0 && h < 0 ) return - 1 ; var R = r ; return R ; } var r = 4 , h = 8 ; document . write ( sph ( r , h ) ) ;
function cyl ( R ) { if ( R < 0 ) return - 1 ; var V = ( ( 2 * 3.14 * Math . pow ( R , 3 ) ) / ( 3 * Math . sqrt ( 3 ) ) ) ; return V ; } var R = 4 ; document . write ( cyl ( R ) . toFixed ( 4 ) ) ;
function rod ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var l = ( Math . sqrt ( Math . pow ( h , 2 ) + 4 * Math . pow ( r , 2 ) ) ) ; return l ; } var h = 4 ; var r = 1.5 ; document . write ( rod ( h , r ) ) ;
function cube ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var a = ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ; return a ; } var h = 5 , r = 6 ; document . write ( cube ( h , r ) . toFixed ( 5 ) ) ;
function coner ( R ) { if ( R < 0 ) return - 1 ; var r = ( 2 * Math . sqrt ( 2 ) * R ) / 3 ; return r ; } function coneh ( R ) { if ( R < 0 ) return - 1 ; var h = ( 4 * R ) / 3 ; return h ; } var R = 10 ; document . write ( " " + coner ( R ) . toFixed ( 5 ) + " " + " " + coneh ( R ) . toFixed ( 5 ) ) ;
function coneRadius ( a ) { if ( a < 0 ) return - 1 ; var r = ( a / Math . sqrt ( 2 ) ) ; return r ; } function coneHeight ( a ) { if ( a < 0 ) return - 1 ; var h = a ; return h ; } var a = 6 ; document . write ( " " + coneRadius ( a ) . toFixed ( 5 ) + " " + " " + coneHeight ( a ) ) ;
function largestCube ( r ) { if ( r < 0 ) return - 1 ; var a = ( 2 * r ) / Math . sqrt ( 3 ) ; return a ; } var r = 5 ; document . write ( largestCube ( r ) . toFixed ( 5 ) ) ;
function sphere ( a ) { if ( a < 0 ) return - 1 ; var r = a / 2 ; return r ; } var a = 5 ; document . write ( sphere ( a ) ) ;
function numberOfCuts ( M , N ) { var result = 0 ; result = ( M - 1 ) * ( N - 1 ) ; return result ; } var M = 4 , N = 4 ; var Cuts = numberOfCuts ( M , N ) ; document . write ( " " + Cuts ) ;
function maxVol ( P , A ) { let l = ( P - Math . sqrt ( P * P - 24 * A ) ) / 12 ; let V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) ; return V ; } let P = 20 , A = 16 ; document . write ( maxVol ( P , A ) . toFixed ( 5 ) ) ;
function rhombusAreaPeri ( d1 , d2 ) { let area , perimeter ; area = Math . floor ( ( d1 * d2 ) / 2 ) ; perimeter = Math . floor ( 2 * Math . sqrt ( Math . pow ( d1 , 2 ) + Math . pow ( d2 , 2 ) ) ) ; document . write ( " " + d1 + " " + d2 + " " + area + " " + " " ) ; document . write ( " " + d1 + " " + d2 + " " + perimeter + " " + " " ) ; } let d1 = 2 , d2 = 4 ; rhombusAreaPeri ( d1 , d2 ) ;
function area ( r ) { if ( r < 0 ) return - 1 ; var area = ( 5 * Math . pow ( r , 2 ) * ( 3 - Math . sqrt ( 5 ) ) * ( Math . sqrt ( 5 ) + ( ( 2 * Math . sqrt ( 5 ) ) ) ) / 4 ) ; return area ; } var r = 8 ; document . write ( area ( r ) . toFixed ( 3 ) ) ;
function maxArea ( perimeter ) { let length = Math . ceil ( perimeter / 4 ) ; let breadth = Math . floor ( perimeter / 4 ) ; return length * breadth ; } let n = 38 ; document . write ( " " + maxArea ( n ) ) ;
function foot ( a , b , c , d , x1 , y1 , z1 ) { var k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; var x2 = a * k + x1 ; var y2 = b * k + y1 ; var z2 = c * k + z1 ; document . write ( " " + x2 . toFixed ( 1 ) + " " ) ; document . write ( " " + y2 . toFixed ( 1 ) + " " ) ; document . write ( " " + z2 . toFixed ( 1 ) + " " ) ; } var a = 1 ; var b = - 2 ; var c = 0 ; var d = 0 ; var x1 = - 1 ; var y1 = 3 ; var z1 = 4 ; foot ( a , b , c , d , x1 , y1 , z1 ) ;
function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } function countRectangles ( l , w ) { let squareSide = __gcd ( l , w ) ; return parseInt ( ( l * w ) / ( squareSide * squareSide ) ) ; } let l = 4 , w = 6 ; document . write ( countRectangles ( l , w ) ) ;
function circle_equation ( x1 , y1 , r ) { let a = - 2 * x1 ; let b = - 2 * y1 ; let c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; document . write ( " " + a + " " ) ; document . write ( " " + b + " " ) ; document . write ( c + " " ) ; } let x1 = 2 ; let y1 = - 3 ; let r = 8 ; circle_equation ( x1 , y1 , r ) ;
function area ( r ) { return ( ( 0.5 ) * ( 3.14 ) * ( r * r ) ) ; } function perimeter ( r ) { return ( ( 3.14 ) * ( r ) ) ; } var r = 10 ; document . write ( " " + area ( r ) . toFixed ( 6 ) + " " ) ; document . write ( " " + perimeter ( r ) . toFixed ( 6 ) + " " ) ;
function checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var resx = x1 + x2 + x3 ; var resy = y1 + y2 + y3 ; var resz = z1 + z2 + z3 ; if ( resx == 0 & resy == 0 & resz == 0 ) return true ; else return false ; } var x1 = - 2 , y1 = - 7 , z1 = - 9 , x2 = 5 , y2 = - 14 , z2 = 14 , x3 = - 3 , y3 = 21 , z3 = - 5 ; if ( checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findTangent ( A , x , y ) { var dif = A - x * 2 ; if ( y == ( 2 * x - x * x ) ) { if ( dif < 0 ) document . write ( " " + dif + " " + ( x * dif + y ) + " " ) ; else if ( dif > 0 ) document . write ( " " + dif + " " + - x * dif + y + " " ) ; else document . write ( " " + " " ) ; } } var A = 2 , x = 2 , y = 0 ; findTangent ( A , x , y ) ;
function hexadiagonal ( a ) { if ( a < 0 ) return - 1 ; return 2 * a ; } var a = 4 ; document . write ( hexadiagonal ( a ) ) ;
function octaside ( a ) { if ( a < 0 ) return - 1 ; var s = a / ( Math . sqrt ( 2 ) + 1 ) ; return s ; } var a = 4 ; document . write ( octaside ( a ) . toFixed ( 5 ) ) ;
function Arrive ( a , b , n ) { if ( n >= Math . abs ( a ) + Math . abs ( b ) && ( n - ( Math . abs ( a ) + Math . abs ( b ) ) ) % 2 == 0 ) return true ; return false ; } var a = 5 , b = 5 , n = 11 ; if ( Arrive ( a , b , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function Move ( a , x , b ) { if ( ( ( ( b - a ) % x == 0 ) || ( ( b - a - 1 ) % x == 0 ) && a + 1 != b ) && b >= a ) return true ; return false ; } let a = 3 , x = 2 , b = 7 ; if ( Move ( a , x , b ) ) document . write ( " " ) ; else document . write ( " " ) ;
function area ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var A = a * b ; return A ; } var a = 5 , b = 2 ; document . write ( area ( a , b ) ) ;
function findRadiusOfcircumcircle ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var radius = Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; } var l = 4 , b = 3 ; document . write ( findRadiusOfcircumcircle ( l , b ) . toFixed ( 6 ) ) ;
function circlearea ( a , b , c ) { if ( a < 0 b < 0 c < 0 ) return - 1 ; var p = ( a + b + c ) / 2 ; var At = Math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; var A = 3.14 * Math . pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) ; return A ; } var a = 4 , b = 5 , c = 3 ; document . write ( circlearea ( a , b , c ) ) ;
function altitude ( a , b ) { return Math . sqrt ( Math . pow ( a , 2 ) - ( Math . pow ( b , 2 ) / 4 ) ) ; } function area ( b , h ) { return ( 1 * b * h ) / 2 ; } let a = 2 , b = 3 ; let h = altitude ( a , b ) ; document . write ( " " + h . toFixed ( 2 ) + " " ) ; document . write ( " " + area ( b , h ) . toFixed ( 2 ) ) ;
function surfaceArea ( b , s ) { return 2 * b * s + parseInt ( Math . pow ( b , 2 ) ) ; } var b = 3 , s = 4 ; document . write ( surfaceArea ( b , s ) ) ;
function trianglearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; let area = ( l * b ) / 2 ; return area ; } let l = 5 , b = 4 ; document . write ( trianglearea ( l , b ) ) ;
function halfsquare ( n , x , y ) { let half = n / 2 ; if ( ( half == x half == x - 1 ) && ( half == y half == y - 1 ) ) document . write ( " " ) ; else document . write ( " " ) ; } let n = 100 ; let x = 51 , y = 100 ; halfsquare ( n , x , y ) ;
function _check ( a , b , p , q ) { var d = p * p + q * q ; if ( d == 0 ) return a == 0 && b == 0 ; else return ( a * p + b * q ) % d == 0 && ( b * p - a * q ) % d == 0 ; } function check ( a , b , x , y , p , q ) { if ( _check ( a - x , b - y , p , q ) || _check ( a + x , b + y , p , q ) || _check ( a - y , b + x , p , q ) || _check ( a + y , b - x , p , q ) ) return true ; else return false ; } var a = - 4 , b = - 2 ; var x = 0 , y = 0 ; var p = - 2 , q = - 1 ; if ( check ( a , b , x , y , p , q ) ) document . write ( " " ) ; else document . write ( " " ) ;
function trianglearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / ( 4 * b ) ; return area ; } var a = 4 , b = 2 ; document . write ( trianglearea ( a , b ) . toFixed ( 4 ) ) ;
function squarearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var area = 4 * ( ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) / ( Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) ) ; return area ; } var a = 4 , b = 2 ; document . write ( squarearea ( a , b ) ) ;
function trianglearea ( r ) { if ( r < 0 ) return - 1 ; return r * r ; } var r = 5 ; document . write ( trianglearea ( r ) ) ;
function squarearea ( r ) { if ( r < 0 ) return - 1 ; var a = 4 * ( Math . pow ( r , 2 ) / 5 ) ; return a ; } var r = 5 ; document . write ( squarearea ( r ) ) ;
function rectanglearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; return 2 * a * b ; } var a = 10 , b = 8 ; document . write ( rectanglearea ( a , b ) ) ;
function squareArea ( l , b , h ) { if ( l < 0 b < 0 h < 0 ) return - 1 ; var a = ( l * b ) / ( l + b ) ; return a * a ; } var l = 5 , b = 12 , h = 13 ; document . write ( squareArea ( l , b , h ) . toFixed ( 4 ) ) ;
var MAX = 50 function solveQuery ( n , q , qi , qj ) { var arr = Array ( MAX ) ; for ( var i = 0 ; i <= n ; i ++ ) arr [ i ] = 0 ; for ( var k = 0 ; k < q ; k ++ ) { var flag = 0 ; if ( qj [ k ] < qi [ k ] ) { var temp = qi [ k ] ; qi [ k ] = qj [ k ] ; qj [ k ] = temp ; } if ( arr [ qi [ k ] ] != 0 arr [ qj [ k ] ] != 0 ) flag = 1 ; else if ( qi [ k ] == qj [ k ] ) flag = 1 ; else { for ( var i = 1 ; i < qi [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] < qj [ k ] && qi [ k ] < arr [ i ] ) { flag = 1 ; break ; } } if ( flag == 0 ) { for ( var i = qi [ k ] + 1 ; i < qj [ k ] ; i ++ ) { if ( arr [ i ] != 0 && arr [ i ] > qj [ k ] ) { flag = 1 ; break ; } } } } if ( flag == 0 ) { document . write ( " " ) ; arr [ qi [ k ] ] = qj [ k ] ; arr [ qj [ k ] ] = qi [ k ] ; } else document . write ( " " ) ; } } var n = 10 ; var q = 7 ; var qi = [ 1 , 2 , 2 , 2 , 9 , 10 , 8 ] ; var qj = [ 5 , 7 , 3 , 4 , 9 , 9 , 6 ] ; solveQuery ( n , q , qi , qj ) ;
function squares ( l , b , a ) { return parseInt ( Math . ceil ( l / a ) * Math . ceil ( b / a ) ) ; } var l = 11 , b = 23 , a = 14 ; document . write ( squares ( l , b , a ) ) ;
function gcd ( a , b ) { if ( a == 0 b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } function squarearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; var n = ( l * b ) / gcd ( l , b ) ; return n * n ; } var l = 6 , b = 4 ; document . write ( squarearea ( l , b ) ) ;
function angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) { let num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) ; let den = Math . sqrt ( Math . pow ( ( x2 - x1 ) , 2 ) + Math . pow ( ( y2 - y1 ) , 2 ) + Math . pow ( ( z2 - z1 ) , 2 ) ) * Math . sqrt ( Math . pow ( ( x3 - x1 ) , 2 ) + Math . pow ( ( y3 - y1 ) , 2 ) + Math . pow ( ( z3 - z1 ) , 2 ) ) ; let angle = Math . acos ( num / den ) * ( 180.0 / 3.141592653589793238463 ) ; return angle ; } let x1 = - 1 ; let y1 = 3 ; let z1 = 2 ; let x2 = 2 ; let y2 = 3 ; let z2 = 5 ; let x3 = 3 ; let y3 = 5 ; let z3 = - 2 ; let angle_A = angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) ; let angle_B = angle_triangle ( x2 , x3 , x1 , y2 , y3 , y1 , z2 , z3 , z1 ) ; let angle_C = angle_triangle ( x3 , x2 , x1 , y3 , y2 , y1 , z3 , z2 , z1 ) ; document . write ( " " ) ; document . write ( " " + angle_A + " " ) ; document . write ( " " + angle_B . toFixed ( 3 ) + " " ) ; document . write ( " " + angle_C . toFixed ( 3 ) + " " ) ;
function solve ( M , N , s ) { if ( N % s == 0 ) { N = N / s ; } else { N = ( N / s ) + 1 ; } if ( M % s == 0 ) { M = M / s ; } else { M = ( M / s ) + 1 ; } return parseInt ( M * N ) ; } var N = 12 , M = 13 , s = 4 ; document . write ( solve ( M , N , s ) ) ;
function solve ( M , N , s ) { let ans = Math . floor ( ( ( Math . ceil ( M / s ) ) * ( Math . ceil ( N / s ) ) ) ) ; return ans ; } let N = 12 , M = 13 , s = 4 ; document . write ( solve ( M , N , s ) ) ;
function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; document . write ( " " + a + " " + b + " " + c + " " + d + " " ) ; } var x1 = - 1 ; var y1 = 2 ; var z1 = 1 ; var x2 = 0 ; var y2 = - 3 ; var z2 = 2 ; var x3 = 1 ; var y3 = 1 ; var z3 = - 4 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ;
function shortest_distance ( x1 , y1 , a , b , c ) { var d = Math . abs ( ( ( a * x1 + b * y1 + c ) ) / ( Math . sqrt ( a * a + b * b ) ) ) ; document . write ( " " + " " + d . toFixed ( 11 ) ) ; return ; } var x1 = 5 ; var y1 = 6 ; var a = - 2 ; var b = 3 ; var c = 4 ; shortest_distance ( x1 , y1 , a , b , c ) ;
function octant ( x , y , z ) { if ( x >= 0 && y >= 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y >= 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y < 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y < 0 && z >= 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y >= 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y >= 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x < 0 && y < 0 && z < 0 ) document . write ( " " + " " ) ; else if ( x >= 0 && y < 0 && z < 0 ) document . write ( " " + " " ) ; } let x = 2 , y = 3 , z = 4 ; octant ( x , y , z ) ; x = - 4 , y = 2 , z = - 8 ; octant ( x , y , z ) ; x = - 6 , y = - 2 , z = 8 ; octant ( x , y , z ) ;
function countNumberOfTriangles ( n ) { return n * ( n - 1 ) * ( n - 2 ) / 6 ; } var n = 4 ; document . write ( countNumberOfTriangles ( n ) ) ;
function centeredTridecagonalNum ( n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; } var n = 3 ; document . write ( centeredTridecagonalNum ( n ) + " " ) ; n = 10 ; document . write ( centeredTridecagonalNum ( n ) ) ;
function pentagon_pyramidal ( n ) { var sum = 0 ; for ( i = 1 ; i <= n ; i ++ ) { var p = ( 3 * i * i - i ) / 2 ; sum = sum + p ; } return sum ; } var n = 4 ; document . write ( pentagon_pyramidal ( n ) ) ;
function pentagon_pyramidal ( n ) { return n * n * ( n + 1 ) / 2 ; } var n = 4 ; document . write ( pentagon_pyramidal ( n ) ) ;
function checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) { return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) ; } a1 = 2 , b1 = - 3 , c1 = 5 ; a2 = 3 , b2 = 4 , c2 = - 7 ; a3 = 9 , b3 = - 5 , c3 = 8 ; ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ? ( document . write ( " " ) ) : ( document . write ( " " ) ) ) ;
function center_octadecagon_num ( n ) { return 9 * n * n - 9 * n + 1 ; } var n = 3 ; document . write ( n + " " + " " ) ; document . write ( center_octadecagon_num ( n ) + " " ) ; n = 13 ; document . write ( n + " " + " " ) ; document . write ( center_octadecagon_num ( n ) ) ;
function centereddecagonalnum ( n ) { return ( 5 * n * n + 5 * n + 1 ) ; } var n = 5 ; document . write ( n + " " + " " ) ; document . write ( centereddecagonalnum ( n ) + " " ) ; n = 9 ; document . write ( n + " " + " " ) ; document . write ( centereddecagonalnum ( n ) ) ;
function factorial ( a , b ) { var res = 1 ; for ( var i = 1 ; i <= ( a + b ) ; i ++ ) res = res * i ; for ( var i = 1 ; i <= a ; i ++ ) res = res / i ; for ( var i = 1 ; i <= b ; i ++ ) res = res / i ; return res ; } function Ksmallest ( x , y , k ) { if ( x == 0 && y == 0 ) return ; else if ( x == 0 ) { y -- ; document . write ( " " ) ; Ksmallest ( x , y , k ) ; } else if ( y == 0 ) { x -- ; document . write ( " " ) ; Ksmallest ( x , y , k ) ; } else { if ( factorial ( x - 1 , y ) > k ) { document . write ( " " ) ; Ksmallest ( x - 1 , y , k ) ; } else { document . write ( " " ) ; Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) ; } } } var x = 2 , y = 2 , k = 2 ; Ksmallest ( x , y , k ) ;
function centered_pentagonal_Num ( n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; } var n = 7 ; document . write ( n + " " + " " ) ; document . write ( centered_pentagonal_Num ( n ) ) ;
function pivotDis ( x0 , y0 , x1 , y1 ) { return Math . sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) ; } function minDis ( D , r1 , r2 ) { return Math . max ( ( D - r1 - r2 ) , 0 ) ; } function maxDis ( D , r1 , r2 ) { return D + r1 + r2 ; } let x0 = 0 , y0 = 0 , x1 = 8 , y1 = 0 , r1 = 4 , r2 = 5 ; let D = pivotDis ( x0 , y0 , x1 , y1 ) ; document . write ( " " + maxDis ( D , r1 , r2 ) + " " ) ; document . write ( " " + minDis ( D , r1 , r2 ) ) ;
function maximumValueOfF ( R ) { return 4 * R * R + 0.25 ; } var R = 3 ; document . write ( maximumValueOfF ( R ) ) ;
function otherEndPoint ( x1 , y1 , m1 , m2 ) { let x2 = 2 * m1 - x1 ; let y2 = 2 * m2 - y1 ; document . write ( " " + x2 + " " + " " + y2 ) ; } let x1 = - 4 , y1 = - 1 , m1 = 3 , m2 = 5 ; otherEndPoint ( x1 , y1 , m1 , m2 ) ;
function printRect ( X , Y , n ) { var Xmax = X . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var Xmin = X . reduce ( ( a , b ) => Math . min ( a , b ) ) ; var Ymax = Y . reduce ( ( a , b ) => Math . max ( a , b ) ) ; var Ymin = Y . reduce ( ( a , b ) => Math . min ( a , b ) ) ; document . write ( " " + Xmin + " " + Ymin + " " + " " ) ; document . write ( " " + Xmin + " " + Ymax + " " + " " ) ; document . write ( " " + Xmax + " " + Ymax + " " + " " ) ; document . write ( " " + Xmax + " " + Ymin + " " + " " ) ; } var X = [ 4 , 3 , 6 , 1 , - 1 , 12 ] ; var Y = [ 4 , 1 , 10 , 3 , 7 , - 1 ] ; var n = X . length ; printRect ( X , Y , n ) ;
function checkOrigin ( x1 , y1 , x2 , y2 ) { return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) ; } if ( checkOrigin ( 1 , 28 , 2 , 56 ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function isBetween ( a , b , c ) { return ( Math . min ( a , b ) <= c && c <= Math . max ( a , b ) ) ; } function canJoin ( x , y , i , j , k ) { return ( x [ k ] == x [ i ] x [ k ] == x [ j ] ) && isBetween ( y [ i ] , y [ j ] , y [ k ] ) || ( y [ k ] == y [ i ] y [ k ] == y [ j ] ) && isBetween ( x [ i ] , x [ j ] , x [ k ] ) ; } function countLineSegments ( x , y ) { if ( ( x [ 0 ] == x [ 1 ] && x [ 1 ] == x [ 2 ] ) || ( y [ 0 ] == y [ 1 ] && y [ 1 ] == y [ 2 ] ) ) return 1 ; else if ( canJoin ( x , y , 0 , 1 , 2 ) || canJoin ( x , y , 0 , 2 , 1 ) || canJoin ( x , y , 1 , 2 , 0 ) ) return 2 ; else return 3 ; } let x = [ ] , y = [ ] ; x [ 0 ] = - 1 ; y [ 0 ] = - 1 ; x [ 1 ] = - 1 ; y [ 1 ] = 3 ; x [ 2 ] = 4 ; y [ 2 ] = 3 ; document . write ( countLineSegments ( x , y ) ) ;
function pythagorean_quadruple ( a , b , c , d ) { let sum = a * a + b * b + c * c ; if ( d * d == sum ) return true ; else return false ; } let a = 1 , b = 2 , c = 2 , d = 3 ; if ( pythagorean_quadruple ( a , b , c , d ) ) document . write ( " " ) ; else document . write ( " " ) ;
function Circumference ( a ) { return 4 * a ; } let a = 5 ; document . write ( " " + " " + Circumference ( a ) ) ;
function maxArea ( a , b , c , d ) { let semiperimeter = ( a + b + c + d ) / 2 ; return Math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) ; } let a = 1 , b = 2 , c = 1 , d = 2 ; document . write ( maxArea ( a , b , c , d ) ) ;
function minRadius ( k , x , y , n ) { let dis = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] ; dis . sort ( ) ; return dis [ k - 1 ] ; } let k = 3 ; let x = [ 1 , - 1 , 1 ] ; let y = [ 1 , - 1 , - 1 ] ; let n = x . length ; document . write ( minRadius ( k , x , y , n ) ) ;
function areaRectangle ( a , b ) { let area = a * b ; return area ; } function perimeterRectangle ( a , b ) { let perimeter = 2 * ( a + b ) ; return perimeter ; } let a = 5 ; let b = 6 ; document . write ( " " + areaRectangle ( a , b ) + " " ) ; document . write ( " " + perimeterRectangle ( a , b ) ) ;
function areaSquare ( side ) { let area = side * side ; return area ; } let side = 4 ; document . write ( areaSquare ( side ) ) ;
function minPerimeter ( n ) { let l = Math . sqrt ( n ) ; let sq = l * l ; if ( sq == n ) return l * 4 ; else { let row = n / l ; let perimeter = 2 * ( l + row ) ; if ( n % l != 0 ) perimeter += 2 ; return perimeter ; } } let n = 10 ; document . write ( Math . floor ( minPerimeter ( n ) ) )
function possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) { var dis1 = Math . pow ( b1 - a1 , 2 ) + Math . pow ( b2 - a2 , 2 ) ; var dis2 = Math . pow ( c1 - b1 , 2 ) + Math . pow ( c2 - b2 , 2 ) ; if ( dis1 != dis2 ) document . write ( " " ) ; else if ( b1 == ( ( a1 + c1 ) / 2.0 ) && b2 == ( ( a2 + c2 ) / 2.0 ) ) document . write ( " " ) ; else document . write ( " " ) ; } var a1 = 1 , a2 = 0 , b1 = 2 , b2 = 0 , c1 = 3 , c2 = 0 ; possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) ;
function circle ( x1 , y1 , x2 , y2 , r1 , r2 ) { let distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; let radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; if ( distSq == radSumSq ) return 1 ; else if ( distSq > radSumSq ) return - 1 ; else return 0 ; } let x1 = - 10 , y1 = 8 ; let x2 = 14 , y2 = - 24 ; let r1 = 30 , r2 = 10 ; let t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; if ( t == 1 ) document . write ( " " + " " ) ; else if ( t < 0 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function countObtuseAngles ( a , b , k ) { var c1 = ( b - a ) - 1 ; var c2 = ( k - b ) + ( a - 1 ) ; if ( c1 == c2 ) return 0 ; return Math . min ( c1 , c2 ) ; } var k = 6 , a = 1 , b = 3 ; document . write ( countObtuseAngles ( a , b , k ) ) ;
function findTriangle ( a , n ) { let b = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { b [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) b [ i ] = a [ i ] * a [ i ] ; a . sort ( function ( i , j ) { return i - j ; } ) ; b . sort ( function ( i , j ) { return i - j ; } ) ; let x = 0 , y = 0 , z = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let p = i + 1 ; let q = i + 1 ; for ( let j = i + 1 ; j < n ; j ++ ) { while ( p < n - 1 && b [ i ] + b [ j ] >= b [ p + 1 ] ) p ++ ; q = Math . max ( q , p ) ; while ( q < n - 1 && a [ i ] + a [ j ] > a [ q + 1 ] ) q ++ ; if ( b [ i ] + b [ j ] == b [ p ] ) { x += Math . max ( p - j - 1 , 0 ) ; y ++ ; z += q - p ; } else { x += Math . max ( p - j , 0 ) ; z += q - p ; } } } document . write ( " " + x + " " ) ; document . write ( " " + y + " " ) ; document . write ( " " + z + " " ) ; } let arr = [ 2 , 3 , 9 , 10 , 12 , 15 ] ; let n = arr . length ; findTriangle ( arr , n ) ;
function polygonArea ( X , Y , n ) { let area = 0.0 ; let j = n - 1 ; for ( let i = 0 ; i < n ; i ++ ) { area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) ; j = i ; } return Math . abs ( area / 2.0 ) ; } let X = [ 0 , 2 , 4 ] ; let Y = [ 1 , 3 , 7 ] ; let n = 3 ; document . write ( polygonArea ( X , Y , n ) ) ;
function last_digit ( X , Y ) { document . write ( X % Y ) ; } var X = 55 , Y = 3 ; last_digit ( X , Y ) ;
function printRoots ( a , b , c ) { document . write ( 1 + " " + c / ( a * 1.0 ) ) ; } var a = 2 ; var b = 3 ; var c = - 5 ; printRoots ( a , b , c ) ;
const MAX = 130 ; function validQuadruple ( arr , n ) { if ( n >= MAX ) return true ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) for ( let k = j + 1 ; k < n ; k ++ ) for ( let l = k + 1 ; l < n ; l ++ ) { if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) { return true ; } } return false ; } let arr = [ 1 , 0 , 2 , 3 , 7 ] ; let n = arr . length ; if ( validQuadruple ( arr , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function solve ( n , k ) { if ( n >= ( k * ( k + 1 ) ) / 2 ) { return true ; } return false ; } var n = 12 , k = 4 ; if ( solve ( n , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; } } return ans ; } let arr = [ 4 , 7 , 10 ] ; let n = arr . length ; let k = 2 ; document . write ( closetAND ( arr , n , k ) ) ;
function Rate ( N1 , N2 ) { var rate = ( N2 - N1 ) * 100 / N1 ; return parseInt ( rate ) ; } var N1 = 100 , N2 = 120 ; document . write ( Rate ( N1 , N2 ) + " " ) ;
function getPrime ( arr , n ) { let max_val = Math . max ( ... arr ) ; let prime = new Array ( max_val + 1 ) . fill ( true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } let maximum = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) maximum = Math . max ( maximum , arr [ i ] ) ; } return maximum ; } let arr = [ 2 , 10 , 15 , 7 , 6 , 8 , 13 ] ; let n = arr . length ; document . write ( getPrime ( arr , n ) ) ;
function getMinNum ( N ) { var lcm = 1 ; for ( var i = 2 ; i <= N ; i ++ ) lcm = ( ( i * lcm ) / ( __gcd ( i , lcm ) ) ) ; return ( lcm + 1 ) ; } function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } var N = 5 ; document . write ( getMinNum ( N ) ) ;
function maxEdges ( N ) { var edges = 0 ; edges = Math . floor ( ( N * N ) / 4 ) ; return edges ; } var N = 5 ; document . write ( maxEdges ( N ) ) ;
function Permutation ( n , k ) { let p = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) p [ i ] = i ; for ( let i = 1 ; i < n - k ; i ++ ) p [ i + 1 ] = i ; p [ 1 ] = n - k ; for ( let i = 1 ; i <= n ; i ++ ) document . write ( p [ i ] + " " ) ; } let n = 5 , k = 2 ; Permutation ( n , k ) ;
function validPosition ( arr , N , K ) { var count = 0 , sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { sum += arr [ i ] ; } for ( var i = 0 ; i < N ; i ++ ) { if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) count ++ ; } return count ; } var arr = [ 2 , 1 , 6 , 7 ] , K = 4 ; var N = arr . length ; document . write ( validPosition ( arr , N , K ) ) ;
function maxBitElement ( arr , n ) { let num = 0 , max = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { let cnt = BitCount ( arr [ i ] ) ; if ( cnt > max ) { max = cnt ; num = arr [ i ] ; } } return num ; } function BitCount ( n ) { let count = 0 ; while ( n != 0 ) { count ++ ; n &= ( n - 1 ) ; } return count ; } let arr = [ 3 , 2 , 4 , 7 , 1 , 10 , 5 , 8 , 9 , 6 ] ; let n = arr . length ; document . write ( maxBitElement ( arr , n ) ) ;
function smallestSum ( n ) { if ( n == 1 ) return 0 ; return ( 2 * Math . pow ( 10 , n - 1 ) ) ; } function largestSum ( n ) { return ( 2 * ( Math . pow ( 10 , n ) - 1 ) ) ; } var n = 4 ; document . write ( " " + largestSum ( n ) + " " ) ; document . write ( " " + smallestSum ( n ) ) ;
function count_pairs ( a , b , n , m ) { let odd1 = 0 , even1 = 0 ; let odd2 = 0 , even2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 ) odd1 ++ ; else even1 ++ ; } for ( let i = 0 ; i < m ; i ++ ) { if ( b [ i ] % 2 ) odd2 ++ ; else even2 ++ ; } let pairs = Math . min ( odd1 , even2 ) + Math . min ( odd2 , even1 ) ; return pairs ; } let a = [ 9 , 14 , 6 , 2 , 11 ] ; let b = [ 8 , 4 , 7 , 20 ] ; let n = a . length ; let m = b . length ; document . write ( count_pairs ( a , b , n , m ) ) ;
function find_leftmost_unsetbit ( n ) { let ind = - 1 ; let i = 1 ; while ( n ) { if ( ! ( n & 1 ) ) ind = i ; i ++ ; n >>= 1 ; } return ind ; } function perform_steps ( n ) { let left = find_leftmost_unsetbit ( n ) ; if ( left == - 1 ) { document . write ( " " ) ; return ; } let step = 1 ; while ( find_leftmost_unsetbit ( n ) != - 1 ) { if ( step % 2 == 0 ) { n += 1 ; document . write ( " " + step + " " ) ; } else { let m = find_leftmost_unsetbit ( n ) ; let num = Math . pow ( 2 , m ) - 1 ; n = n ^ num ; document . write ( " " + step + " " + num + " " ) ; } step += 1 ; } } let n = 39 ; perform_steps ( n ) ;
function vertices ( N , A , B ) { var position = 0 ; var minisum = Number . MAX_VALUE ; var sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( i == A i == B ) continue ; else { var x = Math . abs ( i - A ) ; var y = Math . abs ( i - B ) ; sum = x + y ; if ( sum < minisum ) { minisum = sum ; position = i ; } } } return position ; } var N = 3 , A = 1 , B = 2 ; document . write ( " " + vertices ( N , A , B ) ) ;
function factorial ( n ) { let f = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { f *= i ; } return f ; } function sumFactorial ( arr , n ) { let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s += factorial ( arr [ i ] ) ; } return s ; } let arr = [ 7 , 3 , 5 , 4 , 8 ] ; let n = arr . length ; document . write ( sumFactorial ( arr , n ) ) ;
function highestPower ( str , len ) { let ans = 0 ; for ( let i = len - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) ans ++ ; else break ; } return ans ; } let str = " " ; let len = str . length ; document . write ( highestPower ( str , len ) ) ;
var mod = parseInt ( 1e4 + 7 ) ; function factorial ( n , p ) { for ( var i = 2 ; i <= n ; i ++ ) res = ( res * i ) % p ; return res ; } function power ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function modInverse ( n , p ) { return power ( n , p - 2 , p ) ; } function nCrModP ( n , r , p ) { if ( r == 0 ) return 1 ; var fac = Array . from ( { length : n + 1 } , ( _ , i ) => 0 ) ; ; fac [ 0 ] = 1 ; for ( var i = 1 ; i <= n ; i ++ ) fac [ i ] = fac [ i - 1 ] * i % p ; return ( fac [ parseInt ( n ) ] * modInverse ( fac [ parseInt ( r ) ] , p ) % p * modInverse ( fac [ parseInt ( n ) - parseInt ( r ) ] , p ) % p ) % p ; } function countArrangements ( n , k , p ) { return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p ; } var N = 5 , K = 8 ; document . write ( countArrangements ( N , K , mod ) ) ;
function maxProd ( N ) { if ( N == 0 ) return 1 ; if ( N < 10 ) return N ; return Math . max ( maxProd ( parseInt ( N / 10 ) ) * ( N % 10 ) , maxProd ( parseInt ( N / 10 ) - 1 ) * 9 ) ; } let N = 390 ; document . write ( maxProd ( N ) ) ;
let N = 2 ; let M = 3 ; function check ( mat ) { let xorr = 0 ; for ( let i = 0 ; i < N ; i ++ ) { xorr ^= mat [ i ] [ 0 ] ; } if ( xorr != 0 ) return true ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 1 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] != mat [ i ] [ 0 ] ) return true ; } } return false ; } let mat = [ [ 7 , 7 , 7 ] , [ 10 , 10 , 7 ] ] ; if ( check ( mat ) ) document . write ( " " ) ; else document . write ( " " ) ;
function sumodd ( n ) { return ( n * n ) ; } function sumeven ( n ) { return ( n * ( n + 1 ) ) ; } function findSum ( num ) { let sumo = 0 ; let sume = 0 ; let x = 1 ; let cur = 0 ; let ans = 0 ; while ( num > 0 ) { let inc = Math . min ( x , num ) ; num -= inc ; if ( cur == 0 ) { ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) ; sumo += inc ; } else { ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) ; sume += inc ; } x *= 2 ; cur ^= 1 ; } return ans ; } let n = 4 ; document . write ( findSum ( n ) ) ;
function oddTriangularNumber ( N ) { return ( N * ( ( 2 * N ) - 1 ) ) ; } let N = 3 ; document . write ( oddTriangularNumber ( N ) ) ;
function idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) { if ( ( a1 / a2 == b1 / b2 ) && ( a1 / a2 == c1 / c2 ) && ( b1 / b2 == c1 / c2 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; } var a1 = - 2 , b1 = 4 , c1 = 3 , a2 = - 6 , b2 = 12 , c2 = 9 ; idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) ;
function line ( x0 , y0 ) { var c = parseInt ( 2 * y0 * x0 ) ; document . write ( y0 + " " + " " + x0 + " " + c ) ; } var x0 = 4 , y0 = 3 ; line ( x0 , y0 ) ;
let N = 3 ; let M = 7 ; function printOriginalMatrix ( a , b , mat ) { for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < M ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) document . write ( Math . min ( a [ i ] , b [ j ] ) + " " ) ; else document . write ( " " + " " ) ; } document . write ( " " ) ; } } let a = [ 2 , 1 , 3 ] ; let b = [ 2 , 3 , 0 , 0 , 2 , 0 , 1 ] ; let mat = [ [ 1 , 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] , [ 1 , 1 , 0 , 0 , 0 , 0 , 0 ] ] ; printOriginalMatrix ( a , b , mat ) ;
function percent ( n , x ) { let p = n * x ; p = Math . floor ( p / 100 ) ; return p ; } function getLoss ( price , quantity , X , n ) { let loss = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let originalPrice = price [ i ] ; let sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; let afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ; loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; } return loss ; } let price = [ 20 , 48 , 200 , 100 ] ; let quantity = [ 20 , 48 , 1 , 1 ] ; let X = [ 0 , 48 , 200 , 5 ] ; let n = X . length ; document . write ( getLoss ( price , quantity , X , n ) ) ;
function maxAbsDiff ( arr , n ) { let minEle = arr [ 0 ] ; let maxEle = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { minEle = Math . min ( minEle , arr [ i ] ) ; maxEle = Math . max ( maxEle , arr [ i ] ) ; } return ( maxEle - minEle ) ; } let arr = [ 2 , 1 , 5 , 3 ] ; let n = arr . length ; document . write ( maxAbsDiff ( arr , n ) ) ;
function maxSubArraySum ( a , size ) { let max_so_far = Number . MIN_VALUE , max_ending_here = 0 ; for ( let i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } function maximizeSum ( a , n ) { let cnt = 0 ; let mini = Number . MAX_VALUE ; let minSubarray = Number . MAX_VALUE ; let sum = maxSubArraySum ( a , n ) ; let max_so_far = Number . MIN_VALUE , max_ending_here = 0 ; for ( let i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; cnt ++ ; minSubarray = Math . min ( a [ i ] , minSubarray ) ; if ( sum == max_ending_here ) { if ( cnt == 1 ) mini = Math . min ( mini , 0 ) ; else mini = Math . min ( mini , minSubarray ) ; } if ( max_ending_here < 0 ) { max_ending_here = 0 ; cnt = 0 ; minSubarray = Integer . MAX_VALUE ; } } return sum - mini ; } let a = [ 1 , 2 , 3 , - 2 , 3 ] ; let n = a . length ; document . write ( maximizeSum ( a , n ) ) ;
function isOsiris ( n ) { let a = n % 10 ; let b = parseInt ( ( n / 10 ) % 10 ) ; let c = parseInt ( n / 100 ) ; let digit_sum = a + b + c ; if ( n == ( 2 * ( digit_sum ) * 11 ) ) { return true ; } return false ; } let n = 132 ; if ( isOsiris ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isDudeney ( n ) { let cube_rt = parseInt ( Math . round ( ( Math . pow ( n , 1.0 / 3.0 ) ) ) ) ; if ( cube_rt * cube_rt * cube_rt != n ) return false ; let dig_sum = 0 ; let temp = n ; while ( temp > 0 ) { let rem = temp % 10 ; dig_sum += rem ; temp = parseInt ( temp / 10 ) ; } if ( cube_rt != dig_sum ) return false ; return true ; } let n = 17576 ; if ( isDudeney ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countTriangles ( a , n ) { var cnt = 0 ; var pairs = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { pairs += a [ i ] / 2 ; if ( a [ i ] % 2 == 1 && pairs > 0 ) { cnt += 1 ; pairs -= 1 ; } } cnt += parseInt ( ( 2 * pairs ) / 3 ) ; return cnt ; } var a = [ 1 , 2 , 2 , 2 , 2 ] ; var n = a . length ; document . write ( countTriangles ( a , n ) ) ;
function smallestMultiple ( n ) { if ( n == 1 ) return 5 ; return Math . pow ( 10 , n - 1 ) ; } var n = 4 ; document . write ( smallestMultiple ( n ) ) ;
function getHCF ( x , y ) { var minimum = Math . min ( x , y ) ; if ( x % minimum == 0 && y % minimum == 0 ) return minimum ; for ( var i = minimum / 2 ; i >= 2 ; i -- ) { if ( x % i == 0 && y % i == 0 ) return i ; } return 1 ; } var x = 16 , y = 32 ; document . write ( getHCF ( x , y ) ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function isDivisible ( n ) { if ( isPrime ( n + 1 ) ) return false ; return true ; } var n = 6 ; if ( isDivisible ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
var R = 5 ; var C = 5 ; function findMaxCock ( ar ) { if ( R < 3 C < 3 ) return - 1 ; var max_sum = - 1000000000 ; for ( var i = 0 ; i < R - 2 ; i ++ ) { for ( var j = 0 ; j < C - 2 ; j ++ ) { var sum = ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ; max_sum = Math . max ( max_sum , sum ) ; } } return max_sum ; } ar = [ [ 0 , 3 , 0 , 6 , 0 ] , [ 0 , 1 , 1 , 0 , 0 ] , [ 1 , 1 , 1 , 0 , 0 ] , [ 0 , 0 , 2 , 0 , 1 ] , [ 0 , 2 , 0 , 1 , 3 ] ] ; document . write ( findMaxCock ( ar ) ) ;
function segments ( n , p , m ) { var c = new Map ( ) ; c . set ( 0 , 1 ) ; var hs = false ; var sum = 0 ; var ans = 0 ; var r ; for ( r = 0 ; r < n ; r ++ ) { if ( p [ r ] < m ) sum -- ; else if ( p [ r ] > m ) sum ++ ; if ( p [ r ] == m ) hs = true ; if ( hs ) { if ( c . has ( sum ) && c . has ( sum - 1 ) ) ans += c . get ( sum ) + c . get ( sum - 1 ) ; else if ( c . has ( sum ) ) ans += c . get ( sum ) ; else if ( c . has ( sum - 1 ) ) ans += c . get ( sum - 1 ) ; } else { if ( c . has ( sum ) ) c . set ( sum , c . get ( sum ) + 1 ) ; else c . set ( sum , 1 ) ; } } return ans ; } var a = [ 2 , 4 , 5 , 3 , 1 ] ; var n = a . length ; var m = 4 ; document . write ( segments ( n , a , m ) ) ;
function oddDays ( N ) { var hund1 = N / 100 ; var hund4 = N / 400 ; var leap = N >> 2 ; var ord = N - leap ; if ( hund1 > 0 ) { ord += hund1 ; leap -= hund1 ; } if ( hund4 > 0 ) { ord -= hund4 ; leap += hund4 ; } var days = ord + leap * 2 ; var odd = days % 7 ; return odd ; } var N = 100 ; document . write ( oddDays ( N ) . toFixed ( ) ) ;
function ellipsearea ( r ) { if ( r < 0 ) return - 1 ; var a = ( ( 3.14 * r * r ) / 4 ) ; return a ; } var r = 5 ; document . write ( ellipsearea ( r ) ) ;
function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = number * 2 + arr [ i ] ; if ( ( number % x == 0 ) ) count += 1 ; } return count ; } let arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] ; let n = arr . length ; let x = 2 ; document . write ( CntDivbyX ( arr , n , x ) ) ;
function countCon ( ar , n ) { let cnt = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) cnt ++ ; } return cnt ; } let ar = [ 1 , 2 , 2 , 3 , 4 , 4 , 5 , 5 , 5 , 5 ] ; let n = ar . length ; document . write ( countCon ( ar , n ) ) ;
function reduceFraction ( x , y ) { let d ; d = __gcd ( x , y ) ; x = parseInt ( x / d ) ; y = parseInt ( y / d ) ; document . write ( " " + x + " " + y ) ; } function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } let x = 16 ; let y = 10 ; reduceFraction ( x , y ) ;
function noOfYears ( t1 , n1 , t2 ) { var years = ( ( t2 - 1 ) * n1 / ( t1 - 1 ) ) ; return years ; } var T1 = 3 , N1 = 5 , T2 = 6 ; document . write ( noOfYears ( T1 , N1 , T2 ) ) ;
function isPossible ( n ) { var fac = new Array ( 10 ) ; fac [ 0 ] = fac [ 1 ] = 1 ; for ( var i = 2 ; i < 10 ; i ++ ) fac [ i ] = fac [ i - 1 ] * i ; var sum = 0 ; var x = n ; while ( x != 0 ) { sum += fac [ x % 10 ] ; x = parseInt ( x / 10 ) ; } if ( sum % n == 0 ) return true ; return false ; } var n = 19 ; if ( isPossible ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findSubsequence ( arr , n , k ) { let M = new Map ( ) ; for ( let i = 0 ; i < n ; ++ i ) { if ( M . has ( arr [ i ] ) ) { M . set ( arr [ i ] , M . get ( arr [ i ] ) + 1 ) } else { M . set ( arr [ i ] , 1 ) } } let numCount = new Array ( k + 1 ) ; for ( let i = 0 ; i <= k ; ++ i ) numCount [ i ] = 0 ; for ( let p of M ) { if ( p [ 0 ] <= k ) { for ( let i = 1 ; ; ++ i ) { if ( p [ 0 ] * i > k ) break ; numCount [ p [ 0 ] * i ] += p [ 1 ] ; } } else break ; } let lcm = 0 , length = 0 ; for ( let i = 1 ; i <= k ; ++ i ) { if ( numCount [ i ] > length ) { length = numCount [ i ] ; lcm = i ; } } if ( lcm == 0 ) document . write ( - 1 + " " ) ; else { document . write ( " " + lcm + " " + length + " " ) ; document . write ( " " ) ; for ( let i = 0 ; i < n ; ++ i ) if ( lcm % arr [ i ] == 0 ) document . write ( i + " " ) ; } } let k = 14 ; let arr = [ 2 , 3 , 4 , 5 ] ; let n = arr . length ; findSubsequence ( arr , n , k ) ;
mod = 1000000007 function power ( x , y , p ) { var res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function findCount ( N ) { var count = power ( 2 , N , mod ) ; return count ; } var N = 25 ; document . write ( findCount ( N ) ) ;
function msb ( x ) { let ret = 0 ; while ( ( x >> ( ret + 1 ) ) != 0 ) ret ++ ; return ret ; } function xorRange ( l , r ) { let max_bit = msb ( r ) ; let mul = 2 ; let ans = 0 ; for ( let i = 1 ; i <= max_bit ; i ++ ) { if ( ( parseInt ( l / mul ) * mul ) == ( parseInt ( r / mul ) * mul ) ) { if ( ( ( l & ( 1 << i ) ) != 0 ) && ( r - l + 1 ) % 2 == 1 ) ans += mul ; mul *= 2 ; continue ; } let odd_c = 0 ; if ( ( ( l & ( 1 << i ) ) != 0 ) && l % 2 == 1 ) odd_c = ( odd_c ^ 1 ) ; if ( ( ( r & ( 1 << i ) ) != 0 ) && r % 2 == 0 ) odd_c = ( odd_c ^ 1 ) ; if ( odd_c ) ans += mul ; mul *= 2 ; } let zero_bit_cnt = parseInt ( ( r - l + 1 ) / 2 ) ; if ( l % 2 == 1 && r % 2 == 1 ) zero_bit_cnt ++ ; if ( zero_bit_cnt % 2 == 1 ) ans ++ ; return ans ; } let l = 1 , r = 4 ; document . write ( xorRange ( l , r ) ) ;
function computeXOR ( n ) { switch ( n & 3 ) { case 0 : return n ; case 1 : return 1 ; case 2 : return n + 1 ; case 3 : return 0 ; } } let l = 1 , r = 4 ; document . write ( computeXOR ( r ) ^ computeXOR ( l - 1 ) ) ;
function countNumbers ( x , n ) { if ( x > n ) return 0 ; return 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ; } let n = 120 ; document . write ( countNumbers ( 1 , n ) ) ;
function checkfact ( N , countprime , prime ) { var countfact = 0 ; if ( prime == 2 prime == 3 ) countfact ++ ; var divide = prime ; while ( N / divide != 0 ) { countfact += N / divide ; divide = divide * divide ; } if ( countfact >= countprime ) return true ; else return false ; } function check ( N ) { var sumsquares = ( N + 1 ) * ( 2 * N + 1 ) ; var countprime = 0 ; for ( i = 2 ; i <= Math . sqrt ( sumsquares ) ; i ++ ) { var flag = 0 ; while ( sumsquares % i == 0 ) { flag = 1 ; countprime ++ ; sumsquares /= i ; } if ( flag == 1 ) { if ( ! checkfact ( N - 1 , countprime , i ) ) return false ; countprime = 0 ; } } if ( sumsquares != 1 ) if ( ! checkfact ( N - 1 , 1 , sumsquares ) ) return false ; return true ; } var N = 5 ; if ( check ( N ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countNonIncreasing ( arr , n ) { var cnt = 0 ; var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( arr [ i + 1 ] <= arr [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len + 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len + 1 ) * len ) / 2 ) ; return cnt ; } var arr = [ 5 , 2 , 3 , 7 , 1 , 1 ] ; var n = arr . length ; document . write ( countNonIncreasing ( arr , n ) ) ;
function printPermutation ( n ) { if ( n % 2 != 0 ) document . write ( - 1 ) ; else for ( let i = 1 ; i <= Math . floor ( n / 2 ) ; i ++ ) document . write ( ( 2 * i ) + " " + ( ( 2 * i ) - 1 ) + " " ) ; } let n = 4 ; printPermutation ( n ) ;
var MAXN = 10000000 ; function minimumSteps ( n , m , a , b ) { if ( n > m ) return MAXN ; if ( n == m ) return 0 ; return Math . min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) ; } var n = 120 , m = 51840 ; var a = 2 , b = 3 ; document . write ( minimumSteps ( n , m , a , b ) ) ;
function minOperations ( n , m ) { if ( m % n != 0 ) return - 1 ; var minOperations = 0 ; var q = m / n ; while ( q % 2 == 0 ) { q = q / 2 ; minOperations ++ ; } while ( q % 3 == 0 ) { q = q / 3 ; minOperations ++ ; } if ( q == 1 ) return minOperations ; return - 1 ; } var n = 120 , m = 51840 ; document . write ( minOperations ( n , m ) ) ;
function fib ( n ) { var phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return parseInt ( Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ) ; } function calculateSum ( l , r ) { var sum = 0 ; for ( i = l ; i <= r ; i ++ ) sum += fib ( i ) ; return sum ; } var l = 4 , r = 8 ; document . write ( calculateSum ( l , r ) ) ;
function sphereSide ( h , r ) { if ( h < 0 && r < 0 ) return - 1 ; var R = ( ( h * r * Math . sqrt ( 2 ) ) / ( h + Math . sqrt ( 2 ) * r ) ) / 2 ; return R ; } var h = 5 , r = 6 ; document . write ( sphereSide ( h , r ) . toFixed ( 5 ) ) ;
function possibleways ( n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; } let n = 20 ; document . write ( possibleways ( n ) ) ;
function countSubarrays ( arr , n , K ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { let product = 1 ; for ( let x = i ; x <= j ; x ++ ) product *= arr [ x ] ; if ( product % K == 0 ) count ++ ; } } return count ; } let arr = [ 6 , 2 , 8 ] ; let n = arr . length ; let K = 4 ; document . write ( countSubarrays ( arr , n , K ) ) ;
function printMaxValPair ( v , n ) { v . sort ( ( a , b ) => a - b ) var N = v [ n - 1 ] ; if ( N % 2 == 1 ) { var first_maxima = N / 2 ; var second_maxima = first_maxima + 1 ; var ans1 = 3000000000000000000 , ans2 = 3000000000000000000 ; var from_left = - 1 , from_right = - 1 ; var from = - 1 ; for ( var i = 0 ; i < n ; ++ i ) { if ( v [ i ] > first_maxima ) { from = i ; break ; } else { var diff = first_maxima - v [ i ] ; if ( diff < ans1 ) { ans1 = diff ; from_left = v [ i ] ; } } } from_right = v [ from ] ; var diff1 = first_maxima - from_left ; var diff2 = from_right - second_maxima ; if ( diff1 < diff2 ) document . write ( N + " " + from_left ) ; else document . write ( N + " " + from_right ) ; } else { var maxima = parseInt ( N / 2 ) ; var ans1 = 3000000000000000000 ; var R = - 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { var diff = Math . abs ( v [ i ] - maxima ) ; if ( diff < ans1 ) { ans1 = diff ; R = v [ i ] ; } } document . write ( N + " " + R ) ; } } var v = [ 1 , 1 , 2 , 3 , 6 , 1 ] ; var n = v . length ; printMaxValPair ( v , n ) ;
function Permutations ( n , k ) { var ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; } var n = 5 , k = 2 ; document . write ( Permutations ( n , k ) ) ;
function power ( a , n ) { if ( n == 0 ) return 1 ; var p = power ( a , parseInt ( n / 2 ) ) ; p = p * p ; if ( n % 2 == 1 ) p = p * a ; return p ; } function countIntegers ( l , r ) { var ans = 0 , i = 1 ; var v = power ( 2 , i ) ; while ( v <= r ) { while ( v <= r ) { if ( v >= l ) ans ++ ; v = v * 3 ; } i ++ ; v = power ( 2 , i ) ; } if ( l == 1 ) ans ++ ; return parseInt ( ans ) ; } var l = 12 , r = 21 ; document . write ( countIntegers ( l , r ) ) ;
function findPairCount ( N , K ) { var count = 0 ; var rem = Array . from ( { length : K } , ( _ , i ) => 0 ) ; rem [ 0 ] = parseInt ( N / K ) ; for ( i = 1 ; i < K ; i ++ ) rem [ i ] = parseInt ( ( N - i ) / K + 1 ) ; if ( K % 2 == 0 ) { count += parseInt ( ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ) ; for ( i = 1 ; i < K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; count += ( rem [ K / 2 ] * ( rem [ K / 2 ] - 1 ) ) / 2 ; } else { count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) / 2 ; for ( i = 1 ; i <= K / 2 ; i ++ ) count += rem [ i ] * rem [ K - i ] ; } return count ; } var N = 10 , K = 4 ; document . write ( findPairCount ( N , K ) ) ;
let N = 1000005 ; let prime = new Array ( N ) ; function sieve ( ) { for ( let i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 1 ] = false ; prime [ 0 ] = false ; for ( let i = 2 ; i < N ; i ++ ) { if ( prime [ i ] ) { for ( let j = i * 2 ; j < N ; j += i ) { prime [ j ] = false ; } } } } function sumTruncatablePrimes ( n ) { let sum = 0 ; for ( let i = 2 ; i < n ; i ++ ) { let num = i ; let flag = true ; while ( num > 0 ) { if ( ! prime [ num ] ) { flag = false ; break ; } num = Math . floor ( num / 10 ) ; } num = i ; let power = 10 ; while ( num / power > 0 ) { if ( ! prime [ num % power ] ) { flag = false ; break ; } power *= 10 ; } if ( flag ) { sum += i ; } } return sum ; } let n = 25 ; sieve ( ) ; document . write ( sumTruncatablePrimes ( n ) ) ;
function nDigitPerfectSquares ( n ) { document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n - 1 ) ) ) , 2 ) + " " ) ; document . write ( Math . pow ( Math . ceil ( Math . sqrt ( Math . pow ( 10 , n ) ) ) - 1 , 2 ) ) ; } var n = 4 ; nDigitPerfectSquares ( n ) ;
var N = 3 ; function MaxTraceSub ( mat ) { var max_trace = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { var r = i , s = j , trace = 0 ; while ( r < N && s < N ) { trace += mat [ r ] [ s ] ; r ++ ; s ++ ; max_trace = Math . max ( trace , max_trace ) ; } } } return max_trace ; } var mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 4 ] , [ 2 , 7 , - 10 ] ] ; document . write ( MaxTraceSub ( mat ) ) ;
var n = 3 var m = 3 function check ( a , b ) { for ( var i = 0 ; i < n ; i ++ ) { var v1 = [ ] , v2 = [ ] ; var r = i ; var col = 0 ; while ( r >= 0 && col < m ) { v1 . push ( a [ r ] [ col ] ) ; v2 . push ( b [ r ] [ col ] ) ; r -- ; col ++ ; } v1 . sort ( ) ; v2 . sort ( ) ; for ( var i = 0 ; i < v1 . length ; i ++ ) { if ( v1 [ i ] != v2 [ i ] ) return false ; } } for ( var j = 1 ; j < m ; j ++ ) { var v1 = [ ] , v2 = [ ] ; var r = n - 1 ; var col = j ; while ( r >= 0 && col < m ) { v1 . push ( a [ r ] [ col ] ) ; v2 . push ( b [ r ] [ col ] ) ; r -- ; col ++ ; } v1 . sort ( ) ; v2 . sort ( ) ; for ( var i = 0 ; i < v1 . length ; i ++ ) { if ( v1 [ i ] != v2 [ i ] ) return false ; } } return true ; } var a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; var b = [ [ 1 , 4 , 7 ] , [ 2 , 5 , 6 ] , [ 3 , 8 , 9 ] ] ; if ( check ( a , b ) ) document . write ( " " ) ; else document . write ( " " ) ;
function lastDigit ( a , b ) { var lastDig = ( a [ a . length - 1 ] - ' ' ) * ( b [ b . length - 1 ] - ' ' ) ; document . write ( lastDig % 10 ) ; } var a = " " , b = " " ; lastDigit ( a , b ) ;
function printPalindrome ( n ) { if ( n == 1 ) { document . write ( " " ) ; document . write ( " " ) ; } else { document . write ( " " + ( parseInt ( Math . pow ( 10 , n - 1 ) ) + 1 ) ) ; document . write ( " " + parseInt ( Math . pow ( 10 , n ) - 1 ) ) ; } } var n = 4 ; printPalindrome ( n ) ;
function printSum ( a , b ) { var res = 0 ; var temp1 = 0 , temp2 = 0 ; while ( a ) { temp1 = temp1 * 10 + ( a % 10 ) ; a = parseInt ( a / 10 ) ; } a = temp1 ; while ( b ) { temp2 = temp2 * 10 + ( b % 10 ) ; b = parseInt ( b / 10 ) ; } b = temp2 ; while ( a ) { var sum = ( a % 10 + b % 10 ) ; if ( parseInt ( sum / 10 ) == 0 ) res = res * 10 + sum ; else { temp1 = 0 ; while ( sum ) { temp1 = temp1 * 10 + ( sum % 10 ) ; sum = parseInt ( sum / 10 ) ; } sum = temp1 ; while ( sum ) { res = res * 10 + ( sum % 10 ) ; sum = parseInt ( sum / 10 ) ; } } a = parseInt ( a / 10 ) ; b = parseInt ( b / 10 ) ; } return res ; } var a = 7752 , b = 8834 ; document . write ( printSum ( a , b ) ) ;
function countDigits ( a , b ) { var count = 0 ; var p = Math . abs ( parseInt ( a / b ) ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 ) ; } return count ; } var a = 100 ; var b = 10 ; document . write ( countDigits ( a , b ) ) ;
function countDigits ( a , b ) { return Math . floor ( ( Math . log ( Math . abs ( a ) ) / Math . log ( 10 ) ) - ( Math . log ( Math . abs ( b ) ) / Math . log ( 10 ) ) ) + 1 ; } var a = 100 ; var b = 10 ; document . write ( countDigits ( a , b ) ) ;
function smallestOdd ( n ) { if ( n == 1 ) return 1 ; return Math . pow ( 10 , n - 1 ) + 1 ; } var n = 4 ; document . write ( smallestOdd ( n ) ) ;
function findNumbers ( n ) { var odd = Math . pow ( 10 , n ) - 1 ; var even = odd - 1 ; document . write ( " " + even + " " ) ; document . write ( " " + odd ) ; } var n = 4 ; findNumbers ( n ) ;
function longestSubArray ( arr , n ) { var isZeroPresent = false ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 0 ) { isZeroPresent = true ; break ; } } if ( isZeroPresent ) return n ; return 0 ; } var arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] ; var n = arr . length ; document . write ( longestSubArray ( arr , n ) ) ;
function smallestEven ( n ) { if ( n == 1 ) return 0 ; return Math . pow ( 10 , n - 1 ) ; } var n = 4 ; document . write ( smallestEven ( n ) ) ;
function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } function maxProfit ( n , a , b , x , y ) { let res = x * Math . floor ( n / a ) ; res += y * Math . floor ( n / b ) ; res -= Math . min ( x , y ) * ( n / ( ( a * b ) / __gcd ( a , b ) ) ) ; return res ; } let n = 6 , a = 6 , b = 2 , x = 8 , y = 2 ; document . write ( maxProfit ( n , a , b , x , y ) ) ;
let MOD = 1000000007 ; function sumOfSeries ( n ) { let ans = Math . pow ( n % MOD , 2 ) ; return ( ans % MOD ) ; } let n = 10 ; document . write ( sumOfSeries ( n ) ) ;
function kthOdd ( arr , n , k ) { for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) k -- ; if ( k == 0 ) return arr [ i ] ; } return - 1 ; } var arr = [ 1 , 2 , 3 , 4 , 5 ] ; var n = arr . length ; var k = 2 ; document . write ( kthOdd ( arr , n , k ) ) ;
function lastFiveDigits ( n ) { n = ( Math . floor ( n / 10000 ) ) * 10000 + ( Math . floor ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( Math . floor ( n / 10 ) % 10 ) * 10 + Math . floor ( n / 1000 ) % 10 ; let ans = 1 ; for ( let i = 0 ; i < 5 ; i ++ ) { ans *= n ; ans %= 100000 ; } document . write ( ans ) ; } let n = 12345 ; lastFiveDigits ( n ) ;
let mod = 1000000007 ; function power ( a , n ) { if ( n == 0 ) { return 1 ; } let p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( n == 1 ) { p = ( p * a ) % mod ; } return p ; } function computeSum ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let maxs = ( power ( 2 , i ) - 1 + mod ) % mod ; maxs = ( maxs * arr [ i ] ) % mod ; let mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod ; mins = ( mins * arr [ i ] ) % mod ; let V = ( maxs - mins + mod ) % mod ; sum = ( sum + V ) % mod ; } return sum ; } let arr = [ 4 , 3 , 1 ] ; let n = arr . length ; document . write ( computeSum ( arr , n ) ) ;
function countNumbers ( n ) { if ( n % 2 == 1 ) return 0 ; return ( 9 * Math . pow ( 10 , parseInt ( n / 2 ) - 1 ) ) ; } var n = 2 ; document . write ( countNumbers ( n ) ) ;
function count ( n ) { var cnt = 0 ; var p = 1 ; while ( p <= n ) { cnt ++ ; p *= 2 ; } return cnt ; } var n = 7 ; document . write ( count ( n ) ) ;
function KthMinValAfterMconcatenate ( A , N , M , K ) { A . sort ( ( a , b ) => a - b ) return ( A [ ( ( K - 1 ) / M ) ] ) ; } var A = [ 3 , 1 , 2 ] ; var M = 3 , K = 4 ; var N = A . length ; document . write ( KthMinValAfterMconcatenate ( A , N , M , K ) ) ;
function sumN ( n ) { n = parseInt ( ( n + 1 ) / 2 ) ; return ( n * n ) ; } var n = 3 ; document . write ( sumN ( n ) ) ;
function countNumbers ( n ) { return n - parseInt ( n / 2 , 10 ) - parseInt ( n / 3 , 10 ) - parseInt ( n / 5 , 10 ) - parseInt ( n / 7 , 10 ) + parseInt ( n / 6 , 10 ) + parseInt ( n / 10 , 10 ) + parseInt ( n / 14 , 10 ) + parseInt ( n / 15 , 10 ) + parseInt ( n / 21 , 10 ) + parseInt ( n / 35 , 10 ) - parseInt ( n / 30 , 10 ) - parseInt ( n / 42 , 10 ) - parseInt ( n / 70 , 10 ) - parseInt ( n / 105 , 10 ) + parseInt ( n / 210 , 10 ) ; } let n = 20 ; document . write ( countNumbers ( n ) ) ;
function maxPrimes ( n ) { return parseInt ( n / 2 ) ; } var n = 17 ; document . write ( maxPrimes ( n ) ) ;
function sum ( n ) { return n * ( n + 1 ) * ( n + 2 ) / 3 ; } var n = 2 ; document . write ( sum ( n ) ) ;
function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } function findMinimum ( n , m ) { var mini = m ; for ( var i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { var sec = n / i ; if ( __gcd ( m , i ) > 1 ) { return i ; } else if ( __gcd ( sec , m ) > 1 ) { mini = Math . min ( sec , mini ) ; } } } if ( mini == m ) return - 1 ; else return mini ; } var n = 8 , m = 10 ; document . write ( findMinimum ( n , m ) ) ;
function nthTerm ( N ) { let nth = 0 , i ; for ( i = N ; i > 0 ; i -- ) { nth += Math . pow ( i , i ) ; } return nth ; } let N = 3 ; document . write ( nthTerm ( N ) ) ;
function kthSmallest ( n , k ) { return ( 2 * k ) ; } var n = 8 , k = 4 ; document . write ( kthSmallest ( n , k ) ) ;
function isSumOfPowersOfTwo ( n ) { if ( n % 2 == 1 ) return false ; else return true ; } var n = 10 ; if ( isSumOfPowersOfTwo ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findMinRemoval ( arr , n ) { var temp , value = 0 ; var maximum = 0 ; if ( n == 1 ) return 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) + Math . abs ( arr [ i ] - arr [ i - 1 ] ) - Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . max ( maximum , temp ) ; } return ( value - maximum ) ; } var arr = [ 1 , 5 , 3 , 2 , 10 ] ; var n = arr . length ; document . write ( findMinRemoval ( arr , n ) + " " ) ;
function getTime ( u , v , x ) { let speed = u + v ; let time = x / speed ; return time ; } let u = 3 , v = 3 , x = 3 ; document . write ( getTime ( u , v , x ) ) ;
function number_of_teams ( M ) { var N1 , N2 , sqr ; sqr = parseInt ( Math . sqrt ( 1 + ( 8 * M ) ) ) ; N1 = ( 1 + sqr ) / 2 ; N2 = ( 1 - sqr ) / 2 ; if ( N1 > 0 ) return N1 ; return N2 ; } var M = 45 ; document . write ( number_of_teams ( M ) ) ;
function LucasSum ( N ) { var sum = 0 ; var a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; var c = a + b ; a = b ; b = c ; } return sum ; } var N = 20 ; document . write ( LucasSum ( N ) ) ;
function countNumbers ( l , r ) { return ( parseInt ( r / 6 ) - parseInt ( ( l - 1 ) / 6 ) ) ; } var l = 1000 , r = 6000 ; document . write ( countNumbers ( l , r ) ) ;
function findMinSum ( arr , n ) { var occ = n - 1 , sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) { sum += arr [ i ] * Math . pow ( 2 , occ ) ; occ -- ; } return sum ; } var arr = [ 1 , 2 , 4 , 5 ] ; var n = arr . length ; document . write ( findMinSum ( arr , n ) ) ;
function getPosition ( n , m ) { if ( m > ( n / 2 ) ) return ( m - parseInt ( n / 2 ) ) ; return ( m + parseInt ( n / 2 ) ) ; } var n = 8 , m = 5 ; document . write ( getPosition ( n , m ) ) ;
function parity ( a ) { return a % 3 ; } function solve ( array , size ) { var operations = 0 ; for ( var i = 0 ; i < size - 1 ; i ++ ) { if ( parity ( array [ i ] ) == parity ( array [ i + 1 ] ) ) { operations ++ ; if ( i + 2 < size ) { var pari1 = parity ( array [ i ] ) ; var pari2 = parity ( array [ i + 2 ] ) ; if ( pari1 == pari2 ) { if ( pari1 == 0 ) array [ i + 1 ] = 1 ; else if ( pari1 == 1 ) array [ i + 1 ] = 0 ; else array [ i + 1 ] = 1 ; } else { if ( ( pari1 == 0 && pari2 == 1 ) || ( pari1 == 1 && pari2 == 0 ) ) array [ i + 1 ] = 2 ; if ( ( pari1 == 1 && pari2 == 2 ) || ( pari1 == 2 && pari2 == 1 ) ) array [ i + 1 ] = 0 ; if ( ( pari1 == 2 && pari2 == 0 ) || ( pari1 == 0 && pari2 == 2 ) ) array [ i + 1 ] = 1 ; } } } } return operations ; } var array = [ 2 , 1 , 3 , 0 ] ; var size = array . length ; document . write ( solve ( array , size ) ) ;
const n = 3 ; function submatrixXor ( arr ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; if ( ( top_left % 2 == 1 ) && ( bottom_right % 2 == 1 ) ) ans = ( ans ^ arr [ i ] [ j ] ) ; } } return ans ; } let arr = [ [ 6 , 7 , 13 ] , [ 8 , 3 , 4 ] , [ 9 , 7 , 6 ] ] ; document . write ( submatrixXor ( arr ) ) ;
function findDigitalRoot ( num ) { var sum = Number . MAX_VALUE , tempNum = num ; while ( sum >= 10 ) { sum = 0 ; while ( tempNum > 0 ) { sum += tempNum % 10 ; tempNum = parseInt ( tempNum / 10 ) ; } tempNum = sum ; } return sum ; } function findAnswer ( X , N ) { var counter = 0 ; for ( var i = 1 ; counter < N ; ++ i ) { var digitalRoot = findDigitalRoot ( i ) ; if ( digitalRoot == X ) { counter += 1 ; } if ( counter == N ) { document . write ( i ) ; break ; } } } var X = 1 , N = 3 ; findAnswer ( X , N ) ;
function findAnswer ( X , N ) { return ( N - 1 ) * 9 + X ; } let X = 7 ; let N = 43 ; document . write ( findAnswer ( X , N ) ) ;
function count ( N , K , R ) { var sum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( i % K == R ) sum += i ; } return sum ; } var N = 20 , K = 4 , R = 3 ; document . write ( count ( N , K , R ) ) ;
function getCount ( a , b , c ) { let count = 0 ; for ( let i = 1 ; i <= 81 ; i ++ ) { let cr = b * Math . pow ( i , a ) + c ; let tmp = cr ; let sm = 0 ; while ( tmp != 0 ) { sm += tmp % 10 ; tmp = Math . floor ( tmp / 10 ) ; } if ( sm == i && cr < 1e9 ) count ++ ; } return count ; } let a = 3 , b = 2 , c = 8 ; document . write ( getCount ( a , b , c ) ) ;
function isSpiltPossible ( n , a ) { let sum = 0 , c1 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; if ( a [ i ] == 1 ) { c1 ++ ; } } if ( sum % 2 != 0 ) return false ; if ( ( sum / 2 ) % 2 == 0 ) return true ; if ( c1 > 0 ) return true ; else return false ; } let n = 3 ; let a = [ 1 , 1 , 2 ] ; if ( isSpiltPossible ( n , a ) ) document . write ( " " ) ; else document . write ( " " ) ;
let n = 3 ; function matrixSum ( arr ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) { let top_left = ( i + 1 ) * ( j + 1 ) ; let bottom_right = ( n - i ) * ( n - j ) ; sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; } return sum ; } let arr = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; document . write ( matrixSum ( arr ) ) ;
function maxAND ( L , R ) { var maximum = L & R ; for ( var i = L ; i < R ; i ++ ) for ( var j = i + 1 ; j <= R ; j ++ ) maximum = Math . max ( maximum , ( i & j ) ) ; return maximum ; } var L = 1 , R = 632 ; document . write ( maxAND ( L , R ) ) ;
function checkArray ( arr , n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; } var arr = [ 1 , 2 , 3 , 4 , 5 ] ; var n = arr . length ; document . write ( checkArray ( arr , n ) ) ;
function findCount ( arr , n ) { var countOdd = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 == 1 ) countOdd ++ ; if ( countOdd % 2 == 0 ) return 1 ; else return 0 ; } var arr = [ 1 , 2 , 3 , 5 , 1 ] ; var n = arr . length ; document . write ( findCount ( arr , n ) ) ;
function isPerfectSquare ( x ) { let sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ; } function isSunnyNum ( n ) { if ( isPerfectSquare ( n + 1 ) ) return true ; return false ; } let n = 3 ; if ( isSunnyNum ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
let N = 10005 ; let isprime = new Array ( N ) . fill ( true ) ; let can = new Array ( N ) . fill ( false ) ; function SieveOfEratosthenes ( ) { for ( let p = 2 ; p * p < N ; p ++ ) { if ( isprime [ p ] == true ) { for ( let i = p * p ; i < N ; i += p ) isprime [ i ] = false ; } } let primes = new Array ( ) ; for ( let i = 2 ; i < N ; i ++ ) if ( isprime [ i ] ) primes . push ( i ) ; return primes ; } function Prime_Numbers ( n ) { let primes = SieveOfEratosthenes ( ) ; for ( let i = 0 ; i < primes . length - 1 ; i ++ ) if ( primes [ i ] + primes [ i + 1 ] + 1 < N ) can [ primes [ i ] + primes [ i + 1 ] + 1 ] = true ; let ans = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( can [ i ] && isprime [ i ] ) { ans ++ ; } } return ans ; } let n = 50 ; document . write ( Prime_Numbers ( n ) ) ;
function findAndSum ( arr , n ) { var sum = 0 ; var mul = 1 ; for ( var i = 0 ; i < 30 ; i ++ ) { var count_on = 0 ; var l = 0 ; for ( var j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) if ( count_on ) l ++ ; else { count_on = 1 ; l ++ ; } else if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = 0 ; l = 0 ; } } if ( count_on ) { sum += ( ( mul * l * ( l + 1 ) ) / 2 ) ; count_on = 0 ; l = 0 ; } mul *= 2 ; } return sum ; } var arr = [ 7 , 1 , 1 , 5 ] ; var n = arr . length ; document . write ( findAndSum ( arr , n ) ) ;
function isPossible ( Sx , Sy , Dx , Dy , x , y ) { if ( Math . abs ( Sx - Dx ) % x == 0 && Math . abs ( Sy - Dy ) % y == 0 && ( Math . abs ( Sx - Dx ) / x ) % 2 == ( Math . abs ( Sy - Dy ) / y ) % 2 ) return true ; return false ; } let Sx = 0 , Sy = 0 , Dx = 0 , Dy = 0 ; let x = 3 , y = 4 ; if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) document . write ( " " ) ; else document . write ( " " ) ;
function getPairs ( a ) { let count = 0 ; for ( let i = 0 ; i < a . length ; i ++ ) { for ( let j = 0 ; j < a . length ; j ++ ) { if ( a [ i ] < a [ j ] ) count ++ ; } } return count ; } let a = [ 2 , 4 , 3 , 1 ] ; document . write ( getPairs ( a ) ) ;
function isComposite ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } function isDigitSumOne ( nm ) { while ( nm > 9 ) { let sum_digit = 0 ; while ( nm > 0 ) { let digit = nm % 10 ; sum_digit = sum_digit + digit ; nm = Math . floor ( nm / 10 ) ; } nm = sum_digit ; } if ( nm == 1 ) return true ; else return false ; } function printValidNums ( l , r ) { for ( let i = l ; i <= r ; i ++ ) { if ( isComposite ( i ) && isDigitSumOne ( i ) ) document . write ( i + " " ) ; } } let l = 10 , r = 100 ; printValidNums ( l , r ) ;
function calcNodes ( N , I ) { var result = 0 ; result = I * ( N - 1 ) + 1 ; return result ; } var N = 5 , I = 2 ; document . write ( " " + calcNodes ( N , I ) ) ;
let mod = 1000000007 ; let arr = new Array ( 1000001 ) ; arr . fill ( 0 ) ; function cal_factorial ( ) { arr [ 0 ] = 1 ; for ( let i = 1 ; i <= 1000000 ; i ++ ) { arr [ i ] = ( ( arr [ i - 1 ] * i ) % mod ) ; } } function mod_exponent ( num , p ) { if ( p != 0 ) return 1 ; if ( ( p & 1 ) != 0 ) { return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , parseInt ( p / 2 , 10 ) ) ) % mod ) % mod ; } else return ( mod_exponent ( ( num * num ) % mod , parseInt ( p / 2 , 10 ) ) ) % mod ; } function getCount ( x , y ) { let ans = arr [ x + y - 1 ] ; ans *= 0 * mod_exponent ( arr [ x ] , mod - 2 ) ; ans ++ ; ans %= mod ; ans *= mod_exponent ( arr [ y ] , mod - 2 ) ; ans %= mod ; ans *= ( x - y ) ; ans %= mod ; return ans ; } cal_factorial ( ) ; let x = 3 , y = 1 ; document . write ( getCount ( x , y ) ) ;
function findValues ( a , b ) { if ( ( a - b ) % 2 == 1 ) { document . write ( " " ) ; return ; } document . write ( ( a - b ) / 2 + " " + ( a + b ) / 2 ) ; } let a = 12 ; let b = 8 ; findValues ( a , b ) ;
function countTriplets ( n , points ) { var pts = new Set ( ) ; var ct = 0 ; for ( var i = 0 ; i < n ; i ++ ) pts . add ( points [ i ] . toString ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) { var x = points [ i ] [ 0 ] + points [ j ] [ 0 ] ; var y = points [ i ] [ 1 ] + points [ j ] [ 1 ] ; if ( x % 2 == 0 && y % 2 == 0 ) if ( pts . has ( [ ( x / 2 ) , ( y / 2 ) ] . toString ( ) ) ) ct ++ ; } return ct ; } var points = [ [ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 3 ] ] ; var n = points . length ; document . write ( countTriplets ( n , points ) )
function mixtureConcentration ( n , p ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) res += p [ i ] ; res /= n ; return res ; } var arr = [ 0 , 20 , 20 ] ; var n = arr . length ; document . write ( mixtureConcentration ( n , arr ) . toFixed ( 4 ) ) ;
function countOddSquares ( n , m ) { return Math . pow ( m , 0.5 ) - Math . pow ( n - 1 , 0.5 ) ; } var n = 5 , m = 100 ; document . write ( " " + ( ( m - n + 1 ) - countOddSquares ( n , m ) ) ) ;
function Square ( row , column , moves ) { var a = 0 , b = 0 , c = 0 , d = 0 , total = 0 ; a = row - moves ; b = row + moves ; c = column - moves ; d = column + moves ; if ( a < 1 ) a = 1 ; if ( c < 1 ) c = 1 ; if ( b > 8 ) b = 8 ; if ( d > 8 ) d = 8 ; total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; return total ; } var R = 4 , C = 5 , M = 2 ; document . write ( Square ( R , C , M ) ) ;
function findNumber ( n , m ) { var num = ( m - 1 ) * 9 + n ; return num ; } var n = 2 , m = 5 ; document . write ( findNumber ( n , m ) ) ;
function checkTriangularSumRepresentation ( n ) { var tri = new Set ( ) ; var i = 1 ; while ( 1 ) { var x = i * parseInt ( ( i + 1 ) / 2 ) ; if ( x >= n ) break ; tri . add ( x ) ; i ++ ; } var ans = false ; tri . forEach ( tm => { if ( tri . has ( n - tm ) ) ans = true } ) ; return ans ; } var n = 24 ; checkTriangularSumRepresentation ( n ) ? document . write ( " " ) : document . write ( " " ) ;
function digitsCount ( n ) { let len = 0 ; while ( n > 0 ) { len ++ ; n = Math . floor ( n / 10 ) ; } return len ; } function absoluteFirstLast ( n , x ) { let i = 0 , mod = 1 ; while ( i < x ) { mod *= 10 ; i ++ ; } let last = n % mod ; let len = digitsCount ( n ) ; while ( len != x ) { n = Math . floor ( n / 10 ) ; len -- ; } let first = n ; return Math . abs ( first - last ) ; } let n = 21546 , x = 2 ; document . write ( absoluteFirstLast ( n , x ) ) ;
function make_sequence ( N ) { var arr = Array ( N + 1 ) , sum = 0 ; for ( var i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 1 ) arr [ i ] = 1 ; else arr [ i ] = 2 ; sum += arr [ i ] ; } if ( sum % 2 == 1 ) arr [ 2 ] = 3 ; for ( var i = 1 ; i <= N ; i ++ ) document . write ( arr [ i ] + " " ) ; } var N = 9 ; make_sequence ( N ) ;
function countOdd ( L , R ) { let N = Math . floor ( ( R - L ) / 2 ) ; if ( R % 2 != 0 L % 2 != 0 ) N += 1 ; return N ; } let L = 3 , R = 7 ; let odds = countOdd ( L , R ) ; let evens = ( R - L + 1 ) - odds ; document . write ( " " + odds + " " ) ; document . write ( " " + evens + " " ) ;
function getMinCost ( n , m ) { let cost = ( n - 1 ) * m + ( m - 1 ) * n ; return cost ; } let n = 4 , m = 5 ; document . write ( getMinCost ( n , m ) ) ;
function minOperation ( n , k , a ) { for ( i = k ; i < n ; i ++ ) { if ( a [ i ] != a [ k - 1 ] ) document . write ( - 1 ) ; } for ( i = k - 2 ; i > - 1 ; i -- ) { if ( a [ i ] != a [ k - 1 ] ) document . write ( i + 1 ) ; } } var n = 5 ; var k = 3 ; var a = [ 2 , 1 , 1 , 1 , 1 ] ; minOperation ( n , k , a ) ;
function binomialCoeff ( n , k ) { if ( k > n ) return 0 ; var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } var N = 5 , M = 1 ; var P = ( N * ( N - 1 ) ) / 2 ; document . write ( binomialCoeff ( P , M ) ) ;
function generateSequence ( n , g ) { for ( var i = 1 ; i <= n ; i ++ ) { document . write ( i * g + " " ) ; } } var n = 6 , g = 5 ; generateSequence ( n , g ) ;
let MAX = 1000 ; let f = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { f [ i ] = 0 ; } function fib ( n ) { if ( n == 0 ) return 0 ; if ( n == 1 n == 2 ) return ( f [ n ] = 1 ) ; if ( f [ n ] != 0 ) return f [ n ] ; let k = 0 ; if ( ( n & 1 ) != 0 ) k = ( n + 1 ) / 2 ; else k = n / 2 ; if ( ( n & 1 ) != 0 ) f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) ; else f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ; return f [ n ] ; } function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function findLCMFibonacci ( a , b ) { return ( fib ( a ) * fib ( b ) ) / fib ( gcd ( a , b ) ) ; } let a = 3 , b = 12 ; document . write ( findLCMFibonacci ( a , b ) ) ;
function isEvenOrOdd ( L , R ) { let oddCount = Math . floor ( ( R - L ) / 2 ) ; if ( R % 2 == 1 L % 2 == 1 ) oddCount ++ ; if ( oddCount % 2 == 0 ) return " " ; else return " " ; } let L = 5 , R = 15 ; document . write ( isEvenOrOdd ( L , R ) ) ;
function trailing_zeros ( N ) { let count_of_two = 0 , count_of_five = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { let val = i ; while ( val % 2 == 0 && val > 0 ) { val = parseInt ( val / 2 ) ; count_of_two += i ; } while ( val % 5 == 0 && val > 0 ) { val = parseInt ( val / 5 ) ; count_of_five += i ; } } let ans = Math . min ( count_of_two , count_of_five ) ; return ans ; } let N = 12 ; document . write ( trailing_zeros ( N ) ) ;
function midptellipse ( rx , ry , xc , yc ) { var dx , dy , d1 , d2 , x , y ; x = 0 ; y = ry ; d1 = ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ; dx = 2 * ry * ry * x ; dy = 2 * rx * rx * y ; while ( dx < dy ) { document . write ( " " + ( x + xc ) . toFixed ( 5 ) + " " + ( y + yc ) . toFixed ( 5 ) + " " + " " ) ; document . write ( " " + ( - x + xc ) . toFixed ( 5 ) + " " + ( y + yc ) . toFixed ( 5 ) + " " + " " ) ; document . write ( " " + ( x + xc ) . toFixed ( 5 ) + " " + ( - y + yc ) . toFixed ( 5 ) + " " + " " ) ; document . write ( " " + ( - x + xc ) . toFixed ( 5 ) + " " + ( - y + yc ) . toFixed ( 5 ) + " " + " " ) ; if ( d1 < 0 ) { x ++ ; dx = dx + ( 2 * ry * ry ) ; d1 = d1 + dx + ( ry * ry ) ; } else { x ++ ; y -- ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d1 = d1 + dx - dy + ( ry * ry ) ; } } d2 = ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ; while ( y >= 0 ) { document . write ( " " + ( x + xc ) . toFixed ( 5 ) + " " + ( y + yc ) . toFixed ( 5 ) + " " + " " ) ; document . write ( " " + ( - x + xc ) . toFixed ( 5 ) + " " + ( y + yc ) . toFixed ( 5 ) + " " + " " ) ; document . write ( " " + ( x + xc ) . toFixed ( 5 ) + " " + ( - y + yc ) . toFixed ( 5 ) + " " + " " ) ; document . write ( " " + ( - x + xc ) . toFixed ( 5 ) + " " + ( - y + yc ) . toFixed ( 5 ) + " " + " " ) ; if ( d2 > 0 ) { y -- ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + ( rx * rx ) - dy ; } else { y -- ; x ++ ; dx = dx + ( 2 * ry * ry ) ; dy = dy - ( 2 * rx * rx ) ; d2 = d2 + dx - dy + ( rx * rx ) ; } } } midptellipse ( 10 , 15 , 50 , 50 ) ;
function isDivisible ( n ) { temp = n ; sum = 0 ; while ( n ) { k = n % 10 ; sum += k ; n = parseInt ( n / 10 ) ; } if ( temp % sum == 0 ) return " " ; return " " ; } let n = 123 ; document . write ( isDivisible ( n ) ) ;
function alter ( x , y ) { while ( true ) { if ( x == 0 y == 0 ) break ; if ( x >= 2 * y ) x = x % ( 2 * y ) ; else if ( y >= 2 * x ) y = y % ( 2 * x ) ; else break ; } document . write ( " " + x + " " + " " + y ) ; } var x = 12 , y = 5 ; alter ( x , y ) ;
function digitProduct ( n ) { let prod = 1 ; while ( n > 0 ) { prod = prod * ( n % 10 ) ; n = Math . floor ( n / 10 ) ; } return prod ; } function printMultiplicativePrimes ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; prime [ 0 ] = prime [ 1 ] = false ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] && prime [ digitProduct ( i ) ] ) document . write ( i + " " ) ; } } let n = 10 ; printMultiplicativePrimes ( n ) ;
function gcd ( a , b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } function coPrime ( n1 , n2 ) { if ( gcd ( n1 , n2 ) == 1 ) return true ; else return false ; } function largestCoprime ( N ) { let half = Math . floor ( N / 2 ) ; while ( coPrime ( N , half ) == false ) half -- ; return half ; } let n = 50 ; document . write ( largestCoprime ( n ) ) ;
function largestCoprime ( N ) { if ( N == 6 ) return 1 ; else if ( N % 4 == 0 ) return ( N / 2 ) - 1 ; else if ( N % 2 == 0 ) return ( N / 2 ) - 2 ; else return ( ( N - 1 ) / 2 ) ; } var n = 50 ; document . write ( largestCoprime ( n ) ) ;
function printSafePrimes ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 2 ; i <= n ; i ++ ) prime [ i ] = 1 ; prime [ 0 ] = prime [ 1 ] = 0 ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == 1 ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = 0 ; } } for ( let i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] != 0 ) { let temp = ( 2 * i ) + 1 ; if ( temp <= n && prime [ temp ] != 0 ) prime [ temp ] = 2 ; } } for ( let i = 5 ; i <= n ; i ++ ) if ( prime [ i ] == 2 ) document . write ( i + " " ) ; } let n = 20 ; printSafePrimes ( n ) ;
function Divisors ( x ) { var c = 0 ; var v = [ ] ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . push ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . push ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . push ( c ) ; v . push ( x ) ; return v ; } function MinOperations ( a , b ) { var va = Divisors ( a ) ; var vb = Divisors ( b ) ; if ( va [ 3 ] != vb [ 3 ] ) { return - 1 ; } var minOperations = Math . abs ( va [ 0 ] - vb [ 0 ] ) + Math . abs ( va [ 1 ] - vb [ 1 ] ) + Math . abs ( va [ 2 ] - vb [ 2 ] ) ; return minOperations ; } var a = 14 , b = 28 ; document . write ( MinOperations ( a , b ) ) ;
function largestOddDigit ( n ) { var maxOdd = - 1 ; while ( n > 0 ) { var digit = n % 10 ; if ( digit % 2 == 1 && digit > maxOdd ) maxOdd = digit ; n = n / 10 ; } return maxOdd ; } function getProduct ( n ) { var maxOdd = largestOddDigit ( n ) ; if ( maxOdd == - 1 ) return - 1 ; return ( n * maxOdd ) ; } var n = 12345 ; document . write ( getProduct ( n ) ) ;
var n = 1000002 ; var phi = Array ( n + 2 ) . fill ( 0 ) ; var ans = Array ( n + 2 ) . fill ( 0 ) ; function ETF ( ) { for ( i = 1 ; i <= n ; i ++ ) { phi [ i ] = i ; } for ( i = 2 ; i <= n ; i ++ ) { if ( phi [ i ] == i ) { phi [ i ] = i - 1 ; for ( j = 2 * i ; j <= n ; j += i ) { phi [ j ] = ( phi [ j ] * ( i - 1 ) ) / i ; } } } } function LcmSum ( m ) { ETF ( ) ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = i ; j <= n ; j += i ) { ans [ j ] += ( i * phi [ i ] ) ; } } var answer = ans [ m ] ; answer = ( answer + 1 ) * m ; answer = answer / 2 ; return answer ; } var m = 5 ; document . write ( LcmSum ( m ) ) ;
function factorial ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } function ncr ( n , r ) { return Math . floor ( factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ) ; } function countWays ( str ) { let freq = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { freq [ i ] = 0 ; } let nvowels = 0 , nconsonants = 0 ; let vplaces , cways , vways ; for ( let i = 0 ; i < str . length ; i ++ ) ++ freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 ) nvowels += freq [ i ] ; else nconsonants += freq [ i ] ; } vplaces = nconsonants + 1 ; cways = factorial ( nconsonants ) ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( i != 0 && i != 4 && i != 8 && i != 14 && i != 20 && freq [ i ] > 1 ) { cways = Math . floor ( cways / factorial ( freq [ i ] ) ) ; } } vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( i == 0 i == 4 i == 8 i == 14 i == 20 && freq [ i ] > 1 ) { vways = Math . floor ( vways / factorial ( freq [ i ] ) ) ; } } return cways * vways ; } let str = " " ; document . write ( countWays ( str ) ) ;
function setBits ( n ) { let count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } return count ; } function countPairs ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { let setbits_x = setBits ( a [ i ] ) ; for ( let j = i + 1 ; j < n ; j ++ ) { let setbits_y = setBits ( a [ j ] ) ; let setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) ; if ( setbits_x + setbits_y == setbits_xor_xy ) count ++ ; } } return count ; } let a = [ 2 , 3 , 4 , 5 , 6 ] ; let n = a . length ; document . write ( countPairs ( a , n ) ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function findPossibleDerivables ( arr , n , D , A , B ) { var gcdAB = gcd ( A , B ) ; var counter = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( Math . abs ( arr [ i ] - D ) % gcdAB ) == 0 ) { counter ++ ; } } return counter ; } var arr = [ 1 , 2 , 3 , 4 , 7 , 13 ] ; var n = arr . length ; var D = 5 , A = 4 , B = 2 ; document . write ( findPossibleDerivables ( arr , n , D , A , B ) + " " ) ; var a = [ 1 , 2 , 3 ] ; n = a . length ; D = 6 ; A = 3 ; B = 2 ; document . write ( findPossibleDerivables ( a , n , D , A , B ) ) ;
function calSum ( n ) { return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; } let n = 3 ; document . write ( calSum ( n ) ) ;
function getElements ( a , arr , n ) { let elements = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { elements [ i ] = 0 ; } elements [ 0 ] = a ; for ( let i = 0 ; i < n ; i ++ ) { elements [ i + 1 ] = arr [ i ] ^ elements [ i ] ; } for ( let i = 0 ; i < n + 1 ; i ++ ) document . write ( elements [ i ] + " " ) ; } let arr = [ 13 , 2 , 6 , 1 ] ; let n = arr . length ; let a = 5 ; getElements ( a , arr , n ) ;
function distinctDigitSum ( n ) { var used = Array ( 10 ) . fill ( false ) ; var sum = 0 ; while ( n > 0 ) { var digit = n % 10 ; if ( ! used [ digit ] ) { used [ digit ] = true ; sum += digit ; } n = parseInt ( n / 10 ) ; } return sum ; } function checkSum ( m , n ) { var sumM = distinctDigitSum ( m ) ; var sumN = distinctDigitSum ( n ) ; if ( sumM == sumN ) return " " ; return " " ; } var m = 2452 , n = 9222 ; document . write ( checkSum ( m , n ) ) ;
function doubleFactorial ( n ) { var fact = 1 ; for ( var i = 1 ; i <= n ; i = i + 2 ) { fact = fact * i ; } return fact ; } function hermiteNumber ( n ) { if ( n % 2 == 1 ) return 0 ; else { var number = ( Math . pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ; if ( ( n / 2 ) % 2 == 1 ) number = number * - 1 ; return number ; } } var n = 6 ; document . write ( hermiteNumber ( n ) ) ;
function getSum ( n , d ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( i % 10 == d ) sum += i ; } return sum ; } let n = 30 ; let d = 3 ; document . write ( getSum ( n , d ) ) ;
function printThreeParts ( N ) { if ( N % 3 == 0 ) document . write ( " " + ( N - 2 ) ) ; else document . write ( " " + ( N - 3 ) ) ; } var N = 10 ; printThreeParts ( N ) ;
function isPrime ( N ) { for ( let i = 2 ; i <= Math . sqrt ( N ) ; i ++ ) { if ( N % i == 0 ) return false ; } return true ; } function getDifference ( N ) { if ( N == 0 ) return 2 ; else if ( N == 1 ) return 1 ; else if ( isPrime ( N ) ) return 0 ; let aboveN = - 1 ; let belowN = - 1 ; let n1 = N + 1 ; while ( true ) { if ( isPrime ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPrime ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } let diff1 = aboveN - N ; let diff2 = N - belowN ; return Math . min ( diff1 , diff2 ) ; } let N = 25 ; document . write ( getDifference ( N ) + " " ) ;
function check ( arr , x , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let y = Math . sqrt ( arr [ i ] ) ; if ( Math . floor ( y ) == Math . ceil ( y ) ) { sum += arr [ i ] ; } } if ( sum % x == 0 ) return true ; else return false ; } let arr = [ 2 , 3 , 4 , 9 , 10 ] ; let n = arr . length ; let x = 13 ; if ( check ( arr , x , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function MinimumMaximumPairs ( n , m ) { var max_pairs = parseInt ( ( ( n - m + 1 ) * ( n - m ) ) / 2 ) ; var min_pairs = m * parseInt ( ( ( ( n - m ) / m + 1 ) * ( ( n - m ) / m ) ) / 2 ) + parseInt ( Math . ceil ( ( ( n - m ) / ( m ) ) ) ) * ( ( n - m ) % m ) ; document . write ( " " + min_pairs + " " ) ; document . write ( " " + max_pairs ) ; } var n = 5 , m = 2 ; MinimumMaximumPairs ( n , m ) ;
function findGreater ( a , b ) { var x = a * ( Math . log ( ( b ) ) ) ; var y = b * ( Math . log ( ( a ) ) ) ; if ( y > x ) { document . write ( " " ) ; } else if ( y < x ) { document . write ( " " ) ; } else { document . write ( " " ) ; } } var a = 3 , b = 5 , c = 2 , d = 4 ; findGreater ( a , b ) ; findGreater ( c , d ) ;
var m = 100000007 ; function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function modexp ( x , n ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) ; } } function getFractionModulo ( a , b ) { var c = gcd ( a , b ) ; a = a / c ; b = b / c ; var d = modexp ( b , m - 2 ) ; var ans = ( ( a % m ) * ( d % m ) ) % m ; return ans ; } var a = 2 , b = 6 ; document . write ( getFractionModulo ( a , b ) ) ;
function maxPrimeFactors ( n ) { var num = n ; var maxPrime = - 1 ; while ( n % 2 == 0 ) { maxPrime = 2 ; n = parseInt ( n / 2 ) ; } for ( var i = 3 ; i <= parseInt ( Math . sqrt ( n ) ) ; i += 2 ) { while ( n % i == 0 ) { maxPrime = i ; n = parseInt ( n / i ) ; } } if ( n > 2 ) { maxPrime = n ; } var sum = maxPrime + num ; return sum ; } var n = 19 ; document . write ( maxPrimeFactors ( n ) ) ;
function sumOfDigits ( n ) { var res = 0 ; while ( n > 0 ) { res += n % 10 ; n = parseInt ( n / 10 ) ; } return res ; } function findNumber ( n ) { var i = n - 1 ; while ( i > 0 ) { if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) return i ; i -- ; } return - 1 ; } var n = 824 ; document . write ( findNumber ( n ) ) ;
function findNth ( N ) { let b = 14 ; for ( let i = 2 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) b = b * 2 ; else b = b - 8 ; } return b ; } N = 6 ; document . write ( findNth ( N ) ) ;
let N = 4 ; function predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) { let c = 0 ; while ( K != 0 ) { K -- ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { c = 0 ; if ( i > 0 && arr [ i - 1 ] [ j ] == 1 ) c ++ ; if ( j > 0 && arr [ i ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j > 0 && arr [ i - 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i < N - 1 && arr [ i + 1 ] [ j ] == 1 ) c ++ ; if ( j < N - 1 && arr [ i ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j < N - 1 && arr [ i + 1 ] [ j + 1 ] == 1 ) c ++ ; if ( i < N - 1 && j > 0 && arr [ i + 1 ] [ j - 1 ] == 1 ) c ++ ; if ( i > 0 && j < N - 1 && arr [ i - 1 ] [ j + 1 ] == 1 ) c ++ ; if ( arr [ i ] [ j ] == 1 ) { if ( c >= range1a && c <= range1b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } if ( arr [ i ] [ j ] == 0 ) { if ( c >= range0a && c <= range0b ) b [ i ] [ j ] = 1 ; else b [ i ] [ j ] = 0 ; } } } for ( let k = 0 ; k < N ; k ++ ) for ( let m = 0 ; m < N ; m ++ ) arr [ k ] [ m ] = b [ k ] [ m ] ; } } let arr = [ [ 0 , 0 , 0 , 0 ] , [ 0 , 1 , 1 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 ] ] ; let range1a = 2 , range1b = 2 ; let range0a = 2 , range0b = 3 ; let K = 3 ; let b = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { b [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { b [ i ] [ j ] = 0 ; } } predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) ; for ( let i = 0 ; i < N ; i ++ ) { document . write ( " " ) ; for ( let j = 0 ; j < N ; j ++ ) document . write ( b [ i ] [ j ] + " " ) ; }
function countMoves ( n ) { let ct = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ct += i * ( n - i ) ; ct += n ; return ct ; } let n = 3 ; document . write ( countMoves ( n ) ) ;
function countNumbers ( N ) { return ( Math . pow ( 10 , N ) - 1 ) - ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 ; } var n = 2 ; document . write ( countNumbers ( n ) ) ;
let N = 3 ; function calcDeterminant ( arr ) { let determinant = 0 ; for ( let i = 0 ; i < N ; i ++ ) { determinant += Math . pow ( arr [ i ] , 3 ) ; } determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] ; return determinant ; } let arr = [ 4 , 5 , 3 ] ; document . write ( calcDeterminant ( arr ) ) ;
function minimumMoves ( k , l , r ) { let count = r - l + 1 ; if ( count % k == 0 ) return 0 ; return ( k - ( count % k ) ) ; } let k = 3 , l = 10 , r = 10 ; document . write ( minimumMoves ( k , l , r ) ) ;
function sumNatural ( n ) { let sum = Math . floor ( n * ( n + 1 ) ) ; return sum ; } function sumEven ( l , r ) { return sumNatural ( Math . floor ( r / 2 ) ) - sumNatural ( Math . floor ( l - 1 ) / 2 ) ; } let l = 2 , r = 5 ; document . write ( " " + sumEven ( l , r ) ) ;
function isDivisibleRec ( x , a , b , n ) { if ( x > n ) return false ; if ( n % x == 0 ) return true ; return ( isDivisibleRec ( x * 10 + a , a , b , n ) || isDivisibleRec ( x * 10 + b , a , b , n ) ) ; } function isDivisible ( a , b , n ) { return isDivisibleRec ( a , a , b , n ) || isDivisibleRec ( b , a , b , n ) ; } let a = 3 , b = 5 , n = 53 ; if ( isDivisible ( a , b , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function MinSteps ( SourceX , SourceY , DestX , DestY ) { document . write ( Math . max ( Math . abs ( SourceX - DestX ) , Math . abs ( SourceY - DestY ) ) + " " ) ; while ( ( SourceX != DestX ) || ( SourceY != DestY ) ) { if ( SourceX < DestX ) { document . write ( ' ' ) ; SourceX ++ ; } if ( SourceX > DestX ) { document . write ( ' ' ) ; SourceX -- ; } if ( SourceY > DestY ) { document . write ( ' ' ) ; SourceY -- ; } if ( SourceY < DestY ) { document . write ( ' ' ) ; SourceY ++ ; } document . write ( " " ) ; } } let sourceX = 4 , sourceY = 4 ; let destinationX = 7 , destinationY = 0 ; MinSteps ( sourceX , sourceY , destinationX , destinationY ) ;
function findEle ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] == sum - arr [ i ] ) return arr [ i ] ; return - 1 ; } var arr = [ 1 , 2 , 3 , 6 ] ; var n = arr . length ; document . write ( findEle ( arr , n ) ) ;
function sumNatural ( n ) { sum = ( n * ( n + 1 ) ) / 2 ; return sum ; } function suminRange ( l , r ) { return sumNatural ( r ) - sumNatural ( l - 1 ) ; } let l = 2 ; let r = 5 ; document . write ( " " + suminRange ( l , r ) ) ;
function divisibleBy3 ( number ) { let sumOfDigit = 0 ; for ( let i = 0 ; i < number . length ; i ++ ) sumOfDigit += number [ i ] - ' ' ; if ( sumOfDigit % 3 == 0 ) return true ; return false ; } function divisibleBy25 ( number ) { if ( number . length < 2 ) return false ; let length = number . length ; let lastTwo = ( number [ length - 2 ] - ' ' ) * 10 + ( number [ length - 1 ] - ' ' ) ; if ( lastTwo % 25 == 0 ) return true ; return false ; } function divisibleBy75 ( number ) { if ( divisibleBy3 ( number ) && divisibleBy25 ( number ) ) return true ; return false ; } let number = " " ; let divisible = divisibleBy75 ( number ) ; if ( divisible ) document . write ( " " ) ; else document . write ( " " ) ;
function otherNumber ( A , Lcm , Hcf ) { return ( Lcm * Hcf ) / A ; } let A = 8 , Lcm = 8 , Hcf = 1 ; let result = otherNumber ( A , Lcm , Hcf ) ; document . write ( " " + result ) ;
function minimumNumbers ( n , s ) { if ( s % n ) return parseInt ( s / n ) + 1 ; else return parseInt ( s / n ) ; } let n = 5 ; let s = 11 ; document . write ( minimumNumbers ( n , s ) ) ;
function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } function sumAP ( n , d ) { n = parseInt ( n / d ) ; return ( n ) * ( 1 + n ) * d / 2 ; } function sumMultiples ( A , B , n ) { n -- ; common = parseInt ( ( A * B ) / __gcd ( A , B ) ) ; return sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ; } let n = 100 ; let A = 5 ; let B = 10 ; document . write ( " " + sumMultiples ( A , B , n ) ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; for ( var i = 2 ; i <= parseInt ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } function isPossible ( N ) { if ( isPrime ( N ) && isPrime ( N - 2 ) ) return true ; else return false ; } var n = 13 ; if ( isPossible ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function contiguousPerfectSquare ( arr , n ) { var a ; var b ; var current_length = 0 ; var max_length = 0 ; for ( var i = 0 ; i < n ; i ++ ) { b = ( Math . sqrt ( arr [ i ] ) ) ; a = parseInt ( b ) ; if ( a == b ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; } var arr = [ 9 , 75 , 4 , 64 , 121 , 25 ] ; var n = arr . length ; document . write ( contiguousPerfectSquare ( arr , n ) ) ;
function countPairs ( n ) { let count = 0 ; for ( let x = 1 ; x < n ; x ++ ) { for ( let y = x + 1 ; y <= n ; y ++ ) { if ( ( y * x ) % ( y + x ) == 0 ) count ++ ; } } return count ; } let n = 15 ; document . write ( countPairs ( n ) ) ;
function getIndex ( a , n ) { if ( n == 1 ) return 0 ; let ptrL = 0 , ptrR = n - 1 , sumL = a [ 0 ] , sumR = a [ n - 1 ] ; while ( ptrR - ptrL > 1 ) { if ( sumL < sumR ) { ptrL ++ ; sumL += a [ ptrL ] ; } else if ( sumL > sumR ) { ptrR -- ; sumR += a [ ptrR ] ; } else { break ; } } return ptrL ; } let a = [ 2 , 7 , 9 , 8 , 7 ] ; let n = a . length ; document . write ( getIndex ( a , n ) ) ;
function getPosition ( a , n , m ) { for ( let i = 0 ; i < n ; i ++ ) { a [ i ] = ( a [ i ] / m + ( a [ i ] % m ) ) ; } let ans = - 1 , max = - 1 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( max < a [ i ] ) { max = a [ i ] ; ans = i ; } } return ans + 1 ; } let a = [ 2 , 5 , 4 ] ; let n = a . length ; let m = 2 ; document . write ( getPosition ( a , n , m ) ) ;
function calcFunction ( n , r ) { var finalDenominator = 1 ; var mx = Math . max ( r , n - r ) ; for ( var i = mx + 1 ; i <= n ; i ++ ) { var denominator = Math . pow ( i , i ) ; var numerator = Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; } var n = 6 , r = 2 ; document . write ( " " + calcFunction ( n , r ) ) ;
function findNum ( div , rem , N ) { var num = rem [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { num = num * div [ i ] + rem [ i ] ; } return num ; } var div = [ 8 , 3 ] ; var rem = [ 2 , 2 ] ; var N = div . length ; document . write ( findNum ( div , rem , N ) ) ;
function profitLoss ( N , M ) { if ( N == M ) document . write ( " " ) ; else { var result = 0.0 ; result = ( Math . abs ( N - M ) ) / M ; if ( N - M < 0 ) document . write ( " " + result . toFixed ( 6 ) * 100 + " " ) ; else document . write ( " " + result . toFixed ( 6 ) * 100 + " " ) ; } } var N = 8 , M = 9 ; profitLoss ( N , M ) ;
function countPieces ( N ) { return 2 * N ; } let N = 100 ; document . write ( countPieces ( N ) ) ;
function sumAP ( n , d ) { n = parseInt ( n / d ) ; return ( n ) * ( 1 + n ) * ( d / 2 ) ; } function sumMultiples ( n ) { n -- ; return sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ; } let n = 24 ; document . write ( sumMultiples ( n ) ) ;
function productSumDivisible ( n , size ) { var sum = 0 , product = 1 ; while ( n > 0 ) { if ( size % 2 == 0 ) { product *= n % 10 ; } else { sum += n % 10 ; } n = parseInt ( n / 10 ) ; size -- ; } if ( product % sum == 0 ) return true ; return false ; } var n = 1234 ; var len = 4 ; if ( productSumDivisible ( n , len ) ) document . write ( " " ) ; else document . write ( " " ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function powGCD ( a , n , b ) { for ( i = 0 ; i < n ; i ++ ) a = a * a ; return gcd ( a , b ) ; } var a = 10 , b = 5 , n = 2 ; document . write ( powGCD ( a , n , b ) ) ;
function lastCoordinate ( n , a , b ) { return ( parseInt ( n + 1 ) / 2 ) * a - parseInt ( n / 2 ) * b ; } let n = 3 , a = 5 , b = 2 ; document . write ( lastCoordinate ( n , a , b ) ) ;
function findNum ( N , K ) { var rem = ( N + K ) % K ; if ( rem == 0 ) return N ; else return N + K - rem ; } var N = 45 , K = 6 ; document . write ( " " + N + " " + K + " " + findNum ( N , K ) ) ;
function countDigit ( n ) { let temp = n ; let sum = 0 ; let product = 1 ; while ( temp != 0 ) { let d = temp % 10 ; temp = parseInt ( temp / 10 ) ; if ( d > 0 && n % d == 0 ) { sum += d ; product *= d ; } } document . write ( " " + sum ) ; document . write ( " " + product ) ; } let n = 1012 ; countDigit ( n ) ;
function findNum ( N , K ) { var rem = N % K ; if ( rem == 0 ) return N ; else return N - rem ; } var N = 45 , K = 6 ; document . write ( " " + N + " " + K + " " + findNum ( N , K ) ) ;
function isDivisiblePalindrome ( n ) { var hash = Array ( 10 ) . fill ( 0 ) ; var digitSum = 0 ; while ( n ) { digitSum += n % 10 ; hash [ n % 10 ] ++ ; n = parseInt ( n / 10 ) ; } if ( digitSum % 3 != 0 ) return false ; var oddCount = 0 ; for ( var i = 0 ; i < 10 ; i ++ ) { if ( hash [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount > 1 ) return false ; else return true ; } var n = 34734 ; isDivisiblePalindrome ( n ) ? document . write ( " " ) : document . write ( " " ) ;
function productDivisible ( n , k ) { var product = 1 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 0 ) product *= n % 10 ; n = parseInt ( n / 10 ) ; position ++ ; } if ( product % k == 0 ) return true ; return false ; } var n = 321922 ; var k = 3 ; if ( productDivisible ( n , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
function factorial ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } function npr ( n , r ) { let pnr = Math . floor ( factorial ( n ) / factorial ( n - r ) ) ; return pnr ; } function countPermutations ( n , r , k ) { return factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ; } let n = 8 ; let r = 5 ; let k = 2 ; document . write ( countPermutations ( n , r , k ) ) ;
function GIF ( n ) { return Math . floor ( n ) ; } var n = 2.3 ; document . write ( GIF ( n ) ) ;
function factorial ( n ) { var fact = 1 ; for ( i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } function ncr ( n , r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } var m = 3 , n = 4 , k = 5 ; var totalTriangles = ncr ( m + n + k , 3 ) - ncr ( m , 3 ) - ncr ( n , 3 ) - ncr ( k , 3 ) ; document . write ( totalTriangles ) ;
function SumDivisible ( n , k ) { let sum = 0 , position = 1 ; while ( n > 0 ) { if ( position % 2 == 1 ) sum += n % 10 ; n = Math . floor ( n / 10 ) ; position ++ ; } if ( sum % k == 0 ) return true ; return false ; } let n = 592452 ; let k = 3 ; if ( SumDivisible ( n , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isTriangleExists ( a , b , c ) { if ( a != 0 && b != 0 && c != 0 && ( a + b + c ) == 180 ) if ( ( a + b ) >= c || ( b + c ) >= a || ( a + c ) >= b ) return " " ; else return " " ; else return " " ; } var a = 50 , b = 60 , c = 70 ; document . write ( isTriangleExists ( a , b , c ) ) ;
function findX ( n , k ) { let r = n ; let v = 0 ; let u = 0 ; let m = Math . floor ( Math . sqrt ( k ) + 1 ) ; for ( let i = 2 ; i <= m && k > 1 ; i ++ ) { if ( i == m ) { i = k ; } for ( let u = v = 0 ; k % i == 0 ; v ++ ) { k = Math . floor ( k / i ) ; } if ( v > 0 ) { let t = n ; while ( t > 0 ) { t = Math . floor ( t / i ) ; u += t ; } r = Math . min ( r , Math . floor ( u / v ) ) ; } } return r ; } let n = 5 ; let k = 2 ; document . write ( findX ( n , k ) ) ;
function fact ( n ) { var fact = 1 ; for ( i = 2 ; i <= n ; i ++ ) fact *= i ; return fact ; } function ncr ( n , r ) { var ncr = fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; return parseInt ( ncr ) ; } function ways ( m , w , n , k ) { var ans = 0 ; while ( m >= k ) { ans += ncr ( m , k ) * ncr ( w , n - k ) ; k += 1 ; } return parseInt ( ans ) ; } var m , w , n , k ; m = 7 ; w = 6 ; n = 5 ; k = 3 ; document . write ( ways ( m , w , n , k ) ) ;
function square ( n ) { return n * n ; } function sum ( n ) { if ( n == 0 ) return 0 ; if ( n % 2 == 1 ) { return square ( ( n + 1 ) / 2 ) + sum ( n / 2 ) ; } else { return square ( n / 2 ) + sum ( n / 2 ) ; } } function oddDivSum ( a , b ) { return sum ( b ) - sum ( a - 1 ) ; } var a = 3 , b = 9 ; document . write ( parseInt ( oddDivSum ( a , b ) ) ) ;
function countBits ( n ) { var count = 0 ; while ( n ) { count ++ ; n >>= 1 ; } return count ; } var n = 32 ; document . write ( " " + countBits ( n ) ) ;
function isPowerful ( n ) { while ( n % 2 == 0 ) { let power = 0 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 , 10 ) ; power ++ ; } if ( power == 1 ) return false ; } for ( let factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { let power = 0 ; while ( n % factor == 0 ) { n = parseInt ( n / factor , 10 ) ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } function isPower ( a ) { if ( a == 1 ) return true ; for ( let i = 2 ; i * i <= a ; i ++ ) { let val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - parseInt ( val , 10 ) ) < 0.00000001 ) return true ; } return false ; } function isAchillesNumber ( n ) { if ( isPowerful ( n ) && ! isPower ( n ) ) return true ; else return false ; } let n = 72 ; if ( isAchillesNumber ( n ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; n = 36 ; if ( isAchillesNumber ( n ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function OddDivCount ( a , b ) { let res = 0 ; for ( let i = a ; i <= b ; ++ i ) { let divCount = 0 ; for ( let j = 1 ; j <= i ; ++ j ) { if ( i % j == 0 ) { ++ divCount ; } } if ( ( divCount % 2 ) != 0 ) { ++ res ; } } return res ; } let a = 1 , b = 10 ; document . write ( OddDivCount ( a , b ) ) ;
function largestSquareFactor ( num ) { let answer = 1 ; for ( let i = 2 ; i < Math . sqrt ( num ) ; ++ i ) { let cnt = 0 ; let j = i ; while ( num % j == 0 ) { cnt ++ ; j *= i ; } if ( cnt & 1 ) { cnt -- ; answer *= Math . pow ( i , cnt ) ; } else { answer *= Math . pow ( i , cnt ) ; } } return answer ; } let N = 420 ; document . write ( largestSquareFactor ( N ) ) ;
function Nth_Term ( n ) { return ( 3 * Math . pow ( n , 2 ) - n + 2 ) / ( 2 ) ; } let N = 5 ; document . write ( Nth_Term ( N ) ) ;
function countPermutations ( N , B ) { var x = Math . pow ( B , N ) ; var y = Math . pow ( B , N - 1 ) ; document . write ( x - y ) ; } var N = 6 ; var B = 4 ; countPermutations ( N , B ) ;
function calculateDifference ( arr , n ) { var max_val = Math . max . apply ( Math , arr ) ; var prime = Array ( max_val + 1 ) . fill ( true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } var P1 = 1 , P2 = 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { P1 *= arr [ i ] ; } else if ( arr [ i ] != 1 ) { P2 *= arr [ i ] ; } } return Math . abs ( P2 - P1 ) ; } var arr = [ 1 , 3 , 5 , 10 , 15 , 7 ] ; var n = arr . length ; document . write ( calculateDifference ( arr , n ) ) ;
function EqualNumbers ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] ; if ( sum % n ) return n - 1 ; return n ; } let a = [ 1 , 4 , 1 ] ; let n = a . length ; document . write ( EqualNumbers ( a , n ) ) ;
function count_odd_pair ( n , a ) { var odd = 0 , even = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } var ans = odd * even * 2 ; return ans ; } function count_even_pair ( odd_sum_pairs , n ) { var total_pairs = ( n * ( n - 1 ) ) ; var ans = total_pairs - odd_sum_pairs ; return ans ; } var n = 6 ; var a = [ 2 , 4 , 5 , 9 , 1 , 8 ] ; var odd_sum_pairs = count_odd_pair ( n , a ) ; var even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) ; document . write ( " " + even_sum_pairs + " " ) ; document . write ( " " + odd_sum_pairs + " " ) ;
function findSteps ( n , m , a ) { var cur = 1 ; var steps = 0 ; for ( var i = 0 ; i < m ; i ++ ) { if ( a [ i ] >= cur ) steps += ( a [ i ] - cur ) ; else steps += ( n - cur + a [ i ] ) ; cur = a [ i ] ; } return steps ; } var n = 3 , m = 3 ; var a = [ 2 , 1 , 2 ] ; document . write ( findSteps ( n , m , a ) ) ;
function isPowerOfTwo ( x ) { return ( x > 0 && ( ! ( ( x & ( x - 1 ) ) > 0 ) ) ) ; } function Count_pairs ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) ) count ++ ; } let ans = ( count * ( count - 1 ) ) / 2 ; document . write ( ans ) ; } let a = [ 2 , 5 , 8 , 16 , 128 ] ; let n = a . length ; Count_pairs ( a , n ) ;
function factorial ( n ) { let result = 1 ; for ( let i = 1 ; i <= n ; i ++ ) result = result * i ; return result ; } function nCr ( n , r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } function calculate_result ( n ) { let result = 2 * nCr ( ( n - 2 ) , ( n / 2 - 1 ) ) ; return result ; } let a = 2 ; let b = 4 ; document . write ( calculate_result ( 2 * a ) + " " ) ; document . write ( calculate_result ( 2 * b ) + " " ) ;
function PossibleValues ( b , x , n ) { let leastdivisible = ( Math . floor ( b / x ) + 1 ) * x ; let flag = 1 ; while ( leastdivisible <= n ) { if ( leastdivisible - b >= 1 ) { document . write ( leastdivisible - b + " " ) ; leastdivisible += x ; flag = 0 ; } else break ; } if ( flag > 0 ) document . write ( - 1 + " " ) ; } let b = 10 , x = 6 , n = 40 ; PossibleValues ( b , x , n ) ;
function digitProduct ( digits , start , end ) { let pro = 1 ; for ( let i = start ; i <= end ; i ++ ) { pro *= digits [ i ] ; } return pro ; } function isDistinct ( N ) { let s = " " ; let len = s . length ; let digits = new Array ( ) ; let products = new Array ( ) ; for ( let i = 0 ; i < len ; i ++ ) { digits [ i ] = s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; } for ( let i = 0 ; i < len ; i ++ ) { for ( let j = i ; j < len ; j ++ ) { let val = digitProduct ( digits , i , j ) ; if ( products . includes ( val ) ) return false ; else products . push ( val ) ; } } return true ; } let N = 324 ; if ( isDistinct ( N ) ) document . write ( " " ) ; else document . write ( " " ) ;
function nthHilbertNumber ( n ) { return 4 * ( n - 1 ) + 1 ; } var n = 5 ; document . write ( nthHilbertNumber ( n ) ) ;
function nthKyneaNumber ( n ) { n = ( 1 << n ) + 1 ; n = n * n ; n = n - 2 ; return n ; } let n = 8 ; document . write ( nthKyneaNumber ( n ) ) ;
function nthKyneaNumber ( n ) { return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) ; } let n = 2 ; document . write ( nthKyneaNumber ( n ) ) ;
function isPowerOfTwo ( n ) { return ( n && ! ( n & ( n - 1 ) ) ) ; } function isProthNumber ( n ) { let k = 1 ; while ( k < parseInt ( n / k ) ) { if ( n % k == 0 ) { if ( isPowerOfTwo ( parseInt ( n / k ) ) ) return true ; } k = k + 2 ; } return false ; } let n = 25 ; if ( isProthNumber ( n - 1 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function get_last_two_digit ( N ) { if ( N <= 10 ) { let ans = 0 , fac = 1 ; for ( let i = 1 ; i <= N ; i ++ ) { fac = fac * i ; ans += fac ; } return ans % 100 ; } return 13 ; } let N = 1 ; for ( N = 1 ; N <= 10 ; N ++ ) document . write ( " " + N + " " + get_last_two_digit ( N ) + " " ) ;
function isProductEven ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) if ( ( arr [ i ] & 1 ) == 0 ) return true ; return false ; } let arr = [ 2 , 4 , 3 , 5 ] ; let n = arr . length ; if ( isProductEven ( arr , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function calculateSquareSum ( n ) { if ( n <= 0 ) return 0 ; var fibo = Array ( n + 1 ) . fill ( 0 ) ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; var sum = ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ; for ( i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += ( fibo [ i ] * fibo [ i ] ) ; } return sum ; } var n = 6 ; document . write ( " " + calculateSquareSum ( n ) ) ;
function fnMod ( n ) { var rem = n % 4 ; if ( rem == 0 rem == 3 ) return 0 ; else if ( rem == 1 rem == 2 ) return 1 ; return 0 ; } var n = 6 ; document . write ( fnMod ( n ) ) ;
function MinimumMoves ( a , n , x ) { var ans = 0 ; for ( i = 1 ; i < n ; i ++ ) { if ( a [ i ] <= a [ i - 1 ] ) { var p = parseInt ( ( a [ i - 1 ] - a [ i ] ) / x + 1 ) ; ans += p ; a [ i ] += p * x ; } } return ans ; } var arr = [ 1 , 3 , 3 , 2 ] ; var x = 2 ; var n = arr . length ; document . write ( MinimumMoves ( arr , n , x ) ) ;
function SumOfDigits ( str , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += ( str . charAt ( i ) - ' ' ) ; return sum ; } function Divisible ( str , n ) { if ( SumOfDigits ( str , n ) % 3 == 0 && str . charAt ( n - 1 ) == ' ' ) return true ; return false ; } var str = " " ; var n = str . length ; if ( Divisible ( str , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isPrime ( k ) { if ( k <= 1 ) return false ; for ( let i = 2 ; i < k ; i ++ ) if ( k % i == 0 ) return false ; return true ; } function check ( num , k ) { let flag = 1 ; for ( let i = 2 ; i < k ; i ++ ) { if ( num % i == 0 ) flag = 0 ; } if ( flag == 1 ) { if ( num % k == 0 ) return 1 ; else return 0 ; } else return 0 ; } function findCount ( a , b , k ) { let count = 0 ; if ( ! isPrime ( k ) ) return 0 ; else { let ans ; for ( let i = a ; i <= b ; i ++ ) { ans = check ( i , k ) ; if ( ans == 1 ) count ++ ; else continue ; } } return count ; } let a = 2020 , b = 6300 , k = 29 ; document . write ( findCount ( a , b , k ) ) ;
function NumberOfSolutions ( a , b , c , d ) { let ans = 0 ; for ( let i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; } let a = 2 , b = 3 , c = 3 , d = 4 ; document . write ( NumberOfSolutions ( a , b , c , d ) ) ;
function findF_N ( n ) { var ans = 0 ; for ( var i = 0 ; i < n ; ++ i ) ans += ( i + 1 ) * ( n - i - 1 ) ; return ans ; } var n = 3 ; document . write ( findF_N ( n ) ) ;
function findNumber ( n , d ) { let ans = " " ; if ( d != 10 ) { ans += ( d ) . toString ( ) ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } else { if ( n == 1 ) ans += " " ; else { ans += ' ' ; for ( let i = 1 ; i < n ; i ++ ) ans += ' ' ; } } return ans ; } let n = 12 , d = 3 ; document . write ( findNumber ( n , d ) ) ;
var MAX = 1000000 ; var sieve_Prime = Array . from ( { length : MAX + 4 } , ( _ , i ) => 0 ) ; var sieve_count = Array . from ( { length : MAX + 4 } , ( _ , i ) => 0 ) ; function form_sieve ( ) { sieve_Prime [ 1 ] = 1 ; for ( i = 2 ; i <= MAX ; i ++ ) { if ( sieve_Prime [ i ] == 0 ) { for ( j = i * 2 ; j <= MAX ; j += i ) { if ( sieve_Prime [ j ] == 0 ) { sieve_Prime [ j ] = 1 ; sieve_count [ i ] ++ ; } } } } } form_sieve ( ) ; var n = 2 ; document . write ( " " + ( sieve_count [ n ] + 1 ) ) ; n = 3 ; document . write ( " " + ( sieve_count [ n ] + 1 ) ) ;
function PrimeFactors ( n ) { let v = [ ] ; let x = n ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( x % i == 0 ) { v . push ( i ) ; while ( x % i == 0 ) x = Math . floor ( x / i ) ; } } if ( x > 1 ) v . push ( x ) ; return v ; } function GoodNumber ( n ) { let v = PrimeFactors ( n ) ; let ans = 1 ; for ( let i = 0 ; i < v . length ; i ++ ) ans *= v [ i ] ; return ans ; } let n = 12 ; document . write ( GoodNumber ( n ) ) ;
function checkSpecialPrime ( sieve , num ) { while ( num != 0 ) { if ( ! sieve [ num ] ) { return false ; } num = Math . floor ( num / 10 ) ; } return true ; } function findSpecialPrime ( N ) { let sieve = new Array ( N + 10 ) ; sieve [ 0 ] = sieve [ 1 ] = false ; for ( let i = 0 ; i < N + 10 ; i ++ ) sieve [ i ] = true ; for ( let i = 2 ; i <= N ; i ++ ) { if ( sieve [ i ] ) { for ( let j = i * i ; j <= N ; j += i ) { sieve [ j ] = false ; } } } while ( true ) { if ( checkSpecialPrime ( sieve , N ) ) { document . write ( N + " " ) ; break ; } else N -- ; } } findSpecialPrime ( 379 ) ; findSpecialPrime ( 100 ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( var i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } var n = 13 ; if ( isPrime ( n ) && ( n % 4 == 1 ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function heightCalculate ( H , n , m ) { let N = n * 1.0 ; let M = m * 1.0 ; let h = H * Math . sqrt ( N / ( N + M ) ) ; return h ; } let H = 10 , n = 3 , m = 4 ; document . write ( heightCalculate ( H , n , m ) ) ;
function isprime ( x ) { for ( var i = 2 ; i * i <= x ; i ++ ) if ( x % i == 0 ) return false ; return true ; } function isNSqMinusnMSqPrime ( m , n ) { if ( n - m == 1 && isprime ( m + n ) ) return true ; else return false ; } var m = 13 , n = 16 ; if ( isNSqMinusnMSqPrime ( m , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findsolution ( n , x , y ) { if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x y < n ) { document . write ( " " ) ; return ; } document . write ( y - n + 1 ) ; while ( n -- > 1 ) document . write ( " " + 1 ) ; } let n = 5 ; let x = 15 ; let y = 15 ; findsolution ( n , x , y ) ;
function findPosition ( n , f , b ) { return n - Math . max ( f + 1 , n - b ) + 1 ; } let n = 5 , f = 2 , b = 3 ; document . write ( findPosition ( n , f , b ) ) ;
function nthOdd ( n ) { return ( 2 * n - 1 ) ; } var n = 10 ; document . write ( nthOdd ( n ) ) ;
function nthHarmonic ( N ) { let harmonic = 1.00 ; for ( let i = 2 ; i <= N ; i ++ ) { harmonic += parseFloat ( 1 ) / i ; } return harmonic ; } let N = 8 ; document . write ( nthHarmonic ( N ) . toFixed ( 5 ) ) ;
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + n - 3 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function nthTerm ( n ) { return 5 * Math . pow ( n , 2 ) - 5 * n ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) + n - 2 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 4 * n - 2 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function nthTerm ( n ) { return 3 * Math . pow ( n , 2 ) + 2 * n - 5 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) + 3 * n - 5 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 3 * n + 2 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
let PI = 3.1415926535 ; function findAnglesA ( a , b , c ) { let A = Math . acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) ; return A * 180 / PI ; } function findAnglesB ( a , b , c ) { let B = Math . acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) ; return B * 180 / PI ; } function printAngles ( a , b , c ) { let x = a ; let y = b ; let z = c ; let A = findAnglesA ( x , y , z ) ; let B = findAnglesB ( x , y , z ) ; document . write ( " " + A + " " + B + " " + 90 ) ; } function printOtherSides ( n ) { let b = 0 , c = 0 ; if ( ( n & 1 ) > 0 ) { if ( n == 1 ) document . write ( - 1 ) ; else { b = ( n * n - 1 ) / 2 ; c = ( n * n + 1 ) / 2 ; document . write ( " " + b + " " + c ) ; } } else { if ( n == 2 ) document . write ( - 1 ) ; else { b = n * n / 4 - 1 ; c = n * n / 4 + 1 ; document . write ( " " + b + " " + c + " " ) ; } } printAngles ( n , b , c ) ; } let a = 12 ; printOtherSides ( a ) ;
function calculateSum ( n ) { return n * ( n + 1 ) / 2 + n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; } let n = 3 ; document . write ( " " + calculateSum ( n ) ) ;
function nthTerm ( n ) { return 2 * Math . pow ( n , 2 ) - n - 1 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function nthTerm ( n ) { return 4 * Math . pow ( n , 2 ) - 7 * n + 3 ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function checkIfPowerIsolated ( num ) { let input = num ; let count = 0 ; let factor = new Array ( 0 ) ; if ( num % 2 == 0 ) { while ( num % 2 == 0 ) { ++ count ; num /= 2 ; } factor [ 2 ] = count ; } for ( let i = 3 ; i * i <= num ; i += 2 ) { count = 0 ; while ( num % i == 0 ) { ++ count ; num /= i ; } if ( count > 0 ) factor [ i ] = count ; } if ( num > 1 ) factor [ num ] = 1 ; let product = 1 ; for ( let i = 0 ; i < num + 1 ; i ++ ) { if ( factor [ i ] > 0 ) product = product * factor [ i ] * i ; } if ( product == input ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; } checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ;
function getNthTerm ( N ) { return ( Math . pow ( N , 2 ) + N + 1 ) ; } let N = 11 ; document . write ( getNthTerm ( N ) ) ;
function findSum ( n ) { var sum2 , sum5 , sum10 ; sum2 = parseInt ( ( parseInt ( n / 2 ) * ( 4 + ( parseInt ( n / 2 ) - 1 ) * 2 ) ) / 2 ) ; sum5 = parseInt ( ( parseInt ( n / 5 ) * ( 10 + ( parseInt ( n / 5 ) - 1 ) * 5 ) ) / 2 ) ; sum10 = parseInt ( ( parseInt ( n / 10 ) * ( 20 + ( parseInt ( n / 10 ) - 1 ) * 10 ) ) / 2 ) ; return sum2 + sum5 - sum10 ; } var n = 5 ; document . write ( findSum ( n ) ) ;
function CalculateRatio ( m , n ) { return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; } let m = 6 , n = 2 ; document . write ( CalculateRatio ( m , n ) ) ;
function calculateSum ( n ) { return parseInt ( Math . pow ( n * ( n + 1 ) / 2 , 2 ) ) ; } var n = 4 ; document . write ( calculateSum ( n ) ) ;
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } function powerDigitSum ( a , n ) { let res = 1 ; while ( n ) { if ( n % 2 == 1 ) { res = res * digSum ( a ) ; res = digSum ( res ) ; } a = digSum ( digSum ( a ) * digSum ( a ) ) ; n /= 2 ; } return res ; } let a = 9 , n = 4 ; document . write ( powerDigitSum ( a , n ) ) ;
function totEdge ( n ) { var result = 0 ; result = ( n * ( n - 1 ) ) / 2 ; return result ; } var n = 6 ; document . write ( totEdge ( n ) ) ;
function coin ( totalRupees , X , Y , Z ) { var one = 0 , fifty = 0 , twentyfive = 0 , result = 0 , total = 0 ; one = X * 1 ; fifty = ( ( Y * 1 ) / 2.0 ) ; twentyfive = ( ( Z * 1 ) / 4.0 ) ; total = one + fifty + twentyfive ; result = ( ( totalRupees ) / total ) ; return result ; } var totalRupees = 1800 ; var X = 1 , Y = 2 , Z = 4 ; var Rupees = coin ( totalRupees , X , Y , Z ) ; document . write ( " " + Rupees * 1 + " " ) ; document . write ( " " + Rupees * 2 + " " ) ; document . write ( " " + Rupees * 4 + " " ) ;
function sumOfSeries ( x , k ) { var y = ( ( ( x ) / 81 ) * ( 9 * k - 1 + Math . pow ( 10 , ( - 1 ) * k ) ) ) ; return y ; } var x = 9 ; var k = 20 ; document . write ( sumOfSeries ( x , k ) ) ;
function modExp ( a , b ) { let result = 1 ; while ( b > 0 ) { if ( b == 1 ) result = result * a ; a = a * a ; b = Math . floor ( b / 2 ) ; } return result ; } function check ( num ) { if ( num == 1 num < 3 ) return - 1 ; else if ( num % 4 == 0 ) return modExp ( Math . floor ( num / 4 ) , 4 ) ; else if ( num % 6 == 0 ) return modExp ( Math . floor ( num / 3 ) , 2 ) * modExp ( Math . floor ( num / 6 ) , 2 ) ; else if ( num % 10 == 0 ) return modExp ( Math . floor ( num / 5 ) , 2 ) * Math . floor ( num / 10 ) * Math . floor ( num / 2 ) ; else return - 1 ; } let num = 10 ; document . write ( check ( num ) ) ;
function isDivisible ( n ) { while ( Math . floor ( n / 100 ) > 0 ) { let d = n % 10 ; n = Math . floor ( n / 10 ) ; n -= d * 5 ; } return ( n % 17 == 0 ) ; } let n = 19877658 ; if ( isDivisible ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function nextPowerOf2 ( n ) { let count = 0 ; if ( n && ! ( n & ( n - 1 ) ) ) return n ; while ( n != 0 ) { n >>= 1 ; count += 1 ; } return 1 << count ; } function removeElement ( n ) { if ( n == 1 n == 2 ) return 0 ; let a = nextPowerOf2 ( n ) ; if ( n == a n == a - 1 ) return 1 ; else if ( n == a - 2 ) return 0 ; else if ( n % 2 == 0 ) return 1 ; else return 2 ; } let n = 5 ; document . write ( removeElement ( n ) ) ;
function bridge_length ( trainLength , Speed , Time ) { return ( ( Time * Speed ) - trainLength ) ; } var trainLength = 120 ; var Speed = 30 ; var Time = 18 ; document . write ( " " + bridge_length ( trainLength , Speed , Time ) + " " ) ;
var MOD = 100000007 ; function modInv ( x ) { var n = MOD - 2 ; var result = 1 ; while ( n ) { if ( n & 1 ) result = result * x % MOD ; x = x * x % MOD ; n = n / 2 ; } return result ; } function getSum ( n , k ) { var ans = 1 ; for ( var i = n + 1 ; i > n - k ; i -- ) ans = ans * i % MOD ; ans = ans * modInv ( k + 1 ) % MOD ; return ans ; } var n = 3 , k = 2 ; document . write ( getSum ( n , k ) ) ;
function printCombination ( n ) { document . write ( 1 + " " ) ; if ( ( n - 2 ) % 3 == 0 ) document . write ( 2 + " " + ( n - 3 ) ) ; else document . write ( 1 + " " + ( n - 2 ) ) ; } let n = 233 ; printCombination ( n ) ;
function checkPairs ( l , r ) { if ( ( l - r ) % 2 == 0 ) return false ; return true ; } var l = 1 , r = 8 ; if ( checkPairs ( l , r ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isPalindrome ( n ) { if ( n % 11 == 0 ) { return true ; } return false ; } document . write ( isPalindrome ( 123321 ) ? " " : " " ) ;
var target = 93 ; var arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] ; var length = arr . length ; var totalCount = 0 ; for ( var i = 0 ; i < length - 2 ; i ++ ) { if ( target % arr [ i ] == 0 ) { for ( var j = i + 1 ; j < length - 1 ; j ++ ) { if ( target % ( arr [ i ] * arr [ j ] ) == 0 ) { var toFind = target / ( arr [ i ] * arr [ j ] ) ; for ( var k = j + 1 ; k < length ; k ++ ) { if ( arr [ k ] == toFind ) { totalCount ++ ; } } } } } } document . write ( " " + totalCount ) ;
function binomialCoeff ( n , k ) { var res = 1 ; if ( k > n - k ) k = n - k ; for ( var i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function catalan ( n ) { var c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } var n = 3 ; document . write ( catalan ( n ) ) ;
function isFascinating ( num ) { let freq = new Array ( 10 ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } let val = " " + num + num * 2 + num * 3 ; for ( let i = 0 ; i < val . length ; i ++ ) { let digit = val [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; if ( freq [ digit ] > 0 && digit != 0 ) return false ; else freq [ digit ] ++ ; } for ( let i = 1 ; i < freq . length ; i ++ ) { if ( freq [ i ] == 0 ) return false ; } return true ; } let num = 192 ; if ( num < 100 ) document . write ( " " ) ; else { let ans = isFascinating ( num ) ; if ( ans ) document . write ( " " ) ; else document . write ( " " ) ; }
function binomial_coefficient ( n , m ) { let res = 1 ; if ( m > n - m ) m = n - m ; for ( let i = 0 ; i < m ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function calculate_ways ( m , n ) { if ( m < n ) return 0 ; let ways = binomial_coefficient ( n + m - 1 , n - 1 ) ; return ways ; } let m = 7 , n = 5 ; let result = calculate_ways ( m , n ) ; document . write ( result ) ;
let N = 100005 ; let phi = new Array ( N ) ; let S = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { phi [ i ] = 0 ; S [ i ] = 0 ; } function computeTotient ( ) { for ( let i = 1 ; i < N ; i ++ ) phi [ i ] = i ; for ( let p = 2 ; p < N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( let i = 2 * p ; i < N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } } function CoPrimes ( ) { computeTotient ( ) ; for ( let i = 1 ; i < N ; i ++ ) S [ i ] = S [ i - 1 ] + phi [ i ] ; } CoPrimes ( ) ; let q = [ 3 , 4 ] ; let n = q . length ; for ( let i = 0 ; i < n ; i ++ ) document . write ( " " + " " + q [ i ] + " " + S [ q [ i ] ] + " " ) ;
function binaryToDecimal ( n ) { let num = n ; let dec_value = 0 ; let base = 1 ; let len = num . length ; for ( let i = len - 1 ; i >= 0 ; i -- ) { if ( num [ i ] == ' ' ) dec_value += base ; base = base * 2 ; } return dec_value ; } function numberSequence ( n ) { if ( n == 1 ) return 1 ; let s = " " ; for ( let i = 1 ; i < n ; i ++ ) s += ' ' ; s += ' ' ; for ( let i = 1 ; i <= n ; i ++ ) s += ' ' ; let num = binaryToDecimal ( s ) ; return num ; } let n = 4 ; document . write ( numberSequence ( n ) ) ;
function numberSequence ( n ) { let num = Math . pow ( 4 , n ) - Math . pow ( 2 , n ) - 1 ; return num ; } let n = 4 ; document . write ( numberSequence ( n ) ) ;
function prime ( num ) { var i , flag = 0 ; for ( i = 2 ; i <= num / 2 ; i ++ ) { if ( num % i == 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) return 1 ; else return 0 ; } function print_alternate_prime ( n ) { var counter = 0 ; for ( num = 2 ; num < n ; num ++ ) { if ( prime ( num ) == 1 ) { if ( counter % 2 == 0 ) document . write ( num + " " ) ; counter ++ ; } } } var n = 15 ; document . write ( " " + " " + " " + n + " " ) ; print_alternate_prime ( n ) ;
function SieveOfEratosthenes ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } let flag = true ; for ( let p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { if ( flag ) { document . write ( p + " " ) ; flag = false ; } else { flag = true ; } } } } let n = 15 ; document . write ( " " + " " + " " + n + " " ) ; SieveOfEratosthenes ( n ) ;
function findGreater ( x , y ) { if ( x > y ) { return false ; } else { return true ; } } var x = 4 ; var y = 9 ; if ( findGreater ( x , y ) ) document . write ( " " ) ; else document . write ( " " ) ;
function max_profit ( a , b , n , fee ) { var i , j , profit ; var l , r , diff_day = 1 , sum = 0 ; b [ 0 ] = 0 ; b [ 1 ] = diff_day ; for ( i = 1 ; i < n ; i ++ ) { l = 0 ; r = diff_day ; sum = 0 ; for ( j = n - 1 ; j >= i ; j -- ) { profit = ( a [ r ] - a [ l ] ) - fee ; if ( profit > 0 ) { sum = sum + profit ; } l ++ ; r ++ ; } if ( b [ 0 ] < sum ) { b [ 0 ] = sum ; b [ 1 ] = diff_day ; } diff_day ++ ; } return 0 ; } var arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] ; var n = arr . length ; var b = Array ( 2 ) . fill ( 0 ) ; var tranFee = 2 ; max_profit ( arr , b , n , tranFee ) ; document . write ( b [ 0 ] + " " + b [ 1 ] ) ;
function binomialCoeff ( x , n , k ) { var sum = 0 , term = 1 ; for ( var i = 1 ; i <= n && sum < k ; ++ i ) { term *= x - i + 1 ; term /= i ; sum += term ; } return sum ; } function minTrials ( n , k ) { var low = 1 , high = k ; while ( low < high ) { var mid = parseInt ( ( low + high ) / 2 ) ; if ( binomialCoeff ( mid , n , k ) < k ) low = mid + 1 ; else high = mid ; } return low ; } document . write ( minTrials ( 2 , 10 ) ) ;
function isPrime ( num ) { if ( num < 2 num % 2 == 0 ) return num == 2 ; for ( i = 3 ; i * i <= num ; i += 2 ) if ( num % i == 0 ) return false ; return true ; } function primePalindrome ( N ) { if ( 8 <= N && N <= 11 ) return 11 ; for ( let x = 1 ; x < 100000 ; ++ x ) { let s = String ( x ) ; let r = s . split ( " " ) . reverse ( ) . join ( " " ) ; let y = parseInt ( s + r . substr ( 1 ) ) ; if ( y >= N && isPrime ( y ) == true ) return y ; } return - 1 ; } document . write ( primePalindrome ( 112 ) ) ;
function getsum ( a ) { let r = 0 , sum = 0 ; while ( a > 0 ) { r = a % 10 ; sum = sum + r ; a = Math . floor ( a / 10 ) ; } return sum ; } function value ( a , b , c ) { let co = 0 , p = 0 ; let no , r = 0 , x = 0 , q = 0 , w = 0 ; let v = [ ] ; for ( let i = 1 ; i < 82 ; i ++ ) { no = Math . pow ( i , a ) ; no = b * no + c ; if ( no > 0 && no < 1000000000 ) { x = getsum ( no ) ; if ( x == i ) { q ++ ; v . push ( no ) ; w ++ ; } } } for ( let i = 0 ; i < v . length ; i ++ ) { document . write ( v [ i ] + " " ) ; } } let a = 2 , b = 2 , c = - 1 ; value ( a , b , c ) ;
function print ( p0 ) { var p1 , i = 0 , x , flag = 1 , k , m = 4 ; while ( flag ) { flag = 1 ; x = Math . pow ( 2 , i ) ; p1 = x * p0 - ( x - 1 ) ; for ( k = 2 ; k < p1 ; k ++ ) { if ( p1 % k == 0 ) { flag = 0 ; break ; } } if ( flag == 0 ) break ; document . write ( p1 + " " ) ; i ++ ; } } var p0 = 19 ; print ( p0 ) ;
function findOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ( A [ i ] % 2 == 1 ) ) count ++ ; return count * ( count - 1 ) / 2 ; } let a = [ 5 , 1 , 3 , 2 ] ; let n = a . length ; document . write ( findOddPair ( a , n ) ) ;
function isSurd ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { let j = i ; while ( j < n ) j = j * i ; if ( j == n ) return false ; } return true ; } let n = 15 ; if ( isSurd ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function LastTwoDigit ( num ) { let one = num % 10 ; num = Math . floor ( num / 10 ) ; let tens = num % 10 ; tens *= 10 ; num = tens + one ; return num ; } let n = 10 ; let num = 1 ; num = Math . pow ( 2 , n ) ; document . write ( " " + 2 ) ; document . write ( " " + 2 ) ; document . write ( " " + n + " " ) ; document . write ( LastTwoDigit ( num ) + " " ) ;
function power ( x , y , p ) { while ( y > 0 ) { let r = y & 1 ; if ( r == 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function numberOfDigits ( x ) { let i = 0 ; while ( x != 0 ) { x /= 10 ; i ++ ; } return i ; } function LastTwoDigit ( n ) { document . write ( " " + 2 + " " + 2 + " " ) ; document . write ( n + " " ) ; let temp = 1 ; for ( let i = 1 ; i <= 2 ; i ++ ) temp *= 10 ; temp = power ( 2 , n , temp ) ; for ( let i = 0 ; i < ( 2 - numberOfDigits ( temp ) ) ; i ++ ) document . write ( 0 + " " ) ; if ( temp != 0 ) document . write ( temp ) ; } let n = 72 ; LastTwoDigit ( n ) ;
function modPower ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function gcdPow ( a , n , c ) { if ( a % c == 0 ) return c ; let modexpo = modPower ( a , n , c ) ; return gcd ( modexpo , c ) ; } let a = 10248585 , n = 1000000 , c = 12564 ; document . write ( gcdPow ( a , n , c ) ) ;
function countOddSum ( ar , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let val = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { val = val + ar [ j ] ; if ( val % 2 != 0 ) result ++ ; } } return ( result ) ; } let ar = [ 5 , 4 , 4 , 5 , 1 , 3 ] ; let n = ar . length ; document . write ( " " + " " ) ; document . write ( countOddSum ( ar , n ) ) ;
function countOddSum ( ar , n ) { let temp = [ 1 , 0 ] ; let result = 0 , val = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 ; temp [ val ] ++ ; } result = temp [ 0 ] * temp [ 1 ] ; return ( result ) ; } let ar = [ 5 , 4 , 4 , 5 , 1 , 3 ] ; let n = ar . length ; document . write ( " " + " " + countOddSum ( ar , n ) ) ;
function printPFsInPairs ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) if ( n % i == 0 ) document . write ( i + " " + parseInt ( n / i ) + " " ) ; } let n = 24 ; printPFsInPairs ( n ) ;
function rangesum ( n , l , r ) { let arr = new Array ( n ) ; let c = 1 , i = 0 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } c = 2 ; while ( c <= n ) { arr [ i ++ ] = c ; c += 2 ; } let sum = 0 ; for ( i = l - 1 ; i < r ; i ++ ) { sum += arr [ i ] ; } return sum ; } let n = 12 ; let l = 1 , r = 11 ; document . write ( rangesum ( n , l , r ) ) ;
function findAngle ( n ) { let interiorAngle , exteriorAngle ; interiorAngle = Math . floor ( ( n - 2 ) * 180 / n ) ; exteriorAngle = Math . floor ( 360 / n ) ; document . write ( " " + interiorAngle + " " ) ; document . write ( " " + exteriorAngle ) ; } let n = 10 ; findAngle ( n ) ;
function distance ( x1 , y1 , z1 , x2 , y2 , z2 ) { var d = Math . pow ( ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) + Math . pow ( z2 - z1 , 2 ) * 1.0 ) , 0.5 ) ; document . write ( " " + d . toFixed ( 10 ) ) ; return ; } var x1 = 2 ; var y1 = - 5 ; var z1 = 7 ; var x2 = 3 ; var y2 = 4 ; var z2 = 5 ; distance ( x1 , y1 , z1 , x2 , y2 , z2 ) ;
function DivisibleBy41 ( first , second , c , n ) { let digit = new Array ( n ) . fill ( 0 ) ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( let i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; let ans = digit [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; } let first = 1 , second = 2 , c = 1 , n = 3 ; if ( DivisibleBy41 ( first , second , c , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findTetrahedralNumber ( n ) { return ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ; } function printSeries ( n ) { let prev = 0 ; let curr ; for ( let i = 1 ; i <= n ; i ++ ) { curr = findTetrahedralNumber ( i ) ; curr = curr + prev ; document . write ( curr + " " ) ; prev = curr ; } } let n = 10 ; printSeries ( n ) ;
function printSeries ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { num = ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) / 24 ) ; document . write ( num + " " ) ; } } let n = 10 ; printSeries ( n ) ;
function No_Of_Pairs ( N ) { let i = 1 ; while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) i ++ ; return ( i - 1 ) ; } function print_pairs ( pairs ) { let i = 1 , mul ; for ( i = 1 ; i <= pairs ; i ++ ) { mul = i * ( i + 1 ) ; document . write ( " " + i + " " + ( mul * i ) + " " + mul * ( i + 1 ) + " " ) ; } } let N = 500 , pairs , mul , i = 1 ; pairs = No_Of_Pairs ( N ) ; document . write ( " " + pairs + " " ) ; print_pairs ( pairs ) ;
function findTriangularNumber ( n ) { return ( n * ( n + 1 ) ) / 2 ; } function printSeries ( n ) { var prev = 0 ; var curr ; for ( var i = 1 ; i <= n ; i ++ ) { curr = findTriangularNumber ( i ) ; curr = curr + prev ; document . write ( curr + " " ) ; prev = curr ; } } var n = 10 ; printSeries ( n ) ;
function printSeries ( n ) { let i ; for ( i = 1 ; i <= n ; i ++ ) { let num = i * ( i + 1 ) * ( ( i + 2 ) / 6 ) ; document . write ( num + " " ) ; } } let n = 10 ; printSeries ( n ) ;
function count_even_odd ( min , max , steps ) { var a , b , even , odd ; var beven = true , aeven = false ; var n = 2 ; for ( i = 0 ; i < n ; i ++ ) { a = steps [ i ] [ 0 ] ; b = steps [ i ] [ 1 ] ; if ( ! ( aeven || ( a & 1 ) > 0 ) ) aeven = true ; if ( beven ) { if ( ( b & 1 ) > 0 ) beven = false ; } else if ( ! ( ( a & 1 ) > 0 ) ) { if ( ! ( ( b & 1 ) > 0 ) ) beven = true ; } else { if ( ( b & 1 ) > 0 ) beven = true ; } } if ( beven ) { even = parseInt ( max / 2 ) - parseInt ( ( min - 1 ) / 2 ) ; odd = 0 ; } else { even = parseInt ( max / 2 ) - parseInt ( ( min - 1 ) / 2 ) ; odd = 0 ; } if ( ! ( beven ^ aeven ) ) even += max - min + 1 - parseInt ( max / 2 ) + parseInt ( ( min - 1 ) / 2 ) ; else odd += max - min + 1 - parseInt ( max / 2 ) + parseInt ( ( min - 1 ) / 2 ) ; document . write ( " " + even + " " + odd ) ; } var min = 1 , max = 4 ; var steps = [ [ 1 , 2 ] , [ 3 , 4 ] ] ; count_even_odd ( min , max , steps ) ;
function getMaxOnes ( n , x ) { let zeroes = parseInt ( n / x , 10 ) ; zeroes = zeroes * zeroes ; let total = n * n ; let ans = total - zeroes ; return ans ; } let n = 5 ; let x = 2 ; document . write ( getMaxOnes ( n , x ) ) ;
function check ( n , m ) { if ( n == 2 m == 2 n % m == 0 ) { document . write ( " " + " " ) ; } else { document . write ( " " + " " ) ; } } let m = 3 , n = 9 ; check ( n , m ) ;
function findSurfaceArea ( a , h ) { let Area ; Area = 6 * a * h + 3 * Math . sqrt ( 3 ) * a * a ; document . write ( " " + Area . toFixed ( 3 ) + " " ) ; } function findVolume ( a , h ) { let Volume ; Volume = 3 * Math . sqrt ( 3 ) * a * a * h / 2 ; document . write ( " " + Volume . toFixed ( 3 ) ) ; } let a = 5 , h = 10 ; findSurfaceArea ( a , h ) ; findVolume ( a , h ) ;
function MinimumMail ( n , k , x ) { let m = ( n - 1 ) + Math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + Math . ceil ( n * 1.0 / x ) * ( k - n ) ; return m ; } let N = 4 ; let K = 9 ; let X = 2 ; document . write ( MinimumMail ( N , K , X ) + " " ) ;
function findArea ( a , b ) { var Area ; Area = 3.142 * a * b ; document . write ( " " + Area . toFixed ( 2 ) ) ; } var a = 5 , b = 4 ; findArea ( a , b ) ;
function calculate ( x , k , m ) { let result = x ; k = k - 1 ; while ( k -- ) { result = Math . pow ( result , x ) ; if ( result > m ) result %= m ; } return result ; } let x = 5 ; let k = 2 ; let m = 3 ; document . write ( calculate ( x , k , m ) ) ;
function rev ( n , temp ) { if ( n == 0 ) return temp ; temp = ( temp * 10 ) + ( n % 10 ) ; return rev ( Math . floor ( n / 10 ) , temp ) ; } let n = 121 ; let temp = rev ( n , 0 ) ; if ( temp == n ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function findGreater ( a , b , n ) { if ( ! ( ( n & 1 ) > 0 ) ) { a = Math . abs ( a ) ; b = Math . abs ( b ) ; } if ( a == b ) document . write ( " " + " " ) ; else if ( a > b ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; } var a = 12 , b = 24 , n = 5 ; findGreater ( a , b , n ) ;
function fibonacci ( n ) { var fib ; for ( i = 0 ; i < n ; i ++ ) { fib = ( Math . pow ( ( 1 + Math . sqrt ( 5 ) ) , i ) - Math . pow ( ( 1 - Math . sqrt ( 5 ) ) , i ) ) / ( Math . pow ( 2 , i ) * Math . sqrt ( 5 ) ) ; document . write ( parseInt ( fib ) + " " ) ; } } var n = 8 ; fibonacci ( n ) ;
function center_hexadecagonal_num ( n ) { return 8 * n * n - 8 * n + 1 ; } var n = 2 ; document . write ( n + " " + " " ) ; document . write ( center_hexadecagonal_num ( n ) + " " ) ; n = 12 ; document . write ( n + " " + " " ) ; document . write ( center_hexadecagonal_num ( n ) ) ;
var MAX = 100 ; function findNature ( a , b , n ) { var seq = Array ( MAX ) . fill ( 0 ) ; seq [ 0 ] = a ; seq [ 1 ] = b ; for ( var i = 2 ; i <= n ; i ++ ) seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; return ( seq [ n ] & 1 ) ; } var a = 2 , b = 4 ; var n = 3 ; ( findNature ( a , b , n ) ? ( document . write ( " " + " " ) ) : ( document . write ( " " + " " ) ) ) ;
function check ( m , n ) { var RHS = m * Math . log ( n ) ; var LHS = n * Math . log ( m ) ; if ( LHS > RHS ) { document . write ( " " ) ; } else if ( LHS < RHS ) { document . write ( " " ) ; } else { document . write ( " " ) ; } } var m = 987654321 ; var n = 123456987 ; check ( m , n ) ;
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function maxDivisorRange ( a , b , l , h ) { var g = gcd ( a , b ) ; var res = - 1 ; for ( i = l ; i * i <= g && i <= h ; i ++ ) if ( g % i == 0 ) res = Math . max ( res , Math . max ( i , g / i ) ) ; return res ; } var a = 3 , b = 27 , l = 1 , h = 5 ; document . write ( maxDivisorRange ( a , b , l , h ) ) ;
function checksum ( n ) { if ( n == 0 ) { document . write ( " " ) ; return ; } var inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( i = 0 ; i <= n - 4 ; i += inc ) { if ( i + i + 1 + i + 2 + i + 3 + i + 4 == n ) { document . write ( ( i ) + " " + ( i + 1 ) + " " + ( i + 2 ) + " " + ( i + 3 ) + " " + ( i + 4 ) ) ; return ; } } document . write ( " " ) ; } var n = 15 ; checksum ( n ) ;
function checksum ( n ) { if ( n % 5 == 0 ) document . write ( ( n / 5 - 2 ) + " " + ( n / 5 - 1 ) + " " + ( n / 5 ) + " " + ( n / 5 + 1 ) + " " + ( n / 5 + 2 ) ) ; else document . write ( " " ) ; } var n = 15 ; checksum ( n ) ;
function sumOfSeries ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i * i * i * i ; return ans ; } let n = 4 ; document . write ( sumOfSeries ( n ) ) ;
function countUnmarked ( N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; } var N = 4 ; document . write ( " " + " " + countUnmarked ( N ) ) ;
function factorial ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } function calculateSeries ( n ) { return factorial ( n + 1 ) - 1 ; } let n = 3 ; document . write ( calculateSeries ( n ) ) ;
function factorial ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } function calculateSeries ( n ) { return 2 + ( n * n + n - 2 ) * factorial ( n + 1 ) ; } let n = 3 ; document . write ( calculateSeries ( n ) ) ;
function minimumLength ( x , y , z ) { return 1 + Math . abs ( x - y ) + Math . abs ( y - z ) ; } var x = 3 , y = 1 , z = 2 ; document . write ( minimumLength ( x , y , z ) ) ;
function endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) { document . write ( " " + ( 2 * c1 - x1 ) + " " ) ; document . write ( " " + ( 2 * c2 - y1 ) ) ; } let x1 = - 4 , y1 = - 1 ; let c1 = 3 , c2 = 5 ; endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) ;
function centered_heptagonal_num ( n ) { return parseInt ( ( 7 * n * n - 7 * n + 2 ) / 2 ) ; } let n = 5 ; document . write ( n + " " ) ; document . write ( centered_heptagonal_num ( n ) ) ;
function findSum ( n ) { return ( n * ( n + 1 ) * ( n + 1 ) * ( n + 2 ) ) / 12 ; } let n = 3 ; document . write ( findSum ( n ) + " " ) ;
function checkHankelMatrix ( n , m ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( i + j < n ) { if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) return false ; } else { if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) return false ; } } } return true ; } let n = 4 ; let m = [ [ 1 , 2 , 3 , 5 ] , [ 2 , 3 , 5 , 8 ] , [ 3 , 5 , 8 , 0 ] , [ 5 , 8 , 0 , 9 ] ] ; if ( checkHankelMatrix ( n , m ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isPower ( n ) { for ( x = 2 ; x <= parseInt ( Math . sqrt ( n ) ) ; x ++ ) { var f = Math . log ( n ) / Math . log ( x ) ; if ( ( f - parseInt ( f ) ) == 0.0 ) return true ; } return false ; } for ( i = 2 ; i < 100 ; i ++ ) if ( isPower ( i ) ) document . write ( i + " " ) ;
var N = 1000005 ; function sumOddDigit ( digitSum ) { for ( var i = 1 ; i < N ; i ++ ) { digitSum [ i ] = digitSum [ parseInt ( i / 10 ) ] + ( i & 1 ) * ( i % 10 ) ; } } function sumFactor ( digitSum , factorDigitSum ) { for ( var i = 1 ; i < N ; i ++ ) { for ( var j = i ; j < N ; j += i ) { factorDigitSum [ j ] += digitSum [ i ] ; } } } function wrapper ( q , n ) { var digitSum = Array ( N ) . fill ( 0 ) ; var factorDigitSum = Array ( N ) . fill ( 0 ) ; sumOddDigit ( digitSum ) ; sumFactor ( digitSum , factorDigitSum ) ; for ( var i = 0 ; i < q ; i ++ ) document . write ( factorDigitSum [ n [ i ] ] + " " ) ; } var q = 2 ; var n = [ 10 , 36 ] ; wrapper ( q , n ) ;
function number_of_digits ( n ) { let i , res , sum = 0 ; for ( i = 4 , res = 1 ; ; i *= 4 , res ++ ) { sum += i ; if ( sum >= n ) break ; } return res ; } let n = 21 ; document . write ( number_of_digits ( n ) + " " ) ;
function Reverseorder ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = n ; p >= 2 ; p -- ) if ( prime [ p ] ) document . write ( p + " " ) ; } let N = 25 ; document . write ( " " + " " ) ; if ( N == 1 ) document . write ( " " ) ; else
function magicOfSequence ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) sum += ( i * i * i + i * 2 ) ; return sum ; } let N = 4 ; document . write ( magicOfSequence ( N ) ) ;
function isPossibleToZero ( a , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( i & 1 ) == 0 ) odd += a [ i ] ; else even += a [ i ] ; } return ( odd == even ) ; } let arr = [ 0 , 1 , 1 , 0 ] ; let n = arr . length ; if ( isPossibleToZero ( arr , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
const PI = 3.142 ; function cosXSertiesSum ( x , n ) { x = x * ( PI / 180.0 ) ; let res = 1 ; let sign = 1 , fact = 1 , pow = 1 , i ; for ( i = 1 ; i < 5 ; i ++ ) { sign = sign * - 1 ; fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; pow = pow * x * x ; res = res + sign * pow / fact ; } return res ; } let x = 50 ; let n = 5 ; document . write ( ( ( cosXSertiesSum ( x , 5 ) * 1000000 ) / 1000000.00 ) . toFixed ( 6 ) ) ;
function solve ( n , base ) { var result = 0 ; while ( n > 0 ) { var remainder = n % base ; result = result + remainder ; n = parseInt ( n / base ) ; } return result ; } function printSumsOfDigits ( n ) { for ( base = 2 ; base < n ; ++ base ) document . write ( solve ( n , base ) + " " ) ; } var n = 8 ; printSumsOfDigits ( n ) ;
function check ( N , D ) { let temp = ( N * ( N + 1 ) ) / 2 + D ; return ( temp % 2 == 0 ) ; } let N = 5 ; let M = 7 ; if ( check ( N , M ) ) document . write ( " " ) ; else document . write ( " " ) ;
function perfectSquare ( s ) { let n = s . length ; let ans = - 1 ; let num = " " ; for ( let i = 1 ; i < ( 1 << n ) ; i ++ ) { let str = " " ; for ( j = 0 ; j < n ; j ++ ) { if ( ( i >> j ) & 1 ) { str = str + s [ j ] ; } } if ( str [ 0 ] != ' ' ) { let temp = 0 ; for ( let j = 0 ; j < str . length ; j ++ ) temp = temp * 10 + ( str [ j ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; k = Math . floor ( Math . sqrt ( temp ) ) ; if ( ( k * k ) == temp ) { if ( ans < str . length ) { ans = str . length ; num = str ; } } } } if ( ans == - 1 ) return ans ; else { document . write ( num + " " ) ; return ( n - ans ) ; } } document . write ( perfectSquare ( " " ) + " " ) ; document . write ( perfectSquare ( " " ) + " " ) ;
function printFourSquares ( a ) { for ( let i = 0 ; i * i <= a ; i ++ ) { for ( let j = i ; j * j <= a ; j ++ ) { for ( let k = j ; k * k <= a ; k ++ ) { for ( let l = k ; l * l <= a ; l ++ ) { if ( i * i + j * j + k * k + l * l == a ) { document . write ( a + " " + i + " " + i + " " + j + " " + j + " " ) ; document . write ( k + " " + k + " " + l + " " + l + " " ) ; } } } } } } let a = 74 ; printFourSquares ( a ) ;
function exactPrimeFactorCount ( n ) { let count = 0 ; if ( n % 2 == 0 ) { count ++ ; while ( n % 2 == 0 ) n = n / 2 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { count ++ ; while ( n % i == 0 ) n = n / i ; } } if ( n > 2 ) count ++ ; return count ; } let n = 51242183 ; document . write ( " " + exactPrimeFactorCount ( n ) + " " ) ; document . write ( " " + Math . log ( Math . log ( n ) ) + " " ) ;
function no_of_digit ( a , b ) { return ( Math . round ( ( b * Math . log10 ( a ) ) + 1 ) ) ; } let a = 2 , b = 100 ; document . write ( " " + no_of_digit ( a , b ) ) ;
function checkSemiprime ( num ) { let cnt = 0 ; for ( let i = 2 ; cnt < 2 && i * i <= num ; ++ i ) { while ( num % i == 0 ) { num = parseInt ( num / i , 10 ) ; ++ cnt ; } } if ( num > 1 ) ++ cnt ; return cnt == 2 ; } function isEmirpimes ( n ) { if ( checkSemiprime ( n ) == false ) return false ; let r = 0 ; for ( let t = n ; t != 0 ; t = parseInt ( t / n , 10 ) ) r = r * 10 + t % 10 ; if ( r == n ) return false ; return ( checkSemiprime ( r ) ) ; } let n = 15 ; if ( isEmirpimes ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function factorial ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { res *= i ; } return res ; } function printNComposite ( n ) { let fact = factorial ( n + 1 ) ; for ( let i = 2 ; i <= n + 1 ; ++ i ) { document . write ( fact + i + " " ) ; } } let n = 4 ; printNComposite ( n ) ;
function primes ( n ) { var prime = Array ( n + 1 ) . fill ( true ) ; for ( var i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( var j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } var arr = [ ] ; for ( var i = 2 ; i < n ; i ++ ) if ( prime [ i ] ) arr . push ( i ) ; return arr ; } function countDigits ( n ) { var temp = n ; var c = 0 ; while ( temp != 0 ) { temp = parseInt ( temp / 10 ) ; c ++ ; } return c ; } function frugal ( n ) { var r = primes ( n ) ; var t = n ; var s = 0 ; for ( var i = 0 ; i < r . length ; i ++ ) { if ( t % r [ i ] == 0 ) { var k = 0 ; while ( t % r [ i ] == 0 ) { t = parseInt ( t / r [ i ] ) ; k ++ ; } if ( k == 1 ) s = s + countDigits ( r [ i ] ) ; else if ( k != 1 ) s = s + countDigits ( r [ i ] ) + countDigits ( k ) ; } } return ( countDigits ( n ) > s && s != 0 ) ; } var n = 343 ; if ( frugal ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function nthSquareCube ( n ) { return n * n * n * n * n * n ; } let n = 5 ; document . write ( nthSquareCube ( n ) ) ;
function findS ( s ) { let sum = 0 ; for ( let n = 1 ; sum < s ; n ++ ) { sum += n * n * n ; if ( sum == s ) return n ; } return - 1 ; } let s = 9 ; let n = findS ( s ) ; n == - 1 ? document . write ( " " ) : document . write ( n ) ;
function findKthGoodNo ( n ) { let lastDig = n % 10 ; if ( lastDig >= 0 && lastDig <= 4 ) return n << 1 ; else return ( n << 1 ) + 1 ; } let n = 10 ; document . write ( findKthGoodNo ( n ) ) ;
function NicomachuTheorum_sum ( n ) { let sum = 0 ; for ( let k = 1 ; k <= n ; k ++ ) sum += k * k * k ; let triNo = n * ( n + 1 ) / 2 ; if ( sum == triNo * triNo ) document . write ( " " ) ; else document . write ( " " ) ; } let n = 5 ; NicomachuTheorum_sum ( n ) ;
function checkDigits ( n ) { while ( n > 0 ) { if ( ( ( n % 10 ) % 2 ) > 0 ) return 0 ; n = parseInt ( n / 10 ) ; } return 1 ; } function largestNumber ( n ) { for ( i = n ; ; i -- ) if ( checkDigits ( i ) > 0 ) return i ; } var N = 23 ; document . write ( largestNumber ( N ) ) ;
function largestNumber ( n ) { var s = " " ; var duplicate = n ; while ( n > 0 ) { s = String . fromCharCode ( n % 10 + 48 ) + s ; n = parseInt ( n / 10 ) ; } var index = - 1 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( ( ( ( s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) % 2 ) & 1 ) > 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; var num = 0 ; for ( i = 0 ; i < index ; i ++ ) num = num * 10 + ( s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; num = num * 10 + ( s . charAt ( index ) . charCodeAt ( 0 ) - ( ' ' ) . charCodeAt ( 0 ) - 1 ) ; for ( i = index + 1 ; i < s . length ; i ++ ) num = num * 10 + 8 ; return num ; } var N = 24578 ; document . write ( largestNumber ( N ) ) ;
function countDigits ( n ) { return ( n * Math . log10 ( 2 ) + 1 ) ; } let n = 5 ; document . write ( Math . floor ( countDigits ( n ) ) ) ;
function check_digits ( n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 != 0 ) return 0 ; n = parseInt ( n / 10 ) ; } return 1 ; } function smallest_number ( n ) { for ( i = n ; ; i ++ ) if ( check_digits ( i ) != 0 ) return i ; } var N = 2397 ; document . write ( smallest_number ( N ) ) ;
function findBucketNo ( p ) { return Math . ceil ( ( Math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) ; } let p = 10 ; document . write ( findBucketNo ( p ) ) ;
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } function LCMOfNeighbourFact ( n ) { return factorial ( n + 1 ) ; } var N = 5 ; document . write ( LCMOfNeighbourFact ( N ) ) ;
function sumofFactors ( n ) { let res = 1 ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 , curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function checkFriendly ( n , m ) { let sumFactors_n = sumofFactors ( n ) ; let sumFactors_m = sumofFactors ( m ) ; let gcd_n = gcd ( n , sumFactors_n ) ; let gcd_m = gcd ( m , sumFactors_m ) ; if ( n / gcd_n == m / gcd_m && sumFactors_n / gcd_n == sumFactors_m / gcd_m ) return true ; else return false ; } let n = 6 , m = 28 ; if ( checkFriendly ( n , m ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function primorial ( n ) { let p = 2 ; n -- ; for ( let i = 3 ; n != 0 ; i ++ ) { if ( isPrime ( i ) == true ) { p = p * i ; n -- ; } i ++ ; } return p ; } function findNextPrime ( n ) { let nextPrime = n + 2 ; while ( true ) { if ( isPrime ( nextPrime ) == true ) break ; nextPrime ++ ; } return nextPrime ; } function fortunateNumber ( n ) { let p = primorial ( n ) ; return findNextPrime ( p ) - p ; } let n = 5 ; document . write ( fortunateNumber ( n ) ) ;
function procal ( n ) { return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) ; } let a = [ 1 , 2 , 3 , 4 , 5 ] ; let n = a . length ; document . write ( procal ( n ) ) ;
function testSomeNumbers ( limit , n ) { if ( n < 3 ) return ; for ( let a = 1 ; a <= limit ; a ++ ) for ( let b = a ; b <= limit ; b ++ ) { let pow_sum = ( Math . pow ( a , n ) + Math . pow ( b , n ) ) ; let c = Math . pow ( pow_sum , 1.0 / n ) ; let c_pow = Math . pow ( Math . round ( c ) , n ) ; if ( c_pow == pow_sum ) { document . write ( " " ) ; return ; } } document . write ( " " + " " ) ; } testSomeNumbers ( 12 , 5 ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function productReduce ( n , num , den ) { let new_num = 1 , new_den = 1 ; for ( let i = 0 ; i < n ; i ++ ) { new_num *= num [ i ] ; new_den *= den [ i ] ; } let GCD = gcd ( new_num , new_den ) ; new_num /= GCD ; new_den /= GCD ; document . write ( new_num + " " + new_den ) ; } let n = 3 ; let num = [ 1 , 2 , 5 ] ; let den = [ 2 , 1 , 6 ] ; productReduce ( n , num , den ) ;
function fnMod ( n ) { if ( n % 5 == 1 ) return 4 ; else return 0 ; } let n = 10 ; document . write ( fnMod ( n ) + " " ) ; n = 11 ; document . write ( fnMod ( n ) + " " ) ;
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } function repeatedNumberSum ( n , x ) { sum = x * digSum ( n ) ; return digSum ( sum ) ; } let n = 24 ; let x = 3 ; document . write ( repeatedNumberSum ( n , x ) ) ;
function totalSumDivisibleByNum ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let sum = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) sum += i ; return sum ; } let n = 3 , num = 7 ; document . write ( totalSumDivisibleByNum ( n , num ) ) ;
function numberofterm ( n , number ) { let firstnum = Math . pow ( 10 , n - 1 ) ; let lastnum = Math . pow ( 10 , n ) ; let count = 0 ; for ( let i = firstnum ; i < lastnum ; i ++ ) if ( i % number == 0 ) count ++ ; return count ; } let n = 3 , num = 7 ; document . write ( numberofterm ( n , num ) ) ;
function georgeCantor ( n ) { let i = 1 ; let j = 1 ; let k = 1 ; while ( k < n ) { j ++ ; k ++ ; if ( k == n ) break ; while ( j > 1 && k < n ) { i ++ ; j -- ; k ++ ; } if ( k == n ) break ; i ++ ; k ++ ; if ( k == n ) break ; while ( i > 1 && k < n ) { i -- ; j ++ ; k ++ ; } } document . write ( " " + i + " " + j ) ; } let n = 15 ; georgeCantor ( n ) ;
function isDivisible ( n ) { while ( parseInt ( n / 100 ) ) { let last_digit = n % 10 ; n = parseInt ( n / 10 ) ; n += last_digit * 3 ; } return ( n % 29 == 0 ) ; } let n = 348 ; if ( isDivisible ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function pronic_check ( n ) { var x = parseInt ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; } var n = 56 ; pronic_check ( n ) == true ? document . write ( " " ) : document . write ( " " ) ;
let MAX = 100000 function multiply ( x , res , res_size ) { let carry = 0 ; for ( let i = 0 ; i < res_size ; i ++ ) { let prod = res [ i ] * x + carry ; res [ i ] = prod % 10 ; carry = Math . floor ( prod / 10 ) ; } while ( carry ) { res [ res_size ] = carry % 10 ; carry = Math . floor ( carry / 10 ) ; res_size ++ ; } return res_size ; } function power ( x , n ) { if ( n == 0 ) { document . write ( " " ) ; return ; } let res = new Array ( MAX ) ; let res_size = 0 ; let temp = x ; while ( temp != 0 ) { res [ res_size ++ ] = temp % 10 ; temp = Math . floor ( temp / 10 ) ; } for ( let i = 2 ; i <= n ; i ++ ) res_size = multiply ( x , res , res_size ) ; document . write ( x + " " + n + " " ) ; for ( let i = res_size - 1 ; i >= 0 ; i -- ) document . write ( res [ i ] ) ; } let exponent = 100 ; let base = 2 ; power ( base , exponent ) ;
function check ( n , p ) { let maximum = - 1 ; while ( ! ( n % 2 ) ) { maximum = Math . max ( maximum , 2 ) n = n / 2 ; } var i ; for ( i = 3 ; i * i <= n ; i += 2 ) { while ( n % i == 0 ) { maximum = Math . max ( maximum , i ) ; n = n / i ; } } if ( n > 2 ) maximum = Math . max ( maximum , n ) ; if ( maximum <= p ) return true ; else return false ; } let n = 24 , p = 7 ; if ( check ( n , p ) ) document . write ( " " ) ; else document . write ( " " ) ;
function find_time ( h1 ) { theta = 30 * h1 ; document . write ( " " + ( theta * 2 ) + " " + " " + " " + " " ) ; } h1 = 3 ; find_time ( h1 ) ;
function sum_series ( n ) { let nSquare = n * n ; return nSquare * ( nSquare - 1 ) / 4 ; } let n = 2 ; document . write ( sum_series ( n ) ) ;
function isPrime ( n ) { if ( n == 0 n == 1 ) return false ; let root = Math . sqrt ( n ) ; for ( let i = 2 ; i <= root ; i ++ ) if ( n % i == 0 ) return false ; return true ; } function isSandwitched ( n ) { return ( isPrime ( n - 1 ) && isPrime ( n + 1 ) ) ; } let n = 642 ; document . write ( n + " " ) ; if ( isSandwitched ( n ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; n = 9 ; document . write ( n + " " ) ; if ( isSandwitched ( n ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function day_of_the_week ( y , m , d ) { let t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] ; if ( m < 3 ) y -= 1 ; return ( y + y / 4 - y / 100 + y / 400 + t [ m - 1 ] + d ) % 7 ; } let day = 13 , month = 7 , year = 2017 ; document . write ( Math . round ( day_of_the_week ( year , month , day ) ) ) ;
function isPrime ( n , i ) { if ( n <= 2 ) return ( n == 2 ) ? true : false ; if ( n % i == 0 ) return false ; if ( i * i > n ) return true ; return isPrime ( n , i + 1 ) ; } let n = 15 ; if ( isPrime ( n , 2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isSquareFree ( n ) { if ( n % 2 == 0 ) n = n / 2 ; if ( n % 2 == 0 ) return false ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; if ( n % i == 0 ) return false ; } } return true ; } let n = 10 ; if ( isSquareFree ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findArea ( d ) { return ( d * d ) / 2 ; } let d = 10 ; document . write ( findArea ( d ) ) ;
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) ; return sum ; } let n = 10 ; document . write ( sumOfSeries ( n ) ) ;
function sumOfSeries ( n ) { return ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ; } let n = 10 ; document . write ( sumOfSeries ( n ) ) ;
function StepstoReachTarget ( target ) { target = Math . abs ( target ) ; let n = Math . ceil ( ( - 1.0 + Math . sqrt ( 1 + 8.0 * target ) ) / 2 ) ; let sum = n * ( n + 1 ) / 2 ; if ( sum == target ) return n ; let d = sum - target ; if ( ( d & 1 ) == 0 ) return n ; else return n + ( ( n & 1 ) != 0 ? 2 : 1 ) ; } let target = 5 ; document . write ( StepstoReachTarget ( target ) ) ;
function seriesSum ( n ) { let i = 1 ; let res = 0.0 ; let sign = true ; while ( n > 0 ) { n -- ; if ( sign ) { sign = ! sign ; res = res + ++ i / ++ i ; } else { sign = ! sign ; res = res - ++ i / ++ i ; } } return res ; } let n = 5 ; document . write ( seriesSum ( n ) . toFixed ( 6 ) ) ;
function countSymmetric ( n ) { if ( n == 0 ) return 1 ; return 1 << ( ( n * ( n + 1 ) ) / 2 ) ; } let n = 3 ; document . write ( countSymmetric ( n ) ) ;
function centeredNonagonal ( n ) { return parseInt ( ( 3 * n - 2 ) * ( 3 * n - 1 ) / 2 ) ; } let n = 10 ; document . write ( centeredNonagonal ( n ) ) ;
function Mean ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum / n ; } function meanAbsDevtion ( arr , n ) { let absSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) absSum = absSum + Math . abs ( arr [ i ] - Mean ( arr , n ) ) ; return absSum / n ; } let arr = [ 10 , 15 , 15 , 17 , 18 , 21 ] ; let n = arr . length ; document . write ( meanAbsDevtion ( arr , n ) ) ;
function isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) { for ( let i = lowQuant ; i <= upQuant ; i ++ ) { let ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; } let lowCost = 14 , upCost = 30 , lowQuant = 5 , upQuant = 12 , r = 9 ; if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findNumbers ( n , d ) { for ( let i = 0 ; i < n - 2 ; i ++ ) document . write ( " " + " " ) ; document . write ( " " + " " ) ; document . write ( n + d ) ; } let N = 3 , D = 5 ; findNumbers ( N , D ) ;
function oddNumSum ( n ) { return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 ; } var n = 4 ; document . write ( oddNumSum ( n ) ) ;
function trailingZero ( x ) { let i = 5 ; let count = 0 ; while ( x > i ) { count = count + parseInt ( x / i ) ; i = i * 5 ; } return count ; } function countProductTrailing ( M , N ) { return trailingZero ( N ) + trailingZero ( M ) ; } let N = 67 ; let M = 98 ; document . write ( countProductTrailing ( N , M ) ) ;
function isTrimorphic ( N ) { let cube = N * N * N ; while ( N > 0 ) { if ( N % 10 != cube % 10 ) return false ; N = parseInt ( N / 10 , 10 ) ; cube = parseInt ( cube / 10 , 10 ) ; } return true ; } let N = 24 ; if ( isTrimorphic ( N ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
let LET_MAX = 2147483647 ; function checkTrimorphic ( num ) { let cube = num * num * num ; while ( num > 0 ) { if ( num % 10 != cube % 10 ) return false ; num = Math . floor ( num / 10 ) ; cube = Math . floor ( cube / 10 ) ; } return true ; } function nthTrimorphic ( n ) { let count = 0 ; for ( let i = 0 ; i < LET_MAX ; i ++ ) { if ( checkTrimorphic ( i ) ) count ++ ; if ( count == n ) return i ; } return - 1 ; } let n = 9 ; document . write ( nthTrimorphic ( n ) ) ;
function reachTarget ( target ) { target = Math . abs ( target ) ; let sum = 0 , step = 0 ; while ( sum < target || ( sum - target ) % 2 != 0 ) { step ++ ; sum += step ; } return step ; } let target = 5 ; document . write ( reachTarget ( target ) ) ;
function fifthPowerSum ( n ) { return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) / 12 ; } let n = 5 ; document . write ( fifthPowerSum ( n ) + " " ) ;
function unitDigitXRaisedY ( x , y ) { let res = 1 ; for ( let i = 0 ; i < y ; i ++ ) res = ( res * x ) % 10 ; return res ; } document . write ( unitDigitXRaisedY ( 4 , 2 ) ) ;
function findDivisor ( x , y ) { if ( x == y ) return y ; return 2 ; } var x = 3 , y = 16 ; document . write ( findDivisor ( x , y ) ) ;
function AvgofSquareN ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum / n ; } let n = 2 ; document . write ( AvgofSquareN ( n ) . toFixed ( 6 ) ) ;
function sumofFactors ( n ) { if ( n % 2 != 0 ) return 0 ; let res = 1 ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 , curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; if ( i == 2 && count == 1 ) curr_sum = 0 ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } let n = 18 ; document . write ( sumofFactors ( n ) ) ;
function focal_length_concave ( R ) { return R / 2 ; } function focal_length_convex ( R ) { return - ( R / 2 ) ; } let R = 30 ; document . write ( " " + " " + " " + focal_length_concave ( R ) + " " + " " ) ; document . write ( " " + " " + " " + focal_length_convex ( R ) + " " ) ;
function sumofoddFactors ( n ) { let res = 1 ; while ( n % 2 == 0 ) n = n / 2 ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i ++ ) { let count = 0 ; let curr_sum = 1 ; let curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = n / i ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } let n = 30 ; document . write ( sumofoddFactors ( n ) ) ;
function countSolutions ( n , val ) { let total = 0 ; if ( n == 1 && val >= 0 ) return 1 ; for ( let i = 0 ; i <= val ; i ++ ) { total += countSolutions ( n - 1 , val - i ) ; } return total ; } let n = 5 ; let val = 20 ; document . write ( countSolutions ( n , val ) ) ;
var N = 6 ; function fib ( f , n ) { var i ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( i = 2 ; i <= n ; i ++ ) f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; } function fibcoef ( fc , f , n ) { for ( i = 0 ; i <= n ; i ++ ) fc [ i ] [ 0 ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= i ; j ++ ) { var k = j ; while ( k > 0 ) { k -- ; fc [ i ] [ j ] *= f [ k ] ; } k = 1 ; while ( ( j + 1 ) != k ) fc [ i ] [ j ] /= f [ k ++ ] ; } } } function printFibonomialTriangle ( n ) { var f = Array ( N + 1 ) . fill ( 0 ) ; fib ( f , n ) ; var dp = Array ( N + 1 ) ; for ( var i = 0 ; i < N + 1 ; i ++ ) dp [ i ] = Array ( N + 1 ) . fill ( 0 ) ; for ( i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ i ] = 1 ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j < i ; j ++ ) dp [ i ] [ j ] = f [ i - j + 1 ] * dp [ i - 1 ] [ j - 1 ] + f [ j - 1 ] * dp [ i - 1 ] [ j ] ; } for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) document . write ( dp [ i ] [ j ] + " " ) ; document . write ( " " ) ; } } var n = 6 ; printFibonomialTriangle ( n ) ;
function sumofNterm ( a , d , b , r , n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( ( a + ( i - 1 ) * d ) * ( b * Math . pow ( r , i - 1 ) ) ) ; return sum ; } let a = 1 ; let d = 1 ; let b = 2 ; let r = 2 ; let n = 3 ; document . write ( sumofNterm ( a , d , b , r , n ) ) ;
function sumOfTheSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let k = 2 ; for ( let j = 1 ; j <= i ; j ++ ) { sum += k ; k += 2 ; } } return sum ; } let n = 5 ; document . write ( " " + sumOfTheSeries ( n ) ) ;
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum = sum + i * ( i + 1 ) * ( i + 2 ) ; return sum ; } let n = 10 ; document . write ( sumOfSeries ( n ) ) ;
function Series ( x , n ) { let sum = 1 , term = 1 , fct , j , y = 2 , m ; let i ; for ( i = 1 ; i < n ; i ++ ) { fct = 1 ; for ( j = 1 ; j <= y ; j ++ ) { fct = fct * j ; } term = term * ( - 1 ) ; m = term * Math . pow ( x , y ) / fct ; sum = sum + m ; y += 2 ; } return sum ; } let x = 9 ; let n = 10 ; document . write ( Series ( x , n ) . toFixed ( 4 ) ) ;
function Series ( x , n ) { var sum = 1 , term = 1 , fct = 1 ; var p = 1 , multi = 1 ; for ( let i = 1 ; i < n ; i ++ ) { fct = fct * multi * ( multi + 1 ) ; p = p * x * x ; term = ( - 1 ) * term ; multi += 2 ; sum = sum + ( term * p ) / fct ; } return sum ; } var x = 9 ; var n = 10 ; document . write ( Series ( x , n ) . toFixed ( 4 ) ) ;
function two_factor ( n ) { let twocount = 0 ; while ( n % 2 == 0 ) { twocount ++ ; n = n / 2 ; } return twocount ; } function five_factor ( n ) { let fivecount = 0 ; while ( n % 5 == 0 ) { fivecount ++ ; n = n / 5 ; } return fivecount ; } function find_con_zero ( arr , n ) { let twocount = 0 ; let fivecount = 0 ; for ( let i = 0 ; i < n ; i ++ ) { twocount += two_factor ( arr [ i ] ) ; fivecount += five_factor ( arr [ i ] ) ; } if ( twocount < fivecount ) return twocount ; else return fivecount ; } let arr = [ 100 , 10 , 5 , 25 , 35 , 14 ] ; let n = 6 ; document . write ( find_con_zero ( arr , n ) ) ;
function first ( a , b , c ) { a %= b ; for ( let i = 1 ; i <= b ; i ++ ) { a = a * 10 ; if ( a / b == c ) return i ; a %= b ; } return - 1 ; } let a = 1 , b = 4 , c = 5 ; document . write ( first ( a , b , c ) ) ;
function subsetDifference ( n ) { let s = n * ( n + 1 ) / 2 ; if ( n % 4 == 0 ) { document . write ( " " + Math . floor ( s / 2 ) ) ; document . write ( " " + Math . floor ( s / 2 ) ) ; document . write ( " " + 0 ) ; } else { if ( n % 4 == 1 n % 4 == 2 ) { document . write ( " " + Math . floor ( s / 2 ) ) ; document . write ( " " + Math . floor ( s / 2 + 1 ) ) ; document . write ( " " + 1 ) ; } else { document . write ( " " + Math . floor ( s / 2 ) ) ; document . write ( " " + Math . floor ( s / 2 ) ) ; document . write ( " " + 0 ) ; } } } let n = 6 ; subsetDifference ( n ) ;
function timeToMeet ( s , v ) { var V = 3 * v / 2 ; var time = s / V ; document . write ( time . toFixed ( 6 ) ) ; } var s = 25 , v = 56 ; timeToMeet ( s , v ) ;
function checksum ( n ) { if ( n == 0 ) { document . write ( " " ) ; return ; } var inc ; if ( n > 0 ) inc = 1 ; else inc = - 1 ; for ( i = 0 ; i <= n - 2 ; i += inc ) { if ( i + i + 1 + i + 2 == n ) { document . write ( i + " " + ( i + 1 ) + " " + ( i + 2 ) ) ; return ; } } document . write ( " " ) ; } var n = 6 ; checksum ( n ) ;
function divisorSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = 1 ; j * j <= i ; ++ j ) { if ( i % j == 0 ) { if ( i / j == j ) sum += j ; else sum += j + i / j ; } } } return sum ; } let n = 4 ; document . write ( divisorSum ( n ) + " " ) ; n = 5 ; document . write ( divisorSum ( n ) + " " ) ;
function printbinomial ( max ) { for ( let m = 0 ; m <= max ; m ++ ) { document . write ( m ) ; let binom = 1 ; for ( let x = 0 ; x <= m ; x ++ ) { if ( m != 0 && x != 0 ) binom = binom * ( m - x + 1 ) / x ; document . write ( " " + binom + " " ) ; } document . write ( " " ) ; } } let max = 10 ; printbinomial ( max ) ;
function countSetBits ( n ) { var count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; } function countUnsetBitsInGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( r - l + 1 ) - countSetBits ( n & num ) ; } var n = 80 ; var l = 1 , r = 4 ; document . write ( countUnsetBitsInGivenRange ( n , l , r ) ) ;
function evenPowerSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let j = 2 * i ; sum = sum + ( j * j * j * j ) ; } return sum ; } let n = 5 ; document . write ( evenPowerSum ( n ) ) ;
function evenPowerSum ( n ) { return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; } var n = 4 ; document . write ( evenPowerSum ( n ) ) ;
var MAX = 501 ; function balancedprime ( n ) { var prime = Array ( MAX + 1 ) . fill ( true ) ; for ( var p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } var v = [ ] ; for ( var p = 3 ; p <= MAX ; p += 2 ) if ( prime [ p ] ) v . push ( p ) ; var count = 0 ; for ( var i = 1 ; i < v . length ; i ++ ) { if ( v [ i ] == ( v [ i + 1 ] + v [ i - 1 ] ) / 2 ) count ++ ; if ( count == n ) return v [ i ] ; } } var n = 4 ; document . write ( balancedprime ( n ) ) ;
var MAX = 1000001 ; var factor = Array ( MAX ) . fill ( 0 ) ; function generatePrimeFactors ( ) { factor [ 1 ] = 1 ; for ( i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } function calculateNoOFactors ( n ) { if ( n == 1 ) return 1 ; var ans = 1 ; var dup = factor [ n ] ; var c = 1 ; var j = n / factor [ n ] ; while ( j != 1 ) { if ( factor [ j ] == dup ) c += 1 ; else { dup = factor [ j ] ; ans = ans * ( c + 1 ) ; c = 1 ; } j = j / factor [ j ] ; } ans = ans * ( c + 1 ) ; return ans ; } function smallest ( n ) { for ( i = 1 ; ; i ++ ) if ( calculateNoOFactors ( i ) >= n ) return i ; } generatePrimeFactors ( ) ; var n = 4 ; document . write ( smallest ( n ) ) ;
function squaresum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; } let n = 4 ; document . write ( squaresum ( n ) + " " ) ;
function isPrime ( n ) { let i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) return false ; i ++ ; } return true ; } function minimumSum ( n ) { if ( isPrime ( n ) ) return 1 ; if ( n % 2 == 0 ) return 2 ; if ( isPrime ( n - 2 ) ) return 2 ; return 3 ; } let n = 27 ; document . write ( minimumSum ( n ) ) ;
function firstDigit ( n ) { while ( n >= 10 ) n /= 10 ; return Math . floor ( n ) ; } function lastDigit ( n ) { return Math . floor ( n % 10 ) ; } let n = 98562 ; document . write ( firstDigit ( n ) + " " + lastDigit ( n ) ) ;
function isPrime ( x ) { if ( x == 0 x == 1 ) return false ; for ( let i = 2 ; i * i <= x ; ++ i ) if ( x % i == 0 ) return false ; return true ; } function findPrimes ( n ) { document . write ( n ) ; document . write ( 2 + " " + ( n - 2 ) ) ; { document . write ( 3 + " " ) ; n = n - 3 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPrime ( i ) && isPrime ( n - i ) ) { document . write ( i + " " + ( n - i ) ) ; break ; } } } } let n = 27 ; findPrimes ( n ) ;
let c = [ ] ; function coef ( n ) { c [ 0 ] = 1 ; for ( let i = 0 ; i < n ; c [ 0 ] = - c [ 0 ] , i ++ ) { c [ 1 + i ] = 1 ; for ( let j = i ; j > 0 ; j -- ) c [ j ] = c [ j - 1 ] - c [ j ] ; } } function isPrime ( n ) { coef ( n ) ; c [ 0 ] ++ ; c [ n ] -- ; let i = n ; while ( ( i -- ) > 0 && c [ i ] % n == 0 ) ; return i < 0 ; } let n = 37 ; if ( isPrime ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function motzkin ( n ) { if ( n == 0 n == 1 ) return 1 ; return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) ; } var n = 8 ; document . write ( motzkin ( n ) ) ;
function sumOfSeries ( n ) { return ( 0.666 ) * ( 1 - 1 / Math . pow ( 10 , n ) ) ; } let n = 2 ; document . write ( sumOfSeries ( n ) . toFixed ( 5 ) ) ;
function countDigit ( n ) { if ( n == 0 ) return 0 ; return ( 1 + countDigit ( n / 10 ) ) ; } function check ( n ) { let l = countDigit ( n ) ; let dup = n ; let sum = 0 ; while ( dup ) { sum += Math . pow ( dup % 10 , l ) ; dup = parseINT ( dup / 10 ) ; } return ( n == sum ) ; } let n = 1634 ; if ( check ( ! n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function summation ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( i * i ) ; return sum ; } let n = 2 ; document . write ( summation ( n ) ) ;
let MAX = 100 ; function leyland ( n ) { let ans = [ ] ; let index = 0 ; for ( let x = 2 ; x <= n ; x ++ ) { for ( let y = 2 ; y <= x ; y ++ ) { let temp = Math . pow ( x , y ) + Math . pow ( y , x ) ; ans [ index ] = temp ; index ++ ; } } console . log ( ans ) ans = ans . sort ( ( a , b ) => a - b ) ; console . log ( ans ) for ( let i = 0 ; i < n ; i ++ ) document . write ( ans [ i ] + " " ) ; } let n = 6 ; leyland ( n ) ;
function kthgroupsum ( k ) { let cur = ( k * ( k - 1 ) ) + 1 ; let sum = 0 ; while ( k -- ) { sum += cur ; cur += 2 ; } return sum ; } let k = 3 ; document . write ( kthgroupsum ( k ) ) ;
function nthTerm ( n ) { return ( n * n ) + ( n * n * n ) ; } let n = 4 ; document . write ( nthTerm ( n ) ) ;
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } let n = 4 ; document . write ( seriesSum ( n ) ) ;
function cal_speed ( dist , time ) { document . write ( " " + dist + " " ) ; document . write ( " " + time + " " ) ; return dist / time ; } function cal_dis ( speed , time ) { document . write ( " " + time + " " ) ; document . write ( " " + speed + " " ) ; return speed * time ; } function cal_time ( dist , speed ) { document . write ( " " + dist + " " ) ; document . write ( " " + speed + " " ) ; return speed * dist ; } document . write ( " " + cal_speed ( 45.9 , 2.0 ) + " " ) ; document . write ( " " ) ; document . write ( " " + cal_dis ( 62.9 , 2.5 ) + " " ) ; document . write ( " " ) ; document . write ( " " + cal_time ( 48.0 , 4.5 ) + " " ) ;
function find_factorial ( num1 , num2 ) { let vec = [ ] ; let t = 0 ; let fac = 1 ; let temp = num1 ; while ( 1 ) { if ( temp == 1 ) break ; fac *= temp ; temp -- ; } vec [ t ++ ] = fac ; num1 ++ ; while ( num1 <= num2 ) { fac *= num1 ; vec [ t ++ ] = fac ; num1 ++ ; } return ( vec ) ; } function print_format ( result ) { let x = result . length ; let digits = String ( result [ x - 1 ] ) . length ; for ( let i = 0 ; i < x ; i ++ ) { result [ i ] = new Array ( x - i ) . fill ( " " ) . join ( " " ) + result [ i ] ; document . write ( String ( result [ i ] ) + " " ) ; } } let m = 10 ; let n = 20 ; let result_fac ; result_fac = find_factorial ( m , n ) ; print_format ( result_fac ) ;
function term ( n ) { let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) ans += i ; return ans ; } let n = 4 ; document . write ( term ( n ) ) ;
function avgOfFirstN ( n ) { return ( 1 + n ) / 2 ; } let n = 20 ; document . write ( avgOfFirstN ( n ) ) ;
function summation ( n ) { let sum ; sum = ( Math . pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ; return sum ; } let n = 5 ; document . write ( summation ( n ) ) ;
function sum ( x , n ) { let total = 1.0 ; let multi = x ; for ( let i = 1 ; i <= n ; i ++ ) { total = total + multi / i ; multi = multi * x ; } return total ; } let x = 2 ; let n = 5 ; document . write ( sum ( x , n ) . toFixed ( 2 ) ) ;
function term ( n ) { let x = parseInt ( ( ( 1 ) + Math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) ; return x ; } let n = 5 ; document . write ( term ( n ) ) ;
function countDigits ( n ) { let c = 0 ; do { c ++ ; n = Math . floor ( n / 10 ) ; } while ( n != 0 ) ; return c ; } function isDeserium ( x ) { let temp = x ; let p = countDigits ( x ) ; let sum = 0 ; while ( x != 0 ) { let digit = x % 10 ; sum += Math . floor ( Math . pow ( digit , p ) ) ; p -- ; x = Math . floor ( x / 10 ) ; } return ( sum == temp ) ; } let x = 135 ; if ( isDeserium ( x ) ) document . write ( " " ) ; else document . write ( " " ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function sameRemainder ( a , b , c ) { var a1 = ( b - a ) , b1 = ( c - b ) , c1 = ( c - a ) ; return gcd ( a1 , gcd ( b1 , c1 ) ) ; } var a = 62 , b = 132 , c = 237 ; document . write ( sameRemainder ( a , b , c ) ) ;
function mean ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; var mean = sum / n ; return mean ; } function sd ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ; var sdd = sum / n ; return sdd ; } function combinedVariance ( arr1 , arr2 , n , m ) { var mean1 = mean ( arr1 , n ) ; var mean2 = mean ( arr2 , m ) ; document . write ( " " + mean1 . toFixed ( 4 ) + " " ) ; document . write ( " " + mean2 + " " ) ; var sd1 = sd ( arr1 , n ) ; var sd2 = sd ( arr2 , m ) ; document . write ( " " + sd1 . toFixed ( 3 ) + " " ) ; document . write ( " " + sd2 + " " + " " ) ; var combinedMean = ( n * mean1 + m * mean2 ) / ( n + m ) ; document . write ( " " + combinedMean . toFixed ( 4 ) + " " + " " ) ; var d1_square = ( mean1 - combinedMean ) * ( mean1 - combinedMean ) ; var d2_square = ( mean2 - combinedMean ) * ( mean2 - combinedMean ) ; document . write ( " " + d1_square . toFixed ( 3 ) + " " ) ; document . write ( " " + d2_square . toFixed ( 4 ) + " " ) ; var combinedVar = ( n * ( sd1 + d1_square ) + m * ( sd2 + d2_square ) ) / ( n + m ) ; return combinedVar ; } var arr1 = [ 23 , 45 , 34 , 78 , 12 , 76 , 34 ] var arr2 = [ 65 , 67 , 34 , 23 , 45 ] var n = arr1 . length ; var m = arr2 . length ; document . write ( " " + combinedVariance ( arr1 , arr2 , n , m ) . toFixed ( 3 ) ) ;
function checkDivisibility ( num ) { let length = num . length ; if ( length == 1 && num [ 0 ] == ' ' ) return true ; if ( length % 3 == 1 ) { num += " " ; length += 2 ; } else if ( length % 3 == 2 ) { num += " " ; length += 1 ; } let sum = 0 ; p = 1 ; for ( let i = length - 1 ; i >= 0 ; i -- ) { group = 0 ; group += num [ i -- ] - ' ' ; group += ( num [ i -- ] - ' ' ) * 10 ; group += ( num [ i ] - ' ' ) * 100 ; sum = sum + group * p ; p *= ( - 1 ) ; } sum = Math . abs ( sum ) ; return ( sum % 13 == 0 ) ; } let number = " " ; if ( checkDivisibility ( number ) ) document . write ( number + " " ) ; else document . write ( number + " " ) ;
function modularEquation ( a , b ) { if ( a < b ) { document . write ( " " ) ; return ; } if ( a == b ) { document . write ( " " ) ; return ; } let count = 0 ; let n = a - b ; let y = Math . sqrt ( a - b ) ; for ( let i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; document . write ( count ) ; } let a = 21 ; let b = 5 ; modularEquation ( a , b ) ;
function countWays ( num ) { let dp = [ ] ; let MOD = 1E9 + 7 ; dp [ 1 ] = 2 ; for ( let i = 2 ; i <= num ; ++ i ) { dp [ i ] = 0 ; for ( let j = 1 ; j <= 3 ; ++ j ) { if ( i - j == 0 ) dp [ i ] += 1 ; else if ( j == 1 ) dp [ i ] += dp [ i - j ] * 2 ; else if ( i - j > 0 ) dp [ i ] += dp [ i - j ] ; if ( dp [ i ] >= MOD ) dp [ i ] %= MOD ; } } return dp [ num ] ; } let n = 3 ; document . write ( countWays ( n ) ) ;
function judgeSquareSum ( n ) { for ( i = 2 ; i * i <= n ; i ++ ) { var count = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { count ++ ; n = parseInt ( n / i ) ; } if ( i % 4 == 3 && count % 2 != 0 ) return false ; } } return n % 4 != 3 ; } var n = 17 ; if ( judgeSquareSum ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countDigitOne ( n ) { var countr = 0 ; for ( var i = 1 ; i <= n ; i *= 10 ) { var divider = i * 10 ; countr += parseInt ( n / divider ) * i + Math . min ( Math . max ( n % divider - i + 1 , 0 ) , i ) ; } return countr ; } var n = 13 ; document . write ( countDigitOne ( n ) + " " ) ; n = 113 ; document . write ( countDigitOne ( n ) + " " ) ; n = 205 ; document . write ( countDigitOne ( n ) + " " ) ;
function isPrime ( c ) { return ( c == ' ' c == ' ' c == ' ' c == ' ' ) ; } function decrease ( s , i ) { if ( s [ i ] <= ' ' ) { s . splice ( i , 1 ) s [ i ] = ' ' ; } else if ( s [ i ] == ' ' ) s [ i ] = ' ' ; else if ( s [ i ] <= ' ' ) s [ i ] = ' ' ; else if ( s [ i ] <= ' ' ) s [ i ] = ' ' ; else s [ i ] = ' ' ; return s ; } function primeDigits ( s ) { for ( let i = 0 ; i < s . length ; i ++ ) { if ( ! isPrime ( s [ i ] ) ) { while ( i >= 0 && s [ i ] . charCodeAt ( 0 ) <= ' ' . charCodeAt ( 0 ) ) i -- ; if ( i < 0 ) { i = 0 ; s = decrease ( s . split ( " " ) , i ) ; } else s = decrease ( s . split ( " " ) , i ) ; for ( let j = i + 1 ; j < s . length ; j ++ ) s [ j ] = ' ' ; break ; } } return s . join ( " " ) ; } let s = " " ; document . write ( primeDigits ( s ) + " " ) ; s = " " ; document . write ( primeDigits ( s ) + " " ) ; s = " " ; document . write ( primeDigits ( s ) + " " ) ; s = " " ; document . write ( primeDigits ( s ) + " " ) ; s = " " ; document . write ( primeDigits ( s ) + " " ) ;
function greatest ( s ) { let n = s . length ; let a = new Array ( n ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { a [ i ] = s [ i ] - ' ' ; sum += a [ i ] ; } if ( a [ n - 1 ] % 2 ) { if ( a [ n - 2 ] % 2 != 0 || ( sum - a [ n - 1 ] ) % 3 != 0 ) { document . write ( " " + " " ) ; } else { document . write ( n + " " ) ; } } else { let re = sum % 3 ; let del = - 1 ; let flag = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( ( a [ i ] ) % 3 === re ) { if ( a [ i + 1 ] > a [ i ] ) { del = i ; flag = 1 ; break ; } else { del = i ; } } } if ( flag === 0 ) { if ( a [ n - 2 ] % 2 === 0 && re === a [ n - 1 ] % 3 ) del = n - 1 ; } if ( del === - 1 ) document . write ( - 1 + " " ) ; else { document . write ( del + 1 + " " ) ; } } } let s = " " ; greatest ( s ) ;
function asPowerSum ( w , m ) { while ( m > 0 ) { if ( ( m - 1 ) % w == 0 ) m = ( m - 1 ) / w ; else if ( ( m + 1 ) % w == 0 ) m = ( m + 1 ) / w ; else if ( m % w == 0 ) m = m / w ; else } return ( m == 0 ) ; } let w = 3 , m = 7 ; if ( asPowerSum ( w , m ) ) document . write ( " " ) ; else document . write ( " " ) ;
function divisible ( num ) { let n = num . length ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += ( num . charAt ( i ) ) ; if ( sum % 3 == 0 ) return 0 ; if ( n == 1 ) return - 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( sum % 3 == ( num . charAt ( i ) - ' ' ) % 3 ) return 1 ; if ( n == 2 ) return - 1 ; return 2 ; } let num = " " ; document . write ( divisible ( num ) ) ;
let n = 3 ; function dotProduct ( vect_A , vect_B ) { let product = 0 ; for ( let i = 0 ; i < n ; i ++ ) product = product + vect_A [ i ] * vect_B [ i ] ; return product ; } function crossProduct ( vect_A , vect_B , cross_P ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; } let vect_A = [ 3 , - 5 , 4 ] ; let vect_B = [ 2 , 6 , 5 ] ; let cross_P = [ ] ; document . write ( " " ) ; document . write ( dotProduct ( vect_A , vect_B ) + " " ) ; document . write ( " " ) ; crossProduct ( vect_A , vect_B , cross_P ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( cross_P [ i ] + " " ) ;
let MOD = 1000000007 ; function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( 1 * res * x ) % p ; x = ( 1 * x * x ) % p ; } return res ; } function countEvenWays ( n ) { return power ( 2 , n / 2 - 1 , MOD ) ; } let n = 6 ; document . write ( countEvenWays ( n ) + " " ) ; n = 8 ; document . write ( countEvenWays ( n ) ) ;
let MAX = 1000001 ; let factor = [ ] ; function cal_factor ( ) { factor [ 1 ] = 1 ; for ( let i = 2 ; i < MAX ; i ++ ) factor [ i ] = i ; for ( let i = 4 ; i < MAX ; i += 2 ) factor [ i ] = 2 ; for ( let i = 3 ; i * i < MAX ; i ++ ) { if ( factor [ i ] == i ) { for ( let j = i * i ; j < MAX ; j += i ) { if ( factor [ j ] == j ) factor [ j ] = i ; } } } } function no_of_representations ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let temp = a [ i ] ; let flag = 0 ; while ( factor [ temp ] != 1 ) { flag = - 1 ; count ++ ; temp = temp / factor [ temp ] ; } count += flag ; } return count ; } cal_factor ( ) ; let a = [ 4 , 4 , 4 ] ; let n = a . length ; document . write ( no_of_representations ( a , n ) ) ;
function coutSubSeq ( A , N , M ) { let sum = 0 ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { for ( let k = j + 1 ; k < N ; k ++ ) { sum = A [ i ] + A [ j ] + A [ k ] ; if ( sum % M == 0 ) ans ++ ; } } } return ans ; } let M = 3 ; let A = [ 1 , 2 , 4 , 3 ] ; let N = A . length ; document . write ( coutSubSeq ( A , N , M ) ) ;
function countSubSeq ( A , N , M ) { var ans = 0 ; var h = Array . from ( { length : M } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { A [ i ] = A [ i ] % M ; h [ A [ i ] ] ++ ; } for ( var i = 0 ; i < M ; i ++ ) { for ( var j = i ; j < M ; j ++ ) { var rem = ( M - ( i + j ) % M ) % M ; if ( rem < j ) continue ; if ( i == j && rem == j ) ans += h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 ; else if ( i == j ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ; else if ( i == rem ) ans += h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 ; else if ( rem == j ) ans += h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 ; else ans = ans + h [ i ] * h [ j ] * h [ rem ] ; } } return ans ; } var M = 3 ; var A = [ 1 , 2 , 4 , 3 ] ; var N = A . length ; document . write ( countSubSeq ( A , N , M ) ) ;
function findTerm ( n ) { if ( n == 1 ) return n ; else { let term = 7 ; for ( let i = 2 ; i <= n ; i ++ ) term = term * 2 + ( i - 1 ) ; return term ; } } let n = 5 ; document . write ( findTerm ( n ) ) ;
function findNumber ( n ) { n -- ; let i = 1 ; while ( n >= 0 ) { n -= i ; ++ i ; } return ( n + i ) ; } let n = 3 ; document . write ( findNumber ( n ) ) ;
function correlationCoefficient ( X , Y , n ) { let sum_X = 0 , sum_Y = 0 , sum_XY = 0 ; let squareSum_X = 0 , squareSum_Y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum_X = sum_X + X [ i ] ; sum_Y = sum_Y + Y [ i ] ; sum_XY = sum_XY + X [ i ] * Y [ i ] ; squareSum_X = squareSum_X + X [ i ] * X [ i ] ; squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] ; } let corr = ( n * sum_XY - sum_X * sum_Y ) / ( Math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) ; return corr ; } let X = [ 15 , 18 , 21 , 24 , 27 ] ; let Y = [ 25 , 25 , 27 , 31 , 32 ] ; let n = X . length ; document . write ( correlationCoefficient ( X , Y , n ) ) ;
function result ( n , k , t ) { if ( t <= k ) document . write ( t ) ; else if ( t <= n ) document . write ( k ) ; else { let temp = t - n ; temp = k - temp ; document . write ( temp ) ; } } let n , k , t ; n = 10 ; k = 5 ; t = 12 ; result ( n , k , t ) ;
function weightedMean ( X , W , n ) { let sum = 0 , numWeight = 0 ; for ( let i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( numWeight ) / sum ; } let X = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ; let W = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] ; let n = X . length ; let m = W . length ; if ( n == m ) document . write ( weightedMean ( X , W , n ) ) ; else document . write ( " " ) ;
function gcd ( a , b ) { if ( a < b ) return gcd ( b , a ) ; if ( Math . abs ( b ) < 0.001 ) return a ; else return ( gcd ( b , a - Math . floor ( a / b ) * b ) ) ; } var a = 1.20 , b = 22.5 ; document . write ( gcd ( a , b ) . toFixed ( 1 ) ) ;
function harmonicMean ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum = sum + ( 1 / arr [ i ] ) ; return n / sum ; } let arr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] ; let n = arr . length ; document . write ( harmonicMean ( arr , n ) ) ;
function harmonicMean ( arr , freq , n ) { let sum = 0 , frequency_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + ( freq [ i ] / arr [ i ] ) ; frequency_sum = frequency_sum + freq [ i ] ; } return frequency_sum / sum ; } let num = [ 13 , 14 , 15 , 16 , 17 ] ; let freq = [ 2 , 5 , 13 , 7 , 3 ] ; let n = num . length ; document . write ( harmonicMean ( num , freq , n ) ) ;
function point ( a , b , c , d , n ) { let x ; let flag = 0 ; for ( let i = 0 ; i < n ; i ++ ) { x = b + i * a ; if ( ( x - d ) % c == 0 && x - d >= 0 ) { document . write ( x ) ; flag = 1 ; break ; } } if ( flag == 0 ) { document . write ( " " ) ; } } let a = 20 ; let b = 2 ; let c = 9 ; let d = 19 ; let n = 20 ; point ( a , b , c , d , n ) ;
function findArmstrong ( low , high ) { for ( let i = low + 1 ; i < high ; ++ i ) { let x = i ; let n = 0 ; while ( x != 0 ) { x = parseInt ( x / 10 ) ; ++ n ; } let pow_sum = 0 ; x = i ; while ( x != 0 ) { let digit = x % 10 ; pow_sum += parseInt ( Math . pow ( digit , n ) ) ; x = parseInt ( x / 10 ) ; } if ( pow_sum == i ) document . write ( i + " " ) ; } } let num1 = 100 ; let num2 = 400 ; findArmstrong ( num1 , num2 ) ;
function gcdMax ( a , b , n , N ) { let cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let first = Array . from ( { length : N } , ( _ , i ) => 0 ) ; let second = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ a [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) first [ i ] = Math . max ( first [ i ] , j ) ; cnt = Array . from ( { length : N } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; ++ i ) cnt [ b [ i ] ] = 1 ; for ( let i = 1 ; i < N ; ++ i ) for ( let j = i ; j < N ; j += i ) if ( cnt [ j ] > 0 ) second [ i ] = Math . max ( second [ i ] , j ) ; let x ; for ( x = N - 1 ; x >= 0 ; x -- ) if ( first [ x ] > 0 && second [ x ] > 0 ) break ; document . write ( first [ x ] + " " + second [ x ] ) ; } let a = [ 3 , 1 , 4 , 2 , 8 ] ; let b = [ 5 , 2 , 12 , 8 , 3 ] ; let n = a . length ; let N = 20 ; gcdMax ( a , b , n , N ) ;
function printPierpont ( n ) { var arr = Array ( n + 1 ) . fill ( false ) ; var two = 1 , three = 1 ; while ( two + 1 < n ) { arr [ two ] = true ; while ( two * three + 1 < n ) { arr [ three ] = true ; arr [ two * three ] = true ; three *= 3 ; } three = 1 ; two *= 2 ; } var v = [ ] ; for ( var i = 0 ; i < n ; i ++ ) if ( arr [ i ] ) v . push ( i + 1 ) ; arr = Array ( n + 1 ) . fill ( false ) ; for ( var p = 2 ; p * p < n ; p ++ ) { if ( arr [ p ] == false ) for ( var i = p * 2 ; i < n ; i += p ) arr [ i ] = true ; } for ( var i = 0 ; i < v . length ; i ++ ) if ( ! arr [ v [ i ] ] ) document . write ( v [ i ] + " " ) ; } var n = 200 ; printPierpont ( n ) ;
function isWoodall ( x ) { if ( x % 2 == 0 ) return false ; if ( x == 1 ) return true ; x ++ ; let p = 0 ; while ( x % 2 == 0 ) { x = x / 2 ; p ++ ; if ( p == x ) return true ; } return false ; } let x = 383 ; if ( isWoodall ( x ) ) document . write ( " " ) ; else document . write ( " " ) ;
function print_result ( a , n , k , m ) { var v = Array . from ( Array ( m ) , ( ) => Array ( ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var rem = a [ i ] % m ; v [ rem ] . push ( a [ i ] ) ; if ( v [ rem ] . length == k ) { for ( var j = 0 ; j < k ; j ++ ) document . write ( v [ rem ] [ j ] + " " ) ; return ; } } document . write ( " " ) ; } var a = [ 1 , 8 , 4 ] ; var n = a . length ; print_result ( a , n , 2 , 3 ) ;
function smallestX ( n ) { let temp = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < 10 ; i ++ ) temp [ i ] = 0 ; if ( n == 0 ) return - 1 ; let count = 0 , x = 0 ; for ( x = 1 ; count < 10 ; x ++ ) { let y = x * n ; while ( y > 0 ) { if ( temp [ y % 10 ] == 0 ) { count ++ ; temp [ y % 10 ] = 1 ; } y /= 10 ; } } return x - 1 ; } let n = 5 ; document . write ( smallestX ( n ) ) ;
function digSum ( n ) { let sum = 0 , rem = 0 ; while ( n > 0 ) { rem = n % 10 ; sum += rem ; n = Math . floor ( n / 10 ) ; } return sum ; } function findX ( n ) { for ( let i = 0 ; i <= n ; i ++ ) if ( i + digSum ( i ) == n ) return i ; return - 1 ; } let n = 43 ; document . write ( " " + findX ( n ) ) ;
function complement ( number ) { number = number . split ( ' ' ) for ( let i = 0 ; i < number . length ; i ++ ) { if ( number [ i ] != ' ' ) { number [ i ] = String ( 9 - Number ( number [ i ] ) + 0 ) ; } } number = number . join ( " " ) document . write ( " " + number ) ; } let number = " " ; complement ( number ) ;
function countWays ( n ) { let count = 0 ; for ( let i = 1 ; i * i < n ; i ++ ) if ( n % i == 0 ) count ++ ; return count ; } let n = 12 ; document . write ( countWays ( n ) ) ;
function isDigitPresent ( m , hash ) { while ( m > 0 ) { if ( hash [ m % 10 ] ) return true ; m = Math . floor ( m / 10 ) ; } return false ; } function countDivisibles ( n ) { let hash = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; let m = n ; while ( m > 0 ) { hash [ m % 10 ] = true ; m = Math . floor ( m / 10 ) ; } let ans = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( isDigitPresent ( i , hash ) ) ans ++ ; if ( n / i != i ) { if ( isDigitPresent ( n / i , hash ) ) ans ++ ; } } } return ans ; } let n = 15 ; document . write ( countDivisibles ( n ) ) ;
var s = " " ; function luDecomposition ( mat , n ) { var lower = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; var upper = Array ( n ) . fill ( 0 ) . map ( x => Array ( n ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var k = i ; k < n ; k ++ ) { var sum = 0 ; for ( var j = 0 ; j < i ; j ++ ) sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) ; upper [ i ] [ k ] = mat [ i ] [ k ] - sum ; } for ( var k = i ; k < n ; k ++ ) { if ( i == k ) lower [ i ] [ i ] = 1 ; else { var sum = 0 ; for ( var j = 0 ; j < i ; j ++ ) sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) ; lower [ k ] [ i ] = parseInt ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) ; } } } document . write ( setw ( 2 ) + " " + setw ( 10 ) + " " ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) document . write ( setw ( 4 ) + lower [ i ] [ j ] + " " ) ; document . write ( setw ( 10 ) ) ; for ( var j = 0 ; j < n ; j ++ ) document . write ( setw ( 4 ) + upper [ i ] [ j ] + " " ) ; document . write ( " " ) ; } } function setw ( noOfSpace ) { var s = " " ; for ( i = 0 ; i < noOfSpace ; i ++ ) s += " " ; return s ; } var mat = [ [ 2 , - 1 , - 2 ] , [ - 4 , 6 , 3 ] , [ - 4 , - 2 , 8 ] ] ; luDecomposition ( mat , 3 ) ;
function printTwoDivisibleParts ( num , f , s ) { var N = num . length ; var prefixReminder = [ ] var suffixReminder = [ ] suffixReminder [ 0 ] = 0 ; for ( var i = 1 ; i < N ; i ++ ) suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( num [ i - 1 ] - ' ' ) ) % f ; prefixReminder [ N ] = 0 ; var base1 = 1 ; for ( var i = N - 1 ; i >= 0 ; i -- ) { prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( num [ i ] - ' ' ) * base1 ) % s ; base1 = ( base1 * 10 ) % s ; } for ( var i = 0 ; i < N ; i ++ ) { if ( prefixReminder [ i ] == 0 && suffixReminder [ i ] == 0 && num [ i ] != ' ' ) { document . write ( num . substring ( 0 , i ) + " " + num . substring ( i ) ) ; return ; } } document . write ( " " ) ; } var num = " " ; var f = 12345 ; var s = 1024 ; printTwoDivisibleParts ( num , f , s ) ;
function calculate ( a , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let r = i + 1 ; for ( let j = r ; j < n ; j ++ ) { if ( a [ i ] == a [ j ] ) r += 1 ; else break ; } let d = r - i ; ans += ( d * ( d + 1 ) / 2 ) ; i = r - 1 ; } return ans ; } let a = [ 2 , 4 , 5 , 3 , 3 , 3 ] ; document . write ( calculate ( a , a . length ) ) ;
function sum ( n ) { var rem = 0 ; var sum_of_digits = 0 ; while ( n > 0 ) { rem = n % 10 ; sum_of_digits += rem ; n = parseInt ( n / 10 ) ; } return sum_of_digits ; } function count ( n ) { var c = 0 ; for ( i = n - 97 ; i <= n ; i ++ ) { var a = sum ( i ) ; var b = sum ( a ) ; if ( ( i + a + b ) == n ) { c += 1 ; } } return c ; } var n = 9939 ; document . write ( count ( n ) ) ;
function isPowerOfK ( n , k ) { let oneSeen = false ; while ( n > 0 ) { let digit = n % k ; if ( digit > 1 ) return false ; if ( digit == 1 ) { if ( oneSeen ) return false ; oneSeen = true ; } n = Math . floor ( n / k ) ; } return true ; } let n = 64 , k = 4 ; if ( isPowerOfK ( n , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
const MAX_DIGITS = 20 ; function isOctal ( n ) { while ( n ) { if ( ( n % 10 ) >= 8 ) return false ; else n = Math . floor ( n / 10 ) ; } return true ; } function isPalindrome ( n ) { var divide = ( isOctal ( n ) == false ) ? 8 : 10 ; var octal = new Array ( MAX_DIGITS ) ; var i = 0 ; while ( n != 0 ) { octal [ i ++ ] = n % divide ; n = Math . floor ( n / divide ) ; } for ( var j = i - 1 , k = 0 ; k <= j ; j -- , k ++ ) if ( octal [ j ] != octal [ k ] ) return false ; return true ; } var n = 97 ; if ( isPalindrome ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function printFactorialNums ( n ) { let fact = 1 ; let x = 2 ; while ( fact <= n ) { document . write ( fact + " " ) ; fact = fact * x ; x ++ ; } } let n = 100 ; printFactorialNums ( n ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function isThreeDisctFactors ( n ) { let sq = parseInt ( Math . sqrt ( n ) ) ; if ( sq * sq != n ) return false ; return isPrime ( sq ) ? true : false ; } let num = 9 ; if ( isThreeDisctFactors ( num ) ) document . write ( " " ) ; else document . write ( " " ) ; num = 15 ; if ( isThreeDisctFactors ( num ) ) document . write ( " " ) ; else document . write ( " " ) ; num = 12397923568441 ; if ( isThreeDisctFactors ( num ) ) document . write ( " " ) ; else document . write ( " " ) ;
function computeLastDigit ( A , B ) { let variable = 1 ; return 1 ; else if ( ( B - A ) >= 5 ) return 0 ; else { for ( let i = A + 1 ; i <= B ; i ++ ) variable = ( variable * ( i % 10 ) ) % 10 ; return variable % 10 ; } } document . write ( computeLastDigit ( 2632 , 2634 ) ) ;
function sumOfAP ( a , d , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum = sum + a ; a = a + d ; } return sum ; } let n = 20 ; let a = 2.5 , d = 1.5 ; document . write ( sumOfAP ( a , d , n ) ) ;
function multiplyFactors ( n ) { let M = 1000000007 ; let i ; prod = 1 ; for ( i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) prod = ( prod * i ) % M ; else { prod = ( prod * i ) % M ; prod = ( prod * n / i ) % M ; } } } return prod ; } n = 12 ; document . write ( multiplyFactors ( n ) ) ;
let M = 1000000007 ; function power ( x , y ) { let res = 1 ; while ( y > 0 ) { if ( y % 2 == 1 ) res = ( res * x ) % M ; y = ( y >> 1 ) % M ; x = ( x * x ) % M ; } return res ; } function countFactors ( n ) { let count = 0 ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) count ++ ; else count += 2 ; } } return count ; } function multiplyFactors ( n ) { let numFactor = countFactors ( n ) ; let product = power ( n , numFactor / 2 ) ; if ( numFactor % 2 == 1 ) product = ( product * Math . sqrt ( n ) ) % M ; return product ; } let n = 12 ; document . write ( multiplyFactors ( n ) ) ;
function isDivisibleBy10 ( bin ) { let n = bin . length ; if ( bin [ n - 1 ] == ' ' ) return false ; let sum = 0 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == ' ' ) { let posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; } let bin = " " ; if ( isDivisibleBy10 ( bin ) ) document . write ( " " ) ; else document . write ( " " ) ;
function printTrib ( n ) { if ( n < 1 ) return ; let first = 0 , second = 0 ; let third = 1 ; document . write ( first + " " ) ; if ( n > 1 ) document . write ( second + " " ) ; if ( n > 2 ) document . write ( second + " " ) ; for ( let i = 3 ; i < n ; i ++ ) { let curr = first + second + third ; first = second ; second = third ; third = curr ; document . write ( curr + " " ) ; } } let n = 10 ; printTrib ( n ) ;
function SieveOfEratosthenes ( n ) { let prime = new Array ( n + 1 ) . fill ( true ) ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) for ( let i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = false ; } let lis = new Array ( ) ; for ( let p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) lis . push ( p ) ; return lis ; } function setBits ( n ) { let cnt = 0 ; while ( n ) { if ( n & 1 ) cnt ++ ; n >>= 1 ; } ; return cnt ; } let x = 4 ; let y = 8 ; let count = 0 ; let primeArr = SieveOfEratosthenes ( Math . ceil ( Math . log ( y , 2 ) ) ) ; for ( let i = x ; i < y + 1 ; i ++ ) { let temp = setBits ( i ) ; if ( primeArr . includes ( temp ) ) count += 1 ; } document . write ( count ) ;
function count_square ( n ) { let count = 0 ; for ( let i = 1 ; i <= n ; i = i + 2 ) { let k = n - i + 1 ; count += ( k * k ) ; } return count ; } let N = 8 ; document . write ( count_square ( N ) ) ;
function countAnomalies ( arr , n , k ) { var cnt = 0 ; var i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; } var arr = [ 1 , 3 , 5 ] ; var n = arr . length ; var k = 1 ; document . write ( countAnomalies ( arr , n , k ) ) ;
const N = 100005 ; let d = new Array ( N ) . fill ( 0 ) ; let pre = new Array ( N ) . fill ( 0 ) ; function Positive_Divisors ( ) { for ( let i = 1 ; i < N ; i ++ ) { for ( let j = 1 ; j * j <= i ; j ++ ) { if ( i % j == 0 ) { if ( j * j == i ) d [ i ] ++ ; else d [ i ] += 2 ; } } } let ans = 0 ; for ( let i = 2 ; i < N ; i ++ ) { if ( d [ i ] == d [ i - 1 ] ) ans ++ ; pre [ i ] = ans ; } } Positive_Divisors ( ) ; let n = 15 ; document . write ( pre [ n ] ) ;
function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) { return - 1 ; } var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = number * 10 + 1 ; if ( ( number % K == 0 ) ) { return len ; } } return - 1 ; } var K = 7 ; document . write ( numLen ( K ) ) ;
function doesContainB ( a , b , c ) { if ( a == b ) { return true ; } if ( ( b - a ) * c > 0 && ( b - a ) % c == 0 ) { return true ; } return false ; } let a = 1 , b = 7 , c = 3 ; if ( doesContainB ( a , b , c ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function printPermutation ( n , k ) { for ( var i = 1 ; i <= n ; i ++ ) { var x = 2 * i - 1 ; var y = 2 * i ; if ( i <= k ) document . write ( y + " " + x + " " ) ; else document . write ( x + " " + y + " " ) ; } } var n = 2 , k = 1 ; printPermutation ( n , k ) ;
function maxSum ( N ) { var ans = 0 ; for ( var u = 1 ; u <= N ; u ++ ) { for ( var v = 1 ; v <= N ; v ++ ) { if ( u == v ) continue ; var degreeU = 2 ; if ( u == 1 u == N ) degreeU = 1 ; var degreeV = 2 ; if ( v == 1 v == N ) degreeV = 1 ; ans += ( degreeU * degreeV ) ; } } return ans ; } var N = 6 ; document . write ( maxSum ( N ) ) ;
function maximumFactor ( arr ) { var n = arr . length ; var rank = [ ] ; var factors = [ ] ; var max = arr . reduce ( ( a , b ) => Math . max ( a , b ) ) ; for ( var i = 2 ; i <= max ; i ++ ) { var count = 0 ; for ( var j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % i == 0 ) count += 1 ; rank . push ( count ) ; factors . push ( i ) ; } } var m = rank . reduce ( ( a , b ) => Math . max ( a , b ) ) ; for ( var i = 0 ; i < rank . length ; i ++ ) { if ( rank [ i ] == m ) document . write ( factors [ i ] + " " ) ; } } var arr = [ 120 , 15 , 24 , 63 , 18 ] ; maximumFactor ( arr ) ;
function findSum ( n ) { let sum = 0 ; for ( x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; } n = 5 ; document . write ( findSum ( n ) ) ;
function findMedian ( a , n ) { a . sort ( ) ; if ( n % 2 != 0 ) return a [ parseInt ( n / 2 ) ] ; return ( a [ parseInt ( ( n - 1 ) / 2 ) ] + a [ parseInt ( n / 2 ) ] ) / 2.0 ; } let a = [ 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ] ; let n = a . length ; document . write ( " " + findMedian ( a , n ) ) ;
function CheckArray ( arr , n ) { let prod = 1 ; let freq = [ ] ; for ( let i = 0 ; i < n ; ++ i ) { freq . push ( arr [ i ] ) ; prod *= arr [ i ] ; } let root = Math . floor ( Math . sqrt ( prod ) ) ; if ( root * root == prod ) { if ( freq . includes ( root ) & freq . lastIndexOf ( root ) != ( freq . length ) ) { return true ; } } return false ; } let arr = [ 1 , 2 , 12 , 3 , 2 ] ; let n = arr . length ; if ( CheckArray ( arr , n ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function toK ( N , K ) { let w = 1 ; let s = 0 ; while ( N != 0 ) { let r = N % K ; N = parseInt ( N / K ) ; s = r * w + s ; w *= 10 ; } return s ; } function check ( N ) { let fl = false ; while ( N != 0 ) { let r = N % 10 ; N = parseInt ( N / 10 ) ; if ( fl == true && r == 0 ) return false ; if ( r > 0 ) { fl = false ; continue ; } fl = true ; } return true ; } function hasConsecutiveZeroes ( N , K ) { let z = toK ( N , K ) ; if ( check ( z ) ) document . write ( " " ) ; else document . write ( " " ) ; } let N = 15 ; let K = 8 ; hasConsecutiveZeroes ( N , K ) ;
let MAX = 100000 ; let prime = new Array ( MAX + 1 ) . fill ( true ) ; function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; prime [ 0 ] = false ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } function SumOfKthPrimes ( arr , n , k ) { let c = 0 ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { c ++ ; if ( c % k == 0 ) { sum += arr [ i ] ; c = 0 ; } } } document . write ( sum + " " ) ; } SieveOfEratosthenes ( ) ; let arr = new Array ( 2 , 3 , 5 , 7 , 11 ) ; let n = arr . length ; let k = 2 ; SumOfKthPrimes ( arr , n , k ) ;
var MAX = 100000 ; var prime = Array ( 100002 ) . fill ( true ) ; function SieveOfEratosthenes ( ) { for ( var p = 2 ; p * p <= MAX ; p ++ ) if ( prime [ p ] == true ) for ( var i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } function superpower ( n ) { SieveOfEratosthenes ( ) ; var superPower = 0 , factor = 0 ; var i = 2 ; while ( n > 1 && i <= MAX ) { if ( prime [ i ] ) { factor = 0 ; while ( n % i == 0 && n > 1 ) { factor ++ ; n = n / i ; } if ( superPower < factor ) superPower = factor ; } i ++ ; } return superPower ; } var n = 256 ; document . write ( superpower ( n ) ) ;
function smallestDivisor ( n ) { if ( n % 2 == 0 ) return 2 ; for ( var i = 3 ; i * i <= n ; i += 2 ) { if ( n % i == 0 ) return i ; } return n ; } var n = 31 ; document . write ( smallestDivisor ( n ) ) ;
function countRabbits ( Heads , Legs ) { var count = 0 ; count = ( Legs ) - 2 * ( Heads ) ; count = count / 2 ; return count ; } var Heads = 100 , Legs = 300 ; var Rabbits = countRabbits ( Heads , Legs ) ; document . write ( " " + Rabbits + " " ) ; document . write ( " " + ( Heads - Rabbits ) ) ;
function calculateSum ( n ) { return 2 * ( Math . pow ( n , 6 ) + 15 * Math . pow ( n , 4 ) + 15 * Math . pow ( n , 2 ) + 1 ) ; } var n = 1.4142 ; document . write ( parseInt ( Math . ceil ( calculateSum ( n ) ) ) ) ;
function Sum_upto_nth_Term ( n ) { return ( 1 - parseInt ( Math . pow ( - 2 , n ) ) ) ; } let N = 5 ; document . write ( Sum_upto_nth_Term ( N ) ) ;
function xorEqualsOrCount ( N ) { let count = 0 ; let bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = parseInt ( N / 2 ) ; } return Math . pow ( 2 , count ) ; } let N = 7 ; document . write ( xorEqualsOrCount ( N ) ) ;
function fact ( n ) { if ( n == 1 ) return 1 ; return n * fact ( n - 1 ) ; } function sum ( x , n ) { let total = 1.0 ; for ( let i = 1 ; i <= n ; i ++ ) { total = total + ( Math . pow ( x , i ) / fact ( i + 1 ) ) ; } return total . toFixed ( 4 ) ; } let x = 5 ; let n = 4 ; document . write ( " " + sum ( x , n ) ) ;
function sum_of_series ( n ) { var result = 0 ; for ( i = 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) result = result - parseInt ( Math . pow ( i , 2 ) ) ; else result = result + parseInt ( Math . pow ( i , 2 ) ) ; } return result ; } var n = 3 ; document . write ( sum_of_series ( n ) + " " ) ; n = 10 ; document . write ( sum_of_series ( n ) ) ;
function findSum ( N ) { return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 ; } let N = 4 ; document . write ( findSum ( N ) ) ;
MAX = 16 var nCr = Array . from ( Array ( MAX ) , ( ) => new Array ( MAX ) ) ; function binomial ( ) { for ( var i = 0 ; i < MAX ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) { if ( j == 0 j == i ) nCr [ i ] [ j ] = 1 ; else nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] ; } } } function findCosNTheta ( sinTheta , n ) { var cosTheta = Math . sqrt ( 1 - sinTheta * sinTheta ) ; var ans = 0 ; var toggle = 1 ; for ( var i = 1 ; i <= n ; i += 2 ) { ans = ans + nCr [ n ] [ i ] * Math . pow ( cosTheta , n - i ) * Math . pow ( sinTheta , i ) * toggle ; toggle = toggle * - 1 ; } return ans . toFixed ( 6 ) ; } binomial ( ) ; var sinTheta = 0.5 ; var n = 10 ; document . write ( findCosNTheta ( sinTheta , n ) ) ;
function nthTerm ( N ) { return ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ; } let N = 4 ; document . write ( nthTerm ( N ) ) ;
function calculateSum ( n ) { return ( parseInt ( Math . pow ( 10 , n + 1 ) ) * ( 9 * n - 1 ) + 10 ) / parseInt ( Math . pow ( 9 , 3 ) ) - n * ( n + 1 ) / 18 ; } let n = 3 ; document . write ( " " + calculateSum ( n ) ) ;
function calculateSum ( n ) { if ( n % 2 == 1 ) return ( n + 1 ) / 2 ; return - n / 2 ; } var n = 8 ; document . write ( calculateSum ( n ) ) ;
function isPower ( a ) { if ( a == 1 ) return true ; for ( let i = 2 ; i * i <= a ; i ++ ) { let val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - Math . floor ( val ) ) < 0.00000001 ) return true ; } return false ; } let n = 16 ; document . write ( isPower ( n ) ? " " : " " ) ;
function rmsValue ( arr , n ) { var square = 0 ; var mean = 0 ; var root = 0 ; for ( i = 0 ; i < n ; i ++ ) { square += Math . pow ( arr [ i ] , 2 ) ; } mean = ( square / ( n ) ) ; root = Math . sqrt ( mean ) ; return root ; } var arr = [ 10 , 4 , 6 , 8 ] ; var n = arr . length ; document . write ( rmsValue ( arr , n ) . toFixed ( 5 ) ) ;
function Mixture ( X , Y , Z ) { var result = 0.0 , result1 = 0.0 ; result1 = ( ( X - Y ) / X ) ; result = Math . pow ( result1 , Z ) ; result = result * X ; return result ; } var X = 10 , Y = 2 , Z = 2 ; document . write ( Mixture ( X , Y , Z ) . toFixed ( 1 ) + " " ) ;
const mod = ( 1e9 + 7 ) ; function power ( x , y , p ) { while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function check ( n ) { n -- ; let ans = n * n ; if ( ans >= mod ) ans %= mod ; ans += n + 2 ; if ( ans >= mod ) ans %= mod ; ans = ( power ( 2 , n , mod ) % mod * ans % mod ) % mod ; ans = ( ans - 1 + mod ) % mod ; return ans ; } let n = 4 ; document . write ( check ( n ) ) ;
function findLCM ( a , b ) { var lar = Math . max ( a , b ) ; var small = Math . min ( a , b ) ; for ( i = lar ; ; i += lar ) { if ( i % small == 0 ) return i ; } } var a = 5 , b = 7 ; document . write ( " " + a + " " + b + " " + findLCM ( a , b ) ) ;
function primes ( n ) { var i = 2 ; var j = 0 ; var result = Array ( n ) var z = 0 ; while ( j < n ) { var flag = true ; for ( var item = 2 ; item <= parseInt ( i * 1 / 2 ) ; item ++ ) if ( i % item == 0 && i != item ) { flag = false ; break ; } if ( flag ) { result [ z ++ ] = i ; j += 1 ; } i += 1 ; } for ( i = 0 ; i < 5 ; i ++ ) { for ( j = 0 ; j <= i ; j ++ ) document . write ( result [ j ] ) ; document . write ( " " ) ; } } function smar_wln ( n ) { primes ( n ) ; } var n = 5 ; document . write ( " " + n + " " ) ; smar_wln ( n ) ;
function Pentatope_number ( n ) { return n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 24 ; } let n = 7 ; document . write ( n + " " + " " + Pentatope_number ( n ) + " " ) ; n = 12 ; document . write ( n + " " + " " + Pentatope_number ( n ) ) ;
function centeredIcosahedralNum ( n ) { return parseInt ( ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) / 3 ) ; } let n = 10 ; document . write ( centeredIcosahedralNum ( n ) + " " ) ; n = 12 ; document . write ( centeredIcosahedralNum ( n ) ) ;
function seriesSum ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } var n = 4 ; document . write ( seriesSum ( n ) ) ;
function Dodecagonal_number ( n ) { return 5 * n * n - 4 * n ; } let n = 7 ; document . write ( Dodecagonal_number ( n ) + " " ) ; n = 12 ; document . write ( Dodecagonal_number ( n ) + " " ) ;
function SieveOfEratosthenes ( n , prime , primesquare , a ) { for ( var i = 2 ; i <= n ; i ++ ) prime [ i ] = true ; for ( var i = 0 ; i <= ( n * n + 1 ) ; i ++ ) primesquare [ i ] = false ; prime [ 1 ] = false ; for ( var p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } var j = 0 ; for ( var p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { a [ j ] = p ; primesquare [ p * p ] = true ; j ++ ; } } } function countDivisors ( n ) { if ( n == 1 ) return 1 ; var prime = Array ( n + 1 ) . fill ( false ) ; var primesquare = Array ( n * n + 1 ) . fill ( 0 ) ; SieveOfEratosthenes ( n , prime , primesquare , a ) ; var ans = 1 ; for ( var i = 0 ; ; i ++ ) { if ( a [ i ] * a [ i ] * a [ i ] > n ) break ; var cnt = 1 ; while ( n % a [ i ] == 0 ) { n = parseInt ( n / a [ i ] ) ; } ans = ans * cnt ; } if ( prime [ n ] ) ans = ans * 2 ; else if ( primesquare [ n ] ) ans = ans * 3 ; else if ( n != 1 ) ans = ans * 4 ; } function sumofFactors ( n ) { var res = 1 ; for ( var i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { var count = 0 , curr_sum = 1 ; var curr_term = 1 ; while ( n % i == 0 ) { count ++ ; n = parseInt ( n / i ) ; curr_term *= i ; curr_sum += curr_term ; } res *= curr_sum ; } if ( n >= 2 ) res *= ( 1 + n ) ; return res ; } function checkArithmetic ( n ) { var count = countDivisors ( n ) ; var sum = sumofFactors ( n ) ; return ( sum % count == 0 ) ; } var n = 6 ; ( checkArithmetic ( n ) ) ? ( document . write ( " " ) ) : ( document . write ( " " ) ) ;
function magicOfSequence ( N ) { return ( N * ( N + 1 ) / 2 ) + 2 * N ; } let N = 6 ; document . write ( magicOfSequence ( N ) ) ;
function nextPower ( N , power ) { var carry = 0 ; for ( var i = 0 ; i < power . length ; i ++ ) { var prod = ( power [ i ] * N ) + carry ; power [ i ] = prod % 10 ; carry = parseInt ( prod / 10 ) ; } while ( carry >= 1 ) { power . push ( carry % 10 ) ; carry = parseInt ( carry / 10 ) ; } return power ; } function printPowerNumber ( X , N ) { var power = [ ] ; power . push ( 1 ) ; var res = [ ] ; for ( var i = 1 ; i <= X ; i ++ ) { power = nextPower ( N , power ) ; res . push ( power [ power . length - 1 ] ) ; res . push ( power [ 0 ] ) ; } for ( var i = 0 ; i < res . length ; i ++ ) document . write ( res [ i ] ) ; } var N = 19 , X = 4 ; printPowerNumber ( X , N ) ;
function firstDigit ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { fact = fact * i ; while ( fact % 10 == 0 ) fact = fact / 10 ; } while ( fact >= 10 ) fact = fact / 10 ; return ( Math . round ( fact ) ) ; } let n = 5 ; document . write ( firstDigit ( n ) ) ;
function sumofseries ( n ) { let res = 0 ; for ( let i = 1 ; i <= n ; i ++ ) res += ( i ) * ( i + 1 ) * ( i + 2 ) ; return res ; } document . write ( sumofseries ( 3 ) ) ;
function printGMeans ( A , B , N ) { let R = Math . pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ; for ( let i = 1 ; i <= N ; i ++ ) document . write ( A * Math . pow ( R , i ) + " " ) ; } let A = 3 , B = 81 , N = 2 ; printGMeans ( A , B , N ) ;
function digitSum ( n ) { let digSum = 0 ; while ( n > 0 ) { digSum += n % 10 ; n /= 10 ; } return digSum ; } function countInteger ( n , s ) { if ( n < s ) return 0 ; for ( let i = s ; i <= Math . min ( n , s + 163 ) ; i ++ ) if ( ( i - digitSum ( i ) ) > s ) return ( n - i + 1 ) ; return 0 ; } let n = 1000 , s = 100 ; document . write ( countInteger ( n , s ) ) ;
function division ( num1 , num2 ) { if ( num1 == 0 ) return 0 ; if ( num2 == 0 ) return Number . MAX_VALUE ; ; let negResult = false ; if ( num1 < 0 ) { num1 = - num1 ; if ( num2 < 0 ) num2 = - num2 ; else negResult = true ; } else if ( num2 < 0 ) { num2 = - num2 ; negResult = true ; } let quotient = 0 ; while ( num1 >= num2 ) { num1 = num1 - num2 ; quotient ++ ; } if ( negResult ) quotient = - quotient ; return quotient ; } let num1 = 13 , num2 = 2 ; document . write ( division ( num1 , num2 ) ) ;
function Nonagonal ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { document . write ( parseInt ( i * ( 7 * i - 5 ) / 2 ) + " " ) ; } } let n = 10 ; Nonagonal ( n ) ;
function seriesFunc ( n ) { let sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; let sumNatural = ( n * ( n + 1 ) / 2 ) ; return ( sumSquare + sumNatural + 1 ) ; } let n = 8 ; document . write ( seriesFunc ( n ) + " " ) ; n = 13 ; document . write ( seriesFunc ( 13 ) ) ;
function checkplusperfect ( x ) { let temp = x ; let n = 0 ; while ( x != 0 ) { x = parseInt ( x / 10 ) ; n ++ ; } x = temp ; let sum = 0 ; while ( x != 0 ) { sum += Math . pow ( x % 10 , n ) ; x = parseInt ( x / 10 ) ; } return ( sum == temp ) ; } let x = 9474 ; if ( checkplusperfect ( x ) ) document . write ( " " ) ; else document . write ( " " ) ;
function subsetCount ( arr , n ) { return 1 << n ; } let A = [ 1 , 2 , 3 ] ; let n = A . length ; document . write ( subsetCount ( A , n ) ) ;
function Calculate_GST ( org_cost , N_price ) { return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; } var org_cost = 100 ; var N_price = 120 ; document . write ( " " + Calculate_GST ( org_cost , N_price ) + " " ) ;
function centeredHexagonalNumber ( n ) { return 3 * n * ( n - 1 ) + 1 ; } let n = 10 ; document . write ( n + " " ) ; document . write ( centeredHexagonalNumber ( n ) ) ;
function find_distance ( n ) { return n * ( 3 * n + 7 ) ; } let n = 5 ; document . write ( " " ) ; document . write ( find_distance ( n ) ) ;
function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function twinPrime ( n1 , n2 ) { return ( isPrime ( n1 ) && isPrime ( n2 ) && Math . abs ( n1 - n2 ) == 2 ) ; } let n1 = 11 , n2 = 13 ; if ( twinPrime ( n1 , n2 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function sumOfSeries ( n ) { return 0.0246 * ( Math . pow ( 10 , n ) - 1 - ( 9 * n ) ) ; } let n = 3 ; document . write ( sumOfSeries ( n ) ) ;
function evenbinomialCoeffSum ( n ) { return ( 1 << ( n - 1 ) ) ; } let n = 4 ; document . write ( evenbinomialCoeffSum ( n ) ) ;
function triangular_series ( n ) { let i , j = 1 , k = 1 ; for ( i = 1 ; i <= n ; i ++ ) { document . write ( k + " " ) ; j = j + 1 ; k = k + j ; } } let n = 5 ; triangular_series ( n ) ;
function sumOfTheSeries ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } let n = 5 ; document . write ( " " + sumOfTheSeries ( n ) ) ;
function sumOfSeries ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= i ; j ++ ) sum += j ; return sum ; } let n = 10 ; document . write ( sumOfSeries ( n ) ) ;
function numberOfTriangles ( n ) { var ans = 2 * ( Math . pow ( 3 , n ) ) - 1 ; return ans ; } var n = 2 ; document . write ( numberOfTriangles ( n ) ) ;
function kthgroupsum ( k ) { return k * k * k ; } let k = 3 ; document . write ( kthgroupsum ( k ) ) ;
function printXYZ ( n ) { if ( n == 1 ) document . write ( - 1 ) ; else document . write ( " " + n + " " + ( n + 1 ) + " " + n * ( n + 1 ) ) ; } let n = 7 ; printXYZ ( n ) ;
function term ( n ) { return parseInt ( n * ( n + 1 ) / 2 ) ; } let n = 4 ; document . write ( term ( n ) ) ;
function compute ( a , b ) { var AM = ( a + b ) / 2 ; var GM = Math . sqrt ( a * b ) ; var HM = ( GM * GM ) / AM ; return HM ; } var a = 5 ; var b = 15 ; var HM = compute ( a , b ) document . write ( " " + a + " " + b + " " + HM . toFixed ( 3 ) ) ;
function series ( n ) { return ( 8 * n * n ) + 1 ; } let n = 5 ; document . write ( series ( n ) ) ;
function gcd ( a , b ) { return b == 0 ? a : gcd ( b , a % b ) ; } function isDivisible ( x , y ) { if ( y == 1 ) return true ; var z = gcd ( x , y ) ; if ( z == 1 ) return false ; return isDivisible ( x , y / z ) ; } var x = 18 , y = 12 ; if ( isDivisible ( x , y ) ) document . write ( " " ) ; else document . write ( " " ) ;
function sumOfSeries ( a , num ) { let res = 0 , prev = 1 ; for ( let i = 1 ; i <= num ; i ++ ) { prev *= ( a / i ) ; res = res + prev ; } return ( res ) ; } let n = 5 , a = 2 ; document . write ( sumOfSeries ( a , n ) ) ;
function Cel_To_Fah ( n ) { return ( ( n * 9.0 / 5.0 ) + 32.0 ) ; } let n = 20.0 ; document . write ( Cel_To_Fah ( n ) ) ;
function print_sequence ( n , k ) { let b = parseInt ( n / ( k * ( k + 1 ) / 2 ) ) ; if ( b == 0 ) { document . write ( - 1 ) ; } else { let r = 1 ; for ( let x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( let i = 1 ; i < k ; i ++ ) document . write ( r * i + " " ) ; let res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; document . write ( res + " " ) ; } } let n = 24 ; let k = 4 ; print_sequence ( n , k ) ; n = 24 ; k = 5 ; print_sequence ( n , k ) ; n = 6 ; k = 4 ; print_sequence ( n , k ) ;
function countCompositions ( n ) { return 1 << ( n - 1 ) ; } var n = 4 ; document . write ( countCompositions ( n ) ) ;
function countDigit ( n ) { if ( n / 10 == 0 ) return 1 ; return 1 + countDigit ( parseInt ( n / 10 ) ) ; } var n = 345289467 ; document . write ( " " + countDigit ( n ) ) ;
function printTrib ( n ) { let dp = Array . from ( { length : n } , ( _ , i ) => 0 ) ; dp [ 0 ] = dp [ 1 ] = 0 ; dp [ 2 ] = 1 ; for ( let i = 3 ; i < n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; for ( let i = 0 ; i < n ; i ++ ) document . write ( dp [ i ] + " " ) ; } let n = 10 ; printTrib ( n ) ;
function multiply ( T , M ) { var a , b , c , d , e , f , g , h , i ; a = T [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 0 ] ; b = T [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 1 ] ; c = T [ 0 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 2 ] ; d = T [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 0 ] ; e = T [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 1 ] ; f = T [ 1 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 2 ] ; g = T [ 2 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 0 ] ; h = T [ 2 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 1 ] ; i = T [ 2 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 2 ] ; T [ 0 ] [ 0 ] = a ; T [ 0 ] [ 1 ] = b ; T [ 0 ] [ 2 ] = c ; T [ 1 ] [ 0 ] = d ; T [ 1 ] [ 1 ] = e ; T [ 1 ] [ 2 ] = f ; T [ 2 ] [ 0 ] = g ; T [ 2 ] [ 1 ] = h ; T [ 2 ] [ 2 ] = i ; } function power ( T , n ) { if ( n == 0 n == 1 ) return ; var M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; power ( T , parseInt ( n / 2 ) ) ; multiply ( T , T ) ; if ( n % 2 != 0 ) multiply ( T , M ) ; } function tribonacci ( n ) { var T = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; if ( n == 0 n == 1 ) return 0 ; else power ( T , n - 2 ) ; return T [ 0 ] [ 0 ] ; } var n = 10 ; for ( var i = 0 ; i < n ; i ++ ) document . write ( tribonacci ( i ) + " " ) ; document . write ( ' ' ) ;
function geometricMean ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum = sum + Math . log ( arr [ i ] ) ; sum = sum / n ; return Math . exp ( sum ) ; } var arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ; var n = arr . length ; document . write ( geometricMean ( arr , n ) . toFixed ( 5 ) ) ;
function smallestNumber ( n ) { if ( n >= 0 && n <= 9 ) { return n ; } let digits = [ ] ; for ( let i = 9 ; i >= 2 && n > 1 ; i -- ) { while ( n % i == 0 ) { digits . push ( i ) ; n = Math . floor ( n / i ) ; } } if ( n != 1 ) { return - 1 ; } let k = 0 ; while ( digits . length != 0 ) { k = k * 10 + digits [ digits . length - 1 ] ; digits . pop ( ) ; } return k ; } let n = 100 ; document . write ( smallestNumber ( n ) ) ;
function isMagic ( n ) { var sum = 0 ; while ( n > 0 sum > 9 ) { if ( n = 0 ) { n = sum ; sum = 0 ; } sum += n % 10 ; n /= 10 ; } return ( sum = 1 ) ; } var n = 1234 ; if ( isMagic ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
let N = 1000000007 ; function printSequence ( n ) { let a = 1 ; let ans = 2 ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( ans + " " ) ; ans = ( ( a % N ) * ( ans % N ) ) % N ; a = ans ; ans = ( ans + 1 ) % N ; } } let n = 6 ; printSequence ( n ) ;
function findSum ( n ) { let sum = 0 ; for ( let x = 1 ; x <= n ; x ++ ) sum = sum + x ; return sum ; } let n = 5 ; document . write ( findSum ( n ) ) ;
let c = 0 ; function HailstoneNumbers ( N ) { document . write ( N + " " ) ; if ( N == 1 && c == 0 ) { return c ; } else if ( N == 1 && c != 0 ) { c ++ ; return c ; } else if ( N % 2 == 0 ) { c ++ ; HailstoneNumbers ( N / 2 ) ; } else if ( N % 2 != 0 ) { c ++ ; HailstoneNumbers ( 3 * N + 1 ) ; } return c ; } let N = 7 ; let x ; x = HailstoneNumbers ( N ) ; document . write ( " " ) ; document . write ( " " + x ) ;
function SUM ( n , m ) { if ( m == 1 ) return ( n * ( n + 1 ) / 2 ) ; let sum = SUM ( n , m - 1 ) ; return ( sum * ( sum + 1 ) / 2 ) ; } let n = 5 ; let m = 3 ; document . write ( " " + n + " " + m + " " + SUM ( n , m ) ) ;
function xorCalc ( k ) { if ( k == 1 ) return 2 ; if ( ( ( k + 1 ) & k ) == 0 ) return parseInt ( k / 2 ) ; return 1 ; } var k = 31 ; document . write ( xorCalc ( k ) ) ;
function findNthNo ( n ) { res = " " ; while ( n >= 1 ) { if ( ( n & 1 ) == 1 ) { res = res + " " ; n = ( n - 1 ) / 2 ; } else { res = res + " " ; n = parseInt ( ( n - 2 ) / 2 ) ; } } return res . split ( " " ) . reverse ( ) . join ( " " ) ; } var n = 13 ; document . write ( findNthNo ( n ) ) ;
function divCount ( n ) { var hash = Array ( n + 1 ) . fill ( true ) ; for ( var p = 2 ; p * p < n ; p ++ ) if ( hash [ p ] == true ) for ( var i = p * 2 ; i < n ; i += p ) hash [ i ] = false ; var total = 1 ; for ( var p = 2 ; p <= n ; p ++ ) { if ( hash [ p ] ) { var count = 0 ; if ( n % p == 0 ) { while ( n % p == 0 ) { n = parseInt ( n / p ) ; count ++ ; } total = total * ( count + 1 ) ; } } } return total ; } var n = 24 ; document . write ( divCount ( n ) ) ;
function getMax ( Arr ) { let max = Arr [ 0 ] ; for ( let i = 1 ; i < Arr . length ; i ++ ) if ( Arr [ i ] > max ) max = Arr [ i ] ; return max ; } function maxPrimefactorNum ( N ) { let arr = new Array ( N + 1 ) . fill ( 0 ) ; for ( let i = 2 ; i * i <= N ; i ++ ) { if ( arr [ i ] == 0 ) for ( let j = 2 * i ; j <= N ; j += i ) arr [ j ] ++ ; arr [ i ] = 1 ; } return getMax ( arr ) ; } let N = 40 ; document . write ( maxPrimefactorNum ( N ) ) ;
function decToBin ( n ) { if ( n == 0 ) return " " ; var bin = " " ; while ( n > 0 ) { bin = ( ( n & 1 ) == 0 ? ' ' : ' ' ) + bin ; n >>= 1 ; } return bin ; } var n = 38 ; document . write ( decToBin ( n ) ) ;
function arraySum ( arr , n ) { let x = ( n + 1 ) / 2 ; return ( arr [ 0 ] - 1 ) * n + x * x ; } let arr = [ 10 , 11 , 12 , 13 , 12 , 11 , 10 ] ; let n = arr . length ; document . write ( arraySum ( arr , n ) ) ;
function isBalancePossible ( T , a ) { let baseForm = [ ] ; let s = 0 ; while ( T > 0 ) { baseForm . push ( T % a ) ; T = Math . floor ( T / a ) ; s ++ ; } baseForm . push ( 0 ) ; for ( let i = 0 ; i < s ; i ++ ) { if ( baseForm [ i ] != 0 && baseForm [ i ] != 1 && baseForm [ i ] != ( a - 1 ) && baseForm [ i ] != a ) { return false ; } if ( baseForm [ i ] == a || baseForm [ i ] == ( a - 1 ) ) { baseForm . splice ( i + 1 , 0 , baseForm [ i + 1 ] + 1 ) ; } } return true ; } let T = 11 ; let a = 4 ; let balancePossible = isBalancePossible ( T , a ) ; if ( balancePossible ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
function countDigits ( a , b ) { if ( a == 0 b == 0 ) return 1 ; return Math . floor ( Math . log10 ( Math . abs ( a ) ) + Math . log10 ( Math . abs ( b ) ) ) + 1 ; } let a = 33 ; let b = - 24 ; document . write ( countDigits ( a , b ) ) ;
function lastPosition ( n , m , k ) { if ( m <= n - k + 1 ) return m + k - 1 ; m = m - ( n - k + 1 ) ; return ( m % n == 0 ) ? n : ( m % n ) ; } let n = 5 ; let m = 8 ; let k = 2 ; document . write ( lastPosition ( n , m , k ) ) ;
function primesInRange ( n ) { let fact = 1 ; for ( let k = 2 ; k < n ; k ++ ) { fact = fact * ( k - 1 ) ; if ( ( fact + 1 ) % k == 0 ) document . write ( ( k + " " ) ) ; } } let n = 15 ; primesInRange ( n ) ;
var EPS = 1e-9 ; function productPuzzle ( a , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += Math . log10 ( a [ i ] ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( parseInt ( ( EPS + Math . pow ( 10.00 , sum - Math . log10 ( a [ i ] ) ) ) ) + " " ) ; } var a = [ 10 , 3 , 5 , 6 , 2 ] ; var n = a . length ; document . write ( " " ) ; productPuzzle ( a , n ) ;
function changeEvenBits ( n ) { let to_subtract = 0 ; let m = 0 ; for ( x = n ; x ; x >>= 2 ) { if ( x & 1 ) to_subtract += ( 1 << m ) ; m += 2 ; } return n - to_subtract ; } n = 30 ; document . write ( changeEvenBits ( n ) ) ;
function closestNumber ( n , m ) { let q = parseInt ( n / m ) ; let n1 = m * q ; let n2 = ( n * m ) > 0 ? ( m * ( q + 1 ) ) : ( m * ( q - 1 ) ) ; if ( Math . abs ( n - n1 ) < Math . abs ( n - n2 ) ) return n1 ; return n2 ; } let n = 13 ; let m = 4 ; document . write ( closestNumber ( n , m ) + " " ) ; n = - 15 ; m = 6 ; document . write ( closestNumber ( n , m ) + " " ) ; n = 0 ; m = 8 ; document . write ( closestNumber ( n , m ) + " " ) ; n = 18 ; m = - 7 ; document . write ( closestNumber ( n , m ) + " " ) ;
function checkPronic ( x ) { for ( var i = 0 ; i <= parseInt ( Math . sqrt ( x ) ) ; i ++ ) if ( x == i * ( i + 1 ) ) return true ; return false ; } for ( var i = 0 ; i <= 200 ; i ++ ) if ( checkPronic ( i ) ) document . write ( i + " " ) ;
function findMinSum ( num ) { let sum = 0 ; for ( let i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { sum += i ; num /= i ; } } sum += num ; return sum ; } let num = 12 ; document . write ( findMinSum ( num ) ) ;
function findMin ( sum ) { var a = 0 , b = 0 ; while ( sum > 0 ) { if ( sum % 7 == 0 ) { b ++ ; sum -= 7 ; } else if ( sum % 4 == 0 ) { a ++ ; sum -= 4 ; } else { a ++ ; sum -= 4 ; } } if ( sum < 0 ) { document . write ( " " ) ; return ; } for ( i = 0 ; i < a ; i ++ ) document . write ( " " ) ; for ( i = 0 ; i < b ; i ++ ) document . write ( " " ) ; document . write ( ) ; } findMin ( 15 ) ;
function minNum ( arr , n ) { let odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd += 1 ; return ( ( odd % 2 ) != 0 ) ? 1 : 2 ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ; let n = arr . length ; document . write ( minNum ( arr , n ) ) ;
function printMaxNum ( num ) { let count = new Array ( 10 ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } let str = num . toString ( ) ; for ( let i = 0 ; i < str . length ; i ++ ) count [ str [ i ] - ' ' ] ++ ; let result = 0 , multiplier = 1 ; for ( let i = 0 ; i <= 9 ; i ++ ) { while ( count [ i ] > 0 ) { result = result + ( i * multiplier ) ; count [ i ] -- ; multiplier = multiplier * 10 ; } } return result ; } let num = 38293367 ; document . write ( printMaxNum ( num ) ) ;
function largestNumber ( num ) { var n = num . length ; var rightMax = Array ( n ) , right ; rightMax [ n - 1 ] = - 1 ; right = n - 1 ; for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( num [ i ] < num [ right ] ) rightMax [ i ] = right ; else { rightMax [ i ] = - 1 ; right = i ; } } for ( var i = 0 ; i < n ; i ++ ) { if ( rightMax [ i ] != - 1 ) { var tmp = num [ i ] ; num [ i ] = num [ rightMax [ i ] ] ; num [ rightMax [ i ] ] = tmp break ; } } return num . join ( ' ' ) ; } var num = " " . split ( ' ' ) ; document . write ( " " + largestNumber ( num ) ) ;
function nCr ( n , r ) { if ( r > n / 2 ) r = n - r ; let answer = 1 ; for ( let i = 1 ; i <= r ; i ++ ) { answer *= ( n - r + i ) ; answer /= i ; } return answer ; } function binomialProbability ( n , k , p ) { return nCr ( n , k ) * Math . pow ( p , k ) * Math . pow ( 1 - p , n - k ) ; } let n = 10 ; let k = 5 ; let p = 1.0 / 3 ; let probability = binomialProbability ( n , k , p ) ; document . write ( " " + k ) ; document . write ( " " + n ) ; document . write ( " " + p ) ; document . write ( " " + probability ) ;
function findMaxGCD ( arr , n ) { var high = 0 ; for ( var i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; var divisors = Array . from ( { length : high + 1 } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( var i = high ; i >= 1 ; i -- ) if ( divisors [ i ] > 1 ) return i ; return 1 ; } var arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] ; var n = arr . length ; document . write ( findMaxGCD ( arr , n ) ) ;
function findMaxGCD ( arr , n ) { var high = 0 ; for ( let i = 0 ; i < n ; i ++ ) high = Math . max ( high , arr [ i ] ) ; var count = Array ( high + 1 ) . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] ++ ; var counter = 0 ; for ( let i = high ; i >= 1 ; i -- ) { var j = i ; while ( j <= high ) { if ( count [ j ] > 0 ) counter += count [ j ] ; j += i ; if ( counter == 2 ) return i ; } counter = 0 ; } return 1 ; } var arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] ; var n = arr . length ; document . write ( findMaxGCD ( arr , n ) ) ;
function count_one ( n ) { let c_one = 0 ; while ( n != 0 ) { let rem = n % 10 ; if ( rem == 1 ) c_one = c_one + 1 ; n = parseInt ( n / 10 , 10 ) ; } return c_one ; } function checkEvil ( n ) { let i = 0 , bin = 0 , n_one = 0 ; while ( n != 0 ) { let r = n % 2 ; bin = bin + r * ( Math . pow ( 10 , i ) ) ; n = parseInt ( n / 2 , 10 ) ; } n_one = count_one ( bin ) ; if ( n_one % 2 == 0 ) return 1 ; else return 0 ; } let check , num ; num = 32 ; check = checkEvil ( num ) ; if ( check == 1 ) document . write ( num + " " ) ; else document . write ( num + " " ) ;
function CountPairs ( n ) { let k = n ; let imin = 1 ; let ans = 0 ; while ( imin <= n ) { let imax = Math . floor ( n / k ) ; ans += k * ( imax - imin + 1 ) ; imin = imax + 1 ; k = Math . floor ( n / imin ) ; } return ans ; } document . write ( CountPairs ( 1 ) + " " ) ; document . write ( CountPairs ( 2 ) + " " ) ; document . write ( CountPairs ( 3 ) + " " ) ;
function PowerOFPINnfactorial ( n , p ) { let ans = 0 ; let temp = p ; while ( temp <= n ) { ans += n / temp ; temp = temp * p ; } return ans ; } document . write ( PowerOFPINnfactorial ( 4 , 2 ) ) ;
function binaryToDecimal ( n ) { let num = n ; let dec_value = 0 ; let base = 1 ; let temp = num ; while ( temp ) { let last_digit = temp % 10 ; temp = Math . floor ( temp / 10 ) ; dec_value += last_digit * base ; base = base * 2 ; } return dec_value ; } let num = 10101001 ; document . write ( binaryToDecimal ( num ) + " " ) ;
function stirlingFactorial ( n ) { if ( n == 1 ) return 1 ; let z ; let e = 2.71 ; z = Math . sqrt ( 2 * 3.14 * n ) * Math . pow ( ( n / e ) , n ) ; return Math . floor ( z ) ; } document . write ( stirlingFactorial ( 1 ) + " " ) ; document . write ( stirlingFactorial ( 2 ) + " " ) ; document . write ( stirlingFactorial ( 3 ) + " " ) ; document . write ( stirlingFactorial ( 4 ) + " " ) ; document . write ( stirlingFactorial ( 5 ) + " " ) ; document . write ( stirlingFactorial ( 6 ) + " " ) ; document . write ( stirlingFactorial ( 7 ) + " " ) ;
function countXorPair ( arr , n ) { let odd = 0 , even = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return odd * even ; } let arr = [ 1 , 2 , 3 ] ; document . write ( countXorPair ( arr , arr . length ) ) ;
var MAX_ITERATIONS = 20 ; function isLychrel ( number ) { for ( var i = 0 ; i < MAX_ITERATIONS ; i ++ ) { number = number + reverse ( number ) ; if ( isPalindrome ( number ) ) return false ; } return true ; } function isPalindrome ( number ) { return number == reverse ( number ) ; } function reverse ( number ) { var reverse = 0 ; while ( number > 0 ) { var remainder = number % 10 ; reverse = ( reverse * 10 ) + remainder ; number = parseInt ( number / 10 ) ; } return reverse ; } var number = 295 ; document . write ( number + " " + isLychrel ( number ) ) ;
function findRectNum ( n ) { return n * ( n + 1 ) ; } var n = 6 ; document . write ( findRectNum ( n ) ) ;
const MAX_ITERATIONS = 10000 ; function f ( x ) { return 1 * Math . pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ; } function Muller ( a , b , c ) { let i ; let res ; for ( i = 0 ; ; ++ i ) { let f1 = f ( a ) ; let f2 = f ( b ) ; let f3 = f ( c ) ; let d1 = f1 - f3 ; let d2 = f2 - f3 ; let h1 = a - c ; let h2 = b - c ; let a0 = f3 ; let a1 = ( ( ( d2 * Math . pow ( h1 , 2 ) ) - ( d1 * Math . pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; let a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; let x = ( ( - 2 * a0 ) / ( a1 + Math . abs ( Math . sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; let y = ( ( - 2 * a0 ) / ( a1 - Math . abs ( Math . sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; if ( x >= y ) res = x + c ; else res = y + c ; let m = res * 100 ; let n = c * 100 ; m = Math . floor ( m ) ; n = Math . floor ( n ) ; if ( m == n ) break ; a = b ; b = c ; c = res ; if ( i > MAX_ITERATIONS ) { document . write ( " " + " " ) ; break ; } } if ( i <= MAX_ITERATIONS ) document . write ( " " + res . toFixed ( 4 ) ) ; } let a = 0 , b = 1 , c = 2 ; Muller ( a , b , c ) ;
function nthprimedigitsnumber ( n ) { var len = 1 ; var prev_count = 0 ; while ( true ) { var curr_count = ( prev_count + Math . pow ( 4 , len ) ) ; if ( prev_count < n && curr_count >= n ) break ; len ++ ; prev_count = curr_count ; } for ( var i = 1 ; i <= len ; i ++ ) { for ( var j = 1 ; j <= 4 ; j ++ ) { if ( prev_count + Math . pow ( 4 , len - i ) < n ) prev_count += Math . pow ( 4 , len - i ) ; else { if ( j == 1 ) document . write ( " " ) ; else if ( j == 2 ) document . write ( " " ) ; else if ( j == 3 ) document . write ( " " ) ; else if ( j == 4 ) document . write ( " " ) ; break ; } } } document . write ( ' ' ) ; } nthprimedigitsnumber ( 10 ) ; nthprimedigitsnumber ( 21 ) ;
function findNoIsDivisibleOrNot ( a , n , l ) { for ( let i = 0 ; i < l ; i ++ ) { if ( a [ i ] % n != 0 ) return false ; } return true ; } let a = [ 14 , 12 , 4 , 18 ] ; let n = 2 ; let l = a . length ; if ( findNoIsDivisibleOrNot ( a , n , l ) ) document . write ( " " ) ; else document . write ( " " ) ;
function factorial ( n ) { if ( n == 0 ) return 1 ; return n * factorial ( n - 1 ) ; } function printRange ( n ) { let a = factorial ( n + 2 ) + 2 ; let b = a + n - 1 ; document . write ( ` ${ a } ${ b } ` ) ; return 0 ; } let n = 3 ; printRange ( n ) ;
function findMinValue ( arr , n ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < n ; i ++ ) { val += ( Math . log ( ( arr [ i ] ) ) ) ; } let left = arr [ 0 ] , right = arr [ n - 1 ] ; let ans = 0 ; while ( left <= right ) { let mid = Math . floor ( ( left + right ) / 2 ) ; let temp = n * ( Math . log ( ( mid ) ) ) ; if ( val < temp ) { ans = mid ; right = mid - 1 ; } else { left = mid + 1 ; } } return ans ; } let arr = [ 4 , 2 , 1 , 10 , 6 ] ; let n = arr . length ; document . write ( findMinValue ( arr , n ) ) ;
function sumOfTermsInNthRow ( n ) { let sum = n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; return sum ; } let n = 4 ; document . write ( " " + sumOfTermsInNthRow ( n ) ) ;
function firstDigit ( x ) { while ( x >= 10 ) x = x / 10 ; return Math . floor ( x ) ; } document . write ( firstDigit ( 12345 ) + " " ) ; document . write ( firstDigit ( 5432 ) ) ;
function getOccurence ( n , d ) { let result = 0 ; let itr = d ; while ( itr <= n ) { if ( itr % 10 == d ) result ++ ; if ( itr != 0 && Math . floor ( itr / 10 ) == d ) { result ++ ; itr ++ ; } else if ( Math . floor ( itr / 10 ) == d - 1 ) itr = itr + ( 10 - d ) ; else itr = itr + 10 ; } return result ; } let n = 11 ; let d = 1 ; document . write ( getOccurence ( n , d ) ) ;
function cal_cos ( n ) { let accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; let i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; document . write ( cosx . toFixed ( 5 ) ) ; } let n = 30 ; cal_cos ( n ) ;
let v = [ ] ; function multiply ( x ) { let carry = 0 ; let size = v . length ; for ( let i = 0 ; i < size ; i ++ ) { let res = carry + v [ i ] * x ; v [ i ] = res % 10 ; carry = Math . floor ( res / 10 ) ; } while ( carry != 0 ) { v . push ( carry % 10 ) ; carry = Math . floor ( carry / 10 ) ; } } function findSumOfDigits ( n ) { for ( let i = 1 ; i <= n ; i ++ ) multiply ( i ) ; let sum = 0 ; let size = v . length ; for ( let i = 0 ; i < size ; i ++ ) sum += v [ i ] ; return sum ; } let n = 1000 ; document . write ( findSumOfDigits ( n ) ) ;
function printOtherSides ( n ) { if ( n % 2 != 0 ) { if ( n == 1 ) document . write ( " " ) ; else { var b = ( n * n - 1 ) / 2 ; var c = ( n * n + 1 ) / 2 ; document . write ( " " + b + " " + c ) ; } } else { if ( n == 2 ) document . write ( " " ) ; else { var b = n * n / 4 - 1 ; var c = n * n / 4 + 1 ; document . write ( " " + b + " " + c ) ; } } } var a = 3 ; printOtherSides ( a ) ;
function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var i ; for ( i = 2 ; i <= n ; i ++ ) if ( ( n % i == 0 ) && ( ( n / i ) % 2 == 1 ) ) break ; return i ; } var n = 36 ; var res = makeOdd ( n ) ; document . write ( res ) ;
function getTotalXorOfSubarrayXors ( arr , N ) { if ( N % 2 == 0 ) return 0 ; let res = 0 ; for ( let i = 0 ; i < N ; i += 2 ) { res ^= arr [ i ] ; } return res ; } let arr = [ 3 , 5 , 2 , 4 , 6 ] ; let N = arr . length ; document . write ( getTotalXorOfSubarrayXors ( arr , N ) ) ;
function countIterations ( arr , n ) { var oneFound = false ; var res = 0 ; for ( var i = 0 ; i < n ; ) { if ( arr [ i ] == 1 ) oneFound = true ; while ( i < n && arr [ i ] == 1 ) i ++ ; var count_zero = 0 ; while ( i < n && arr [ i ] == 0 ) { count_zero ++ ; i ++ ; } if ( oneFound == false && i == n ) return - 1 ; var curr_count ; if ( i < n && oneFound == true ) { if ( ( count_zero & 1 ) == 0 ) curr_count = count_zero / 2 ; else curr_count = ( count_zero + 1 ) / 2 ; count_zero = 0 ; } else { curr_count = count_zero ; count_zero = 0 ; } res = Math . max ( res , curr_count ) ; } return res ; } var arr = [ 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ; document . write ( countIterations ( arr , arr . length ) ) ;
function printConsecutive ( last , first ) { document . write ( first ++ ) ; for ( let x = first ; x <= last ; x ++ ) document . write ( " " + x ) ; } function findConsecutive ( N ) { for ( let last = 1 ; last < N ; last ++ ) { for ( let first = 0 ; first < last ; first ++ ) { if ( 2 * N == ( last - first ) * ( last + first + 1 ) ) { document . write ( N + " " ) ; printConsecutive ( last , first + 1 ) ; return ; } } } document . write ( " " ) ; } let n = 12 ; findConsecutive ( n ) ;
function printNthElement ( n ) { var arr = Array ( n + 1 ) . fill ( 0 ) ; arr [ 1 ] = 4 ; arr [ 2 ] = 7 ; for ( var i = 3 ; i <= n ; i ++ ) { if ( i % 2 != 0 ) arr [ i ] = arr [ i / 2 ] * 10 + 4 ; else arr [ i ] = arr [ ( i / 2 ) - 1 ] * 10 + 7 ; } return arr [ n ] ; } var n = 6 ; document . write ( printNthElement ( n ) ) ;
function maxSumLCM ( n ) { for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { max_sum += i ; if ( n / i != i ) max_sum += ( n / i ) ; } } return max_sum ; } let n = 2 ; document . write ( maxSumLCM ( n ) + " " ) ;
var n = 12 ; document . write ( Math . sqrt ( n ) . toFixed ( 6 ) ) ;
function findMaxValue ( ) { let res = 2 ; let fact = 2 ; while ( true ) { if ( fact < 0 fact > 9223372036854775807 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; } document . write ( " " + " " + findMaxValue ( ) ) ;
function func ( a , k ) { for ( let i = 0 ; i < a . length ; i ++ ) if ( a [ i ] % k == 0 ) return true ; return false ; } let a = [ 14 , 27 , 38 , 76 , 84 ] ; var k = 19 ; let res = func ( a , k ) ; document . write ( res ) ;
function tidyNum ( str1 , len ) { var str = str1 . split ( ' ' ) ; for ( i = len - 2 ; i >= 0 ; i -- ) { if ( str [ i ] > str [ i + 1 ] ) { str [ i ] -- ; for ( j = i + 1 ; j < len ; j ++ ) str [ j ] = ' ' ; } } return str . join ( " " ) ; } var str = " " ; var len = str . length ; document . write ( tidyNum ( str , len ) ) ;
function findCount ( m , n ) { let num1 = 0 ; for ( let i = 0 ; i < m ; i ++ ) num1 = ( num1 * 10 ) + 9 ; let num2 = 0 ; for ( let i = 0 ; i < ( m - 1 ) ; i ++ ) num2 = ( num2 * 10 ) + 9 ; return ( ( num1 / n ) - ( num2 / n ) ) ; } let m = 2 ; n = 6 ; document . write ( findCount ( m , n ) + " " ) ;
function findNthEvenDigitNumber ( n ) { let count = 0 ; for ( let i = 0 ; ; i ++ ) { let curr = i ; let isCurrEvenDigit = true ; while ( curr != 0 ) { if ( curr % 10 == 1 curr % 10 == 3 curr % 10 == 5 curr % 10 == 7 curr % 10 == 9 ) isCurrEvenDigit = false ; curr = Math . floor ( curr / 10 ) ; } if ( isCurrEvenDigit === true ) count ++ ; if ( count === n ) return i ; } } document . write ( findNthEvenDigitNumber ( 2 ) + " " ) ; document . write ( findNthEvenDigitNumber ( 10 ) + " " ) ;
function findNthEvenDigitNumber ( n ) { if ( n == 1 ) { return 0 ; } let v = [ ] ; n = n - 1 ; while ( n > 0 ) { v . push ( n % 5 ) ; n = Math . floor ( n / 5 ) ; } let result = 0 ; for ( let i = v . length - 1 ; i >= 0 ; i -- ) { result = result * 10 ; result = result + v [ i ] ; } return 2 * result ; } document . write ( findNthEvenDigitNumber ( 2 ) + " " ) ; document . write ( findNthEvenDigitNumber ( 10 ) ) ;
function isDivisibleBy25 ( str ) { n = str . length ; if ( n == 1 ) return false ; return ( ( str [ n - 1 ] - ' ' == 0 && str [ n - 2 ] - ' ' == 0 ) || ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 25 == 0 ) ; } var str = " " ; var x = isDivisibleBy25 ( str ) ? " " : " " ; document . write ( x ) ;
function check ( str ) { let n = str . length ; if ( n == 0 && n == 1 ) return false ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 16 == 0 ) ; if ( n == 3 ) return ( ( ( str [ n - 3 ] - ' ' ) * 100 + ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 16 == 0 ) ; let last = str [ n - 1 ] - ' ' ; let second_last = str [ n - 2 ] - ' ' ; let third_last = str [ n - 3 ] - ' ' ; let fourth_last = str [ n - 4 ] - ' ' ; return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) ; } let str = " " ; if ( check ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findIndex ( n ) { if ( n <= 1 ) return n ; let a = 0 , b = 1 , c = 1 ; let res = 1 ; while ( c < n ) { c = a + b ; res ++ ; a = b ; b = c ; } return res ; } let result = findIndex ( 21 ) ; document . write ( result ) ;
function divisorSum ( N , K ) { let sum = 0 ; for ( let i = 2 ; i <= Math . ceil ( Math . sqrt ( N ) ) ; i ++ ) if ( N % i == 0 ) sum += ( i + parseInt ( N / i , 10 ) ) ; return sum ; } function isPrime ( n ) { if ( n == 1 n == 0 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function isHyperPerfect ( N , K ) { let sum = divisorSum ( N , K ) ; if ( ( 1 + K * ( sum ) ) == N ) return true ; else return false ; } let N1 = 1570153 , K1 = 12 ; let N2 = 321 , K2 = 3 ; if ( isHyperPerfect ( N1 , K1 ) ) document . write ( N1 + " " + K1 + " " + " " ) ; else document . write ( N1 + " " + K1 + " " + " " ) ; if ( isHyperPerfect ( N2 , K2 ) ) document . write ( N2 + " " + K2 + " " + " " ) ; else document . write ( N2 + " " + K2 + " " + " " ) ;
function firstkdigits ( n , k ) { let product = n * Math . log10 ( n ) ; let decimal_part = product - Math . floor ( product ) ; decimal_part = Math . pow ( 10 , decimal_part ) ; let digits = Math . pow ( 10 , k - 1 ) , i = 0 ; return ( Math . floor ( decimal_part * digits ) ) ; } let n = 1450 ; let k = 6 ; document . write ( firstkdigits ( n , k ) ) ;
function printWellOrdered ( number , x , k ) { if ( k == 0 ) { document . write ( number + " " ) ; return ; } for ( let i = ( x + 1 ) ; i < 10 ; i ++ ) printWellOrdered ( number * 10 + i , i , k - 1 ) ; } function generateWellOrdered ( k ) { printWellOrdered ( 0 , 0 , k ) ; } let k = 3 ; generateWellOrdered ( k ) ;
function moduloMultiplication ( a , b , mod ) { let res = 0 ; a = ( a % mod ) ; while ( b > 0 ) { if ( ( b & 1 ) > 0 ) { res = ( res + a ) % mod ; } a = ( 2 * a ) % mod ; } return res ; } let a = 426 ; let b = 964 ; let m = 235 ; document . write ( moduloMultiplication ( a , b , m ) ) ;
function count2sinRangeAtDigit ( number , d ) { var powerOf10 = parseInt ( Math . pow ( 10 , d ) ) ; var nextPowerOf10 = powerOf10 * 10 ; var right = number % powerOf10 ; var roundDown = number - number % nextPowerOf10 ; var roundup = roundDown + nextPowerOf10 ; var digit = parseInt ( number / powerOf10 ) % 10 ; if ( digit < 2 ) { return roundDown / 10 ; } if ( digit == 2 ) { return roundDown / 10 + right + 1 ; } return roundup / 10 ; } function numberOf2sinRange ( number ) { var convert ; convert = number . toString ( ) ; var s = convert ; var len = s . length ; var count = 0 ; for ( digit = 0 ; digit < len ; digit ++ ) { count += count2sinRangeAtDigit ( number , digit ) ; } return count ; } document . write ( numberOf2sinRange ( 22 ) ) ; document . write ( " " + numberOf2sinRange ( 100 ) ) ;
function findStarNum ( n ) { return ( 6 * n * ( n - 1 ) + 1 ) ; } let n = 3 ; document . write ( findStarNum ( n ) ) ;
function isDivisibleBy5 ( str ) { n = str . length ; return ( ( ( str [ n - 1 ] - ' ' ) == 0 ) || ( ( str [ n - 1 ] - ' ' ) == 5 ) ) ; } var str = " " ; var x = isDivisibleBy5 ( str ) ? " " : " " ; document . write ( x ) ;
function isTidy ( num ) { let prev = 10 ; while ( num != 0 ) { let rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; } let num = 1556 ; document . write ( isTidy ( num ) ? " " : " " ) ;
function squareFree ( n ) { let cnt = 0 ; for ( let i = 1 ; ; i ++ ) { let isSqFree = true ; for ( let j = 2 ; j * j <= i ; j ++ ) { if ( i % ( j * j ) == 0 ) { isSqFree = false ; break ; } } if ( isSqFree == true ) { cnt ++ ; if ( cnt == n ) return i ; } } } let n = 10 ; document . write ( " " + squareFree ( n ) ) ;
function kFactors ( n , k ) { var P = Array ( ) ; while ( n % 2 == 0 ) { P . push ( 2 ) ; n = parseInt ( n / 2 ) ; } for ( i = 3 ; i * i <= n ; i = i + 2 ) { while ( n % i == 0 ) { n = parseInt ( n / i ) ; P . push ( i ) ; } } if ( n > 2 ) P . push ( n ) ; if ( P . length < k ) { document . write ( " " ) ; return ; } for ( i = 0 ; i < k - 1 ; i ++ ) document . write ( P [ i ] + " " ) ; var product = 1 ; for ( i = k - 1 ; i < P . length ; i ++ ) product = product * P [ i ] ; document . write ( product ) ; } var n = 54 , k = 3 ; kFactors ( n , k ) ;
function nondecdigits ( n ) { let x = 0 ; for ( x = n ; x >= 1 ; x -- ) { let no = x ; let prev_dig = 11 ; let flag = true ; while ( no != 0 ) { if ( prev_dig < no % 10 ) { flag = false ; break ; } prev_dig = no % 10 ; no = Math . floor ( no / 10 ) ; } if ( flag == true ) break ; } return x ; } let n = 200 ; document . write ( nondecdigits ( n ) ) ;
function nondecdigits ( s ) { var m = s . length ; var a = Array . from ( { length : m + 1 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < m ; i ++ ) a [ i ] = s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; var level = m - 1 ; for ( i = m - 1 ; i > 0 ; i -- ) { if ( a [ i ] < a [ i - 1 ] ) { a [ i - 1 ] -- ; level = i - 1 ; } } if ( a [ 0 ] != 0 ) { for ( i = 0 ; i <= level ; i ++ ) document . write ( a [ i ] ) ; for ( i = level + 1 ; i < m ; i ++ ) document . write ( " " ) ; } else { for ( i = 1 ; i < level ; i ++ ) document . write ( a [ i ] ) ; for ( i = level + 1 ; i < m ; i ++ ) document . write ( " " ) ; } } var n = " " ; nondecdigits ( n ) ;
function countDivisors ( n ) { let cnt = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) cnt ++ ; cnt = cnt + 2 ; } } return cnt ; } document . write ( " " + " " + countDivisors ( 100 ) ) ;
function hasEvenNumberOfFactors ( n ) { let root_n = Math . sqrt ( n ) ; if ( ( root_n * root_n ) == n ) return false ; return true ; } function printStatusOfDoors ( n ) { for ( let i = 1 ; i <= n ; i ++ ) { if ( hasEvenNumberOfFactors ( i ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; } } let n = 5 ; printStatusOfDoors ( n ) ;
function validate ( n ) { for ( let i = 0 ; i < 10 ; i ++ ) { let temp = n ; let count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; } let n = 1552793 ; if ( validate ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function divisibleBy36 ( num ) { let l = num . length ; if ( l == 0 ) return " " ; if ( l == 1 && num [ 0 ] != ' ' ) return " " ; let two_digit_num = ( num [ l - 2 ] - ' ' ) * 10 + ( num [ l - 1 ] - ' ' ) ; if ( two_digit_num % 4 != 0 ) return " " ; let sum = 0 ; for ( let i = 0 ; i < l ; i ++ ) sum += ( num [ i ] - ' ' ) ; if ( sum % 9 != 0 ) return " " ; return " " ; } let num = " " ; document . write ( divisibleBy36 ( num ) ) ;
function check ( str ) { let n = str . length ; if ( n == 0 ) return false ; if ( n == 1 ) return ( ( str [ 0 ] - ' ' ) % 8 == 0 ) ; if ( n == 2 ) return ( ( ( str [ n - 2 ] - ' ' ) * 10 + ( str [ n - 1 ] - ' ' ) ) % 8 == 0 ) ; let last = str [ n - 1 ] - ' ' ; let second_last = str [ n - 2 ] - ' ' ; let third_last = str [ n - 3 ] - ' ' ; return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) ; } let str = " " ; if ( check ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countDigits ( n ) { let count = 0 ; while ( n > 0 ) { count ++ ; n = Math . floor ( n / 10 ) ; } return count ; } function checkPrime ( n ) { if ( n <= 1 ) return - 1 ; if ( n <= 3 ) return 0 ; if ( n % 2 == 0 n % 3 == 0 ) return - 1 ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return - 1 ; return 0 ; } function printPrimePoints ( n ) { let count = countDigits ( n ) ; if ( count == 1 count == 2 ) { document . write ( " " ) ; return ; } let found = false ; for ( let i = 1 ; i < ( count - 1 ) ; i ++ ) { let left = Math . floor ( n / ( Math . pow ( 10 , count - i ) ) ) ; let right = n % ( Math . pow ( 10 , count - i - 1 ) ) ; if ( checkPrime ( left ) == 0 && checkPrime ( right ) == 0 ) { document . write ( i + " " ) ; found = true ; } } if ( found == false ) document . write ( " " ) ; } let n = 2317 ; printPrimePoints ( n ) ;
function power ( num , n ) { if ( n == 0 ) return 1 ; else if ( n % 2 == 0 ) return power ( num , parseInt ( n / 2 ) ) * power ( num , parseInt ( n / 2 ) ) ; else return num * power ( num , parseInt ( n / 2 ) ) * power ( num , parseInt ( n / 2 ) ) ; } function checkRecursive ( x , n , curr_num , curr_sum ) { var results = 0 ; var p = power ( curr_num , n ) ; while ( p + curr_sum < x ) { results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) ; curr_num ++ ; p = power ( curr_num , n ) ; } if ( p + curr_sum == x ) results ++ ; return results ; } var x = 10 , n = 2 ; document . write ( checkRecursive ( x , n , 1 , 0 ) ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function printGenerators ( n ) { document . write ( " " ) ; for ( var i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) document . write ( i + " " ) ; } var n = 10 ; printGenerators ( n ) ;
function check ( str ) { let n = str . length ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 3 == 0 ) ; } let str = " " ; let x = check ( str ) ? " " : " " ; document . write ( x ) ;
let MAX = 100001 ; ; let perfectDiv = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { perfectDiv [ i ] = 0 ; } function precomputeCounts ( ) { for ( let i = 1 ; i * i < MAX ; ++ i ) { for ( let j = i * i ; j < MAX ; j += i * i ) ++ perfectDiv [ j ] ; } } function countPerfectDivisors ( n ) { return perfectDiv [ n ] ; } precomputeCounts ( ) ; let n = 16 ; document . write ( " " + n + " " + countPerfectDivisors ( n ) + " " ) ; n = 12 ; document . write ( " " + n + " " + countPerfectDivisors ( n ) ) ;
let MAXN = 100001 ; let spf = new Array ( MAXN ) ; function sieve ( ) { spf [ 1 ] = 1 ; for ( let i = 2 ; i < MAXN ; i ++ ) spf [ i ] = i ; for ( let i = 4 ; i < MAXN ; i += 2 ) spf [ i ] = 2 ; for ( let i = 3 ; i * i < MAXN ; i ++ ) { if ( spf [ i ] == i ) { for ( let j = i * i ; j < MAXN ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } function getFactorization ( x ) { let ret = [ ] ; while ( x != 1 ) { ret . push ( spf [ x ] ) ; x = Math . floor ( x / spf [ x ] ) ; } return ret ; } sieve ( ) ; let x = 12246 ; document . write ( " " + x + " " ) ; let p = getFactorization ( x ) ; for ( let i = 0 ; i < p . length ; i ++ ) document . write ( p [ i ] + " " ) ; document . write ( " " ) ;
function largestGCDSubsequence ( arr , n ) { var ans = 0 ; var maxele = Math . max ( ... arr ) ; for ( var i = 2 ; i <= maxele ; ++ i ) { var count = 0 ; for ( j = 0 ; j < n ; ++ j ) { if ( arr [ j ] % i == 0 ) ++ count ; } ans = Math . max ( ans , count ) ; } return ans ; } var arr = [ 3 , 6 , 2 , 5 , 4 ] ; var size = arr . length ; document . write ( largestGCDSubsequence ( arr , size ) ) ;
var MAX = 1000006 ; function sieve ( count ) { for ( i = 2 ; i * i <= MAX ; i ++ ) { if ( count [ i ] == 0 ) { for ( j = 2 * i ; j < MAX ; j += i ) count [ j ] ++ ; count [ i ] = 1 ; } } } function query ( count , l , r ) { var sum = 0 ; for ( i = l ; i <= r ; i ++ ) sum += count [ i ] ; return sum ; } var count = Array . from ( { length : MAX } , ( _ , i ) => 0 ) ; sieve ( count ) ; document . write ( query ( count , 6 , 10 ) + " " + query ( count , 1 , 5 ) ) ;
function generateNumbers ( factor , n , k ) { let next = new Array ( k ) ; next . fill ( 0 ) ; for ( let i = 0 ; i < n ; ) { let toincrement = 0 ; for ( let j = 0 ; j < k ; j ++ ) if ( next [ j ] < next [ toincrement ] ) toincrement = j ; if ( output != next [ toincrement ] ) { output = next [ toincrement ] ; document . write ( next [ toincrement ] + " " ) ; i ++ ; } next [ toincrement ] += factor [ toincrement ] ; } } let factor = [ 3 , 5 , 7 ] ; let n = 10 ; let k = factor . length ; generateNumbers ( factor , n , k ) ;
function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } function multiplicativeOrder ( A , N ) { if ( GCD ( A , N ) != 1 ) return - 1 ; let result = 1 ; let K = 1 ; while ( K < N ) { result = ( result * A ) % N ; if ( result == 1 ) return K ; K ++ ; } return - 1 ; } let A = 4 , N = 7 ; document . write ( multiplicativeOrder ( A , N ) ) ;
function sumOfRange ( a , b ) { let i = ( a * ( a + 1 ) ) >> 1 ; let j = ( b * ( b + 1 ) ) >> 1 ; return ( i - j ) ; } function sumofproduct ( n ) { let sum = 0 ; let root = Math . floor ( Math . sqrt ( n ) ) ; for ( let i = 1 ; i <= root ; i ++ ) { let up = Math . floor ( n / i ) ; let low = Math . max ( Math . floor ( n / ( i + 1 ) ) , root ) ; sum += ( i * sumOfRange ( up , low ) ) ; sum += ( i * Math . floor ( n / i ) ) ; } return sum ; } let n = 10 ; document . write ( sumofproduct ( n ) ) ;
function minPower ( n , x ) { if ( x == 1 ) return n ; let ans = 0 ; while ( n > 0 ) { ans += ( n % x ) ; n = Math . floor ( n / x ) ; } return ans ; } let n = 5 , x = 3 ; document . write ( minPower ( n , x ) + " " ) ;
function calSum ( n ) { let a = 3 , b = 0 , c = 2 ; return 3 ; return 3 ; return 5 ; let sum = 5 ; while ( n > 2 ) { let d = a + b ; sum += d ; a = b ; b = c ; c = d ; n -- ; } return sum ; } let n = 9 ; document . write ( calSum ( n ) ) ;
function findKHCF ( x , y , k ) { let small = Math . min ( x , y ) ; let count = 1 ; for ( let i = 2 ; i <= small ; i ++ ) { if ( x % i == 0 && y % i == 0 ) count ++ ; if ( count == k ) return i ; } return - 1 ; } let x = 4 , y = 24 , k = 3 ; document . write ( findKHCF ( x , y , k ) ) ;
function findMinNumber ( n ) { let count = 0 ; let ans = 1 ; while ( n % 2 == 0 ) { count ++ ; n /= 2 ; } if ( count % 2 ) ans *= 2 ; for ( let i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n /= i ; } if ( count % 2 ) ans *= i ; } if ( n > 2 ) ans *= n ; return ans ; } let n = 72 ; document . write ( findMinNumber ( n ) + " " ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function findgcd ( n , x , y ) { let g = gcd ( x , y ) ; for ( let i = 0 ; i < g ; i ++ ) document . write ( n ) ; } let n = 123 , x = 5 , y = 2 ; findgcd ( n , x , y ) ;
function gcd ( a , b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; } function firstFactorialDivisibleNumber ( x ) { let new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; } function countFactorialXNotY ( x , y ) { return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) ; } let x = 15 , y = 25 ; document . write ( countFactorialXNotY ( x , y ) ) ;
function firstFactorialDivisibleNumber ( x ) { var fact = 1 ; for ( i = 1 ; i < x ; i ++ ) { fact = fact * i ; if ( fact % x == 0 ) break ; } return i ; } var x = 16 ; document . write ( firstFactorialDivisibleNumber ( x ) ) ;
function SieveOfEratosthenes ( n , isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( let i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) isPrime [ i ] = false ; } } return false ; } function findPrimePair ( n ) { let isPrime = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { isPrime [ i ] = false ; } SieveOfEratosthenes ( n , isPrime ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPrime [ i ] && isPrime [ n - i ] ) { document . write ( i + " " + ( n - i ) ) ; return ; } } } let n = 74 ; findPrimePair ( n ) ;
function getFirstDigit ( x ) { while ( x >= 10 ) x /= 10 ; return x ; } function getCountWithSameStartAndEndFrom1 ( x ) { if ( x < 10 ) return x ; let tens = x / 10 ; let res = tens + 9 ; let firstDigit = getFirstDigit ( x ) ; let lastDigit = x % 10 ; if ( lastDigit < firstDigit ) res -- ; return res ; } function getCountWithSameStartAndEnd ( start , end ) { return getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ; } let start = 5 , end = 40 ; document . write ( getCountWithSameStartAndEnd ( start , end ) ) ;
function sieveOfEratosthenes ( n , isPrime ) { isPrime [ 0 ] = isPrime [ 1 ] = false ; for ( let i = 2 ; i <= n ; i ++ ) isPrime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( isPrime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) isPrime [ i ] = false ; } } } function rightTruPrime ( n ) { let isPrime = new Array ( n + 1 ) . fill ( false ) ; sieveOfEratosthenes ( n , isPrime ) ; while ( n != 0 ) { if ( isPrime [ n ] ) n = parseInt ( n / 10 ) ; else return false ; } return true ; } var n = 59399 ; if ( rightTruPrime ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function SieveOfEratosthenes ( n , prime ) { for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } } function mersennePrimes ( n ) { let prime = [ ] ; SieveOfEratosthenes ( n , prime ) ; for ( let k = 2 ; ( ( 1 << k ) - 1 ) <= n ; k ++ ) { let num = ( 1 << k ) - 1 ; if ( prime [ ( num ) ] ) document . write ( num + " " ) ; } } let n = 31 ; document . write ( " " + " " + " " + n + " " ) ; mersennePrimes ( n ) ;
function findSum ( N , K ) { let ans = 0 ; for ( let i = 1 ; i <= N ; i ++ ) ans += ( i % K ) ; return ans ; } let N = 10 , K = 2 ; document . write ( findSum ( N , K ) ) ;
function findSum ( N , K ) { let ans = 0 ; let y = N / K ; let x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; } let N = 10 ; let K = 2 ; document . write ( findSum ( N , K ) ) ;
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function findnum ( str ) { var n = str . length ; var count_after_dot = 0 ; let dot_seen = false ; var num = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != ' ' ) { num = num * 10 + ( str . charAt ( i ) - ' ' ) ; if ( dot_seen == true ) count_after_dot ++ ; } else dot_seen = true ; } if ( dot_seen == false ) return 1 ; var dem = parseInt ( Math . pow ( 10 , count_after_dot ) ) ; return ( dem / gcd ( num , dem ) ) ; } let str = " " ; document . write ( findnum ( str ) ) ;
function maxHandshake ( n ) { return ( n * ( n - 1 ) ) / 2 ; } let n = 10 ; document . write ( maxHandshake ( n ) ) ;
function divisible ( N , digit ) { let ans = 0 ; for ( let i = 0 ; i < N . length ; i ++ ) { ans = ( ans * 10 + ( N [ i ] - ' ' ) ) ; ans %= digit ; } return ( ans == 0 ) ; } function allDigits ( N ) { let divide = [ ] ; for ( let i = 0 ; i < divide . length ; i ++ ) { divide [ i ] = false ; } divide [ 1 ] = true ; for ( let digit = 2 ; digit <= 9 ; digit ++ ) { if ( divisible ( N , digit ) ) divide [ digit ] = true ; } let result = 0 ; for ( let i = 0 ; i < N . length ; i ++ ) { if ( divide [ N [ i ] - ' ' ] == true ) result ++ ; } return result ; } let N = " " ; document . write ( allDigits ( N ) ) ;
function countNums ( n , x , y ) { arr = Array ( n + 1 ) . fill ( false ) ; if ( x <= n ) arr [ x ] = true ; if ( y <= n ) arr [ y ] = true ; var result = 0 ; for ( i = Math . min ( x , y ) ; i <= n ; i ++ ) { if ( arr [ i ] ) { if ( i + x <= n ) arr [ i + x ] = true ; if ( i + y <= n ) arr [ i + y ] = true ; result ++ ; } } return result ; } var n = 15 , x = 5 , y = 7 ; document . write ( countNums ( n , x , y ) ) ;
function reverse ( x ) { var rev = 0 ; while ( x > 0 ) { rev = ( rev * 10 ) + x % 10 ; x = parseInt ( x / 10 ) ; } return rev ; } function printEmirp ( n ) { var prime = Array . from ( { length : n + 1 } , ( _ , i ) => true ) ; for ( p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] ) { var rev = reverse ( p ) ; if ( p != rev && rev <= n && prime [ rev ] ) { document . write ( p + " " + rev + " " ) ; prime [ rev ] = false ; } } } } var n = 100 ; printEmirp ( n ) ;
function getSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else { sum = sum + i ; sum = sum + ( n / i ) ; } } } sum = sum - n ; return sum ; } function checkAbundant ( n ) { return ( getSum ( n ) > n ) ; } let k = checkAbundant ( 12 ) ? " " : " " ; document . write ( k ) ; k = checkAbundant ( 15 ) ? " " : " " ; document . write ( k ) ;
function isPowerful ( n ) { while ( n % 2 == 0 ) { let power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( let factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { let power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } if ( isPowerful ( 20 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; if ( isPowerful ( 27 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function divisorsSum ( n ) { for ( let i = 1 ; i <= ( Math . sqrt ( n ) ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { sum = sum + i ; } { sum = sum + i ; sum = sum + ( n / i ) ; } } } return sum ; } function isDeficient ( n ) { return ( divisorsSum ( n ) < ( 2 * n ) ) ; } if ( isDeficient ( 12 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; if ( isDeficient ( 15 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function iskaprekar ( n ) { if ( n == 1 ) return true ; let sq_n = n * n ; let count_digits = 0 ; while ( sq_n ) { count_digits ++ ; sq_n = parseInt ( sq_n / 10 ) ; } for ( let r_digits = 1 ; r_digits < count_digits ; r_digits ++ ) { let eq_parts = Math . pow ( 10 , r_digits ) ; if ( eq_parts == n ) continue ; let sum = parseInt ( ( sq_n1 / eq_parts ) + sq_n1 % eq_parts ) ; if ( sum == n ) return true ; } return false ; } document . write ( " " + " " ) ; for ( let i = 1 ; i < 10000 ; i ++ ) if ( iskaprekar ( i ) ) document . write ( i + " " ) ;
function isKeith ( x ) { let terms = [ ] ; let temp = x ; while ( temp > 0 ) { terms . push ( temp % 10 ) ; temp = parseInt ( temp / 10 ) ; n ++ ; } terms = terms . reverse ( ) ; let next_term = 0 ; let i = n ; while ( next_term < x ) { next_term = 0 ; for ( let j = 1 ; j <= n ; j ++ ) next_term += terms [ i - j ] ; terms . push ( next_term ) ; i ++ ; } return ( next_term == x ) ; } isKeith ( 14 ) ? document . write ( " " ) : document . write ( " " ) ; isKeith ( 12 ) ? document . write ( " " ) : document . write ( " " ) ; isKeith ( 197 ) ? document . write ( " " ) : document . write ( " " ) ;
function canBeSumofConsec ( n ) { return ( ( ( n & ( n - 1 ) ) != 0 ) && n != 0 ) ; } let n = 15 ; document . write ( canBeSumofConsec ( n ) ? " " : " " ) ;
function evenFibSum ( limit ) { if ( limit < 2 ) return 0 ; let ef1 = 0 , ef2 = 2 ; let sum = ef1 + ef2 ; while ( ef2 <= limit ) { let ef3 = 4 * ef2 + ef1 ; if ( ef3 > limit ) break ; ef1 = ef2 ; ef2 = ef3 ; sum += ef2 ; } return sum ; } let limit = 400 ; document . write ( evenFibSum ( limit ) ) ;
function isPerfect ( n ) { var s = parseInt ( ( Math . sqrt ( n ) ) ) ; return ( s * s == n ) ; } function divisorsCount ( n ) { var count = 0 ; for ( var i = 1 ; i <= parseInt ( Math . sqrt ( n ) ) + 1 ; i ++ ) { if ( n % i == 0 ) { if ( parseInt ( n / i ) == i ) count += 1 ; else count += 2 ; } } return count ; } function kDivisors ( a , b , k ) { var count = 0 ; for ( var i = a ; i <= b ; i ++ ) { if ( isPerfect ( i ) ) { if ( divisorsCount ( i ) == k ) { count ++ ; } } } return count ; } var a = 2 , b = 49 , k = 3 ; document . write ( kDivisors ( a , b , k ) ) ;
function evenFib ( n ) { if ( n < 1 ) return n ; if ( n == 1 ) return 2 ; return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) ; } let n = 7 ; document . write ( evenFib ( n ) ) ;
function countSteps ( x , y ) { if ( x % y == 0 ) return Math . floor ( x / y ) ; return Math . floor ( x / y ) + countSteps ( y , x % y ) ; } let x = 100 , y = 19 ; document . write ( countSteps ( x , y ) ) ;
function findCountOfSolutions ( n , p ) { let ans = 0 ; for ( let x = 1 ; x < p ; x ++ ) { if ( ( x * x ) % p == 1 ) { let last = x + p * ( n / p ) ; if ( last > n ) last -= p ; ans += ( ( last - x ) / p + 1 ) ; } } return ans ; } let n = 10 ; let p = 5 ; document . write ( findCountOfSolutions ( n , p ) ) ;
function kaprekarRec ( n , prev ) { if ( n == 0 ) return 0 ; prev = n ; var digits = Array . from ( { length : 4 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < 4 ; i ++ ) { digits [ i ] = n % 10 ; n = parseInt ( n / 10 ) ; } digits . sort ( ) ; var asc = 0 ; for ( i = 0 ; i < 4 ; i ++ ) asc = asc * 10 + digits [ i ] ; digits . sort ( ) ; var desc = 0 ; for ( i = 3 ; i >= 0 ; i -- ) desc = desc * 10 + digits [ i ] ; var diff = Math . abs ( asc - desc ) ; if ( diff == prev ) return diff ; return kaprekarRec ( diff , prev ) ; } function kaprekar ( n ) { var prev = 0 ; return kaprekarRec ( n , prev ) ; } document . write ( kaprekar ( 1000 ) + " " ) ; document . write ( kaprekar ( 1112 ) + " " ) ; document . write ( kaprekar ( 9812 ) + " " ) ;
function sqroot ( s ) { var pSq = 0 ; var N = 0 ; for ( i = parseInt ( s ) ; i > 0 ; i -- ) { for ( j = 1 ; j < i ; j ++ ) { if ( j * j == i ) { pSq = i ; N = j ; break ; } } if ( pSq > 0 ) break ; } var d = s - pSq ; var P = ( d / ( 2.0 * N ) ) ; var A = N + P ; var sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; return sqrt_of_s ; } var num = 9.2345 ; var sqroot_of_num = sqroot ( num ) ; document . write ( " " + num + " " + ( Math . round ( sqroot_of_num * 100000.0 ) / 100000.0 ) . toFixed ( 6 ) ) ;
function power ( x , a ) { let res = 1 ; while ( a > 0 ) { if ( ( a & 1 ) > 0 ) res = res * x ; x = x * x ; a >>= 1 ; } return res ; } function breakInteger ( N ) { if ( N == 2 ) return 1 ; if ( N == 3 ) return 2 ; let maxProduct ; switch ( N % 3 ) { case 0 : maxProduct = power ( 3 , N / 3 ) ; break ; case 1 : maxProduct = 2 * 2 * power ( 3 , ( N / 3 ) - 1 ) ; break ; case 2 : maxProduct = 2 * power ( 3 , N / 3 ) ; break ; } return maxProduct ; } let maxProduct = breakInteger ( 10 ) ; document . write ( maxProduct ) ;
let n = 1234 ; function getSum ( n ) { let sum = 0 ; while ( n > 0 sum > 9 ) { if ( n == 0 ) { n = sum ; sum = 0 ; } sum = sum + n % 10 ; n = Math . floor ( n / 10 ) ; } return sum ; } document . write ( getSum ( n ) ) ;
function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } n = 9999 ; document . write ( digSum ( n ) ) ;
function countMultiples ( n ) { return Math . floor ( n / 3 + n / 7 - n / 21 ) ; } document . write ( " " + countMultiples ( 25 ) ) ;
function Modulo ( a , b ) { let mod = 0 ; for ( let i = 0 ; i < b . length ; i ++ ) mod = ( mod * 10 + b [ i ] - ' ' ) % a ; } function LastDigit ( a , b ) { let len_a = a . length ; let len_b = b . length ; if ( len_a == 1 && len_b == 1 && b [ 0 ] == ' ' && a [ 0 ] == ' ' ) return 1 ; if ( len_b == 1 && b [ 0 ] == ' ' ) return 1 ; if ( len_a == 1 && a [ 0 ] == ' ' ) return 0 ; exp = ( Modulo ( 4 , b ) == 0 ) ? 4 : Modulo ( 4 , b ) ; res = Math . pow ( a [ len_a - 1 ] - ' ' , exp ) ; return res % 10 ; } let a = " " ; let b = " " ; document . write ( LastDigit ( a , b ) ) ;
function reversDigits ( num ) { let rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = parseInt ( num / 10 , 10 ) ; } return rev_num ; } function isPalindrome ( num ) { return ( reversDigits ( num ) == num ) ; } function ReverseandAdd ( num ) { let rev_num = 0 ; while ( num <= 4294967295 ) { rev_num = reversDigits ( num ) ; num = num + rev_num ; if ( isPalindrome ( num ) ) { document . write ( num + " " ) ; break ; } else if ( num > 4294967295 ) { document . write ( " " + " " ) ; } } } ReverseandAdd ( 195 ) ; ReverseandAdd ( 265 ) ;
function gcd ( a , b ) { if ( a == b ) return a ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; { return gcd ( a >> 1 , b ) ; return gcd ( a >> 1 , b >> 1 ) << 1 ; } if ( ( ~ b & 1 ) == 1 ) return gcd ( a , b >> 1 ) ; if ( a > b ) return gcd ( ( a - b ) >> 1 , b ) ; return gcd ( ( b - a ) >> 1 , a ) ; } let a = 34 , b = 17 ; document . write ( " " + " " + gcd ( a , b ) ) ;
function findNDigitNumsUtil ( n , sum , out , index ) { if ( index > n sum < 0 ) return ; if ( index == n ) { if ( sum == 0 ) { out [ index ] = ' \0 ' ; for ( let i = 0 ; i < out . length ; i ++ ) document . write ( out [ i ] ) ; document . write ( " " ) ; } return ; } for ( let i = 0 ; i <= 9 ; i ++ ) { out [ index ] = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , sum - i , out , index + 1 ) ; } } function findNDigitNums ( n , sum ) { let out = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { out [ i ] = false ; } for ( let i = 1 ; i <= 9 ; i ++ ) { out [ 0 ] = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , sum - i , out , 1 ) ; } } let n = 2 , sum = 3 ; findNDigitNums ( n , sum ) ;
function oneDigit ( num ) { return ( num >= 0 && num < 10 ) ; } function isPalUtil ( num , dupNum ) { if ( oneDigit ( num ) ) return ( num == ( dupNum ) % 10 ) ; if ( ! isPalUtil ( parseInt ( num / 10 ) , dupNum ) ) return false ; dupNum = parseInt ( dupNum / 10 ) ; return ( num % 10 == ( dupNum ) % 10 ) ; } function isPal ( num ) { if ( num < 0 ) num = - num ; return isPalUtil ( num , dupNum ) ; } function printPalPrimesLessThanN ( n ) { var prime = Array . from ( { length : n + 1 } , ( _ , i ) => true ) ; for ( p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( i = p * 2 ; i <= n ; i += p ) { prime [ i ] = false ; } } } for ( p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] && isPal ( p ) ) { document . write ( p + " " ) ; } } } var n = 100 ; document . write ( ' ' + n + ' ' ) ; printPalPrimesLessThanN ( n ) ;
function countPrimeFactors ( n ) { let count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } function printKAlmostPrimes ( k , n ) { for ( let i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == k ) { document . write ( num + " " ) ; i ++ ; } } return ; } let n = 10 , k = 2 ; document . write ( " " + n + " " + k + " " + " " ) ; printKAlmostPrimes ( k , n ) ;
const gcd = ( a , b ) => { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } const lowest = ( den3 , num3 ) => { let common_factor = gcd ( num3 , den3 ) ; den3 = parseInt ( den3 / common_factor ) ; num3 = parseInt ( num3 / common_factor ) ; document . write ( ` ${ num3 } ${ den3 } ` ) } const addFraction = ( num1 , den1 , num2 , den2 ) => { let den3 = gcd ( den1 , den2 ) ; den3 = ( den1 * den2 ) / den3 ; let num3 = ( ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ) ; lowest ( den3 , num3 ) ; } let num1 = 1 ; let den1 = 500 ; let num2 = 2 ; let den2 = 1500 ; document . write ( ` ${ num1 } ${ den1 } ${ num2 } ${ den2 } ` ) ; addFraction ( num1 , den1 , num2 , den2 ) ;
function findPieces ( n ) { return ( n * ( n + 1 ) ) / 2 + 1 ; } document . write ( findPieces ( 1 ) + " " ) ; document . write ( findPieces ( 2 ) + " " ) ; document . write ( findPieces ( 3 ) + " " ) ; document . write ( findPieces ( 50 ) ) ;
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let x = ( ( n * Math . log10 ( n / Math . E ) + Math . log10 ( 2 * Math . PI * n ) / 2.0 ) ) ; return Math . floor ( x ) + 1 ; } document . write ( findDigits ( 1 ) + " " ) ; document . write ( findDigits ( 50000000 ) + " " ) ; document . write ( findDigits ( 1000000000 ) + " " ) ; document . write ( findDigits ( 120 ) + " " ) ;
function findDigits ( n ) { if ( n < 0 ) return 0 ; if ( n <= 1 ) return 1 ; let digits = 0 ; for ( let i = 2 ; i <= n ; i ++ ) digits += Math . log10 ( i ) ; return Math . floor ( digits ) + 1 ; } document . write ( findDigits ( 1 ) + " " ) ; document . write ( findDigits ( 5 ) + " " ) ; document . write ( findDigits ( 10 ) + " " ) ; document . write ( findDigits ( 120 ) + " " ) ;
function countEvenSum ( arr , n ) { let result = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { let sum = 0 ; for ( let j = i ; j <= n - 1 ; j ++ ) { sum = sum + arr [ j ] ; if ( sum % 2 == 0 ) result ++ ; } } return ( result ) ; } let arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] ; let n = arr . length ; document . write ( " " + " " ) ; document . write ( countEvenSum ( arr , n ) ) ;
function countEvenSum ( arr , n ) { let temp = [ 1 , 0 ] ; let result = 0 , sum = 0 ; for ( let i = 0 ; i <= n - 1 ; i ++ ) { sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 ; temp [ sum ] ++ ; } result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) / 2 ) ; result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) / 2 ) ; return ( result ) ; } let arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] ; let n = arr . length ; document . write ( " " + " " + countEvenSum ( arr , n ) ) ;
function calculateSum ( n ) { let fibo = [ ] ; if ( n <= 0 ) return 0 ; fibo [ 0 ] = 0 ; fibo [ 1 ] = 1 ; let sum = fibo [ 0 ] + fibo [ 1 ] ; for ( let i = 2 ; i <= n ; i ++ ) { fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] ; sum += fibo [ i ] ; } return sum ; } let n = 4 ; document . write ( ` ${ calculateSum ( n ) } ` ) ;
function findCombinationsUtil ( arr , index , num , reducedNum ) { if ( reducedNum < 0 ) return ; if ( reducedNum == 0 ) { for ( let i = 0 ; i < index ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; return ; } let prev = ( index == 0 ) ? 1 : arr [ index - 1 ] ; for ( let k = prev ; k <= num ; k ++ ) { arr [ index ] = k ; findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) ; } } function findCombinations ( n ) { let arr = [ ] ; findCombinationsUtil ( arr , 0 , n , n ) ; } let n = 5 ; findCombinations ( n ) ;
let z = 0 ; function pow1 ( base1 , exponent , modulus ) { let result = 1 ; base1 = base1 % modulus ; while ( exponent > 0 ) { if ( exponent % 2 == 1 ) result = ( result * base1 ) % modulus ; exponent = exponent >> 1 ; base1 = ( base1 * base1 ) % modulus ; } return result ; } function gcd ( a , b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } function order ( p , b ) { if ( gcd ( p , b ) != 1 ) { document . write ( " " + " " + " " ) ; return - 1 ; } let k = 3 ; while ( true ) { if ( pow1 ( b , k , p ) == 1 ) return k ; k ++ ; } } function convertx2e ( x ) { z = 0 ; while ( x % 2 == 0 ) { x /= 2 ; z ++ ; } return x ; } function STonelli ( n , p ) { if ( gcd ( n , p ) != 1 ) { System . out . prletln ( " " ) ; return - 1 ; } if ( pow1 ( n , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) { document . write ( " " + " " ) ; return - 1 ; } let s , e ; s = convertx2e ( p - 1 ) ; e = z ; let q ; for ( q = 2 ; ; q ++ ) { if ( pow1 ( q , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) break ; } let x = pow1 ( n , ( s + 1 ) / 2 , p ) ; let b = pow1 ( n , s , p ) ; let g = pow1 ( q , s , p ) ; let r = e ; while ( true ) { let m ; for ( m = 0 ; m < r ; m ++ ) { if ( order ( p , b ) == - 1 ) return - 1 ; if ( order ( p , b ) == Math . pow ( 2 , m ) ) break ; } if ( m == 0 ) return x ; x = ( x * pow1 ( g , Math . pow ( 2 , r - m - 1 ) , p ) ) % p ; g = pow1 ( g , Math . pow ( 2 , r - m ) , p ) ; b = ( b * g ) % p ; if ( b == 1 ) return x ; r = m ; } } let n = 2 ; let p = 113 ; let x = STonelli ( n , p ) ; if ( x == - 1 ) document . write ( " " + " " ) ; else document . write ( " " + n + " " + p + " " + x + " " ) ;
function isPower ( x , y ) { var res1 = parseInt ( Math . log ( y ) ) / parseInt ( Math . log ( x ) ) ; var res2 = Math . log ( y ) / Math . log ( x ) ; return ( res1 == res2 ) ; } if ( isPower ( 27 , 729 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findRoots ( a , b , c ) { if ( a == 0 ) { document . write ( " " ) ; return ; } let d = b * b - 4 * a * c ; let sqrt_val = Math . sqrt ( Math . abs ( d ) ) ; if ( d > 0 ) { document . write ( " " + " " ) ; document . write ( ( - b + sqrt_val ) / ( 2 * a ) + " " + ( - b - sqrt_val ) / ( 2 * a ) ) ; } else if ( d == 0 ) { document . write ( " " + " " ) ; document . write ( - b / ( 2 * a ) + " " + - b / ( 2 * a ) ) ; } { document . write ( " " ) ; document . write ( - b / ( 2 * a ) + " " + sqrt_val + " " + - b / ( 2 * a ) + " " + sqrt_val ) ; } } let a = 1 , b = - 7 , c = 12 ; findRoots ( a , b , c ) ;
function isPerfectSquare ( n ) { for ( let sum = 0 , i = 1 ; sum < n ; i += 2 ) { sum += i ; if ( sum == n ) return true ; } return false ; } if ( isPerfectSquare ( 35 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; if ( isPerfectSquare ( 49 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function findCount ( d ) { return 9 * ( ( Math . pow ( 10 , d - 1 ) ) - ( Math . pow ( 9 , d - 1 ) ) ) ; } let d = 1 ; document . write ( findCount ( d ) + " " ) ; d = 2 ; document . write ( findCount ( d ) + " " ) ; d = 4 ; document . write ( findCount ( d ) + " " ) ;
function countDyckPaths ( n ) { let res = 1 ; for ( let i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; } let n = 4 ; document . write ( " " + countDyckPaths ( n ) ) ;
function isTriangular ( num ) { if ( num < 0 ) return false ; let sum = 0 ; for ( let n = 1 ; sum <= num ; n ++ ) { sum = sum + n ; if ( sum == num ) return true ; } return false ; } let n = 55 ; if ( isTriangular ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isTriangular ( num ) { if ( num < 0 ) return false ; var c = ( - 2 * num ) ; var b = 1 , a = 1 ; var d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return false ; var root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; var root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( root1 > 0 && Math . floor ( root1 ) == root1 ) return true ; if ( root2 > 0 && Math . floor ( root2 ) == root2 ) return true ; return false ; } var num = 55 ; if ( isTriangular ( num ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function val ( c ) { if ( c >= ' ' . charCodeAt ( ) && c <= ' ' . charCodeAt ( ) ) return ( c - ' ' . charCodeAt ( ) ) ; else return ( c - ' ' . charCodeAt ( ) + 10 ) ; } function toDeci ( str , b_ase ) { let len = str . length ; let power = 1 ; let num = 0 ; let i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] . charCodeAt ( ) ) >= b_ase ) { document . write ( " " ) ; return - 1 ; } num += val ( str [ i ] . charCodeAt ( ) ) * power ; power = power * b_ase ; } return num ; } let str = " " ; let b_ase = 16 ; document . write ( " " + str + " " + b_ase + " " + toDeci ( str , b_ase ) ) ;
function xor_c ( a , b ) { return ( a == b ) ? ' ' : ' ' ; } function flip ( c ) { return ( c == ' ' ) ? ' ' : ' ' ; } function binarytoGray ( binary ) { let gray = " " ; gray += binary [ 0 ] ; for ( let i = 1 ; i < binary . length ; i ++ ) { gray += xor_c ( binary [ i - 1 ] , binary [ i ] ) ; } return gray ; } function graytoBinary ( gray ) { let binary = " " ; binary += gray [ 0 ] ; for ( let i = 1 ; i < gray . length ; i ++ ) { if ( gray [ i ] == ' ' ) binary += binary [ i - 1 ] ; else binary += flip ( binary [ i - 1 ] ) ; } return binary ; } let binary = " " ; document . write ( " " + binary + " " + binarytoGray ( binary ) + " " ) ; let gray = " " ; document . write ( " " + gray + " " + graytoBinary ( gray ) ) ;
function seriesSum ( calculated , current , N ) { let i , cur = 1 ; if ( current == N + 1 ) return 0 ; for ( i = calculated ; i < calculated + current ; i ++ ) cur *= i ; return cur + seriesSum ( i , current + 1 , N ) ; } let N = 5 ; document . write ( seriesSum ( 1 , 1 , N ) ) ;
function modFact ( n , p ) { if ( n >= p ) return 0 ; let result = 1 ; for ( let i = 1 ; i <= n ; i ++ ) result = ( result * i ) % p ; return result ; } let n = 25 , p = 29 ; document . write ( modFact ( n , p ) ) ;
function inv ( a , m ) { let m0 = m ; let x0 = 0 ; let x1 = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { let q = parseInt ( a / m ) ; let t = m ; m = a % m ; a = t ; t = x0 ; x0 = x1 - q * x0 ; x1 = t ; } if ( x1 < 0 ) x1 += m0 ; return x1 ; } function findMinX ( num , rem , k ) { let prod = 1 ; for ( let i = 0 ; i < k ; i ++ ) prod *= num [ i ] ; let result = 0 ; for ( let i = 0 ; i < k ; i ++ ) { pp = parseInt ( prod / num [ i ] ) ; result += rem [ i ] * inv ( pp , num [ i ] ) * pp ; } return result % prod ; } let num = new Array ( 3 , 4 , 5 ) ; let rem = new Array ( 2 , 3 , 1 ) ; let k = num . length ; document . write ( " " + findMinX ( num , rem , k ) ) ;
function findMinX ( num , rem , k ) { while ( true ) { var j ; for ( j = 0 ; j < k ; j ++ ) if ( x % num [ j ] != rem [ j ] ) break ; if ( j == k ) return x ; x ++ ; } } var num = [ 3 , 4 , 5 ] ; var rem = [ 2 , 3 , 1 ] ; var k = num . length ; document . write ( " " + findMinX ( num , rem , k ) ) ;
function nCrModpDP ( n , r , p ) { C = Array ( r + 1 ) . fill ( 0 ) ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = Math . min ( i , r ) ; j > 0 ; j -- ) C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p ; } return C [ r ] ; } function nCrModpLucas ( n , r , p ) { if ( r == 0 ) return 1 ; var ni = n % p , ri = r % p ; } var n = 1000 , r = 900 , p = 13 ; document . write ( " " + nCrModpLucas ( n , r , p ) ) ;
function isValid ( n , d ) { var digit = n % 10 ; var sum = digit ; if ( digit == d ) return false ; n = parseInt ( n / 10 ) ; while ( n > 0 ) { digit = n % 10 ; if ( digit == d digit <= sum ) return false ; else { sum += digit ; n = parseInt ( n / 10 ) ; } } return true ; } function printGoodNumber ( L , R , d ) { for ( i = L ; i <= R ; i ++ ) { if ( isValid ( i , d ) ) document . write ( i + " " ) ; } } var L = 410 , R = 520 , d = 3 ; printGoodNumber ( L , R , d ) ;
function nearestSmallerEqFib ( n ) { if ( n == 0 n == 1 ) return n ; let f1 = 0 ; let f2 = 1 ; let f3 = 1 ; while ( f3 <= n ) { f1 = f2 ; f2 = f3 ; f3 = f1 + f2 ; } return f2 ; } function printFibRepresntation ( n ) { while ( n > 0 ) { let f = nearestSmallerEqFib ( n ) ; document . write ( f , " " ) ; n = n - f ; } } let n = 30 ; document . write ( " " + n + " " ) ; printFibRepresntation ( n ) ;
let dp = new Array ( 5001 ) ; for ( let i = 0 ; i < 5001 ; i ++ ) { dp [ i ] = new Array ( 5001 ) ; for ( let j = 0 ; j < 5001 ; j ++ ) { dp [ i ] [ j ] = new Array ( 5 ) ; } } function countWaysUtil ( n , parts , nextPart ) { if ( parts == 0 && n == 0 ) return 1 ; if ( n <= 0 parts <= 0 ) return 0 ; if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) return dp [ n ] [ nextPart ] [ parts ] ; for ( let i = nextPart ; i <= n ; i ++ ) ans += countWaysUtil ( n - i , parts - 1 , i ) ; return ( dp [ n ] [ nextPart ] [ parts ] = ans ) ; } function countWays ( n ) { for ( let i = 0 ; i < 5001 ; i ++ ) { for ( let j = 0 ; j < 5001 ; j ++ ) { for ( let l = 0 ; l < 5 ; l ++ ) dp [ i ] [ j ] [ l ] = - 1 ; } } return countWaysUtil ( n , 4 , 1 ) ; } let n = 8 ; document . write ( countWays ( n ) ) ;
function printTwins ( low , high ) { var prime = Array . from ( { length : high + 1 } , ( _ , i ) => 0 ) ; var twin = false ; for ( i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( p = 2 ; p <= Math . floor ( Math . sqrt ( high ) ) + 1 ; p ++ ) { if ( prime [ p ] ) { for ( i = p * 2 ; i <= high ; i += p ) { prime [ i ] = false ; } } } for ( i = low ; i <= high ; i ++ ) { if ( prime [ i ] && prime [ i + 2 ] ) { var a = i + 2 ; document . write ( " " + " " + i + " " + a + " " ) ; twin = true ; break ; } } if ( twin == false ) { document . write ( " " ) ; } } printTwins ( 10 , 100 ) ;
function nextSparse ( x ) { let bin = new Array ( ) ; while ( x != 0 ) { bin . push ( x & 1 ) ; x >>= 1 ; } bin . push ( 0 ) ; n = bin . length ; let last_final = 0 ; for ( let i = 1 ; i < n - 1 ; i ++ ) { if ( bin [ i ] == 1 && bin [ i - 1 ] == 1 && bin [ i + 1 ] != 1 ) { bin [ i + 1 ] = 1 ; for ( let j = i ; j >= last_final ; j -- ) bin [ j ] = 0 ; last_final = i + 1 ; } } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += bin [ i ] * ( 1 << i ) ; return ans ; } let x = 38 ; document . write ( " " + nextSparse ( x ) ) ;
function sumBitDifferences ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { let count = 0 ; for ( let j = 0 ; j < n ; j ++ ) if ( ( arr [ j ] & ( 1 << i ) ) ) count ++ ; ans += ( count * ( n - count ) * 2 ) ; } return ans ; } let arr = [ 1 , 3 , 5 ] ; let n = arr . length ; document . write ( sumBitDifferences ( arr , n ) ) ;
function printArr ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; } function generateUtil ( x , arr , curr_sum , curr_idx ) { if ( curr_sum == x ) { printArr ( arr , curr_idx ) ; return ; } let num = 1 ; while ( num <= x - curr_sum && ( curr_idx == 0 num <= arr [ curr_idx - 1 ] ) ) { arr [ curr_idx ] = num ; generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) ; num ++ ; } } function generate ( x ) { let arr = new Array ( x ) ; generateUtil ( x , arr , 0 , 0 ) ; } let x = 5 ; generate ( x ) ;
function isPerfect ( n ) { sum = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { if ( i * i != n ) sum = sum + i + n / i ; else sum = sum + i ; } } if ( sum == n && n != 1 ) return true ; return false ; } document . write ( " " + " " ) ; for ( let n = 2 ; n < 10000 ; n ++ ) if ( isPerfect ( n ) ) document . write ( n + " " + " " ) ;
function checkUtil ( num , dig , base ) { if ( dig == 1 && num < base ) return true ; if ( dig > 1 && num >= base ) return checkUtil ( parseInt ( num / base ) , -- dig , base ) ; return false ; } function check ( num , dig ) { for ( base = 2 ; base <= 32 ; base ++ ) if ( checkUtil ( num , dig , base ) ) return true ; return false ; } var num = 8 ; var dig = 3 ; if ( check ( num , dig ) ) document . write ( " " ) ; else document . write ( " " ) ;
function mod ( num , a ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) res = ( res * 10 + num [ i ] - ' ' ) % a ; return res ; } let num = " " ; document . write ( mod ( num , 10 ) ) ;
function modInverse ( a , m ) { for ( let x = 1 ; x < m ; x ++ ) if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) return x ; } let a = 3 ; let m = 11 ; document . write ( modInverse ( a , m ) ) ;
function modInverse ( a , m ) { let m0 = m ; let y = 0 ; let x = 1 ; if ( m == 1 ) return 0 ; while ( a > 1 ) { let q = parseInt ( a / m ) ; let t = m ; m = a % m ; a = t ; t = y ; y = x - q * y ; x = t ; } if ( x < 0 ) x += m0 ; return x ; } let a = 3 ; let m = 11 ; document . write ( ` ${ modInverse ( a , m ) } ` ) ;
function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function phi ( n ) { let result = 1 ; for ( let i = 2 ; i < n ; i ++ ) if ( gcd ( i , n ) == 1 ) result ++ ; return result ; } for ( let n = 1 ; n <= 10 ; n ++ ) document . write ( ` ${ n } ${ phi ( n ) } ` ) ;
function phi ( n ) { let result = n ; for ( let p = 2 ; p * p <= n ; ++ p ) { if ( n % p == 0 ) { while ( n % p == 0 ) n /= p ; result *= ( 1.0 - ( 1.0 / p ) ) ; } } if ( n > 1 ) result *= ( 1.0 - ( 1.0 / n ) ) ; return parseInt ( result ) ; } for ( let n = 1 ; n <= 10 ; n ++ ) document . write ( ` ${ n } ${ phi ( n ) } ` ) ;
function factorial ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res *= i ; return res ; } function sum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += 1.0 / factorial ( i ) ; return sum ; } let n = 5 ; document . write ( sum ( n ) . toFixed ( 5 ) ) ;
function binomialCoeff ( n , k ) { let res = 1 ; if ( k > n - k ) k = n - k ; for ( let i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function catalan ( n ) { let c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } function findWays ( n ) { if ( n & 1 ) return 0 ; return catalan ( n / 2 ) ; } let n = 6 ; document . write ( " " + n + " " + findWays ( 6 ) ) ;
function isOperand ( c ) { return ( c . charCodeAt ( 0 ) >= ' ' . charCodeAt ( 0 ) && c . charCodeAt ( 0 ) <= ' ' . charCodeAt ( 0 ) ) ; } function value ( c ) { return ( c . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; } function evaluate ( exp ) { if ( exp . length == 0 ) return - 1 ; let res = value ( exp [ 0 ] ) ; for ( let i = 1 ; i < exp . length ; i += 2 ) { let opr = exp [ i ] , opd = exp [ i + 1 ] ; if ( isOperand ( opd ) == false ) return - 1 ; if ( opr == ' ' ) res += value ( opd ) ; else if ( opr == ' ' ) res -= value ( opd ) ; else if ( opr == ' ' ) res *= value ( opd ) ; else if ( opr == ' ' ) res /= value ( opd ) ; else return - 1 ; } return res ; } let expr1 = " " ; let res = evaluate ( expr1 ) ; if ( res == - 1 ) document . write ( expr1 + " " ) ; else document . write ( " " + expr1 + " " + res + " " ) ; let expr2 = " " ; res = evaluate ( expr2 ) ; if ( res == - 1 ) document . write ( expr2 + " " ) ; else document . write ( " " + expr2 + " " + res + " " ) ; let expr3 = " " ; res = evaluate ( expr3 ) ; if ( res == - 1 ) document . write ( expr3 + " " ) ; else document . write ( " " + expr3 + " " + res + " " ) ; let expr4 = " " ; res = evaluate ( expr4 ) ; if ( res == - 1 ) document . write ( expr4 + " " ) ; else document . write ( " " + expr4 + " " + res + " " ) ;
function printFibonacciNumbers ( n ) { let f1 = 0 , f2 = 1 , i ; if ( n < 1 ) return ; document . write ( f1 + " " ) ; for ( i = 1 ; i < n ; i ++ ) { document . write ( f2 + " " ) ; let next = f1 + f2 ; f1 = f2 ; f2 = next ; } } printFibonacciNumbers ( 7 ) ;
function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function lcm ( a , b ) { return ( a / gcd ( a , b ) ) * b ; } let a = 15 , b = 20 ; document . write ( " " + a + " " + b + " " + lcm ( a , b ) ) ;
MAX = 11 ; function isMultipleof5 ( n ) { str = Array ( n ) . fill ( ' ' ) ; var len = str . length ; if ( str [ len - 1 ] == ' ' str [ len - 1 ] == ' ' ) return true ; return false ; } var n = 19 ; if ( isMultipleof5 ( n ) == true ) document . write ( n + " " + " " ) ; else document . write ( n + " " + " " ) ;
function pairORSum ( arr , n ) { for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; } var arr = [ 1 , 2 , 3 , 4 ] ; var n = arr . length ; document . write ( pairORSum ( arr , n ) ) ;
function multiplyByFifteen ( n ) { let prod = ( n << 4 ) ; prod = prod - n ; return prod ; } let n = 7 ; document . write ( multiplyByFifteen ( n ) ) ;
function minAND ( arr , n ) { let s = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { s = s & arr [ i ] ; } document . write ( ( s ) + " " ) ; } let arr = [ 1 , 2 , 3 ] ; let n = arr . length ; minAND ( arr , n ) ;
function check ( a , n ) { for ( var i = 0 ; i < n ; i ++ ) if ( a [ i ] ) return true ; return false ; } var a = [ 0 , 1 , 0 , 1 ] ; var n = a . length ; check ( a , n ) ? document . write ( " " ) : document . write ( " " ) ;
function printArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; } function findArray ( q , n ) { let arr = new Array ( n ) , ans ; for ( let k = 0 , j = 0 ; j < parseInt ( n / 4 ) ; j ++ ) { ans = q [ k ] ^ q [ k + 3 ] ; arr [ k + 1 ] = q [ k + 1 ] ^ ans ; arr [ k + 2 ] = q [ k + 2 ] ^ ans ; arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) ; arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) ; k += 4 ; } printArray ( arr , n ) ; } let q = [ 4 , 1 , 7 , 0 ] ; let n = q . length ; findArray ( q , n ) ;
function isEqualBlock ( n ) { var first_bit = n % 2 ; var first_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit && n > 0 ) { n = n / 2 ; first_count ++ ; } if ( n == 0 ) return false ; while ( n > 0 ) { first_bit = n % 2 ; var curr_count = 1 ; n = n / 2 ; while ( n % 2 == first_bit ) { n = n / 2 ; curr_count ++ ; } if ( curr_count != first_count ) return false ; } return true ; } var n = 51 ; if ( isEqualBlock ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function binToDecimal3 ( n ) { var last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; n = n >> 3 ; while ( n > 7 ) n = n >> 1 ; var first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; document . write ( first_3 + " " + last_3 ) ; } var n = 86 ; binToDecimal3 ( n ) ;
function isPowerOfTwo ( x ) { if ( x == 0 ) return false ; if ( ( x & ( x - 1 ) ) == 0 ) return true ; else return false ; } function countNum ( a , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPowerOfTwo ( a [ i ] ) || isPowerOfTwo ( a [ i ] + 1 ) ) count ++ ; } return count ; } let arr = [ 5 , 6 , 9 , 3 , 1 ] ; let n = arr . length ; document . write ( countNum ( arr , n ) ) ;
function checkEvenParity ( x ) { let parity = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; parity ++ ; } if ( parity % 2 == 0 ) return true ; else return false ; } function sumlist ( a , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( checkEvenParity ( a [ i ] ) ) sum += a [ i ] ; } return sum ; } let arr = [ 2 , 4 , 3 , 5 , 9 ] ; let n = arr . length ; document . write ( sumlist ( arr , n ) ) ;
function findOddPair ( A , N ) { let oddPair = 0 ; for ( let i = 0 ; i < N ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; } let A = [ 5 , 6 , 2 , 8 ] ; let N = A . length ; document . write ( findOddPair ( A , N ) ) ;
function findevenPair ( A , N ) { let i , j ; let evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; } let A = [ 5 , 4 , 7 , 2 , 1 ] ; let N = A . length ; document . write ( findevenPair ( A , N ) ) ;
function findEvenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 != 0 ) count ++ ; } let totalPairs = parseInt ( N * ( N - 1 ) / 2 ) ; let oddEvenPairs = count * ( N - count ) ; return totalPairs - oddEvenPairs ; } let a = [ 5 , 4 , 7 , 2 , 1 ] ; let n = a . length ; document . write ( findEvenPair ( a , n ) ) ;
function findevenPair ( A , N ) { let i , j ; let evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; } let a = [ 5 , 1 , 3 , 2 ] ; let n = a . length ; document . write ( findevenPair ( a , n ) ) ;
function findevenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; let oddCount = parseInt ( ( count * ( count - 1 ) ) / 2 ) ; return parseInt ( ( N * ( N - 1 ) ) / 2 ) - oddCount ; } let a = [ 5 , 1 , 3 , 2 ] ; let n = a . length ; document . write ( findevenPair ( a , n ) ) ;
function calculate ( X ) { let number_of_bits = 8 ; return ( ( 1 << number_of_bits ) - 1 ) ^ X ; } let X = 4 ; document . write ( " " + calculate ( X ) + " " ) ;
function ReplaceElements ( arr , n ) { let X = 0 ; for ( let i = 0 ; i < n ; ++ i ) { X ^= arr [ i ] ; } for ( let i = 0 ; i < n ; ++ i ) { arr [ i ] = X ^ arr [ i ] ; } } let arr = [ 2 , 3 , 3 , 5 , 5 ] ; let n = arr . length ; ReplaceElements ( arr , n ) ; for ( let i = 0 ; i < n ; ++ i ) { document . write ( arr [ i ] + " " ) ; }
function alternate ( a , b , x ) { return x = a ^ b ^ x ; } var a = - 10 ; var b = 15 ; var x = a ; document . write ( " " + x ) ; x = alternate ( a , b , x ) ; document . write ( " " ) ; document . write ( " " + x ) ;
function countZeros ( x ) { let y ; let n = 32 ; y = x >> 16 ; if ( y != 0 ) { n = n - 16 ; x = y ; } y = x >> 8 ; if ( y != 0 ) { n = n - 8 ; x = y ; } y = x >> 4 ; if ( y != 0 ) { n = n - 4 ; x = y ; } y = x >> 2 ; if ( y != 0 ) { n = n - 2 ; x = y ; } y = x >> 1 ; if ( y != 0 ) return n - 2 ; return n - x ; } let x = 101 ; document . write ( countZeros ( x ) ) ;
function LeadingZeros ( x , y ) { if ( ( x ^ y ) <= ( x & y ) ) document . write ( " " ) ; else if ( ( x & ( ~ y ) ) > y ) document . write ( y ) ; else document . write ( x ) ; } let x = 10 , y = 16 ; LeadingZeros ( x , y ) ;
function solve ( A , B ) { var count = 0 ; for ( i = 0 ; i < 32 ; i ++ ) { if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) { count ++ ; } } document . write ( " " + count ) ; } var A = 12 , B = 15 ; solve ( A , B ) ;
function setRightmostUnsetBit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; return n | ( n + 1 ) ; } let n = 21 ; document . write ( setRightmostUnsetBit ( n ) ) ;
function AND ( a , n ) { let ans = a [ 0 ] ; for ( let i = 0 ; i < n ; ++ i ) ans &= a [ i ] ; return ans ; } let a = [ 1 , 2 , 3 ] ; let n = a . length ; document . write ( AND ( a , n ) ) ;
function TwoscomplementbyXOR ( str ) { let n = str . length ; let check_bit = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' && check_bit == 0 ) { continue ; } else { if ( check_bit == 1 ) { if ( str . charAt ( i ) == ' ' ) str = str . substr ( 0 , i ) + ' ' + str . substr ( i + 1 ) ; else str = str . substr ( 0 , i ) + ' ' + str . substr ( i + 1 ) ; } check_bit = 1 ; } } if ( check_bit == 0 ) return " " + str ; else return str ; } let str = " " ; document . write ( TwoscomplementbyXOR ( str ) ) ;
function bitsAreInAltPatrnInGivenTRange ( n , l , r ) { var num , prev , curr ; num = n >> ( l - 1 ) ; prev = num & 1 ; num = num >> 1 ; for ( var i = 1 ; i <= ( r - l ) ; i ++ ) { curr = num & 1 ; if ( curr == prev ) return false ; prev = curr ; num = num >> 1 ; } return true ; } var n = 18 ; var l = 1 , r = 3 ; if ( bitsAreInAltPatrnInGivenTRange ( n , l , r ) ) document . write ( " " ) ; else document . write ( " " ) ;
function increment ( i ) { i = - ( ~ i ) ; return i ; } let n = 3 ; document . write ( increment ( n ) ) ;
function bit_count ( n ) { var count = 0 ; while ( n ) { count ++ ; n = n & ( n - 1 ) ; } return count ; } function maxsum ( arr , n ) { var bits = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { bits [ i ] = bit_count ( arr [ i ] ) ; } var sum = Array ( 32 ) . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) { sum [ bits [ i ] ] += arr [ i ] ; } var maximum = 0 ; for ( var i = 0 ; i < 32 ; i ++ ) { maximum = Math . max ( sum [ i ] , maximum ) ; } return maximum ; } var arr = [ 2 , 3 , 8 , 5 , 6 , 7 ] ; var n = arr . length ; document . write ( maxsum ( arr , n ) ) ;
function xorPairSum ( ar , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum = sum ^ ar [ i ] ; return 2 * sum ; } var arr = [ 1 , 2 , 3 ] ; var n = arr . length ; document . write ( xorPairSum ( arr , n ) ) ;
function findEvenPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ( ! ( ( A [ i ] & 1 ) > 0 ) ) ) count ++ ; return count * ( count - 1 ) / 2 ; } let A = [ 5 , 6 , 2 , 8 ] ; let N = A . length ; document . write ( findEvenPair ( A , N ) ) ;
function allBitsSetInTheGivenRange ( n , l , r ) { let num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; let new_num = n & num ; if ( new_num == 0 ) return true ; return false ; } let n = 17 ; let l = 2 , r = 4 ; if ( allBitsSetInTheGivenRange ( n , l , r ) ) document . write ( " " ) ; else document . write ( " " ) ;
function checkSame ( n ) { let set = 0 , unset = 0 ; while ( n ) { if ( n & 1 ) set ++ ; else unset ++ ; n = n >> 1 ; } if ( set == unset ) return true ; else return false ; } let n = 12 ; if ( checkSame ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function KthCharacter ( m , n , k ) { let distance = Math . pow ( 2 , n ) ; let Block_number = Math . floor ( k / distance ) ; let remaining = k % distance ; let s = new Array ( 32 ) . fill ( 0 ) ; let x = 0 ; for ( ; m > 0 ; x ++ ) { s [ x ] = m % 2 ; m = Math . floor ( m / 2 ) ; } let root = s [ x - 1 - Block_number ] ; if ( remaining == 0 ) { document . write ( root ) ; return ; } let flip = true ; while ( remaining > 1 ) { if ( ( remaining & 1 ) > 0 ) { flip = ! flip ; } remaining = remaining >> 1 ; } if ( flip ) { document . write ( ( root > 0 ) ? 0 : 1 ) ; } else { document . write ( root ) ; } } let m = 5 , k = 5 , n = 3 ; KthCharacter ( m , n , k ) ;
function onlyFirstAndLastAreSet ( n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) ; } var n = 9 ; if ( onlyFirstAndLastAreSet ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function getInteger ( L , R ) { var number = 0 ; for ( var i = L ; i <= R ; i ++ ) number += Math . pow ( 2 , i ) ; return number ; } var L = 2 , R = 5 ; document . write ( getInteger ( L , R ) ) ;
function setbitsfromLtoR ( L , R ) { return ( 1 << ( R + 1 ) ) - ( 1 << L ) ; } var L = 2 , R = 5 ; document . write ( setbitsfromLtoR ( L , R ) ) ;
function findXor ( arr , n ) { let xoR = 0 ; for ( let i = 0 ; i < n ; i ++ ) { xoR = xoR ^ arr [ i ] ; } return xoR * 2 ; } let arr = [ 1 , 5 , 6 ] ; let n = arr . length ; document . write ( findXor ( arr , n ) ) ;
function printOdds ( arr , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = res ^ arr [ i ] ; let set_bit = res & ( ~ ( res - 1 ) ) ; let x = 0 , y = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & set_bit ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } document . write ( x + " " + y ) ; } let arr = [ 2 , 3 , 3 , 4 , 4 , 5 ] ; let n = arr . length ; printOdds ( arr , n ) ;
function subsetBitwiseORk ( arr , n , k ) { var v = [ ] ; for ( var i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] k ) == k ) v . push ( arr [ i ] ) ; } var ans = 0 ; for ( var i = 0 ; i < v . length ; i ++ ) ans |= v [ i ] ; if ( ans != k ) { document . write ( " " ) ; return ; } for ( var i = 0 ; i < v . length ; i ++ ) document . write ( v [ i ] + ' ' ) ; } var k = 3 ; var arr = [ 1 , 4 , 2 ] ; var n = arr . length ; subsetBitwiseORk ( arr , n , k ) ;
function findEletobeInserted ( A , n , k ) { var ans = k ; for ( var i = 0 ; i < n ; i ++ ) ans ^= A [ i ] ; return ans ; } var A = [ 1 , 2 , 3 , 4 , 5 ] ; var n = A . length ; var k = 10 ; document . write ( findEletobeInserted ( A , n , k ) + " " + " " + " " + k ) ;
var BITS = 32 ; function andSum ( arr , n ) { var ans = 0 ; for ( i = 0 ; i < BITS ; i ++ ) { var countSetBits = 0 ; for ( j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) countSetBits ++ ; } var subset = ( 1 << countSetBits ) - 1 ; subset = ( subset * ( 1 << i ) ) ; ans += subset ; } return ans ; } var arr = [ 1 , 2 , 3 ] ; var size = 3 ; document . write ( andSum ( arr , size ) ) ;
function countSetBits ( n ) { var count = 0 ; while ( n ) { count += n & 1 ; n >>= 1 ; } return count ; } var i = 3 ; document . write ( countSetBits ( i ) ) ;
function isEven ( n ) { let isEven = true ; for ( let i = 1 ; i <= n ; i ++ ) isEven = ! isEven ; return isEven ; } let n = 101 ; if ( isEven ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function isEven ( n ) { return ( parseInt ( n / 2 , 10 ) * 2 == n ) ; } let n = 101 ; isEven ( n ) ? document . write ( " " ) : document . write ( " " ) ;
function add ( x , y ) { let keep = ( x & y ) << 1 ; let res = x ^ y ; if ( keep == 0 ) return res ; return add ( keep , res ) ; } document . write ( add ( 15 , 38 ) ) ;
function checkValidPair ( num1 , num2 ) { var s1 = num1 . toString ( ) ; var s2 = num2 . toString ( ) ; var i , j ; for ( i = 0 ; i < s1 . length ; i ++ ) for ( j = 0 ; j < s2 . length ; j ++ ) if ( s1 [ i ] == s2 [ j ] ) return true ; return false ; } function countPairs ( arr , n ) { var numberOfPairs = 0 ; for ( i = 0 ; i < n ; i ++ ) for ( j = i + 1 ; j < n ; j ++ ) if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) numberOfPairs ++ ; return numberOfPairs ; } var arr = [ 10 , 12 , 24 ] ; var n = arr . length ; ; document . write ( countPairs ( arr , n ) ) ;
var NUM_BITS = 32 ; function isPowerOf2 ( num ) { return ( num && ! ( num & ( num - 1 ) ) ) ; } function checkSubsequence ( arr , n ) { if ( n == 1 ) return isPowerOf2 ( arr [ 0 ] ) ; var total = 0 ; for ( var i = 0 ; i < NUM_BITS ; i ++ ) total = total | ( 1 << i ) ; for ( var i = 0 ; i < NUM_BITS ; i ++ ) { var ans = total ; for ( var j = 0 ; j < n ; j ++ ) { if ( arr [ j ] & ( 1 << i ) ) ans = ans & arr [ j ] ; } if ( isPowerOf2 ( ans ) ) return true ; } return false ; } var arr = [ 12 , 13 , 7 ] ; var n = arr . length ; if ( checkSubsequence ( arr , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findWinner ( A , n ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res ^= A [ i ] ; if ( res == 0 n % 2 == 0 ) return " " ; else return " " ; } let A = [ 1 , 4 , 3 , 5 ] ; let n = A . length ; document . write ( " " + findWinner ( A , n ) ) ;
function isFibbinaryNum ( n ) { if ( ( n & ( n >> 1 ) ) == 0 ) return true ; return false ; } let n = 10 ; if ( isFibbinaryNum ( n ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function maxXOR ( n , k ) { let c = ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; return ( ( 1 << c ) - 1 ) ; } let n = 12 ; let k = 3 ; document . write ( maxXOR ( n , k ) ) ;
function divide ( dividend , divisor ) { var sign = ( ( dividend < 0 ) ? 1 : 0 ^ ( divisor < 0 ) ? 1 : 0 ) ? - 1 : 1 ; dividend = Math . abs ( dividend ) ; divisor = Math . abs ( divisor ) ; var quotient = 0 , temp = 0 ; while ( dividend >= divisor ) { dividend -= divisor ; ++ quotient ; } if ( sign == - 1 ) quotient = - quotient ; return quotient ; } var a = 10 , b = 3 ; document . write ( divide ( a , b ) + " " ) ; var a1 = 43 , b1 = - 8 ; document . write ( divide ( a1 , b1 ) + " " ) ;
function count ( n ) { let c = 0 ; while ( n != 0 ) { c ++ ; n = n >> 1 ; } return c ; } function XOR ( a , b ) { let c = Math . min ( a , b ) ; let d = Math . max ( a , b ) ; if ( count ( c ) < count ( d ) ) c = c << ( count ( d ) - count ( c ) ) ; return ( c ^ d ) ; } let a = 13 , b = 5 ; document . write ( XOR ( a , b ) ) ;
function swapBitsInPair ( x ) { return ( ( x & 0b10101010 ) >> 1 ) | ( ( x & 0b01010101 ) << 1 ) ; } let x = 4 ; document . write ( swapBitsInPair ( x ) ) ;
function setevenbits ( n ) { var temp = n ; var count = 0 ; var res = 0 ; for ( temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return ( n & res ) ; } function setoddbits ( m ) { var count = 0 ; var res = 0 ; for ( temp = m ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return ( m & res ) ; } function getAlternateBits ( n , m ) { var tempn = setevenbits ( n ) ; var tempm = setoddbits ( m ) ; return ( tempn tempm ) ; } var n = 10 ; var m = 11 ; document . write ( getAlternateBits ( n , m ) ) ;
function isDivisibleBy10 ( bin , n ) { if ( bin [ n - 1 ] == ' ' ) return false ; var sum = 0 ; for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( bin [ i ] == ' ' ) { var posFromRight = n - i - 1 ; if ( posFromRight % 4 == 1 ) sum = sum + 2 ; else if ( posFromRight % 4 == 2 ) sum = sum + 4 ; else if ( posFromRight % 4 == 3 ) sum = sum + 8 ; else if ( posFromRight % 4 == 0 ) sum = sum + 6 ; } } if ( sum % 10 == 0 ) return true ; return false ; } function isDivisibleBy20 ( bin , n ) { if ( bin [ n - 1 ] == ' ' ) return false ; return isDivisibleBy10 ( bin , n - 1 ) ; } var bin = " " ; var n = bin . length ; if ( isDivisibleBy20 ( bin , n - 1 ) ) document . write ( " " ) ; else document . write ( " " ) ;
function toggleBits ( n1 , n2 ) { return ( n1 ^ n2 ) ; } let n1 = 2 , n2 = 5 ; document . write ( toggleBits ( n1 , n2 ) ) ;
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 1 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; } let n = 11 ; document . write ( evenbittogglenumber ( n ) ) ;
function takeLandFsetbits ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return ( ( n + 1 ) >> 1 ) + 1 ; } function toggleFandLbits ( n ) { if ( n == 1 ) return 0 ; return n ^ takeLandFsetbits ( n ) ; } let n = 10 ; document . write ( toggleFandLbits ( n ) ) ;
function countSetBits ( n ) { let count = 0 ; while ( n != 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } function checkOdious ( n ) { return ( countSetBits ( n ) % 2 == 1 ) ; } let num = 32 ; if ( checkOdious ( num ) ) document . write ( " " ) ; else document . write ( " " ) ;
function setleftmostunsetbit ( n ) { if ( ( n & ( n + 1 ) ) == 0 ) return n ; let pos = 0 ; for ( let temp = n , count = 0 ; temp > 0 ; temp >>= 1 , count ++ ) if ( ( temp & 1 ) == 0 ) pos = count ; return ( n | ( 1 << ( pos ) ) ) ; } let n = 10 ; document . write ( setleftmostunsetbit ( n ) ) ;
function maxXorSum ( n , k ) { if ( k == 1 ) return n ; let res = 1 ; while ( res <= n ) res <<= 1 ; return res - 1 ; } let n = 4 , k = 3 ; document . write ( maxXorSum ( n , k ) ) ;
function getPosOfRightmostSetBit ( n ) { return ( Math . log ( n & - n ) / Math . log ( 2 ) ) ; } function toggleLastKBits ( n , k ) { let num = ( 1 << k ) - 1 ; return ( n ^ num ) ; } function incrementByOne ( n ) { let k = getPosOfRightmostSetBit ( ~ n ) ; n = ( ( 1 << k ) n ) ; if ( k != 0 ) n = toggleLastKBits ( n , k ) ; return n ; } let n = 15 ; document . write ( incrementByOne ( n ) ) ;
function xnor ( a , b ) { if ( a < b ) { let t = a ; a = b ; b = t ; } if ( a == 0 && b == 0 ) return 1 ; let a_rem = 0 ; let b_rem = 0 ; let count = 0 ; let xnornum = 0 ; while ( true ) { a_rem = a & 1 ; b_rem = b & 1 ; if ( a_rem == b_rem ) xnornum |= ( 1 << count ) ; count ++ ; a = a >> 1 ; b = b >> 1 ; if ( a < 1 ) break ; } return xnornum ; } let a = 10 , b = 50 ; document . write ( xnor ( a , b ) ) ;
function togglebit ( n ) { if ( n == 0 ) return 1 ; let i = n ; n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return i ^ n ; } function XNOR ( num1 , num2 ) { if ( num1 < num2 ) { let temp = num1 ; num1 = num2 ; num2 = temp ; } num1 = togglebit ( num1 ) ; return num1 ^ num2 ; } let num1 = 10 , num2 = 20 ; document . write ( XNOR ( num1 , num2 ) ) ;
function MaximumSum ( a , b , n ) { let sum1 = 0 , sum2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum1 |= a [ i ] ; sum2 |= b [ i ] ; } document . write ( sum1 + sum2 ) ; } let A = [ 1 , 2 , 4 , 3 , 2 ] ; let B = [ 2 , 3 , 3 , 12 , 1 ] ; let n = A . length ; MaximumSum ( A , B , n ) ;
function isPowerOfTwo ( x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } function differAtOneBitPos ( a , b ) { return isPowerOfTwo ( a ^ b ) ; } let a = 13 , b = 9 ; if ( differAtOneBitPos ( a , b ) == true ) document . write ( " " ) ; else document . write ( " " ) ;
function power2 ( n ) { if ( n == 0 ) return 1 ; if ( n == 1 ) return 2 ; return power2 ( n / 2 ) * power2 ( n / 2 ) ; } function multiply ( x , n ) { return x * power2 ( n ) ; } let x = 70 let n = 2 ; document . write ( multiply ( x , n ) ) ;
function multiply ( x , n ) { return x << n ; } let x = 70 ; let n = 2 ; document . write ( multiply ( x , n ) ) ;
function isDivBy2PowerM ( n , m ) { if ( ( n & ( ( 1 << m ) - 1 ) ) == 0 ) return true ; return false ; } let n = 8 , m = 2 ; if ( isDivBy2PowerM ( n , m ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findWinner ( N ) { return N & 1 ; } let N = 15 ; if ( findWinner ( N ) == 1 ) document . write ( " " ) ; else document . write ( " " ) ;
function evenbittogglenumber ( n ) { let res = 0 , count = 0 ; for ( let temp = n ; temp > 0 ; temp >>= 1 ) { if ( count % 2 == 0 ) res |= ( 1 << count ) ; count ++ ; } return n ^ res ; } let n = 11 ; document . write ( evenbittogglenumber ( n ) ) ;
function divide ( n , m ) { document . write ( " " + ( ( n ) & ( m - 1 ) ) + " " ) ; document . write ( " " + ( n >> ( Math . log ( m ) / Math . log ( 2 ) ) ) ) ; } let n = 43 , m = 8 ; divide ( n , m ) ;
function maxAND ( arr , n ) { var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i + 1 ; j < n ; j ++ ) res = Math . max ( res , arr [ i ] & arr [ j ] ) ; return res ; } var arr = [ 4 , 8 , 6 , 2 ] ; var n = arr . length ; document . write ( " " + maxAND ( arr , n ) ) ;
function index ( i ) { return 1 + ( i >> 31 ) - ( - i >> 31 ) ; } function check ( n ) { let s = [ " " , " " , " " ] ; let val = index ( n ) ; document . write ( n + " " + s [ val ] + " " ) ; } check ( 30 ) ; check ( - 20 ) ; check ( 0 ) ;
function checking ( s ) { let c = 0 ; let n = s . length ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' ) c ++ ; if ( c >= 6 && s [ i ] == ' ' ) return true ; } return false ; } let s = " " ; if ( checking ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function modifyBit ( n , p , b ) { let mask = 1 << p ; return ( n & ~ mask ) | ( ( b << p ) & mask ) ; } document . write ( modifyBit ( 6 , 2 , 0 ) + " " ) ; document . write ( modifyBit ( 6 , 5 , 1 ) ) ;
function countSetBits ( n ) { let count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } function countSetBitsInGivenRange ( n , l , r ) { let num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return countSetBits ( n & num ) ; } let n = 42 ; let l = 2 , r = 5 ; document . write ( countSetBitsInGivenRange ( n , l , r ) ) ;
function areAllBitsSet ( n ) { if ( n == 0 ) return false ; if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } function isOnesComplementOfOther ( a , b ) { return areAllBitsSet ( a ^ b ) ; } let a = 10 , b = 5 ; if ( isOnesComplementOfOther ( a , b ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findUnique ( a , n , k ) { let sizeof_let = 4 ; let LET_SIZE = 8 * sizeof_let ; let count = Array . from ( { length : LET_SIZE } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) for ( let j = 0 ; j < n ; j ++ ) if ( ( a [ j ] & ( 1 << i ) ) != 0 ) count [ i ] += 1 ; let res = 0 ; for ( let i = 0 ; i < LET_SIZE ; i ++ ) res += ( count [ i ] % k ) * ( 1 << i ) ; return res ; } let a = [ 6 , 2 , 5 , 2 , 2 , 6 , 6 ] ; let n = a . length ; let k = 3 ; document . write ( findUnique ( a , n , k ) ) ;
function powerOfTwo ( n ) { return ( ! ( n & n - 1 ) ) ; } function onlyFirstAndLastAreSet ( n ) { if ( n == 1 ) return true ; if ( n == 2 ) return false ; return powerOfTwo ( n - 1 ) ; } var n = 9 ; if ( onlyFirstAndLastAreSet ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function allBitsAreSet ( n ) { if ( ( ( n + 1 ) & n ) == 0 ) return true ; return false ; } function bitsAreInAltOrder ( n ) { let num = n ^ ( n >>> 1 ) ; return allBitsAreSet ( num ) ; } let n = 10 ; if ( bitsAreInAltOrder ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function setBit ( xorValue ) { var count = 0 ; while ( xorValue ) { if ( xorValue % 2 ) count ++ ; xorValue = parseInt ( xorValue / 2 ) ; } return count ; } function minFlip ( n , k ) { var size = Math . log2 ( n ) + 1 ; var max = Math . pow ( 2 , k ) - 1 ; max = ( max << ( size - k ) ) ; var xorValue = ( n ^ max ) ; return ( setBit ( xorValue ) ) ; } var n = 27 , k = 3 ; document . write ( " " + minFlip ( n , k ) ) ;
function setallbitgivenrange ( n , l , r ) { let range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) ; return ( n range ) ; } let n = 17 , l = 2 , r = 3 ; document . write ( setallbitgivenrange ( n , l , r ) ) ;
function countBits ( number ) { return Math . floor ( Math . log2 ( number ) + 1 ) ; } let num = 65 ; document . write ( countBits ( num ) ) ;
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( new_num == 0 ) return " " ; return " " ; } var n = 17 ; var l = 2 , r = 4 ; document . write ( allBitsSetInTheGivenRange ( n , l , r ) ) ;
function setAllBitsAfterMSB ( n ) { n |= n >> 1 ; n |= n >> 2 ; n |= n >> 4 ; n |= n >> 8 ; n |= n >> 16 ; return n ; } function toggle ( n ) { n = n ^ setAllBitsAfterMSB ( n ) ; return n ; } let n = 10 ; document . write ( toggle ( n ) ) ;
function getRightMostSetBit ( n ) { return Math . log2 ( n & - n ) + 1 ; } function posOfRightMostSameBit ( m , n ) { return getRightMostSetBit ( ~ ( m ^ n ) ) ; } let m = 16 , n = 7 ; document . write ( " " + posOfRightMostSameBit ( m , n ) ) ;
function allBitsSetInTheGivenRange ( n , l , r ) { var num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; var new_num = n & num ; if ( num == new_num ) return " " ; return " " ; } var n = 22 ; var l = 2 , r = 3 ; document . write ( allBitsSetInTheGivenRange ( n , l , r ) ) ;
function printNonConsecutive ( n ) { let p = ( 1 << n ) ; for ( let i = 1 ; i < p ; i ++ ) if ( ( i & ( i << 1 ) ) == 0 ) document . write ( i + " " ) ; } let n = 3 ; printNonConsecutive ( n ) ;
var INT_SIZE = 32 ; function constructNthNumber ( group_no , aux_num , op ) { var a = Array . from ( { length : INT_SIZE } , ( _ , i ) => 0 ) ; var num = 0 , len_f = 0 ; var i = 0 ; if ( op == 2 ) { len_f = 2 * group_no ; a [ len_f - 1 ] = a [ 0 ] = 1 ; while ( aux_num > 0 ) { a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else if ( op == 0 ) { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 0 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } else { len_f = 2 * group_no + 1 ; a [ len_f - 1 ] = a [ 0 ] = 1 ; a [ group_no ] = 1 ; while ( aux_num > 0 ) { a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 ; aux_num = aux_num >> 1 ; i ++ ; } } for ( i = 0 ; i < len_f ; i ++ ) num += ( 1 << i ) * a [ i ] ; return num ; } function getNthNumber ( n ) { var group_no = 0 , group_offset ; var count_upto_group = 0 , count_temp = 1 ; var op , aux_num ; while ( count_temp < n ) { group_no ++ ; count_upto_group = count_temp ; count_temp += 3 * ( 1 << ( group_no - 1 ) ) ; } group_offset = n - count_upto_group - 1 ; if ( ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) ) { op = 2 ; aux_num = group_offset ; } else { if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 == 1 ) op = 0 ; else op = 1 ; aux_num = ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) / 2 ; } return constructNthNumber ( group_no , aux_num , op ) ; } var n = 9 ; document . write ( getNthNumber ( n ) ) ;
function countSetBits ( n ) { let count = 0 ; while ( n ) { n &= ( n - 1 ) ; count ++ ; } return count ; } function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) if ( countSetBits ( i ) == 2 ) sum += i ; return sum ; } let n = 10 ; document . write ( findSum ( n ) ) ;
function toggleLastMBits ( n , m ) { var num = ( 1 << m ) - 1 ; return ( n ^ num ) ; } var n = 107 ; var m = 4 ; document . write ( toggleLastMBits ( n , m ) ) ;
function getFirstSetBitPos ( n ) { return parseInt ( Math . log ( n & - n ) / Math . log ( 2 ) ) + 1 ; } function previousSmallerInteger ( n ) { var pos = getFirstSetBitPos ( n ) ; return ( n & ~ ( 1 << ( pos - 1 ) ) ) ; } var n = 25 ; document . write ( " " + previousSmallerInteger ( n ) ) ;
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " " ; n = n >> 1 ; } return " " ; } var n = 7 ; document . write ( areAllBitsSet ( n ) ) ;
function areAllBitsSet ( n ) { if ( n == 0 ) return " " ; if ( ( ( n + 1 ) & n ) == 0 ) return " " ; return " " ; } var n = 7 ; document . write ( areAllBitsSet ( n ) ) ;
function getFirstSetBitPos ( n ) { return ( parseInt ( Math . log ( n & - n ) / Math . log ( 2 ) ) + 1 ) - 1 ; } function nextGreaterWithOneMoreSetBit ( n ) { var pos = getFirstSetBitPos ( ~ n ) ; if ( pos > - 1 ) return ( 1 << pos ) | n ; return ( ( n << 1 ) + 1 ) ; } var n = 10 ; document . write ( " " + nextGreaterWithOneMoreSetBit ( n ) ) ;
function CountZeroBit ( x ) { let count = 0 ; while ( x > 0 ) { if ( ( x & 1 ) == 0 ) count ++ ; x >>= 1 ; } return count ; } function CountXORandSumEqual ( x ) { let count = CountZeroBit ( x ) ; return ( 1 << count ) ; } let x = 10 ; document . write ( CountXORandSumEqual ( x ) ) ;
function missingNumber ( arr1 , arr2 , n ) { let mnum = 0 ; for ( let i = 0 ; i < n ; i ++ ) mnum = mnum ^ arr1 [ i ] ; for ( let i = 0 ; i < n - 1 ; i ++ ) mnum = mnum ^ arr2 [ i ] ; return mnum ; } let arr1 = [ 4 , 8 , 1 , 3 , 7 ] ; let arr2 = [ 7 , 4 , 3 , 1 ] ; let n = arr1 . length ; document . write ( " " + missingNumber ( arr1 , arr2 , n ) ) ;
function countValues ( x ) { var count = 0 , n = 1 ; while ( x != 0 ) { if ( x % 2 == 0 ) count += n ; n *= 2 ; x = parseInt ( x / 2 ) ; } return count ; } var x = 10 ; document . write ( countValues ( x ) ) ;
function constructXOR ( A , n ) { let XOR = 0 ; for ( let i = 0 ; i < n ; i ++ ) XOR ^= A [ i ] ; for ( let i = 0 ; i < n ; i ++ ) A [ i ] = XOR ^ A [ i ] ; } let A = [ 2 , 4 , 1 , 3 , 5 ] ; let n = A . length ; constructXOR ( A , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( A [ i ] + " " ) ;
function bitCount ( n ) { let count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) > 0 ) ++ count ; n >>= 1 ; } return count ; } function countPairsWithKDiff ( arr , n , k ) { for ( let i = 0 ; i < n - 1 ; ++ i ) { for ( let j = i + 1 ; j < n ; ++ j ) { let xoredNum = arr [ i ] ^ arr [ j ] ; if ( k == bitCount ( xoredNum ) ) ++ ans ; } } return ans ; } let k = 2 ; let arr = [ 2 , 4 , 1 , 3 , 1 ] ; let n = arr . length ; document . write ( " " + k + " " + countPairsWithKDiff ( arr , n , k ) + " " ) ;
function multiply ( n , m ) { let ans = 0 , count = 0 ; while ( m ) { if ( m % 2 == 1 ) ans += n << count ; count ++ ; m = Math . floor ( m / 2 ) ; } return ans ; } let n = 20 , m = 13 ; document . write ( multiply ( n , m ) ) ;
function EqualNumber ( A , B ) { return ( A ^ B ) ; } let A = 5 , B = 6 ; if ( ! EqualNumber ( A , B ) == false ) document . write ( " " ) ; else document . write ( " " ) ;
function areSetBitsIncreasing ( n ) { var prev_count = Number . MAX_VALUE ; while ( n > 0 ) { while ( n > 0 && n % 2 == 0 ) n = parseInt ( n / 2 ) ; var curr_count = 1 ; while ( n > 0 && n % 2 == 1 ) { n = n / 2 ; curr_count ++ ; } if ( curr_count >= prev_count ) return false ; prev_count = curr_count ; } return true ; } var n = 10 ; if ( areSetBitsIncreasing ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function findPattern ( n ) { let prev = n % 2 ; n = Math . floor ( n / 2 ) ; while ( n > 0 ) { let curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = Math . floor ( n / 2 ) ; } return true ; } let n = 10 ; if ( findPattern ( n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countXOR ( n ) { let count0 = 0 , count1 = 0 ; while ( n != 0 ) { if ( n % 2 == 0 ) count0 ++ ; else count1 ++ ; n = Math . floor ( n / 2 ) ; } return ( count0 ^ count1 ) ; } let n = 31 ; document . write ( countXOR ( n ) ) ;
function msbPos ( n ) { let msb_p = - 1 ; while ( n > 0 ) { n = n >> 1 ; msb_p ++ ; } return msb_p ; } function andOperator ( x , y ) { while ( x > 0 && y > 0 ) { let msb_p1 = msbPos ( x ) ; let msb_p2 = msbPos ( y ) ; if ( msb_p1 != msb_p2 ) break ; let msb_val = ( 1 << msb_p1 ) ; res = res + msb_val ; x = x - msb_val ; y = y - msb_val ; } return res ; } let x = 10 , y = 15 ; document . write ( andOperator ( x , y ) ) ;
function multiplyTen ( n ) { return ( n << 1 ) + ( n << 3 ) ; } let n = 50 ; document . write ( multiplyTen ( n ) ) ;
function countValues ( n ) { let countV = 0 ; for ( let i = 0 ; i <= n ; i ++ ) if ( ( n + i ) == ( n ^ i ) ) countV ++ ; return countV ; } let n = 12 ; document . write ( countValues ( n ) ) ;
function countValues ( n ) { let unset_bits = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) unset_bits ++ ; n = n >> 1 ; } return 1 << unset_bits ; } let n = 12 ; document . write ( countValues ( n ) ) ;
function findProffesion ( level , pos ) { if ( level == 1 ) return ' ' ; if ( findProffesion ( level - 1 , ( pos + 1 ) / 2 ) == ' ' ) return ( pos % 2 > 0 ) ? ' ' : ' ' ; return ( pos % 2 > 0 ) ? ' ' : ' ' ; } let level = 4 , pos = 2 ; if ( findProffesion ( level , pos ) == ' ' ) document . write ( " " ) ; else document . write ( " " ) ;
function printTwoSetBitNums ( n ) { let x = 1 ; while ( n > 0 ) { let y = 0 ; while ( y < x ) { document . write ( ( 1 << x ) + ( 1 << y ) + " " ) ; n -- ; if ( n == 0 ) return ; y ++ ; } x ++ ; } } printTwoSetBitNums ( 4 ) ;
function rand50 ( ) { return Math . floor ( Math . random ( ) * 10 ) & 1 ; } function rand75 ( ) { return rand50 ( ) | rand50 ( ) ; } for ( let i = 0 ; i < 50 ; i ++ ) document . write ( rand75 ( ) ) ;
function printRepeatingEven ( arr , n ) { let _xor = 0 ; let pos ; for ( let i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; _xor ^= pos ; } for ( let i = 0 ; i < n ; ++ i ) { pos = 1 << arr [ i ] ; if ( ! ( ( pos & _xor ) != 0 ) ) { document . write ( arr [ i ] + " " ) ; _xor ^= pos ; } } } let arr = [ 9 , 12 , 23 , 10 , 12 , 12 , 15 , 23 , 14 , 12 , 15 ] ; let n = arr . length ; printRepeatingEven ( arr , n ) ;
function countSetBits ( x ) { let count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; } function isBleak ( n ) { for ( let x = 1 ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; } if ( isBleak ( 3 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ; if ( isBleak ( 4 ) ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
let INT_BITS = 32 ; function maxSubarrayXOR ( set , n ) { let index = 0 ; for ( let i = INT_BITS - 1 ; i >= 0 ; i -- ) { let maxInd = index ; let maxEle = Number . MIN_VALUE ; for ( let j = index ; j < n ; j ++ ) { if ( ( set [ j ] & ( 1 << i ) ) != 0 && set [ j ] > maxEle ) { maxEle = set [ j ] ; maxInd = j ; } } if ( maxEle == Number . MIN_VALUE ) continue ; let temp = set [ index ] ; set [ index ] = set [ maxInd ] ; set [ maxInd ] = temp ; maxInd = index ; for ( let j = 0 ; j < n ; j ++ ) { if ( j != maxInd && ( set [ j ] & ( 1 << i ) ) != 0 ) set [ j ] = set [ j ] ^ set [ maxInd ] ; } index ++ ; } let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res ^= set [ i ] ; return res ; } let set = [ 9 , 8 , 5 ] ; let n = set . length ; document . write ( " " ) ; document . write ( maxSubarrayXOR ( set , n ) ) ;
function findXOR ( Set , n ) { if ( n == 1 ) return Set [ 0 ] ; else return 0 ; } let Set = [ 1 , 2 , 3 ] ; let n = Set . length ; document . write ( " " + findXOR ( Set , n ) ) ;
function myXOR ( x , y ) { return ( x y ) & ( ~ x ~ y ) ; } let x = 3 , y = 5 ; document . write ( " " + myXOR ( x , y ) ) ;
let N = 2 ; function freivald ( a , b , c ) { let r = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) r [ i ] = Math . random ( ) % 2 ; let br = new Array ( N ) ; br . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) br [ i ] = br [ i ] + b [ i ] [ j ] * r [ j ] ; let cr = new Array ( N ) ; cr . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) cr [ i ] = cr [ i ] + c [ i ] [ j ] * r [ j ] ; let axbr = new Array ( N ) ; axbr . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < N ; j ++ ) axbr [ i ] = axbr [ i ] + a [ i ] [ j ] * br [ j ] ; for ( let i = 0 ; i < N ; i ++ ) if ( axbr [ i ] - cr [ i ] != 0 ) false ; return true ; } function isProduct ( a , b , c , k ) { for ( let i = 0 ; i < k ; i ++ ) if ( freivald ( a , b , c ) == false ) return false ; return true ; } let a = [ [ 1 , 1 ] , [ 1 , 1 ] ] ; let b = [ [ 1 , 1 ] , [ 1 , 1 ] ] ; let c = [ [ 2 , 2 ] , [ 2 , 2 ] ] ; let k = 2 ; if ( isProduct ( a , b , c , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
function calc_Expectation ( a , n ) { let prb = ( 1 / n ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += a [ i ] * prb ; return sum ; } let expect , n = 6 ; let a = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; expect = calc_Expectation ( a , n ) ; document . write ( " " + expect ) ;
function findPoints ( l1 , r1 , l2 , r2 ) { var x = ( l1 != l2 ) ? Math . min ( l1 , l2 ) : - 1 ; var y = ( r1 != r2 ) ? Math . max ( r1 , r2 ) : - 1 ; document . write ( x + " " + y ) ; } var l1 = 5 , r1 = 10 , l2 = 1 , r2 = 7 ; findPoints ( l1 , r1 , l2 , r2 ) ;
function fact ( n ) { if ( n == 0 ) return 1 ; return n * fact ( n - 1 ) ; } document . write ( fact ( 5 ) ) ;
function printElements ( a , n ) { a = a . sort ( compare ) ; a = reverse ( a ) ; var cnt = 1 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] != a [ i + 1 ] ) { document . write ( a [ i ] + " " + cnt + " " + " " ) ; cnt = 1 ; } else cnt += 1 ; } document . write ( a [ n - 1 ] + " " + cnt + " " + " " ) ; } function reverse ( a ) { var i , n = a . length , t ; for ( i = 0 ; i < n / 2 ; i ++ ) { t = a [ i ] ; a [ i ] = a [ n - i - 1 ] ; a [ n - i - 1 ] = t ; } return a ; } function compare ( a , b ) { if ( a < b ) { return - 1 ; } else if ( a > b ) { return 1 ; } else { return 0 ; } } var a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 ] ; var n = a . length ; printElements ( a , n ) ;
const SMALL_N = 1000000 ; const LARGE_N = 1000000000000000 ; function func ( a , b , c , n ) { let res = a * n ; let logVlaue = Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ; res += b * n * logVlaue ; res += c * ( n * n * n ) ; return res ; } function getPositionInSeries ( a , b , c , k ) { let start = 1 , end = SMALL_N ; if ( c == 0 ) { end = LARGE_N ; } let ans = 0 ; while ( start <= end ) { let mid = parseInt ( ( start + end ) / 2 ) ; let val = func ( a , b , c , mid ) ; if ( val == k ) { ans = mid ; break ; } else if ( val > k ) { end = mid - 1 ; } else { start = mid + 1 ; } } return ans ; } let a = 2 , b = 1 , c = 1 ; let k = 12168587437017 ; document . write ( getPositionInSeries ( a , b , c , k ) ) ;
function checkIndices ( Arr , N ) { for ( var i = 0 ; i < N - 1 ; i ++ ) { for ( var j = i + 1 ; j < N ; j ++ ) { if ( Arr [ i ] != Arr [ j ] ) { if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) return true ; } } } return false ; } var Arr = [ 3 , 2 , 1 , 1 , 4 ] ; var N = Arr . length ; checkIndices ( Arr , N ) ? document . write ( " " ) : document . write ( " " ) ;
function printPairs ( arr , n , sum ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( arr [ i ] + arr [ j ] == sum ) document . write ( " " + arr [ i ] + " " + arr [ j ] + " " + " " ) ; } let arr = [ 1 , 5 , 7 , - 1 , 5 ] ; let n = arr . length ; let sum = 6 ; printPairs ( arr , n , sum ) ;
function minSum ( arr , n ) { let sum = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] == arr [ i - 1 ] ) { let j = i ; while ( j < n && arr [ j ] <= arr [ j - 1 ] ) { arr [ j ] = arr [ j ] + 1 ; j ++ ; } } sum = sum + arr [ i ] ; } return sum ; } let arr = [ 2 , 2 , 3 , 5 , 6 ] ; let n = arr . length ; document . write ( minSum ( arr , n ) ) ;
function minSum ( arr , n ) { let sum = arr [ 0 ] , prev = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] <= prev ) { prev = prev + 1 ; sum = sum + prev ; } else { sum = sum + arr [ i ] ; prev = arr [ i ] ; } } return sum ; } let arr = [ 2 , 2 , 3 , 5 , 6 ] ; let n = arr . length ; document . write ( minSum ( arr , n ) ) ;
let MAX = 26 ; function functions ( str ) { let l = str . length ; let counter1 = [ ] ; let counter2 = [ ] ; for ( let i = 0 ; i < MAX ; i ++ ) { counter1 [ i ] = 0 ; counter2 [ i ] = 0 ; } for ( let i = 0 ; i < l / 2 ; i ++ ) counter1 [ str [ i ] - ' ' ] ++ ; for ( let i = l / 2 ; i < l ; i ++ ) counter2 [ str [ i ] - ' ' ] ++ ; for ( let i = 0 ; i < MAX ; i ++ ) { if ( counter2 [ i ] != counter1 [ i ] ) return true ; } return false ; } let str = " " ; if ( functions ( str ) != 1 ) document . write ( " " + " " ) ; else document . write ( " " + " " ) ;
function minDifferenceAmongMaxMin ( arr , N , K ) { arr . sort ( ( a , b ) => a - b ) ; let res = 2147483647 ; for ( let i = 0 ; i <= ( N - K ) ; i ++ ) { let curSeqDiff = arr [ i + K - 1 ] - arr [ i ] ; res = Math . min ( res , curSeqDiff ) ; } return res ; } let arr = [ 10 , 20 , 30 , 100 , 101 , 102 ] ; let N = arr . length ; let K = 3 ; document . write ( minDifferenceAmongMaxMin ( arr , N , K ) ) ;
function getIndexInSortedArray ( arr , n , idx ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ idx ] ) result ++ ; if ( arr [ i ] == arr [ idx ] && i < idx ) result ++ ; } return result ; } let arr = [ 3 , 4 , 3 , 5 , 2 , 3 , 4 , 3 , 1 , 5 ] ; let n = arr . length ; let idxOfEle = 5 ; document . write ( getIndexInSortedArray ( arr , n , idxOfEle ) ) ;
function getMaxValue ( arr , arr_size ) { let i , first , second ; if ( arr_size < 2 ) { return 0 ; } first = second = Number . MIN_VALUE ; for ( i = 0 ; i < arr_size ; i ++ ) { if ( arr [ i ] > first ) { second = first ; first = arr [ i ] ; } else if ( arr [ i ] > second && arr [ i ] != first ) { second = arr [ i ] ; } } if ( second == Number . MIN_VALUE ) { return 0 ; } else { return second ; } } let arr = [ 4 , 5 , 1 , 8 ] ; let n = arr . length ; document . write ( getMaxValue ( arr , n ) ) ;
function maximumResult ( a , b , c ) { let countOfNegative = 0 ; let sum = a + b + c ; let product = a * b * c ; let largest = Math . max ( a , Math . max ( b , c ) ) ; let smallest = Math . min ( a , Math . min ( b , c ) ) ; if ( a < 0 ) countOfNegative ++ ; if ( b < 0 ) countOfNegative ++ ; if ( c < 0 ) countOfNegative ++ ; switch ( countOfNegative ) { case 0 : return ( sum - largest ) * largest ; case 1 : return ( product / smallest ) + smallest ; case 2 : return ( product / largest ) + largest ; case 3 : return ( sum - smallest ) * smallest ; } } let a = - 2 , b = - 1 , c = - 4 ; document . write ( maximumResult ( a , b , c ) ) ;
function check ( n , marks ) { let x = Math . max ( ... marks ) ; let bonus = 100 - x ; let c = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( marks [ i ] + bonus >= 50 ) c += 1 ; } return c ; } let n = 5 ; let marks = [ 0 , 21 , 83 , 45 , 64 ] ; document . write ( check ( n , marks ) ) ;
function find_sum ( n , k ) { let total_sum = ( n * ( n + 1 ) ) / 2 ; let power = k ; while ( power <= n ) { total_sum -= power ; power *= k ; } return total_sum ; } let n = 11 , k = 2 ; document . write ( find_sum ( n , k ) ) ;
var MAX = 10000 ; var hashTable = Array ( MAX ) . fill ( 0 ) ; function minOperations ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; for ( var i = 0 ; i < n ; i ++ ) hashTable [ arr [ i ] ] ++ ; var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( hashTable [ arr [ i ] ] ) { for ( var j = i ; j < n ; j ++ ) if ( arr [ j ] % arr [ i ] == 0 ) hashTable [ arr [ j ] ] = 0 ; res ++ ; } } return res ; } var arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ] ; var n = arr . length ; document . write ( minOperations ( arr , n ) ) ;
function ifPossible ( arr , n ) { let copy = arr ; copy . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! ( arr [ i ] == copy [ i ] ) && ! ( arr [ n - 1 - i ] == copy [ i ] ) ) return false ; } return true ; } let arr = [ 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 ] ; let n = arr . length ; if ( ifPossible ( arr , n ) ) document . write ( " " ) ; else document . write ( " " ) ; ;
function FindMinimumCost ( ind , a , n , k , dp ) { if ( ind == ( n - 1 ) ) return 0 ; else if ( dp [ ind ] != - 1 ) return dp [ ind ] ; else { var ans = Number . MAX_VALUE ; for ( var i = 1 ; i <= k ; i ++ ) { if ( ind + i < n ) ans = Math . min ( ans , Math . abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) ; else break ; } return dp [ ind ] = ans ; } } var a = [ 10 , 30 , 40 , 50 , 20 ] ; var k = 3 ; var n = a . length ; var dp = Array ( n ) . fill ( - 1 ) ; document . write ( FindMinimumCost ( 0 , a , n , k , dp ) ) ;
var MAX = 100000 ; prefix = Array ( MAX ) . fill ( 0 ) ; function sieve_modified ( ) { for ( var i = 2 ; i < MAX ; i += 2 ) { for ( var j = i ; j < MAX ; j += i ) prefix [ j ] += i ; } for ( var i = 1 ; i < MAX ; i ++ ) prefix [ i ] += prefix [ i - 1 ] ; } function sumEvenFactors ( L , R ) { return ( prefix [ R ] - prefix [ L - 1 ] ) ; } sieve_modified ( ) ; var l = 6 , r = 10 ; document . write ( sumEvenFactors ( l , r ) ) ;
let N = 1000 ; function find ( index , openbrk , n , dp , adj ) { if ( openbrk < 0 ) { return 0 ; } if ( index == n ) { if ( openbrk == 0 ) { return 1 ; } else { return 0 ; } } if ( dp [ index ] [ openbrk ] != - 1 ) { return dp [ index ] [ openbrk ] ; } if ( adj [ index ] == 1 ) { dp [ index ] [ openbrk ] = find ( index + 1 , openbrk + 1 , n , dp , adj ) ; } else { dp [ index ] [ openbrk ] = find ( index + 1 , openbrk + 1 , n , dp , adj ) + find ( index + 1 , openbrk - 1 , n , dp , adj ) ; } return dp [ index ] [ openbrk ] ; } let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } let n = 2 ; let adj = [ 1 , 0 , 0 , 0 ] ; document . write ( find ( 0 , 0 , 2 * n , dp , adj ) ) ;
let ans = 0 ; function findMaxValUtil ( arr , n , num , maxLimit , ind ) { if ( ind == n ) { ans = Math . max ( ans , num ) ; return ; } if ( num - arr [ ind ] >= 0 ) { findMaxValUtil ( arr , n , num - arr [ ind ] , maxLimit , ind + 1 ) ; } if ( num + arr [ ind ] <= maxLimit ) { findMaxValUtil ( arr , n , num + arr [ ind ] , maxLimit , ind + 1 ) ; } } function findMaxVal ( arr , n , num , maxLimit ) { let ind = 0 ; findMaxValUtil ( arr , n , num , maxLimit , ind ) ; return ans ; } let num = 1 ; let arr = [ 3 , 10 , 6 , 4 , 5 ] ; let n = arr . length ; let maxLimit = 15 ; document . write ( findMaxVal ( arr , n , num , maxLimit ) ) ;
function printSets ( set1 , set2 ) { var i ; for ( i = 0 ; i < set1 . length ; i ++ ) { document . write ( set1 [ i ] + " " ) ; } document . write ( " " ) ; for ( i = 0 ; i < set2 . length ; i ++ ) { document . write ( set2 [ i ] + " " ) ; } } function findSets ( arr , n , set1 , set2 , sum1 , sum2 , pos ) { if ( pos == n ) { if ( sum1 == sum2 ) { printSets ( set1 , set2 ) ; return true ; } else return false ; } set1 . push ( arr [ pos ] ) ; var res = findSets ( arr , n , set1 , set2 , sum1 + arr [ pos ] , sum2 , pos + 1 ) ; if ( res ) return res ; set1 . pop ( ) ; set2 . push ( arr [ pos ] ) ; res = findSets ( arr , n , set1 , set2 , sum1 , sum2 + arr [ pos ] , pos + 1 ) ; if ( res == false ) if ( ! set2 . length == 0 ) set2 . pop ( ) ; return res ; } function isPartitionPoss ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( sum % 2 != 0 ) return false ; var set1 = [ ] ; var set2 = [ ] ; return findSets ( arr , n , set1 , set2 , 0 , 0 , 0 ) ; } var arr = [ 5 , 5 , 1 , 11 ] ; var n = arr . length ; if ( ! isPartitionPoss ( arr , n ) ) { document . write ( " " ) ; }
function maximumSumSubarray ( arr , n ) { let min_prefix_sum = 0 ; let res = Number . MIN_VALUE ; let prefix_sum = [ ] ; prefix_sum [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) prefix_sum [ i ] = prefix_sum [ i - 1 ] + arr [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { res = Math . max ( res , prefix_sum [ i ] - min_prefix_sum ) ; min_prefix_sum = Math . min ( min_prefix_sum , prefix_sum [ i ] ) ; } return res ; } let arr1 = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] ; let n1 = arr1 . length ; document . write ( maximumSumSubarray ( arr1 , n1 ) + " " ) ; let arr2 = [ 4 , - 8 , 9 , - 4 , 1 , - 8 , - 1 , 6 ] ; let n2 = arr2 . length ; document . write ( maximumSumSubarray ( arr2 , n2 ) ) ;
function sequence ( n ) { let i ; let f = [ ] ; f [ 0 ] = 0 ; f [ 1 ] = 1 ; f [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; i ++ ) f [ i ] = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ; return f [ n ] ; } let n = 10 ; document . write ( sequence ( n ) ) ;
of maximum product of an increasing function lis ( arr , n ) { let mpis = [ ] ; let max = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) mpis [ i ] = arr [ i ] ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && mpis [ i ] < ( mpis [ j ] * arr [ i ] ) ) mpis [ i ] = mpis [ j ] * arr [ i ] ; for ( let k = 0 ; k < mpis . length ; k ++ ) { if ( mpis [ k ] > max ) { max = mpis [ k ] ; } } return max ; } let arr = [ 3 , 100 , 4 , 5 , 150 , 6 ] ; let n = arr . length ; document . write ( lis ( arr , n ) ) ;
function Hosoya ( n , m ) { if ( ( n == 0 && m == 0 ) || ( n == 1 && m == 0 ) || ( n == 1 && m == 1 ) || ( n == 2 && m == 1 ) ) return 1 ; if ( n > m ) return Hosoya ( n - 1 , m ) + Hosoya ( n - 2 , m ) ; else if ( m == n ) return Hosoya ( n - 1 , m - 1 ) + Hosoya ( n - 2 , m - 2 ) ; else return 0 ; } function printHosoya ( n ) { for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j <= i ; j ++ ) document . write ( Hosoya ( i , j ) + " " ) ; document . write ( " " ) ; } } let n = 5 ; printHosoya ( n ) ;
function eulerian ( n , m ) { if ( m >= n n == 0 ) return 0 ; if ( m == 0 ) return 1 ; return ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ; } let n = 3 , m = 1 ; document . write ( eulerian ( n , m ) ) ;
function largestSubset ( a , n ) { let dp = [ ] ; dp [ n - 1 ] = 1 ; for ( let i = n - 2 ; i >= 0 ; i -- ) { let mxm = 0 ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] % a [ i ] == 0 a [ i ] % a [ j ] == 0 ) { mxm = Math . max ( mxm , dp [ j ] ) ; } } dp [ i ] = 1 + mxm ; } return Math . max ( ... dp ) ; } let a = [ 1 , 3 , 6 , 13 , 17 , 18 ] ; let n = a . length ; document . write ( largestSubset ( a , n ) ) ;
function countFriendsPairings ( n ) { let dp = [ ] ; for ( let i = 0 ; i <= n ; i ++ ) { if ( i <= 2 ) dp [ i ] = i ; else dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; } return dp [ n ] ; } let n = 4 ; document . write ( countFriendsPairings ( n ) ) ;
function countFriendsPairings ( n ) { let a = 1 , b = 2 , c = 0 ; if ( n <= 2 ) { return n ; } for ( let i = 3 ; i <= n ; i ++ ) { c = b + ( i - 1 ) * a ; a = b ; b = c ; } return c ; } let n = 4 ; document . write ( countFriendsPairings ( n ) ) ;
function lcsOf3 ( X , Y , Z , m , n , o ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = new Array ( o + 1 ) ; for ( let k = 0 ; k < o + 1 ; k ++ ) { L [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i <= m ; i ++ ) { for ( let j = 0 ; j <= n ; j ++ ) { for ( let k = 0 ; k <= o ; k ++ ) { if ( i == 0 j == 0 k == 0 ) L [ i ] [ j ] [ k ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] && X [ i - 1 ] == Z [ k - 1 ] ) L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 ; else L [ i ] [ j ] [ k ] = Math . max ( Math . max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) ; } } } return L [ m ] [ n ] [ o ] ; } let X = " " ; let Y = " " ; let Z = " " ; let m = X . length ; let n = Y . length ; let o = Z . length ; document . write ( " " + lcsOf3 ( X , Y , Z , m , n , o ) ) ;
function findLongestRepeatingSubSeq ( str ) { var n = str . length ; var dp = new Array ( n + 1 ) ; for ( var i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( var j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= n ; j ++ ) { if ( ( str [ i - 1 ] == str [ j - 1 ] ) && ( i != j ) ) dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] ; else dp [ i ] [ j ] = Math . max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) ; } } return dp [ n ] [ n ] ; } var str = " " ; document . write ( " " + findLongestRepeatingSubSeq ( str ) ) ;
function numberOfPaths ( m , n ) { dp = Array . from ( { length : n } , ( _ , i ) => 0 ) ; dp [ 0 ] = 1 ; for ( i = 0 ; i < m ; i ++ ) { for ( j = 1 ; j < n ; j ++ ) { dp [ j ] += dp [ j - 1 ] ; } } return dp [ n - 1 ] ; } document . write ( numberOfPaths ( 3 , 3 ) ) ;
function factorial ( N ) { if ( N == 0 N == 1 ) return 1 ; return N * factorial ( N - 1 ) ; } function nthTerm ( N ) { return ( factorial ( N ) * ( N + 2 ) / 2 ) ; } let N = 6 ; document . write ( nthTerm ( N ) ) ;
function isFrequencyEqual ( str , len ) { if ( len % 2 == 1 ) return false ; var i , freq = Array ( 26 ) . fill ( 0 ) ; for ( i = 0 ; i < len ; i ++ ) freq [ str [ i ] - ' ' ] ++ ; for ( i = 0 ; i < 26 ; i ++ ) if ( freq [ i ] == parseInt ( len / 2 ) ) return true ; return false ; } var str = " " ; var len = str . length ; if ( isFrequencyEqual ( str , len ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countMinimalReplacements ( s ) { var n = s . length ; var cnt = 0 ; var str = " " ; for ( var i = 1 ; i < n ; i ++ ) { if ( s [ i ] === s [ i - 1 ] ) { cnt += 1 ; if ( i !== n - 1 ) { for ( var it = 0 ; it < str . length ; it ++ ) { if ( str [ it ] !== s [ i + 1 ] && str [ it ] !== s [ i - 1 ] ) { s [ i ] = str [ it ] ; break ; } } else { for ( var it = 0 ; it < str . length ; it ++ ) { if ( str [ it ] !== s [ i - 1 ] ) { s [ i ] = str [ it ] ; break ; } } } } } return cnt ; } var s = " " ; document . write ( countMinimalReplacements ( s ) ) ;
function nextIndex ( str , start , c ) { for ( let i = start ; i < str . length ; i ++ ) { if ( str [ i ] == c ) return i ; } return - 1 ; } function countSubStrings ( str ) { let i , n = str . length ; let countX = new Array ( n ) ; let count = 0 ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) count ++ ; countX [ i ] = count ; } let nextIndexX = nextIndex ( str , 0 , ' ' ) ; let nextIndexY = nextIndex ( str , 0 , ' ' ) ; count = 0 ; while ( nextIndexX != - 1 && nextIndexY != - 1 ) { if ( nextIndexX > nextIndexY ) { nextIndexY = nextIndex ( str , nextIndexY + 1 , ' ' ) ; continue ; } else { count += countX [ nextIndexY ] ; nextIndexX = nextIndex ( str , nextIndexX + 1 , ' ' ) ; } } return count ; } let s = " " ; document . write ( countSubStrings ( s ) ) ;
function minimize ( str ) { let mstr = " " ; let l , i , flagchar = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { flagchar [ i ] = 0 ; } let ch ; l = str . length ; for ( i = 0 ; i < str . length ; i ++ ) { ch = str [ i ] ; if ( flagchar [ ch . charCodeAt ( 0 ) - 97 ] == 0 ) { mstr = mstr + ch ; flagchar [ ch . charCodeAt ( 0 ) - 97 ] = 1 ; } } return mstr ; } function replaceMinimizeUtil ( str ) { let minimizedStr , finalStr = " " ; let i , index , l ; let ch ; l = str . length ; minimizedStr = minimize ( str ) ; for ( i = 0 ; i < minimizedStr . length ; i ++ ) { ch = minimizedStr [ i ] . charCodeAt ( 0 ) ; index = ( ch * ch ) % l ; finalStr = finalStr + str [ index ] ; } document . write ( " " + finalStr ) ; } let str = " " ; replaceMinimizeUtil ( str ) ;
function cipher ( str ) { for ( var i = 0 ; i < str . length ; i ++ ) { if ( ! isLetter ( str [ i ] ) && str [ i ] !== " " ) { document . write ( " " ) ; return ; } } document . write ( " " ) ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] >= " " && str [ i ] <= " " ) { document . write ( str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) + 1 + " " ) ; } else if ( str [ i ] >= " " && str [ i ] <= " " ) { document . write ( str [ i ] . charCodeAt ( 0 ) - " " . charCodeAt ( 0 ) + 1 + " " ) ; } if ( str [ i ] == " " ) document . write ( str [ i ] ) ; } document . write ( " " ) ; } function isLetter ( str ) { return str . length === 1 && str . match ( / [a-z] / i ) ; } var str = " " ; cipher ( str ) ;
function round ( n ) { let a = parseInt ( n / 10 , 10 ) * 10 ; let b = a + 10 ; return ( n - a > b - n ) ? b : a ; } let n = 4722 ; document . write ( round ( n ) ) ;
function countOccurrences ( s , K ) { let n = s . length ; let C = 0 , c1 = 0 , c2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) c1 ++ ; if ( s [ i ] == ' ' ) { c2 ++ ; C += c1 ; } } return C * K + ( K * ( K - 1 ) / 2 ) * c1 * c2 ; } let S = " " ; let k = 2 ; document . write ( countOccurrences ( S , k ) ) ;
function findString ( n , k ) { let res = " " ; for ( let i = 0 ; i < k ; i ++ ) res = res + String . fromCharCode ( ' ' . charCodeAt ( 0 ) + i ) ; let count = 0 ; for ( let i = 0 ; i < n - k ; i ++ ) { res = res + String . fromCharCode ( ' ' . charCodeAt ( 0 ) + count ) ; count ++ ; if ( count == k ) count = 0 ; } return res ; } let n = 5 , k = 2 ; document . write ( findString ( n , k ) ) ;
function printRotatedString ( str ) { var n = str . length ; var sb = str ; sb += ( str ) ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j != n ; j ++ ) document . write ( sb . charAt ( i + j ) ) ; document . write ( ' ' ) ; } } var str = " " ; printRotatedString ( str ) ;
let M = 26 ; function getIdx ( ch ) { return ( ch - ' ' ) ; } function allSame ( freq , N ) { let same = 0 ; let i ; for ( i = 0 ; i < N ; i ++ ) { if ( freq [ i ] > 0 ) { same = freq [ i ] ; break ; } } for ( let j = i + 1 ; j < N ; j ++ ) if ( freq [ j ] > 0 && freq [ j ] != same ) return false ; return true ; } function possibleSameCharFreqByOneRemoval ( str ) { let l = str . length ; let freq = new Array ( M ) ; for ( let i = 0 ; i < M ; i ++ ) { freq [ i ] = 0 ; } for ( let i = 0 ; i < l ; i ++ ) freq [ getIdx ( str [ i ] ) ] ++ ; if ( allSame ( freq , M ) ) return true ; for ( let c = ' ' ; c <= ' ' ; c ++ ) { let i = getIdx ( c ) ; if ( freq [ i ] > 0 ) { freq [ i ] -- ; if ( allSame ( freq , M ) ) return true ; freq [ i ] ++ ; } } return false ; } let str = " " ; if ( possibleSameCharFreqByOneRemoval ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function check ( str ) { let n = str . length ; let oddDigSum = 0 , evenDigSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) oddDigSum += ( str [ i ] - ' ' ) ; else evenDigSum += ( str [ i ] - ' ' ) ; } return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) ; } let str = " " ; if ( check ( str ) ) document . write ( " " ) ; else document . write ( " " ) ;
function hammingDist ( str1 , str2 ) { let i = 0 , count = 0 ; while ( i < str1 . length ) { if ( str1 [ i ] != str2 [ i ] ) count ++ ; i ++ ; } return count ; } let str1 = " " ; let str2 = " " ; document . write ( hammingDist ( str1 , str2 ) ) ;
let MAX_CHAR = 26 ; function arekAnagrams ( str1 , str2 , k ) { let n = str1 . length ; if ( str2 . length != n ) return false ; let count1 = new Array ( MAX_CHAR ) ; let count2 = new Array ( MAX_CHAR ) ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) count1 [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < n ; i ++ ) count2 [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( count1 [ i ] > count2 [ i ] ) count = count + Math . abs ( count1 [ i ] - count2 [ i ] ) ; return ( count <= k ) ; } let str1 = " " ; let str2 = " " ; let k = 2 ; if ( arekAnagrams ( str1 , str2 , k ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countSubStr ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) m ++ ; } return m * Math . floor ( ( m - 1 ) / 2 ) ; } let str = " " ; let n = str . length ; document . write ( countSubStr ( str , n ) ) ;
function count9s ( number ) { let count = 0 ; let n = ( number . length ) ; for ( let i = 0 ; i < n ; i ++ ) { let sum = number [ i ] - ' ' ; if ( number [ i ] == ' ' ) { count ++ ; } for ( let j = i + 1 ; j < n ; j ++ ) { sum = ( sum + number [ j ] - ' ' ) % 9 ; if ( sum == 0 ) { count ++ ; } } } return count ; } document . write ( count9s ( " " ) ) ; document . write ( " " ) ; document . write ( count9s ( " " ) ) ;
function minStepsRecur ( height , l , r , h ) { if ( l >= r ) return 0 ; let m = l ; for ( let i = l ; i < r ; i ++ ) if ( height [ i ] < height [ m ] ) m = i ; return Math . min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) ; } function minSteps ( height , N ) { return minStepsRecur ( height , 0 , N , 0 ) ; } let height = [ 2 , 1 , 2 , 5 , 1 ] ; let N = height . length ; document . write ( minSteps ( height , N ) ) ;
function ReuleauxArea ( a ) { if ( a < 0 ) return - 1 ; var A = 0.70477 * Math . pow ( a , 2 ) ; return A ; } var a = 6 ; document . write ( ReuleauxArea ( a ) ) ;
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; let x = 0.5176 * a ; return x ; } let a = 6 ; document . write ( hexagonside ( a ) + " " ) ;
function hexagonside ( a ) { if ( a < 0 ) return - 1 ; var x = a / 3 ; return x ; } var a = 6 ; document . write ( hexagonside ( a ) ) ;
function findSegment ( n , m , segment_length ) { let meet_point = ( 1.0 * n ) / 2.0 ; let sum = 0 ; let segment_number = 0 , i ; for ( i = 0 ; i < m ; i ++ ) { sum += segment_length [ i ] ; if ( sum == meet_point ) { segment_number = - 1 ; break ; } if ( sum > meet_point ) { segment_number = i + 1 ; break ; } } return segment_number ; } let n = 13 ; let m = 3 ; let segment_length = [ 3 , 2 , 8 ] ; let ans = findSegment ( n , m , segment_length ) ; document . write ( ans ) ;
function countMaxIntersect ( n ) { return ( n ) * ( n - 1 ) / 2 ; } var n = 8 ; document . write ( countMaxIntersect ( n ) ) ;
function surfaceArea ( a , b , h ) { return 5 * a * b + 5 * b * h ; } function volume ( b , h ) { return ( 5 * b * h ) / 2 ; } let a = 5 ; let b = 3 ; let h = 7 ; document . write ( " " + surfaceArea ( a , b , h ) + " " ) ; document . write ( " " + volume ( b , h ) ) ;
function checkpoint ( h , k , x , y , a ) { var p = parseInt ( Math . pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) ) ; return p ; } var h = 0 , k = 0 , x = 2 , y = 1 , a = 4 ; if ( checkpoint ( h , k , x , y , a ) > 0 ) document . write ( " " ) ; else if ( checkpoint ( h , k , x , y , a ) == 0 ) document . write ( " " ) ; else document . write ( " " ) ;
function checkpoint ( h , k , x , y , a , b ) { var p = ( parseInt ( Math . pow ( ( x - h ) , 2 ) ) / parseInt ( Math . pow ( a , 2 ) ) ) + ( parseInt ( Math . pow ( ( y - k ) , 2 ) ) / parseInt ( Math . pow ( b , 2 ) ) ) ; return p ; } var h = 0 , k = 0 , x = 2 , y = 1 , a = 4 , b = 5 ; if ( checkpoint ( h , k , x , y , a , b ) > 1 ) document . write ( " " ) ; else if ( checkpoint ( h , k , x , y , a , b ) == 1 ) document . write ( " " ) ; else document . write ( " " ) ;
function circlearea ( a , b ) { if ( a < 0 b < 0 ) return - 1 ; var A = ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; } var a = 8 , b = 10 ; document . write ( circlearea ( a , b ) . toFixed ( 4 ) ) ;
function circlearea ( l , b ) { if ( l < 0 b < 0 ) return - 1 ; if ( l < b ) return ( 3.14 * Math . pow ( l / 2 , 2 ) ) ; else return ( 3.14 * Math . pow ( b / 2 , 2 ) ) ; } var l = 4 , b = 8 ; document . write ( circlearea ( l , b ) ) ;
function centered_cube ( n ) { return ( 2 * n + 1 ) * ( n * n + n + 1 ) ; } let n = 3 ; document . write ( n + " " ) ; document . write ( centered_cube ( n ) ) ; document . write ( " " ) ; n = 10 ; document . write ( n + " " ) ; document . write ( centered_cube ( n ) ) ;
function center ( x1 , x2 , y1 , y2 ) { document . write ( ( x1 + x2 ) / 2 + " " + ( y1 + y2 ) / 2 ) ; } let x1 = - 9 , y1 = 3 , x2 = 5 , y2 = - 7 ; center ( x1 , x2 , y1 , y2 ) ;
function vol_of_octahedron ( side ) { return ( ( side * side * side ) * ( Math . sqrt ( 2 ) / 3 ) ) ; } let side = 3 ; document . write ( " " + vol_of_octahedron ( side ) . toFixed ( 4 ) ) ;
function volumeOfEllipsoid ( r1 , r2 , r3 ) { let pi = 3.14 ; return 1.33 * pi * r1 * r2 * r3 ; } let r1 = 2.3 , r2 = 3.4 , r3 = 5.7 ; document . write ( " " + volumeOfEllipsoid ( r1 , r2 , r3 ) . toFixed ( 2 ) ) ;
function areaOctagon ( side ) { return ( 2 * ( 1 + Math . sqrt ( 2 ) ) * side * side ) ; } let side = 4 ; document . write ( " " + areaOctagon ( side ) + " " ) ;
function areaCube ( a ) { return ( a * a * a ) ; } function surfaceCube ( a ) { return ( 6 * a * a ) ; } let a = 5 ; document . write ( " " + areaCube ( a ) + " " ) ; document . write ( " " + surfaceCube ( a ) ) ;
function minRevolutions ( r , x1 , y1 , x2 , y2 ) { let d = Math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) ; return Math . ceil ( d / ( 2 * r ) ) ; } let r = 2 , x1 = 0 , y1 = 0 , x2 = 0 , y2 = 4 ; document . write ( minRevolutions ( r , x1 , y1 , x2 , y2 ) ) ;
let eps = 1e-6 ; function getArea ( base , hypotenuse ) { let height = Math . sqrt ( hypotenuse * hypotenuse - base * base ) ; return 0.5 * base * height ; } function printRightAngleTriangle ( hypotenuse , area ) { let hsquare = hypotenuse * hypotenuse ; let sideForMaxArea = Math . sqrt ( hsquare / 2.0 ) ; let maxArea = getArea ( sideForMaxArea , hypotenuse ) ; if ( area > maxArea ) { document . write ( " " ) ; return ; } let low = 0.0 ; let high = sideForMaxArea ; let base = 0 ; while ( Math . abs ( high - low ) > eps ) { base = ( low + high ) / 2.0 ; if ( getArea ( base , hypotenuse ) >= area ) { high = base ; } else { low = base ; } } let height = Math . sqrt ( hsquare - base * base ) ; document . write ( Math . round ( base ) + " " + Math . round ( height ) ) ; } let hypotenuse = 5 ; let area = 6 ; printRightAngleTriangle ( hypotenuse , area ) ;
function countLattice ( r ) { if ( r <= 0 ) return 0 ; var result = 4 ; for ( x = 1 ; x < r ; x ++ ) { var ySquare = r * r - x * x ; var y = parseInt ( Math . sqrt ( ySquare ) ) ; if ( y * y == ySquare ) result += 4 ; } return result ; } var r = 5 ; document . write ( countLattice ( r ) ) ;
function power ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } x = ( x * x ) % p ; } return res ; } let L = 2 ; let P = Math . pow ( 10 , 9 ) ; let ans = power ( 325 , L , P ) ; document . write ( ans ) ;
var MAXN = 30 ; function countMaxLength ( N ) { var res ; var pre = Array ( MAXN ) , p = 1 ; pre [ 0 ] = 0 ; for ( var i = 1 ; i < MAXN ; i ++ ) { p *= 2 ; pre [ i ] = pre [ i - 1 ] + i * p ; } var ind ; for ( var i = 1 ; i < MAXN ; i ++ ) { if ( pre [ i ] >= N ) { ind = i ; break ; } } var x = N - pre [ ind - 1 ] ; var y = 2 * ind - 1 ; if ( x >= y ) res = Math . min ( x , y ) ; else res = Math . max ( x , 2 * ( ind - 2 ) + 1 ) ; return res ; } var N = 25 ; document . write ( countMaxLength ( N ) ) ;
function factorialUsingRecursion ( n ) { if ( n == 0 ) return 1 ; return n * factorialUsingRecursion ( n - 1 ) ; } function factorialUsingIteration ( n ) { var res = 1 , i ; for ( i = 2 ; i <= n ; i ++ ) res *= i ; return res ; } var num = 5 ; document . write ( " " + num + " " + factorialUsingRecursion ( 5 ) + " " ) ; document . write ( " " + num + " " + factorialUsingIteration ( 5 ) ) ;
function maxSum ( arr , n , K ) { var maximum = - 1000000000 ; var sum = Array ( n ) . fill ( 0 ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( i + K < n ) sum [ i ] = sum [ i + K ] + arr [ i ] ; else sum [ i ] = arr [ i ] ; maximum = Math . max ( maximum , sum [ i ] ) ; } return maximum ; } var arr = [ 3 , 6 , 4 , 7 , 2 ] ; var n = arr . length ; var K = 2 ; document . write ( maxSum ( arr , n , K ) ) ;
function findpair ( l , r ) { let c = 0 ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = i + 1 ; j <= r ; j ++ ) { if ( j % i == 0 && j != i ) { document . write ( i + " " + j + " " ) ; c = 1 ; break ; } } if ( c == 1 ) break ; } } let l = 1 , r = 10 ; findpair ( l , r ) ;
function check ( arr , N , K ) { var unique = new Set ( ) ; for ( var i = 0 ; i < N ; i ++ ) unique . add ( arr [ i ] ) ; if ( unique . size == K ) return true ; return false ; } var arr = [ 1 , 1 , 2 , 3 ] ; var N = arr . length ; var K = 3 ; if ( check ( arr , N , K ) ) document . write ( " " ) ; else document . write ( " " ) ;
function minIndex ( arr , n , pos ) { var num = arr [ pos ] ; var i = pos - 1 ; while ( i >= 0 ) { if ( arr [ i ] != num ) break ; i -- ; } return i + 1 ; } var arr = [ 2 , 1 , 1 , 1 , 5 , 2 ] ; var n = arr . length ; var pos = 4 ; document . write ( minIndex ( arr , n , pos ) ) ;
function findAnswer ( str1 , str2 , n ) { var l = 0 , r = 0 ; var ans = 2 ; for ( i = 0 ; i < n ; ++ i ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { l = i ; break ; } } for ( i = n - 1 ; i >= 0 ; i -- ) { if ( str1 . charAt ( i ) != str2 . charAt ( i ) ) { r = i ; break ; } } if ( r < l ) return 26 * ( n + 1 ) ; else if ( l == r ) return ans ; else { for ( i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i ) != str2 . charAt ( i - 1 ) ) { ans -- ; break ; } } for ( i = l + 1 ; i <= r ; i ++ ) { if ( str1 . charAt ( i - 1 ) != str2 . charAt ( i ) ) { ans -- ; break ; } } return ans ; } } var str1 = " " , str2 = " " ; var n = str1 . length ; document . write ( findAnswer ( str1 , str2 , n ) ) ;
function findMinDifference ( arr , n ) { arr . sort ( ) ; let diff1 = arr [ n - 1 ] - arr [ 1 ] ; let diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; } let arr = [ 1 , 2 , 4 , 3 , 4 ] ; let n = arr . length ; document . write ( findMinDifference ( arr , n ) ) ;
function findMinDifference ( arr , n ) { let min__ , secondMin , max__ , secondMax ; min__ = secondMax = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 0 ] : arr [ 1 ] ; max__ = secondMin = ( arr [ 0 ] < arr [ 1 ] ) ? arr [ 1 ] : arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) { if ( arr [ i ] > max__ ) { secondMax = max__ ; max__ = arr [ i ] ; } else if ( arr [ i ] > secondMax ) { secondMax = arr [ i ] ; } else if ( arr [ i ] < min__ ) { secondMin = min__ ; min__ = arr [ i ] ; } else if ( arr [ i ] < secondMin ) { secondMin = arr [ i ] ; } } let diff = Math . min ( max__ - secondMin , secondMax - min__ ) ; return diff ; } let arr = [ 1 , 2 , 4 , 3 , 4 ] ; let n = arr . length ; document . write ( findMinDifference ( arr , n ) ) ;
function checkDistinct ( x ) { var last = x % 10 ; while ( x > 0 ) { if ( x % 10 != last ) return false ; x = parseInt ( x / 10 ) ; } return true ; } function findCount ( L , R ) { var count = 0 ; for ( i = L ; i <= R ; i ++ ) { if ( checkDistinct ( i ) ) count += 1 ; } return count ; } var L = 10 , R = 50 ; document . write ( findCount ( L , R ) ) ;
function smallest_pair ( a , n ) { let min = Number . MAX_VALUE , secondMin = Number . MAX_VALUE ; for ( let j = 0 ; j < n ; j ++ ) { if ( a [ j ] < min ) { secondMin = min ; min = a [ j ] ; } else if ( ( a [ j ] < secondMin ) && a [ j ] != min ) secondMin = a [ j ] ; } return ( secondMin + min ) ; } let arr = [ 1 , 2 , 3 ] ; let n = arr . length ; document . write ( smallest_pair ( arr , n ) ) ;
function longestsubarray ( arr , n , k ) { let current_count = 0 ; let max_count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % k == 0 ) current_count ++ ; else current_count = 0 ; max_count = Math . max ( current_count , max_count ) ; } return max_count ; } let arr = [ 2 , 5 , 11 , 32 , 64 , 88 ] ; let n = arr . length ; let k = 8 ; document . write ( longestsubarray ( arr , n , k ) ) ;
function check ( s ) { for ( let i = 0 ; i < s . length - 1 ; i ++ ) if ( s [ i ] == s [ i + 1 ] ) return true ; return false ; } let s = " " ; if ( check ( s ) ) document . write ( " " ) ; else document . write ( " " ) ;
function countAnomalies ( arr , n , k ) { let res = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let j ; for ( j = 0 ; j < n ; j ++ ) if ( i != j && Math . abs ( arr [ i ] - arr [ j ] ) <= k ) break ; if ( j == n ) res ++ ; } return res ; } let arr = [ 7 , 1 , 8 ] ; let k = 5 ; let n = arr . length ; document . write ( countAnomalies ( arr , n , k ) ) ;
function colMaxDiff ( mat ) { let max_diff = Number . MIN_VALUE ; for ( let i = 0 ; i < N ; i ++ ) { let max_val = mat [ 0 ] [ i ] , min_val = mat [ 0 ] [ i ] ; for ( let j = 1 ; j < N ; j ++ ) { max_val = Math . max ( max_val , mat [ j ] [ i ] ) ; min_val = Math . min ( min_val , mat [ j ] [ i ] ) ; } max_diff = Math . max ( max_diff , max_val - min_val ) ; } return max_diff ; } let mat = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 5 , 3 , 5 , 4 , 0 ] , [ 5 , 6 , 7 , 8 , 9 ] , [ 0 , 6 , 3 , 4 , 12 ] , [ 9 , 7 , 12 , 4 , 3 ] ] ; document . write ( " " + colMaxDiff ( mat ) )
function search ( ar , size ) { let a = 0 , b = size - 1 ; let mid = 0 ; while ( ( b - a ) > 1 ) { mid = ( a + b ) / 2 ; if ( ( ar [ a ] - a ) != ( ar [ mid ] - mid ) ) b = mid ; else if ( ( ar [ b ] - b ) != ( ar [ mid ] - mid ) ) a = mid ; } return ( ar [ a ] + 3 ) ; } let ar = [ 1 , 2 , 3 , 4 , 5 , 6 , 8 ] ; let size = ar . length ; document . write ( " " + search ( ar , size ) ) ;
function deleteElement ( A , L , R , N ) { let i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; } let A = [ 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 ] ; let L = 2 , R = 7 ; let n = A . length ; let res_size = deleteElement ( A , L , R , n ) ; for ( let i = 0 ; i < res_size ; i ++ ) document . write ( A [ i ] + " " ) ;
function findmissing ( ar , N ) { var l = 0 , r = N - 1 ; while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; if ( ar [ mid ] != mid + 1 && ar [ mid - 1 ] == mid ) return mid + 1 ; if ( ar [ mid ] != mid + 1 ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } var arr = [ 1 , 2 , 3 , 4 , 5 , 7 , 8 ] ; var N = arr . length ; document . write ( findmissing ( arr , N ) ) ;
function findFirst ( arr , n , x ) { arr . sort ( ) ; let ptr = lowerBound ( arr , 0 , n , x ) ; return ( arr [ ptr ] != x ) ? - 1 : ( ptr ) ; } function lowerBound ( a , low , high , element ) { while ( low < high ) { let middle = low + parseInt ( ( high - low ) / 2 , 10 ) ; if ( element > a [ middle ] ) low = middle + 1 ; else high = middle ; } return low ; } let x = 20 ; let arr = [ 10 , 30 , 20 , 50 , 20 ] ; let n = arr . length ; document . write ( findFirst ( arr , n , x ) ) ;
function findFirst ( arr , n , x ) { var count = 0 ; var isX = false ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == x ) { isX = true ; } else if ( arr [ i ] < x ) { count ++ ; } } return ( isX == false ) ? - 1 : count ; } var x = 20 , arr = [ 10 , 30 , 20 , 50 , 20 ] ; var n = arr . length ; document . write ( findFirst ( arr , n , x ) ) ;
function findDuplicate ( arr ) { let slow = arr [ 0 ] ; let fast = arr [ 0 ] ; do { slow = arr [ slow ] ; fast = arr [ arr [ fast ] ] ; } while ( slow != fast ) ; let ptr1 = arr [ 0 ] ; let ptr2 = slow ; while ( ptr1 != ptr2 ) { ptr1 = arr [ ptr1 ] ; ptr2 = arr [ ptr2 ] ; } return ptr1 ; } let arr = [ 1 , 3 , 2 , 1 ] ; document . write ( findDuplicate ( arr ) + " " ) ;
let MAX_CHAR = 26 ; function printGreaterCount ( str ) { let len = str . length ; let ans = new Array ( len ) ; ans . fill ( 0 ) ; let count = new Array ( MAX_CHAR ) ; count . fill ( 0 ) ; for ( let i = len - 1 ; i >= 0 ; i -- ) { count [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; for ( let j = str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ; j < MAX_CHAR ; j ++ ) { ans [ i ] += count [ j ] ; } } for ( let i = 0 ; i < len ; i ++ ) { document . write ( ans [ i ] + " " ) ; } } let str = " " ; printGreaterCount ( str ) ;
function maxProduct ( arr , n ) { if ( n < 4 ) { return - 1 ; } let maxA = Number . MIN_VALUE , maxB = Number . MIN_VALUE , maxC = Number . MIN_VALUE , maxD = Number . MIN_VALUE ; let minA = Number . MAX_VALUE , minB = Number . MAX_VALUE , minC = Number . MAX_VALUE , minD = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > maxA ) { maxD = maxC ; maxC = maxB ; maxB = maxA ; maxA = arr [ i ] ; } else if ( arr [ i ] > maxB ) { maxD = maxC ; maxC = maxB ; maxB = arr [ i ] ; } else if ( arr [ i ] > maxC ) { maxD = maxC ; maxC = arr [ i ] ; } else if ( arr [ i ] > maxD ) { maxD = arr [ i ] ; } if ( arr [ i ] < minA ) { minD = minC ; minC = minB ; minB = minA ; minA = arr [ i ] ; } else if ( arr [ i ] < minB ) { minD = minC ; minC = minB ; minB = arr [ i ] ; } else if ( arr [ i ] < minC ) { minD = minC ; minC = arr [ i ] ; } else if ( arr [ i ] < minD ) { minD = arr [ i ] ; } } let x = maxA * maxB * maxC * maxD ; let y = minA * minB * minC * minD ; let z = minA * minB * maxA * maxB ; return Math . max ( x , Math . max ( y , z ) ) ; } let arr = [ 1 , - 4 , 3 , - 6 , 7 , 0 ] ; let n = arr . length ; let max = maxProduct ( arr , n ) ; if ( max == - 1 ) document . write ( " " ) ; else document . write ( " " + max ) ;
function countTripletsLessThanL ( n , L , arr ) { arr . sort ( ) ; var ways = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { for ( k = j + 1 ; k < n ; k ++ ) { var mostDistantDistance = arr [ k ] - arr [ i ] ; if ( mostDistantDistance <= L ) { ways ++ ; } } } } return ways ; } var arr = [ 1 , 2 , 3 , 4 ] ; var n = arr . length ; var L = 3 ; var ans = countTripletsLessThanL ( n , L , arr ) ; document . write ( " " + ans ) ;
function missingNum ( arr , n ) { let minvalue = Math . min ( ... arr ) ; let xornum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { xornum ^= ( minvalue ) ^ arr [ i ] ; minvalue ++ ; } return xornum ^ minvalue ; } let arr = [ 13 , 12 , 11 , 15 ] ; let n = arr . length ; document . write ( missingNum ( arr , n ) ) ;
function findLastIndex ( str , x ) { let index = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) if ( str [ i ] == x ) index = i ; return index ; } let str = " " ; let x = ' ' ; let index = findLastIndex ( str , x ) ; if ( index == - 1 ) document . write ( " " ) ; else document . write ( " " + index ) ;
function findLastIndex ( str , x ) { for ( let i = str . length - 1 ; i >= 0 ; i -- ) if ( str [ i ] == x ) return i ; return - 1 ; } let str = " " ; let x = ' ' ; let index = findLastIndex ( str , x ) ; if ( index == - 1 ) document . write ( " " ) ; else document . write ( " " + index ) ;
function countMaxSetBits ( left , right ) { while ( ( left | ( left + 1 ) ) <= right ) left |= left + 1 ; return left ; } let l = 1 , r = 5 ; document . write ( countMaxSetBits ( l , r ) + " " ) ; l = 1 , r = 10 ; document . write ( countMaxSetBits ( l , r ) ) ;
function findS ( s ) { var l = 1 , r = parseInt ( ( s / 2 ) + 1 ) ; while ( l <= r ) { var mid = parseInt ( ( l + r ) / 2 ) ; var sum = mid * parseInt ( ( mid + 1 ) / 2 ) ; if ( sum == s ) return mid ; else if ( sum > s ) r = mid - 1 ; else l = mid + 1 ; } return - 1 ; } var s = 15 ; var n = findS ( s ) ; if ( n == - 1 ) document . write ( " " ) ; else document . write ( n ) ;
function pendulumArrangement ( arr , n ) { arr . sort ( function ( a , b ) { return a - b } ) ; let odd , temp , p , pos ; pos = n - 1 ; if ( n % 2 == 0 ) odd = n - 1 ; else odd = n - 2 ; while ( odd > 0 ) { temp = arr [ odd ] ; p = odd ; while ( p != pos ) { arr [ p ] = arr [ p + 1 ] ; p ++ ; } arr [ p ] = temp ; odd = odd - 2 ; pos = pos - 1 ; } let start = 0 , end = parseInt ( ( n - 1 ) / 2 , 10 ) ; for ( ; start < end ; start ++ , end -- ) { temp = arr [ start ] ; arr [ start ] = arr [ end ] ; arr [ end ] = temp ; } for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; } let arr = [ 11 , 2 , 4 , 55 , 6 , 8 ] ; let n = arr . length ; pendulumArrangement ( arr , n ) ;
function findNumber ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; var max = arr [ n - 1 ] ; var table = Array ( ( 2 * max ) + 1 ) . fill ( 0 ) ; table [ 0 ] = 0 ; for ( i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) table [ i ] = Number . MAX_VALUE ; var ans = - 1 ; for ( i = 1 ; i < ( 2 * max ) + 1 ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( arr [ j ] <= i ) { var res = table [ i - arr [ j ] ] ; if ( res != Number . MAX_VALUE && res + 1 < table [ i ] ) table [ i ] = res + 1 ; } } if ( i > arr [ n - 1 ] && table [ i ] == Number . MAX_VALUE ) { ans = i ; break ; } } return ans ; } var arr = [ 6 , 7 , 15 ] ; var n = arr . length ; document . write ( findNumber ( arr , n ) ) ;
function countPoints ( n , m , a , b , x , y ) { a . sort ( function ( a , b ) { return a - b } ) ; b . sort ( function ( a , b ) { return a - b } ) ; let j = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( j < m ) { if ( a [ i ] + y < b [ j ] ) break ; if ( b [ j ] >= a [ i ] - x && b [ j ] <= a [ i ] + y ) { count ++ ; j ++ ; break ; } else j ++ ; } } return count ; } let x = 1 , y = 4 ; let a = [ 1 , 5 ] ; let n = a . length ; let b = [ 1 , 1 , 2 ] ; let m = a . length ; document . write ( countPoints ( n , m , a , b , x , y ) ) ;
function minSubarray ( A , n ) { let minValue = Number . MAX_VALUE ; let maxValue = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { minValue = Math . min ( minValue , A [ i ] ) ; maxValue = Math . max ( maxValue , A [ i ] ) ; } let pos_min = - 1 , pos_max = - 1 , ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { if ( A [ i ] == minValue ) pos_min = i ; if ( A [ i ] == maxValue ) pos_max = i ; if ( pos_max != - 1 && pos_min != - 1 ) ans = Math . min ( ans , Math . abs ( pos_min - pos_max ) + 1 ) ; } return ans ; } let A = [ 1 , 5 , 9 , 7 , 1 , 9 , 4 ] ; let n = A . length ; document . write ( minSubarray ( A , n ) ) ;
function countSequences ( arr , n ) { let count = 1 ; arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n - 1 ; i ++ ) if ( arr [ i ] + 1 != arr [ i + 1 ] ) count ++ ; return count ; } let arr = [ 1 , 7 , 3 , 5 , 10 ] ; let n = arr . length ; document . write ( countSequences ( arr , n ) ) ;
function minimumMoves ( a , n ) { let operations = 0 ; a . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) operations += Math . abs ( a [ i ] - ( i + 1 ) ) ; return operations ; } let arr = [ 5 , 3 , 2 ] ; let n = arr . length ; document . write ( minimumMoves ( arr , n ) ) ;
function printCase ( n ) { if ( n <= 2 ) { document . write ( - 1 ) ; return ; } for ( let i = n ; i >= 1 ; i -- ) document . write ( i + " " ) ; } let n = 3 ; printCase ( n ) ;
function check ( n , k , a , b ) { a . sort ( ) ; b . sort ( ) ; let fl = false ; let ind = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) { if ( fl == true ) { return false ; } fl = true ; ind = i ; } } if ( ind == - 1 | Math . abs ( a [ ind ] - b [ ind ] ) <= k ) { return true ; } return false ; } let n = 2 , k = 4 ; let a = [ 1 , 5 ] ; let b = [ 1 , 1 ] ; if ( check ( n , k , a , b ) ) { document . write ( " " ) ; } else { document . write ( " " ) ; }
var MOD = 1000000007 function SubseqWidths ( A , n ) { A . sort ( ( a , b ) => a - b ) var pow2 = Array ( n ) . fill ( 0 ) ; pow2 [ 0 ] = 1 ; for ( var i = 1 ; i < n ; ++ i ) pow2 [ i ] = ( pow2 [ i - 1 ] * 2 ) % MOD ; var ans = 0 ; for ( var i = 0 ; i < n ; ++ i ) ans = ( ans + ( pow2 [ i ] - pow2 [ n - 1 - i ] ) * A [ i ] ) % MOD ; return ans ; } var A = [ 5 , 6 , 4 , 3 , 8 ] ; var n = A . length ; document . write ( SubseqWidths ( A , n ) ) ;
function maxArrayCover ( a , n , x ) { a . sort ( ) ; let cc = 0 ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s += a [ i ] ; if ( s > x ) { break ; } cc += 1 ; } var sum = a . reduce ( function ( a , b ) { return a + b ; } , 0 ) ; if ( sum == x ) { return n ; } else { if ( cc == n ) { return n - 1 ; } else { return cc ; } } } let n = 3 ; let x = 70 ; let a = [ 10 , 20 , 30 ] ; document . write ( maxArrayCover ( a , n , x ) ) ;
function maximumSOP ( a , b ) { let sop = 0 ; let n = a . length ; a . sort ( ) ; b . sort ( ) ; for ( let i = 0 ; i < n ; i ++ ) { sop += ( a [ i ] * b [ i ] ) ; } return sop ; } let A = [ 1 , 2 , 3 ] ; let B = [ 4 , 5 , 1 ] ; document . write ( maximumSOP ( A , B ) ) ;
function countTriplets ( arr , n , m ) { let count = 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; let end , start , mid ; for ( end = n - 1 ; end >= 2 ; end -- ) { start = 0 ; mid = end - 1 ; while ( start < mid ) { let prod = arr [ end ] * arr [ start ] * arr [ mid ] ; if ( prod > m ) mid -- ; else if ( prod < m ) start ++ ; else if ( prod == m ) { count ++ ; mid -- ; start ++ ; } } } return count ; } let arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] ; let n = arr . length ; let m = 1 ; document . write ( countTriplets ( arr , n , m ) ) ;
function sort3 ( arr , temp ) { if ( arr [ 1 ] < arr [ 0 ] ) { temp [ 0 ] = arr [ 0 ] ; arr [ 0 ] = arr [ 1 ] ; arr [ 1 ] = temp [ 0 ] ; } if ( arr [ 2 ] < arr [ 1 ] ) { temp [ 0 ] = arr [ 1 ] ; arr [ 1 ] = arr [ 2 ] ; arr [ 2 ] = temp [ 0 ] ; if ( arr [ 1 ] < arr [ 0 ] ) { temp [ 0 ] = arr [ 0 ] ; arr [ 0 ] = arr [ 1 ] ; arr [ 1 ] = temp [ 0 ] ; } } } let a = [ 10 , 12 , 5 ] ; let temp1 = [ 10 ] ; sort3 ( a , temp1 ) ; for ( let i = 0 ; i < 3 ; i ++ ) document . write ( a [ i ] + " " ) ;
function printTriplets ( arr , n , sum ) { arr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < n - 2 ; i ++ ) { let j = i + 1 , k = n - 1 ; while ( j < k ) { if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) k -- ; else { for ( let x = j + 1 ; x <= k ; x ++ ) document . write ( arr [ i ] + " " + arr [ j ] + " " + arr [ x ] + " " ) ; j ++ ; } } } } let arr = [ 5 , 1 , 3 , 4 , 7 ] ; let n = arr . length ; let sum = 12 ; printTriplets ( arr , n , sum ) ;
function checkFittingArrays ( A , B , N ) { A . sort ( function ( a , b ) { return a - b ; } ) ; B . sort ( function ( a , b ) { return a - b ; } ) ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] > B [ i ] ) return false ; return true ; } let A = [ 7 , 5 , 3 , 2 ] ; let B = [ 5 , 4 , 8 , 7 ] ; let N = A . length ; if ( checkFittingArrays ( A , B , N ) ) document . write ( " " ) ; else document . write ( " " ) ;
function maximum_toys ( cost , N , K ) { let count = 0 , sum = 0 ; cost . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 0 ; i < N ; i ++ ) { if ( sum + cost [ i ] <= K ) { sum = sum + cost [ i ] ; count ++ ; } } return count ; } let K = 50 ; let cost = [ 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 ] ; let N = cost . length ; document . write ( maximum_toys ( cost , N , K ) ) ;
function almostSort ( A , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( A [ i ] > A [ i + 1 ] ) { let temp = A [ i ] ; A [ i ] = A [ i + 1 ] ; A [ i + 1 ] = temp ; i ++ ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( A [ i ] > A [ i + 1 ] ) return false ; return true ; } let A = [ 1 , 3 , 2 , 4 , 6 , 5 ] ; let n = A . length ; if ( almostSort ( A , n ) ) document . write ( " " ) ; else document . write ( " " ) ;
function nextGap ( gap ) { if ( gap <= 1 ) return 0 ; return parseInt ( gap / 2 , 10 ) + ( gap % 2 ) ; } function merge ( arr1 , arr2 , n , m ) { let i , j , gap = n + m ; for ( gap = nextGap ( gap ) ; gap > 0 ; gap = nextGap ( gap ) ) { for ( i = 0 ; i + gap < n ; i ++ ) if ( arr1 [ i ] > arr1 [ i + gap ] ) { let temp = arr1 [ i ] ; arr1 [ i ] = arr1 [ i + gap ] ; arr1 [ i + gap ] = temp ; } for ( j = gap > n ? gap - n : 0 ; i < n && j < m ; i ++ , j ++ ) if ( arr1 [ i ] > arr2 [ j ] ) { let temp = arr1 [ i ] ; arr1 [ i ] = arr2 [ j ] ; arr2 [ j ] = temp ; } if ( j < m ) { for ( j = 0 ; j + gap < m ; j ++ ) if ( arr2 [ j ] > arr2 [ j + gap ] ) { let temp = arr2 [ j ] ; arr2 [ j ] = arr2 [ j + gap ] ; arr2 [ j + gap ] = temp ; } } } } let a1 = [ 10 , 27 , 38 , 43 , 82 ] ; let a2 = [ 3 , 9 ] ; merge ( a1 , a2 , a1 . length , a2 . length ) ; document . write ( " " ) ; for ( let i = 0 ; i < a1 . length ; i ++ ) { document . write ( a1 [ i ] + " " ) ; } document . write ( " " ) ; document . write ( " " ) ; for ( let i = 0 ; i < a2 . length ; i ++ ) { document . write ( a2 [ i ] + " " ) ; }
function findMinDiff ( arr , n , m ) { if ( m == 0 n == 0 ) return 0 ; arr . sort ( function ( a , b ) { return a - b } ) ; if ( n < m ) return - 1 ; let min_diff = Number . MAX_VALUE ; for ( let i = 0 ; i + m - 1 < n ; i ++ ) { let diff = arr [ i + m - 1 ] - arr [ i ] ; if ( diff < min_diff ) min_diff = diff ; } return min_diff ; } let arr = [ 12 , 4 , 7 , 9 , 2 , 23 , 25 , 41 , 30 , 40 , 28 , 42 , 30 , 44 , 48 , 43 , 50 ] ; let m = 7 ; let n = arr . length ; document . write ( " " + findMinDiff ( arr , n , m ) ) ;
function distinctCount ( arr , n ) { let count = n ; let i = 0 , j = n - 1 , sum = 0 ; while ( i < j ) { while ( i != j && arr [ i ] == arr [ i + 1 ] ) count -- , i ++ ; while ( i != j && arr [ j ] == arr [ j - 1 ] ) count -- , j -- ; if ( i == j ) break ; sum = arr [ i ] + arr [ j ] ; if ( sum == 0 ) { count -- ; i ++ , j -- ; } else if ( sum < 0 ) i ++ ; else j -- ; } return count ; } let arr = [ - 2 , - 1 , 0 , 1 , 1 ] ; let n = arr . length ; document . write ( " " + distinctCount ( arr , n ) ) ;
function sortByOneSwap ( arr , n ) { for ( let i = n - 1 ; i > 0 ; i -- ) { if ( arr [ i ] < arr [ i - 1 ] ) { let j = i - 1 ; while ( j >= 0 && arr [ i ] < arr [ j ] ) j -- ; let temp = arr [ i ] ; arr [ i ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; break ; } } } function printArray ( arr , n ) { let i ; for ( i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; } let arr = [ 10 , 30 , 20 , 40 , 50 , 60 , 70 ] ; let n = arr . length ; document . write ( " " + " " ) ; printArray ( arr , n ) ; sortByOneSwap ( arr , n ) ; document . write ( " " + " " ) ; printArray ( arr , n ) ;
function flip ( arr , i ) { let temp , start = 0 ; while ( start < i ) { temp = arr [ start ] ; arr [ start ] = arr [ i ] ; arr [ i ] = temp ; start ++ ; i -- ; } } function findMax ( arr , n ) { let mi , i ; for ( mi = 0 , i = 0 ; i < n ; ++ i ) if ( arr [ i ] > arr [ mi ] ) mi = i ; return mi ; } function pancakeSort ( arr , n ) { for ( let curr_size = n ; curr_size > 1 ; -- curr_size ) { let mi = findMax ( arr , curr_size ) ; if ( mi != curr_size - 1 ) { flip ( arr , mi ) ; flip ( arr , curr_size - 1 ) ; } } return 0 ; } function printArray ( arr , arr_size ) { for ( let i = 0 ; i < arr_size ; i ++ ) document . write ( arr [ i ] + " " ) ; document . write ( " " ) ; } let arr = [ 23 , 10 , 20 , 11 , 12 , 6 , 7 ] ; let n = arr . length ; pancakeSort ( arr , n ) ; document . write ( " " + " " ) ; printArray ( arr , n ) ;
function get_maximum ( s , a ) { let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) < a [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) { let j = i ; while ( j < n && ( s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) <= a [ s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) ) { s [ j ] = String . fromCharCode ( ' ' . charCodeAt ( ) + a [ s [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ) ; j ++ ; } return s . join ( " " ) ; } } return s . join ( " " ) ; } let s = " " ; let a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ] ; document . write ( get_maximum ( s . split ( ' ' ) , a ) ) ;
function countSteps ( n ) { let steps = 0 ; while ( n ) { let largest = Math . floor ( Math . sqrt ( n ) ) ; n -= ( largest * largest ) ; steps ++ ; } return steps ; } let n = 85 ; document . write ( countSteps ( n ) ) ;
function sumArr ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } function maxSum ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b } ) ; let i = 0 ; while ( i < n && k > 0 && arr [ i ] < 0 ) { arr [ i ] *= - 1 ; k -- ; i ++ ; } if ( k % 2 == 1 ) { let min = 0 ; for ( i = 1 ; i < n ; i ++ ) if ( arr [ min ] > arr [ i ] ) min = i ; arr [ min ] *= - 1 ; } return sumArr ( arr , n ) ; } let arr = [ - 5 , 4 , 1 , 3 , 2 ] ; let n = arr . length ; let k = 4 ; document . write ( maxSum ( arr , n , k ) ) ;
function Maxsum ( c1 , c2 , c3 , c4 ) { let sum = 0 ; let two34 = Math . min ( c2 , Math . min ( c3 , c4 ) ) ; sum = two34 * 234 ; c2 -= two34 ; sum += Math . min ( c2 , c1 ) * 12 ; return sum ; } let c1 = 5 , c2 = 2 , c3 = 3 , c4 = 4 ; document . write ( Maxsum ( c1 , c2 , c3 , c4 ) ) ;
function findCountOfPairs ( a , b , n ) { let ans = 0 ; ans += n * parseInt ( a / n , 10 ) * parseInt ( b / n , 10 ) ans += parseInt ( a / n , 10 ) * parseInt ( b % n , 10 ) ; ans += parseInt ( a % n , 10 ) * parseInt ( b / n , 10 ) ; ans += parseInt ( ( ( a % n ) + ( b % n ) ) / n , 10 ) ; return ans ; } let a = 5 , b = 13 , n = 3 ; document . write ( findCountOfPairs ( a , b , n ) ) ;
function findArray ( N , P ) { let ans = parseInt ( ( P * ( P + 1 ) ) / 2 , 10 ) + ( N - P ) ; let arr = new Array ( N + 1 ) ; for ( let i = 1 ; i <= P ; i ++ ) { arr [ i ] = i ; } for ( let i = P + 1 ; i <= N ; i ++ ) { arr [ i ] = 1 ; } document . write ( " " + ans + " " ) ; document . write ( " " + " " ) ; for ( let i = 1 ; i <= N ; i ++ ) { document . write ( arr [ i ] + " " ) ; } } let N = 5 , P = 3 ; findArray ( N , P ) ;
function findIntersection ( intervals , N ) { let l = intervals [ 0 ] [ 0 ] ; let r = intervals [ 0 ] [ 1 ] ; for ( let i = 1 ; i < N ; i ++ ) { if ( intervals [ i ] [ 0 ] > r intervals [ i ] [ 1 ] < l ) { document . write ( - 1 + " " ) ; return ; } else { l = Math . max ( l , intervals [ i ] [ 0 ] ) ; r = Math . min ( r , intervals [ i ] [ 1 ] ) ; } } document . write ( " " + l + " " + r + " " + " " ) ; } let intervals = [ [ 1 , 6 ] , [ 2 , 8 ] , [ 3 , 10 ] , [ 5 , 8 ] ] ; let N = intervals . length ; findIntersection ( intervals , N ) ;
function cmp ( a , b ) { if ( a > b ) return 1 ; else if ( a == b ) return 0 ; else return - 1 ; } function maxSubarraySize ( arr , n ) { var ans = 1 ; var anchor = 0 ; for ( i = 1 ; i < n ; i ++ ) { var c = cmp ( arr [ i - 1 ] , arr [ i ] ) ; if ( c == 0 ) anchor = i ; else if ( i == n - 1 || c * cmp ( arr [ i ] , arr [ i + 1 ] ) != - 1 ) { ans = Math . max ( ans , i - anchor + 1 ) ; anchor = i ; } } return ans ; } var arr = [ 9 , 4 , 2 , 10 , 7 , 8 , 8 , 1 , 9 ] ; var n = arr . length ; document . write ( maxSubarraySize ( arr , n ) ) ;
function ValidPairs ( arr , n ) { var count = Array ( 121 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) count [ arr [ i ] ] += 1 ; var ans = 0 ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) continue ; if ( Math . abs ( arr [ i ] - arr [ j ] ) % 2 == 1 ) continue ; ans += count [ arr [ i ] ] * count [ arr [ j ] ] ; if ( arr [ i ] == arr [ j ] ) ans -= count [ arr [ i ] ] ; } return ans ; } var arr = [ 16 , 17 , 18 ] ; var n = arr . length ; document . write ( ValidPairs ( arr , n ) ) ;
function minChanges ( A , n ) { var cnt = 0 ; for ( var i = 0 ; i < n - 2 ; ++ i ) { if ( ( i - 1 >= 0 ) && A [ i - 1 ] == 1 && A [ i + 1 ] == 1 && A [ i ] == 0 ) { A [ i + 1 ] = 0 ; cnt ++ ; } } return cnt ; } var A = [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ] ; var n = A . length ; document . write ( minChanges ( A , n ) ) ;
function completeSequence ( s ) { let n = s . length ; let open = 0 , close = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) open ++ ; else close ++ ; if ( close > open ) { document . write ( " " ) ; return ; } } document . write ( s ) ; for ( let i = 0 ; i < open - close ; i ++ ) document . write ( " " ) ; } let s = " " ; completeSequence ( s ) ;
function smallestPermute ( n ) { var res = Array ( n + 1 ) . fill ( 0 ) ; if ( n % 2 == 0 ) { for ( var i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = 48 + i + 2 ; else res [ i ] = 48 + i ; } } else { for ( var i = 0 ; i < n - 2 ; i ++ ) { if ( i % 2 == 0 ) res [ i ] = 48 + i + 2 ; else res [ i ] = 48 + i ; } res [ n - 1 ] = 48 + n - 2 ; res [ n - 2 ] = 48 + n ; res [ n - 3 ] = 48 + n - 1 ; } for ( var i = 0 ; i < res . length ; i ++ ) { res [ i ] = String . fromCharCode ( res [ i ] ) ; } return res . join ( " " ) ; } var n = 7 ; document . write ( smallestPermute ( n ) ) ;
function minInsertions ( H , n , K ) { var inser = 0 ; for ( var i = 1 ; i < n ; ++ i ) { var diff = Math . abs ( H [ i ] - H [ i - 1 ] ) ; if ( diff <= K ) continue ; else inser += Math . ceil ( diff / K ) - 1 ; } return inser ; } var H = [ 2 , 4 , 8 , 16 ] ; var K = 3 ; var n = H . length ; document . write ( minInsertions ( H , n , K ) ) ;
function count_minimum_operations ( n ) { let count = 0 ; while ( n > 1 ) { if ( n % 3 == 0 ) n /= 3 ; else if ( n % 3 == 1 ) n -- ; else { if ( n == 2 ) n -- ; else n ++ ; } count ++ ; } return count ; } let n = 4 ; let ans = count_minimum_operations ( n ) ; document . write ( ans ) ;
function maxSum ( a , n ) { let l = [ ] ; let s = 0 ; for ( let i = 0 ; i < n ; i ++ ) { s += Math . abs ( a [ i ] ) ; if ( a [ i ] >= 0 ) continue ; if ( i == 0 ) l . push ( i + 1 ) ; else { l . push ( i + 1 ) ; l . push ( i ) ; } } document . write ( s + " " ) ; for ( let i = 0 ; i < l . length ; i ++ ) document . write ( l [ i ] + " " ) ; } let n = 4 ; let a = [ 1 , - 2 , - 3 , 4 ] ; maxSum ( a , n ) ;
function LengthLCP ( x , y ) { let fr = Array ( 26 ) . fill ( 0 ) ; for ( let i = 0 ; i < b ; i ++ ) { fr [ y [ i ] . charCodeAt ( ) - 97 ] += 1 ; } let c = 0 ; for ( let i = 0 ; i < a ; i ++ ) { if ( fr [ x [ i ] . charCodeAt ( ) - 97 ] > 0 ) { c += 1 ; fr [ x [ i ] . charCodeAt ( ) - 97 ] -= 1 ; } else break ; } document . write ( ( c ) ) ; } let x = " " , y = " " ; LengthLCP ( x , y ) ;
function CountPair ( L , R ) { let x = ( R - L + 1 ) ; document . write ( x / 2 + " " ) ; } let L , R ; L = 1 ; R = 8 ; CountPair ( L , R ) ;
function problemsLeft ( K , P , N ) { if ( K <= P ) return 0 ; else return ( K - P ) * N ; } let K , P , N ; K = 4 ; P = 1 ; N = 10 ; document . write ( problemsLeft ( K , P , N ) ) ;
function results ( n , k ) { return parseInt ( Math . round ( Math . pow ( n , ( 1.0 / Math . pow ( 2.0 , k ) ) ) ) ) ; } var k = 3 , n = 100000000 ; document . write ( " " + k + " " + results ( n , k ) ) ;
function steps ( N , M ) { if ( N == 1 ) return 0 ; return M ; return 2 * M + ( N - 3 ) ; } let N = 4 , M = 4 ; document . write ( steps ( N , M ) ) ;
function survival ( S , N , M ) { if ( ( ( N * 6 ) < ( M * 7 ) && S > 6 ) M > N ) document . write ( " " ) ; else { let days = ( M * S ) / N ; if ( ( ( M * S ) % N ) != 0 ) days ++ ; document . write ( " " + Math . round ( days ) ) ; } } let S = 10 , N = 16 , M = 2 ; survival ( S , N , M ) ;
