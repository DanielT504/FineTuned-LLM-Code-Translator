def isEven ( arr , n , r ) : NEW_LINE INDENT if ( r % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT oddCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT DEDENT if ( oddCount % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE r = 2 NEW_LINE if ( isEven ( arr , n , r ) ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT DEDENT
def solve ( a , n ) : NEW_LINE INDENT ones , twos = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT twos += 1 NEW_LINE DEDENT DEDENT ind = 0 NEW_LINE if ( twos ) : NEW_LINE INDENT a [ ind ] = 2 NEW_LINE ind += 1 NEW_LINE DEDENT if ones % 2 == 0 : NEW_LINE INDENT evenOnes = True NEW_LINE DEDENT else : NEW_LINE INDENT evenOnes = False NEW_LINE DEDENT if ( evenOnes ) : NEW_LINE INDENT ones -= 1 NEW_LINE DEDENT for i in range ( ones ) : NEW_LINE INDENT a [ ind ] = 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( twos - 1 ) : NEW_LINE INDENT a [ ind ] = 2 NEW_LINE ind += 1 NEW_LINE DEDENT if ( evenOnes ) : NEW_LINE INDENT a [ ind ] = 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 1 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE solve ( a , n ) NEW_LINE
def CreateArray ( N , even , odd ) : NEW_LINE INDENT temp = - 1 NEW_LINE for i in range ( N + 2 ) : NEW_LINE INDENT if ( i * ( ( N + 1 ) - i ) == odd ) : NEW_LINE INDENT temp = 0 NEW_LINE OddPreSums = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( temp == - 1 ) : NEW_LINE INDENT print ( temp ) NEW_LINE DEDENT else : NEW_LINE INDENT EvenPreSums = ( N + 1 ) - OddPreSums NEW_LINE e = 1 NEW_LINE o = 0 NEW_LINE CurrSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( CurrSum % 2 == 0 ) : NEW_LINE INDENT if ( e < EvenPreSums ) : NEW_LINE INDENT e += 1 NEW_LINE print ( "0 ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT o += 1 NEW_LINE print ( "1 ▁ " , end = " " ) NEW_LINE CurrSum += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( e < EvenPreSums ) : NEW_LINE INDENT e += 1 NEW_LINE print ( "1 ▁ " ) NEW_LINE CurrSum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT o += 1 NEW_LINE print ( "0 ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT print ( " " , ▁ end ▁ = ▁ " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE even = 60 NEW_LINE odd = 60 NEW_LINE CreateArray ( N , even , odd ) NEW_LINE DEDENT
def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A or B ) : NEW_LINE INDENT if ( ( A & 1 ) and ( B & 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 2 NEW_LINE B = 3 NEW_LINE X = findX ( A , B ) NEW_LINE print ( " X ▁ = " , X , " , ▁ Sum ▁ = " , ( A ^ X ) + ( B ^ X ) ) NEW_LINE DEDENT
def isSumEqual ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += ar [ i ] NEW_LINE DEDENT if ( sum == ar [ n - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isSumEqual ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
from math import sqrt , ceil , floor ; NEW_LINE def perfectSquares ( a , b ) : NEW_LINE INDENT return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; NEW_LINE DEDENT def countOnes ( arr , n ) : NEW_LINE INDENT return perfectSquares ( 1 , n ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 ; NEW_LINE arr = [ 0 ] * 10 ; NEW_LINE print ( countOnes ( arr , N ) ) ; NEW_LINE DEDENT
import bisect NEW_LINE def printPosition ( A , B , sizeOfA , sizeOfB ) : NEW_LINE INDENT for i in range ( 1 , sizeOfA ) : NEW_LINE INDENT A [ i ] += A [ i - 1 ] NEW_LINE DEDENT for i in range ( sizeOfB ) : NEW_LINE INDENT row = bisect . bisect_left ( A , B [ i ] ) NEW_LINE if row >= 1 : NEW_LINE INDENT boxNumber = B [ i ] - A [ row - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT boxNumber = B [ i ] NEW_LINE DEDENT print ( row + 1 , " , " , boxNumber ) NEW_LINE DEDENT DEDENT A = [ 2 , 2 , 2 , 2 ] NEW_LINE B = [ 1 , 2 , 3 , 4 ] NEW_LINE sizeOfA = len ( A ) NEW_LINE sizeOfB = len ( B ) NEW_LINE printPosition ( A , B , sizeOfA , sizeOfB ) NEW_LINE
import math NEW_LINE def primeFactors ( n , freq ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE n = int ( n // 2 ) NEW_LINE DEDENT freq [ 2 ] = cnt NEW_LINE i = 3 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE n = int ( n // i ) NEW_LINE DEDENT freq [ int ( i ) ] = cnt NEW_LINE i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT freq [ int ( n ) ] = 1 NEW_LINE DEDENT DEDENT def getMaximumPower ( n , m ) : NEW_LINE INDENT freq1 = [ 0 ] * ( n + 1 ) NEW_LINE freq2 = [ 0 ] * ( m + 1 ) NEW_LINE primeFactors ( n , freq1 ) NEW_LINE primeFactors ( m , freq2 ) NEW_LINE maxi = 0 NEW_LINE i = 2 NEW_LINE while i <= m : NEW_LINE INDENT if ( freq1 [ i ] == 0 and freq2 [ i ] == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT if ( freq2 [ i ] > freq1 [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( freq2 [ i ] ) : NEW_LINE INDENT maxi = max ( maxi , int ( freq1 [ i ] // freq2 [ i ] ) ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return maxi NEW_LINE DEDENT n = 48 NEW_LINE m = 4 NEW_LINE print ( getMaximumPower ( n , m ) ) NEW_LINE
def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if j * i <= n : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE findDivisors ( n ) NEW_LINE DEDENT
def decideWinner ( a , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE count3 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 4 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 2 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 3 ) : NEW_LINE INDENT count3 += 1 NEW_LINE DEDENT DEDENT if ( count0 % 2 == 0 and count1 % 2 == 0 and count2 % 2 == 0 and count3 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT a = [ 4 , 8 , 5 , 9 ] NEW_LINE n = len ( a ) NEW_LINE if ( decideWinner ( a , n ) == 1 ) : NEW_LINE INDENT print ( " X ▁ wins " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Y ▁ wins " ) NEW_LINE DEDENT
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT number = ( number * 2 + arr [ i ] ) % x NEW_LINE if number == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = 7 NEW_LINE x = 2 NEW_LINE print ( CntDivbyX ( arr , n , x ) ) NEW_LINE
def numLen ( K ) : NEW_LINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT number = 0 NEW_LINE len = 1 NEW_LINE for len in range ( 1 , K + 1 ) : NEW_LINE INDENT number = ( number * 10 + 1 ) % K NEW_LINE if number == 0 : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT K = 7 NEW_LINE print ( numLen ( K ) ) NEW_LINE
max_Element = 100005 NEW_LINE sum1 = [ 0 for i in range ( max_Element ) ] NEW_LINE sum2 = [ 0 for i in range ( max_Element ) ] NEW_LINE sum3 = [ 0 for i in range ( max_Element ) ] NEW_LINE def precomputation ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum1 [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum2 [ j ] += ( sum1 [ j ] - i ) * i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum2 [ i ] = int ( sum2 [ i ] / 2 ) NEW_LINE DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum3 [ i ] = int ( sum3 [ i ] / 3 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum3 [ arr [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE precomputation ( arr , n ) NEW_LINE DEDENT
import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 ; NEW_LINE return int ( round ( pow ( phi , n ) / math . sqrt ( 5 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE
def printBalancedExpression ( a , b , c , d ) : NEW_LINE INDENT if ( ( a == d and a ) or ( a == 0 and c == 0 and d == 0 ) ) : NEW_LINE INDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT print ( " ( ( " , end = " " ) NEW_LINE DEDENT for i in range ( 1 , c + 1 ) : NEW_LINE INDENT print ( " ) ( " , end = " " ) NEW_LINE DEDENT for i in range ( 1 , d + 1 ) : NEW_LINE INDENT print ( " ) ) " , end = " " ) NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT print ( " ( ) " , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c , d = 3 , 1 , 4 , 3 NEW_LINE printBalancedExpression ( a , b , c , d ) NEW_LINE DEDENT
def factorial ( f ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , f + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def findPermuatation ( N , M ) : NEW_LINE INDENT permutation = ( factorial ( N + M - 1 ) // ( factorial ( N ) * factorial ( M - 1 ) ) ) NEW_LINE return permutation NEW_LINE DEDENT N = 3 ; M = 3 NEW_LINE print ( findPermuatation ( N , M ) ) NEW_LINE
def maxValue ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( n * n // 2 ) - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( maxValue ( n ) ) NEW_LINE
import math NEW_LINE def findCount ( n ) : NEW_LINE INDENT a , b , c = 1 , 0 , 0 ; NEW_LINE x = ( int ) ( n / 60 ) ; NEW_LINE a = int ( math . pow ( 32 , x ) ) ; NEW_LINE x = 60 * x ; NEW_LINE for i in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT b += a ; NEW_LINE a = 0 ; NEW_LINE DEDENT if ( i % 5 == 0 ) : NEW_LINE INDENT c += b ; NEW_LINE b = 0 ; NEW_LINE DEDENT if ( i % 12 == 0 ) : NEW_LINE INDENT a += ( 2 * c ) ; NEW_LINE c = 0 ; NEW_LINE DEDENT DEDENT print ( " a ▁ = " , a , end = " , ▁ " ) ; NEW_LINE print ( " b ▁ = " , b , end = " , ▁ " ) ; NEW_LINE print ( " c ▁ = " , c ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 72 ; NEW_LINE findCount ( n ) ; NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorial ( n - 1 ) * n NEW_LINE DEDENT DEDENT def gcdOfFactorial ( arr , n ) : NEW_LINE INDENT minm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if minm > arr [ i ] : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = minm NEW_LINE DEDENT DEDENT return factorial ( minm ) NEW_LINE DEDENT arr = [ 9 , 12 , 122 , 34 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( gcdOfFactorial ( arr , n ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( n , n ) + sum ( n - 1 ) NEW_LINE DEDENT DEDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE
mod = 1000000007 NEW_LINE def power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , int ( n / 2 ) ) % mod ; NEW_LINE p = ( p * p ) % mod NEW_LINE if ( n & 1 ) : NEW_LINE INDENT p = ( p * a ) % mod NEW_LINE DEDENT return p NEW_LINE DEDENT def countPermutations ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( power ( 2 , n - 1 ) - 2 ) % mod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( countPermutations ( n ) ) NEW_LINE DEDENT
def numbers ( n ) : NEW_LINE INDENT return pow ( 2 , n + 1 ) - 2 NEW_LINE DEDENT n = 2 NEW_LINE print ( numbers ( n ) ) NEW_LINE
def NumbersofWays ( n ) : NEW_LINE INDENT x = ( n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) // ( 4 * 3 * 2 * 1 ) NEW_LINE y = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) NEW_LINE return x * y NEW_LINE DEDENT n = 4 NEW_LINE print ( NumbersofWays ( n ) ) NEW_LINE
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE nth = ( N * N * ( N + 1 ) ) // 2 NEW_LINE return nth NEW_LINE DEDENT N = 5 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def findNumber ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT print ( ( 2 * i ) - 1 , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 3 NEW_LINE findNumber ( n ) NEW_LINE
import sys NEW_LINE def findMissingNums ( even , sizeEven , odd , sizeOdd ) : NEW_LINE INDENT minEven = sys . maxsize ; NEW_LINE maxEven = - ( sys . maxsize - 1 ) ; NEW_LINE minOdd = sys . maxsize ; NEW_LINE maxOdd = - ( sys . maxsize - 1 ) ; NEW_LINE sumEvenArr = 0 ; NEW_LINE sumOddArr = 0 ; NEW_LINE for i in range ( sizeEven ) : NEW_LINE INDENT minEven = min ( minEven , even [ i ] ) ; NEW_LINE maxEven = max ( maxEven , even [ i ] ) ; NEW_LINE sumEvenArr += even [ i ] ; NEW_LINE DEDENT for i in range ( sizeOdd ) : NEW_LINE INDENT minOdd = min ( minOdd , odd [ i ] ) ; NEW_LINE maxOdd = max ( maxOdd , odd [ i ] ) ; NEW_LINE sumOddArr += odd [ i ] ; NEW_LINE DEDENT totalTerms = 0 ; NEW_LINE reqSum = 0 ; NEW_LINE totalTerms = minEven // 2 ; NEW_LINE evenSumMin = ( totalTerms * ( totalTerms + 1 ) ) ; NEW_LINE totalTerms = maxEven // 2 ; NEW_LINE evenSumMax = ( totalTerms * ( totalTerms + 1 ) ) ; NEW_LINE reqSum = ( evenSumMax - evenSumMin + minEven ) ; NEW_LINE print ( " Even ▁ = " , reqSum - sumEvenArr ) ; NEW_LINE totalTerms = ( minOdd // 2 ) + 1 ; NEW_LINE oddSumMin = totalTerms * totalTerms ; NEW_LINE totalTerms = ( maxOdd // 2 ) + 1 ; NEW_LINE oddSumMax = totalTerms * totalTerms ; NEW_LINE reqSum = ( oddSumMax - oddSumMin + minOdd ) ; NEW_LINE print ( " Odd ▁ = " , reqSum - sumOddArr ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT even = [ 6 , 4 , 8 , 14 , 10 ] ; NEW_LINE sizeEven = len ( even ) NEW_LINE odd = [ 7 , 5 , 3 , 11 , 13 ] ; NEW_LINE sizeOdd = len ( odd ) ; NEW_LINE findMissingNums ( even , sizeEven , odd , sizeOdd ) ; NEW_LINE DEDENT
def findMinimum ( x , y ) : NEW_LINE INDENT low = 0 NEW_LINE high = y NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( ( mid * 2 + ( y - mid ) ) >= x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 6 NEW_LINE y = 5 NEW_LINE print ( findMinimum ( x , y ) ) NEW_LINE DEDENT
def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if i % 2 == 0 and sumOfDigits ( i ) % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 1000 ; r = 6000 NEW_LINE print ( countNumbers ( l , r ) ) NEW_LINE
def findMinSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] * ( n - i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinSum ( arr , n ) ) NEW_LINE
def maxLenSubArr ( a , n ) : NEW_LINE INDENT cm , Max = 1 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > Max : NEW_LINE INDENT Max = a [ i ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT count = 1 NEW_LINE if a [ i ] == a [ i + 1 ] and a [ i ] == Max : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] == Max : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if count > cm : NEW_LINE INDENT cm = count NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return cm NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 1 , 6 , 6 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxLenSubArr ( arr , n ) ) NEW_LINE DEDENT
def minSum ( arr , n , x ) : NEW_LINE INDENT Sum = 0 NEW_LINE largestDivisible , minimum = - 1 , arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return Sum NEW_LINE DEDENT sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) ) NEW_LINE return min ( Sum , sumAfterOperation ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 5 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( minSum ( arr , n , x ) ) NEW_LINE DEDENT
def maxAND ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L ; NEW_LINE DEDENT elif ( ( R - L ) == 1 ) : NEW_LINE INDENT return ( R & L ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) : NEW_LINE INDENT return ( ( R - 1 ) & R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( R - 2 ) & ( R - 1 ) ) ; NEW_LINE DEDENT DEDENT DEDENT L = 1 ; NEW_LINE R = 632 ; NEW_LINE print ( maxAND ( L , R ) ) ; NEW_LINE
def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( sieve [ num ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = int ( num / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True for i in range ( N * 10 + 1 ) ] NEW_LINE sieve [ 0 ] = False NEW_LINE sieve [ 1 ] = False NEW_LINE for i in range ( 2 , N * 10 + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N * 10 + 1 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT N += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 379 NEW_LINE findSpecialPrime ( N ) NEW_LINE N = 100 NEW_LINE findSpecialPrime ( N ) NEW_LINE DEDENT
import sys NEW_LINE def minMoves ( n ) : NEW_LINE INDENT s = str ( n ) ; NEW_LINE ans = sys . maxsize ; NEW_LINE len1 = len ( s ) ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT for j in range ( len1 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT t = s ; NEW_LINE cur = 0 ; NEW_LINE list1 = list ( t ) ; NEW_LINE for k in range ( i , len1 - 1 ) : NEW_LINE INDENT e = list1 [ k ] ; NEW_LINE list1 [ k ] = list1 [ k + 1 ] ; NEW_LINE list1 [ k + 1 ] = e ; NEW_LINE cur += 1 ; NEW_LINE DEDENT t = ' ' . join ( list1 ) ; NEW_LINE list1 = list ( t ) ; NEW_LINE for k in range ( j - ( j > i ) , len1 - 2 ) : NEW_LINE INDENT e = list1 [ k ] ; NEW_LINE list1 [ k ] = list1 [ k + 1 ] ; NEW_LINE list1 [ k + 1 ] = e ; NEW_LINE cur += 1 ; NEW_LINE DEDENT t = ' ' . join ( list1 ) ; NEW_LINE pos = - 1 ; NEW_LINE for k in range ( len1 ) : NEW_LINE INDENT if ( t [ k ] != '0' ) : NEW_LINE INDENT pos = k ; NEW_LINE break ; NEW_LINE DEDENT DEDENT for k in range ( pos , 0 , - 1 ) : NEW_LINE INDENT e = list1 [ k ] ; NEW_LINE list1 [ k ] = list1 [ k + 1 ] ; NEW_LINE list1 [ k + 1 ] = e ; NEW_LINE cur += 1 ; NEW_LINE DEDENT t = ' ' . join ( list1 ) ; NEW_LINE nn = int ( t ) ; NEW_LINE if ( nn % 25 == 0 ) : NEW_LINE INDENT ans = min ( ans , cur ) ; NEW_LINE DEDENT DEDENT DEDENT if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT n = 509201 ; NEW_LINE print ( minMoves ( n ) ) ; NEW_LINE
def getMaxNum ( a , b , c ) : NEW_LINE INDENT if ( b % c == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT x = ( ( b // c ) * c ) NEW_LINE if ( x >= a and x <= b ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a , b , c = 2 , 10 , 3 NEW_LINE print ( getMaxNum ( a , b , c ) ) NEW_LINE
def countSquares ( row , column ) : NEW_LINE INDENT topLeft = min ( row , column ) - 1 NEW_LINE bottomRight = 8 - max ( row , column ) NEW_LINE topRight = min ( row , 9 - column ) - 1 NEW_LINE bottomLeft = 8 - max ( row , 9 - column ) NEW_LINE return ( topLeft + topRight + bottomRight + bottomLeft ) NEW_LINE DEDENT row = 4 NEW_LINE column = 4 NEW_LINE print ( countSquares ( row , column ) ) NEW_LINE
def canTakeDown ( bishopX , bishopY , pawnX , pawnY ) : NEW_LINE INDENT if ( pawnX - bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( - pawnX + bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT bishopX = 5 NEW_LINE bishopY = 5 NEW_LINE pawnX = 1 NEW_LINE pawnY = 1 NEW_LINE if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
N = 1000005 NEW_LINE primeFactors = [ 0 ] * N ; NEW_LINE def findPrimeFactors ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( primeFactors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT primeFactors [ j ] = primeFactors [ j // i ] + 1 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT primeFactors [ i ] += primeFactors [ i - 1 ] ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT findPrimeFactors ( ) ; NEW_LINE a = 6 ; b = 3 ; NEW_LINE print ( primeFactors [ a ] - primeFactors [ b ] ) ; NEW_LINE DEDENT
from math import floor , pow NEW_LINE import sys NEW_LINE def digitSum ( n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT ans += n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return ans NEW_LINE DEDENT def findInt ( n , m ) : NEW_LINE INDENT minDigit = floor ( m / 9 ) NEW_LINE start = ( int ( pow ( 10 , minDigit ) ) - int ( pow ( 10 , minDigit ) ) % n ) NEW_LINE while ( start < sys . maxsize ) : NEW_LINE INDENT if ( digitSum ( start ) == m ) : NEW_LINE INDENT return start NEW_LINE DEDENT else : NEW_LINE INDENT start += n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE m = 32 NEW_LINE print ( findInt ( n , m ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def smallestDivisor ( n ) : NEW_LINE INDENT mx = int ( sqrt ( n ) ) NEW_LINE for i in range ( 2 , mx + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT def maxSum ( n ) : NEW_LINE INDENT res = n NEW_LINE while ( n > 1 ) : NEW_LINE INDENT divi = smallestDivisor ( n ) NEW_LINE n = int ( n / divi ) NEW_LINE res += n NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 34 NEW_LINE print ( maxSum ( n ) ) NEW_LINE DEDENT
def isPossible ( n , k , arr ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT if ( int ( maxVal ) > int ( ( sum + k ) / n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 8 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isPossible ( n , k , arr ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
from math import * NEW_LINE def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if ( floor ( z ) == ceil ( z ) ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE a = 5 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE print ( maxResult ( n , a , b , c ) ) NEW_LINE DEDENT
def EqualNumbers ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while a [ i ] % 2 == 0 : NEW_LINE INDENT a [ i ] //= 2 NEW_LINE DEDENT while a [ i ] % 3 == 0 : NEW_LINE INDENT a [ i ] //= 3 NEW_LINE DEDENT if a [ i ] != a [ 0 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 50 , 75 , 150 ] NEW_LINE n = len ( a ) NEW_LINE if EqualNumbers ( a , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def max_gcd ( n , p ) : NEW_LINE INDENT count = 0 ; NEW_LINE gcd = 1 ; NEW_LINE while ( p % 2 == 0 ) : NEW_LINE INDENT p >>= 1 ; NEW_LINE count = count + 1 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd = gcd * pow ( 2 , count // n ) ; NEW_LINE DEDENT for i in range ( 3 , ( int ) ( math . sqrt ( p ) ) , 2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( p % i == 0 ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE p = p // i ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd = gcd * pow ( i , count // n ) ; NEW_LINE DEDENT DEDENT if ( p > 2 ) : NEW_LINE INDENT gcd = gcd * pow ( p , 1 // n ) ; NEW_LINE DEDENT return gcd ; NEW_LINE DEDENT n = 3 ; NEW_LINE p = 80 ; NEW_LINE print ( max_gcd ( n , p ) ) ; NEW_LINE
def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT a , b , c = 2 , 4 , 4 NEW_LINE print ( getMinNum ( a , b , c ) ) NEW_LINE
def countPairs ( n ) : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT num = ( ( n // 2 ) + 1 ) ; NEW_LINE max = n % num ; NEW_LINE count = n - max ; NEW_LINE return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; NEW_LINE DEDENT print ( countPairs ( n ) ) ; NEW_LINE
import math as mt NEW_LINE def checkSub ( sub , s ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( sub [ j ] == s [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT if j == int ( len ( sub ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def getMultiple ( s ) : NEW_LINE INDENT for i in range ( 0 , 10 ** 3 , 8 ) : NEW_LINE INDENT if ( checkSub ( str ( i ) , s ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT s = "3454" NEW_LINE print ( getMultiple ( s ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT print ( sum ( 8 ) ) NEW_LINE print ( sum ( 10 ) ) NEW_LINE
import math as mt NEW_LINE def findingValues ( m , n , mth , nth ) : NEW_LINE INDENT d = ( ( abs ( mth - nth ) ) / abs ( ( m - 1 ) - ( n - 1 ) ) ) NEW_LINE a = mth - ( ( m - 1 ) * d ) NEW_LINE return a , d NEW_LINE DEDENT def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT a , d = findingValues ( m , n , mth , nth ) NEW_LINE Sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 NEW_LINE return Sum NEW_LINE DEDENT m = 6 NEW_LINE n = 10 NEW_LINE mTerm = 12 NEW_LINE nTerm = 20 NEW_LINE p = 5 NEW_LINE print ( findSum ( m , n , mTerm , nTerm , p ) ) NEW_LINE
def powerfulIntegers ( x , y , bound ) : NEW_LINE INDENT s = set ( ) NEW_LINE powersOfY = [ ] NEW_LINE powersOfY . append ( 1 ) NEW_LINE i = y NEW_LINE while i < bound and y != 1 : NEW_LINE INDENT powersOfY . append ( i ) NEW_LINE i *= y NEW_LINE DEDENT i = 0 NEW_LINE while ( True ) : NEW_LINE INDENT xPowI = pow ( x , i ) NEW_LINE for j in powersOfY : NEW_LINE INDENT num = xPowI + j NEW_LINE if ( num <= bound ) : NEW_LINE INDENT s . add ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( xPowI >= bound or x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for itr in s : NEW_LINE INDENT print ( itr , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 2 NEW_LINE y = 3 NEW_LINE bound = 10 NEW_LINE powerfulIntegers ( x , y , bound ) NEW_LINE DEDENT
import math as mt NEW_LINE def candies ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE ind = 1 NEW_LINE arr = [ 0 for i in range ( k ) ] NEW_LINE while n > 0 : NEW_LINE INDENT f1 = ( ind - 1 ) * k NEW_LINE f2 = ind * k NEW_LINE sum1 = ( f1 * ( f1 + 1 ) ) // 2 NEW_LINE sum2 = ( f2 * ( f2 + 1 ) ) // 2 NEW_LINE res = sum2 - sum1 NEW_LINE if ( res <= n ) : NEW_LINE INDENT count += 1 NEW_LINE n -= res NEW_LINE ind += 1 NEW_LINE i = 0 NEW_LINE term = ( ( ind - 1 ) * k ) + 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( term <= n ) : NEW_LINE INDENT arr [ i ] = term NEW_LINE i += 1 NEW_LINE n -= term NEW_LINE term += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = n NEW_LINE i += 1 NEW_LINE n = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT arr [ i ] += ( ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) // 2 ) ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n , k = 10 , 3 NEW_LINE candies ( n , k ) NEW_LINE
def candies ( n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE ind = 1 ; NEW_LINE arr = [ 0 ] * k ; NEW_LINE low = 0 ; NEW_LINE high = n ; NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 ; NEW_LINE sum = ( mid * ( mid + 1 ) ) >> 1 ; NEW_LINE if ( sum <= n ) : NEW_LINE INDENT count = int ( mid / k ) ; NEW_LINE low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT DEDENT last = ( count * k ) ; NEW_LINE n -= int ( ( last * ( last + 1 ) ) / 2 ) ; NEW_LINE i = 0 ; NEW_LINE term = ( count * k ) + 1 ; NEW_LINE while ( n ) : NEW_LINE INDENT if ( term <= n ) : NEW_LINE INDENT arr [ i ] = term ; NEW_LINE i += 1 ; NEW_LINE n -= term ; NEW_LINE term += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += n ; NEW_LINE n = 0 ; NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT arr [ i ] += ( ( count * ( i + 1 ) ) + int ( k * ( count * ( count - 1 ) ) / 2 ) ) ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE k = 4 ; NEW_LINE candies ( n , k ) ; NEW_LINE
def printSmallest ( a , n ) : NEW_LINE INDENT sum0 , sum1 = 0 , 0 NEW_LINE a = sorted ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 3 == 0 ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT num = ( a [ i ] * 10 ) + a [ j ] NEW_LINE if ( num % 3 == 0 ) : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT DEDENT return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] NEW_LINE DEDENT arr = [ 7 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( printSmallest ( arr , n ) ) NEW_LINE
def updateMatrix ( n , q , mat ) : NEW_LINE INDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT X1 = q [ i ] [ 0 ] ; NEW_LINE Y1 = q [ i ] [ 1 ] ; NEW_LINE X2 = q [ i ] [ 2 ] ; NEW_LINE Y2 = q [ i ] [ 3 ] ; NEW_LINE mat [ X1 ] [ Y1 ] = mat [ X1 ] [ Y1 ] + 1 ; NEW_LINE if ( Y2 + 1 < n ) : NEW_LINE INDENT mat [ X2 ] [ Y2 + 1 ] = mat [ X2 ] [ Y2 + 1 ] - 1 ; NEW_LINE DEDENT elif ( X2 + 1 < n ) : NEW_LINE INDENT mat [ X2 + 1 ] [ 0 ] = mat [ X2 + 1 ] [ 0 ] - 1 ; NEW_LINE DEDENT DEDENT sum = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT sum = sum + mat [ i ] [ j ] ; NEW_LINE print ( sum , end = ' ▁ ' ) ; NEW_LINE DEDENT print ( " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE mat = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] ; NEW_LINE q = [ [ 0 , 0 , 1 , 2 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 4 , 3 , 4 ] ] ; NEW_LINE updateMatrix ( n , q , mat ) ; NEW_LINE
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def replaceMax ( arr , n ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE ranges = max_element - min_element NEW_LINE coeffOfRange = ranges / ( max_element + min_element ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT arr [ i ] = coeffOfRange NEW_LINE break NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE replaceMax ( arr , n ) NEW_LINE DEDENT
def divide ( a , b ) : NEW_LINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( " A ▁ = " , a , " , ▁ B ▁ = " , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A , B = 10 , 15 NEW_LINE divide ( A , B ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a // n NEW_LINE b = b // n NEW_LINE print ( " A ▁ = " , a , " , ▁ B ▁ = " , b ) NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE commDiv ( a , b ) NEW_LINE
import math NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = 1 << ( int ) ( math . floor ( math . log2 ( n ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT
def find_probability ( p , q , r , s ) : NEW_LINE INDENT t = ( 1 - p / q ) * ( 1 - r / s ) NEW_LINE ans = ( p / q ) / ( 1 - t ) ; NEW_LINE return round ( ans , 9 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT p , q , r , s = 1 , 2 , 1 , 2 NEW_LINE print ( find_probability ( p , q , r , s ) ) NEW_LINE DEDENT
def FindAllElements ( n , k ) : NEW_LINE INDENT sum = k NEW_LINE A = [ 1 for i in range ( k ) ] NEW_LINE i = k - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( sum + A [ i ] <= n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE A [ i ] *= 2 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( sum != n ) : NEW_LINE INDENT print ( " Impossible " ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , k , 1 ) : NEW_LINE INDENT print ( A [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 6 NEW_LINE FindAllElements ( n , k ) NEW_LINE DEDENT
def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isEqual ( a , b ) : NEW_LINE INDENT if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 105 NEW_LINE b = 106 NEW_LINE if ( isEqual ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def sumArray ( arr , n ) : NEW_LINE INDENT leftSum = [ 0 for i in range ( n ) ] NEW_LINE rightSum = [ 0 for i in range ( n ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE i , j = 0 , 0 NEW_LINE leftSum [ 0 ] = 0 NEW_LINE rightSum [ n - 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] = leftSum [ i ] + rightSum [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( Sum [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 3 , 6 , 4 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE sumArray ( arr , n ) NEW_LINE
import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i NEW_LINE sec = n // i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 // k ) * ( num1 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num1 , mini ) NEW_LINE DEDENT num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return mini NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE k = 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n = 5 NEW_LINE k = 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE DEDENT
def minimumX ( n , k ) : NEW_LINE INDENT ans = 10 ** 18 NEW_LINE for i in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans = min ( ans , i + ( n / i ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n , k = 4 , 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n , k = 5 , 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE
def getHermiteNumber ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE print ( getHermiteNumber ( n ) ) ; NEW_LINE
def find ( n ) : NEW_LINE INDENT b = n NEW_LINE a = b * ( n - 1 ) NEW_LINE if a * b > n and a // b < n : NEW_LINE INDENT print ( " a ▁ = ▁ { } , ▁ b ▁ = ▁ { } " . format ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE find ( n ) NEW_LINE DEDENT
from math import sqrt , floor NEW_LINE def isPerfect ( N ) : NEW_LINE INDENT if ( sqrt ( N ) - floor ( sqrt ( N ) ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def getClosestPerfectSquare ( N ) : NEW_LINE INDENT if ( isPerfect ( N ) ) : NEW_LINE INDENT print ( N , "0" ) NEW_LINE return NEW_LINE DEDENT aboveN = - 1 NEW_LINE belowN = - 1 NEW_LINE n1 = 0 NEW_LINE n1 = N + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPerfect ( n1 ) ) : NEW_LINE INDENT aboveN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT DEDENT n1 = N - 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPerfect ( n1 ) ) : NEW_LINE INDENT belowN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 -= 1 NEW_LINE DEDENT DEDENT diff1 = aboveN - N NEW_LINE diff2 = N - belowN NEW_LINE if ( diff1 > diff2 ) : NEW_LINE INDENT print ( belowN , diff2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( aboveN , diff1 ) NEW_LINE DEDENT DEDENT N = 1500 NEW_LINE getClosestPerfectSquare ( N ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lowest ( den3 , num3 ) : NEW_LINE INDENT common_factor = gcd ( num3 , den3 ) NEW_LINE den3 = int ( den3 / common_factor ) NEW_LINE num3 = int ( num3 / common_factor ) NEW_LINE print ( num3 , " / " , den3 ) NEW_LINE DEDENT def addFraction ( num1 , den1 , num2 , den2 ) : NEW_LINE INDENT den3 = gcd ( den1 , den2 ) NEW_LINE den3 = ( den1 * den2 ) / den3 NEW_LINE num3 = ( ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ) NEW_LINE lowest ( den3 , num3 ) NEW_LINE DEDENT num1 = 1 ; den1 = 500 NEW_LINE num2 = 2 ; den2 = 1500 NEW_LINE print ( num1 , " / " , den1 , " ▁ + ▁ " , num2 , " / " , den2 , " ▁ is ▁ equal ▁ to ▁ " , end = " " ) NEW_LINE addFraction ( num1 , den1 , num2 , den2 ) NEW_LINE
import math NEW_LINE def findLargestDivisor ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT while ( n % ( i * i ) == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE print ( findLargestDivisor ( n ) ) NEW_LINE n = 97 NEW_LINE print ( findLargestDivisor ( n ) ) NEW_LINE DEDENT
def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 15 , 5 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Yes " ) if ( checkIsAP ( arr , n ) ) else print ( " No " ) NEW_LINE
def isTriPerfect ( n ) : NEW_LINE INDENT sum = 1 + n NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == 3 * n and n != 1 else False ) NEW_LINE DEDENT n = 120 NEW_LINE if isTriPerfect ( n ) : NEW_LINE INDENT print ( n , " is ▁ a ▁ Triperfect ▁ number " ) NEW_LINE DEDENT
from math import ceil , floor NEW_LINE def sum ( N , X , Y ) : NEW_LINE INDENT S1 = floor ( floor ( N / X ) * floor ( 2 * X + floor ( N / X - 1 ) * X ) / 2 ) NEW_LINE S2 = floor ( floor ( N / Y ) ) * floor ( 2 * Y + floor ( N / Y - 1 ) * Y ) / 2 NEW_LINE S3 = floor ( floor ( N / ( X * Y ) ) ) * floor ( 2 * ( X * Y ) + floor ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 14 NEW_LINE X = 3 NEW_LINE Y = 5 NEW_LINE print ( int ( sum ( N , X , Y ) ) ) NEW_LINE DEDENT
def findTwoThreePrime ( l , r ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE while ( num % 2 == 0 ) : NEW_LINE INDENT num //= 2 ; NEW_LINE DEDENT while ( num % 3 == 0 ) : NEW_LINE INDENT num //= 3 NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE print ( findTwoThreePrime ( l , r ) ) NEW_LINE DEDENT
def getNumber ( s ) : NEW_LINE INDENT number_of_digits = len ( s ) ; NEW_LINE freq = [ 0 ] * 10 ; NEW_LINE for i in range ( number_of_digits ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '2' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 48 ] += 1 ; NEW_LINE DEDENT if ( s [ i ] == '4' ) : NEW_LINE INDENT freq [ 2 ] += 2 ; NEW_LINE freq [ 3 ] += 1 ; NEW_LINE DEDENT if ( s [ i ] == '6' ) : NEW_LINE INDENT freq [ 5 ] += 1 ; NEW_LINE freq [ 3 ] += 1 ; NEW_LINE DEDENT if ( s [ i ] == '8' ) : NEW_LINE INDENT freq [ 7 ] += 1 ; NEW_LINE freq [ 2 ] += 3 ; NEW_LINE DEDENT if ( s [ i ] == '9' ) : NEW_LINE INDENT freq [ 7 ] += 1 ; NEW_LINE freq [ 3 ] += 2 ; NEW_LINE freq [ 2 ] += 1 ; NEW_LINE DEDENT DEDENT t = " " ; NEW_LINE if ( freq [ 1 ] == number_of_digits or freq [ 0 ] == number_of_digits or ( freq [ 0 ] + freq [ 1 ] ) == number_of_digits ) : NEW_LINE INDENT return s ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 9 , 1 , - 1 ) : NEW_LINE INDENT ctr = freq [ i ] ; NEW_LINE while ( ctr > 0 ) : NEW_LINE INDENT t += chr ( i + 48 ) ; NEW_LINE ctr -= 1 ; NEW_LINE DEDENT DEDENT return t ; NEW_LINE DEDENT DEDENT s = "1280" ; NEW_LINE print ( getNumber ( s ) ) ; NEW_LINE
def reversedigit ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def icanobifNumbers ( N ) : NEW_LINE INDENT first = 0 NEW_LINE second = 1 NEW_LINE if N == 1 : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT print ( first , second ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( first , second , end = " ▁ " ) NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT x = reversedigit ( first ) NEW_LINE y = reversedigit ( second ) NEW_LINE print ( x + y , end = " ▁ " ) NEW_LINE temp = second NEW_LINE second = x + y NEW_LINE first = temp NEW_LINE DEDENT DEDENT DEDENT N = 12 NEW_LINE icanobifNumbers ( N ) NEW_LINE
def addNDigits ( a , b , n ) : NEW_LINE INDENT num = a NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT tmp = a * 10 + i NEW_LINE if ( tmp % b == 0 ) : NEW_LINE INDENT a = tmp NEW_LINE break NEW_LINE DEDENT DEDENT if ( num == a ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for j in range ( n - 1 ) : NEW_LINE INDENT a *= 10 NEW_LINE DEDENT return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 3 NEW_LINE print ( addNDigits ( a , b , n ) ) NEW_LINE DEDENT
import math NEW_LINE def Triplets ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = i * i + j * j NEW_LINE y = int ( math . sqrt ( x ) ) NEW_LINE if ( y * y == x and y <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( Triplets ( n ) ) NEW_LINE DEDENT
from math import floor NEW_LINE def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE sum = sum + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE N = floor ( n / 2 ) NEW_LINE for base in range ( 2 , N + 1 , 1 ) : NEW_LINE INDENT sum = sum + solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE DEDENT
import math NEW_LINE def checkPerfectcube ( n ) : NEW_LINE INDENT cube_root = n ** ( 1. / 3. ) NEW_LINE if round ( cube_root ) ** 3 == n : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def largestNonPerfectcubeNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 16 , 64 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectcubeNumber ( a , n ) ) NEW_LINE DEDENT
def checkIfPossibleRec ( x , a , b , isPossible , n ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return NEW_LINE DEDENT if isPossible [ x ] : NEW_LINE INDENT return NEW_LINE DEDENT isPossible [ x ] = True NEW_LINE checkIfPossibleRec ( x + a , a , b , isPossible , n ) NEW_LINE checkIfPossibleRec ( x + b , a , b , isPossible , n ) NEW_LINE DEDENT def checkPossible ( n , a , b ) : NEW_LINE INDENT isPossible = [ False ] * ( n + 1 ) NEW_LINE checkIfPossibleRec ( 0 , a , b , isPossible , n ) NEW_LINE return isPossible [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , n = 3 , 7 , 8 NEW_LINE if checkPossible ( a , b , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def sumOdd ( n ) : NEW_LINE INDENT terms = ( n + 1 ) // 2 NEW_LINE sum1 = terms * terms NEW_LINE return sum1 NEW_LINE DEDENT def suminRange ( l , r ) : NEW_LINE INDENT return sumOdd ( r ) - sumOdd ( l - 1 ) NEW_LINE DEDENT l = 2 ; r = 5 NEW_LINE print ( " Sum ▁ of ▁ odd ▁ natural ▁ number " , " from ▁ L ▁ to ▁ R ▁ is " , suminRange ( l , r ) ) NEW_LINE
from math import gcd , sqrt NEW_LINE def sumcommDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE sum = 0 NEW_LINE N = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT else : NEW_LINE INDENT sum += ( n / i ) + i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 15 NEW_LINE print ( " Sum ▁ = " , int ( sumcommDiv ( a , b ) ) ) NEW_LINE DEDENT
def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp /= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp /= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp /= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return " YES " NEW_LINE DEDENT DEDENT return " NO " NEW_LINE DEDENT N = 1414 ; NEW_LINE print ( checkNumber ( N ) ) ; NEW_LINE
def getResult ( n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT n = 3 NEW_LINE print ( getResult ( n ) ) NEW_LINE
from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - sqrt ( val ) ) / 2.0 NEW_LINE print ( " a ▁ = " , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( " b ▁ = " , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT
def minOperations ( A , n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zeros , consZeros , ones = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( i + 1 < n ) : NEW_LINE INDENT if A [ i ] == 0 and A [ i + 1 ] == 0 : NEW_LINE INDENT consZeros += 1 NEW_LINE DEDENT DEDENT DEDENT if A [ 0 ] == A [ n - 1 ] and A [ 0 ] == 0 : NEW_LINE INDENT consZeros += 1 NEW_LINE DEDENT if zeros == ones : NEW_LINE INDENT return consZeros NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 1 , 0 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minOperations ( A , n ) ) NEW_LINE DEDENT
def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m // 10 ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = pow ( 10 , digits ) NEW_LINE first = last // divisor NEW_LINE lastnumber = first * divisor NEW_LINE skipped = ( last - lastnumber ) // first NEW_LINE skipped += 1 NEW_LINE c += skipped NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 5 NEW_LINE b = 4 NEW_LINE n = 2 NEW_LINE print ( powerGCD ( a , b , n ) ) NEW_LINE DEDENT
def allOddDigits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def largestNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT i = n NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( allOddDigits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 23 NEW_LINE print ( largestNumber ( N ) ) NEW_LINE DEDENT
import math NEW_LINE def countNumbers ( N ) : NEW_LINE INDENT return int ( math . sqrt ( N ) ) - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 36 NEW_LINE print ( countNumbers ( N ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def countOrderedPairs ( N ) : NEW_LINE INDENT count_pairs = 0 NEW_LINE p = int ( sqrt ( N - 1 ) ) + 1 NEW_LINE q = int ( sqrt ( N ) ) + 2 NEW_LINE for i in range ( 1 , p , 1 ) : NEW_LINE INDENT for j in range ( i , q , 1 ) : NEW_LINE INDENT count_pairs += 1 NEW_LINE DEDENT DEDENT count_pairs *= 2 NEW_LINE count_pairs -= int ( sqrt ( N - 1 ) ) NEW_LINE return count_pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( countOrderedPairs ( N ) ) NEW_LINE DEDENT
def pairwiseDifference ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE print ( diff , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 10 , 15 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE pairwiseDifference ( arr , n ) NEW_LINE DEDENT
def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) ; NEW_LINE return ( n ) * ( 1 + n ) * ( d / 2 ) ; NEW_LINE DEDENT def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 ; NEW_LINE return ( int ( sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ) ) ; NEW_LINE DEDENT n = 20 ; NEW_LINE print ( sumMultiples ( n ) ) ; NEW_LINE
def markingScheme ( N , answerKey , studentAnswer ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 0 NEW_LINE notattempt = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( studentAnswer [ i ] == 0 ) : NEW_LINE INDENT notattempt += 1 NEW_LINE DEDENT elif ( answerKey [ i ] == studentAnswer [ i ] ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT elif ( answerKey [ i ] != studentAnswer [ i ] ) : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * 3 ) + ( negative * - 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT answerKey = [ 1 , 2 , 3 , 4 , 1 ] NEW_LINE studentAnswer = [ 1 , 2 , 3 , 4 , 0 ] NEW_LINE N = 5 NEW_LINE print ( markingScheme ( N , answerKey , studentAnswer ) ) NEW_LINE DEDENT
import math as mt NEW_LINE MAX = 10000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfErastosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( MAX ) ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( n ) : NEW_LINE INDENT count , num = 0 , 1 NEW_LINE prod = 1 NEW_LINE while count < n : NEW_LINE INDENT if prime [ num ] : NEW_LINE INDENT prod *= num NEW_LINE count += 1 NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return prod NEW_LINE DEDENT SieveOfErastosthenes ( ) NEW_LINE n = 5 NEW_LINE print ( solve ( n ) ) NEW_LINE
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT div_count = ( r // k ) - ( l // k ) NEW_LINE if l % k == 0 : NEW_LINE INDENT div_count += 1 NEW_LINE DEDENT return div_count > 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r , k = 30 , 70 , 10 NEW_LINE if Check_is_possible ( l , r , k ) == True : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE
def printPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 2 != 0 or a + b < c ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE c = 2 NEW_LINE printPossible ( a , b , c ) NEW_LINE DEDENT
def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 2 * n + 7 ) // 3 NEW_LINE DEDENT N = 5 NEW_LINE print ( Sum_upto_nth_Term ( N ) ) NEW_LINE
import sys NEW_LINE def CalculateDifference ( arr , n ) : NEW_LINE INDENT max_val = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= max_val ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT S1 = 0 NEW_LINE S2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT elif arr [ i ] != 1 : NEW_LINE INDENT S2 += arr [ i ] NEW_LINE DEDENT DEDENT return abs ( S2 - S1 ) NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 10 , 15 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CalculateDifference ( arr , n ) ) NEW_LINE
def numberOfDivisors ( num ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( numberOfDivisors ( i ) == 9 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1000 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def numberOfDistinct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE if ( ( n // i ) != i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( numberOfDistinct ( n ) ) NEW_LINE DEDENT
def NumberOfRectangles ( n , m ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * m NEW_LINE DEDENT elif ( m % 2 == 0 ) : NEW_LINE INDENT return ( m // 2 ) * n NEW_LINE DEDENT return ( n * m - 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE print ( NumberOfRectangles ( n , m ) ) NEW_LINE DEDENT
def findNumUtil ( res , a , aCount , b , bCount , n ) : NEW_LINE INDENT if ( res > 1e11 ) : NEW_LINE INDENT return 1e11 NEW_LINE DEDENT if ( aCount == bCount and res >= n ) : NEW_LINE INDENT return res NEW_LINE DEDENT return min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) NEW_LINE DEDENT def findNum ( n , a , b ) : NEW_LINE INDENT result = 0 NEW_LINE aCount = 0 NEW_LINE bCount = 0 NEW_LINE return findNumUtil ( result , a , aCount , b , bCount , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4500 NEW_LINE A = 4 NEW_LINE B = 7 NEW_LINE print ( findNum ( N , A , B ) ) NEW_LINE DEDENT
n , k = 7 , 3 NEW_LINE if ( n % k == 0 ) : NEW_LINE INDENT print ( n // k , n // k ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - n % k ) // k , ( n - n % k ) // k + 1 ) NEW_LINE DEDENT
import math as ma NEW_LINE m , n , x , h = 50 , 5 , 67 , 2927 NEW_LINE z = int ( ma . ceil ( h / 60 ) ) NEW_LINE if ( z <= n ) : NEW_LINE INDENT print ( z * m ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n * m + ( z - n ) * x ) NEW_LINE DEDENT
def sumProductDifference ( a , b , c , d , e ) : NEW_LINE INDENT rootSum = ( - 1 * b ) / a NEW_LINE rootProduct = e / a NEW_LINE return abs ( rootSum - rootProduct ) NEW_LINE DEDENT print ( sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ) NEW_LINE
def numberOfSolutions ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for x in range ( n + 1 ) : NEW_LINE INDENT if ( n == ( x + ( n ^ x ) ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( numberOfSolutions ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def minimumLecture ( m , n ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( n < math . ceil ( 0.75 * m ) ) : NEW_LINE INDENT ans = math . ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT M = 9 NEW_LINE N = 1 NEW_LINE print ( minimumLecture ( M , N ) ) NEW_LINE
def countNumbers ( N ) : NEW_LINE INDENT return ( pow ( 10 , N ) - pow ( 8 , N ) ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ) + n * ( n + 1 ) // 2 + 2 * ( n ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( " Sum ▁ = " , calculateSum ( n ) ) NEW_LINE DEDENT
def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( ( b * b ) - ( 4 * a * c ) ) > 0 : NEW_LINE INDENT print ( "2 ▁ solutions " ) NEW_LINE DEDENT elif ( ( b * b ) - ( 4 * a * c ) ) == 0 : NEW_LINE INDENT print ( "1 ▁ solution " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ solutions " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c = 2 , 5 , 2 NEW_LINE checkSolution ( a , b , c ) NEW_LINE DEDENT
def Bits ( kilobytes ) : NEW_LINE INDENT Bits = kilobytes * 8192 NEW_LINE return Bits NEW_LINE DEDENT def Bytes ( kilobytes ) : NEW_LINE INDENT Bytes = kilobytes * 1024 NEW_LINE return Bytes NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT kilobytes = 1 NEW_LINE print ( kilobytes , " Kilobytes ▁ = " , Bytes ( kilobytes ) , " Bytes ▁ and " , Bits ( kilobytes ) , " Bits " ) NEW_LINE DEDENT
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT x = sum // n NEW_LINE if ( x * n == sum ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( ( x ** 2 ) * ( x ** ( 2 * n ) - 1 ) ) // ( x ** 2 - 1 ) NEW_LINE sum2 = ( x * y * ( x ** n * y ** n - 1 ) ) // ( x * y - 1 ) NEW_LINE return ( sum1 + sum2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 2 NEW_LINE y = 2 NEW_LINE n = 2 NEW_LINE print ( sum ( x , y , n ) ) NEW_LINE DEDENT
def printPair ( g , l ) : NEW_LINE INDENT print ( g , l ) NEW_LINE DEDENT g = 3 ; l = 12 ; NEW_LINE printPair ( g , l ) ; NEW_LINE
def calculateSum ( n ) : NEW_LINE INDENT a1 = 1 ; NEW_LINE a2 = 2 ; NEW_LINE r = 2 ; NEW_LINE d = 1 ; NEW_LINE return ( ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( " Sum ▁ = " , int ( calculateSum ( n ) ) ) NEW_LINE
def ispower ( n ) : NEW_LINE INDENT if ( n < 125 ) : NEW_LINE INDENT return ( n == 1 or n == 5 or n == 25 ) NEW_LINE DEDENT if ( n % 125 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ispower ( n // 125 ) NEW_LINE DEDENT DEDENT def number ( s , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( i , j ) : NEW_LINE INDENT ans = ans * 2 + ( ord ( s [ x ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def minCuts ( s , n ) : NEW_LINE INDENT dp = [ n + 1 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT if ( s [ j ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT num = number ( s , j , i ) NEW_LINE if ( not ispower ( num ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] = min ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT if dp [ n ] < n + 1 : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "101101101" NEW_LINE n = len ( s ) NEW_LINE print ( minCuts ( s , n ) ) NEW_LINE DEDENT
def MinOfCubed ( k ) : NEW_LINE INDENT if ( k < 8 ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT res = k ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ( i * i * i ) > k ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT num = 15 ; NEW_LINE print ( MinOfCubed ( num ) ) ; NEW_LINE
import sys NEW_LINE def MinOfCubedDP ( k ) : NEW_LINE INDENT DP = [ 0 ] * ( k + 1 ) ; NEW_LINE j = 1 ; NEW_LINE t = 1 ; NEW_LINE DP [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT DP [ i ] = sys . maxsize ; NEW_LINE while ( j <= i ) : NEW_LINE INDENT if ( j == i ) : NEW_LINE INDENT DP [ i ] = 1 ; NEW_LINE DEDENT elif ( DP [ i ] > DP [ i - j ] ) : NEW_LINE INDENT DP [ i ] = DP [ i - j ] + 1 ; NEW_LINE DEDENT t += 1 ; NEW_LINE j = t * t * t ; NEW_LINE DEDENT t = j = 1 ; NEW_LINE DEDENT return DP [ k ] ; NEW_LINE DEDENT num = 15 ; NEW_LINE print ( MinOfCubedDP ( num ) ) ; NEW_LINE
def maxSum ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = a [ i - 1 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] NEW_LINE if i >= 2 : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) NEW_LINE DEDENT if i >= 2 : NEW_LINE INDENT dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] NEW_LINE DEDENT if i >= 3 : NEW_LINE INDENT dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) NEW_LINE DEDENT ans = max ( ans , dp [ i ] [ 0 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 1 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 2 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 5 , 3 , 2 , 7 , - 8 , 3 , 7 , - 9 , 10 , 12 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT
def MinimumCost ( a , n , x ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT a [ i ] = min ( a [ i ] , 2 * a [ i - 1 ] ) NEW_LINE DEDENT ind = 0 NEW_LINE sum = 0 NEW_LINE while ( x ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT sum += a [ ind ] NEW_LINE DEDENT ind += 1 NEW_LINE x = x >> 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 20 , 50 , 60 , 90 ] NEW_LINE x = 7 NEW_LINE n = len ( a ) NEW_LINE print ( MinimumCost ( a , n , x ) ) NEW_LINE DEDENT
def countWays ( n , l , r ) : NEW_LINE INDENT tL , tR = l , r NEW_LINE L = [ 0 for i in range ( 2 ) ] NEW_LINE R = [ 0 for i in range ( 2 ) ] NEW_LINE L [ l % 2 ] = l NEW_LINE R [ r % 2 ] = r NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE if ( l <= tR and r >= tL ) : NEW_LINE INDENT L [ l % 2 ] , R [ r % 2 ] = l , r NEW_LINE DEDENT cnt0 , cnt1 = 0 , 0 NEW_LINE if ( R [ 0 ] and L [ 0 ] ) : NEW_LINE INDENT cnt0 = ( R [ 0 ] - L [ 0 ] ) // 2 + 1 NEW_LINE DEDENT if ( R [ 1 ] and L [ 1 ] ) : NEW_LINE INDENT cnt1 = ( R [ 1 ] - L [ 1 ] ) // 2 + 1 NEW_LINE DEDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = cnt0 NEW_LINE dp [ 1 ] [ 1 ] = cnt1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) NEW_LINE dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) NEW_LINE DEDENT return dp [ n ] [ 0 ] NEW_LINE DEDENT n , l , r = 2 , 1 , 3 NEW_LINE print ( countWays ( n , l , r ) ) NEW_LINE
M = 1001 ; NEW_LINE MOD = 998244353 ; NEW_LINE dp = [ [ - 1 ] * M ] * M NEW_LINE def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( diff == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] ; NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) ; NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; NEW_LINE dp [ idx ] [ diff ] = ans % MOD ; NEW_LINE return dp [ idx ] [ diff ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 0 NEW_LINE print ( M * solve ( 2 , 0 , N , M , K ) ) NEW_LINE DEDENT
N = 3 NEW_LINE def maxPathSum ( tri ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , N - i ) : NEW_LINE INDENT if ( j - 1 >= 0 ) : NEW_LINE INDENT tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; NEW_LINE DEDENT ans = max ( ans , tri [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT tri = [ [ 1 , 5 , 3 ] , [ 4 , 8 , 0 ] , [ 1 , 0 , 0 ] ] NEW_LINE print ( maxPathSum ( tri ) ) NEW_LINE
from math import log2 NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for k in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE DEDENT
def get_max_splits ( num_string ) : NEW_LINE INDENT count = 0 NEW_LINE running_sum = 0 NEW_LINE for i in range ( len ( num_string ) ) : NEW_LINE INDENT current_num = int ( num_string [ i ] ) NEW_LINE running_sum += current_num NEW_LINE if current_num % 3 == 0 or ( running_sum != 0 and running_sum % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT print get_max_splits ( "12345" ) NEW_LINE
def findMinimumCost ( n , x , y ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] = x NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i & 1 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) // 2 ] + y + x ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ i // 2 ] + y ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT n , x , y = 4 , 2 , 1 NEW_LINE print ( findMinimumCost ( n , x , y ) ) NEW_LINE
def nCr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE if r > n - r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT ans *= ( n - i ) NEW_LINE ans /= ( i + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def countDerangements ( n ) : NEW_LINE INDENT der = [ 0 for i in range ( n + 3 ) ] NEW_LINE der [ 0 ] = 1 NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT def countPermutations ( n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - k , n + 1 ) : NEW_LINE INDENT ways = nCr ( n , i ) NEW_LINE ans += ways * countDerangements ( n - i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n , k = 5 , 3 NEW_LINE print ( countPermutations ( n , k ) ) NEW_LINE
def squares ( i ) : NEW_LINE INDENT if ( ( i & 1 ) == 1 ) : NEW_LINE INDENT return int ( i / 4 ) * 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( i - 1 ) / 4 ) * 2 + 2 NEW_LINE DEDENT DEDENT def bishop_placements ( n , k ) : NEW_LINE INDENT if ( k > 2 * n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n * 2 ) ] NEW_LINE for i in range ( n * 2 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n * 2 , 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 0 , k + 1 , 1 ) : NEW_LINE INDENT ans += ( dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE k = 2 NEW_LINE ans = bishop_placements ( n , k ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def countStaircases ( N ) : NEW_LINE INDENT memo = [ [ 0 for x in range ( N + 5 ) ] for y in range ( N + 5 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT memo [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 NEW_LINE for i in range ( 5 , N + 1 ) : NEW_LINE INDENT for j in range ( 2 , i + 1 ) : NEW_LINE INDENT if ( j == 2 ) : NEW_LINE INDENT memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT memo [ i ] [ j ] = ( memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT answer = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT answer = answer + memo [ N ] [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 7 NEW_LINE print ( countStaircases ( N ) ) NEW_LINE DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT if m == 1 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE m = 5 NEW_LINE print ( countPaths ( n , m ) ) NEW_LINE DEDENT
def countPaths ( m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i == 1 or j == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE m = 5 NEW_LINE print ( countPaths ( n , m ) ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) ; NEW_LINE res /= ( i + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) ; NEW_LINE return int ( c / ( n + 1 ) ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( catalan ( n ) ) ; NEW_LINE
def alternateFib ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT f1 = 0 ; NEW_LINE f2 = 1 ; NEW_LINE print ( f1 , end = " ▁ " ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f3 = f2 + f1 ; NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT print ( f3 , end = " ▁ " ) ; NEW_LINE DEDENT f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE DEDENT DEDENT N = 15 ; NEW_LINE alternateFib ( N ) ; NEW_LINE
def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT
MAX = 100 ; NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] ; NEW_LINE DEDENT DEDENT return C [ k ] ; NEW_LINE DEDENT def sumOfproduct ( n ) : NEW_LINE INDENT return binomialCoeff ( 2 * n , n - 1 ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( sumOfproduct ( n ) ) ; NEW_LINE
def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE print ( c , end = ' ▁ ' ) NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT DEDENT fib ( 9 ) NEW_LINE
def pre_compute ( a , n , index , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ 0 ] : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ j ] > a [ i ] and j > i : NEW_LINE INDENT if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ index ] [ k ] NEW_LINE DEDENT a = [ 1 , 101 , 2 , 3 , 100 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE index = 4 NEW_LINE k = 6 NEW_LINE print ( pre_compute ( a , n , index , k ) ) NEW_LINE
def gen ( n ) : NEW_LINE INDENT S = [ 0 , 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT S . append ( 4 * S [ int ( i / 2 ) ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT S . append ( 4 * S [ int ( i / 2 ) ] + 1 ) ; NEW_LINE DEDENT DEDENT z = S [ n ] ; NEW_LINE return z ; NEW_LINE DEDENT def moserDeBruijn ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( gen ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE print ( " First " , n , " terms ▁ of ▁ " , " Moser - de ▁ Brujn ▁ Sequence : " ) NEW_LINE moserDeBruijn ( n ) NEW_LINE
import numpy as np NEW_LINE def LCSubStr ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE result = 0 NEW_LINE len_mat = np . zeros ( ( 2 , n ) ) NEW_LINE currRow = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 j == 0 ) : NEW_LINE INDENT len_mat [ currRow ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1 NEW_LINE result = max ( result , len_mat [ currRow ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT len_mat [ currRow ] [ j ] = 0 NEW_LINE DEDENT DEDENT currRow = 1 - currRow NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = " GeeksforGeeks " NEW_LINE Y = " GeeksQuiz " NEW_LINE print ( LCSubStr ( X , Y ) ) NEW_LINE DEDENT
INT_MAX = 100000000 NEW_LINE def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ INT_MAX for i in range ( n ) ] NEW_LINE s1 = " " NEW_LINE s2 = " " NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 + i + 1 ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT s = " aaaaaaaa " NEW_LINE n = len ( s ) NEW_LINE print ( minimalSteps ( s , n ) ) NEW_LINE
def Golomb ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 1 ] = 1 NEW_LINE print ( dp [ 1 ] , end = " ▁ " ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] NEW_LINE print ( dp [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE Golomb ( n ) NEW_LINE
def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT s = "11000010001" NEW_LINE n = 11 NEW_LINE print ( findLength ( s , n ) ) NEW_LINE
DP_s = 9 NEW_LINE def getNumStrictMonotone ( ln ) : NEW_LINE INDENT DP = [ [ 0 ] * DP_s for _ in range ( ln ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT print ( getNumStrictMonotone ( 2 ) ) NEW_LINE
def chordCnt ( A ) : NEW_LINE INDENT n = 2 * A NEW_LINE dpArray = [ 0 ] * ( n + 1 ) NEW_LINE dpArray [ 0 ] = 1 NEW_LINE dpArray [ 2 ] = 1 NEW_LINE for i in range ( 4 , n + 1 , 2 ) : NEW_LINE INDENT for j in range ( 0 , i - 1 , 2 ) : NEW_LINE INDENT dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) NEW_LINE DEDENT DEDENT return int ( dpArray [ n ] ) NEW_LINE DEDENT N = 2 NEW_LINE print ( chordCnt ( N ) ) NEW_LINE N = 1 NEW_LINE print ( chordCnt ( N ) ) NEW_LINE N = 4 NEW_LINE print ( chordCnt ( N ) ) NEW_LINE
row = 5 NEW_LINE col = 5 NEW_LINE def isPath ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , row ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ 0 ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , row ) : NEW_LINE INDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ row - 1 ] [ col - 1 ] == 1 ) NEW_LINE DEDENT arr = [ [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , 0 , - 1 , - 1 ] , [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , - 1 , 0 , - 1 ] , [ 0 , 0 , - 1 , 0 , 0 ] ] NEW_LINE if ( isPath ( arr ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def nswp ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( nswp ( n ) ) NEW_LINE
def nswp ( n ) : NEW_LINE INDENT dp = [ 1 for x in range ( n + 1 ) ] ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; NEW_LINE DEDENT return dp [ n ] ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( nswp ( n ) ) ; NEW_LINE
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( ord ( X [ i - 1 ] ) - 48 ) NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT def findMinCost ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE cost = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT cost += ord ( X [ i ] ) - 48 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT cost += ord ( Y [ i ] ) - 48 NEW_LINE DEDENT ans = cost - lcs ( X , Y , m , n ) NEW_LINE return ans NEW_LINE DEDENT X = "3759" NEW_LINE Y = "9350" NEW_LINE print ( " Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ " , " identical ▁ is ▁ = ▁ " , findMinCost ( X , Y ) ) NEW_LINE
def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( l , n ) : NEW_LINE INDENT i += 1 NEW_LINE if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT s = " ( ) ( ( ( ( ( ( ) " NEW_LINE n = len ( s ) NEW_LINE print ( maxLength ( s , n ) ) NEW_LINE
import sys NEW_LINE def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT min_ending_here = sys . maxsize NEW_LINE min_so_far = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min_ending_here > 0 ) : NEW_LINE INDENT min_ending_here = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT min_ending_here += arr [ i ] NEW_LINE DEDENT min_so_far = min ( min_so_far , min_ending_here ) NEW_LINE DEDENT return min_so_far NEW_LINE DEDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print " Smallest ▁ sum : ▁ " , smallestSumSubarr ( arr , n ) NEW_LINE
def countWays ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 1000000007 NEW_LINE same , diff = 0 , k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = total * ( k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = ( same + diff ) % mod NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 3 , 2 NEW_LINE print ( countWays ( n , k ) ) NEW_LINE DEDENT
def sumOfSubstrings ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE INDENT mf = 1 NEW_LINE for i in range ( len ( num ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( int ( num [ i ] ) ) * ( i + 1 ) * mf NEW_LINE mf = mf * 10 + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = "6759" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE DEDENT
def maxSumWithK ( a , n , k ) : NEW_LINE INDENT maxSum = [ 0 for i in range ( n ) ] NEW_LINE maxSum [ 0 ] = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE maxSum [ i ] = curr_max NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT result = sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + a [ i ] - a [ i - k ] NEW_LINE result = max ( result , sum ) NEW_LINE result = max ( result , sum + maxSum [ i - k ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT a = [ 1 , 2 , 3 , - 10 , - 3 ] NEW_LINE k = 4 NEW_LINE n = len ( a ) NEW_LINE print ( maxSumWithK ( a , n , k ) ) NEW_LINE
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 10 NEW_LINE n = 4 NEW_LINE print ( ' Total ▁ number ▁ of ▁ possible ▁ sequences : ' , getTotalNumberOfSequences ( m , n ) ) NEW_LINE DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif i < j : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif j == 1 : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 10 NEW_LINE n = 4 NEW_LINE print ( ' Total ▁ number ▁ of ▁ possible ▁ sequences ▁ ' , getTotalNumberOfSequences ( m , n ) ) NEW_LINE DEDENT
def lis ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE lis = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( result < lis [ i ] ) : NEW_LINE INDENT result = lis [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def minimumNumberOfDeletions ( arr , n ) : NEW_LINE INDENT len = lis ( arr , n ) NEW_LINE return ( n - len ) NEW_LINE DEDENT arr = [ 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ " , minimumNumberOfDeletions ( arr , n ) ) NEW_LINE
' NEW_LINE def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( str [ i ] == str [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT def minimumNumberOfDeletions ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE l = lps ( str ) NEW_LINE return ( n - l ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE print ( " Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ " , minimumNumberOfDeletions ( str ) ) NEW_LINE DEDENT
def offeringNumber ( n , templeHeight ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = 0 NEW_LINE right = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum += max ( right , left ) + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT arr1 = [ 1 , 2 , 2 ] NEW_LINE print ( offeringNumber ( 3 , arr1 ) ) NEW_LINE arr2 = [ 1 , 4 , 3 , 6 , 2 , 1 ] NEW_LINE print ( offeringNumber ( 6 , arr2 ) ) NEW_LINE
def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT arr = [ 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE m = 5 NEW_LINE print ( " YES " ) if ( modularSum ( arr , n , m ) ) else print ( " NO " ) NEW_LINE
def maxSum ( tri , n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] NEW_LINE tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] NEW_LINE tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] NEW_LINE for j in range ( 1 , i ) : NEW_LINE INDENT if tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] : NEW_LINE INDENT tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print max ( tri [ n - 1 ] ) NEW_LINE DEDENT tri = [ [ 1 ] , [ 2 , 1 ] , [ 3 , 3 , 2 ] ] NEW_LINE maxSum ( tri , 3 ) NEW_LINE
def maximumDifferenceSum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 , 0 ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE print ( maximumDifferenceSum ( arr , N ) ) NEW_LINE DEDENT
N = 8 NEW_LINE dx = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] NEW_LINE dy = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] NEW_LINE def inside ( x , y ) : NEW_LINE INDENT return ( x >= 0 and x < N and y >= 0 and y < N ) NEW_LINE DEDENT def findProb ( start_x , start_y , steps ) : NEW_LINE INDENT dp1 = [ [ [ 0 for i in range ( N + 5 ) ] for j in range ( N + 5 ) ] for k in range ( steps + 5 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT dp1 [ i ] [ j ] [ 0 ] = 1 NEW_LINE DEDENT DEDENT for s in range ( 1 , steps + 1 ) : NEW_LINE INDENT for x in range ( N ) : NEW_LINE INDENT for y in range ( N ) : NEW_LINE INDENT prob = 0.0 NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT nx = x + dx [ i ] NEW_LINE ny = y + dy [ i ] NEW_LINE if ( inside ( nx , ny ) ) : NEW_LINE INDENT prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 NEW_LINE DEDENT DEDENT dp1 [ x ] [ y ] [ s ] = prob NEW_LINE DEDENT DEDENT DEDENT return dp1 [ start_x ] [ start_y ] [ steps ] NEW_LINE DEDENT K = 3 NEW_LINE print ( findProb ( 0 , 0 , K ) ) NEW_LINE
def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i = i + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT s = s + ( ( count * ( count + 1 ) ) // 2 ) NEW_LINE DEDENT return ( n * ( n + 1 ) // 2 - s ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n , k ) ) NEW_LINE
def nCr ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def resultOfAllSubsets ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for n in range ( 1 , N + 1 ) : NEW_LINE INDENT result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE print ( resultOfAllSubsets ( arr , N ) ) NEW_LINE
arr = [ 100 , 1000 , 100 , 1000 , 1 ] NEW_LINE sum = [ - 1 ] * 10000 NEW_LINE def maxSumWO3Consec ( n ) : NEW_LINE INDENT if ( sum [ n ] != - 1 ) : NEW_LINE INDENT return sum [ n ] NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT sum [ n ] = 0 NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT sum [ n ] = arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT sum [ n ] = arr [ 1 ] + arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) NEW_LINE return sum [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = len ( arr ) NEW_LINE print ( maxSumWO3Consec ( n ) ) NEW_LINE DEDENT
def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : NEW_LINE INDENT maxSum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] < k ) : NEW_LINE INDENT maxSum += arr [ i ] NEW_LINE maxSum += arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return maxSum NEW_LINE DEDENT arr = [ 3 , 5 , 10 , 15 , 17 , 12 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE K = 4 NEW_LINE print ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) NEW_LINE
def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum = sum + int ( num [ i ] ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res = res + countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = "1119" NEW_LINE len = len ( num ) NEW_LINE print ( countGroups ( 0 , 0 , len , num ) ) NEW_LINE DEDENT
def count ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( m + 1 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return lookup [ m ] [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = " GeeksforGeeks " NEW_LINE b = " Gks " NEW_LINE print ( count ( a , b ) ) NEW_LINE DEDENT
def lcs ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] NEW_LINE bi = bool NEW_LINE for i in range ( m ) : NEW_LINE INDENT bi = i & 1 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ bi ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ bi ] [ n ] NEW_LINE DEDENT X = " AGGTAB " NEW_LINE Y = " GXTXAYB " NEW_LINE print ( " Length ▁ of ▁ LCS ▁ is " , lcs ( X , Y ) ) NEW_LINE
import math NEW_LINE def subsetXOR ( arr , n , k ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max_ele : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( int ) ( math . log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE if ( k > m ) : NEW_LINE return 0 NEW_LINE dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( " Count ▁ of ▁ subsets ▁ is " , subsetXOR ( arr , n , k ) ) NEW_LINE
def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT coeff = [ 2 , 2 , 5 ] NEW_LINE rhs = 4 NEW_LINE n = len ( coeff ) NEW_LINE print ( countSol ( coeff , 0 , n - 1 , rhs ) ) NEW_LINE
import sys NEW_LINE def steps ( source , step , dest ) : NEW_LINE INDENT if ( abs ( source ) > ( dest ) ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( source == dest ) : NEW_LINE INDENT return step NEW_LINE DEDENT pos = steps ( source + step + 1 , step + 1 , dest ) NEW_LINE neg = steps ( source - step - 1 , step + 1 , dest ) NEW_LINE return min ( pos , neg ) NEW_LINE DEDENT dest = 11 ; NEW_LINE print ( " No . ▁ of ▁ steps ▁ required " , " ▁ to ▁ reach ▁ " , dest , " ▁ is ▁ " , steps ( 0 , 0 , dest ) ) ; NEW_LINE
def lcs ( i , j , count ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT count = lcs ( i - 1 , j - 1 , count + 1 ) NEW_LINE DEDENT count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) NEW_LINE return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = " abcdxyz " NEW_LINE Y = " xyzabcd " NEW_LINE n = len ( X ) NEW_LINE m = len ( Y ) NEW_LINE print ( lcs ( n , m , 0 ) ) NEW_LINE DEDENT
from math import pow NEW_LINE ' NEW_LINE def no_of_characters ( M ) : NEW_LINE INDENT k = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( pow ( 2 , k + 1 ) - 2 < M ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT ' NEW_LINE def print_string ( M ) : NEW_LINE INDENT k = no_of_characters ( M ) NEW_LINE N = M - ( pow ( 2 , k ) - 2 ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT num = pow ( 2 , k - 1 ) NEW_LINE if ( num >= N ) : NEW_LINE INDENT print ( " A " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " B " , end = " " ) NEW_LINE N -= num NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT print ( " " , ▁ end ▁ = ▁ " " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 30 ; NEW_LINE print_string ( M ) NEW_LINE M = 55 NEW_LINE print_string ( M ) NEW_LINE M = 100 NEW_LINE print_string ( M ) NEW_LINE DEDENT
def updateString ( S , A , B ) : NEW_LINE INDENT l = len ( A ) NEW_LINE i = 0 NEW_LINE while i + l <= len ( S ) : NEW_LINE INDENT curr = S [ i : i + l ] NEW_LINE if curr == A : NEW_LINE INDENT new_string = S [ 0 : i ] + B + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_string = S [ 0 : i ] + A + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return S NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = " aab " NEW_LINE A = " aa " NEW_LINE B = " bb " NEW_LINE print ( updateString ( S , A , B ) ) NEW_LINE DEDENT
def printPattern ( n , m ) : NEW_LINE INDENT if ( m > 2 * ( n + 1 ) or m < n - 1 ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE DEDENT elif ( abs ( n - m ) <= 1 ) : NEW_LINE INDENT while ( n > 0 and m > 0 ) : NEW_LINE INDENT print ( "01" , end = " " ) ; NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE DEDENT if ( n != 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT if ( m != 0 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( m - n > 1 and n > 0 ) : NEW_LINE INDENT print ( "110" , end = " " ) NEW_LINE m = m - 2 NEW_LINE n = n - 1 NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT print ( "10" , end = " " ) NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE DEDENT while ( m > 0 ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE m -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE m = 8 NEW_LINE printPattern ( n , m ) NEW_LINE DEDENT
def countDecreasing ( A , n ) : NEW_LINE INDENT len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) ; NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 100 , 3 , 1 , 13 ] NEW_LINE n = len ( A ) NEW_LINE print ( countDecreasing ( A , n ) ) NEW_LINE DEDENT
import sys NEW_LINE def minimumChar ( S1 , S2 ) : NEW_LINE INDENT n , m = len ( S1 ) , len ( S2 ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( m - n + 1 ) : NEW_LINE INDENT minRemovedChar = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( S1 [ j ] != S2 [ i + j ] ) : NEW_LINE INDENT minRemovedChar += 1 NEW_LINE DEDENT DEDENT ans = min ( minRemovedChar , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S1 = " abc " NEW_LINE S2 = " paxzk " NEW_LINE print ( minimumChar ( S1 , S2 ) ) NEW_LINE DEDENT
def countFreq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE res = 0 NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < M : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT res += 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT txt = " dhimanman " NEW_LINE pat = " man " NEW_LINE print ( countFreq ( pat , txt ) ) NEW_LINE DEDENT
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while i <= N - M : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE print " Pattern ▁ found ▁ at ▁ index ▁ " + str ( i ) NEW_LINE i = i + M NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT txt = " ABCEABCDABCEABCD " NEW_LINE pat = " ABCD " NEW_LINE search ( pat , txt ) NEW_LINE
def printMatrix ( n , m ) : NEW_LINE INDENT if ( n < 5 or m < 5 ) : NEW_LINE INDENT print ( - 1 , end = " ▁ " ) ; NEW_LINE return ; NEW_LINE DEDENT s = " aeiou " ; NEW_LINE s = list ( s ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT print ( s [ j % 5 ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) NEW_LINE c = s [ 0 ] ; NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT s [ i ] = s [ i + 1 ] ; NEW_LINE DEDENT s [ 4 ] = c ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; m = 5 ; NEW_LINE printMatrix ( n , m ) ; NEW_LINE DEDENT
def minOperations ( n , a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE y = b [ i ] NEW_LINE z = c [ i ] NEW_LINE if ( x == y and y == z ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( x == y or y == z or x == z ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = " place " NEW_LINE b = " abcde " NEW_LINE c = " plybe " NEW_LINE n = len ( a ) NEW_LINE print ( minOperations ( n , a , b , c ) ) NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countSubStr ( str , n , x ) : NEW_LINE INDENT res = 0 ; count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT res += ( ( count + 1 ) * ( n - i ) ) ; NEW_LINE count = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT str = " abcabc " ; NEW_LINE n = len ( str ) ; NEW_LINE x = ' c ' ; NEW_LINE print ( countSubStr ( str , n , x ) ) ; NEW_LINE
def countSubStr ( string , n ) : NEW_LINE INDENT length = len ( string ) ; NEW_LINE return ( length - n + 1 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " ; NEW_LINE n = 5 ; NEW_LINE print ( countSubStr ( string , n ) ) ; NEW_LINE DEDENT
def countSubstrings ( s , c ) : NEW_LINE INDENT n = len ( s ) NEW_LINE cnt = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != c ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Sum += ( cnt * ( cnt + 1 ) ) // 2 NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT Sum += ( cnt * ( cnt + 1 ) ) // 2 NEW_LINE return Sum NEW_LINE DEDENT s = " baa " NEW_LINE c = ' b ' NEW_LINE print ( countSubstrings ( s , c ) ) NEW_LINE
def isPalindrome ( s ) : NEW_LINE INDENT i = 0 ; NEW_LINE j = len ( s ) - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] is not s [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = " " ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + S1 [ i ] ; NEW_LINE Temp = " " ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT Temp += S2 [ j ] ; NEW_LINE DEDENT if ( isPalindrome ( S + Temp ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT S1 = " abcdf " ; S2 = " sfgba " ; NEW_LINE n = len ( S1 ) ; NEW_LINE print ( getIndex ( S1 , S2 , n ) ) ; NEW_LINE
def valid ( cnt ) : NEW_LINE INDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if cnt [ i ] >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def getGoodString ( s , n ) : NEW_LINE INDENT if n < 26 : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT for i in range ( 25 , n ) : NEW_LINE INDENT cnt = [ 0 ] * 26 NEW_LINE for j in range ( i , i - 26 , - 1 ) : NEW_LINE INDENT if s [ j ] != ' ? ' : NEW_LINE INDENT cnt [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT if valid ( cnt ) : NEW_LINE INDENT cur = 0 NEW_LINE while cur < 26 and cnt [ cur ] > 0 : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT for j in range ( i - 25 , i + 1 ) : NEW_LINE INDENT if s [ j ] == ' ? ' : NEW_LINE INDENT s [ j ] = chr ( cur + ord ( ' a ' ) ) NEW_LINE cur += 1 NEW_LINE while cur < 26 and cnt [ cur ] > 0 : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcdefghijkl ? nopqrstuvwxy ? " NEW_LINE n = len ( s ) NEW_LINE print ( getGoodString ( list ( s ) , n ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT c = c . lower ( ) ; NEW_LINE if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def swapRepeated ( string ) : NEW_LINE INDENT for i in range ( len ( string ) - 1 ) : NEW_LINE INDENT if ( ( isVowel ( string [ i ] ) and isVowel ( string [ i + 1 ] ) ) or ( not ( isVowel ( string [ i ] ) ) and not ( isVowel ( string [ i + 1 ] ) ) ) ) : NEW_LINE INDENT ( string [ i ] , string [ i + 1 ] ) = ( string [ i + 1 ] , string [ i ] ) ; NEW_LINE DEDENT DEDENT string = " " . join ( string ) NEW_LINE return string ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " ; NEW_LINE print ( swapRepeated ( list ( string ) ) ) ; NEW_LINE DEDENT
def largestPalinSub ( s ) : NEW_LINE INDENT res = " " NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT
def printString ( Str1 , n ) : NEW_LINE INDENT ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '1' ) : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT used = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '2' and used == False ) : NEW_LINE INDENT used = 1 NEW_LINE for j in range ( ones ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT DEDENT if ( Str1 [ i ] != '1' ) : NEW_LINE INDENT print ( Str1 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if ( used == False ) : NEW_LINE INDENT for j in range ( ones ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT Str1 = "100210" NEW_LINE n = len ( Str1 ) NEW_LINE printString ( Str1 , n ) NEW_LINE
import math as mt NEW_LINE def findPermutation ( string , k ) : NEW_LINE INDENT has = [ False for i in range ( 26 ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( has [ ord ( string [ i ] ) - ord ( ' a ' ) ] == False ) : NEW_LINE INDENT cnt += 1 NEW_LINE has [ ord ( string [ i ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 2 , cnt + 1 ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT for i in range ( cnt - k , 1 , - 1 ) : NEW_LINE INDENT ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT string = " geeksforgeeks " NEW_LINE k = 4 NEW_LINE print ( findPermutation ( string , k ) ) NEW_LINE
def product ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x ) : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x //= 10 ; NEW_LINE DEDENT return prod NEW_LINE DEDENT def findNumber ( l , r ) : NEW_LINE INDENT a = str ( l ) ; NEW_LINE b = str ( r ) ; NEW_LINE ans = r NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if ( b [ i ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT curr = list ( b ) NEW_LINE curr [ i ] = str ( ( ( ord ( curr [ i ] ) - ord ( '0' ) ) - 1 ) + ord ( '0' ) ) NEW_LINE for j in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr [ j ] = str ( ord ( '9' ) ) NEW_LINE DEDENT num = 0 NEW_LINE for c in curr : NEW_LINE INDENT num = num * 10 + ( int ( c ) - ord ( '0' ) ) NEW_LINE DEDENT if ( num >= l and product ( ans ) < product ( num ) ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r = 1 , 10 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE l , r = 51 , 62 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE DEDENT
def constructBinString ( a , b , x ) : NEW_LINE INDENT d = x // 2 NEW_LINE if x % 2 == 0 and x // 2 != a : NEW_LINE INDENT d -= 1 NEW_LINE print ( "0" , end = " " ) NEW_LINE a -= 1 NEW_LINE DEDENT for i in range ( d ) : NEW_LINE INDENT print ( "10" , end = " " ) NEW_LINE DEDENT a = a - d NEW_LINE b = b - d NEW_LINE for i in range ( b ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT for i in range ( a ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , x = 4 , 3 , 2 NEW_LINE constructBinString ( a , b , x ) NEW_LINE DEDENT
def matchPattern ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n and s [ i ] == ' a ' ) : NEW_LINE INDENT count += 1 ; NEW_LINE i = + 1 ; NEW_LINE DEDENT while ( i < n and s [ i ] == ' b ' ) : NEW_LINE INDENT count -= 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT if ( count != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT s = " bb " ; NEW_LINE if ( matchPattern ( s ) == True ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE cnt , max_cnt = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT right [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT sum = left [ i - 1 ] + right [ i + 1 ] NEW_LINE if ( sum < cnt_one ) : NEW_LINE INDENT max_cnt = max ( max_cnt , sum + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , sum ) NEW_LINE DEDENT DEDENT DEDENT return max_cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "111011101" NEW_LINE print ( maximum_one ( s , len ( s ) ) ) NEW_LINE DEDENT
def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 for i in range ( 10 ) ] NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT a = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE fre [ a ] += 1 NEW_LINE DEDENT if ( fre [ a ] == 0 and fre [ b ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( fre [ a ] >= fre [ b ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 7 NEW_LINE s = "47744" NEW_LINE print ( maxFreq ( s , a , b ) ) NEW_LINE DEDENT
def convert ( n , a , b ) : NEW_LINE INDENT l = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT l [ i ] = 1 NEW_LINE DEDENT DEDENT cc = 0 NEW_LINE vl = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( l [ i ] == 0 ) : NEW_LINE INDENT if ( vl != 0 ) : NEW_LINE INDENT cc += 1 NEW_LINE DEDENT vl = 0 NEW_LINE DEDENT else : NEW_LINE INDENT vl += 1 NEW_LINE DEDENT DEDENT if ( vl != 0 ) : NEW_LINE INDENT cc += 1 NEW_LINE DEDENT print ( cc ) NEW_LINE DEDENT a = "101010" NEW_LINE b = "110011" NEW_LINE n = len ( a ) NEW_LINE convert ( n , a , b ) NEW_LINE
def countWays ( s1 , s2 , n ) : NEW_LINE INDENT a = b = c = d = 0 NEW_LINE result = 0 ; NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s2 [ i ] == '0' ) : NEW_LINE INDENT if ( s1 [ i ] == '0' ) : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s1 [ i ] == '0' ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT DEDENT result = a * d + b * c + c * d NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s1 = "01011" NEW_LINE s2 = "11001" NEW_LINE print ( countWays ( s1 , s2 , n ) ) NEW_LINE DEDENT
def returnWinner ( s , l ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( 0 , l , 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt == 0 or cnt & 1 == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " abaaab " NEW_LINE l = len ( s ) NEW_LINE winner = returnWinner ( s , l ) NEW_LINE print ( " Player - " , winner ) NEW_LINE DEDENT
import sys NEW_LINE def maxProductSum ( string , m ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxProd , maxSum = ( - ( sys . maxsize ) - 1 , - ( sys . maxsize ) - 1 ) NEW_LINE for i in range ( n - m + 1 ) : NEW_LINE INDENT product , sum = 1 , 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( " Maximum ▁ Product ▁ = " , maxProd ) NEW_LINE print ( " Maximum ▁ sum ▁ = " , maxSum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "3605356297" NEW_LINE m = 3 NEW_LINE maxProductSum ( string , m ) NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE def maxLength ( s , n ) : NEW_LINE INDENT right = 0 NEW_LINE left = 0 NEW_LINE coun = 0 NEW_LINE max_length = - ( sys . maxsize - 1 ) NEW_LINE s = s + '1' NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if s [ i ] == ' o ' : NEW_LINE INDENT coun += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if coun > max_length : NEW_LINE INDENT right = 0 NEW_LINE left = 0 NEW_LINE if s [ i ] == ' x ' : NEW_LINE INDENT right = 1 NEW_LINE DEDENT if i - coun > 0 and s [ i - coun - 1 ] == ' x ' : NEW_LINE INDENT left = 1 NEW_LINE DEDENT coun = math . ceil ( float ( coun / ( right + left ) ) ) NEW_LINE max_length = max ( max_length , coun ) NEW_LINE DEDENT coun = 0 NEW_LINE DEDENT DEDENT return max_length NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " oooxoooooooooxooo " NEW_LINE n = len ( s ) NEW_LINE print ( maxLength ( s , n ) ) NEW_LINE DEDENT
def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT if s [ i ] < c : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbbddeecc " NEW_LINE if areVowelsInOrder ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "13589234356546756" NEW_LINE R = 13 NEW_LINE print ( Remainder ( str , R ) ) NEW_LINE DEDENT
def count_carry ( a , b ) : NEW_LINE INDENT carry = 0 ; NEW_LINE count = 0 ; NEW_LINE len_a = len ( a ) ; NEW_LINE len_b = len ( b ) ; NEW_LINE while ( len_a != 0 or len_b != 0 ) : NEW_LINE INDENT x = 0 ; NEW_LINE y = 0 ; NEW_LINE if ( len_a > 0 ) : NEW_LINE INDENT x = int ( a [ len_a - 1 ] ) + int ( '0' ) ; NEW_LINE len_a -= 1 ; NEW_LINE DEDENT if ( len_b > 0 ) : NEW_LINE INDENT y = int ( b [ len_b - 1 ] ) + int ( '0' ) ; NEW_LINE len_b -= 1 ; NEW_LINE DEDENT sum = x + y + carry ; NEW_LINE if ( sum >= 10 ) : NEW_LINE INDENT carry = 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT a = "9555" ; NEW_LINE b = "555" ; NEW_LINE count = count_carry ( a , b ) ; NEW_LINE if ( count == 0 ) : NEW_LINE INDENT print ( "0" ) ; NEW_LINE DEDENT elif ( count == 1 ) : NEW_LINE INDENT print ( "1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) ; NEW_LINE DEDENT
def isInGivenBase ( Str , base ) : NEW_LINE INDENT if ( base > 16 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( base <= 10 ) : NEW_LINE INDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( Str [ i ] . isnumeric ( ) and ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT ' NEW_LINE INDENT else : NEW_LINE INDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( Str [ i ] . isnumeric ( ) and ( ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) or ( ord ( Str [ i ] ) >= ord ( ' A ' ) and ord ( Str [ i ] ) < ( ord ( ' A ' ) + base - 10 ) ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT Str = " AF87" NEW_LINE if ( isInGivenBase ( Str , 16 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printIndex ( str , s ) : NEW_LINE INDENT flag = False ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i : i + len ( s ) ] == s ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE flag = True ; NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( " NONE " ) ; NEW_LINE DEDENT DEDENT str1 = " GeeksforGeeks " ; NEW_LINE str2 = " Geeks " ; NEW_LINE printIndex ( str1 , str2 ) ; NEW_LINE
def matchClosing ( X , start , end , open , close ) : NEW_LINE INDENT c = 1 NEW_LINE i = start + 1 NEW_LINE while ( i <= end ) : NEW_LINE INDENT if ( X [ i ] == open ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( X [ i ] == close ) : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT if ( c == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT def matchingOpening ( X , start , end , open , close ) : NEW_LINE INDENT c = - 1 NEW_LINE i = end - 1 NEW_LINE while ( i >= start ) : NEW_LINE INDENT if ( X [ i ] == open ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( X [ i ] == close ) : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT if ( c == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def isBalanced ( X , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( X [ i ] == ' ( ' ) : NEW_LINE INDENT j = matchClosing ( X , i , n - 1 , ' ( ' , ' ) ' ) NEW_LINE DEDENT elif ( X [ i ] == ' { ' ) : NEW_LINE INDENT j = matchClosing ( X , i , n - 1 , ' { ' , ' } ' ) NEW_LINE DEDENT elif ( X [ i ] == ' [ ' ) : NEW_LINE INDENT j = matchClosing ( X , i , n - 1 , ' [ ' , ' ] ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( X [ i ] == ' ) ' ) : NEW_LINE INDENT j = matchingOpening ( X , 0 , i , ' ( ' , ' ) ' ) NEW_LINE DEDENT elif ( X [ i ] == ' } ' ) : NEW_LINE INDENT j = matchingOpening ( X , 0 , i , ' { ' , ' } ' ) NEW_LINE DEDENT elif ( X [ i ] == ' ] ' ) : NEW_LINE INDENT j = matchingOpening ( X , 0 , i , ' [ ' , ' ] ' ) NEW_LINE DEDENT if ( j < 0 or j >= i ) : NEW_LINE INDENT return False NEW_LINE DEDENT continue NEW_LINE DEDENT if ( j >= n or j < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT start = i NEW_LINE end = j NEW_LINE for k in range ( start + 1 , end ) : NEW_LINE INDENT if ( X [ k ] == ' ( ' ) : NEW_LINE INDENT x = matchClosing ( X , k , end , ' ( ' , ' ) ' ) NEW_LINE if ( not ( k < x and x < end ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( X [ k ] == ' ) ' ) : NEW_LINE INDENT x = matchingOpening ( X , start , k , ' ( ' , ' ) ' ) NEW_LINE if ( not ( start < x and x < k ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( X [ k ] == ' { ' ) : NEW_LINE INDENT x = matchClosing ( X , k , end , ' { ' , ' } ' ) NEW_LINE if ( not ( k < x and x < end ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( X [ k ] == ' } ' ) : NEW_LINE INDENT x = matchingOpening ( X , start , k , ' { ' , ' } ' ) NEW_LINE if ( not ( start < x and x < k ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( X [ k ] == ' [ ' ) : NEW_LINE INDENT x = matchClosing ( X , k , end , ' [ ' , ' ] ' ) NEW_LINE if ( not ( k < x and x < end ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( X [ k ] == ' ] ' ) : NEW_LINE INDENT x = matchingOpening ( X , start , k , ' [ ' , ' ] ' ) NEW_LINE if ( not ( start < x and x < k ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = " [ ( ) ] ( ) " NEW_LINE n = 6 NEW_LINE if ( isBalanced ( X , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT Y = " [ [ ( ) ] ] ) " NEW_LINE n = 7 NEW_LINE if ( isBalanced ( Y , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def possibleToSort ( arr , n , str ) : NEW_LINE INDENT max_element = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT max_element = max ( max_element , arr [ i ] ) NEW_LINE if ( str [ i ] == '0' ) : NEW_LINE INDENT if ( max_element > i + 1 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT DEDENT return " Yes " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE str = "01110" NEW_LINE print ( possibleToSort ( arr , n , str ) ) NEW_LINE DEDENT
def isPrimeString ( str1 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE n = 0 NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT n += ord ( str1 [ i ] ) NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i * i <= n ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT str1 = " geekRam " NEW_LINE if ( isPrimeString ( str1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
MAX = 256 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def countPalinPermutations ( str ) : NEW_LINE INDENT global MAX NEW_LINE n = len ( str ) NEW_LINE freq = [ 0 ] * MAX ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] = freq [ ord ( str [ i ] ) ] + 1 ; NEW_LINE DEDENT res = fact ( int ( n / 2 ) ) NEW_LINE oddFreq = False NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT half = int ( freq [ i ] / 2 ) NEW_LINE if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT if ( oddFreq == True ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT oddFreq = True NEW_LINE DEDENT res = int ( res / fact ( half ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT str = " gffg " NEW_LINE print ( countPalinPermutations ( str ) ) NEW_LINE
def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str = " abccaa " NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE auxArr = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = "1101" NEW_LINE print ( countSubstr ( s ) ) NEW_LINE
def canMakeStr2 ( s1 , s2 ) : NEW_LINE INDENT count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT count [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( count . get ( s2 [ i ] ) == None or count [ s2 [ i ] ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ s2 [ i ] ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT s1 = " geekforgeeks " NEW_LINE s2 = " for " NEW_LINE if canMakeStr2 ( s1 , s2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def finalPosition ( move ) : NEW_LINE INDENT l = len ( move ) NEW_LINE countUp , countDown = 0 , 0 NEW_LINE countLeft , countRight = 0 , 0 NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( l ) : NEW_LINE INDENT if ( move [ i ] == ' U ' ) : NEW_LINE INDENT countUp += 1 NEW_LINE DEDENT elif ( move [ i ] == ' D ' ) : NEW_LINE INDENT countDown += 1 NEW_LINE DEDENT elif ( move [ i ] == ' L ' ) : NEW_LINE INDENT countLeft += 1 NEW_LINE DEDENT elif ( move [ i ] == ' R ' ) : NEW_LINE INDENT countRight += 1 NEW_LINE DEDENT DEDENT print ( " Final ▁ Position : ▁ ( " , ( countRight - countLeft ) , " , ▁ " , ( countUp - countDown ) , " ) " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT move = " UDDLLRUUUDUURUDDUULLDRRRR " NEW_LINE finalPosition ( move ) NEW_LINE DEDENT
def maxbalancedprefix ( str , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE maxi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == ' ( ' : NEW_LINE INDENT _sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT _sum -= 1 NEW_LINE DEDENT if _sum < 0 : NEW_LINE INDENT break NEW_LINE DEDENT if _sum == 0 : NEW_LINE INDENT maxi = i + 1 NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT str = ' ( ( ( ) ( ) ) ( ) ) ( ( ' NEW_LINE n = len ( str ) NEW_LINE print ( maxbalancedprefix ( str , n ) ) NEW_LINE
def cost ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE res = 0 NEW_LINE j = l - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( st [ i ] != st [ j ] ) : NEW_LINE INDENT res += ( min ( ord ( st [ i ] ) , ord ( st [ j ] ) ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT st = " abcdef " ; NEW_LINE print ( cost ( st ) ) NEW_LINE
MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " abctd " NEW_LINE q = " cat " NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countReduce ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT res += abs ( int ( ord ( str [ i ] ) ) - int ( ord ( str [ n - i - 1 ] ) ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT str = " abcd " NEW_LINE print ( countReduce ( str ) ) NEW_LINE
def calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( 10 ) : NEW_LINE INDENT for m in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if ( i + j + k == l + m + n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c < ans ) : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "123456" NEW_LINE print ( calculate ( s ) ) NEW_LINE DEDENT
def makeAndCheckString ( words , str ) : NEW_LINE INDENT n = len ( words ) NEW_LINE first = second = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if words [ i ] == str : NEW_LINE INDENT return True NEW_LINE DEDENT if str [ 0 ] == words [ i ] [ 1 ] : NEW_LINE INDENT first = True NEW_LINE DEDENT if str [ 1 ] == words [ i ] [ 0 ] : NEW_LINE INDENT second = True NEW_LINE DEDENT if first and second : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT str = ' ya ' NEW_LINE words = [ ' ah ' , ' oy ' , ' to ' , ' ha ' ] NEW_LINE if makeAndCheckString ( words , str ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
def sentencePalindrome ( s ) : NEW_LINE INDENT l , h = 0 , len ( s ) - 1 NEW_LINE s = s . lower ( ) NEW_LINE while ( l <= h ) : NEW_LINE INDENT if ( not ( s [ l ] >= ' a ' and s [ l ] <= ' z ' ) ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( not ( s [ h ] >= ' a ' and s [ h ] <= ' z ' ) ) : NEW_LINE INDENT h -= 1 NEW_LINE DEDENT elif ( s [ l ] == s [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " Too ▁ hot ▁ to ▁ hoot . " NEW_LINE if ( sentencePalindrome ( s ) ) : NEW_LINE INDENT print " Sentence ▁ is ▁ palindrome . " NEW_LINE DEDENT else : NEW_LINE INDENT print " Sentence ▁ is ▁ not ▁ palindrome . " NEW_LINE DEDENT
def xorZero ( str ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "11111" NEW_LINE print ( xorZero ( str ) ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def checkCorrectOrNot ( s ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 ; j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count [ ord ( s [ j ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE i += 1 ; j -= 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count [ i ] != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " abab " NEW_LINE print ( " Yes " if checkCorrectOrNot ( s ) else " No " ) NEW_LINE
import math NEW_LINE def uniqueCharacters ( str ) : NEW_LINE INDENT checker = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT bitAtIndex = ord ( str [ i ] ) - ord ( ' a ' ) NEW_LINE if ( ( bitAtIndex ) > 0 ) : NEW_LINE INDENT if ( ( checker & ( ( 1 << bitAtIndex ) ) ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = " geekforgeeks " NEW_LINE if ( uniqueCharacters ( input ) ) : NEW_LINE INDENT print ( " The ▁ String ▁ " + input + " ▁ has ▁ all ▁ unique ▁ characters " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ String ▁ " + input + " ▁ has ▁ duplicate ▁ characters " ) NEW_LINE DEDENT DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if n & ( 1 << ( k - 1 ) ) : NEW_LINE INDENT print ( " SET " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NOT ▁ SET " ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE k = 1 NEW_LINE isKthBitSet ( n , k ) NEW_LINE
def isPalRec ( st , s , e ) : NEW_LINE INDENT if ( s == e ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( st [ s ] != st [ e ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( s < e + 1 ) : NEW_LINE INDENT return isPalRec ( st , s + 1 , e - 1 ) ; NEW_LINE DEDENT return True NEW_LINE DEDENT def isPalindrome ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPalRec ( st , 0 , n - 1 ) ; NEW_LINE DEDENT st = " geeg " NEW_LINE if ( isPalindrome ( st ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
MAX_CHAR = 26 ; NEW_LINE def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE count = [ 0 ] * MAX_CHAR ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT s = " abcab " ; NEW_LINE print ( countSubstringWithEqualEnds ( s ) ) ; NEW_LINE
def maxRepeating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE cur_count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT cur_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " aaaabbaaccde " NEW_LINE print ( maxRepeating ( str ) ) NEW_LINE DEDENT
def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE print ( " Yes " ) if s [ i ] == s [ j ] else print ( " No " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = " geeksforgeeks " NEW_LINE query ( X , 0 , 8 ) NEW_LINE query ( X , 8 , 13 ) NEW_LINE query ( X , 6 , 15 ) NEW_LINE DEDENT
def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " geeksforgeeks " ; NEW_LINE print ( countPairs ( str1 ) ) ; NEW_LINE DEDENT
def longestString ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result = result + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " geeks " NEW_LINE str2 = " cake " NEW_LINE longestString ( str1 , str2 ) NEW_LINE DEDENT
def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " abcbaa " NEW_LINE k = 3 NEW_LINE print ( " Total ▁ substrings ▁ with ▁ exactly " , k , " distinct ▁ characters ▁ : ▁ " , end = " " ) NEW_LINE print ( countkDist ( str1 , k ) ) NEW_LINE DEDENT
def removeRecur ( n ) : NEW_LINE INDENT prev_digit = n % 10 NEW_LINE pow = 10 NEW_LINE res = prev_digit NEW_LINE while ( n ) : NEW_LINE INDENT curr_digit = n % 10 NEW_LINE if ( curr_digit != prev_digit ) : NEW_LINE INDENT res += curr_digit * pow NEW_LINE prev_digit = curr_digit NEW_LINE pow *= 10 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12224 NEW_LINE print ( removeRecur ( n ) ) NEW_LINE DEDENT
def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE arr = [ None ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE DEDENT
def firstDigit ( n ) : NEW_LINE INDENT while ( n >= 10 ) : NEW_LINE INDENT n //= 10 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT leadDigit = firstDigit ( n ) ; NEW_LINE n -= leadDigit ; NEW_LINE count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def getLargestNumber ( k ) : NEW_LINE INDENT left = k ; NEW_LINE right = k * 10 ; NEW_LINE mid = ( left + right ) // 2 ; NEW_LINE length = getCount ( mid ) ; NEW_LINE while ( length != k ) : NEW_LINE INDENT mid = ( left + right ) // 2 ; NEW_LINE length = getCount ( mid ) ; NEW_LINE if ( length > k ) : NEW_LINE INDENT right = mid ; NEW_LINE DEDENT else : NEW_LINE INDENT left = mid ; NEW_LINE DEDENT DEDENT while ( length == k ) : NEW_LINE INDENT if ( length != getCount ( mid + 1 ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT mid += 1 ; NEW_LINE DEDENT return mid ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 3 ; NEW_LINE print ( getLargestNumber ( k ) ) ; NEW_LINE DEDENT
def diameter ( r ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ longest ▁ chord " , " ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ " , 2 * r ) NEW_LINE DEDENT r = 4 NEW_LINE diameter ( r ) NEW_LINE
def getSlope ( m ) : NEW_LINE INDENT return m ; NEW_LINE DEDENT m = 2 ; NEW_LINE print ( getSlope ( m ) ) ; NEW_LINE
def totalTriangles ( h , v ) : NEW_LINE INDENT if ( h == 0 and v == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( h == 0 ) : NEW_LINE INDENT return ( ( v + 1 ) * ( v + 2 ) / 2 ) NEW_LINE DEDENT if ( v == 0 ) : NEW_LINE INDENT return ( h + 1 ) NEW_LINE DEDENT total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) NEW_LINE return total NEW_LINE DEDENT h = 2 NEW_LINE v = 2 NEW_LINE print ( int ( totalTriangles ( h , v ) ) ) NEW_LINE
import math as mt NEW_LINE def sph ( r , R , h ) : NEW_LINE INDENT if ( r < 0 and R < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = r NEW_LINE V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 NEW_LINE return V NEW_LINE DEDENT r , R , h = 5 , 8 , 11 NEW_LINE print ( sph ( r , R , h ) ) NEW_LINE
def checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT if ( x2 - x1 == 0 and x4 - x3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( x2 - x1 == 0 ) : NEW_LINE INDENT m2 = ( y4 - y3 ) / ( x4 - x3 ) NEW_LINE if ( m2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( x4 - x3 == 0 ) : NEW_LINE INDENT m1 = ( y2 - y1 ) / ( x2 - x1 ) ; NEW_LINE if ( m1 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m1 = ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE m2 = ( y4 - y3 ) / ( x4 - x3 ) NEW_LINE if ( m1 * m2 == - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 4 NEW_LINE x2 = 0 NEW_LINE y2 = - 9 NEW_LINE x3 = 2 NEW_LINE y3 = 0 NEW_LINE x4 = - 1 NEW_LINE y4 = 0 NEW_LINE if ( checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 6 NEW_LINE print ( pentdiagonal ( a ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def hexagonArea ( d ) : NEW_LINE INDENT return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT d = 10 NEW_LINE print ( " Area ▁ of ▁ hexagon : " , round ( hexagonArea ( d ) , 3 ) ) NEW_LINE DEDENT
def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE m = 6 NEW_LINE a = 4 NEW_LINE print ( Squares ( n , m , a ) ) NEW_LINE DEDENT
import math NEW_LINE def octadiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return a * math . sqrt ( 4 + ( 2 * math . sqrt ( 2 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE print ( octadiagonal ( a ) ) NEW_LINE DEDENT
def CalPeri ( ) : NEW_LINE INDENT s = 5 NEW_LINE Perimeter = 10 * s NEW_LINE print ( " The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ " , Perimeter ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT CalPeri ( ) ; NEW_LINE DEDENT
import math NEW_LINE def findEdges ( s1 , s2 , s3 ) : NEW_LINE INDENT a = math . sqrt ( s1 * s2 / s3 ) NEW_LINE b = math . sqrt ( s3 * s1 / s2 ) NEW_LINE c = math . sqrt ( s3 * s2 / s1 ) NEW_LINE sum = a + b + c NEW_LINE return 4 * sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = 65 NEW_LINE s2 = 156 NEW_LINE s3 = 60 NEW_LINE print ( int ( findEdges ( s1 , s2 , s3 ) ) ) NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT x = n // 2 NEW_LINE return ( ( x + 1 ) * ( n - x + 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( " Max ▁ number ▁ of ▁ pieces ▁ for ▁ n ▁ = ▁ " + str ( n ) + " ▁ is ▁ " + str ( findMaximumPieces ( 3 ) ) ) NEW_LINE DEDENT
def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) : NEW_LINE INDENT a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE a = b1 * c2 - b2 * c1 NEW_LINE b = a2 * c1 - a1 * c2 NEW_LINE c = a1 * b2 - b1 * a2 NEW_LINE d = ( - a * x1 - b * y1 - c * z1 ) NEW_LINE if ( a * x + b * y + c * z + d == 0 ) : NEW_LINE INDENT print ( " Coplanar " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Coplanar " ) NEW_LINE DEDENT DEDENT x1 = 3 NEW_LINE y1 = 2 NEW_LINE z1 = - 5 NEW_LINE x2 = - 1 NEW_LINE y2 = 4 NEW_LINE z2 = - 3 NEW_LINE x3 = - 3 NEW_LINE y3 = 8 NEW_LINE z3 = - 5 NEW_LINE x4 = - 3 NEW_LINE y4 = 2 NEW_LINE z4 = 1 NEW_LINE / * function calling * / NEW_LINE equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) NEW_LINE
import math NEW_LINE def distance ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT d = ( a1 * a2 + b1 * b2 + c1 * c2 ) NEW_LINE e1 = math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) NEW_LINE e2 = math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) NEW_LINE d = d / ( e1 * e2 ) NEW_LINE A = math . degrees ( math . acos ( d ) ) NEW_LINE print ( " Angle ▁ is " ) , A , ( " degree " ) NEW_LINE DEDENT a1 = 1 NEW_LINE b1 = 1 NEW_LINE c1 = 2 NEW_LINE d1 = 1 NEW_LINE a2 = 2 NEW_LINE b2 = - 1 NEW_LINE c2 = 1 NEW_LINE d2 = - 4 NEW_LINE distance ( a1 , b1 , c1 , a2 , b2 , c2 ) NEW_LINE
def mirror_point ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / float ( ( a * a + b * b + c * c ) ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE x3 = 2 * x2 - x1 NEW_LINE y3 = 2 * y2 - y1 NEW_LINE z3 = 2 * z2 - z1 NEW_LINE print " x3 ▁ = " , x3 , NEW_LINE print " y3 ▁ = " , y3 , NEW_LINE print " z3 ▁ = " , z3 , NEW_LINE DEDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 4 NEW_LINE mirror_point ( a , b , c , d , x1 , y1 , z1 ) NEW_LINE
def countRectangles ( radius ) : NEW_LINE INDENT rectangles = 0 NEW_LINE diameter = 2 * radius NEW_LINE diameterSquare = diameter * diameter NEW_LINE for a in range ( 1 , 2 * radius ) : NEW_LINE INDENT for b in range ( 1 , 2 * radius ) : NEW_LINE INDENT diagonalLengthSquare = ( a * a + b * b ) NEW_LINE if ( diagonalLengthSquare <= diameterSquare ) : NEW_LINE INDENT rectangles += 1 NEW_LINE DEDENT DEDENT DEDENT return rectangles NEW_LINE DEDENT radius = 2 NEW_LINE totalRectangles = countRectangles ( radius ) NEW_LINE print ( totalRectangles , " rectangles ▁ can ▁ be " , " cut ▁ from ▁ a ▁ circle ▁ of ▁ Radius " , radius ) NEW_LINE
def simi_aaa ( a1 , a2 ) : NEW_LINE INDENT a1 = [ float ( i ) for i in a1 ] NEW_LINE a2 = [ float ( i ) for i in a2 ] NEW_LINE a1 . sort ( ) NEW_LINE a2 . sort ( ) NEW_LINE if a1 [ 0 ] == a2 [ 0 ] and a1 [ 1 ] == a2 [ 1 ] and a1 [ 2 ] == a2 [ 2 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def simi_sas ( s1 , s2 , a1 , a2 ) : NEW_LINE INDENT s1 = [ float ( i ) for i in s1 ] NEW_LINE s2 = [ float ( i ) for i in s2 ] NEW_LINE a1 = [ float ( i ) for i in a1 ] NEW_LINE a2 = [ float ( i ) for i in a2 ] NEW_LINE s1 . sort ( ) NEW_LINE s2 . sort ( ) NEW_LINE a1 . sort ( ) NEW_LINE a2 . sort ( ) NEW_LINE if s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] : NEW_LINE INDENT if a1 [ 2 ] == a2 [ 2 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] : NEW_LINE INDENT if a1 [ 0 ] == a2 [ 0 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] : NEW_LINE INDENT if a1 [ 1 ] == a2 [ 1 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def simi_sss ( s1 , s2 ) : NEW_LINE INDENT s1 = [ float ( i ) for i in s1 ] NEW_LINE s2 = [ float ( i ) for i in s2 ] NEW_LINE s1 . sort ( ) NEW_LINE s2 . sort ( ) NEW_LINE if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] and s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] and s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT s1 = [ 2 , 3 , 3 ] NEW_LINE s2 = [ 4 , 6 , 6 ] NEW_LINE a1 = [ 80 , 60 , 40 ] NEW_LINE a2 = [ 40 , 60 , 80 ] NEW_LINE aaa = simi_aaa ( a1 , a2 ) NEW_LINE sss = simi_sss ( s1 , s2 ) NEW_LINE sas = simi_sas ( s1 , s2 , a1 , a2 ) NEW_LINE if aaa or sss or sas : NEW_LINE INDENT print " Triangles ▁ are ▁ similar ▁ by " , NEW_LINE if aaa : print " AAA " , NEW_LINE if sss : print " SSS " , NEW_LINE if sas : print " SAS " NEW_LINE DEDENT else : print " Triangles ▁ are ▁ not ▁ similar " NEW_LINE
def center_pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 15 * n * n - 15 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , " rd ▁ number ▁ : ▁ " , center_pentadecagonal_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , " th ▁ number ▁ : ▁ " , center_pentadecagonal_num ( n ) ) NEW_LINE DEDENT
def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , " nd ▁ centered ▁ nonadecagonal ▁ " + " number ▁ : ▁ " , center_nonadecagon_num ( n ) ) NEW_LINE n = 7 NEW_LINE print ( n , " nd ▁ centered ▁ nonadecagonal ▁ " + " number ▁ : ▁ " , center_nonadecagon_num ( n ) ) NEW_LINE DEDENT
def hendecagonal_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 7 * n ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , " rd ▁ Hendecagonal ▁ number ▁ : ▁ " , hendecagonal_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , " th ▁ Hendecagonal ▁ number ▁ : ▁ " , hendecagonal_num ( n ) ) NEW_LINE DEDENT
def cen_octagonalnum ( n ) : NEW_LINE INDENT return ( 4 * n * n - 4 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( n , " th ▁ Centered " , " octagonal ▁ number : ▁ " , cen_octagonalnum ( n ) ) NEW_LINE n = 11 NEW_LINE print ( n , " th ▁ Centered " , " octagonal ▁ number : ▁ " , cen_octagonalnum ( n ) ) NEW_LINE DEDENT
def isValid ( arr , i , j , m , c ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return False NEW_LINE DEDENT lhs = arr [ j ] ; NEW_LINE rhs = m * arr [ i ] + c NEW_LINE return ( lhs == rhs ) NEW_LINE DEDENT def findOrderedPoints ( arr , n , m , c ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT firstIndex = i NEW_LINE secondIndex = j NEW_LINE if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE m = 1 NEW_LINE c = 1 NEW_LINE print ( findOrderedPoints ( arr , n , m , c ) ) NEW_LINE
import math NEW_LINE def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT r = 8 ; R = 4 ; r1 = 2 ; x1 = 6 ; y1 = 0 NEW_LINE if ( checkcircle ( r , R , r1 , x1 , y1 ) ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT
import math NEW_LINE def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( " Surface ▁ area ▁ of ▁ octahedron ▁ = " , surface_area_octahedron ( side ) ) NEW_LINE
def nCk ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def count_Straightlines ( n , m ) : NEW_LINE INDENT return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE m = 3 NEW_LINE print ( count_Straightlines ( n , m ) ) ; NEW_LINE
import math NEW_LINE def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEW_LINE DEDENT side = 4 NEW_LINE print ( " Volume ▁ of ▁ dodecahedron ▁ = " , round ( vol_of_dodecahedron ( side ) , 2 ) ) NEW_LINE
def overflow ( H , r , h , N , R ) : NEW_LINE INDENT tank_cap = 3.14 * r * r * H NEW_LINE water_vol = 3.14 * r * r * h NEW_LINE balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R NEW_LINE vol = water_vol + balls_vol NEW_LINE if vol > tank_cap : NEW_LINE INDENT print ( " Overflow " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ in ▁ overflow ▁ state " ) NEW_LINE DEDENT DEDENT H = 10 NEW_LINE r = 5 NEW_LINE h = 5 NEW_LINE N = 2 NEW_LINE R = 2 NEW_LINE overflow ( H , r , h , N , R ) NEW_LINE
def volume ( radius , height ) : NEW_LINE INDENT return ( ( 22 / 7 ) * radius * radius * height ) NEW_LINE DEDENT def check_and_print ( required_time , given_time ) : NEW_LINE INDENT if required_time < given_time : NEW_LINE INDENT print ( " Overflow " ) NEW_LINE DEDENT elif required_time > given_time : NEW_LINE INDENT print ( " Underflow " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Filled " ) NEW_LINE DEDENT DEDENT radius = 5 NEW_LINE height = 10 NEW_LINE rate_of_flow = 10 NEW_LINE given_time = 70.0 NEW_LINE required_time = volume ( radius , height ) / rate_of_flow NEW_LINE check_and_print ( required_time , given_time ) NEW_LINE
import math as mt NEW_LINE def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE x1 , denominator , cosx , cosval = 0 , 0 , 0 , 0 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = 1 NEW_LINE cosx = x1 NEW_LINE cosval = mt . cos ( n ) NEW_LINE i = 1 NEW_LINE while ( accuracy <= abs ( cosval - cosx ) ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT return cosx NEW_LINE DEDENT def third_side ( a , b , c ) : NEW_LINE INDENT angle = cal_cos ( c ) NEW_LINE return mt . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) NEW_LINE DEDENT c = 49 NEW_LINE a , b = 5 , 8 NEW_LINE print ( third_side ( a , b , c ) ) NEW_LINE
import math NEW_LINE def fitOrNotFit ( R , r , x , y , rad ) : NEW_LINE INDENT val = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) NEW_LINE if ( val + rad <= R and val - rad >= R - r ) : NEW_LINE INDENT print ( " Fits " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Doesn ' t ▁ Fit " ) NEW_LINE DEDENT DEDENT R = 8 NEW_LINE r = 4 NEW_LINE x = 5 NEW_LINE y = 3 NEW_LINE rad = 3 NEW_LINE fitOrNotFit ( R , r , x , y , rad ) NEW_LINE
from math import sqrt NEW_LINE def checkPolygonWithMidpoints ( arr , N , midpoints ) : NEW_LINE INDENT for j in range ( midpoints ) : NEW_LINE INDENT val = 1 NEW_LINE for k in range ( j , N , midpoints ) : NEW_LINE INDENT val &= arr [ k ] NEW_LINE DEDENT if ( val and N // midpoints > 2 ) : NEW_LINE INDENT print ( " Polygon ▁ possible ▁ with ▁ side ▁ length " , ( N // midpoints ) ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isPolygonPossible ( arr , N ) : NEW_LINE INDENT limit = sqrt ( N ) NEW_LINE for i in range ( 1 , int ( limit ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( checkPolygonWithMidpoints ( arr , N , i ) or checkPolygonWithMidpoints ( arr , N , ( N // i ) ) ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT DEDENT print ( " Not ▁ possiblen " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE isPolygonPossible ( arr , N ) NEW_LINE DEDENT
def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT def findMaximumHeight ( N ) : NEW_LINE INDENT n = 1 + 8 * N NEW_LINE maxH = ( - 1 + squareRoot ( n ) ) / 2 NEW_LINE return int ( maxH ) NEW_LINE DEDENT N = 12 NEW_LINE print ( findMaximumHeight ( N ) ) NEW_LINE
def calculateSpan ( price , n , S ) : NEW_LINE INDENT S [ 0 ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT S [ i ] = 1 NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 ) and ( price [ i ] >= price [ j ] ) : NEW_LINE INDENT S [ i ] += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT price = [ 10 , 4 , 5 , 90 , 120 , 80 ] NEW_LINE n = len ( price ) NEW_LINE S = [ None ] * n NEW_LINE calculateSpan ( price , n , S ) NEW_LINE printArray ( S , n ) NEW_LINE
def printNGE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + " ▁ - - ▁ " + str ( next ) ) NEW_LINE DEDENT DEDENT arr = [ 11 , 13 , 21 , 3 ] NEW_LINE printNGE ( arr ) NEW_LINE
def TowerOfHanoi ( n , from_rod , to_rod , aux_rod ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( " Move ▁ disk ▁ 1 ▁ from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE return NEW_LINE DEDENT TowerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " to ▁ rod " , to_rod ) NEW_LINE TowerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) NEW_LINE DEDENT n = 4 NEW_LINE TowerOfHanoi ( n , ' A ' , ' C ' , ' B ' ) NEW_LINE
INT_MIN = - 1000000 NEW_LINE def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = INT_MIN ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE
st = [ ] ; NEW_LINE def push_digits ( number ) : NEW_LINE INDENT while ( number != 0 ) : NEW_LINE INDENT st . append ( number % 10 ) ; NEW_LINE number = int ( number / 10 ) ; NEW_LINE DEDENT DEDENT def reverse_number ( number ) : NEW_LINE INDENT push_digits ( number ) ; NEW_LINE reverse = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT reverse = reverse + ( st [ len ( st ) - 1 ] * i ) ; NEW_LINE st . pop ( ) ; NEW_LINE i = i * 10 ; NEW_LINE DEDENT return reverse ; NEW_LINE DEDENT number = 39997 ; NEW_LINE print ( reverse_number ( number ) ) ; NEW_LINE
def heapify ( arr , n , i ) : NEW_LINE INDENT largest = i NEW_LINE l = 2 * i + 1 NEW_LINE r = 2 * i + 2 NEW_LINE if l < n and arr [ largest ] < arr [ l ] : NEW_LINE INDENT largest = l NEW_LINE DEDENT if r < n and arr [ largest ] < arr [ r ] : NEW_LINE INDENT largest = r NEW_LINE DEDENT if largest != i : NEW_LINE INDENT arr [ i ] , arr [ largest ] = arr [ largest ] , arr [ i ] NEW_LINE heapify ( arr , n , largest ) NEW_LINE DEDENT DEDENT def heapSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n // 2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT heapify ( arr , n , i ) NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] , arr [ 0 ] = arr [ 0 ] , arr [ i ] NEW_LINE heapify ( arr , i , 0 ) NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 , 7 ] NEW_LINE heapSort ( arr ) NEW_LINE n = len ( arr ) NEW_LINE print ( " Sorted ▁ array ▁ is " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " % d " % arr [ i ] ) , NEW_LINE DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if i >= int ( ( n - 2 ) / 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) - 1 NEW_LINE if isHeap ( arr , 0 , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if isHeap ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def generate_derangement ( N ) : NEW_LINE INDENT S = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S [ i ] = i NEW_LINE DEDENT D = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 , 2 ) : NEW_LINE INDENT if i == N : NEW_LINE INDENT D [ N ] = S [ N - 1 ] NEW_LINE D [ N - 1 ] = S [ N ] NEW_LINE DEDENT else : NEW_LINE INDENT D [ i ] = i + 1 NEW_LINE D [ i + 1 ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( D [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT generate_derangement ( 10 ) NEW_LINE DEDENT
def Profit ( costPrice , sellingPrice ) : NEW_LINE INDENT profit = ( sellingPrice - costPrice ) NEW_LINE return profit NEW_LINE DEDENT def Loss ( costPrice , sellingPrice ) : NEW_LINE INDENT Loss = ( costPrice - sellingPrice ) NEW_LINE return Loss NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT costPrice , sellingPrice = 1500 , 2000 NEW_LINE if sellingPrice == costPrice : NEW_LINE INDENT print ( " No ▁ profit ▁ nor ▁ Loss " ) NEW_LINE DEDENT elif sellingPrice > costPrice : NEW_LINE INDENT print ( Profit ( costPrice , sellingPrice ) , " Profit " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Loss ( costPrice , sellingPrice ) , " Loss " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 35 NEW_LINE print ( nextPerfectSquare ( N ) ) NEW_LINE DEDENT
import math NEW_LINE def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) ; NEW_LINE d = ( math . pow ( 10 , s ) ) ; NEW_LINE k = d ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( int ( n // d ) ) ; NEW_LINE d = int ( d / 10 ) ; NEW_LINE DEDENT n = int ( n % k ) ; NEW_LINE k = int ( k // 10 ) ; NEW_LINE d = k ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 123 ; NEW_LINE printSubstrings ( n ) ; NEW_LINE DEDENT
MOD = 1000000007 ; NEW_LINE def powerLL ( x , n ) : NEW_LINE INDENT result = 1 ; NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT result = result * x % MOD ; NEW_LINE DEDENT n = int ( n / 2 ) ; NEW_LINE x = x * x % MOD ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def powerStrings ( sa , sb ) : NEW_LINE INDENT a = 0 ; NEW_LINE b = 0 ; NEW_LINE for i in range ( len ( sa ) ) : NEW_LINE INDENT a = ( a * 10 + ( ord ( sa [ i ] ) - ord ( '0' ) ) ) % MOD ; NEW_LINE DEDENT for i in range ( len ( sb ) ) : NEW_LINE INDENT b = ( b * 10 + ( ord ( sb [ i ] ) - ord ( '0' ) ) ) % ( MOD - 1 ) ; NEW_LINE DEDENT return powerLL ( a , b ) ; NEW_LINE DEDENT sa = "2" ; NEW_LINE sb = "3" ; NEW_LINE print ( powerStrings ( sa , sb ) ) ; NEW_LINE
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def previousPowerOfTwo ( n ) : NEW_LINE INDENT while ( n & n - 1 ) : NEW_LINE INDENT n = n & n - 1 NEW_LINE DEDENT return n NEW_LINE DEDENT def checkSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( isPowerOfTwo ( n ) ) : NEW_LINE INDENT print ( n // 2 , n // 2 ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT x = previousPowerOfTwo ( n ) NEW_LINE y = n - x ; NEW_LINE if ( isPowerOfTwo ( y ) ) : NEW_LINE INDENT print ( x , y ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT n1 = 20 NEW_LINE if ( checkSum ( n1 ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT n2 = 11 NEW_LINE if ( checkSum ( n2 ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def complement ( num ) : NEW_LINE INDENT i = 0 ; NEW_LINE len = 0 ; NEW_LINE comp = 0 ; NEW_LINE temp = num ; NEW_LINE while ( 1 ) : NEW_LINE INDENT len += 1 ; NEW_LINE num = int ( num / 10 ) ; NEW_LINE if ( abs ( num ) == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT num = temp ; NEW_LINE comp = math . pow ( 10 , len ) - num ; NEW_LINE return int ( comp ) ; NEW_LINE DEDENT print ( complement ( 25 ) ) ; NEW_LINE print ( complement ( 456 ) ) ; NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE
def findAllSequence ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return ( pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; NEW_LINE DEDENT DEDENT N = 2 ; NEW_LINE print ( int ( findAllSequence ( N ) ) ) ; NEW_LINE
def countOnes ( n ) : NEW_LINE INDENT count = 1 ; NEW_LINE rem = 1 ; NEW_LINE while ( rem != 0 ) : NEW_LINE INDENT rem = ( rem * 10 + 1 ) % n ; NEW_LINE count = count + 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT n = 13 ; NEW_LINE print ( countOnes ( n ) ) ; NEW_LINE
def largestNum ( a , b ) : NEW_LINE INDENT return a * ( bool ) ( a // b ) + b * ( bool ) ( b // a ) ; NEW_LINE DEDENT a = 22 ; NEW_LINE b = 1231 ; NEW_LINE print ( largestNum ( a , b ) ) ; NEW_LINE
import math NEW_LINE def numberOfmeet ( a , b ) : NEW_LINE INDENT ans = 0 ; NEW_LINE if ( a > b ) : NEW_LINE INDENT ans = a - b ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = b - a ; NEW_LINE DEDENT if ( a < 0 ) : NEW_LINE INDENT a = a * ( - 1 ) ; NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT b = b * ( - 1 ) ; NEW_LINE DEDENT return int ( ans / math . gcd ( a , b ) ) ; NEW_LINE DEDENT a = 1 ; NEW_LINE b = - 1 ; NEW_LINE print ( numberOfmeet ( a , b ) ) ; NEW_LINE
import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e-9 ) : NEW_LINE INDENT print ( " Equal " ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , " ^ " , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , " ^ " , x ) ; NEW_LINE DEDENT DEDENT x = 5 ; NEW_LINE y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE
def sumOfSeries ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 NEW_LINE DEDENT n = 4 NEW_LINE print sumOfSeries ( n ) NEW_LINE
def mulmod ( a , b , mod ) : NEW_LINE INDENT a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def findProduct ( N ) : NEW_LINE INDENT product = 1 ; fact = 1 NEW_LINE MOD = 1e9 + 7 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = mulmod ( fact , i , MOD ) NEW_LINE product = mulmod ( product , fact , MOD ) NEW_LINE if not product : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return int ( product ) NEW_LINE DEDENT N = 3 NEW_LINE print ( findProduct ( N ) ) NEW_LINE N = 5 NEW_LINE print ( findProduct ( N ) ) NEW_LINE
import math NEW_LINE def divSum ( n ) : NEW_LINE INDENT sum = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum = ( sum + i + math . floor ( n / i ) ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def areEquivalent ( num1 , num2 ) : NEW_LINE INDENT return divSum ( num1 ) == divSum ( num2 ) ; NEW_LINE DEDENT num1 = 559 ; NEW_LINE num2 = 703 ; NEW_LINE if ( areEquivalent ( num1 , num2 ) == True ) : NEW_LINE INDENT print ( " Equivalent " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Equivalent " ) ; NEW_LINE DEDENT
def dodecahedral_num ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( " % sth ▁ Dodecahedral ▁ number ▁ : " % n , dodecahedral_num ( n ) ) NEW_LINE
import math NEW_LINE def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x /= 2 NEW_LINE ans = ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT if ( bit ( x / d ) <= bit ( d ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False ; NEW_LINE DEDENT def bs ( n ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( math . sqrt ( n ) ) NEW_LINE while ( l < r ) : NEW_LINE INDENT m = int ( ( l + r ) / 2 ) NEW_LINE if ( check ( m , n ) ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( check ( l , n ) == False ) : NEW_LINE INDENT return math . floor ( l + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . floor ( l ) NEW_LINE DEDENT DEDENT def countDivisor ( n ) : NEW_LINE INDENT return n - bs ( n ) + 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( countDivisor ( n ) ) NEW_LINE
def everMeet ( x1 , x2 , v1 , v2 ) : NEW_LINE INDENT if ( x1 < x2 and v1 <= v2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x1 > x2 and v1 >= v2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x1 < x2 ) : NEW_LINE INDENT x1 , x2 = x2 , x1 ; NEW_LINE v1 , v2 = v2 , v1 ; NEW_LINE DEDENT while ( x1 >= x2 ) : NEW_LINE INDENT if ( x1 == x2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT x1 = x1 + v1 ; NEW_LINE x2 = x2 + v2 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT x1 = 5 ; NEW_LINE v1 = 8 ; NEW_LINE x2 = 4 ; NEW_LINE v2 = 7 ; NEW_LINE if ( everMeet ( x1 , x2 , v1 , v2 ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) // 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 1 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE k = 5 NEW_LINE d0 = 3 NEW_LINE d1 = 4 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE DEDENT
import math NEW_LINE a = 4 ; NEW_LINE b = 3 ; NEW_LINE val = ( a / b ) + ( ( a % b ) != 0 ) ; NEW_LINE print ( " The ▁ ceiling ▁ value ▁ of ▁ 4/3 ▁ is " , math . floor ( val ) ) ; NEW_LINE a = 6 ; NEW_LINE b = 3 ; NEW_LINE val = int ( ( a / b ) + ( ( a % b ) != 0 ) ) ; NEW_LINE print ( " The ▁ ceiling ▁ value ▁ of ▁ 6/3 ▁ is " , val ) ; NEW_LINE
def printCollatz ( n ) : NEW_LINE INDENT while n != 1 : NEW_LINE INDENT print ( n , end = ' ▁ ' ) NEW_LINE if n & 1 : NEW_LINE INDENT n = 3 * n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT printCollatz ( 6 ) NEW_LINE
def block ( x ) : NEW_LINE INDENT v = [ ] NEW_LINE print ( " Blocks ▁ for ▁ % d ▁ : ▁ " % x , end = " " ) NEW_LINE while ( x > 0 ) : NEW_LINE INDENT v . append ( int ( x % 2 ) ) NEW_LINE x = int ( x / 2 ) NEW_LINE DEDENT for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT if ( v [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE if ( i != len ( v ) - 1 ) : NEW_LINE INDENT print ( " , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT print ( " " ) NEW_LINE DEDENT block ( 71307 ) NEW_LINE block ( 1213 ) NEW_LINE block ( 29 ) NEW_LINE block ( 100 ) NEW_LINE
import math NEW_LINE def findNumberOfDigits ( n , base ) : NEW_LINE INDENT dig = ( math . floor ( math . log ( n ) / math . log ( base ) ) + 1 ) NEW_LINE print ( " The ▁ Number ▁ of ▁ digits ▁ of " . format ( n , base , dig ) ) DEDENT n = 1446 NEW_LINE base = 7 NEW_LINE findNumberOfDigits ( n , base ) NEW_LINE
def isValidNesbitt ( a , b , c ) : NEW_LINE INDENT A = a / ( b + c ) ; NEW_LINE B = b / ( a + c ) ; NEW_LINE C = c / ( a + b ) ; NEW_LINE inequality = A + B + C ; NEW_LINE return ( inequality >= 1.5 ) ; NEW_LINE DEDENT a = 1.0 ; NEW_LINE b = 2.0 ; NEW_LINE c = 3.0 ; NEW_LINE if ( isValidNesbitt ( a , b , c ) ) : NEW_LINE INDENT print ( " Nesbitt ' s ▁ inequality ▁ satisfied . " , " ▁ for ▁ real ▁ numbers ▁ " , a , " , ▁ " , b , " , ▁ " , c ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ satisfied " ) ; NEW_LINE DEDENT
def printCubeFree ( n ) : NEW_LINE INDENT cubFree = [ 1 ] * ( n + 1 ) ; NEW_LINE i = 2 ; NEW_LINE while ( i * i * i <= n ) : NEW_LINE INDENT if ( cubFree [ i ] == 1 ) : NEW_LINE INDENT multiple = 1 ; NEW_LINE while ( i * i * i * multiple <= n ) : NEW_LINE INDENT cubFree [ i * i * i * multiple ] = 0 ; NEW_LINE multiple += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( cubFree [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT printCubeFree ( 20 ) ; NEW_LINE DEDENT
import math NEW_LINE def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT c = ( - 2 * num ) ; NEW_LINE b = 1 ; NEW_LINE a = 1 ; NEW_LINE d = ( b * b ) - ( 4 * a * c ) ; NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) // ( 2 * a ) ; NEW_LINE root2 = ( - b - math . sqrt ( d ) ) // ( 2 * a ) ; NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return root1 ; NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return root2 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) ; NEW_LINE if ( ( sr - math . floor ( sr ) ) == 0 ) : NEW_LINE INDENT return math . floor ( sr ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT def findS ( s ) : NEW_LINE INDENT sr = isPerfectSquare ( s ) ; NEW_LINE if ( sr == - 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return int ( isTriangular ( sr ) ) ; NEW_LINE DEDENT s = 9 ; NEW_LINE n = findS ( s ) ; NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) ; NEW_LINE DEDENT
def trickyCase ( s , index ) : NEW_LINE INDENT index1 = - 1 ; NEW_LINE for i in range ( index - 1 , - 1 , - 1 ) : NEW_LINE INDENT digit = s [ i ] - '0' ; NEW_LINE if ( digit != 8 ) : NEW_LINE INDENT index1 = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( index1 == - 1 ) : NEW_LINE INDENT return 2 * pow ( 10 , len ( s ) ) ; NEW_LINE DEDENT num = 0 ; NEW_LINE for i in range ( index1 ) : NEW_LINE INDENT num = num * 10 + ( s [ i ] - '0' ) ; NEW_LINE DEDENT if ( s [ index1 ] % 2 == 0 ) : NEW_LINE INDENT num = num * 10 + ( s [ index1 ] - '0' + 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT num = num * 10 + ( s [ index1 ] - '0' + 1 ) ; NEW_LINE DEDENT for i in range ( index1 + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT def smallestNumber ( n ) : NEW_LINE INDENT num = 0 ; NEW_LINE s = " " ; NEW_LINE duplicate = n ; NEW_LINE while ( n ) : NEW_LINE INDENT s = chr ( n % 10 + 48 ) + s ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT index = - 1 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE if ( digit & 1 ) : NEW_LINE INDENT index = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return duplicate ; NEW_LINE DEDENT if ( s [ index ] == '9' ) : NEW_LINE INDENT num = trickyCase ( s , index ) ; NEW_LINE return num ; NEW_LINE DEDENT for i in range ( index ) : NEW_LINE INDENT num = num * 10 + ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE DEDENT num = num * 10 + ( ord ( s [ index ] ) - ord ( '0' ) + 1 ) ; NEW_LINE for i in range ( index + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT N = 2397 ; NEW_LINE print ( smallestNumber ( N ) ) ; NEW_LINE
def findNth ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr = 19 ; NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 ; NEW_LINE x = curr ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr ; NEW_LINE DEDENT curr += 9 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT print ( findNth ( 5 ) ) ; NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sm = sm + i * j NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT n = 5 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) // 2 NEW_LINE sm = multiTerms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiTerms = multiTerms - ( i - 1 ) NEW_LINE sm = sm + multiTerms * i NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 5 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def totalSumDivisibleByNum ( digit , number ) : NEW_LINE INDENT firstnum = pow ( 10 , digit - 1 ) NEW_LINE lastnum = pow ( 10 , digit ) NEW_LINE firstnum = ( firstnum - firstnum % number ) + number NEW_LINE lastnum = ( lastnum - lastnum % number ) NEW_LINE count = ( ( lastnum - firstnum ) / number + 1 ) NEW_LINE return int ( ( ( lastnum + firstnum ) * count ) / 2 ) NEW_LINE DEDENT digit = 3 ; num = 7 NEW_LINE print ( totalSumDivisibleByNum ( digit , num ) ) NEW_LINE
def Nth_of_AP ( a , d , N ) : NEW_LINE INDENT return ( a + ( N - 1 ) * d ) NEW_LINE DEDENT a = 2 NEW_LINE d = 1 NEW_LINE N = 5 NEW_LINE print ( " The ▁ " , N , " th ▁ term ▁ of ▁ the ▁ series ▁ is ▁ : ▁ " , Nth_of_AP ( a , d , N ) ) NEW_LINE
def checkFibinnary ( n ) : NEW_LINE INDENT prev_last = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) and prev_last ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_last = n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if ( checkFibinnary ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def sumOfSeries ( n ) : NEW_LINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT n = 2 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
def Nonagonal ( n ) : NEW_LINE INDENT return int ( n * ( 7 * n - 5 ) / 2 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( Nonagonal ( n ) ) NEW_LINE
import math NEW_LINE def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ - 2 : ] ) NEW_LINE return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT num = "63284689320" NEW_LINE if ( divisibleBy20 ( num ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) ; NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT num = "12244824607284961224" NEW_LINE if ( isDvisibleBy12 ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def check ( n ) : NEW_LINE INDENT d = int ( math . sqrt ( n ) ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( check ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectSquareNumber ( a , n ) ) NEW_LINE
def printAP ( a , d , n ) : NEW_LINE INDENT curr_term NEW_LINE DEDENT curr_term = a NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE DEDENT print ( curr_term , end = ' ▁ ' ) NEW_LINE INDENT curr_term = curr_term + d NEW_LINE DEDENT a = 2 NEW_LINE d = 1 NEW_LINE n = 5 NEW_LINE printAP ( a , d , n ) NEW_LINE
def countZeros ( a , n ) : NEW_LINE INDENT count2 = 0 NEW_LINE count5 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT a [ i ] = a [ i ] // 2 NEW_LINE count2 = count2 + 1 NEW_LINE DEDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] = a [ i ] // 5 NEW_LINE count5 = count5 + 1 NEW_LINE DEDENT DEDENT if ( count2 < count5 ) : NEW_LINE INDENT return count2 NEW_LINE DEDENT else : NEW_LINE INDENT return count5 NEW_LINE DEDENT DEDENT a = [ 10 , 100 , 20 , 30 , 50 , 90 , 12 , 80 ] NEW_LINE n = len ( a ) NEW_LINE print ( countZeros ( a , n ) ) NEW_LINE
def squareSum ( n ) : NEW_LINE INDENT return int ( 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT ans = squareSum ( 8 ) NEW_LINE print ( ans ) NEW_LINE
import math NEW_LINE pwr = [ 0 ] * 10 NEW_LINE def isMunchhausen ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE temp = n NEW_LINE while ( temp ) : NEW_LINE INDENT sm = sm + pwr [ ( temp % 10 ) ] NEW_LINE temp = temp // 10 NEW_LINE DEDENT return ( sm == n ) NEW_LINE DEDENT def printMunchhausenNumbers ( n ) : NEW_LINE INDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT pwr [ i ] = math . pow ( ( float ) ( i ) , ( float ) ( i ) ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( isMunchhausen ( i ) ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT n = 10000 NEW_LINE printMunchhausenNumbers ( n ) NEW_LINE
def kthdigit ( a , b , k ) : NEW_LINE INDENT p = a ** b NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count = count + 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p / 10 ; NEW_LINE DEDENT DEDENT a = 5 NEW_LINE b = 2 NEW_LINE k = 1 NEW_LINE ans = kthdigit ( a , b , k ) NEW_LINE print ( ans ) NEW_LINE
import math NEW_LINE def digSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n % 9 == 0 : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 9 ) NEW_LINE DEDENT DEDENT def PowDigSum ( n , x ) : NEW_LINE INDENT sum = digSum ( n ) NEW_LINE rem = x % 6 NEW_LINE if ( ( sum == 3 or sum == 6 ) and x > 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT elif ( x == 1 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT elif ( x == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( rem == 0 ) : NEW_LINE INDENT return digSum ( math . pow ( sum , 6 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return digSum ( math . pow ( sum , rem ) ) NEW_LINE DEDENT DEDENT n = 33333 NEW_LINE x = 332654 NEW_LINE print ( PowDigSum ( n , x ) ) NEW_LINE
def maxArea ( A ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( A ) - 1 NEW_LINE area = 0 NEW_LINE while l < r : NEW_LINE INDENT area = max ( area , min ( A [ l ] , A [ r ] ) * ( r - l ) ) NEW_LINE if A [ l ] < A [ r ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return area NEW_LINE DEDENT a = [ 1 , 5 , 4 , 3 ] NEW_LINE b = [ 3 , 1 , 2 , 4 , 5 ] NEW_LINE print ( maxArea ( a ) ) NEW_LINE print ( maxArea ( b ) ) NEW_LINE
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i * i NEW_LINE DEDENT return True NEW_LINE DEDENT def mobius ( n ) : NEW_LINE INDENT p = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE p = p + 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE p = p + 1 NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT i = i + 2 NEW_LINE DEDENT if ( p % 2 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT N = 17 NEW_LINE print ( " Mobius defs M ( N ) at N = { } is : { } " . format ( N , mobius ( N ) ) ) ; NEW_LINE print ( " Mobius defs M ( N ) at N = 25 is : { } " . format ( mobius ( 25 ) ) ) ; NEW_LINE print ( " Mobius defs M ( N ) at N = 6 is : { } " . format ( mobius ( 6 ) ) ) ; NEW_LINE
def factorial ( start , end ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT def sumofsquare ( n ) : NEW_LINE INDENT return int ( factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( sumofsquare ( n ) ) NEW_LINE
PHI = 1.6180339 NEW_LINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT n = 9 NEW_LINE print ( n , " th ▁ Fibonacci ▁ Number ▁ = " , fib ( n ) ) NEW_LINE
def func ( x , y ) : NEW_LINE INDENT return ( x + y + x * y ) NEW_LINE DEDENT def euler ( x0 , y , h , x ) : NEW_LINE INDENT temp = - 0 NEW_LINE while x0 < x : NEW_LINE INDENT temp = y NEW_LINE y = y + h * func ( x0 , y ) NEW_LINE x0 = x0 + h NEW_LINE DEDENT print ( " Approximate ▁ solution ▁ at ▁ x ▁ = ▁ " , x , " ▁ is ▁ " , " % .6f " % y ) NEW_LINE DEDENT x0 = 0 NEW_LINE y0 = 1 NEW_LINE h = 0.025 NEW_LINE x = 0.1 NEW_LINE euler ( x0 , y0 , h , x ) NEW_LINE
def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( " x ▁ = ▁ " , i , " , ▁ y ▁ = ▁ " , int ( ( n - ( i * a ) ) / b ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( " No ▁ solution " ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE n = 7 NEW_LINE solution ( a , b , n ) NEW_LINE
import math NEW_LINE def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) ; NEW_LINE DEDENT n = 4 NEW_LINE print ( binomialCoeffSum ( n ) ) NEW_LINE
def precisionCompute ( x , y , n ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT print ( " Infinite " ) ; NEW_LINE return ; NEW_LINE DEDENT if x == 0 : NEW_LINE INDENT print ( 0 ) ; NEW_LINE return ; NEW_LINE DEDENT if n <= 0 : NEW_LINE INDENT print ( x / y ) ; NEW_LINE return ; NEW_LINE DEDENT if ( ( ( x > 0 ) and ( y < 0 ) ) or ( ( x < 0 ) and ( y > 0 ) ) ) : NEW_LINE INDENT print ( " - " , end = " " ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - x ; NEW_LINE DEDENT if y < 0 : NEW_LINE INDENT y = - y ; NEW_LINE DEDENT DEDENT d = x / y ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT print ( d ) ; NEW_LINE x = x - ( y * d ) ; NEW_LINE if x == 0 : NEW_LINE INDENT break ; NEW_LINE DEDENT x = x * 10 ; NEW_LINE d = x / y ; NEW_LINE if ( i == 0 ) : NEW_LINE INDENT print ( " . " , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT x = 22 ; NEW_LINE y = 7 ; NEW_LINE n = 15 ; NEW_LINE precisionCompute ( x , y , n ) ; NEW_LINE
def quadrant ( x , y ) : NEW_LINE INDENT if ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ First ▁ quadrant " ) NEW_LINE DEDENT elif ( x < 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Second ▁ quadrant " ) NEW_LINE DEDENT elif ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Third ▁ quadrant " ) NEW_LINE DEDENT elif ( x > 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ in ▁ Fourth ▁ quadrant " ) NEW_LINE DEDENT elif ( x == 0 and y > 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ positive ▁ y ▁ axis " ) NEW_LINE DEDENT elif ( x == 0 and y < 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ negative ▁ y ▁ axis " ) NEW_LINE DEDENT elif ( y == 0 and x < 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ negative ▁ x ▁ axis " ) NEW_LINE DEDENT elif ( y == 0 and x > 0 ) : NEW_LINE INDENT print ( " lies ▁ at ▁ positive ▁ x ▁ axis " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " lies ▁ at ▁ origin " ) NEW_LINE DEDENT DEDENT x = 1 NEW_LINE y = 1 NEW_LINE quadrant ( x , y ) NEW_LINE
def checkDigits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT dig = n % 10 NEW_LINE if ( dig != 2 and dig != 3 and dig != 5 and dig != 7 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def isFullPrime ( n ) : NEW_LINE INDENT return ( checkDigits ( n ) and prime ( n ) ) NEW_LINE DEDENT n = 53 NEW_LINE if ( isFullPrime ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def nthSHN ( n , dp ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT dp [ n ] = 1 NEW_LINE return dp [ n ] NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n NEW_LINE return dp [ n ] NEW_LINE DEDENT n = 6 ; NEW_LINE dp = [ - 1 for i in range ( 500 ) ] NEW_LINE print ( nthSHN ( n , dp ) ) NEW_LINE
def evensum ( n ) : NEW_LINE INDENT curr = 2 NEW_LINE sum = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum += curr NEW_LINE curr += 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 20 NEW_LINE print ( " sum ▁ of ▁ first ▁ " , n , " even ▁ number ▁ is : ▁ " , evensum ( n ) ) NEW_LINE
def evensum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) NEW_LINE DEDENT n = 20 NEW_LINE print ( " sum ▁ of ▁ first " , n , " even ▁ number ▁ is : ▁ " , evensum ( n ) ) NEW_LINE
def kmphTOmph ( kmph ) : NEW_LINE INDENT mph = 0.6214 * kmph NEW_LINE return mph NEW_LINE DEDENT def mphTOkmph ( mph ) : NEW_LINE INDENT kmph = ( float ) ( mph * 1.60934 ) NEW_LINE return kmph NEW_LINE DEDENT / * Driver code to check the above function * / NEW_LINE kmph = 150 NEW_LINE mph = 100 NEW_LINE print " speed ▁ in ▁ miles ▁ / ▁ hr ▁ is ▁ " , kmphTOmph ( kmph ) NEW_LINE print " speed ▁ in ▁ km ▁ / ▁ hr ▁ is ▁ " , mphTOkmph ( mph ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == ans ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( findNumber ( arr , n ) ) NEW_LINE
primes = [ ] ; NEW_LINE def SieveofEratosthenes ( n ) : NEW_LINE INDENT visited = [ False ] * ( n + 2 ) ; NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT for j in range ( i * i , n + 2 , i ) : NEW_LINE INDENT visited [ j ] = True ; NEW_LINE DEDENT primes . append ( i ) ; NEW_LINE DEDENT DEDENT DEDENT def specialPrimeNumbers ( n , k ) : NEW_LINE INDENT SieveofEratosthenes ( n ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT for j in range ( i - 1 ) : NEW_LINE INDENT if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( count == k ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT n = 27 ; NEW_LINE k = 2 ; NEW_LINE if ( specialPrimeNumbers ( n , k ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
import math NEW_LINE def factorize ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( ( n % 2 > 0 ) == False ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( 2 , count ) ; NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( i , count ) ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( n , 1 ) ; NEW_LINE DEDENT DEDENT n = 1000000000000000000 ; NEW_LINE factorize ( n ) ; NEW_LINE
def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return __gcd ( b % a , a ) NEW_LINE DEDENT def minimumMoves ( A , N ) : NEW_LINE INDENT one = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT if ( one != 0 ) : NEW_LINE INDENT return N - one NEW_LINE DEDENT minimum = + 2147483647 NEW_LINE for i in range ( N ) : NEW_LINE INDENT g = A [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT g = __gcd ( A [ j ] , g ) NEW_LINE if ( g == 1 ) : NEW_LINE INDENT minimum = min ( minimum , j - i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minimum == + 2147483647 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return N + minimum - 1 ; NEW_LINE DEDENT DEDENT A = [ 2 , 4 , 3 , 9 ] NEW_LINE N = len ( A ) NEW_LINE print ( minimumMoves ( A , N ) ) NEW_LINE
import math NEW_LINE def series ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( "0" , end = ' ▁ ' ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT print ( " % .5f " % ( ( math . pow ( - 1 , i ) * d ) ) , end = ' ▁ ' ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m = n NEW_LINE r = ( m / ( m - 1 ) ) NEW_LINE g = ( float ) ( d * float ( math . sqrt ( r ) ) ) NEW_LINE print ( "0 ▁ " , end = ' ▁ ' ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT print ( " % .5f " % ( math . pow ( - 1 , i ) * g ) , end = ' ▁ ' ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( " " ) NEW_LINE DEDENT n = 3 NEW_LINE d = 3 NEW_LINE series ( n , d ) NEW_LINE
def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT str1 = str ( i ) ; NEW_LINE countr += str1 . count ( "1" ) ; NEW_LINE DEDENT return countr ; NEW_LINE DEDENT n = 13 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE n = 131 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE n = 159 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE
N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * bas ) % N ; NEW_LINE DEDENT bas = ( bas * bas ) % N ; NEW_LINE exp = int ( exp / 2 ) ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE
import math NEW_LINE def gcdOfFactorial ( m , n ) : NEW_LINE INDENT return math . factorial ( min ( m , n ) ) NEW_LINE DEDENT m = 5 NEW_LINE n = 9 NEW_LINE print ( gcdOfFactorial ( m , n ) ) NEW_LINE
def recDigSum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if n % 9 == 0 : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return n % 9 NEW_LINE DEDENT DEDENT DEDENT def check ( n ) : NEW_LINE INDENT n = recDigSum ( n ) NEW_LINE if n == 2 or n == 3 or n == 5 or n == 7 : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT DEDENT n = 5602 NEW_LINE check ( n ) NEW_LINE
import math NEW_LINE def findNumber ( n ) : NEW_LINE INDENT x = int ( math . floor ( ( - 1 + math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ) NEW_LINE base = ( x * ( x + 1 ) ) / 2 + 1 NEW_LINE return n - base + 1 NEW_LINE DEDENT n = 55 NEW_LINE print ( findNumber ( n ) ) NEW_LINE
def weightedMean ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) / 3 NEW_LINE DEDENT n = 10 NEW_LINE print ( int ( weightedMean ( n ) ) ) NEW_LINE
import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] / mul ) NEW_LINE print ( x , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE
def bomb_required ( n ) : NEW_LINE INDENT print ( n + n // 2 ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 2 , n , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT bomb_required ( 3 ) NEW_LINE
def lcm_fun ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return lcm_fun ( b , a % b ) ; NEW_LINE DEDENT def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = int ( ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ) ; NEW_LINE if ( lcm == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE DEDENT return lcm ; NEW_LINE DEDENT n = 397 ; NEW_LINE print ( digitLCM ( n ) ) ; NEW_LINE
import random NEW_LINE import math NEW_LINE e = 2.71828 ; NEW_LINE def roundNo ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return ( num - 0.5 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( num + 0.5 ) ; NEW_LINE DEDENT DEDENT def printBestCandidate ( candidate , n ) : NEW_LINE INDENT sample_size = roundNo ( n / e ) ; NEW_LINE print ( " Sample size is " , math . floor ( sample_size ) ) ; NEW_LINE best = 0 ; NEW_LINE for i in range ( 1 , int ( sample_size ) ) : NEW_LINE INDENT if ( candidate [ i ] > candidate [ best ] ) : NEW_LINE INDENT best = i ; NEW_LINE DEDENT DEDENT for i in range ( int ( sample_size ) , n ) : NEW_LINE INDENT if ( candidate [ i ] >= candidate [ best ] ) : NEW_LINE INDENT best = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( best >= int ( sample_size ) ) : NEW_LINE INDENT print ( " Best candidate found is " , math . floor ( best + 1 ) , " with ▁ talent " , math . floor ( candidate [ best ] ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Couldn ' t ▁ find ▁ a ▁ best ▁ candidate " ) ; NEW_LINE DEDENT DEDENT n = 8 ; NEW_LINE candidate = [ 0 ] * ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT candidate [ i ] = 1 + random . randint ( 1 , 8 ) ; NEW_LINE DEDENT print ( " Candidate ▁ : ▁ " , end = " " ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ( i + 1 ) , end = " ▁ " ) ; NEW_LINE DEDENT print ( " Talents : " , ▁ end ▁ = ▁ " " ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( candidate [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT printBestCandidate ( candidate , n ) ; NEW_LINE
def sumDigitSquare ( n ) : NEW_LINE INDENT sq = 0 NEW_LINE while ( n ) : NEW_LINE INDENT digit = n % 10 NEW_LINE sq = sq + digit * digit NEW_LINE n = n // 10 NEW_LINE DEDENT return sq NEW_LINE DEDENT def isHappy ( n ) : NEW_LINE INDENT while ( 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT n = sumDigitSquare ( n ) NEW_LINE if ( n == 4 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 23 NEW_LINE if ( isHappy ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findSumSubsets ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findSumSubsets ( n ) ) NEW_LINE
import math as m NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE x = m . exp ( _sum / n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE
import math NEW_LINE def countdigits ( N ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( N ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE N = int ( math . floor ( N / 10 ) ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def cyclic ( N ) : NEW_LINE INDENT num = N ; NEW_LINE n = countdigits ( N ) ; NEW_LINE while ( 1 ) : NEW_LINE INDENT print ( int ( num ) ) ; NEW_LINE rem = num % 10 ; NEW_LINE div = math . floor ( num / 10 ) ; NEW_LINE num = ( ( math . pow ( 10 , n - 1 ) ) * rem + div ) ; NEW_LINE if ( num == N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT N = 5674 ; NEW_LINE cyclic ( N ) ; NEW_LINE
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def checkCircular ( N ) : NEW_LINE INDENT count = 0 NEW_LINE temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE temp = temp / 10 NEW_LINE DEDENT num = N ; NEW_LINE while ( isPrime ( num ) ) : NEW_LINE INDENT rem = num % 10 NEW_LINE div = num / 10 NEW_LINE num = ( int ) ( ( math . pow ( 10 , count - 1 ) ) * rem ) + div NEW_LINE if ( num == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT N = 1193 ; NEW_LINE if ( checkCircular ( N ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def sackRace ( p1 , s1 , p2 , s2 ) : NEW_LINE INDENT return ( ( s1 > s2 and ( p2 - p1 ) % ( s1 - s2 ) == 0 ) or ( s2 > s1 and ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) NEW_LINE DEDENT p1 = 4 NEW_LINE s1 = 4 NEW_LINE p2 = 8 NEW_LINE s2 = 2 NEW_LINE if ( sackRace ( p1 , s1 , p2 , s2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def solve ( n ) : NEW_LINE INDENT a = float ( n / 2 ) ; NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT print ( ( math . ceil ( a ) - 1 ) , ( math . floor ( a ) + 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( a % 2 == 0 ) : NEW_LINE INDENT print ( ( math . ceil ( a ) - 1 ) , ( math . floor ( a ) + 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( math . ceil ( a ) - 2 ) , ( math . floor ( a ) + 2 ) ) ; NEW_LINE DEDENT DEDENT DEDENT n = 34 ; NEW_LINE solve ( n ) ; NEW_LINE
P = 1 NEW_LINE R = 1 NEW_LINE T = 1 NEW_LINE SI = ( P * R * T ) / 100 NEW_LINE print ( " simple ▁ interest ▁ is " , SI ) NEW_LINE
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( " Number ▁ of ▁ digits ▁ = ▁ " , countDigits ( a , b ) ) NEW_LINE
import math NEW_LINE def multiple ( a , b , x ) : NEW_LINE INDENT if ( b < 0 ) : NEW_LINE INDENT if ( a == 1 and x == 1 ) : NEW_LINE INDENT print ( "1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0" ) ; NEW_LINE DEDENT DEDENT mul = int ( pow ( a , b ) ) ; NEW_LINE ans = int ( mul / x ) ; NEW_LINE ans1 = x * ans ; NEW_LINE ans2 = x * ( ans + 1 ) ; NEW_LINE if ( ( mul - ans1 ) <= ( ans2 - mul ) ) : NEW_LINE INDENT print ( ans1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans2 ) ; NEW_LINE DEDENT DEDENT a = 349 ; NEW_LINE b = 1 ; NEW_LINE x = 4 ; NEW_LINE multiple ( a , b , x ) ; NEW_LINE
def maxSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE print ( maxSum ( n ) ) NEW_LINE
def minNum ( arr , n ) : NEW_LINE INDENT odd = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd = not odd NEW_LINE DEDENT DEDENT if ( odd ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print minNum ( arr , n ) NEW_LINE
def checkJumbled ( num ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( num != 0 ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT digit1 = num % 10 NEW_LINE digit2 = ( num / 10 ) % 10 NEW_LINE if ( abs ( digit2 - digit1 ) > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = num / 10 NEW_LINE DEDENT return True NEW_LINE DEDENT num = - 1234 NEW_LINE if ( checkJumbled ( abs ( num ) ) ) : NEW_LINE INDENT print " True ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT print " False " NEW_LINE DEDENT num = - 1247 NEW_LINE if ( checkJumbled ( abs ( num ) ) ) : NEW_LINE INDENT print " True ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT print " False " NEW_LINE DEDENT
def msbPos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE while n != 0 : NEW_LINE INDENT pos += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT def josephify ( n ) : NEW_LINE INDENT position = msbPos ( n ) NEW_LINE DEDENT ' NEW_LINE INDENT j = 1 << ( position - 1 ) NEW_LINE n = n ^ j NEW_LINE n = n << 1 NEW_LINE n = n | 1 NEW_LINE return n NEW_LINE DEDENT n = 41 NEW_LINE print ( josephify ( n ) ) NEW_LINE
def countXorPair ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countXorPair ( arr , n ) ) NEW_LINE DEDENT
import math ; NEW_LINE def powmod ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) ; NEW_LINE value = [ 0 ] * m ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT value [ powmod ( a , i * n , m ) ] = i ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT cur = ( powmod ( a , j , m ) * b ) % m ; NEW_LINE if ( value [ cur ] ) : NEW_LINE INDENT ans = value [ cur ] * n - j ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT DEDENT return - 1 ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE m = 5 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE a = 3 ; NEW_LINE b = 7 ; NEW_LINE m = 11 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE
import math ; NEW_LINE def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) ; NEW_LINE an = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m ; NEW_LINE DEDENT value = [ 0 ] * m ; NEW_LINE cur = an ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i ; NEW_LINE DEDENT cur = ( cur * an ) % m ; NEW_LINE DEDENT cur = b ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE m = 5 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE a = 3 ; NEW_LINE b = 7 ; NEW_LINE m = 11 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE
def nthprimedigitsnumber ( number ) : NEW_LINE INDENT num = " " ; NEW_LINE while ( number > 0 ) : NEW_LINE INDENT rem = number % 4 ; NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT num += '2' ; NEW_LINE DEDENT if ( rem == 2 ) : NEW_LINE INDENT num += '3' ; NEW_LINE DEDENT if ( rem == 3 ) : NEW_LINE INDENT num += '5' ; NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT num += '7' ; NEW_LINE DEDENT if ( number % 4 == 0 ) : NEW_LINE INDENT number = number - 1 NEW_LINE DEDENT number = number // 4 ; NEW_LINE DEDENT return num [ : : - 1 ] ; NEW_LINE DEDENT number = 21 ; NEW_LINE print ( nthprimedigitsnumber ( 10 ) ) ; NEW_LINE print ( nthprimedigitsnumber ( number ) ) ; NEW_LINE
import math NEW_LINE def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( math . pow ( N , 1 / 3 ) + 1 ) ) : NEW_LINE INDENT cb = i * i * i NEW_LINE diff = N - cb NEW_LINE cbrtDiff = int ( math . pow ( diff , 1 / 3 ) ) NEW_LINE if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( ' For ▁ n ▁ = ▁ ' , i , ' , ▁ ' , countPairs ( i ) , ' ▁ pair ▁ exists ' ) NEW_LINE DEDENT
def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] ; NEW_LINE if ( d == 0 ) : NEW_LINE INDENT print ( " Infinite ▁ solution " ) NEW_LINE return NEW_LINE DEDENT v = [ ] ; NEW_LINE i = 1 ; NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) ; NEW_LINE if ( i != d / i ) : NEW_LINE INDENT v . append ( d / i ) ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] ; NEW_LINE j = 1 ; NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 38 , 6 , 34 ] ; NEW_LINE printEqualModNumbers ( arr , len ( arr ) ) ; NEW_LINE
import math NEW_LINE def FirstDigit ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + math . log10 ( arr [ i ] * 1.0 ) NEW_LINE DEDENT fract_S = S - math . floor ( S ) NEW_LINE ans = math . pow ( 10 , fract_S ) NEW_LINE return ans NEW_LINE DEDENT arr = [ 5 , 8 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ( int ) ( FirstDigit ( arr , n ) ) ) NEW_LINE
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while temp != 0 : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if d > 0 and n % d == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1012 NEW_LINE print ( countDigit ( n ) ) NEW_LINE
def makeOdd ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT resul = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 ; NEW_LINE resul = resul * 2 ; NEW_LINE DEDENT return resul ; NEW_LINE DEDENT n = 36 ; NEW_LINE print ( makeOdd ( n ) ) ; NEW_LINE
def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x / 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT n = 56287 ; NEW_LINE x = 27 ; NEW_LINE print ( closestMultiple ( n , x ) ) ; NEW_LINE
def cbrt ( n ) : NEW_LINE INDENT return ( int ) ( n ** ( 1. / 3 ) ) NEW_LINE DEDENT def printCubes ( a , b ) : NEW_LINE INDENT acrt = cbrt ( a ) NEW_LINE bcrt = cbrt ( b ) NEW_LINE for i in range ( acrt , bcrt + 1 ) : NEW_LINE INDENT if ( i * i * i >= a and i * i * i <= b ) : NEW_LINE INDENT print ( i * i * i , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT a = 24 NEW_LINE b = 576 NEW_LINE print ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : " ) NEW_LINE printCubes ( a , b ) NEW_LINE
def number0f2s ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def numberOf2sinRange ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT count = count + number0f2s ( i ) NEW_LINE DEDENT return count NEW_LINE DEDENT print ( numberOf2sinRange ( 22 ) ) NEW_LINE print ( numberOf2sinRange ( 100 ) ) NEW_LINE
def minToggle ( arr , n ) : NEW_LINE INDENT zero = [ 0 for i in range ( n + 1 + 1 ) ] NEW_LINE zero [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] == 0 ) : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] NEW_LINE DEDENT DEDENT ans = n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minToggle ( arr , n ) ) NEW_LINE
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT st = "1332" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) NEW_LINE DEDENT
def checkRecursive ( num , rem_num , next_int , n , ans = 0 ) : NEW_LINE INDENT if ( rem_num == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT r = int ( num ** ( 1 / n ) ) NEW_LINE for i in range ( next_int + 1 , r + 1 ) : NEW_LINE INDENT a = rem_num - int ( i ** n ) NEW_LINE if a >= 0 : NEW_LINE INDENT ans += checkRecursive ( num , rem_num - int ( i ** n ) , i , n , 0 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def check ( x , n ) : NEW_LINE INDENT return checkRecursive ( x , x , 0 , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( check ( 10 , 2 ) ) NEW_LINE DEDENT
import math ; NEW_LINE def reverseNum ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE rev = ( rev * 10 ) + rem ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def isPalindrom ( num ) : NEW_LINE INDENT return num == reverseNum ( num ) ; NEW_LINE DEDENT def nthPalindrome ( n , k ) : NEW_LINE INDENT num = math . pow ( 10 , k - 1 ) ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPalindrom ( num ) ) : NEW_LINE INDENT n -= 1 ; NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT num += 1 ; NEW_LINE DEDENT return int ( num ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE k = 5 ; NEW_LINE print ( n , " th ▁ palindrome ▁ of " , k , " digit ▁ = " , nthPalindrome ( n , k ) ) ; NEW_LINE n = 10 ; NEW_LINE k = 6 ; NEW_LINE print ( n , " th ▁ palindrome ▁ of " , k , " digit ▁ = " , nthPalindrome ( n , k ) ) ; NEW_LINE
def nthPalindrome ( n , k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT temp = k // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = k // 2 - 1 NEW_LINE DEDENT palindrome = 10 ** temp NEW_LINE palindrome = palindrome + n - 1 NEW_LINE print ( palindrome , end = " " ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while ( palindrome ) : NEW_LINE INDENT print ( palindrome % 10 , end = " " ) NEW_LINE palindrome = palindrome // 10 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 5 NEW_LINE print ( n , " th ▁ palindrome ▁ of " , k , " ▁ digit ▁ = ▁ " , end = " ▁ " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE print ( ) NEW_LINE n = 10 NEW_LINE k = 6 NEW_LINE print ( n , " th ▁ palindrome ▁ of " , k , " digit ▁ = ▁ " , end = " ▁ " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE DEDENT
MAX = 100001 NEW_LINE phi = [ 0 ] * MAX NEW_LINE result = [ 0 ] * MAX NEW_LINE def computeTotient ( ) : NEW_LINE INDENT phi [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if not phi [ i ] : NEW_LINE INDENT phi [ i ] = i - 1 NEW_LINE for j in range ( i << 1 , MAX , i ) : NEW_LINE INDENT if not phi [ j ] : NEW_LINE INDENT phi [ j ] = j NEW_LINE DEDENT phi [ j ] = ( ( phi [ j ] // i ) * ( i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumOfGcdPairs ( ) : NEW_LINE INDENT computeTotient ( ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( 2 , MAX ) : NEW_LINE INDENT if i * j >= MAX : NEW_LINE INDENT break NEW_LINE DEDENT result [ i * j ] += i * phi [ j ] NEW_LINE DEDENT DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT result [ i ] += result [ i - 1 ] NEW_LINE DEDENT DEDENT sumOfGcdPairs ( ) NEW_LINE N = 4 NEW_LINE print ( " Summation ▁ of " , N , " = " , result [ N ] ) NEW_LINE N = 12 NEW_LINE print ( " Summation ▁ of " , N , " = " , result [ N ] ) NEW_LINE N = 5000 NEW_LINE print ( " Summation ▁ of " , N , " = " , result [ N ] ) NEW_LINE
N = 3 NEW_LINE def solve ( v ) : NEW_LINE INDENT res = [ ] NEW_LINE all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] NEW_LINE res . append ( all3 - v [ 1 ] * 2 ) NEW_LINE res . append ( all3 - v [ 2 ] * 2 ) NEW_LINE res . append ( all3 - v [ 0 ] * 2 ) NEW_LINE return res NEW_LINE DEDENT def findVertex ( xmid , ymid ) : NEW_LINE INDENT V1 = solve ( xmid ) NEW_LINE V2 = solve ( ymid ) NEW_LINE for i in range ( 0 , 3 ) : NEW_LINE INDENT print ( V1 [ i ] , end = " ▁ " ) NEW_LINE print ( V2 [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT xmid = [ 5 , 4 , 5 ] NEW_LINE ymid = [ 3 , 4 , 5 ] NEW_LINE findVertex ( xmid , ymid ) NEW_LINE DEDENT
def nthElement ( a , b , n ) : NEW_LINE INDENT seq = [ ] ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT seq . append ( a * i ) ; NEW_LINE DEDENT seq . sort ( ) ; NEW_LINE i = 1 ; NEW_LINE k = n ; NEW_LINE while ( i <= n and k > 0 ) : NEW_LINE INDENT try : NEW_LINE INDENT z = seq . index ( b * i ) ; NEW_LINE DEDENT except ValueError : NEW_LINE INDENT seq . append ( b * i ) ; NEW_LINE seq . sort ( ) ; NEW_LINE k -= 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return seq [ n - 1 ] ; NEW_LINE DEDENT a = 3 ; NEW_LINE b = 5 ; NEW_LINE n = 5 ; NEW_LINE print ( nthElement ( a , b , n ) ) ; NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT return gcd ( b , a % b ) if b > 0 else a NEW_LINE DEDENT def countGCD ( L , R , g ) : NEW_LINE INDENT L = ( L + g - 1 ) // g NEW_LINE R = R // g NEW_LINE ans = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT for j in range ( L , R + 1 ) : NEW_LINE INDENT if ( gcd ( i , j ) == 1 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT L = 1 NEW_LINE R = 11 NEW_LINE g = 5 NEW_LINE print ( countGCD ( L , R , g ) ) NEW_LINE
dig = [ 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 ] NEW_LINE def lastNon0Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 14 NEW_LINE print ( lastNon0Digit ( n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x /= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def sieve ( prime , n ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def maxDigitInPrimes ( L , R ) : NEW_LINE INDENT prime = [ 0 ] * ( R + 1 ) NEW_LINE sieve ( prime , R ) NEW_LINE freq = [ 0 ] * 10 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT while ( p ) : NEW_LINE INDENT freq [ p % 10 ] += 1 NEW_LINE p //= 10 NEW_LINE DEDENT DEDENT DEDENT max = freq [ 0 ] NEW_LINE ans = 0 NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT if ( max <= freq [ j ] ) : NEW_LINE INDENT max = freq [ j ] NEW_LINE ans = j NEW_LINE DEDENT DEDENT if max == 0 NEW_LINE return - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 1 NEW_LINE R = 20 NEW_LINE print ( maxDigitInPrimes ( L , R ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE result = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += 2 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 12 NEW_LINE b = 24 ; NEW_LINE print ( commDiv ( a , b ) ) NEW_LINE DEDENT
def spellsCount ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE result = 1 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 ; NEW_LINE while ( i < n - 1 and num [ i + 1 ] == num [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT result = result * int ( pow ( 2 , count - 1 ) ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT num = "11112" ; NEW_LINE print ( spellsCount ( num ) ) ; NEW_LINE
def numSquareSum ( n ) : NEW_LINE INDENT squareSum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT squareSum += ( n % 10 ) * ( n % 10 ) ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return squareSum ; NEW_LINE DEDENT def isHappynumber ( n ) : NEW_LINE INDENT slow = n ; NEW_LINE fast = n ; NEW_LINE while ( True ) : NEW_LINE INDENT slow = numSquareSum ( slow ) ; NEW_LINE fast = numSquareSum ( numSquareSum ( fast ) ) ; NEW_LINE if ( slow != fast ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return ( slow == 1 ) ; NEW_LINE DEDENT n = 13 ; NEW_LINE if ( isHappynumber ( n ) ) : NEW_LINE INDENT print ( n , " is ▁ a ▁ Happy ▁ number " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is ▁ not ▁ a ▁ Happy ▁ number " ) ; NEW_LINE DEDENT
allPrimes = [ ] ; NEW_LINE def sieve ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT allPrimes . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT def factorialDivisors ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( len ( allPrimes ) ) : NEW_LINE INDENT p = allPrimes [ i ] ; NEW_LINE exp = 0 ; NEW_LINE while ( p <= n ) : NEW_LINE INDENT exp = exp + int ( n / p ) ; NEW_LINE p = p * allPrimes [ i ] ; NEW_LINE DEDENT result = result * ( exp + 1 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT print ( factorialDivisors ( 6 ) ) ; NEW_LINE
def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev = 1 NEW_LINE prev = 2 NEW_LINE curr = 3 NEW_LINE while n > 0 : NEW_LINE INDENT prevPrev = prev NEW_LINE prev = curr NEW_LINE curr = prevPrev + prev NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT print ( nonFibonacci ( 5 ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( ( a b ) & 1 ) == 0 ) : NEW_LINE INDENT a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( ( a & 1 ) == 0 ) : NEW_LINE INDENT a = a >> 1 NEW_LINE DEDENT while ( b != 0 ) : NEW_LINE INDENT while ( ( b & 1 ) == 0 ) : NEW_LINE INDENT b = b >> 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT return ( a << k ) NEW_LINE DEDENT a = 34 NEW_LINE b = 17 NEW_LINE print ( " Gcd ▁ of ▁ given ▁ numbers ▁ is ▁ " , gcd ( a , b ) ) NEW_LINE
def findNDigitNumsUtil ( n , out , index , evenSum , oddSum ) : NEW_LINE INDENT if ( index > n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT if ( abs ( evenSum - oddSum ) == 1 ) : NEW_LINE INDENT out [ index ] = ' ' NEW_LINE out = ' ' . join ( out ) NEW_LINE print ( out , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT if ( index & 1 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , out , index + 1 , evenSum , oddSum + i ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) NEW_LINE DEDENT DEDENT DEDENT def findNDigitNums ( n ) : NEW_LINE INDENT out = [ 0 ] * ( n + 1 ) NEW_LINE index = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE findNDigitNums ( n ) NEW_LINE DEDENT
one = [ " " , " one ▁ " , " two ▁ " , " three ▁ " , " four ▁ " , " five ▁ " , " six ▁ " , " seven ▁ " , " eight ▁ " , " nine ▁ " , " ten ▁ " , " eleven ▁ " , " twelve ▁ " , " thirteen ▁ " , " fourteen ▁ " , " fifteen ▁ " , " sixteen ▁ " , " seventeen ▁ " , " eighteen ▁ " , " nineteen ▁ " ] ; NEW_LINE ten = [ " " , " " , " twenty ▁ " , " thirty ▁ " , " forty ▁ " , " fifty ▁ " , " sixty ▁ " , " seventy ▁ " , " eighty ▁ " , " ninety ▁ " ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = " " ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n // 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] ; NEW_LINE DEDENT if ( n ) : NEW_LINE INDENT str += s ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = " " ; NEW_LINE out += numToWords ( ( n // 10000000 ) , " crore ▁ " ) ; NEW_LINE out += numToWords ( ( ( n // 100000 ) % 100 ) , " lakh ▁ " ) ; NEW_LINE out += numToWords ( ( ( n // 1000 ) % 100 ) , " thousand ▁ " ) ; NEW_LINE out += numToWords ( ( ( n // 100 ) % 10 ) , " hundred ▁ " ) ; NEW_LINE if ( n > 100 and n % 100 ) : NEW_LINE INDENT out += " and ▁ " ; NEW_LINE DEDENT out += numToWords ( ( n % 100 ) , " " ) ; NEW_LINE return out ; NEW_LINE DEDENT n = 438237764 ; NEW_LINE print ( convertToWords ( n ) ) ; NEW_LINE
from math import gcd NEW_LINE def isPossible ( a , b , c ) : NEW_LINE INDENT return ( c % gcd ( a , b ) == 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE b = 6 NEW_LINE c = 9 NEW_LINE if ( isPossible ( a , b , c ) ) : NEW_LINE INDENT print ( " Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT a = 3 NEW_LINE b = 6 NEW_LINE c = 8 NEW_LINE if ( isPossible ( a , b , c ) ) : NEW_LINE INDENT print ( " Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT a = 2 NEW_LINE b = 5 NEW_LINE c = 1 NEW_LINE if ( isPossible ( a , b , c ) ) : NEW_LINE INDENT print ( " Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def farey ( n ) : NEW_LINE INDENT x1 = 0 ; NEW_LINE y1 = 1 ; NEW_LINE x2 = 1 ; NEW_LINE y2 = n ; NEW_LINE print ( x1 , end = " " ) NEW_LINE print ( " / " , end = " " ) NEW_LINE print ( y1 , x2 , end = " " ) NEW_LINE print ( " / " , end = " " ) NEW_LINE print ( y2 , end = " ▁ " ) ; NEW_LINE x = 0 ; NEW_LINE y = 0 ; NEW_LINE while ( y != 1.0 ) : NEW_LINE INDENT x = math . floor ( ( y1 + n ) / y2 ) * x2 - x1 ; NEW_LINE y = math . floor ( ( y1 + n ) / y2 ) * y2 - y1 ; NEW_LINE print ( x , end = " " ) NEW_LINE print ( " / " , end = " " ) NEW_LINE print ( y , end = " ▁ " ) ; NEW_LINE x1 = x2 ; NEW_LINE x2 = x ; NEW_LINE y1 = y2 ; NEW_LINE y2 = y ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE print ( " Farey ▁ Sequence ▁ of ▁ order " , n , " is " ) ; NEW_LINE farey ( n ) ; NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return ( gcd ( b , a % b ) ) NEW_LINE DEDENT def findSmallest ( a , b ) : NEW_LINE INDENT lcm = ( a * b ) / gcd ( a , b ) NEW_LINE print ( " x ▁ = " , lcm / a ,   " y =   " , lcm / b ) NEW_LINE DEDENT a = 25 NEW_LINE b = 35 NEW_LINE findSmallest ( a , b ) NEW_LINE
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( a , p ) : NEW_LINE INDENT return power ( a , p - 2 , p ) NEW_LINE DEDENT def modFact ( n , p ) : NEW_LINE INDENT if ( p <= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( p - 1 ) NEW_LINE for i in range ( n + 1 , p ) : NEW_LINE INDENT res = ( res * modInverse ( i , p ) ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT n = 25 NEW_LINE p = 29 NEW_LINE print ( modFact ( n , p ) ) NEW_LINE
def countWays ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT
def pairAndSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] & arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 10 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairAndSum ( arr , n ) ) NEW_LINE
def pairAndSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT k = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT k = k + 1 NEW_LINE DEDENT DEDENT ans = ans + ( 1 << i ) * ( k * ( k - 1 ) // 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 10 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairAndSum ( arr , n ) ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT print ( " true " ) if isPrime ( 11 ) else print ( " false " ) NEW_LINE print ( " true " ) if isPrime ( 14 ) else print ( " false " ) NEW_LINE
def computeTotient ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " Totient ▁ of ▁ " , i , " ▁ is ▁ " , phi [ i ] ) NEW_LINE DEDENT DEDENT n = 12 NEW_LINE computeTotient ( n ) NEW_LINE
def sumBetweenTwoKth ( arr , n , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( k1 , k2 - 1 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 20 , 8 , 22 , 4 , 12 , 10 , 14 ] NEW_LINE k1 = 3 ; k2 = 6 NEW_LINE n = len ( arr ) NEW_LINE print ( sumBetweenTwoKth ( arr , n , k1 , k2 ) ) NEW_LINE
def countSquares ( n ) : NEW_LINE INDENT return ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Count ▁ of ▁ squares ▁ is ▁ " , countSquares ( n ) ) NEW_LINE
def nthMagicNo ( n ) : NEW_LINE INDENT pow = 1 NEW_LINE answer = 0 NEW_LINE while ( n ) : NEW_LINE INDENT pow = pow * 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT answer += pow NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT n = 5 NEW_LINE print ( " nth ▁ magic ▁ number ▁ is " , nthMagicNo ( n ) ) NEW_LINE
def countOfMultiples ( n ) : NEW_LINE INDENT return ( int ( n / 3 ) + int ( n / 5 ) - int ( n / 15 ) ) ; NEW_LINE DEDENT print ( countOfMultiples ( 6 ) ) NEW_LINE print ( countOfMultiples ( 16 ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def isDefeat ( s1 , s2 , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( s1 [ i ] == '0' and s2 [ i ] == '1' ) or ( s1 [ i ] == '1' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( s1 [ i ] == '0' and s2 [ i ] == ' Z ' ) or ( s1 [ i ] == ' Z ' and s2 [ i ] == '0' ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s1 = "01001101ZZ " NEW_LINE s2 = "10Z1001000" NEW_LINE n = 10 NEW_LINE if ( isDefeat ( s1 , s2 , n ) ) : NEW_LINE INDENT print ( " Defeat " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Victory " ) NEW_LINE DEDENT
N = 3 NEW_LINE M = 3 NEW_LINE def check ( a , b ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT for j in range ( 1 , M , 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] != b [ i ] [ j ] ) : NEW_LINE INDENT a [ i ] [ j ] ^= 1 NEW_LINE a [ 0 ] [ 0 ] ^= 1 NEW_LINE a [ 0 ] [ j ] ^= 1 NEW_LINE a [ i ] [ 0 ] ^= 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( a [ i ] [ j ] != b [ i ] [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ [ 0 , 1 , 0 ] , [ 0 , 1 , 0 ] , [ 1 , 0 , 0 ] ] NEW_LINE b = [ [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] ] NEW_LINE if ( check ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def FindIndexKthBit ( n , k ) : NEW_LINE INDENT cnt , ind = 0 , 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt == k : NEW_LINE INDENT return ind NEW_LINE DEDENT ind += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 15 , 3 NEW_LINE ans = FindIndexKthBit ( n , k ) NEW_LINE if ans != - 1 : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ k - th ▁ set ▁ bit " ) NEW_LINE DEDENT DEDENT
from math import log2 NEW_LINE def minDistance ( n1 , n2 ) : NEW_LINE INDENT bitCount1 = int ( log2 ( n1 ) ) + 1 NEW_LINE bitCount2 = int ( log2 ( n2 ) ) + 1 NEW_LINE bitDiff = abs ( bitCount1 - bitCount2 ) NEW_LINE maxBitCount = max ( bitCount1 , bitCount2 ) NEW_LINE if ( bitCount1 > bitCount2 ) : NEW_LINE INDENT n2 = int ( n2 * pow ( 2 , bitDiff ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 = int ( n1 * pow ( 2 , bitDiff ) ) NEW_LINE DEDENT xorValue = n1 ^ n2 NEW_LINE if xorValue == 0 : NEW_LINE INDENT bitCountXorValue = 1 NEW_LINE DEDENT else : NEW_LINE INDENT bitCountXorValue = int ( log2 ( xorValue ) ) + 1 NEW_LINE DEDENT disSimilarBitPosition = ( maxBitCount - bitCountXorValue ) NEW_LINE result = ( bitCount1 + bitCount2 - 2 * disSimilarBitPosition ) NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n1 = 12 NEW_LINE n2 = 5 NEW_LINE print ( minDistance ( n1 , n2 ) ) NEW_LINE DEDENT
def printMaxAfterRemoval ( s ) : NEW_LINE INDENT flag = False NEW_LINE n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if s [ i ] == '0' and flag == False : NEW_LINE INDENT flag = True NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ i ] , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "1001" NEW_LINE printMaxAfterRemoval ( s ) NEW_LINE DEDENT
from math import floor , log2 NEW_LINE def bitPos ( n1 , n2 ) : NEW_LINE INDENT if n1 == n2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT bitCount1 = floor ( log2 ( n1 ) ) + 1 NEW_LINE bitCount2 = floor ( log2 ( n2 ) ) + 1 NEW_LINE bitDiff = abs ( bitCount1 - bitCount2 ) NEW_LINE maxBitCount = max ( bitCount1 , bitCount2 ) NEW_LINE if ( bitCount1 > bitCount2 ) : NEW_LINE INDENT n2 *= pow ( 2 , bitDiff ) NEW_LINE DEDENT else : NEW_LINE INDENT n1 *= pow ( 2 , bitDiff ) NEW_LINE DEDENT xorValue = n1 ^ n2 NEW_LINE bitCountXorValue = floor ( log2 ( xorValue ) ) + 1 NEW_LINE disSimilarBitPosition = ( maxBitCount - bitCountXorValue + 1 ) NEW_LINE return disSimilarBitPosition NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n1 , n2 = 53 , 55 NEW_LINE print ( bitPos ( n1 , n2 ) ) NEW_LINE DEDENT
def countOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT evenPairCount = count * ( count - 1 ) / 2 NEW_LINE totPairs = N * ( N - 1 ) / 2 NEW_LINE return ( int ) ( totPairs - evenPairCount ) NEW_LINE DEDENT A = [ 5 , 6 , 2 , 8 ] NEW_LINE N = len ( A ) NEW_LINE print ( countOddPair ( A , N ) ) NEW_LINE
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def OR ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans |= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 4 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( OR ( a , n ) ) NEW_LINE DEDENT
def bit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n = n & ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def maxSumOfBits ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = bit ( arr [ i ] ) NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if incl > excl : NEW_LINE INDENT excl_new = incl NEW_LINE DEDENT else : NEW_LINE INDENT excl_new = excl NEW_LINE DEDENT incl = excl + arr [ i ] ; NEW_LINE excl = excl_new NEW_LINE DEDENT if incl > excl : NEW_LINE INDENT return incl NEW_LINE DEDENT else : NEW_LINE INDENT return excl NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSumOfBits ( arr , n ) ) NEW_LINE DEDENT
def increment ( i ) : NEW_LINE INDENT i = - ( ~ ord ( i ) ) ; NEW_LINE return chr ( i ) ; NEW_LINE DEDENT n = ' a ' ; NEW_LINE print ( increment ( n ) ) ; NEW_LINE
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( N - count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findOddPair ( a , n ) ) NEW_LINE DEDENT
def MSBPosition ( N ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( N ) : NEW_LINE INDENT N = N >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def findBitwiseOR ( L , R ) : NEW_LINE INDENT res = 0 NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE while ( msb_p1 == msb_p2 ) : NEW_LINE INDENT res_val = ( 1 << msb_p1 ) NEW_LINE res += res_val NEW_LINE L -= res_val NEW_LINE R -= res_val NEW_LINE msb_p1 = MSBPosition ( L ) NEW_LINE msb_p2 = MSBPosition ( R ) NEW_LINE DEDENT msb_p1 = max ( msb_p1 , msb_p2 ) NEW_LINE for i in range ( msb_p1 , - 1 , - 1 ) : NEW_LINE INDENT res_val = ( 1 << i ) NEW_LINE res += res_val NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L , R = 12 , 18 NEW_LINE print ( findBitwiseOR ( L , R ) ) NEW_LINE DEDENT
def maxOR ( arr , n , k , x ) : NEW_LINE INDENT preSum = [ 0 ] * ( n + 1 ) NEW_LINE suffSum = [ 0 ] * ( n + 1 ) NEW_LINE pow = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT pow *= x NEW_LINE DEDENT preSum [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT preSum [ i + 1 ] = preSum [ i ] | arr [ i ] NEW_LINE DEDENT suffSum [ n ] = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res = max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE x = 3 NEW_LINE print ( maxOR ( arr , n , k , x ) ) NEW_LINE
def turnOnK ( n , k ) : NEW_LINE INDENT if ( k <= 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return ( n | ( 1 << ( k - 1 ) ) ) NEW_LINE DEDENT n = 4 NEW_LINE k = 2 NEW_LINE print ( turnOnK ( n , k ) ) NEW_LINE
def minSum ( a , n ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE num1 , num2 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT num1 = num1 * 10 + a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT num2 = num2 * 10 + a [ i ] NEW_LINE DEDENT DEDENT return num2 + num1 NEW_LINE DEDENT arr = [ 5 , 3 , 0 , 7 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ required ▁ sum ▁ is " , minSum ( arr , n ) ) NEW_LINE
def printKthBit ( n , k ) : NEW_LINE INDENT print ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) NEW_LINE DEDENT n = 13 NEW_LINE k = 2 NEW_LINE printKthBit ( n , k ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countOfOddPascal ( n ) : NEW_LINE INDENT c = countSetBits ( n ) NEW_LINE return pow ( 2 , c ) NEW_LINE DEDENT n = 20 NEW_LINE print ( countOfOddPascal ( n ) ) NEW_LINE
N = 100 NEW_LINE def ansQueries ( prefeven , prefodd , l , r ) : NEW_LINE INDENT if ( ( r - l + 1 ) % 2 == 0 ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( l % 2 == 0 ) : NEW_LINE INDENT print ( prefeven [ r ] ^ prefeven [ l - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( prefodd [ r ] ^ prefodd [ l - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def wrapper ( arr , n , l , r , q ) : NEW_LINE INDENT prefodd = [ 0 ] * N NEW_LINE prefeven = [ 0 ] * N NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i ) % 2 == 0 ) : NEW_LINE INDENT prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT prefeven [ i ] = prefeven [ i - 1 ] NEW_LINE prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i != q ) : NEW_LINE INDENT ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE l = [ 1 , 1 , 2 ] NEW_LINE r = [ 2 , 3 , 4 ] NEW_LINE q = len ( l ) NEW_LINE wrapper ( arr , n , l , r , q ) NEW_LINE DEDENT
def solve ( p , n ) : NEW_LINE INDENT G = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( p [ i ] % 2 != 0 ) : NEW_LINE INDENT G ^= ( p [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT G ^= ( p [ i ] - 1 ) NEW_LINE DEDENT DEDENT return G NEW_LINE DEDENT n = 3 NEW_LINE p = [ 32 , 49 , 58 ] NEW_LINE res = solve ( p , n ) NEW_LINE INDENT print ( " Player ▁ 2 ▁ wins " ) NEW_LINE print ( " Player ▁ 1 ▁ wins " ) NEW_LINE DEDENT
def checkBit ( pattern , arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( pattern & arr [ i ] ) == pattern ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for bit in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT count = checkBit ( res | ( 1 << bit ) , arr , n ) NEW_LINE if ( count >= 2 ) : NEW_LINE INDENT res = res | ( 1 << bit ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ AND ▁ Value ▁ = ▁ " , maxAND ( arr , n ) ) NEW_LINE
from math import log , trunc NEW_LINE def checkPowerof8 ( n ) : NEW_LINE INDENT i = log ( n , 8 ) NEW_LINE return ( i - trunc ( i ) < 0.000001 ) ; NEW_LINE DEDENT n = 65 NEW_LINE if checkPowerof8 ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
ULL_SIZE = 64 NEW_LINE def bit_anagram_check ( a ) : NEW_LINE INDENT return ( bin ( a ) . count ( "1" ) == ( ULL_SIZE >> 1 ) ) NEW_LINE DEDENT a = 4294967295 NEW_LINE print ( int ( bit_anagram_check ( a ) ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while ( ( 1 << i ) < n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT num = ( 1 << i ) + ( 1 << j ) NEW_LINE if ( num <= n ) : NEW_LINE INDENT sum += num NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( findSum ( n ) ) NEW_LINE
from math import floor , log10 NEW_LINE def posOfRightMostDiffBit ( m , n ) : NEW_LINE INDENT return floor ( log10 ( pow ( m ^ n , 2 ) ) ) + 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m , n = 52 , 4 NEW_LINE print ( " Position ▁ = ▁ " , posOfRightMostDiffBit ( m , n ) ) NEW_LINE DEDENT
def setKthBit ( n , k ) : NEW_LINE INDENT return ( ( 1 << k ) n ) NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE print ( " Kth ▁ bit ▁ set ▁ number ▁ = ▁ " , setKthBit ( n , k ) ) NEW_LINE
def reverseArray ( arr , n ) : NEW_LINE INDENT import sys NEW_LINE x = - sys . maxsize // sys . maxsize NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ n + ( x * i ) + x ] = arr [ n + ( x * i ) + x ] , arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def reverseArray ( arr , n ) : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT arr [ i ] , arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] = arr [ ( n + ~ i + 1 ) + ~ 1 + 1 ] , arr [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE reverseArray ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def maxXORInRange ( L , R ) : NEW_LINE INDENT LXR = L ^ R NEW_LINE msbPos = 0 NEW_LINE while ( LXR ) : NEW_LINE INDENT msbPos += 1 NEW_LINE LXR >>= 1 NEW_LINE DEDENT maxXOR , two = 0 , 1 NEW_LINE while ( msbPos ) : NEW_LINE INDENT maxXOR += two NEW_LINE two <<= 1 NEW_LINE msbPos -= 1 NEW_LINE DEDENT return maxXOR NEW_LINE DEDENT L , R = 8 , 20 NEW_LINE print ( maxXORInRange ( L , R ) ) NEW_LINE
def CountZeroBit ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( not ( n & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountORandSumEqual ( N ) : NEW_LINE INDENT count = CountZeroBit ( N ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT N = 10 NEW_LINE print ( CountORandSumEqual ( N ) ) NEW_LINE
def countNumbers ( n ) : NEW_LINE INDENT k = 0 NEW_LINE count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT count += pow ( 2 , k ) NEW_LINE DEDENT k += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 11 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE
def isMultipleOf4 ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT XOR = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT XOR = XOR ^ i NEW_LINE DEDENT return ( XOR == n ) NEW_LINE DEDENT for n in range ( 0 , 43 ) : NEW_LINE INDENT if ( isMultipleOf4 ( n ) ) : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def countSetBits ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def ceilLog2 ( x ) : NEW_LINE INDENT count = 0 NEW_LINE x = x - 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT x = x >> 1 NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def isBleak ( n ) : NEW_LINE INDENT for x in range ( ( n - ceilLog2 ( n ) ) , n ) : NEW_LINE INDENT if ( x + countSetBits ( x ) == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if ( isBleak ( 3 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT if ( isBleak ( 4 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countStrings ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE a [ 0 ] = b [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] + b [ i - 1 ] NEW_LINE b [ i ] = a [ i - 1 ] NEW_LINE DEDENT return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] NEW_LINE DEDENT print ( countStrings ( 5 ) ) NEW_LINE
def printDistance ( mat ) : NEW_LINE INDENT global N , M NEW_LINE ans = [ [ None ] * M for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT ans [ i ] [ j ] = 999999999999 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT for k in range ( N ) : NEW_LINE INDENT for l in range ( M ) : NEW_LINE INDENT if ( mat [ k ] [ l ] == 1 ) : NEW_LINE INDENT ans [ i ] [ j ] = min ( ans [ i ] [ j ] , abs ( i - k ) + abs ( j - l ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT print ( ans [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 3 NEW_LINE M = 4 NEW_LINE mat = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 1 , 1 ] , [ 0 , 1 , 1 , 0 ] ] NEW_LINE printDistance ( mat ) NEW_LINE
def isMinHeap ( level , n ) : NEW_LINE INDENT for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if level [ i ] > level [ 2 * i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT if 2 * i + 2 < n : NEW_LINE INDENT if level [ i ] > level [ 2 * i + 2 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT level = [ 10 , 15 , 14 , 25 , 30 ] NEW_LINE n = len ( level ) NEW_LINE if isMinHeap ( level , n ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT DEDENT
def mostFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE max_count = 1 ; res = arr [ 0 ] ; curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count > max_count ) : NEW_LINE INDENT max_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 5 , 2 , 1 , 3 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( mostFrequent ( arr , n ) ) NEW_LINE
def areDisjoint ( set1 , set2 , m , n ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( set1 [ i ] == set2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT set1 = [ 12 , 34 , 11 , 9 , 3 ] NEW_LINE set2 = [ 7 , 2 , 1 , 5 ] NEW_LINE m = len ( set1 ) NEW_LINE n = len ( set2 ) NEW_LINE print ( " yes " ) if areDisjoint ( set1 , set2 , m , n ) else ( " ▁ No " ) NEW_LINE
def findMissing ( a , b , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( a [ i ] == b [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == m - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 6 , 3 , 4 , 5 ] NEW_LINE b = [ 2 , 4 , 3 , 1 , 0 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE findMissing ( a , b , n , m ) NEW_LINE DEDENT
def areEqual ( arr1 , arr2 , n , m ) : NEW_LINE INDENT if ( n != m ) : NEW_LINE INDENT return False NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr1 = [ 3 , 5 , 2 , 5 , 2 ] NEW_LINE arr2 = [ 2 , 3 , 5 , 5 , 2 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE if ( areEqual ( arr1 , arr2 , n , m ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isProduct ( arr , n , x ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT for j in arr : NEW_LINE INDENT if i * j == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 9 , 40 ] NEW_LINE x = 400 NEW_LINE n = len ( arr ) NEW_LINE if ( isProduct ( arr , n , x ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT x = 900 NEW_LINE if ( isProduct ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findGreatest ( arr , n ) : NEW_LINE INDENT result = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] * arr [ k ] == arr [ i ] ) : NEW_LINE INDENT result = max ( result , arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 30 , 10 , 9 , 3 , 35 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findGreatest ( arr , n ) ) NEW_LINE DEDENT
def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] + arr [ j ] == sum : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( " Count ▁ of ▁ pairs ▁ is " , getPairsCount ( arr , n , sum ) ) NEW_LINE
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if arr1 [ i ] + arr2 [ j ] == x : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr1 = [ 1 , 3 , 5 , 7 ] NEW_LINE arr2 = [ 2 , 3 , 5 , 8 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE x = 10 NEW_LINE print ( " Count ▁ = ▁ " , countPairs ( arr1 , arr2 , m , n , x ) ) NEW_LINE
def isPresent ( arr , low , high , value ) : NEW_LINE INDENT while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( arr [ mid ] == value ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( arr [ mid ] > value ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT value = x - arr1 [ i ] NEW_LINE if ( isPresent ( arr2 , 0 , n - 1 , value ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ 1 , 3 , 5 , 7 ] NEW_LINE arr2 = [ 2 , 3 , 5 , 8 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE x = 10 NEW_LINE print ( " Count ▁ = ▁ " , countPairs ( arr1 , arr2 , m , n , x ) ) NEW_LINE DEDENT
def countPairs ( arr1 , arr2 , m , n , x ) : NEW_LINE INDENT count , l , r = 0 , 0 , n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if ( ( arr1 [ l ] + arr2 [ r ] ) == x ) : NEW_LINE INDENT l += 1 NEW_LINE r -= 1 NEW_LINE count += 1 NEW_LINE DEDENT elif ( ( arr1 [ l ] + arr2 [ r ] ) < x ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 1 , 3 , 5 , 7 ] NEW_LINE arr2 = [ 2 , 3 , 5 , 8 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE x = 10 NEW_LINE print ( " Count ▁ = " , countPairs ( arr1 , arr2 , m , n , x ) ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT product = arr [ i ] * arr [ j ] ; NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ k ] == product ) : NEW_LINE INDENT result = result + 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT arr = [ 6 , 2 , 4 , 12 , 5 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPairs ( arr , n ) ) ; NEW_LINE
def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT n = 9 NEW_LINE print ( fib ( n ) ) NEW_LINE
def fact ( n , a = 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return fact ( n - 1 , n * a ) NEW_LINE DEDENT print ( fact ( 5 ) ) NEW_LINE
def findPairs ( arr1 , arr2 , n , m , x ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , m ) : NEW_LINE INDENT if ( arr1 [ i ] + arr2 [ j ] == x ) : NEW_LINE INDENT print ( arr1 [ i ] , arr2 [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr1 = [ 1 , 2 , 3 , 7 , 5 , 4 ] NEW_LINE arr2 = [ 0 , 7 , 4 , 3 , 2 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE x = 8 NEW_LINE findPairs ( arr1 , arr2 , n , m , x ) NEW_LINE
def findPair ( arr , n ) : NEW_LINE INDENT found = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == arr [ k ] ) : NEW_LINE INDENT print ( arr [ i ] , arr [ j ] ) NEW_LINE found = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " Not ▁ exist " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 4 , 8 , 13 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findPair ( arr , n ) NEW_LINE DEDENT
def printPairs ( arr , n , k ) : NEW_LINE INDENT isPairFound = True NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and arr [ i ] % arr [ j ] == k ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , sep = " " , end = " ▁ " ) NEW_LINE isPairFound = True NEW_LINE DEDENT DEDENT DEDENT return isPairFound NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE if ( printPairs ( arr , n , k ) == False ) : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ exists " ) NEW_LINE DEDENT
ASCII_SIZE = 256 NEW_LINE def getMaxOccuringChar ( str ) : NEW_LINE INDENT count = [ 0 ] * ASCII_SIZE NEW_LINE for i in str : NEW_LINE INDENT count [ ord ( i ) ] += 1 ; NEW_LINE DEDENT max = - 1 NEW_LINE c = ' ' NEW_LINE for i in str : NEW_LINE INDENT if max < count [ ord ( i ) ] : NEW_LINE INDENT max = count [ ord ( i ) ] NEW_LINE c = i NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT str = " sample ▁ string " NEW_LINE print " Max ▁ occurring ▁ character ▁ is ▁ " + getMaxOccuringChar ( str ) NEW_LINE
def firstNonRepeating ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( i != j and arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 9 , 4 , 9 , 6 , 7 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( firstNonRepeating ( arr , n ) ) NEW_LINE
def subarrayDivisibleByK ( arr , n , k ) : NEW_LINE INDENT mp = [ 0 ] * 1000 NEW_LINE s = 0 ; e = 0 ; maxs = 0 ; maxe = 0 ; NEW_LINE mp [ arr [ 0 ] % k ] = mp [ arr [ 0 ] % k ] + 1 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT mod = arr [ i ] % k NEW_LINE while ( mp [ k - mod ] != 0 or ( mod == 0 and mp [ mod ] != 0 ) ) : NEW_LINE INDENT mp [ arr [ s ] % k ] = mp [ arr [ s ] % k ] - 1 NEW_LINE s = s + 1 NEW_LINE DEDENT mp [ mod ] = mp [ mod ] + 1 NEW_LINE e = e + 1 NEW_LINE if ( ( e - s ) > ( maxe - maxs ) ) : NEW_LINE INDENT maxe = e NEW_LINE maxs = s NEW_LINE DEDENT DEDENT print ( " The ▁ maximum ▁ size ▁ is ▁ { } ▁ and ▁ the ▁ " . format ( ( maxe - maxs + 1 ) ) ) for i in range ( maxs , maxe + 1 ) : NEW_LINE INDENT print ( " { } ▁ " . format ( arr [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT k = 3 NEW_LINE arr = [ 5 , 10 , 15 , 20 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE subarrayDivisibleByK ( arr , n , k ) NEW_LINE
def findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) : NEW_LINE INDENT for i in range ( 0 , n1 ) : NEW_LINE INDENT for j in range ( 0 , n2 ) : NEW_LINE INDENT for k in range ( 0 , n3 ) : NEW_LINE INDENT if ( a1 [ i ] + a2 [ j ] + a3 [ k ] == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT a1 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE a2 = [ 2 , 3 , 6 , 1 , 2 ] NEW_LINE a3 = [ 3 , 2 , 4 , 5 , 6 ] NEW_LINE sum = 9 NEW_LINE n1 = len ( a1 ) NEW_LINE n2 = len ( a2 ) NEW_LINE n3 = len ( a3 ) NEW_LINE print ( " Yes " ) if findTriplet ( a1 , a2 , a3 , n1 , n2 , n3 , sum ) else print ( " No " ) NEW_LINE
import math as mt NEW_LINE def minInsertion ( tr1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE count = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] % 2 == 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT if ( res == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return res - 1 NEW_LINE DEDENT DEDENT str1 = " geeksforgeeks " NEW_LINE print ( minInsertion ( str1 ) ) NEW_LINE
def findDiff ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 ; max_count = 0 ; min_count = n NEW_LINE for i in range ( 0 , ( n - 1 ) ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT max_count = max ( max_count , count ) NEW_LINE min_count = min ( min_count , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max_count - min_count NEW_LINE DEDENT arr = [ 7 , 8 , 4 , 5 , 4 , 1 , 1 , 7 , 7 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findDiff ( arr , n ) ) NEW_LINE
import math NEW_LINE def maxDiff ( arr , n ) : NEW_LINE INDENT SubsetSum_1 = 0 NEW_LINE SubsetSum_2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT isSingleOccurance = True NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT isSingleOccurance = False NEW_LINE arr [ i ] = arr [ j ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( isSingleOccurance == True ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT SubsetSum_1 += arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT SubsetSum_2 += arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return abs ( SubsetSum_1 - SubsetSum_2 ) NEW_LINE DEDENT arr = [ 4 , 2 , - 3 , 3 , - 2 , - 2 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ Difference ▁ = ▁ { } " . format ( maxDiff ( arr , n ) ) ) NEW_LINE
def maxDiff ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) != abs ( arr [ i + 1 ] ) ) : NEW_LINE INDENT result += abs ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT pass NEW_LINE DEDENT DEDENT if ( arr [ n - 2 ] != arr [ n - 1 ] ) : NEW_LINE INDENT result += abs ( arr [ n - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 2 , - 3 , 3 , - 2 , - 2 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ Difference ▁ = ▁ " , maxDiff ( arr , n ) ) NEW_LINE DEDENT
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE if ( ( arr [ i ] - diff ) in arr ) : NEW_LINE INDENT print ( " { } ▁ { } ▁ { } " . format ( ( arr [ i ] - diff ) , arr [ i ] , arr [ j ] ) , end =   " " ) ; NEW_LINE DEDENT DEDENT DEDENT s . append ( arr [ i ] ) ; NEW_LINE DEDENT arr = [ 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printAllAPTriplets ( arr , n ) ; NEW_LINE
def printAllAPTriplets ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT j = i - 1 NEW_LINE k = i + 1 NEW_LINE while ( j >= 0 and k < n ) : NEW_LINE INDENT if ( arr [ j ] + arr [ k ] == 2 * arr [ i ] ) : NEW_LINE INDENT print ( arr [ j ] , " " , arr [ i ] , " " , arr [ k ] ) NEW_LINE k += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( arr [ j ] + arr [ k ] < 2 * arr [ i ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 2 , 6 , 9 , 12 , 17 , 22 , 31 , 32 , 35 , 42 ] NEW_LINE n = len ( arr ) NEW_LINE printAllAPTriplets ( arr , n ) NEW_LINE
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] * arr [ j ] * arr [ k ] == m ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 6 , 2 , 3 , 8 ] NEW_LINE m = 24 NEW_LINE print ( countTriplets ( arr , len ( arr ) , m ) ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
def preCalculate ( binary , n , left ) : NEW_LINE INDENT count1 , count0 = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT left [ i ] [ 0 ] = count1 NEW_LINE left [ i ] [ 1 ] = count0 NEW_LINE if ( binary [ i ] ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT DEDENT DEDENT binary = [ 1 , 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( binary ) NEW_LINE left = [ [ 0 for i in range ( 2 ) ] for i in range ( n ) ] NEW_LINE preCalculate ( binary , n , left ) NEW_LINE queries = [ 0 , 1 , 2 , 4 ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( left [ queries [ i ] ] [ 0 ] , " ones " , left [ queries [ i ] ] [ 1 ] , " zeros " ) NEW_LINE DEDENT
def equiSumUtil ( arr , pos1 , pos2 ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE pre = [ 0 ] * n ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE pre [ i ] = sum ; NEW_LINE DEDENT suf = [ 0 ] * n ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE suf [ i ] = sum ; NEW_LINE DEDENT total_sum = sum ; NEW_LINE i = 0 ; NEW_LINE j = n - 1 ; NEW_LINE while ( i < j - 1 ) : NEW_LINE INDENT if ( pre [ i ] == total_sum // 3 ) : NEW_LINE INDENT pos1 = i ; NEW_LINE DEDENT if ( suf [ j ] == total_sum // 3 ) : NEW_LINE INDENT pos2 = j ; NEW_LINE DEDENT if ( pos1 != - 1 and pos2 != - 1 ) : NEW_LINE INDENT if ( suf [ pos1 + 1 ] - suf [ pos2 ] == total_sum // 3 ) : NEW_LINE INDENT return [ True , pos1 , pos2 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT return [ False , pos1 , pos2 ] ; NEW_LINE DEDENT DEDENT if ( pre [ i ] < suf [ j ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 ; NEW_LINE DEDENT DEDENT return [ False , pos1 , pos2 ] ; NEW_LINE DEDENT def equiSum ( arr ) : NEW_LINE INDENT pos1 = - 1 ; NEW_LINE pos2 = - 1 ; NEW_LINE ans = equiSumUtil ( arr , pos1 , pos2 ) ; NEW_LINE pos1 = ans [ 1 ] ; NEW_LINE pos2 = ans [ 2 ] ; NEW_LINE if ( ans [ 0 ] ) : NEW_LINE INDENT print ( " First ▁ Segment ▁ : ▁ " , end = " " ) ; NEW_LINE for i in range ( pos1 + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE print ( " Second ▁ Segment ▁ : ▁ " , end = " " ) ; NEW_LINE for i in range ( pos1 + 1 , pos2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE print ( " Third ▁ Segment ▁ : ▁ " , end = " " ) ; NEW_LINE for i in range ( pos2 , len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT println ( " Array ▁ cannot ▁ be ▁ divided ▁ into " , " three ▁ equal ▁ sum ▁ segments " ) ; NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 6 , 2 , 7 , 1 , 2 , 8 ] ; NEW_LINE equiSum ( arr ) ; NEW_LINE
def getRightMin ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE rightMin = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == min ) : NEW_LINE INDENT rightMin = i NEW_LINE DEDENT i *= 2 NEW_LINE DEDENT i = rightMin + 1 NEW_LINE while ( i < n and arr [ i ] == min ) : NEW_LINE INDENT rightMin = i NEW_LINE i += 1 NEW_LINE DEDENT return rightMin NEW_LINE DEDENT def getLeftMax ( arr , n ) : NEW_LINE INDENT max = arr [ n - 1 ] NEW_LINE leftMax = n - 1 NEW_LINE i = n - 2 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( arr [ i ] == max ) : NEW_LINE INDENT leftMax = i NEW_LINE DEDENT i = int ( i / 2 ) NEW_LINE DEDENT i = leftMax - 1 NEW_LINE while ( i >= 0 and arr [ i ] == max ) : NEW_LINE INDENT leftMax = i NEW_LINE i -= 1 NEW_LINE DEDENT return leftMax NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 0 , 1 , 2 , 5 , 5 , 6 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ left ▁ : " , 0 ) NEW_LINE print ( " Minimum ▁ right ▁ : " , getRightMin ( arr , n ) ) NEW_LINE print ( " Maximum ▁ left ▁ : " , getLeftMax ( arr , n ) ) NEW_LINE print ( " Maximum ▁ right ▁ : " , ( n - 1 ) ) NEW_LINE DEDENT
def countNum ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i + 1 ] - 1 ) : NEW_LINE INDENT count += arr [ i + 1 ] - arr [ i ] - 1 ; NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 3 , 5 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE
def countSubarrays ( arr , n ) : NEW_LINE INDENT difference = 0 NEW_LINE ans = 0 NEW_LINE hash_positive = [ 0 ] * ( n + 1 ) NEW_LINE hash_negative = [ 0 ] * ( n + 1 ) NEW_LINE hash_positive [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & 1 == 1 ) : NEW_LINE INDENT difference = difference + 1 NEW_LINE DEDENT else : NEW_LINE INDENT difference = difference - 1 NEW_LINE DEDENT if ( difference < 0 ) : NEW_LINE INDENT ans += hash_negative [ - difference ] NEW_LINE hash_negative [ - difference ] = hash_negative [ - difference ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += hash_positive [ difference ] NEW_LINE hash_positive [ difference ] = hash_positive [ difference ] + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 4 , 6 , 8 , 1 , 10 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Total ▁ Number ▁ of ▁ Even - Odd ▁ subarrays ▁ are ▁ " + str ( countSubarrays ( arr , n ) ) ) NEW_LINE
def printGreaterCount ( str ) : NEW_LINE INDENT len__ = len ( str ) NEW_LINE right = [ 0 for i in range ( len__ ) ] NEW_LINE for i in range ( len__ ) : NEW_LINE INDENT for j in range ( i + 1 , len__ , 1 ) : NEW_LINE INDENT if ( str [ i ] < str [ j ] ) : NEW_LINE INDENT right [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( len__ ) : NEW_LINE INDENT print ( right [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " abcd " NEW_LINE printGreaterCount ( str ) NEW_LINE DEDENT
import sys NEW_LINE def appearsNBy3 ( arr , n ) : NEW_LINE INDENT count1 = 0 NEW_LINE count2 = 0 NEW_LINE first = sys . maxsize NEW_LINE second = sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( first == arr [ i ] ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( second == arr [ i ] ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT elif ( count1 == 0 ) : NEW_LINE INDENT count1 += 1 NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( count2 == 0 ) : NEW_LINE INDENT count2 += 1 NEW_LINE second = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT count1 -= 1 NEW_LINE count2 -= 1 NEW_LINE DEDENT DEDENT count1 = 0 NEW_LINE count2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == first ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( arr [ i ] == second ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT DEDENT if ( count1 > n / 3 ) : NEW_LINE INDENT return first NEW_LINE DEDENT if ( count2 > n / 3 ) : NEW_LINE INDENT return second NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( appearsNBy3 ( arr , n ) ) NEW_LINE
' NEW_LINE ' NEW_LINE def count4Divisibiles ( arr , n ) : NEW_LINE INDENT freq = [ 0 , 0 , 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] % 4 ] += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT ans = freq [ 0 ] * ( freq [ 0 ] - 1 ) / 2 NEW_LINE ans += freq [ 2 ] * ( freq [ 2 ] - 1 ) / 2 NEW_LINE ans += freq [ 1 ] * freq [ 3 ] NEW_LINE return int ( ans ) NEW_LINE DEDENT arr = [ 2 , 2 , 1 , 7 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( count4Divisibiles ( arr , n ) ) NEW_LINE
' NEW_LINE def countMaxSetBits ( left , right ) : NEW_LINE INDENT max_count = - 1 NEW_LINE for i in range ( left , right + 1 ) : NEW_LINE INDENT temp = i NEW_LINE cnt = 0 NEW_LINE while temp : NEW_LINE INDENT if temp & 1 : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT temp = temp >> 1 NEW_LINE DEDENT if cnt > max_count : NEW_LINE INDENT max_count = cnt NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE
def recaman ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE arr [ 0 ] = 0 NEW_LINE print ( arr [ 0 ] , end = " , ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = arr [ i - 1 ] - i NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ j ] == curr ) or curr < 0 ) : NEW_LINE INDENT curr = arr [ i - 1 ] + i NEW_LINE break NEW_LINE DEDENT DEDENT arr [ i ] = curr NEW_LINE print ( arr [ i ] , end = " , ▁ " ) NEW_LINE DEDENT DEDENT n = 17 NEW_LINE recaman ( n ) NEW_LINE
def recaman ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( 0 , " , " , end = ' ' ) NEW_LINE s = set ( [ ] ) NEW_LINE s . add ( 0 ) NEW_LINE prev = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr = prev - i NEW_LINE if ( curr < 0 or curr in s ) : NEW_LINE INDENT curr = prev + i NEW_LINE DEDENT s . add ( curr ) NEW_LINE print ( curr , " , " , end = ' ' ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 17 NEW_LINE recaman ( n ) NEW_LINE DEDENT
def findArea ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE dimension = [ 0 , 0 ] NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n - 1 and j < 2 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT dimension [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( dimension [ 0 ] * dimension [ 1 ] ) NEW_LINE DEDENT arr = [ 4 , 2 , 1 , 4 , 6 , 6 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findArea ( arr , n ) ) NEW_LINE
def pairInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE while ( l != r ) : NEW_LINE INDENT if ( arr [ l ] + arr [ r ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( arr [ l ] + arr [ r ] < x ) : NEW_LINE INDENT l = ( l + 1 ) % n ; NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT arr = [ 11 , 15 , 6 , 8 , 9 , 10 ] NEW_LINE sum = 16 NEW_LINE n = len ( arr ) NEW_LINE if ( pairInSortedRotated ( arr , n , sum ) ) : NEW_LINE INDENT print ( " Array ▁ has ▁ two ▁ elements ▁ with ▁ sum ▁ 16" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Array ▁ doesn ' t ▁ have ▁ two ▁ elements ▁ with ▁ sum ▁ 16 ▁ " ) NEW_LINE DEDENT
def pairsInSortedRotated ( arr , n , x ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > arr [ i + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT l = ( i + 1 ) % n NEW_LINE r = i NEW_LINE cnt = 0 NEW_LINE while ( l != r ) : NEW_LINE INDENT if arr [ l ] + arr [ r ] == x : NEW_LINE INDENT cnt += 1 NEW_LINE if l == ( r - 1 + n ) % n : NEW_LINE INDENT return cnt NEW_LINE DEDENT l = ( l + 1 ) % n NEW_LINE r = ( r - 1 + n ) % n NEW_LINE DEDENT elif arr [ l ] + arr [ r ] < x : NEW_LINE INDENT l = ( l + 1 ) % n NEW_LINE DEDENT else : NEW_LINE INDENT r = ( n + r - 1 ) % n NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 11 , 15 , 6 , 7 , 9 , 10 ] NEW_LINE s = 16 NEW_LINE print ( pairsInSortedRotated ( arr , 6 , s ) ) NEW_LINE
def maxSum ( arr ) : NEW_LINE INDENT arrSum = 0 NEW_LINE currVal = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arrSum = arrSum + arr [ i ] NEW_LINE currVal = currVal + ( i * arr [ i ] ) NEW_LINE DEDENT maxVal = currVal NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT currVal = currVal + arrSum - n * arr [ n - j ] NEW_LINE if currVal > maxVal : NEW_LINE INDENT maxVal = currVal NEW_LINE DEDENT DEDENT return maxVal NEW_LINE DEDENT arr = [ 10 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE print " Max ▁ sum ▁ is : ▁ " , maxSum ( arr ) NEW_LINE
import sys NEW_LINE def maxSum ( arr , n ) : NEW_LINE INDENT res = - sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT index = int ( ( i + j ) % n ) NEW_LINE curr_sum += j * arr [ index ] NEW_LINE DEDENT res = max ( res , curr_sum ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 8 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
def maxSum ( arr , n ) : NEW_LINE INDENT cum_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cum_sum += arr [ i ] NEW_LINE DEDENT curr_val = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT curr_val += i * arr [ i ] NEW_LINE DEDENT res = curr_val NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT next_val = ( curr_val - ( cum_sum - arr [ i - 1 ] ) + arr [ i - 1 ] * ( n - 1 ) ) NEW_LINE curr_val = next_val NEW_LINE res = max ( res , next_val ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 8 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
def countRotations ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE min_index = i NEW_LINE DEDENT DEDENT return min_index ; NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , n ) ) NEW_LINE
def countRotations ( arr , low , high ) : NEW_LINE INDENT if ( high < low ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( high == low ) : NEW_LINE INDENT return low NEW_LINE DEDENT mid = low + ( high - low ) / 2 ; NEW_LINE mid = int ( mid ) NEW_LINE if ( mid < high and arr [ mid + 1 ] < arr [ mid ] ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( mid > low and arr [ mid ] < arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ high ] > arr [ mid ] ) : NEW_LINE INDENT return countRotations ( arr , low , mid - 1 ) ; NEW_LINE DEDENT return countRotations ( arr , mid + 1 , high ) NEW_LINE DEDENT arr = [ 15 , 18 , 2 , 3 , 6 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countRotations ( arr , 0 , n - 1 ) ) NEW_LINE
def preprocess ( arr , n ) : NEW_LINE INDENT temp = [ None ] * ( 2 * n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ i ] = temp [ i + n ] = arr [ i ] NEW_LINE DEDENT return temp NEW_LINE DEDENT def leftRotate ( arr , n , k , temp ) : NEW_LINE INDENT start = k % n NEW_LINE for i in range ( start , start + n ) : NEW_LINE INDENT print ( temp [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE temp = preprocess ( arr , n ) NEW_LINE k = 2 NEW_LINE leftRotate ( arr , n , k , temp ) NEW_LINE k = 3 NEW_LINE leftRotate ( arr , n , k , temp ) NEW_LINE k = 4 NEW_LINE leftRotate ( arr , n , k , temp ) NEW_LINE
def leftRotate ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , k + n ) : NEW_LINE INDENT print ( str ( arr [ i % n ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 ; NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 3 ; NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE k = 4 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE print ( ) NEW_LINE
def reverseArray ( arr , start , end ) : NEW_LINE INDENT while ( start < end ) : NEW_LINE INDENT arr [ start ] , arr [ end ] = arr [ end ] , arr [ start ] NEW_LINE start = start + 1 NEW_LINE end = end - 1 NEW_LINE DEDENT DEDENT def rightRotate ( arr , d , n ) : NEW_LINE INDENT reverseArray ( arr , 0 , n - 1 ) ; NEW_LINE reverseArray ( arr , 0 , d - 1 ) ; NEW_LINE reverseArray ( arr , d , n - 1 ) ; NEW_LINE DEDENT def prArray ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE rightRotate ( arr , k , n ) NEW_LINE prArray ( arr , n ) NEW_LINE
def maxHamming ( arr , n ) : NEW_LINE INDENT brr = [ 0 ] * ( 2 * n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT brr [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT brr [ n + i ] = arr [ i ] NEW_LINE DEDENT maxHam = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT currHam = 0 NEW_LINE k = 0 NEW_LINE for j in range ( i , i + n ) : NEW_LINE INDENT if brr [ j ] != arr [ k ] : NEW_LINE INDENT currHam += 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT if currHam == n : NEW_LINE INDENT return n NEW_LINE DEDENT maxHam = max ( maxHam , currHam ) NEW_LINE DEDENT return maxHam NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxHamming ( arr , n ) ) NEW_LINE
def leftRotate ( arr , n , k ) : NEW_LINE INDENT mod = k % n NEW_LINE s = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT print str ( arr [ ( mod + i ) % n ] ) , NEW_LINE DEDENT print NEW_LINE return NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE k = 3 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE k = 4 NEW_LINE leftRotate ( arr , n , k ) NEW_LINE
def findElement ( arr , ranges , rotations , index ) : NEW_LINE INDENT for i in range ( rotations - 1 , - 1 , - 1 ) : NEW_LINE INDENT left = ranges [ i ] [ 0 ] NEW_LINE right = ranges [ i ] [ 1 ] NEW_LINE if ( left <= index and right >= index ) : NEW_LINE INDENT if ( index == left ) : NEW_LINE INDENT index = right NEW_LINE DEDENT else : NEW_LINE INDENT index = index - 1 NEW_LINE DEDENT DEDENT DEDENT return arr [ index ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE rotations = 2 NEW_LINE ranges = [ [ 0 , 2 ] , [ 0 , 3 ] ] NEW_LINE index = 1 NEW_LINE print ( findElement ( arr , ranges , rotations , index ) ) NEW_LINE
def splitArr ( arr , n , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT x = arr [ 0 ] NEW_LINE for j in range ( 0 , n - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE DEDENT arr [ n - 1 ] = x NEW_LINE DEDENT DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE position = 2 NEW_LINE splitArr ( arr , n , position ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT
import array as a NEW_LINE import numpy as np NEW_LINE def rearrangeArr ( arr , n ) : NEW_LINE INDENT evenPos = int ( n / 2 ) NEW_LINE oddPos = n - evenPos NEW_LINE tempArr = np . empty ( n , dtype = object ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tempArr [ i ] = arr [ i ] NEW_LINE DEDENT tempArr . sort ( ) NEW_LINE j = oddPos - 1 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT arr [ i ] = tempArr [ j ] NEW_LINE j = j - 1 NEW_LINE DEDENT j = oddPos NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT arr [ i ] = tempArr [ j ] NEW_LINE j = j + 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT arr = a . array ( ' i ' , [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] ) NEW_LINE rearrangeArr ( arr , 7 ) NEW_LINE
import numpy as np NEW_LINE class GFG : NEW_LINE INDENT def MaxSumDifference ( a , n ) : NEW_LINE INDENT np . sort ( a ) ; NEW_LINE j = 0 NEW_LINE finalSequence = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT finalSequence [ j ] = a [ i ] NEW_LINE finalSequence [ j + 1 ] = a [ n - i - 1 ] NEW_LINE j = j + 2 NEW_LINE DEDENT if ( n % 2 != 0 ) : NEW_LINE finalSequence [ n - 1 ] = a [ n // 2 + 1 ] NEW_LINE MaximumSum = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ i ] - finalSequence [ i + 1 ] ) ) NEW_LINE DEDENT MaximumSum = ( MaximumSum + abs ( finalSequence [ n - 1 ] - finalSequence [ 0 ] ) ) ; NEW_LINE print ( MaximumSum ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 4 , 8 ] NEW_LINE n = len ( a ) NEW_LINE GFG . MaxSumDifference ( a , n ) ; NEW_LINE
def minSwap ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] <= k ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT bad = 0 NEW_LINE for i in range ( 0 , count ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT bad = bad + 1 NEW_LINE DEDENT DEDENT ans = bad NEW_LINE j = count NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( j == n ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ i ] > k ) : NEW_LINE INDENT bad = bad - 1 NEW_LINE DEDENT if ( arr [ j ] > k ) : NEW_LINE INDENT bad = bad + 1 NEW_LINE DEDENT ans = min ( ans , bad ) NEW_LINE j = j + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 2 , 1 , 5 , 6 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minSwap ( arr , n , k ) ) NEW_LINE arr1 = [ 2 , 7 , 9 , 5 , 8 , 7 , 4 ] NEW_LINE n = len ( arr1 ) NEW_LINE k = 5 NEW_LINE print ( minSwap ( arr1 , n , k ) ) NEW_LINE
def maxProductSubarrayOfSizeK ( A , n , k ) : NEW_LINE INDENT A . sort ( ) NEW_LINE product = 1 NEW_LINE if ( A [ n - 1 ] == 0 and ( k & 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( A [ n - 1 ] <= 0 and ( k & 1 ) ) : NEW_LINE INDENT for i in range ( n - 1 , n - k + 1 , - 1 ) : NEW_LINE INDENT product *= A [ i ] NEW_LINE DEDENT return product NEW_LINE DEDENT i = 0 NEW_LINE j = n - 1 NEW_LINE if ( k & 1 ) : NEW_LINE INDENT product *= A [ j ] NEW_LINE j -= 1 NEW_LINE k -= 1 NEW_LINE DEDENT k >>= 1 NEW_LINE for itr in range ( k ) : NEW_LINE INDENT left_product = A [ i ] * A [ i + 1 ] NEW_LINE right_product = A [ j ] * A [ j - 1 ] NEW_LINE if ( left_product > right_product ) : NEW_LINE INDENT product *= left_product NEW_LINE i += 2 NEW_LINE DEDENT else : NEW_LINE INDENT product *= right_product NEW_LINE j -= 2 NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , - 1 , - 3 , - 6 , 4 ] NEW_LINE n = len ( A ) NEW_LINE k = 4 NEW_LINE print ( maxProductSubarrayOfSizeK ( A , n , k ) ) NEW_LINE DEDENT
def reorder ( arr , index , n ) : NEW_LINE INDENT temp = [ 0 ] * n ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT temp [ index [ i ] ] = arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE index [ i ] = i NEW_LINE DEDENT DEDENT arr = [ 50 , 40 , 70 , 60 , 90 ] NEW_LINE index = [ 3 , 0 , 4 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE reorder ( arr , index , n ) NEW_LINE print ( " Reordered ▁ array ▁ is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " Modified Index array is : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( index [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def gnomeSort ( arr , n ) : NEW_LINE INDENT index = 0 NEW_LINE while index < n : NEW_LINE INDENT if index == 0 : NEW_LINE INDENT index = index + 1 NEW_LINE DEDENT if arr [ index ] >= arr [ index - 1 ] : NEW_LINE INDENT index = index + 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ index ] , arr [ index - 1 ] = arr [ index - 1 ] , arr [ index ] NEW_LINE index = index - 1 NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT arr = [ 34 , 2 , 10 , - 9 ] NEW_LINE n = len ( arr ) NEW_LINE arr = gnomeSort ( arr , n ) NEW_LINE print " Sorted ▁ sequence ▁ after ▁ applying ▁ Gnome ▁ Sort ▁ : " , NEW_LINE for i in arr : NEW_LINE INDENT print i , NEW_LINE DEDENT
def findMaxGuests ( arrl , exit , n ) : NEW_LINE INDENT arrl . sort ( ) ; NEW_LINE exit . sort ( ) ; NEW_LINE guests_in = 1 ; NEW_LINE max_guests = 1 ; NEW_LINE time = arrl [ 0 ] ; NEW_LINE i = 1 ; NEW_LINE j = 0 ; NEW_LINE while ( i < n and j < n ) : NEW_LINE INDENT if ( arrl [ i ] <= exit [ j ] ) : NEW_LINE INDENT guests_in = guests_in + 1 ; NEW_LINE if ( guests_in > max_guests ) : NEW_LINE INDENT max_guests = guests_in ; NEW_LINE time = arrl [ i ] ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT guests_in = guests_in - 1 ; NEW_LINE j = j + 1 ; NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Number ▁ of ▁ Guests ▁ = " , max_guests , " at ▁ time " , time ) NEW_LINE DEDENT arrl = [ 1 , 2 , 10 , 5 , 5 ] ; NEW_LINE exit = [ 4 , 5 , 12 , 9 , 12 ] ; NEW_LINE n = len ( arrl ) ; NEW_LINE findMaxGuests ( arrl , exit , n ) ; NEW_LINE
def rearrange ( arr , n ) : NEW_LINE INDENT temp = n * [ None ] NEW_LINE small , large = 0 , n - 1 NEW_LINE flag = True NEW_LINE for i in range ( n ) : NEW_LINE INDENT if flag is True : NEW_LINE INDENT temp [ i ] = arr [ large ] NEW_LINE large -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ i ] = arr [ small ] NEW_LINE small += 1 NEW_LINE DEDENT flag = bool ( 1 - flag ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return arr NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Original ▁ Array " ) NEW_LINE print ( arr ) NEW_LINE print ( " Modified ▁ Array " ) NEW_LINE print ( rearrange ( arr , n ) ) NEW_LINE
def rearrange ( arr , n ) : NEW_LINE INDENT max_idx = n - 1 NEW_LINE min_idx = 0 NEW_LINE max_elem = arr [ n - 1 ] + 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT arr [ i ] += ( arr [ max_idx ] % max_elem ) * max_elem NEW_LINE max_idx -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += ( arr [ min_idx ] % max_elem ) * max_elem NEW_LINE min_idx += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] / max_elem NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Original ▁ Array " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT rearrange ( arr , n ) NEW_LINE print ( " Modified Array " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( int ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ j ] NEW_LINE arr [ j ] = temp NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT print ( arr ) NEW_LINE DEDENT arr = [ - 1 , 2 , - 3 , 4 , 5 , 6 , - 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE
def segregateElements ( arr , n ) : NEW_LINE INDENT temp = [ 0 for k in range ( n ) ] NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( j == n or j == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT temp [ j ] = arr [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for k in range ( n ) : NEW_LINE INDENT arr [ k ] = temp [ k ] NEW_LINE DEDENT DEDENT arr = [ 1 , - 1 , - 3 , - 2 , 7 , 5 , 11 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE segregateElements ( arr , n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( i % 2 == 0 and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ i + 1 ] NEW_LINE arr [ i + 1 ] = temp NEW_LINE DEDENT if ( i % 2 != 0 and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = arr [ i + 1 ] NEW_LINE arr [ i + 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 6 , 4 , 2 , 1 , 8 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Before ▁ rearranging : ▁ " ) NEW_LINE printArray ( arr , n ) NEW_LINE rearrange ( arr , n ) NEW_LINE print ( " After ▁ rearranging : " ) NEW_LINE printArray ( arr , n ) ; NEW_LINE
def rearrange ( a , size ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 1 NEW_LINE while ( True ) : NEW_LINE INDENT while ( positive < size and a [ positive ] >= 0 ) : NEW_LINE INDENT positive = positive + 2 NEW_LINE DEDENT while ( negative < size and a [ negative ] <= 0 ) : NEW_LINE INDENT negative = negative + 2 NEW_LINE DEDENT if ( positive < size and negative < size ) : NEW_LINE INDENT temp = a [ positive ] NEW_LINE a [ positive ] = a [ negative ] NEW_LINE a [ negative ] = temp NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , - 3 , 5 , 6 , - 3 , 6 , 7 , - 4 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE rearrange ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def arrayEvenAndOdd ( arr , n ) : NEW_LINE INDENT i = - 1 NEW_LINE j = 0 NEW_LINE while ( j != n ) : NEW_LINE INDENT if ( arr [ j ] % 2 == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT for i in arr : NEW_LINE INDENT print ( str ( i ) + " ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 4 , 7 , 6 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE arrayEvenAndOdd ( arr , n ) NEW_LINE DEDENT
def largest ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT arr = [ 10 , 324 , 45 , 90 , 9808 ] NEW_LINE n = len ( arr ) NEW_LINE print ( largest ( arr , n ) ) NEW_LINE
def findMean ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return float ( sum / n ) NEW_LINE DEDENT def findMedian ( a , n ) : NEW_LINE INDENT sorted ( a ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT return float ( a [ int ( n / 2 ) ] ) NEW_LINE DEDENT return float ( ( a [ int ( ( n - 1 ) / 2 ) ] + a [ int ( n / 2 ) ] ) / 2.0 ) NEW_LINE DEDENT a = [ 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Mean ▁ = " , findMean ( a , n ) ) NEW_LINE print ( " Median ▁ = " , findMedian ( a , n ) ) NEW_LINE
def printSmall ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , n ) : NEW_LINE INDENT max_var = arr [ k - 1 ] NEW_LINE pos = k - 1 NEW_LINE for j in range ( k - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] > max_var ) : NEW_LINE INDENT max_var = arr [ j ] NEW_LINE pos = j NEW_LINE DEDENT DEDENT if ( max_var > arr [ i ] ) : NEW_LINE INDENT j = pos NEW_LINE while ( j < k - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT arr [ k - 1 ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE printSmall ( arr , n , k ) NEW_LINE
def print2largest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = second = - 2147483648 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - 2147483648 ) : NEW_LINE INDENT print ( " There ▁ is ▁ no ▁ second ▁ largest ▁ element " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ second ▁ largest ▁ element ▁ is " , second ) NEW_LINE DEDENT DEDENT arr = [ 12 , 35 , 1 , 10 , 34 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print2largest ( arr , n ) NEW_LINE
import math NEW_LINE def sumNodes ( l ) : NEW_LINE INDENT leafNodeCount = math . pow ( 2 , l - 1 ) ; NEW_LINE sumLastLevel = 0 ; NEW_LINE sumLastLevel = ( ( leafNodeCount * ( leafNodeCount + 1 ) ) / 2 ) ; NEW_LINE sum = sumLastLevel * l ; NEW_LINE return int ( sum ) ; NEW_LINE DEDENT l = 3 ; NEW_LINE print ( sumNodes ( l ) ) ; NEW_LINE
def add ( arr , N , lo , hi , val ) : NEW_LINE INDENT arr [ lo ] += val NEW_LINE if ( hi != N - 1 ) : NEW_LINE INDENT arr [ hi + 1 ] -= val NEW_LINE DEDENT DEDENT def updateArray ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT DEDENT def printArr ( arr , N ) : NEW_LINE INDENT updateArray ( arr , N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 6 NEW_LINE arr = [ 0 for i in range ( N ) ] NEW_LINE add ( arr , N , 0 , 2 , 100 ) NEW_LINE add ( arr , N , 1 , 5 , 100 ) NEW_LINE add ( arr , N , 2 , 3 , 100 ) NEW_LINE printArr ( arr , N ) NEW_LINE
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def FillPrefixSuffix ( prefix , arr , suffix , n ) : NEW_LINE INDENT prefix [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = GCD ( prefix [ i - 1 ] , arr [ i ] ) NEW_LINE DEDENT suffix [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT suffix [ i ] = GCD ( suffix [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT DEDENT def GCDoutsideRange ( l , r , prefix , suffix , n ) : NEW_LINE INDENT if ( l == 0 ) : NEW_LINE INDENT return suffix [ r + 1 ] NEW_LINE DEDENT if ( r == n - 1 ) : NEW_LINE INDENT return prefix [ l - 1 ] NEW_LINE DEDENT return GCD ( prefix [ l - 1 ] , suffix [ r + 1 ] ) NEW_LINE DEDENT arr = [ 2 , 6 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE prefix = [ ] NEW_LINE suffix = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT prefix . append ( 0 ) NEW_LINE suffix . append ( 0 ) NEW_LINE DEDENT FillPrefixSuffix ( prefix , arr , suffix , n ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE print ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) NEW_LINE l = 1 NEW_LINE r = 1 NEW_LINE print ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) NEW_LINE l = 1 NEW_LINE r = 2 NEW_LINE print ( GCDoutsideRange ( l , r , prefix , suffix , n ) ) NEW_LINE
def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] >= x and arr [ i ] <= y ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 9 , 10 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE i = 1 NEW_LINE j = 4 NEW_LINE print ( countInRange ( arr , n , i , j ) ) NEW_LINE i = 9 NEW_LINE j = 12 NEW_LINE print ( countInRange ( arr , n , i , j ) ) NEW_LINE
def lowerIndex ( arr , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = int ( ( l + h ) / 2 ) NEW_LINE if ( arr [ mid ] >= x ) : NEW_LINE h = mid - 1 NEW_LINE else : NEW_LINE l = mid + 1 NEW_LINE DEDENT return l NEW_LINE DEDENT def upperIndex ( arr , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = n - 1 NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = int ( ( l + h ) / 2 ) NEW_LINE if ( arr [ mid ] <= x ) : NEW_LINE l = mid + 1 NEW_LINE else : NEW_LINE h = mid - 1 NEW_LINE DEDENT return h NEW_LINE DEDENT def countInRange ( arr , n , x , y ) : NEW_LINE INDENT count = 0 ; NEW_LINE count = upperIndex ( arr , n , y ) - lowerIndex ( arr , n , x ) + 1 ; NEW_LINE return count NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 9 , 10 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE i = 1 NEW_LINE j = 4 NEW_LINE print ( countInRange ( arr , n , i , j ) ) NEW_LINE i = 9 NEW_LINE j = 12 NEW_LINE print ( countInRange ( arr , n , i , j ) ) NEW_LINE
from math import pow NEW_LINE def precompute ( arr , n , pre ) : NEW_LINE INDENT pre [ n - 1 ] = arr [ n - 1 ] * pow ( 2 , 0 ) NEW_LINE i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT pre [ i ] = ( pre [ i + 1 ] + arr [ i ] * ( 1 << ( n - 1 - i ) ) ) NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT def decimalOfSubarr ( arr , l , r , n , pre ) : NEW_LINE INDENT if ( r != n - 1 ) : NEW_LINE INDENT return ( ( pre [ l ] - pre [ r + 1 ] ) / ( 1 << ( n - 1 - r ) ) ) NEW_LINE DEDENT return pre [ l ] / ( 1 << ( n - 1 - r ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE pre = [ 0 for i in range ( n ) ] NEW_LINE precompute ( arr , n , pre ) NEW_LINE print ( int ( decimalOfSubarr ( arr , 2 , 4 , n , pre ) ) ) NEW_LINE print ( int ( decimalOfSubarr ( arr , 4 , 5 , n , pre ) ) ) NEW_LINE DEDENT
def answerQuery ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE l = l - 1 NEW_LINE for i in range ( l , r , 1 ) : NEW_LINE INDENT element = a [ i ] NEW_LINE divisors = 0 NEW_LINE for j in range ( l , r , 1 ) : NEW_LINE INDENT if ( a [ j ] % a [ i ] == 0 ) : NEW_LINE INDENT divisors += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( divisors == ( r - l ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE l = 1 NEW_LINE r = 4 NEW_LINE print ( answerQuery ( a , n , l , r ) ) NEW_LINE l = 2 NEW_LINE r = 4 NEW_LINE print ( answerQuery ( a , n , l , r ) ) NEW_LINE DEDENT
import math NEW_LINE one = [ [ 0 for x in range ( 32 ) ] for y in range ( 100001 ) ] NEW_LINE MAX = 2147483647 NEW_LINE def make_prefix ( A , n ) : NEW_LINE INDENT global one , MAX NEW_LINE for j in range ( 0 , 32 ) : NEW_LINE INDENT one [ 0 ] [ j ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a = A [ i - 1 ] NEW_LINE for j in range ( 0 , 32 ) : NEW_LINE INDENT x = int ( math . pow ( 2 , j ) ) NEW_LINE if ( a & x ) : NEW_LINE INDENT one [ i ] [ j ] = 1 + one [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT one [ i ] [ j ] = one [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def Solve ( L , R ) : NEW_LINE INDENT global one , MAX NEW_LINE l = L NEW_LINE r = R NEW_LINE tot_bits = r - l + 1 NEW_LINE X = MAX NEW_LINE for i in range ( 0 , 31 ) : NEW_LINE INDENT x = one [ r ] [ i ] - one [ l - 1 ] [ i ] NEW_LINE if ( x >= ( tot_bits - x ) ) : NEW_LINE INDENT ith_bit = pow ( 2 , i ) NEW_LINE X = X ^ ith_bit NEW_LINE DEDENT DEDENT return X NEW_LINE DEDENT n = 5 NEW_LINE q = 3 NEW_LINE A = [ 210 , 11 , 48 , 22 , 133 ] NEW_LINE L = [ 1 , 4 , 2 ] NEW_LINE R = [ 3 , 14 , 4 ] NEW_LINE make_prefix ( A , n ) NEW_LINE for j in range ( 0 , q ) : NEW_LINE INDENT print ( Solve ( L [ j ] , R [ j ] ) , end = " " ) NEW_LINE DEDENT
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , a + 1 ) : NEW_LINE INDENT ans += b // n NEW_LINE ans += 1 if ( i % n + b % n ) >= n else 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT a = 5 ; b = 13 ; n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE
def minItems ( k , r ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( ( i * k - r ) % 10 == 0 or ( i * k ) % 10 == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 10 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k , r = 15 , 2 ; NEW_LINE print ( minItems ( k , r ) ) NEW_LINE DEDENT
def answer_query ( a , n , l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a = [ 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] NEW_LINE n = len ( a ) NEW_LINE L = 1 NEW_LINE R = 8 NEW_LINE print ( answer_query ( a , n , L , R ) ) NEW_LINE L = 0 NEW_LINE R = 4 NEW_LINE print ( answer_query ( a , n , L , R ) ) NEW_LINE
N = 1000 NEW_LINE prefixans = [ 0 ] * N ; NEW_LINE def countIndex ( a , n ) : NEW_LINE INDENT global N , prefixans NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT prefixans [ i ] = 1 NEW_LINE DEDENT if ( i != 0 ) : NEW_LINE INDENT prefixans [ i ] = ( prefixans [ i ] + prefixans [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT def answer_query ( l , r ) : NEW_LINE INDENT global N , prefixans NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return prefixans [ r - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( prefixans [ r - 1 ] - prefixans [ l - 1 ] ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 2 , 2 , 3 , 3 , 4 , 4 , 4 ] NEW_LINE n = len ( a ) NEW_LINE countIndex ( a , n ) NEW_LINE L = 1 NEW_LINE R = 8 NEW_LINE print ( answer_query ( L , R ) ) NEW_LINE L = 0 NEW_LINE R = 4 NEW_LINE print ( answer_query ( L , R ) ) NEW_LINE
def primeSubarrays ( A , n ) : NEW_LINE INDENT max_val = 10 ** 7 NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( max_val ** ( 0.5 ) ) + 1 ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( 2 * p , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT val = A [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT val += A [ j ] NEW_LINE if prime [ val ] == True : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( primeSubarrays ( A , n ) ) NEW_LINE DEDENT
def repeated_digit ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE if d in a : NEW_LINE INDENT return 0 NEW_LINE DEDENT a . append ( d ) NEW_LINE n = n // 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def calculate ( L , R ) : NEW_LINE INDENT answer = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT answer = answer + repeated_digit ( i ) NEW_LINE DEDENT return answer NEW_LINE DEDENT L = 1 NEW_LINE R = 100 NEW_LINE print ( calculate ( L , R ) ) NEW_LINE
def countMinSwaps ( st ) : NEW_LINE INDENT min_swaps = 0 NEW_LINE odd_0 , even_0 = 0 , 0 NEW_LINE odd_1 , even_1 = 0 , 0 NEW_LINE n = len ( st ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT if st [ i ] == "1" : NEW_LINE INDENT even_1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_0 += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if st [ i ] == "1" : NEW_LINE INDENT odd_1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd_0 += 1 NEW_LINE DEDENT DEDENT DEDENT cnt_swaps_1 = min ( even_0 , odd_1 ) NEW_LINE cnt_swaps_2 = min ( even_1 , odd_0 ) NEW_LINE return min ( cnt_swaps_1 , cnt_swaps_2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT st = "000111" NEW_LINE print ( countMinSwaps ( st ) ) NEW_LINE DEDENT
from sys import maxint NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxint - 1 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT a = [ - 13 , - 3 , - 25 , - 20 , - 3 , - 16 , - 23 , - 12 , - 5 , - 22 , - 15 , - 4 , - 7 ] NEW_LINE print " Maximum ▁ contiguous ▁ sum ▁ is " , maxSubArraySum ( a , len ( a ) ) NEW_LINE
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = a [ 0 ] NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT elif ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT
def findMinRooms ( slots , n , m ) : NEW_LINE INDENT counts = [ 0 ] * m ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( slots [ i ] [ j ] == '1' ) : NEW_LINE INDENT counts [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ( counts ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = 7 ; NEW_LINE slots = [ "0101011" , "0011001" , "0110111" ] ; NEW_LINE print ( findMinRooms ( slots , n , m ) ) ; NEW_LINE
def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT a = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] NEW_LINE print " Maximum ▁ contiguous ▁ sum ▁ is " , maxSubArraySum ( a , len ( a ) ) NEW_LINE
from sys import maxsize NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxsize - 1 NEW_LINE max_ending_here = 0 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here += a [ i ] NEW_LINE if max_so_far < max_ending_here : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE start = s NEW_LINE end = i NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE s = i + 1 NEW_LINE DEDENT DEDENT print ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ % d " % ( max_so_far ) ) NEW_LINE print ( " Starting ▁ Index ▁ % d " % ( start ) ) NEW_LINE print ( " Ending ▁ Index ▁ % d " % ( end ) ) NEW_LINE DEDENT a = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] NEW_LINE maxSubArraySum ( a , len ( a ) ) NEW_LINE
def minSum ( A ) : NEW_LINE INDENT min_val = min ( A ) ; NEW_LINE return min_val * ( len ( A ) - 1 ) NEW_LINE DEDENT A = [ 7 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE print ( minSum ( A ) ) NEW_LINE
def NextFit ( blockSize , m , processSize , n ) : NEW_LINE INDENT allocation = [ - 1 ] * n NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if blockSize [ j ] >= processSize [ i ] : NEW_LINE INDENT allocation [ i ] = j NEW_LINE blockSize [ j ] -= processSize [ i ] NEW_LINE break NEW_LINE DEDENT j = ( j + 1 ) % m NEW_LINE DEDENT DEDENT print ( " Process ▁ No . ▁ Process ▁ Size ▁ Block ▁ no . " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , " ▁ " , processSize [ i ] , end = " ▁ " ) NEW_LINE if allocation [ i ] != - 1 : NEW_LINE INDENT print ( allocation [ i ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Allocated " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT blockSize = [ 5 , 10 , 20 ] NEW_LINE processSize = [ 10 , 20 , 5 ] NEW_LINE m = len ( blockSize ) NEW_LINE n = len ( processSize ) NEW_LINE NextFit ( blockSize , m , processSize , n ) NEW_LINE DEDENT
def findMinAvgSubarray ( arr , n , k ) : NEW_LINE INDENT if ( n < k ) : return 0 NEW_LINE res_index = 0 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT min_sum = curr_sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum += arr [ i ] - arr [ i - k ] NEW_LINE if ( curr_sum < min_sum ) : NEW_LINE INDENT min_sum = curr_sum NEW_LINE res_index = ( i - k + 1 ) NEW_LINE DEDENT DEDENT print ( " Subarray ▁ between ▁ [ " , res_index , " , ▁ " , ( res_index + k - 1 ) , " ] ▁ has ▁ minimum ▁ average " ) NEW_LINE DEDENT arr = [ 3 , 7 , 90 , 20 , 10 , 50 , 40 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE findMinAvgSubarray ( arr , n , k ) NEW_LINE
def findLargest ( m , s ) : NEW_LINE INDENT if ( s == 0 ) : NEW_LINE INDENT if ( m == 1 ) : NEW_LINE INDENT print ( " Largest ▁ number ▁ is ▁ " , "0" , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT if ( s > 9 * m ) : NEW_LINE INDENT print ( " Not ▁ possible " , end = " " ) NEW_LINE return NEW_LINE DEDENT res = [ 0 ] * m NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( s >= 9 ) : NEW_LINE INDENT res [ i ] = 9 NEW_LINE s = s - 9 NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = s NEW_LINE s = 0 NEW_LINE DEDENT DEDENT print ( " Largest ▁ number ▁ is ▁ " , end = " " ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) NEW_LINE DEDENT DEDENT s = 9 NEW_LINE m = 2 NEW_LINE findLargest ( m , s ) NEW_LINE
def minJumps ( arr , l , h ) : NEW_LINE INDENT if ( h == l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( arr [ l ] == 0 ) : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT min = float ( ' inf ' ) NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( i < l + arr [ l ] + 1 ) : NEW_LINE INDENT jumps = minJumps ( arr , i , h ) NEW_LINE if ( jumps != float ( ' inf ' ) and jumps + 1 < min ) : NEW_LINE INDENT min = jumps + 1 NEW_LINE DEDENT DEDENT DEDENT return min NEW_LINE DEDENT arr = [ 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ' Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ' , ' end ▁ is ' , minJumps ( arr , 0 , n - 1 ) ) NEW_LINE
def minJumps ( arr , n ) : NEW_LINE INDENT jumps = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT jumps [ i ] = float ( ' inf ' ) NEW_LINE DEDENT elif ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT jumps [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT min = float ( ' inf ' ) NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( j <= arr [ i ] + i ) : NEW_LINE INDENT if ( min > jumps [ j ] ) : NEW_LINE INDENT min = jumps [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( min != float ( ' inf ' ) ) : NEW_LINE INDENT jumps [ i ] = min + 1 NEW_LINE DEDENT else : NEW_LINE INDENT jumps [ i ] = min NEW_LINE DEDENT DEDENT DEDENT return jumps [ 0 ] NEW_LINE DEDENT arr = [ 1 , 3 , 6 , 3 , 2 , 3 , 6 , 8 , 9 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ' Minimum ▁ number ▁ of ▁ jumps ▁ to ▁ reach ' , ' end ▁ is ' , minJumps ( arr , n - 1 ) ) NEW_LINE
def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT min_len = n + 1 NEW_LINE for start in range ( 0 , n ) : NEW_LINE INDENT curr_sum = arr [ start ] NEW_LINE if ( curr_sum > x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for end in range ( start + 1 , n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE if curr_sum > x and ( end - start + 1 ) < min_len : NEW_LINE INDENT min_len = ( end - start + 1 ) NEW_LINE DEDENT DEDENT DEDENT return min_len ; NEW_LINE DEDENT arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] NEW_LINE x = 51 NEW_LINE n1 = len ( arr1 ) NEW_LINE res1 = smallestSubWithSum ( arr1 , n1 , x ) ; NEW_LINE if res1 == n1 + 1 : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res1 ) NEW_LINE DEDENT arr2 = [ 1 , 10 , 5 , 2 , 7 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE x = 9 NEW_LINE res2 = smallestSubWithSum ( arr2 , n2 , x ) ; NEW_LINE if res2 == n2 + 1 : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res2 ) NEW_LINE DEDENT arr3 = [ 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE x = 280 NEW_LINE res3 = smallestSubWithSum ( arr3 , n3 , x ) NEW_LINE if res3 == n3 + 1 : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res3 ) NEW_LINE DEDENT
def smallestSubWithSum ( arr , n , x ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE min_len = n + 1 NEW_LINE start = 0 NEW_LINE end = 0 NEW_LINE while ( end < n ) : NEW_LINE INDENT while ( curr_sum <= x and end < n ) : NEW_LINE INDENT curr_sum += arr [ end ] NEW_LINE end += 1 NEW_LINE DEDENT while ( curr_sum > x and start < n ) : NEW_LINE INDENT if ( end - start < min_len ) : NEW_LINE INDENT min_len = end - start NEW_LINE DEDENT curr_sum -= arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT DEDENT return min_len NEW_LINE DEDENT arr1 = [ 1 , 4 , 45 , 6 , 10 , 19 ] NEW_LINE x = 51 NEW_LINE n1 = len ( arr1 ) NEW_LINE res1 = smallestSubWithSum ( arr1 , n1 , x ) NEW_LINE print ( " Not ▁ possible " ) if ( res1 == n1 + 1 ) else print ( res1 ) NEW_LINE arr2 = [ 1 , 10 , 5 , 2 , 7 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE x = 9 NEW_LINE res2 = smallestSubWithSum ( arr2 , n2 , x ) NEW_LINE print ( " Not ▁ possible " ) if ( res2 == n2 + 1 ) else print ( res2 ) NEW_LINE arr3 = [ 1 , 11 , 100 , 1 , 0 , 200 , 3 , 2 , 1 , 250 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE x = 280 NEW_LINE res3 = smallestSubWithSum ( arr3 , n3 , x ) NEW_LINE print ( " Not ▁ possible " ) if ( res3 == n3 + 1 ) else print ( res3 ) NEW_LINE
def countMinOperations ( target , n ) : NEW_LINE INDENT result = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT zero_count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( ( target [ i ] & 1 ) > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT elif ( target [ i ] == 0 ) : NEW_LINE INDENT zero_count += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( zero_count == n ) : NEW_LINE INDENT return result ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT target [ j ] = target [ j ] // 2 ; NEW_LINE DEDENT result += 1 ; NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if ( target [ j ] & 1 ) : NEW_LINE INDENT target [ j ] -= 1 ; NEW_LINE result += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 16 , 16 , 16 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( " Minimum ▁ number ▁ of ▁ steps ▁ required ▁ to " , 	 	 " get the given target array is " , countMinOperations ( arr , n ) ) ; NEW_LINE
def findMinOps ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE i , j = 0 , n - 1 NEW_LINE while i <= j : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif arr [ i ] > arr [ j ] : NEW_LINE INDENT j -= 1 NEW_LINE arr [ j ] += arr [ j + 1 ] NEW_LINE ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] += arr [ i - 1 ] NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 4 , 5 , 9 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Count ▁ of ▁ minimum ▁ operations ▁ is ▁ " + str ( findMinOps ( arr , n ) ) ) NEW_LINE
def findSmallest ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] <= res : NEW_LINE INDENT res = res + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr1 = [ 1 , 3 , 4 , 5 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( findSmallest ( arr1 , n1 ) ) NEW_LINE arr2 = [ 1 , 2 , 6 , 10 , 11 , 15 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( findSmallest ( arr2 , n2 ) ) NEW_LINE arr3 = [ 1 , 1 , 1 , 1 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE print ( findSmallest ( arr3 , n3 ) ) NEW_LINE arr4 = [ 1 , 1 , 3 , 4 ] NEW_LINE n4 = len ( arr4 ) NEW_LINE print ( findSmallest ( arr4 , n4 ) ) NEW_LINE
def findMinDiff ( arr , n ) : NEW_LINE INDENT diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] - arr [ j ] ) < diff : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return diff NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 19 , 18 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ difference ▁ is ▁ " + str ( findMinDiff ( arr , n ) ) ) NEW_LINE
def findMinDiff ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE diff = 10 ** 20 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] - arr [ i ] < diff : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 19 , 18 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ difference ▁ is ▁ " + str ( findMinDiff ( arr , n ) ) ) NEW_LINE
import math NEW_LINE a = 2 NEW_LINE b = 10 NEW_LINE size = abs ( b - a ) + 1 NEW_LINE array = [ 0 ] * size NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 or i % 5 == 0 ) : NEW_LINE INDENT array [ i - a ] = 1 NEW_LINE DEDENT DEDENT print ( " MULTIPLES ▁ of ▁ 2 ▁ and ▁ 5 : " ) NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( array [ i - a ] == 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def longestCommonSum ( arr1 , arr2 , n ) : NEW_LINE INDENT maxLen = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum1 += arr1 [ j ] NEW_LINE sum2 += arr2 [ j ] NEW_LINE if ( sum1 == sum2 ) : NEW_LINE INDENT len = j - i + 1 NEW_LINE if ( len > maxLen ) : NEW_LINE INDENT maxLen = len NEW_LINE DEDENT DEDENT DEDENT DEDENT return maxLen NEW_LINE DEDENT arr1 = [ 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 1 , 1 , 1 , 1 , 1 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( " Length ▁ of ▁ the ▁ longest ▁ common ▁ span ▁ with ▁ same ▁ " " sum ▁ is " , longestCommonSum ( arr1 , arr2 , n ) ) NEW_LINE
NA = - 1 NEW_LINE def moveToEnd ( mPlusN , size ) : NEW_LINE INDENT i = 0 NEW_LINE j = size - 1 NEW_LINE for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mPlusN [ i ] != NA ) : NEW_LINE INDENT mPlusN [ j ] = mPlusN [ i ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT def merge ( mPlusN , N , m , n ) : NEW_LINE INDENT i = n NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( k < ( m + n ) ) : NEW_LINE INDENT if ( ( j == n ) or ( i < ( m + n ) and mPlusN [ i ] <= N [ j ] ) ) : NEW_LINE INDENT mPlusN [ k ] = mPlusN [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mPlusN [ k ] = N [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT mPlusN = [ 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 ] NEW_LINE N = [ 5 , 7 , 9 , 25 ] NEW_LINE n = len ( N ) NEW_LINE m = len ( mPlusN ) - n NEW_LINE moveToEnd ( mPlusN , m + n ) NEW_LINE merge ( mPlusN , N , m , n ) NEW_LINE printArray ( mPlusN , m + n ) NEW_LINE
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( B [ i ] == 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( B [ j ] == 1 ) : NEW_LINE INDENT j = j + 1 NEW_LINE DEDENT A = A [ 0 : i ] + sorted ( A [ i : j + 1 ] ) + A [ j + 1 : ] NEW_LINE i = j NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] != i + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT A = [ 1 , 2 , 5 , 3 , 4 , 6 ] NEW_LINE B = [ 0 , 1 , 1 , 1 , 0 ] NEW_LINE n = len ( A ) NEW_LINE if ( sortedAfterSwap ( A , B , n ) ) : NEW_LINE INDENT print ( " A ▁ can ▁ be ▁ sorted " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " A ▁ can ▁ not ▁ be ▁ sorted " ) NEW_LINE DEDENT
def sortedAfterSwap ( A , B , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if B [ i ] : NEW_LINE INDENT if A [ i ] != i + 1 : NEW_LINE INDENT A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if A [ i ] != i + 1 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 5 , 3 , 4 , 6 ] NEW_LINE B = [ 0 , 1 , 1 , 1 , 0 ] NEW_LINE n = len ( A ) NEW_LINE if ( sortedAfterSwap ( A , B , n ) ) : NEW_LINE INDENT print ( " A ▁ can ▁ be ▁ sorted " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " A ▁ can ▁ not ▁ be ▁ sorted " ) NEW_LINE DEDENT DEDENT
def segregate0and1 ( arr , n ) : NEW_LINE INDENT type0 = 0 ; type1 = n - 1 NEW_LINE while ( type0 < type1 ) : NEW_LINE INDENT if ( arr [ type0 ] == 1 ) : NEW_LINE INDENT arr [ type0 ] , arr [ type1 ] = arr [ type1 ] , arr [ type0 ] NEW_LINE type1 -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT type0 += 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 1 , 1 , 0 , 1 , 0 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE segregate0and1 ( arr , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def getInvCount ( arr , n ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT arr = [ 1 , 20 , 6 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number ▁ of ▁ inversions ▁ are " , getInvCount ( arr , n ) ) NEW_LINE
def minAbsSumPair ( arr , arr_size ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if arr_size < 2 : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT min_l = 0 NEW_LINE min_r = 1 NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE for l in range ( 0 , arr_size - 1 ) : NEW_LINE INDENT for r in range ( l + 1 , arr_size ) : NEW_LINE INDENT sum = arr [ l ] + arr [ r ] NEW_LINE if abs ( min_sum ) > abs ( sum ) : NEW_LINE INDENT min_sum = sum NEW_LINE min_l = l NEW_LINE min_r = r NEW_LINE DEDENT DEDENT DEDENT print ( " The ▁ two ▁ elements ▁ whose ▁ sum ▁ is ▁ minimum ▁ are " , arr [ min_l ] , " and ▁ " , arr [ min_r ] ) NEW_LINE DEDENT arr = [ 1 , 60 , - 10 , 70 , - 80 , 85 ] NEW_LINE minAbsSumPair ( arr , 6 ) ; NEW_LINE
def increasing ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= a [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def decreasing ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( a [ i ] < a [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def shortestUnsorted ( a , n ) : NEW_LINE INDENT if ( increasing ( a , n ) == True or decreasing ( a , n ) == True ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT ar = [ 7 , 9 , 10 , 8 , 11 ] NEW_LINE n = len ( ar ) NEW_LINE print ( shortestUnsorted ( ar , n ) ) NEW_LINE
def printUnion ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT elif arr2 [ j ] < arr1 [ i ] : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT while i < m : NEW_LINE INDENT print ( arr1 [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT while j < n : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT arr1 = [ 1 , 2 , 4 , 5 , 6 ] NEW_LINE arr2 = [ 2 , 3 , 5 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE printUnion ( arr1 , arr2 , m , n ) NEW_LINE
def printIntersection ( arr1 , arr2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif arr2 [ j ] < arr1 [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr2 [ j ] ) NEW_LINE j += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT arr1 = [ 1 , 2 , 4 , 5 , 6 ] NEW_LINE arr2 = [ 2 , 3 , 5 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE printIntersection ( arr1 , arr2 , m , n ) NEW_LINE
def printUnion ( arr1 , arr2 , m , n ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT tempp = arr1 NEW_LINE arr1 = arr2 NEW_LINE arr2 = tempp NEW_LINE temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT print ( arr1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) == - 1 ) : NEW_LINE INDENT print ( arr2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT def printIntersection ( arr1 , arr2 , m , n ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT tempp = arr1 NEW_LINE arr1 = arr2 NEW_LINE arr2 = tempp NEW_LINE temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( binarySearch ( arr1 , 0 , m - 1 , arr2 [ i ] ) != - 1 ) : NEW_LINE INDENT print ( arr2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr1 = [ 7 , 1 , 5 , 2 , 3 , 6 ] NEW_LINE arr2 = [ 3 , 8 , 6 , 20 , 7 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( " Union ▁ of ▁ two ▁ arrays ▁ is ▁ " ) NEW_LINE printUnion ( arr1 , arr2 , m , n ) NEW_LINE print ( " Intersection of two arrays is   " ) NEW_LINE printIntersection ( arr1 , arr2 , m , n ) NEW_LINE
def intersection ( a , b , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( a [ i ] > b [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( b [ j ] > a [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 3 , 2 , 3 , 4 , 5 , 5 , 6 ] NEW_LINE b = [ 3 , 3 , 5 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE intersection ( a , b , n , m ) NEW_LINE DEDENT
def sort012 ( a , arr_size ) : NEW_LINE INDENT lo = 0 NEW_LINE hi = arr_size - 1 NEW_LINE mid = 0 NEW_LINE while mid <= hi : NEW_LINE INDENT if a [ mid ] == 0 : NEW_LINE INDENT a [ lo ] , a [ mid ] = a [ mid ] , a [ lo ] NEW_LINE lo = lo + 1 NEW_LINE mid = mid + 1 NEW_LINE DEDENT elif a [ mid ] == 1 : NEW_LINE INDENT mid = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ mid ] , a [ hi ] = a [ hi ] , a [ mid ] NEW_LINE hi = hi - 1 NEW_LINE DEDENT DEDENT return a NEW_LINE DEDENT def printArray ( a ) : NEW_LINE INDENT for k in a : NEW_LINE INDENT print k , NEW_LINE DEDENT DEDENT arr = [ 0 , 1 , 1 , 0 , 1 , 2 , 1 , 2 , 0 , 0 , 0 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE arr = sort012 ( arr , arr_size ) NEW_LINE print   " Array after segregation : NEW_LINE " , NEW_LINE printArray ( arr ) NEW_LINE
def printUnsorted ( arr , n ) : NEW_LINE INDENT e = n - 1 NEW_LINE for s in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ s ] > arr [ s + 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if s == n - 1 : NEW_LINE INDENT print ( " The ▁ complete ▁ array ▁ is ▁ sorted " ) NEW_LINE exit ( ) NEW_LINE DEDENT e = n - 1 NEW_LINE while e > 0 : NEW_LINE INDENT if arr [ e ] < arr [ e - 1 ] : NEW_LINE INDENT break NEW_LINE DEDENT e -= 1 NEW_LINE DEDENT max = arr [ s ] NEW_LINE min = arr [ s ] NEW_LINE for i in range ( s + 1 , e + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if arr [ i ] < min : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( s ) : NEW_LINE INDENT if arr [ i ] > min : NEW_LINE INDENT s = i NEW_LINE break NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while i >= e + 1 : NEW_LINE INDENT if arr [ i ] < max : NEW_LINE INDENT e = i NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( " The ▁ unsorted ▁ subarray ▁ which ▁ makes ▁ the ▁ given ▁ array " ) NEW_LINE print ( " sorted ▁ lies ▁ between ▁ the ▁ indexes ▁ % d ▁ and ▁ % d " % ( s , e ) ) NEW_LINE DEDENT arr = [ 10 , 12 , 20 , 30 , 25 , 40 , 32 , 31 , 35 , 50 , 60 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printUnsorted ( arr , arr_size ) NEW_LINE
def findnumberofTriangles ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE arr . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT k = i + 2 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT while ( k < n and arr [ i ] + arr [ j ] > arr [ k ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if ( k > j ) : NEW_LINE INDENT count += k - j - 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 10 , 21 , 22 , 100 , 101 , 200 , 300 ] NEW_LINE print " Number ▁ of ▁ Triangles : " , findnumberofTriangles ( arr ) NEW_LINE
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ i ] - arr [ j ] == k or arr [ j ] - arr [ i ] == k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " , countPairsWithDiffK ( arr , n , k ) ) NEW_LINE
def binarySearch ( arr , low , high , x ) : NEW_LINE INDENT if ( high >= low ) : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if x == arr [ mid ] : NEW_LINE INDENT return ( mid ) NEW_LINE DEDENT elif ( x > arr [ mid ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , low , ( mid - 1 ) , x ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT if ( binarySearch ( arr , i + 1 , n - 1 , arr [ i ] + k ) != - 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " , countPairsWithDiffK ( arr , n , k ) ) NEW_LINE
def countPairsWithDiffK ( arr , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r < n : NEW_LINE INDENT if arr [ r ] - arr [ l ] == k : NEW_LINE INDENT count += 1 NEW_LINE l += 1 NEW_LINE r += 1 NEW_LINE DEDENT elif arr [ r ] - arr [ l ] > k : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( " Count ▁ of ▁ pairs ▁ with ▁ given ▁ diff ▁ is ▁ " , countPairsWithDiffK ( arr , n , k ) ) NEW_LINE DEDENT
def constructArr ( arr , pair , n ) : NEW_LINE INDENT arr [ 0 ] = ( pair [ 0 ] + pair [ 1 ] - pair [ n - 1 ] ) // 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT arr [ i ] = pair [ i - 1 ] - arr [ 0 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT pair = [ 15 , 13 , 11 , 10 , 12 , 10 , 9 , 8 , 7 , 5 ] NEW_LINE n = 5 NEW_LINE arr = [ 0 ] * n NEW_LINE constructArr ( arr , pair , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def merge ( ar1 , ar2 , m , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT last = ar1 [ m - 1 ] NEW_LINE j = m - 2 NEW_LINE while ( j >= 0 and ar1 [ j ] > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar1 [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT if ( j != m - 2 or last > ar2 [ i ] ) : NEW_LINE INDENT ar1 [ j + 1 ] = ar2 [ i ] NEW_LINE ar2 [ i ] = last NEW_LINE DEDENT DEDENT DEDENT ar1 = [ 1 , 5 , 9 , 10 , 15 , 20 ] NEW_LINE ar2 = [ 2 , 3 , 8 , 13 ] NEW_LINE m = len ( ar1 ) NEW_LINE n = len ( ar2 ) NEW_LINE merge ( ar1 , ar2 , m , n ) NEW_LINE print ( " After Merging First Array : " , ▁ end = " " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( ar1 [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT print ( " Second Array : " , ▁ end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ar2 [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT
def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( 1 , n ) : NEW_LINE INDENT count = 1 NEW_LINE c = 1 NEW_LINE for i in range ( 1 , row_num ) : NEW_LINE INDENT c = c * ( row_num - i ) / i NEW_LINE if ( c % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 16 ; NEW_LINE gouldSequence ( n ) NEW_LINE
def minmaxProduct ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE return arr1 [ n1 - 1 ] * arr2 [ 0 ] NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 , 6 , 4 , 1 ] NEW_LINE arr2 = [ 5 , 1 , 4 , 2 , 6 , 9 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( minmaxProduct ( arr1 , arr2 , n1 , n2 ) ) NEW_LINE
M = 100 NEW_LINE N = 100 NEW_LINE def find_min_odd_cost ( given , m , n ) : NEW_LINE INDENT floor = [ [ 0 for i in range ( M ) ] for i in range ( N ) ] NEW_LINE min_odd_cost = 0 NEW_LINE i , j , temp = 0 , 0 , 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT floor [ 0 ] [ j ] = given [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT floor [ i ] [ j ] = given [ i ] [ j ] ; NEW_LINE floor [ i ] [ j ] += min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT elif ( j == n - 1 ) : NEW_LINE INDENT floor [ i ] [ j ] = given [ i ] [ j ] ; NEW_LINE floor [ i ] [ j ] += min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = min ( floor [ i - 1 ] [ j ] , floor [ i - 1 ] [ j - 1 ] ) NEW_LINE temp = min ( temp , floor [ i - 1 ] [ j + 1 ] ) NEW_LINE floor [ i ] [ j ] = given [ i ] [ j ] + temp NEW_LINE DEDENT DEDENT DEDENT min_odd_cost = 10 ** 9 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( floor [ n - 1 ] [ j ] % 2 == 1 ) : NEW_LINE INDENT if ( min_odd_cost > floor [ n - 1 ] [ j ] ) : NEW_LINE INDENT min_odd_cost = floor [ n - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( min_odd_cost == - 10 ** 9 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return min_odd_cost NEW_LINE DEDENT m , n = 5 , 5 NEW_LINE given = [ [ 1 , 2 , 3 , 4 , 6 ] , [ 1 , 2 , 3 , 4 , 5 ] , [ 1 , 2 , 3 , 4 , 5 ] , [ 1 , 2 , 3 , 4 , 5 ] , [ 100 , 2 , 3 , 4 , 5 ] ] NEW_LINE print ( " Minimum ▁ odd ▁ cost ▁ is " , find_min_odd_cost ( given , m , n ) ) NEW_LINE
def minMaxProduct ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT max = arr1 [ 0 ] NEW_LINE min = arr2 [ 0 ] NEW_LINE i = 1 NEW_LINE while ( i < n1 and i < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] > max ) : NEW_LINE INDENT max = arr1 [ i ] NEW_LINE DEDENT if ( arr2 [ i ] < min ) : NEW_LINE INDENT min = arr2 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while ( i < n1 ) : NEW_LINE INDENT if ( arr1 [ i ] > max ) : NEW_LINE INDENT max = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT while ( i < n2 ) : NEW_LINE INDENT if ( arr2 [ i ] < min ) : NEW_LINE INDENT min = arr2 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return max * min NEW_LINE DEDENT arr1 = [ 10 , 2 , 3 , 6 , 4 , 1 ] NEW_LINE arr2 = [ 5 , 1 , 4 , 2 , 6 , 9 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr1 ) NEW_LINE print ( minMaxProduct ( arr1 , arr2 , n1 , n2 ) ) NEW_LINE
def findElement ( arr , n , key ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == key ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 12 , 34 , 10 , 6 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE key = 40 NEW_LINE index = findElement ( arr , n , key ) NEW_LINE if index != - 1 : NEW_LINE INDENT print ( " element ▁ found ▁ at ▁ position : ▁ " + str ( index + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " element ▁ not ▁ found " ) NEW_LINE DEDENT
def binarySearch ( arr , low , high , key ) : NEW_LINE INDENT mid = ( low + high ) / 2 NEW_LINE if ( key == arr [ int ( mid ) ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( key > arr [ int ( mid ) ] ) : NEW_LINE INDENT return binarySearch ( arr , ( mid + 1 ) , high , key ) NEW_LINE DEDENT if ( key < arr [ int ( mid ) ] ) : NEW_LINE INDENT return binarySearch ( arr , low , ( mid - 1 ) , key ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE key = 10 NEW_LINE print ( " Index : " , int ( binarySearch ( arr , 0 , n - 1 , key ) ) ) NEW_LINE
def findSDSFunc ( n ) : NEW_LINE INDENT DP = [ 0 ] * ( n + 1 ) NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( int ( i % 2 ) == 0 ) : NEW_LINE INDENT DP [ i ] = DP [ int ( i / 2 ) ] NEW_LINE DEDENT else : NEW_LINE INDENT DP [ i ] = ( DP [ int ( ( i - 1 ) / 2 ) ] + DP [ int ( ( i + 1 ) / 2 ) ] ) NEW_LINE DEDENT DEDENT return DP [ n ] NEW_LINE DEDENT n = 15 NEW_LINE print ( findSDSFunc ( n ) ) NEW_LINE
def findCommon ( ar1 , ar2 , ar3 , n1 , n2 , n3 ) : NEW_LINE INDENT i , j , k = 0 , 0 , 0 NEW_LINE while ( i < n1 and j < n2 and k < n3 ) : NEW_LINE INDENT if ( ar1 [ i ] == ar2 [ j ] and ar2 [ j ] == ar3 [ k ] ) : NEW_LINE INDENT print ar1 [ i ] , NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT elif ar1 [ i ] < ar2 [ j ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ar2 [ j ] < ar3 [ k ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT DEDENT DEDENT ar1 = [ 1 , 5 , 10 , 20 , 40 , 80 ] NEW_LINE ar2 = [ 6 , 7 , 20 , 80 , 100 ] NEW_LINE ar3 = [ 3 , 4 , 15 , 20 , 30 , 70 , 80 , 120 ] NEW_LINE n1 = len ( ar1 ) NEW_LINE n2 = len ( ar2 ) NEW_LINE n3 = len ( ar3 ) NEW_LINE print " Common ▁ elements ▁ are " , NEW_LINE findCommon ( ar1 , ar2 , ar3 , n1 , n2 , n3 ) NEW_LINE
def Jacobsthal ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT def Jacobsthal_Lucas ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 2 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + 2 * dp [ i - 2 ] ; NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT n = 5 NEW_LINE print ( " Jacobsthal ▁ number : " , Jacobsthal ( n ) ) NEW_LINE print ( " Jacobsthal - Lucas ▁ number : " , Jacobsthal_Lucas ( n ) ) NEW_LINE
def binary_search ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) / 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ mid ] > x : NEW_LINE INDENT return binary_search ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binary_search ( arr , mid + 1 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def findPos ( a , key ) : NEW_LINE INDENT l , h , val = 0 , 1 , arr [ 0 ] NEW_LINE while val < key : NEW_LINE INDENT l = h NEW_LINE h = 2 * h NEW_LINE val = arr [ h ] NEW_LINE DEDENT return binary_search ( a , l , h , key ) NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 9 , 10 , 90 , 100 , 130 , 140 , 160 , 170 ] NEW_LINE ans = findPos ( arr , 10 ) NEW_LINE if ans == - 1 : NEW_LINE INDENT print " Element ▁ not ▁ found " NEW_LINE DEDENT else : NEW_LINE INDENT print " Element ▁ found ▁ at ▁ index " , ans NEW_LINE DEDENT
def answer ( n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( 10 ) ] for y in range ( n + 1 ) ] ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 ; NEW_LINE DEDENT for j in range ( 10 ) : NEW_LINE INDENT dp [ 1 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT sum = 0 ; NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ n ] [ j ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( answer ( n ) ) ; NEW_LINE
def findSingle ( ar , n ) : NEW_LINE INDENT res = ar [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = res ^ ar [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT ar = [ 2 , 3 , 5 , 4 , 5 , 3 , 4 ] NEW_LINE print " Element ▁ occurring ▁ once ▁ is " , findSingle ( ar , len ( ar ) ) NEW_LINE
dp = [ [ 0 for i in range ( 15001 ) ] for j in range ( 1001 ) ] NEW_LINE def computeDpArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , 15001 , 1 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( j == arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + ( arr [ i ] == j ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def countTripletSum ( arr , n ) : NEW_LINE INDENT computeDpArray ( arr , n ) NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n - 2 , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 , 1 ) : NEW_LINE INDENT for k in range ( 1 , 25 , 1 ) : NEW_LINE INDENT cube = k * k * k NEW_LINE rem = cube - ( arr [ i ] + arr [ j ] ) NEW_LINE if ( rem > 0 ) : NEW_LINE INDENT ans += dp [ n - 1 ] [ rem ] - dp [ j ] [ rem ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 5 , 1 , 20 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countTripletSum ( arr , n ) ) NEW_LINE DEDENT
INT_MIN = - 2147483648 NEW_LINE def isPresent ( B , m , x ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT if B [ i ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findMaxSubarraySumUtil ( A , B , n , m ) : NEW_LINE INDENT max_so_far = INT_MIN NEW_LINE curr_max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isPresent ( B , m , A [ i ] ) == True : NEW_LINE INDENT curr_max = 0 NEW_LINE continue NEW_LINE DEDENT curr_max = max ( A [ i ] , curr_max + A [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def findMaxSubarraySum ( A , B , n , m ) : NEW_LINE INDENT maxSubarraySum = findMaxSubarraySumUtil ( A , B , n , m ) NEW_LINE if maxSubarraySum == INT_MIN : NEW_LINE INDENT print ( ' Maximum ▁ Subarray ▁ Sum ▁ cant ▁ be ▁ found ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' The ▁ Maximum ▁ Subarray ▁ Sum ▁ = ' , maxSubarraySum ) NEW_LINE DEDENT DEDENT A = [ 3 , 4 , 5 , - 4 , 6 ] NEW_LINE B = [ 1 , 8 , 5 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE findMaxSubarraySum ( A , B , n , m ) NEW_LINE
import numpy as np NEW_LINE def nonDecNums ( n ) : NEW_LINE INDENT a = np . zeros ( ( n + 1 , 10 ) ) NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT a [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT a [ i ] [ 9 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 8 , - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = a [ i - 1 ] [ j ] + a [ i ] [ j + 1 ] NEW_LINE DEDENT DEDENT return int ( a [ n ] [ 0 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( " Non - decreasing ▁ digits ▁ = ▁ " , nonDecNums ( n ) ) NEW_LINE DEDENT
def countBT ( h ) : NEW_LINE INDENT MOD = 1000000007 NEW_LINE dp = [ 0 for i in range ( h + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , h + 1 ) : NEW_LINE INDENT dp [ i ] = ( dp [ i - 1 ] * ( ( 2 * dp [ i - 2 ] ) % MOD + dp [ i - 1 ] ) % MOD ) % MOD NEW_LINE DEDENT return dp [ h ] NEW_LINE DEDENT h = 3 NEW_LINE print ( " No . ▁ of ▁ balanced ▁ binary ▁ trees ▁ of ▁ height ▁ " + str ( h ) + " ▁ is : ▁ " + str ( countBT ( h ) ) ) NEW_LINE
def equilibrium ( arr ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT leftsum = 0 NEW_LINE rightsum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT leftsum += arr [ j ] NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT rightsum += arr [ j ] NEW_LINE DEDENT if leftsum == rightsum : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ - 7 , 1 , 5 , 2 , - 4 , 3 , 0 ] NEW_LINE print ( equilibrium ( arr ) ) NEW_LINE
import numpy as np NEW_LINE def countEndless ( input_mat , n ) : NEW_LINE INDENT row = np . zeros ( ( n , n ) ) NEW_LINE col = np . zeros ( ( n , n ) ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT isEndless = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input_mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT isEndless = 0 NEW_LINE DEDENT col [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT isEndless = 1 NEW_LINE for j in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( input_mat [ i ] [ j ] == 0 ) : NEW_LINE INDENT isEndless = 0 NEW_LINE DEDENT row [ i ] [ j ] = isEndless NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input_mat = [ [ 1 , 0 , 1 , 1 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 ] , [ 0 , 1 , 1 , 0 ] ] NEW_LINE n = 4 NEW_LINE print ( countEndless ( input_mat , n ) ) NEW_LINE DEDENT
def equilibrium ( arr ) : NEW_LINE INDENT total_sum = sum ( arr ) NEW_LINE leftsum = 0 NEW_LINE for i , num in enumerate ( arr ) : NEW_LINE INDENT total_sum -= num NEW_LINE if leftsum == total_sum : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += num NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ - 7 , 1 , 5 , 2 , - 4 , 3 , 0 ] NEW_LINE print ( ' First ▁ equilibrium ▁ index ▁ is ▁ ' , equilibrium ( arr ) ) NEW_LINE
def sumOfSubstrings ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sumofdigit = [ ] NEW_LINE sumofdigit . append ( int ( num [ 0 ] ) ) NEW_LINE res = sumofdigit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT numi = int ( num [ i ] ) NEW_LINE sumofdigit . append ( ( i + 1 ) * numi + 10 * sumofdigit [ i - 1 ] ) NEW_LINE res += sumofdigit [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT num = "1234" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE
def printLeaders ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] <= arr [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == size - 1 : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT DEDENT DEDENT arr = [ 16 , 17 , 4 , 3 , 5 , 2 ] NEW_LINE printLeaders ( arr , len ( arr ) ) NEW_LINE
def printLeaders ( arr , size ) : NEW_LINE INDENT max_from_right = arr [ size - 1 ] NEW_LINE print max_from_right , NEW_LINE for i in range ( size - 2 , - 1 , - 1 ) : NEW_LINE INDENT if max_from_right < arr [ i ] : NEW_LINE INDENT print arr [ i ] , NEW_LINE max_from_right = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT arr = [ 16 , 17 , 4 , 3 , 5 , 2 ] NEW_LINE printLeaders ( arr , len ( arr ) ) NEW_LINE
def unboundedKnapsack ( W , n , val , wt ) : NEW_LINE INDENT dp = [ 0 for i in range ( W + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( W + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( wt [ j ] <= i ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - wt [ j ] ] + val [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ W ] NEW_LINE DEDENT W = 100 NEW_LINE val = [ 10 , 30 , 20 ] NEW_LINE wt = [ 5 , 10 , 15 ] NEW_LINE n = len ( val ) NEW_LINE print ( unboundedKnapsack ( W , n , val , wt ) ) NEW_LINE
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT i = low NEW_LINE for i in range ( high ) : NEW_LINE INDENT if arr [ i ] == x : NEW_LINE INDENT return i NEW_LINE DEDENT if arr [ i ] < x and arr [ i + 1 ] >= x : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE index = ceilSearch ( arr , 0 , n - 1 , x ) ; NEW_LINE if index == - 1 : NEW_LINE INDENT print ( " Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " % x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ceiling ▁ of ▁ % d ▁ is ▁ % d " % ( x , arr [ index ] ) ) NEW_LINE DEDENT
def maxSumSubarrayRemovingOneEle ( arr , n ) : NEW_LINE INDENT fw = [ 0 for k in range ( n ) ] NEW_LINE bw = [ 0 for k in range ( n ) ] NEW_LINE cur_max , max_so_far = arr [ 0 ] , arr [ 0 ] NEW_LINE fw [ 0 ] = cur_max NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , cur_max ) NEW_LINE fw [ i ] = cur_max NEW_LINE DEDENT cur_max = max_so_far = bw [ n - 1 ] = arr [ n - 1 ] NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT cur_max = max ( arr [ i ] , cur_max + arr [ i ] ) NEW_LINE max_so_far = max ( max_so_far , cur_max ) NEW_LINE bw [ i ] = cur_max NEW_LINE i -= 1 NEW_LINE DEDENT fans = max_so_far NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT fans = max ( fans , fw [ i - 1 ] + bw [ i + 1 ] ) NEW_LINE DEDENT return fans NEW_LINE DEDENT arr = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] NEW_LINE n = len ( arr ) NEW_LINE print maxSumSubarrayRemovingOneEle ( arr , n ) NEW_LINE
def ceilSearch ( arr , low , high , x ) : NEW_LINE INDENT if x <= arr [ low ] : NEW_LINE INDENT return low NEW_LINE DEDENT if x > arr [ high ] : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT if mid + 1 <= high and x <= arr [ mid + 1 ] : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , mid + 1 , high , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if mid - 1 >= low and x > arr [ mid - 1 ] : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT return ceilSearch ( arr , low , mid - 1 , x ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 8 , 10 , 10 , 12 , 19 ] NEW_LINE n = len ( arr ) NEW_LINE x = 20 NEW_LINE index = ceilSearch ( arr , 0 , n - 1 , x ) ; NEW_LINE if index == - 1 : NEW_LINE INDENT print ( " Ceiling ▁ of ▁ % d ▁ doesn ' t ▁ exist ▁ in ▁ array ▁ " % x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ceiling ▁ of ▁ % d ▁ is ▁ % d " % ( x , arr [ index ] ) ) NEW_LINE DEDENT
M = 100 NEW_LINE def maxAverageOfPath ( cost , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ 0 ] [ j ] = dp [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ N - 1 ] [ N - 1 ] / ( 2 * N - 1 ) NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 6 , 5 , 4 ] , [ 7 , 3 , 9 ] ] NEW_LINE print ( maxAverageOfPath ( cost , 3 ) ) NEW_LINE
MAX = 1000 NEW_LINE def maxCost ( mat , N ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = mat [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = mat [ i ] [ 0 ] + dp [ i - 1 ] [ 0 ] NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( 1 , min ( i + 1 , N ) ) : NEW_LINE INDENT dp [ i ] [ j ] = mat [ i ] [ j ] + max ( dp [ i - 1 ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT result = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( result < dp [ N - 1 ] [ i ] ) : NEW_LINE INDENT result = dp [ N - 1 ] [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT mat = [ [ 4 , 1 , 5 , 6 , 1 ] , [ 2 , 9 , 2 , 11 , 10 ] , [ 15 , 1 , 3 , 15 , 2 ] , [ 16 , 92 , 41 , 4 , 3 ] , [ 8 , 142 , 6 , 4 , 8 ] ] NEW_LINE N = 5 NEW_LINE print ( ' Maximum ▁ Path ▁ Sum ▁ : ' , maxCost ( mat , N ) ) NEW_LINE
def mini ( arr , l , h ) : NEW_LINE INDENT mn = arr [ l ] NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( mn > arr [ i ] ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE DEDENT DEDENT return mn NEW_LINE DEDENT def max ( arr , l , h ) : NEW_LINE INDENT mx = arr [ l ] NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( mx < arr [ i ] ) : NEW_LINE INDENT mx = arr [ i ] NEW_LINE DEDENT DEDENT return mx NEW_LINE DEDENT def minRemovals ( arr , l , h ) : NEW_LINE INDENT if ( l >= h ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT mn = mini ( arr , l , h ) NEW_LINE mx = max ( arr , l , h ) NEW_LINE if ( 2 * mn > mx ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( min ( minRemovals ( arr , l + 1 , h ) , minRemovals ( arr , l , h - 1 ) ) + 1 ) NEW_LINE DEDENT arr = [ 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemovals ( arr , 0 , n - 1 ) ) NEW_LINE
def numberOfPaths ( m , n ) : NEW_LINE INDENT count = [ [ 0 for x in range ( n ) ] for y in range ( m ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT count [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT count [ 0 ] [ j ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT count [ i ] [ j ] = count [ i - 1 ] [ j ] + count [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return count [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT m = 3 NEW_LINE n = 3 NEW_LINE print ( numberOfPaths ( m , n ) ) NEW_LINE
def maxProd ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT max_val = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT max_val = max ( max_val , max ( i * ( n - i ) , maxProd ( n - i ) * i ) ) NEW_LINE DEDENT return max_val ; NEW_LINE DEDENT print ( " Maximum ▁ Product ▁ is ▁ " , maxProd ( 10 ) ) ; NEW_LINE
def carAssembly ( a , t , e , x ) : NEW_LINE INDENT NUM_STATION = len ( a [ 0 ] ) NEW_LINE T1 = [ 0 for i in range ( NUM_STATION ) ] NEW_LINE T2 = [ 0 for i in range ( NUM_STATION ) ] NEW_LINE DEDENT T1 [ 0 ] = e [ 0 ] + a [ 0 ] [ 0 ] NEW_LINE T2 [ 0 ] = e [ 1 ] + a [ 1 ] [ 0 ] NEW_LINE INDENT for i in range ( 1 , NUM_STATION ) : NEW_LINE INDENT T1 [ i ] = min ( T1 [ i - 1 ] + a [ 0 ] [ i ] , T2 [ i - 1 ] + t [ 1 ] [ i ] + a [ 0 ] [ i ] ) NEW_LINE T2 [ i ] = min ( T2 [ i - 1 ] + a [ 1 ] [ i ] , T1 [ i - 1 ] + t [ 0 ] [ i ] + a [ 1 ] [ i ] ) NEW_LINE DEDENT return min ( T1 [ NUM_STATION - 1 ] + x [ 0 ] , T2 [ NUM_STATION - 1 ] + x [ 1 ] ) NEW_LINE DEDENT a = [ [ 4 , 5 , 3 , 2 ] , [ 2 , 10 , 1 , 4 ] ] NEW_LINE t = [ [ 0 , 7 , 4 , 5 ] , [ 0 , 9 , 2 , 8 ] ] NEW_LINE e = [ 10 , 12 ] NEW_LINE x = [ 18 , 7 ] NEW_LINE print ( carAssembly ( a , t , e , x ) ) NEW_LINE
def LCSubStr ( X , Y , m , n ) : NEW_LINE INDENT LCSuff = [ [ 0 for k in range ( n + 1 ) ] for l in range ( m + 1 ) ] NEW_LINE result = 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT LCSuff [ i ] [ j ] = LCSuff [ i - 1 ] [ j - 1 ] + 1 NEW_LINE result = max ( result , LCSuff [ i ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT LCSuff [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT X = ' OldSite : GeeksforGeeks . org ' NEW_LINE Y = ' NewSite : GeeksQuiz . com ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( ' Length ▁ of ▁ Longest ▁ Common ▁ Substring ▁ is ' , LCSubStr ( X , Y , m , n ) ) NEW_LINE
def maxCrossingSum ( arr , l , m , h ) : NEW_LINE INDENT sm = 0 NEW_LINE left_sum = - 10000 NEW_LINE for i in range ( m , l - 1 , - 1 ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE if ( sm > left_sum ) : NEW_LINE INDENT left_sum = sm NEW_LINE DEDENT DEDENT sm = 0 NEW_LINE right_sum = - 1000 NEW_LINE for i in range ( m + 1 , h + 1 ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE if ( sm > right_sum ) : NEW_LINE INDENT right_sum = sm NEW_LINE DEDENT DEDENT return max ( left_sum + right_sum , left_sum , right_sum ) NEW_LINE DEDENT def maxSubArraySum ( arr , l , h ) : NEW_LINE INDENT if ( l == h ) : NEW_LINE INDENT return arr [ l ] NEW_LINE DEDENT m = ( l + h ) // 2 NEW_LINE return max ( maxSubArraySum ( arr , l , m ) , maxSubArraySum ( arr , m + 1 , h ) , maxCrossingSum ( arr , l , m , h ) ) NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE max_sum = maxSubArraySum ( arr , 0 , n - 1 ) NEW_LINE print ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " , max_sum ) NEW_LINE
def findWater ( i , j , X ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT print ( " Incorrect ▁ Input " ) ; NEW_LINE return ; NEW_LINE DEDENT glass = [ 0 ] * int ( i * ( i + 1 ) / 2 ) ; NEW_LINE index = 0 ; NEW_LINE glass [ index ] = X ; NEW_LINE for row in range ( 1 , i ) : NEW_LINE INDENT for col in range ( 1 , row + 1 ) : NEW_LINE INDENT X = glass [ index ] ; NEW_LINE glass [ index ] = 1.0 if ( X >= 1.0 ) else X ; NEW_LINE X = ( X - 1 ) if ( X >= 1.0 ) else 0.0 ; NEW_LINE glass [ index + row ] += ( X / 2 ) ; NEW_LINE glass [ index + row + 1 ] += ( X / 2 ) ; NEW_LINE index += 1 ; NEW_LINE DEDENT DEDENT return glass [ int ( i * ( i - 1 ) / 2 + j - 1 ) ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT i = 2 ; NEW_LINE j = 2 ; NEW_LINE X = 2.0 ; NEW_LINE res = repr ( findWater ( i , j , X ) ) ; NEW_LINE print ( " Amount ▁ of ▁ water ▁ in ▁ jth ▁ glass ▁ of ▁ ith ▁ row ▁ is : " , res . ljust ( 8 , '0' ) ) ; NEW_LINE DEDENT
def minPalPartion ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE C = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE P = [ [ False for i in range ( n ) ] for i in range ( n ) ] NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE L = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True ; NEW_LINE C [ i ] [ i ] = 0 ; NEW_LINE DEDENT for L in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE if L == 2 : NEW_LINE INDENT P [ i ] [ j ] = ( str [ i ] == str [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT P [ i ] [ j ] = ( ( str [ i ] == str [ j ] ) and P [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT if P [ i ] [ j ] == True : NEW_LINE INDENT C [ i ] [ j ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = 100000000 NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT C [ i ] [ j ] = min ( C [ i ] [ j ] , C [ i ] [ k ] + C [ k + 1 ] [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return C [ 0 ] [ n - 1 ] NEW_LINE DEDENT str = " ababbbabbababa " NEW_LINE print ( ' Min ▁ cuts ▁ needed ▁ for ▁ Palindrome ▁ Partitioning ▁ is ' , minPalPartion ( str ) ) NEW_LINE
def doMatch ( A , B ) : NEW_LINE INDENT for i in range ( len ( A ) ) : NEW_LINE INDENT if A [ i ] != ' * ' and B [ i ] != ' * ' : NEW_LINE INDENT if A [ i ] != B [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = " gee * sforgeeks " NEW_LINE B = " geeksforgeeks " NEW_LINE print ( int ( doMatch ( A , B ) ) ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( N + N * ( N - 1 ) ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def factorial ( N ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) // 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def update ( arr , l , r , val ) : NEW_LINE INDENT arr [ l ] += val NEW_LINE if r + 1 < len ( arr ) : NEW_LINE INDENT arr [ r + 1 ] -= val NEW_LINE DEDENT DEDENT def getElement ( arr , i ) : NEW_LINE INDENT res = 0 NEW_LINE for j in range ( i + 1 ) : NEW_LINE INDENT res += arr [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 0 , 0 , 0 , 0 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE l = 2 NEW_LINE r = 4 NEW_LINE val = 2 NEW_LINE update ( arr , l , r , val ) NEW_LINE index = 4 NEW_LINE print ( " Element ▁ at ▁ index " , index , " is " , getElement ( arr , index ) ) NEW_LINE l = 0 NEW_LINE r = 3 NEW_LINE val = 4 NEW_LINE update ( arr , l , r , val ) NEW_LINE index = 3 NEW_LINE print ( " Element ▁ at ▁ index " , index , " is " , getElement ( arr , index ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return n * factorial ( n - 1 ) ; NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) / ( factorial ( n - r ) * factorial ( r ) ) ) ; NEW_LINE DEDENT def NumberOfWays ( n , x , y ) : NEW_LINE INDENT return ( nCr ( 2 * n - x - y , n - x ) * factorial ( n ) * factorial ( n ) ) ; NEW_LINE DEDENT n , x , y = 5 , 4 , 2 ; NEW_LINE print ( int ( NumberOfWays ( n , x , y ) ) ) ; NEW_LINE
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 == 1 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = min ( odd1 , odd2 ) + min ( even1 , even2 ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def getValueOfF ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT cnt = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n /= 2 NEW_LINE DEDENT return 2 * cnt NEW_LINE DEDENT n = 20 NEW_LINE print ( getValueOfF ( n ) ) NEW_LINE
def A_mod_B ( N , a ) : NEW_LINE INDENT Len = len ( N ) NEW_LINE ans = 0 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT ans = ( ans * 10 + int ( N [ i ] ) ) % a NEW_LINE DEDENT return ans % a NEW_LINE DEDENT def findMod ( N ) : NEW_LINE INDENT mod = A_mod_B ( N , 4 ) NEW_LINE ans = ( 1 + pow ( 2 , mod ) + pow ( 3 , mod ) + pow ( 4 , mod ) ) NEW_LINE return ans % 5 NEW_LINE DEDENT N = "4" NEW_LINE print ( findMod ( N ) ) NEW_LINE
def printElements ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 1 , 5 , 4 , 9 , 8 , 7 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printElements ( arr , n ) NEW_LINE DEDENT
/ * Python program of above approach * / NEW_LINE def exponent ( A , B ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponent ( A , B / 2 ) ; NEW_LINE y = ( y * y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT y = A ; NEW_LINE y = ( y * exponent ( A , B - 1 ) ) ; NEW_LINE DEDENT return y ; NEW_LINE DEDENT def sum ( k , n ) : NEW_LINE INDENT sum = exponent ( k , n + 1 ) - exponent ( k - 1 , n + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( sum ( K , n ) ) ; NEW_LINE
from math import sqrt NEW_LINE def isPrime ( x ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( x ) ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT def minimumCost ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( n % 2 == 1 and isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT return 3 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 ; NEW_LINE print ( minimumCost ( n ) ) ; NEW_LINE DEDENT
def wastedWater ( V , M , N ) : NEW_LINE INDENT amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT V = 700 NEW_LINE M = 10 NEW_LINE N = 3 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE V = 1000 NEW_LINE M = 100 NEW_LINE N = 50 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE
from math import ceil NEW_LINE def nDigitPerfectCubes ( n ) : NEW_LINE INDENT print ( pow ( ceil ( ( pow ( 10 , ( n - 1 ) ) ) ** ( 1 / 3 ) ) , 3 ) , end = " ▁ " ) NEW_LINE print ( pow ( ceil ( ( pow ( 10 , ( n ) ) ) ** ( 1 / 3 ) ) - 1 , 3 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE nDigitPerfectCubes ( n ) NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT return n // 2520 NEW_LINE DEDENT n = 3000 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE
MAX = 100001 ; NEW_LINE prefix = [ 0 ] * MAX ; NEW_LINE def sieve_modified ( ) : NEW_LINE INDENT for i in range ( 1 , MAX , 2 ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT prefix [ j ] += i ; NEW_LINE DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] ; NEW_LINE DEDENT DEDENT def sumOddFactors ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] - prefix [ L - 1 ] ) ; NEW_LINE DEDENT sieve_modified ( ) ; NEW_LINE l = 6 ; NEW_LINE r = 10 ; NEW_LINE print ( sumOddFactors ( l , r ) ) ; NEW_LINE
n = 3 NEW_LINE def preComputeXor ( arr , prefix_xor ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT prefix_xor [ i ] [ j ] = arr [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT prefix_xor [ i ] [ j ] = ( prefix_xor [ i ] [ j - 1 ] ^ arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT prefix_xor [ j ] [ i ] = ( prefix_xor [ j - 1 ] [ i ] ^ prefix_xor [ j ] [ i ] ) NEW_LINE DEDENT DEDENT DEDENT def ansQuerie ( prefix_xor , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT xor_1 , xor_2 , xor_3 = 0 , 0 , 0 NEW_LINE if ( x1 != 0 ) : NEW_LINE INDENT xor_1 = prefix_xor [ x1 - 1 ] [ y2 ] NEW_LINE DEDENT if ( y1 != 0 ) : NEW_LINE INDENT xor_2 = prefix_xor [ x2 ] [ y1 - 1 ] NEW_LINE DEDENT if ( x1 != 0 and y1 != 0 ) : NEW_LINE INDENT xor_3 = prefix_xor [ x1 - 1 ] [ y1 - 1 ] NEW_LINE DEDENT return ( ( prefix_xor [ x2 ] [ y2 ] ^ xor_1 ) ^ ( xor_2 ^ xor_3 ) ) NEW_LINE DEDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE prefix_xor = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE preComputeXor ( arr , prefix_xor ) NEW_LINE print ( ansQuerie ( prefix_xor , 1 , 1 , 2 , 2 ) ) NEW_LINE print ( ansQuerie ( prefix_xor , 1 , 2 , 2 , 2 ) ) NEW_LINE
import math NEW_LINE def isDigitSumOne ( nm ) : NEW_LINE INDENT if ( nm % 9 == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def printValidNums ( n ) : NEW_LINE INDENT cbrt_n = math . ceil ( n ** ( 1. / 3. ) ) NEW_LINE for i in range ( 1 , cbrt_n + 1 ) : NEW_LINE INDENT cube = i * i * i NEW_LINE if ( cube >= 1 and cube <= n and isDigitSumOne ( cube ) ) : NEW_LINE INDENT print ( cube , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 1000 NEW_LINE printValidNums ( n ) NEW_LINE
def countRhombi ( h , w ) : NEW_LINE INDENT ct = 0 ; NEW_LINE for i in range ( 2 , h + 1 , 2 ) : NEW_LINE INDENT for j in range ( 2 , w + 1 , 2 ) : NEW_LINE INDENT ct += ( h - i + 1 ) * ( w - j + 1 ) NEW_LINE DEDENT DEDENT return ct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT h = 2 NEW_LINE w = 2 NEW_LINE print ( countRhombi ( h , w ) ) NEW_LINE DEDENT
def calculateArea ( x , y ) : NEW_LINE INDENT pi = 3.1415926536 NEW_LINE arx = pi * x * x NEW_LINE ary = pi * y * y NEW_LINE return arx - ary NEW_LINE DEDENT x = 2 NEW_LINE y = 1 NEW_LINE print ( calculateArea ( x , y ) ) NEW_LINE
from math import gcd NEW_LINE def getWinner ( arr , n ) : NEW_LINE INDENT __gcd = arr [ 0 ] ; NEW_LINE maxEle = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT __gcd = gcd ( __gcd , arr [ i ] ) ; NEW_LINE maxEle = max ( maxEle , arr [ i ] ) ; NEW_LINE DEDENT totalMoves = ( maxEle / __gcd ) - n ; NEW_LINE if ( totalMoves % 2 == 1 ) : NEW_LINE INDENT return ' A ' ; NEW_LINE DEDENT return ' B ' ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 6 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( getWinner ( arr , n ) ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT num = ( ( n // 2 ) + 1 ) NEW_LINE Max = n % num NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT val = ( ( n % i ) % j ) % n NEW_LINE if ( val == Max ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 5 NEW_LINE print ( countPairs ( n ) ) NEW_LINE
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 NEW_LINE if ( temp % k == 0 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT n /= 10 ; NEW_LINE DEDENT return " NO " NEW_LINE DEDENT n = 9876543 NEW_LINE print ( isDivisible ( n ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ is " , round ( sum ( n ) , 6 ) ) NEW_LINE
from math import sqrt NEW_LINE N = 100005 NEW_LINE def ABUNDANT ( ) : NEW_LINE INDENT v = set ( ) ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT sum = 1 NEW_LINE for j in range ( 2 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT sum += j NEW_LINE DEDENT if ( i / j != j ) : NEW_LINE INDENT sum += i // j NEW_LINE DEDENT DEDENT if ( sum > i ) : NEW_LINE INDENT v . add ( i ) NEW_LINE DEDENT DEDENT return v NEW_LINE DEDENT def SumOfAbundant ( n ) : NEW_LINE INDENT v = ABUNDANT ( ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( list ( v ) . count ( i ) and list ( v ) . count ( n - i ) ) : NEW_LINE INDENT print ( i , " ▁ " , n - i ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 24 NEW_LINE SumOfAbundant ( n ) NEW_LINE DEDENT
from math import pow NEW_LINE def nthTermOfTheSeries ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT nthTerm = pow ( n - 1 , 2 ) + n NEW_LINE DEDENT else : NEW_LINE INDENT nthTerm = pow ( n + 1 , 2 ) + n NEW_LINE DEDENT return nthTerm NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 12 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 102 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 999 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE n = 9999 NEW_LINE print ( int ( nthTermOfTheSeries ( n ) ) ) NEW_LINE DEDENT
def CPwithProfit ( sellingPrice , profit ) : NEW_LINE INDENT costPrice = ( ( sellingPrice * 100.0 ) / ( 100 + profit ) ) NEW_LINE return costPrice NEW_LINE DEDENT def CPwithLoss ( sellingPrice , loss ) : NEW_LINE INDENT costPrice = ( ( sellingPrice * 100.0 ) / ( 100 - loss ) ) NEW_LINE return costPrice NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT SP = 1020 NEW_LINE profit = 20 NEW_LINE print ( " Cost ▁ Price ▁ = " , CPwithProfit ( SP , profit ) ) NEW_LINE SP = 900 NEW_LINE loss = 10 NEW_LINE print ( " Cost ▁ Price ▁ = " , CPwithLoss ( SP , loss ) ) NEW_LINE SP = 42039 NEW_LINE profit = 8 NEW_LINE print ( " Cost ▁ Price ▁ = " , int ( CPwithProfit ( SP , profit ) ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isNonHypotenuse ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( i - 1 ) % 4 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT DEDENT if ( n > 2 and ( n - 1 ) % 4 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def test ( n ) : NEW_LINE INDENT print ( " Testing ▁ for " , n , " : " , end = " ▁ " ) NEW_LINE if ( isNonHypotenuse ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 NEW_LINE test ( n ) NEW_LINE n = 10 NEW_LINE test ( n ) NEW_LINE DEDENT
from math import log2 NEW_LINE def obtain_str ( n ) : NEW_LINE INDENT length = int ( log2 ( n + 1 ) ) NEW_LINE rel_ind = n + 1 - pow ( 2 , length ) NEW_LINE i = 0 NEW_LINE string = " " NEW_LINE for i in range ( length ) : NEW_LINE INDENT string += ' a ' NEW_LINE DEDENT i = 0 NEW_LINE string_list = list ( string ) NEW_LINE while ( rel_ind > 0 ) : NEW_LINE INDENT if ( rel_ind % 2 == 1 ) : NEW_LINE INDENT string_list [ i ] = ' b ' NEW_LINE DEDENT rel_ind //= 2 NEW_LINE i += 1 NEW_LINE DEDENT string_list . reverse ( ) NEW_LINE string = " " . join ( string_list ) NEW_LINE return string NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 NEW_LINE print ( obtain_str ( n ) ) NEW_LINE DEDENT
def Nthterm ( n ) : NEW_LINE INDENT numerator = n ** 2 - 1 NEW_LINE denomenator = 2 * n - 3 NEW_LINE print ( numerator , " / " , denomenator ) NEW_LINE DEDENT n = 3 NEW_LINE Nthterm ( n ) NEW_LINE
def getSum ( arr , p ) : NEW_LINE INDENT return len ( arr ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 6 , 8 ] NEW_LINE p = 7 NEW_LINE print ( getSum ( arr , p ) ) NEW_LINE DEDENT
def SquareCube ( N ) : NEW_LINE INDENT cnt , i = 0 , 1 NEW_LINE while ( i ** 6 <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT N = 100000 NEW_LINE print ( SquareCube ( N ) ) NEW_LINE
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( d <= n ) : NEW_LINE INDENT sum += d NEW_LINE d += 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 30 NEW_LINE d = 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE
MOD = 1000000007 NEW_LINE def Sum ( N ) : NEW_LINE INDENT val = N * ( N + 1 ) NEW_LINE val = val % MOD NEW_LINE return val NEW_LINE DEDENT def sumX ( N , M , K ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT N = int ( Sum ( K + N ) ) NEW_LINE DEDENT N = N % MOD NEW_LINE return N NEW_LINE DEDENT / * Driver code * / NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , M , K = 1 , 2 , 3 NEW_LINE print ( sumX ( N , M , K ) ) NEW_LINE DEDENT
def Log2n ( n ) : NEW_LINE INDENT return 1 + Log2n ( n / 2 ) if ( n > 1 ) else 0 NEW_LINE DEDENT n = 32 NEW_LINE print ( Log2n ( n ) ) NEW_LINE
def checkIsHP ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT rec = [ ] NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT a = 1 / arr [ i ] NEW_LINE rec . append ( a ) NEW_LINE DEDENT return ( rec ) NEW_LINE rec . sort ( ) NEW_LINE d = rec [ 1 ] - rec [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( rec [ i ] - rec [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 / 5 , 1 / 10 , 1 / 15 , 1 / 20 , 1 / 25 ] NEW_LINE if ( checkIsHP ( arr ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printAMeans ( A , B , N ) : NEW_LINE INDENT d = ( B - A ) / ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( int ( A + i * d ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT A = 20 ; B = 32 ; N = 5 NEW_LINE printAMeans ( A , B , N ) NEW_LINE
import math NEW_LINE def primeFactors ( n ) : NEW_LINE INDENT while n % 2 == 0 : NEW_LINE INDENT print 2 , NEW_LINE n = n / 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT print i , NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT print n NEW_LINE DEDENT DEDENT n = 315 NEW_LINE primeFactors ( n ) NEW_LINE
from math import gcd NEW_LINE def startingPoint ( Length , Speed1 , Speed2 ) : NEW_LINE INDENT result1 = 0 NEW_LINE result2 = 0 NEW_LINE time1 = Length // Speed1 NEW_LINE time2 = Length // Speed2 NEW_LINE result1 = gcd ( time1 , time2 ) NEW_LINE result2 = time1 * time2 // ( result1 ) NEW_LINE return result2 NEW_LINE DEDENT def firstTime ( Length , Speed1 , Speed2 ) : NEW_LINE INDENT result = 0 NEW_LINE relativeSpeed = abs ( Speed1 - Speed2 ) NEW_LINE result = Length / relativeSpeed NEW_LINE return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 30 NEW_LINE S1 = 5 NEW_LINE S2 = 2 NEW_LINE first_Time = firstTime ( L , S1 , S2 ) NEW_LINE starting_Point = startingPoint ( L , S1 , S2 ) NEW_LINE print ( " Met ▁ first ▁ time ▁ after " , first_Time , " hrs " ) NEW_LINE print ( " Met ▁ at ▁ starting ▁ point ▁ after " , starting_Point , " hrs " ) NEW_LINE DEDENT
def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] == prod / arr [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def sum ( a , b ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , min ( a , b ) ) : NEW_LINE INDENT if ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT A = 10 NEW_LINE B = 15 NEW_LINE print ( " Sum ▁ = " , sum ( A , B ) ) NEW_LINE
import math NEW_LINE def minimumCuts ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE gcd = a [ 1 ] - a [ 0 ] NEW_LINE s = gcd NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT gcd = math . gcd ( gcd , a [ i ] - a [ i - 1 ] ) NEW_LINE s += a [ i ] - a [ i - 1 ] NEW_LINE DEDENT if ( 360 - s > 0 ) : NEW_LINE INDENT gcd = math . gcd ( gcd , 360 - s ) NEW_LINE DEDENT return ( 360 // gcd ) - n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 30 , 60 , 180 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumCuts ( arr , n ) ) NEW_LINE DEDENT
def SellingPrice ( CP , PP ) : NEW_LINE INDENT Pdecimal = 1 + ( PP / 100 ) NEW_LINE res = Pdecimal * CP NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT C = 720 NEW_LINE P = 13 NEW_LINE print ( SellingPrice ( C , P ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def compositeProduct ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = True NEW_LINE prime [ 1 ] = True NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( max_val ) ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] == False : NEW_LINE INDENT product *= arr [ i ] NEW_LINE DEDENT DEDENT return product NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( compositeProduct ( arr , n ) ) NEW_LINE
def sum_odd ( n ) : NEW_LINE INDENT sums = 0 NEW_LINE pos = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( pos % 2 == 1 ) : NEW_LINE INDENT sums += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE pos += 1 NEW_LINE DEDENT return sums NEW_LINE DEDENT def check_prime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 223 NEW_LINE sums = sum_odd ( n ) NEW_LINE if ( check_prime ( sums ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def findAmount ( X , W , Y ) : NEW_LINE INDENT return ( X * ( Y - W ) / ( 100 - Y ) ) NEW_LINE DEDENT X = 100 NEW_LINE W = 50 ; Y = 60 NEW_LINE print ( " Water ▁ to ▁ be ▁ added " , findAmount ( X , W , Y ) ) NEW_LINE
def reverseNum ( x ) : NEW_LINE INDENT s = str ( x ) NEW_LINE s = s [ : : - 1 ] NEW_LINE return int ( s ) NEW_LINE DEDENT def isMysteryNumber ( n ) : NEW_LINE INDENT for i in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT j = reverseNum ( i ) NEW_LINE if i + j == n : NEW_LINE INDENT print ( i , j ) NEW_LINE return True NEW_LINE DEDENT DEDENT print ( " Not ▁ a ▁ Mystery ▁ Number " ) NEW_LINE return False NEW_LINE DEDENT n = 121 NEW_LINE isMysteryNumber ( n ) NEW_LINE
def ReplaceElements ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = prod // arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def Check_is_possible ( l , r , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( i % k == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return ( count > 1 ) ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 12 ; NEW_LINE k = 5 ; NEW_LINE if ( Check_is_possible ( l , r , k ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def sum ( N ) : NEW_LINE INDENT S1 = ( ( N // 2 ) ) * ( 2 * 2 + ( N // 2 - 1 ) * 2 ) // 2 NEW_LINE S2 = ( ( N // 7 ) ) * ( 2 * 7 + ( N // 7 - 1 ) * 7 ) // 2 NEW_LINE S3 = ( ( N // 14 ) ) * ( 2 * 14 + ( N // 14 - 1 ) * 14 ) // 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE print ( sum ( N ) ) NEW_LINE DEDENT
def fastPow ( N , K ) : NEW_LINE INDENT if ( K == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT temp = fastPow ( N , int ( K / 2 ) ) ; NEW_LINE if ( K % 2 == 0 ) : NEW_LINE INDENT return temp * temp ; NEW_LINE DEDENT else : NEW_LINE INDENT return N * temp * temp ; NEW_LINE DEDENT DEDENT def countWays ( N , K ) : NEW_LINE INDENT return K * fastPow ( K - 1 , N - 1 ) ; NEW_LINE DEDENT N = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( countWays ( N , K ) ) ; NEW_LINE
def sumNth ( A , B , m , n ) : NEW_LINE INDENT res = 0 ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + A [ i ] ; NEW_LINE DEDENT DEDENT elif ( n == 2 ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT res = res + B [ i ] * m ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = [ 0 ] * n ; NEW_LINE f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT res = ( res + ( m * ( B [ i ] * f [ n - 1 ] ) ) + ( m * ( A [ i ] * f [ n - 2 ] ) ) ) ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT A = [ 1 , 2 , 3 ] ; NEW_LINE B = [ 4 , 5 , 6 ] ; NEW_LINE n = 3 ; NEW_LINE m = len ( A ) ; NEW_LINE print ( sumNth ( A , B , m , n ) ) ; NEW_LINE
import math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE AC = a NEW_LINE CE = 2 * a NEW_LINE shortestDistace = math . sqrt ( AC * AC + CE * CE ) NEW_LINE print ( shortestDistace ) NEW_LINE DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT result = - ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT result = ( n * ( n + 1 ) ) // 2 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( sum_of_series ( n ) ) NEW_LINE n = 10 NEW_LINE print ( sum_of_series ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) + 1 ) , 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isCousinPrime ( n1 , n2 ) : NEW_LINE INDENT if ( not ( abs ( n1 - n2 ) == 4 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return ( isPrime ( n1 ) and isPrime ( n2 ) ) NEW_LINE DEDENT DEDENT n1 = 7 NEW_LINE n2 = 11 NEW_LINE if ( isCousinPrime ( n1 , n2 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def isThabitNumber ( n ) : NEW_LINE INDENT n = n + 1 ; NEW_LINE if ( n % 3 == 0 ) : NEW_LINE INDENT n = n // 3 ; NEW_LINE DEDENT else : NEW_LINE return False NEW_LINE if ( isPowerOfTwo ( n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 47 NEW_LINE if ( isThabitNumber ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
import sys NEW_LINE def findMinEqualSums ( a , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE min = sys . maxsize NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT sum1 += a [ i ] NEW_LINE sum2 = sum - sum1 NEW_LINE if ( abs ( sum1 - sum2 ) < min ) : NEW_LINE INDENT min = abs ( sum1 - sum2 ) NEW_LINE DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 2 , 1 , 5 , 7 , 8 ] NEW_LINE N = len ( a ) NEW_LINE print ( findMinEqualSums ( a , N ) ) NEW_LINE DEDENT
import math as ma NEW_LINE def CountDigits ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT sum += ma . log ( i , 10 ) NEW_LINE DEDENT sum *= n NEW_LINE return ma . ceil ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( CountDigits ( N ) ) NEW_LINE DEDENT
MAX = 200006 NEW_LINE CONS = 32766 NEW_LINE def calc ( a , b , lr , q , n ) : NEW_LINE INDENT cc = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT a [ i + 1 ] += a [ i ] NEW_LINE b [ i + 1 ] += b [ i ] NEW_LINE DEDENT while ( q > 0 ) : NEW_LINE INDENT l = lr [ cc ] NEW_LINE cc += 1 NEW_LINE r = lr [ cc ] NEW_LINE cc += 1 NEW_LINE l -= 2 NEW_LINE r -= 1 NEW_LINE suma = a [ r ] NEW_LINE sumb = b [ r ] NEW_LINE if ( l >= 0 ) : NEW_LINE INDENT suma -= a [ l ] NEW_LINE sumb -= b [ l ] NEW_LINE DEDENT M = max ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) NEW_LINE M = max ( M , max ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) NEW_LINE m = min ( CONS * suma + CONS * sumb , - CONS * suma - CONS * sumb ) NEW_LINE m = min ( m , min ( CONS * suma - CONS * sumb , - CONS * suma + CONS * sumb ) ) NEW_LINE print ( M - m ) NEW_LINE q -= 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE q = 2 NEW_LINE a = [ 0 , 7 , 3 , 4 , 5 ] NEW_LINE b = [ 0 , 3 , 1 , 2 , 3 ] NEW_LINE lr = [ 0 ] * ( q * 2 ) NEW_LINE lr [ 0 ] = 1 NEW_LINE lr [ 1 ] = 1 NEW_LINE lr [ 2 ] = 1 NEW_LINE lr [ 3 ] = 3 NEW_LINE calc ( a , b , lr , q , n ) NEW_LINE DEDENT
def NthTerm ( N ) : NEW_LINE INDENT x = ( 3 * N * N ) % 1000000009 NEW_LINE return ( ( x - N + 1000000009 ) % 1000000009 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( NthTerm ( N ) ) NEW_LINE DEDENT
power = [ 0 ] * 31 NEW_LINE pre = [ 0 ] * 31 NEW_LINE def PowerOfTwo ( ) : NEW_LINE INDENT x = 1 NEW_LINE for i in range ( 31 ) : NEW_LINE INDENT power [ i ] = x NEW_LINE x *= 2 NEW_LINE DEDENT pre [ 0 ] = 1 NEW_LINE for i in range ( 1 , 31 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + power [ i ] NEW_LINE DEDENT DEDENT def Sum ( n ) : NEW_LINE INDENT ans = n * ( n + 1 ) // 2 NEW_LINE for i in range ( 31 ) : NEW_LINE INDENT if ( power [ i ] > n ) : NEW_LINE INDENT ans -= 2 * pre [ i - 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT PowerOfTwo ( ) NEW_LINE n = 4 NEW_LINE print ( Sum ( n ) ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 17 NEW_LINE if ( isPrime ( n ) and ( n % 16 == 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def findNumber ( n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE x = i NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE while ( x ) : NEW_LINE INDENT count [ x % 10 ] += 1 NEW_LINE x = int ( x / 10 ) NEW_LINE count1 += 1 NEW_LINE DEDENT for j in range ( 0 , 10 , 1 ) : NEW_LINE INDENT if ( count [ j ] == 1 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT DEDENT if ( count1 == count2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8490 NEW_LINE print ( findNumber ( n ) ) NEW_LINE DEDENT
from math import * NEW_LINE def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] , isPrime [ 1 ] = False , False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT for p in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if isPrime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE isPrime = [ False ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT x = int ( n / i ) NEW_LINE if ( isPrime [ i ] & isPrime [ x ] and x != i and x * i == n ) : NEW_LINE INDENT print ( i , x ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if not flag : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ found " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 39 ; NEW_LINE findPrimePair ( n ) NEW_LINE DEDENT
import math NEW_LINE def solveProportion ( a , b1 , b2 , c ) : NEW_LINE INDENT A = a * b2 NEW_LINE B = b1 * b2 NEW_LINE C = b1 * c NEW_LINE gcd1 = math . gcd ( math . gcd ( A , B ) , C ) NEW_LINE print ( str ( A // gcd1 ) + " : " + str ( B // gcd1 ) + " : " + str ( C // gcd1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE b1 = 4 NEW_LINE b2 = 8 NEW_LINE c = 9 NEW_LINE solveProportion ( a , b1 , b2 , c ) NEW_LINE DEDENT
def countDivisors ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 and i % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 12 , 3 NEW_LINE print ( countDivisors ( n , k ) ) NEW_LINE DEDENT
import math NEW_LINE pi = math . pi NEW_LINE def volume ( r , h ) : NEW_LINE INDENT return ( 1 / 3 ) * pi * r * r * h NEW_LINE DEDENT def surfacearea ( r , s ) : NEW_LINE INDENT return pi * r * s + pi * r * r NEW_LINE DEDENT radius = float ( 5 ) NEW_LINE height = float ( 12 ) NEW_LINE slat_height = float ( 13 ) NEW_LINE print ( " Volume ▁ Of ▁ Cone ▁ : ▁ " , volume ( radius , height ) ) NEW_LINE print ( " Surface ▁ Area ▁ Of ▁ Cone ▁ : ▁ " , surfacearea ( radius , slat_height ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return int ( 6 * pow ( n , 2 ) - 4 * n - 2 ) NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
from math import * NEW_LINE def nthTerm ( n ) : NEW_LINE INDENT return pow ( n , 2 ) + 2 * n + 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT ans = ( n * ( n - 1 ) ) / 2 ; NEW_LINE return ans NEW_LINE DEDENT n = 5 NEW_LINE print ( int ( sum ( n ) ) ) NEW_LINE
def getNthTerm ( N ) : NEW_LINE INDENT return 4 * pow ( N , 2 ) - 3 * N + 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( getNthTerm ( N ) ) NEW_LINE DEDENT
MOD = 1000000007 NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def sumProd ( n , t ) : NEW_LINE INDENT dino = power ( t + 1 , MOD - 2 , MOD ) NEW_LINE ans = 1 NEW_LINE for i in range ( n + t + 1 , n , - 1 ) : NEW_LINE INDENT ans = ( ans % MOD * i % MOD ) % MOD NEW_LINE DEDENT tfact = 1 NEW_LINE for i in range ( 1 , t + 1 ) : NEW_LINE INDENT tfact = ( tfact * i ) % MOD NEW_LINE DEDENT ans = ans * dino - tfact + MOD NEW_LINE return ans % MOD NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , t = 3 , 2 NEW_LINE print ( sumProd ( n , t ) ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT return ( n * ( pow ( n , 2 ) + 3 * n + 5 ) ) / 3 NEW_LINE DEDENT n = 25 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE
mod = 1000000007 NEW_LINE def power ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res *= a NEW_LINE res %= mod NEW_LINE DEDENT b //= 2 NEW_LINE a *= a NEW_LINE a %= mod NEW_LINE DEDENT return res NEW_LINE DEDENT def minPlayer ( n , k ) : NEW_LINE INDENT num = ( ( power ( k , n ) - 1 ) + mod ) % mod NEW_LINE den = ( power ( k - 1 , mod - 2 ) + mod ) % mod NEW_LINE ans = ( ( ( num * den ) % mod ) * k ) % mod NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 3 , 3 NEW_LINE print ( minPlayer ( n , k ) ) NEW_LINE DEDENT
def sieveOfEratosthenes ( N , s ) : NEW_LINE INDENT prime = [ False ] * ( N + 1 ) NEW_LINE for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT s [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , N + 1 , 2 ) : NEW_LINE INDENT if prime [ i ] == False : NEW_LINE INDENT s [ i ] = i NEW_LINE for j in range ( i , ( N + 1 ) // i , 2 ) : NEW_LINE INDENT if prime [ i * j ] == False : NEW_LINE INDENT prime [ i * j ] = True NEW_LINE s [ i * j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def findSum ( N ) : NEW_LINE INDENT s = [ 0 ] * ( N + 1 ) NEW_LINE ans = 1 NEW_LINE sieveOfEratosthenes ( N , s ) NEW_LINE currFactor = s [ N ] NEW_LINE power = 1 NEW_LINE while N > 1 : NEW_LINE INDENT N //= s [ N ] NEW_LINE if currFactor == s [ N ] : NEW_LINE INDENT power += 1 NEW_LINE continue NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( power + 1 ) : NEW_LINE INDENT sum += pow ( currFactor , i ) NEW_LINE DEDENT ans *= sum NEW_LINE currFactor = s [ N ] NEW_LINE power = 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE print ( " Sum ▁ of ▁ the ▁ factors ▁ is ▁ : " , end = " ▁ " ) NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT multiple = [ 2 , 3 , 5 ] NEW_LINE count = 0 NEW_LINE mask = int ( pow ( 2 , 3 ) ) NEW_LINE for i in range ( 1 , mask ) : NEW_LINE INDENT prod = 1 NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT prod = prod * multiple [ j ] NEW_LINE DEDENT DEDENT if ( bin ( i ) . count ( '1' ) % 2 == 1 ) : NEW_LINE INDENT count = count + n // prod NEW_LINE DEDENT else : NEW_LINE INDENT count = count - n // prod NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( countMultiples ( n ) ) NEW_LINE DEDENT
def findN ( k ) : NEW_LINE ' NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT ans = 3 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT ans = 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT elif ( k % 4 == 0 ) : NEW_LINE INDENT ans = k NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT elif ( k % 4 == 3 ) : NEW_LINE INDENT ans = k - 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT k = 7 NEW_LINE res = findN ( k ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
def Circular ( n ) : NEW_LINE INDENT Result = 1 NEW_LINE while n > 0 : NEW_LINE INDENT Result = Result * n NEW_LINE n -= 1 NEW_LINE DEDENT return Result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( Circular ( n - 1 ) ) NEW_LINE DEDENT
def calTime ( arr , n ) : NEW_LINE INDENT work = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT work += 1 / arr [ i ] NEW_LINE DEDENT return 1 / work NEW_LINE DEDENT arr = [ 6.0 , 3.0 , 4.0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calTime ( arr , n ) , " Hours " ) NEW_LINE
from math import sqrt , floor NEW_LINE def printTwins ( low , high ) : NEW_LINE INDENT prime = [ True for i in range ( high + 1 ) ] NEW_LINE twin = False NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE k = floor ( sqrt ( high ) ) + 2 NEW_LINE for p in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , high + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT i = high NEW_LINE while ( i >= low ) : NEW_LINE INDENT if ( prime [ i ] and ( i - 2 >= low and prime [ i - 2 ] == True ) ) : NEW_LINE INDENT print ( " Largest ▁ twins ▁ in ▁ given ▁ range : ( " , ( i - 2 ) , " , " , ( i ) , " ) " ) NEW_LINE twin = True NEW_LINE break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( twin == False ) : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ exists " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT printTwins ( 10 , 100 ) NEW_LINE DEDENT
def prevComplement ( n , b ) : NEW_LINE INDENT maxNum , digits , num = 0 , 0 , n NEW_LINE while n > 1 : NEW_LINE INDENT digits += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT maxDigit = b - 1 NEW_LINE while digits : NEW_LINE INDENT maxNum = maxNum * 10 + maxDigit NEW_LINE digits -= 1 NEW_LINE DEDENT return maxNum - num NEW_LINE DEDENT def complement ( n , b ) : NEW_LINE INDENT return prevComplement ( n , b ) + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT / * Driver code * / NEW_LINE a = 2 NEW_LINE b = 4 NEW_LINE print ( gcd ( a , b ) ) NEW_LINE
def MaximumDivisors ( X , Y ) : NEW_LINE INDENT arr = [ 0 ] * ( Y - X + 1 ) NEW_LINE mx = 0 NEW_LINE cnt = 0 NEW_LINE i = 1 NEW_LINE while i * i <= Y : NEW_LINE INDENT sq = i * i NEW_LINE if ( ( X // i ) * i >= X ) : NEW_LINE INDENT first_divisible = ( X // i ) * i NEW_LINE DEDENT else : NEW_LINE INDENT first_divisible = ( X // i + 1 ) * i NEW_LINE DEDENT for j in range ( first_divisible , Y + 1 , i ) : NEW_LINE INDENT if j < sq : NEW_LINE INDENT continue NEW_LINE DEDENT elif j == sq : NEW_LINE INDENT arr [ j - X ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ j - X ] += 2 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( X , Y + 1 ) : NEW_LINE INDENT if arr [ i - X ] > mx : NEW_LINE INDENT cnt = 1 NEW_LINE mx = arr [ i - X ] NEW_LINE DEDENT elif arr [ i - X ] == mx : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 1 NEW_LINE Y = 10 NEW_LINE print ( MaximumDivisors ( X , Y ) ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while y > 0 : NEW_LINE INDENT if y & 1 : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def NearestElement ( A , D , P ) : NEW_LINE INDENT if A == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif D == 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT X = power ( D , P - 2 , P ) NEW_LINE return ( X * ( P - A ) ) % P NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A , D , P = 4 , 9 , 11 NEW_LINE A %= P NEW_LINE D %= P NEW_LINE print ( NearestElement ( A , D , P ) ) NEW_LINE DEDENT
def print_C ( p0 ) : NEW_LINE INDENT i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT flag = 1 ; NEW_LINE x = pow ( 2 , i ) ; NEW_LINE p1 = x * p0 + ( x - 1 ) ; NEW_LINE for k in range ( 2 , p1 ) : NEW_LINE INDENT if ( p1 % k == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT print ( p1 , end = " ▁ " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT p0 = 2 ; NEW_LINE print_C ( p0 ) ; NEW_LINE
def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N - 1 ) : NEW_LINE INDENT if ( ( A [ i ] & A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair = oddPair + 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT a = [ 5 , 1 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( findOddPair ( a , n ) ) NEW_LINE
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE sum = 1 << n ; NEW_LINE return ( sum - 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ all ▁ elements : " , calculateSum ( n ) ) NEW_LINE
import math NEW_LINE def Divide ( a , b ) : NEW_LINE INDENT dividend = a ; NEW_LINE divisor = b ; NEW_LINE sign = - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 ; NEW_LINE dividend = abs ( dividend ) ; NEW_LINE divisor = abs ( divisor ) ; NEW_LINE if ( divisor == 0 ) : NEW_LINE INDENT print ( " Cannot ▁ Divide ▁ by ▁ 0" ) ; NEW_LINE DEDENT if ( dividend == 0 ) : NEW_LINE INDENT print ( a , " / " , b , " is ▁ equal ▁ to ▁ : " , 0 ) ; NEW_LINE DEDENT if ( divisor == 1 ) : NEW_LINE INDENT print ( a , " / " , b , " is ▁ equal ▁ to ▁ : " , ( sign * dividend ) ) ; NEW_LINE DEDENT print ( a , " / " , b , " is ▁ equal ▁ to ▁ : " , math . floor ( sign * math . exp ( math . log ( dividend ) - math . log ( divisor ) ) ) ) ; NEW_LINE DEDENT a = 10 ; NEW_LINE b = 5 ; NEW_LINE Divide ( a , b ) ; NEW_LINE a = 49 ; NEW_LINE b = - 7 ; NEW_LINE Divide ( a , b ) ; NEW_LINE
def findNature ( a , b , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( a & 1 ) ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( b & 1 ) ; NEW_LINE DEDENT if ( ( a & 1 ) == 0 ) : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( n % 3 != 0 ) else False ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( b & 1 ) == 0 ) : NEW_LINE INDENT return True if ( ( n - 1 ) % 3 != 0 ) else False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True if ( ( n + 1 ) % 3 != 0 ) else False ; NEW_LINE DEDENT DEDENT DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE n = 3 ; NEW_LINE if ( findNature ( a , b , n ) == True ) : NEW_LINE INDENT print ( " Odd " , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " , end = " ▁ " ) ; NEW_LINE DEDENT
def checkEqual ( S ) : NEW_LINE INDENT for i in range ( len ( S ) ) : NEW_LINE INDENT if ( S [ i ] != '1' and S [ i ] != '0' and S [ i ] != '8' ) : NEW_LINE INDENT return " No " ; NEW_LINE DEDENT DEDENT start = 0 ; NEW_LINE end = len ( S ) - 1 ; NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( S [ start ] != S [ end ] ) : NEW_LINE INDENT return " No " ; NEW_LINE DEDENT start += 1 ; NEW_LINE end -= 1 ; NEW_LINE DEDENT return " Yes " ; NEW_LINE DEDENT S = "101" ; NEW_LINE print ( checkEqual ( S ) ) ; NEW_LINE
def Log2n ( n ) : NEW_LINE INDENT return ( 1 + Log2n ( n / 2 ) ) if ( n > 1 ) else 0 ; NEW_LINE DEDENT def isPowerOfd ( n , d ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT return ( count % ( Log2n ( d ) ) == 0 ) ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 64 ; NEW_LINE d = 8 ; NEW_LINE if ( isPowerOfd ( n , d ) ) : NEW_LINE INDENT print ( n , " is ▁ a ▁ power ▁ of " , d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is ▁ not ▁ a ▁ power ▁ of " , d ) ; NEW_LINE DEDENT
def octahedral_num ( n ) : NEW_LINE INDENT return n * ( 2 * n * n + 1 ) // 3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( n , " th ▁ Octahedral ▁ number : ▁ " , octahedral_num ( n ) ) NEW_LINE DEDENT
def centeredTetrahedralNumber ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 3 ) // 3 NEW_LINE DEDENT n = 6 NEW_LINE print ( centeredTetrahedralNumber ( n ) ) NEW_LINE
def swap ( a , b , c , d ) : NEW_LINE INDENT a = a + b NEW_LINE b = a - b NEW_LINE a = a - b NEW_LINE b = b + c NEW_LINE c = b - c NEW_LINE b = b - c NEW_LINE c = c + d NEW_LINE d = c - d NEW_LINE c = c - d NEW_LINE print ( " values ▁ after ▁ swapping ▁ are ▁ : ▁ " ) NEW_LINE print ( " a ▁ = ▁ " , a ) NEW_LINE print ( " b ▁ = ▁ " , b ) NEW_LINE print ( " c ▁ = ▁ " , c ) NEW_LINE print ( " d ▁ = ▁ " , d ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 3 NEW_LINE d = 4 NEW_LINE print ( " values ▁ before ▁ swapping ▁ are ▁ : ▁ " ) NEW_LINE print ( " a ▁ = ▁ " , a ) NEW_LINE print ( " b ▁ = ▁ " , b ) NEW_LINE print ( " c ▁ = ▁ " , c ) NEW_LINE print ( " d ▁ = ▁ " , d ) NEW_LINE print ( " " ) NEW_LINE swap ( a , b , c , d ) NEW_LINE
def seriessum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += i * ( i + 1 ) / 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( seriessum ( n ) ) NEW_LINE
def checkCentrosymmetricted ( n , m ) : NEW_LINE INDENT mid_row = 0 ; NEW_LINE if ( ( n & 1 ) > 0 ) : NEW_LINE INDENT mid_row = n / 2 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mid_row = n / 2 ; NEW_LINE DEDENT for i in range ( int ( mid_row ) ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 3 , 5 ] , [ 6 , 8 , 6 ] , [ 5 , 3 , 1 ] ] ; NEW_LINE if ( checkCentrosymmetricted ( n , m ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def Centered_Triangular_num ( n ) : NEW_LINE INDENT return ( 3 * n * n + 3 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( Centered_Triangular_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( Centered_Triangular_num ( n ) ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def k_Leaves ( n , k ) : NEW_LINE INDENT ans = ( ( binomialCoeff ( n , k ) * binomialCoeff ( n , k - 1 ) ) // n ) NEW_LINE print ( " Number ▁ of ▁ trees ▁ " , " having ▁ 4 ▁ edges ▁ and ▁ exactly ▁ 2 ▁ " , " leaves ▁ : ▁ " , ans ) NEW_LINE DEDENT def numberOfNodes ( n , d ) : NEW_LINE INDENT ans = binomialCoeff ( 2 * n - 1 - d , n - 1 ) NEW_LINE print ( " Number ▁ of ▁ Nodes ▁ " , " of ▁ degree ▁ 1 ▁ in ▁ a ▁ tree ▁ having ▁ 4 ▁ " , " edges ▁ : ▁ " , ans ) NEW_LINE DEDENT def rootDegreeR ( n , r ) : NEW_LINE INDENT ans = r * binomialCoeff ( 2 * n - 1 - r , n - 1 ) NEW_LINE ans = ans // n NEW_LINE print ( " Number ▁ of ▁ trees ▁ " , " having ▁ 4 ▁ edges ▁ where ▁ root ▁ has ▁ " , " degree ▁ 2 ▁ : ▁ " , ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k_Leaves ( 3 , 2 ) NEW_LINE numberOfNodes ( 3 , 1 ) NEW_LINE rootDegreeR ( 3 , 2 ) NEW_LINE DEDENT
def repUnitValue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 or n % 5 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT rem = 1 NEW_LINE power = 1 NEW_LINE k = 1 NEW_LINE while ( rem % n != 0 ) : NEW_LINE INDENT k += 1 NEW_LINE power = power * 10 % n NEW_LINE rem = ( rem + power ) % n NEW_LINE DEDENT return k NEW_LINE DEDENT n = 13 NEW_LINE print ( repUnitValue ( n ) ) NEW_LINE
def __gcd ( a , b ) : NEW_LINE INDENT return a if ( b == 0 ) else __gcd ( b , a % b ) ; NEW_LINE DEDENT def isSplittable ( n , m ) : NEW_LINE INDENT total_sum = ( int ) ( ( n * ( n + 1 ) ) / 2 ) ; NEW_LINE sum_s1 = int ( ( total_sum + m ) / 2 ) ; NEW_LINE sum_s2 = total_sum - sum_s1 ; NEW_LINE if ( total_sum < m ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( sum_s1 + sum_s2 == total_sum and sum_s1 - sum_s2 == m ) : NEW_LINE INDENT return ( __gcd ( sum_s1 , sum_s2 ) == 1 ) ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 5 ; NEW_LINE m = 7 ; NEW_LINE if ( isSplittable ( n , m ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def isPossibleToZero ( a , n ) : NEW_LINE INDENT num = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = num * 10 + a [ i ] ; NEW_LINE DEDENT return ( num % 11 == 0 ) ; NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 0 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( isPossibleToZero ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def isBlumInteger ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT if ( ( n % i == 0 ) and ( ( i - 3 ) % 4 ) == 0 ) : NEW_LINE INDENT q = int ( n / i ) NEW_LINE return ( q != i and prime [ q ] and ( q - 3 ) % 4 == 0 ) NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT n = 249 NEW_LINE if ( isBlumInteger ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def nCr ( n , r ) : NEW_LINE INDENT return ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE r = 3 NEW_LINE print ( int ( nCr ( n , r ) ) ) NEW_LINE
import math NEW_LINE def summingSeries ( n ) : NEW_LINE INDENT return math . pow ( n , 2 ) NEW_LINE DEDENT n = 100 NEW_LINE print ( " The ▁ sum ▁ of ▁ n ▁ term ▁ is : ▁ " , summingSeries ( n ) ) NEW_LINE
def find_sum_of_two_squares ( a , b ) : NEW_LINE INDENT ab = a * b NEW_LINE i = 0 ; NEW_LINE while ( i * i <= ab ) : NEW_LINE INDENT j = i NEW_LINE while ( i * i + j * j <= ab ) : NEW_LINE INDENT if ( i * i + j * j == ab ) : NEW_LINE INDENT print ( i , " ^ 2 ▁ + ▁ " , j , " ^ 2 ▁ = ▁ " , ab ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT a = 1 * 1 + 2 * 2 NEW_LINE b = 3 * 3 + 4 * 4 NEW_LINE print ( " Representation ▁ of ▁ a ▁ * ▁ b ▁ as ▁ sum " " ▁ of ▁ 2 ▁ squares : " ) NEW_LINE find_sum_of_two_squares ( a , b ) NEW_LINE
def tetrahedralNumber ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 NEW_LINE DEDENT def tetrahedralNumber ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 NEW_LINE DEDENT n = 5 NEW_LINE print ( tetrahedralNumber ( n ) ) NEW_LINE
def check_euler_four_square_identity ( a , b , ab ) : NEW_LINE INDENT s = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= ab ) : NEW_LINE INDENT s = i * i ; NEW_LINE j = i ; NEW_LINE while ( j * j <= ab ) : NEW_LINE INDENT s = j * j + i * i ; NEW_LINE k = j ; NEW_LINE while ( k * k <= ab ) : NEW_LINE INDENT s = k * k + j * j + i * i ; NEW_LINE l = k ; NEW_LINE while ( l * l <= ab ) : NEW_LINE INDENT s = l * l + k * k + j * j + i * i ; NEW_LINE if ( s == ab ) : NEW_LINE INDENT print ( " i ▁ = " , i ) ; NEW_LINE print ( " j ▁ = " , j ) ; NEW_LINE print ( " k ▁ = " , k ) ; NEW_LINE print ( " l ▁ = " , l ) ; NEW_LINE print ( " Product ▁ of ▁ " , a , " and " , b , end = " " ) ; NEW_LINE print ( " ▁ can ▁ be ▁ written ▁ as ▁ sum ▁ of " , " squares ▁ of ▁ i , ▁ j , ▁ k , ▁ l " ) ; NEW_LINE print ( ab , " = ▁ " , end = " " ) ; NEW_LINE print ( i , " * " , i , " + ▁ " , end = " " ) ; NEW_LINE print ( j , " * " , j , " + ▁ " , end = " " ) ; NEW_LINE print ( k , " * " , k , " + ▁ " , end = " " ) ; NEW_LINE print ( l , " * " , l ) ; NEW_LINE print ( " " ) ; NEW_LINE DEDENT l += 1 ; NEW_LINE DEDENT k += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT ab = a * b ; NEW_LINE check_euler_four_square_identity ( a , b , ab ) ; NEW_LINE
import math NEW_LINE def calculateDivisors ( A , B ) : NEW_LINE INDENT N = A - B NEW_LINE noOfDivisors = 0 NEW_LINE a = math . sqrt ( N ) NEW_LINE for i in range ( 1 , int ( a + 1 ) ) : NEW_LINE INDENT if ( ( N % i == 0 ) ) : NEW_LINE INDENT if ( i > B ) : NEW_LINE INDENT noOfDivisors += 1 NEW_LINE DEDENT if ( ( N / i ) != i and ( N / i ) > B ) : NEW_LINE INDENT noOfDivisors += 1 ; NEW_LINE DEDENT DEDENT DEDENT return noOfDivisors NEW_LINE DEDENT def numberOfPossibleWaysUtil ( A , B ) : NEW_LINE INDENT if ( A == B ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( A < B ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT noOfDivisors = 0 NEW_LINE noOfDivisors = calculateDivisors ; NEW_LINE return noOfDivisors NEW_LINE DEDENT def numberOfPossibleWays ( A , B ) : NEW_LINE INDENT noOfSolutions = numberOfPossibleWaysUtil ( A , B ) NEW_LINE if ( noOfSolutions == - 1 ) : NEW_LINE INDENT print ( " For ▁ A ▁ = ▁ " , A , " ▁ and ▁ B ▁ = ▁ " , B , " , ▁ X ▁ can ▁ take ▁ Infinitely ▁ many ▁ values " , " ▁ greater ▁ than ▁ " , A ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " For ▁ A ▁ = ▁ " , A , " ▁ and ▁ B ▁ = ▁ " , B , " , ▁ X ▁ can ▁ take ▁ " , noOfSolutions , " ▁ values " ) NEW_LINE DEDENT DEDENT A = 26 NEW_LINE B = 2 NEW_LINE numberOfPossibleWays ( A , B ) NEW_LINE A = 21 NEW_LINE B = 5 NEW_LINE numberOfPossibleWays ( A , B ) NEW_LINE
import math NEW_LINE def powerNumbers ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 2 , int ( math . pow ( n , 1.0 / 3.0 ) ) + 1 ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT j = j * i NEW_LINE s = int ( math . sqrt ( j ) ) NEW_LINE if ( s * s != j ) : NEW_LINE INDENT v . append ( j ) NEW_LINE DEDENT DEDENT DEDENT v . sort ( ) NEW_LINE v = list ( dict . fromkeys ( v ) ) NEW_LINE return len ( v ) + int ( math . sqrt ( n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( powerNumbers ( 50 ) ) NEW_LINE DEDENT
import math ; NEW_LINE def mean ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += a [ i ] [ j ] ; NEW_LINE DEDENT DEDENT return math . floor ( int ( sum / ( n * n ) ) ) ; NEW_LINE DEDENT def variance ( a , n , m ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT a [ i ] [ j ] -= m ; NEW_LINE a [ i ] [ j ] *= a [ i ] [ j ] ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += a [ i ] [ j ] ; NEW_LINE DEDENT DEDENT return math . floor ( int ( sum / ( n * n ) ) ) ; NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEW_LINE m = mean ( mat , 3 ) ; NEW_LINE var = variance ( mat , 3 , m ) ; NEW_LINE dev = math . sqrt ( var ) ; NEW_LINE print ( " Mean : " , m ) ; NEW_LINE print ( " Variance : " , var ) ; NEW_LINE print ( " Deviation : " , math . floor ( dev ) ) ; NEW_LINE
def printAMeans ( A , B , N ) : NEW_LINE INDENT d = ( B - A ) / ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( int ( A + i * d ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT A = 20 ; B = 32 ; N = 5 NEW_LINE printAMeans ( A , B , N ) NEW_LINE
def sumofseries ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) / 4 ) NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE
import math NEW_LINE def isValid ( i , m ) : NEW_LINE INDENT sq_i = math . sqrt ( i ) NEW_LINE sq = min ( m , sq_i ) NEW_LINE for j in range ( 2 , sq + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findLargestNum ( n , m ) : NEW_LINE INDENT for i in range ( n , m , - 1 ) : NEW_LINE INDENT if ( isValid ( i , m ) ) : NEW_LINE INDENT print ( " { } " . format ( i ) ) ; NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Number Doesn ' t Exists " ) NEW_LINE DEDENT n = 16 NEW_LINE m = 3 NEW_LINE findLargestNum ( n , m ) NEW_LINE
/ * Function to check orthogonalilty * / NEW_LINE def isOrthogonal ( a , m , n ) : NEW_LINE INDENT if ( m != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT trans = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT trans [ i ] [ j ] = a [ j ] [ i ] NEW_LINE DEDENT DEDENT prod = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for k in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( a [ i ] [ k ] * a [ j ] [ k ] ) NEW_LINE DEDENT prod [ i ] [ j ] = sum NEW_LINE DEDENT DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i != j and prod [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i == j and prod [ i ] [ j ] != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT a = [ [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] , [ 0 , 0 , 1 ] ] NEW_LINE if ( isOrthogonal ( a , 3 , 3 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT if ( x >= 0 ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr * sr ) == float ( x ) ) NEW_LINE DEDENT return false NEW_LINE DEDENT x = 2502 NEW_LINE if ( isPerfectSquare ( x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printGP ( a , r , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT curr_term = a * pow ( r , i ) NEW_LINE print ( curr_term , end = " ▁ " ) NEW_LINE DEDENT DEDENT a = 2 NEW_LINE r = 3 NEW_LINE n = 5 NEW_LINE printGP ( a , r , n ) NEW_LINE
def getMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( ( n + 1 ) >> 2 ) NEW_LINE DEDENT def multiply ( F , M ) : NEW_LINE INDENT x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE m = getMSB ( n ) NEW_LINE while m : NEW_LINE INDENT multiply ( F , F ) NEW_LINE if ( n & m ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT m = m >> 1 NEW_LINE DEDENT DEDENT def fib ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n - 1 ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE
import math NEW_LINE def SternSequenceFunc ( BrocotSequence , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT considered_element = BrocotSequence [ i ] NEW_LINE precedent = BrocotSequence [ i - 1 ] NEW_LINE BrocotSequence . append ( considered_element + precedent ) NEW_LINE BrocotSequence . append ( considered_element ) NEW_LINE DEDENT for i in range ( 0 , 15 ) : NEW_LINE INDENT print ( BrocotSequence [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE BrocotSequence = [ ] NEW_LINE BrocotSequence . append ( 1 ) NEW_LINE BrocotSequence . append ( 1 ) NEW_LINE SternSequenceFunc ( BrocotSequence , n ) NEW_LINE
def isRevDiffDivisible ( x , k ) : NEW_LINE INDENT n = x ; m = 0 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT m = m * 10 + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return ( abs ( n - m ) % k == 0 ) NEW_LINE DEDENT def countNumbers ( l , r , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isRevDiffDivisible ( i , k ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 20 ; r = 23 ; k = 6 NEW_LINE print ( countNumbers ( l , r , k ) ) NEW_LINE
import math NEW_LINE def isPerfectSquare ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root = round ( math . sqrt ( n ) ) NEW_LINE return ( n == root * root ) NEW_LINE DEDENT def printnonsquare ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( count < n ) : NEW_LINE INDENT if ( isPerfectSquare ( i ) == False ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE count = count + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printnonsquare ( n ) NEW_LINE
import math NEW_LINE def nonsquare ( n ) : NEW_LINE INDENT return n + ( int ) ( 0.5 + math . sqrt ( n ) ) NEW_LINE DEDENT def printNonSquare ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( nonsquare ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printNonSquare ( n ) NEW_LINE
def maxFraction ( first , sec ) : NEW_LINE INDENT a = first [ 0 ] ; b = first [ 1 ] NEW_LINE c = sec [ 0 ] ; d = sec [ 1 ] NEW_LINE Y = a * d - b * c NEW_LINE return first if Y else sec NEW_LINE DEDENT first = ( 3 , 2 ) NEW_LINE sec = ( 3 , 4 ) NEW_LINE res = maxFraction ( first , sec ) NEW_LINE print ( str ( res [ 0 ] ) + " / " + str ( res [ 1 ] ) ) NEW_LINE
import math NEW_LINE def isPentagonal ( N ) : NEW_LINE INDENT i = 1 NEW_LINE while True : NEW_LINE INDENT M = ( 3 * i * i - i ) / 2 NEW_LINE i += 1 NEW_LINE if ( M >= N ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ( M == N ) NEW_LINE DEDENT N = 12 NEW_LINE if ( isPentagonal ( N ) ) : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE print ( " is ▁ pentagonal ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , end = ' ▁ ' ) NEW_LINE print ( " is ▁ not ▁ pentagonal " ) NEW_LINE DEDENT
import math NEW_LINE def fourthPowerSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( i * i * i * i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
import math NEW_LINE def fourthPowerSum ( n ) : NEW_LINE INDENT return ( ( 6 * n * n * n * n * n ) + ( 15 * n * n * n * n ) + ( 10 * n * n * n ) - n ) / 30 NEW_LINE DEDENT n = 6 NEW_LINE print ( fourthPowerSum ( n ) ) NEW_LINE
import math NEW_LINE def unitnumber ( x , y ) : NEW_LINE INDENT x = x % 10 NEW_LINE if y != 0 : NEW_LINE INDENT y = y % 4 + 4 NEW_LINE DEDENT return ( ( ( int ) ( math . pow ( x , y ) ) ) % 10 ) NEW_LINE DEDENT x = 133 ; y = 5 NEW_LINE print ( unitnumber ( x , y ) ) NEW_LINE
def aliquotSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sm = sm + i NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT n = 12 NEW_LINE print ( aliquotSum ( n ) ) NEW_LINE
def AvgofSquareN ( n ) : NEW_LINE INDENT return ( ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( AvgofSquareN ( n ) ) ; NEW_LINE
def func ( x ) : NEW_LINE INDENT return ( float ( 1 ) / ( 1 + x * x ) ) NEW_LINE DEDENT def calculate ( lower_limit , upper_limit , interval_limit ) : NEW_LINE INDENT interval_size = ( float ( upper_limit - lower_limit ) / interval_limit ) NEW_LINE sum = func ( lower_limit ) + func ( upper_limit ) ; NEW_LINE for i in range ( 1 , interval_limit ) : NEW_LINE INDENT if ( i % 3 == 0 ) : NEW_LINE INDENT sum = sum + 2 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + 3 * func ( lower_limit + i * interval_size ) NEW_LINE DEDENT DEDENT return ( ( float ( 3 * interval_size ) / 8 ) * sum ) NEW_LINE DEDENT interval_limit = 10 NEW_LINE lower_limit = 1 NEW_LINE upper_limit = 10 NEW_LINE integral_res = calculate ( lower_limit , upper_limit , interval_limit ) NEW_LINE print ( round ( integral_res , 6 ) ) NEW_LINE
def focal_length ( image_distance , object_distance ) NEW_LINE INDENT : return 1 / ( ( 1 / image_distance ) + ( 1 / object_distance ) ) NEW_LINE DEDENT image_distance = 2 NEW_LINE object_distance = 50 NEW_LINE result = focal_length ( image_distance , object_distance ) NEW_LINE print ( " Focal ▁ length ▁ of ▁ a ▁ lens ▁ is ▁ " , result , " ▁ units . " ) NEW_LINE
def check ( n ) : NEW_LINE INDENT m = n NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 NEW_LINE if ( r > 0 ) : NEW_LINE INDENT if ( ( m % r ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def count ( l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( check ( i ) ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT l = 10 NEW_LINE r = 20 NEW_LINE print ( count ( l , r ) ) NEW_LINE
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += 1.0 / ( i * ( i + 1 ) ) ; NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ans = sumOfTheSeries ( 10 ) NEW_LINE print ( round ( ans , 6 ) ) NEW_LINE DEDENT
import math NEW_LINE def sum ( n ) : NEW_LINE INDENT root = ( int ) ( math . sqrt ( n ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT ans = ans + n // i NEW_LINE DEDENT ans = 2 * ans - ( root * root ) NEW_LINE return ans NEW_LINE DEDENT n = 35 NEW_LINE print ( sum ( n ) ) NEW_LINE
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum_n = int ( ( n * ( n + 1 ) / 2 ) ) ; NEW_LINE sum_sq_n = int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE return ( sum_n + sum_sq_n ) ; NEW_LINE DEDENT n = 5 NEW_LINE ans = sumOfTheSeries ( n ) NEW_LINE print ( ans ) NEW_LINE
def sumofsquare ( n ) : NEW_LINE INDENT C = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT sum = sum + ( C [ n ] [ i ] * C [ n ] [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( sumofsquare ( n ) , end = " " ) NEW_LINE
import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
import math NEW_LINE def evenSum ( n ) : NEW_LINE INDENT C = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , n + 1 ) ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT sum = sum + C [ n ] [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print evenSum ( n ) NEW_LINE
def triangular_series ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i * ( i + 1 ) // 2 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE triangular_series ( n ) NEW_LINE
def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 3 == 0 : NEW_LINE INDENT print ( int ( n / 3 - 1 ) , " ▁ " , int ( n / 3 ) , " ▁ " , int ( n / 3 + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE checksum ( n ) NEW_LINE
' NEW_LINE ' NEW_LINE def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += int ( n / i ) * i NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE
import math NEW_LINE def Polite ( n ) : NEW_LINE INDENT n = n + 1 NEW_LINE return ( int ) ( n + ( math . log ( ( n + math . log ( n , 2 ) ) , 2 ) ) ) NEW_LINE DEDENT n = 7 NEW_LINE print Polite ( n ) NEW_LINE
def solve ( low , high , T ) : NEW_LINE INDENT while low <= high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( mid * ( mid + 1 ) ) == T : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and ( mid * ( mid + 1 ) ) > T and ( mid * ( mid - 1 ) ) <= T ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( mid * ( mid + 1 ) ) > T : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT T = 15 NEW_LINE ans = solve ( 1 , T , 2 * T ) NEW_LINE if ans != - 1 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT print ( " Number ▁ of ▁ stair ▁ steps ▁ = ▁ " , ans ) NEW_LINE
def isOverflow ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT result = a * b NEW_LINE if ( result >= 9223372036854775807 or result <= - 9223372036854775808 ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT if ( a == ( result // b ) ) : NEW_LINE INDENT print ( result // b ) NEW_LINE return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10000000000 NEW_LINE b = - 10000000000 NEW_LINE if ( isOverflow ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def oddSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE curr = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + curr NEW_LINE curr = curr + 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 20 NEW_LINE print ( " ▁ Sum ▁ of ▁ first " , n , " Odd ▁ Numbers ▁ is : ▁ " , oddSum ( n ) ) NEW_LINE
def oddSum ( n ) : NEW_LINE INDENT return ( n * n ) ; NEW_LINE DEDENT n = 20 NEW_LINE print ( " ▁ Sum ▁ of ▁ first " , n , " Odd ▁ Numbers ▁ is : ▁ " , oddSum ( n ) ) NEW_LINE
def printKPFNums ( A , B , K ) : NEW_LINE INDENT prime = [ True ] * ( B + 1 ) NEW_LINE p_factors = [ 0 ] * ( B + 1 ) NEW_LINE for p in range ( 2 , B + 1 ) : NEW_LINE INDENT if ( p_factors [ p ] == 0 ) : NEW_LINE INDENT for i in range ( p , B + 1 , p ) : NEW_LINE INDENT p_factors [ i ] = p_factors [ i ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( A , B + 1 ) : NEW_LINE INDENT if ( p_factors [ i ] == K ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT A = 14 NEW_LINE B = 18 NEW_LINE K = 2 NEW_LINE printKPFNums ( A , B , K ) NEW_LINE
from math import sqrt NEW_LINE MAX = 100005 NEW_LINE def precompute ( prefix , suffix ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE k = int ( sqrt ( MAX ) ) NEW_LINE for i in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT prefix [ 1 ] = 1 NEW_LINE suffix [ MAX - 1 ] = int ( 1e9 + 7 ) NEW_LINE for i in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT prefix [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] NEW_LINE DEDENT DEDENT i = MAX - 2 NEW_LINE while ( i > 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT suffix [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT suffix [ i ] = suffix [ i + 1 ] NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT def query ( prefix , suffix , L , R ) : NEW_LINE INDENT if ( prefix [ R ] < L or suffix [ L ] > R ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return prefix [ R ] - suffix [ L ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT q = 3 NEW_LINE L = [ 2 , 2 , 24 ] NEW_LINE R = [ 5 , 2 , 28 ] NEW_LINE prefix = [ 0 for i in range ( MAX ) ] NEW_LINE suffix = [ 0 for i in range ( MAX ) ] NEW_LINE precompute ( prefix , suffix ) NEW_LINE for i in range ( 0 , q , 1 ) : NEW_LINE INDENT print ( query ( prefix , suffix , L [ i ] , R [ i ] ) ) NEW_LINE DEDENT DEDENT
def SUM ( x , n ) : NEW_LINE INDENT total = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + ( ( x ** i ) / i ) NEW_LINE DEDENT return total NEW_LINE DEDENT x = 2 NEW_LINE n = 5 NEW_LINE s = SUM ( x , n ) NEW_LINE print ( round ( s , 2 ) ) NEW_LINE
def isMember ( a , d , x ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT return x == a NEW_LINE DEDENT return ( ( x - a ) % d == 0 and int ( ( x - a ) / d ) >= 0 ) NEW_LINE DEDENT a = 1 NEW_LINE x = 7 NEW_LINE d = 3 NEW_LINE if isMember ( a , d , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def sumSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT j = 1 NEW_LINE while ( j * j <= n ) : NEW_LINE INDENT if ( i * i + j * j == n ) : NEW_LINE INDENT print ( i , " ^ 2 ▁ + ▁ " , j , " ^ 2" ) NEW_LINE return True NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 25 NEW_LINE if ( sumSquare ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def check ( a , b ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT c = c + a % 10 ; NEW_LINE a = int ( a / 10 ) ; NEW_LINE DEDENT return True if ( c == b ) else False ; NEW_LINE DEDENT def root ( n ) : NEW_LINE INDENT found = False ; NEW_LINE mx = 1000000000000000001 ; NEW_LINE for i in range ( 91 ) : NEW_LINE INDENT s = i * i + 4 * n ; NEW_LINE sq = int ( math . sqrt ( s ) ) ; NEW_LINE if ( sq * sq == s and check ( int ( ( sq - i ) / 2 ) , i ) ) : NEW_LINE INDENT found = True ; NEW_LINE mx = min ( mx , int ( ( sq - i ) / 2 ) ) ; NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT return mx ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT n = 110 ; NEW_LINE print ( root ( n ) ) ; NEW_LINE
def calculate ( n , power ) : NEW_LINE INDENT return sum ( [ int ( i ) for i in str ( pow ( n , power ) ) ] ) NEW_LINE DEDENT n = 5 NEW_LINE power = 4 NEW_LINE print ( calculate ( n , power ) ) NEW_LINE
import math NEW_LINE def coprime ( a , b ) : NEW_LINE INDENT return 1 if ( math . gcd ( a , b ) == 1 ) else 0 ; NEW_LINE DEDENT def pairSum ( n ) : NEW_LINE INDENT mid = int ( n / 2 ) ; NEW_LINE i = mid ; NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( coprime ( i , n - i ) == 1 ) : NEW_LINE INDENT print ( i , n - i ) ; NEW_LINE break ; NEW_LINE DEDENT i = i - 1 ; NEW_LINE DEDENT DEDENT n = 11 ; NEW_LINE pairSum ( n ) ; NEW_LINE
def modBigNumber ( num , m ) : NEW_LINE INDENT vec = [ ] NEW_LINE mod = 0 NEW_LINE for i in range ( 0 , len ( num ) , 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - ord ( '0' ) NEW_LINE mod = mod * 10 + digit NEW_LINE quo = int ( mod / m ) NEW_LINE vec . append ( quo ) NEW_LINE mod = mod % m NEW_LINE DEDENT print ( " Remainder ▁ : " , mod ) NEW_LINE print ( " Quotient ▁ : " , end = " ▁ " ) NEW_LINE zeroflag = 0 ; NEW_LINE for i in range ( 0 , len ( vec ) , 1 ) : NEW_LINE INDENT if ( vec [ i ] == 0 and zeroflag == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT zeroflag = 1 NEW_LINE print ( vec [ i ] , end = " " ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = "14598499948265358486" NEW_LINE m = 487 NEW_LINE modBigNumber ( num , m ) NEW_LINE DEDENT
N = 1000001 ; NEW_LINE fourDiv = [ False ] * ( N + 1 ) ; NEW_LINE def fourDistinctFactors ( ) : NEW_LINE INDENT primeAll = [ True ] * ( N + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( primeAll [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= N ) : NEW_LINE INDENT primeAll [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT prime = [ ] ; NEW_LINE for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( primeAll [ p ] ) : NEW_LINE INDENT prime . append ( p ) ; NEW_LINE DEDENT DEDENT for i in range ( len ( prime ) ) : NEW_LINE INDENT p = prime [ i ] ; NEW_LINE if ( 1 * p * p * p <= N ) : NEW_LINE INDENT fourDiv [ p * p * p ] = True ; NEW_LINE DEDENT for j in range ( i + 1 , len ( prime ) ) : NEW_LINE INDENT q = prime [ j ] ; NEW_LINE if ( 1 * p * q > N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT fourDiv [ p * q ] = True ; NEW_LINE DEDENT DEDENT DEDENT fourDistinctFactors ( ) ; NEW_LINE num = 10 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT num = 12 ; NEW_LINE if ( fourDiv [ num ] ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def leonardo ( n ) : NEW_LINE INDENT dp = [ ] ; NEW_LINE dp . append ( 1 ) ; NEW_LINE dp . append ( 1 ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + dp [ i - 2 ] + 1 ) ; NEW_LINE DEDENT return dp [ n ] ; NEW_LINE DEDENT print ( leonardo ( 3 ) ) ; NEW_LINE
import math NEW_LINE MAX = 100 ; NEW_LINE def Cholesky_Decomposition ( matrix , n ) : NEW_LINE INDENT lower = [ [ 0 for x in range ( n + 1 ) ] for y in range ( n + 1 ) ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE if ( j == i ) : NEW_LINE INDENT for k in range ( j ) : NEW_LINE INDENT sum1 += pow ( lower [ j ] [ k ] , 2 ) ; NEW_LINE DEDENT lower [ j ] [ j ] = int ( math . sqrt ( matrix [ j ] [ j ] - sum1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for k in range ( j ) : NEW_LINE INDENT sum1 += ( lower [ i ] [ k ] * lower [ j ] [ k ] ) ; NEW_LINE DEDENT if ( lower [ j ] [ j ] > 0 ) : NEW_LINE INDENT lower [ i ] [ j ] = int ( ( matrix [ i ] [ j ] - sum1 ) / lower [ j ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Lower ▁ Triangular TABSYMBOL TABSYMBOL Transpose " ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( lower [ i ] [ j ] , end = " TABSYMBOL " ) ; NEW_LINE DEDENT print ( " " , end = " TABSYMBOL " ) ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( lower [ j ] [ i ] , end = " TABSYMBOL " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT n = 3 ; NEW_LINE matrix = [ [ 4 , 12 , - 16 ] , [ 12 , 37 , - 43 ] , [ - 16 , - 43 , 98 ] ] ; NEW_LINE Cholesky_Decomposition ( matrix , n ) ; NEW_LINE
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = ( n / 2 ) * ( 2 * a + ( n - 1 ) * d ) NEW_LINE return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE
def sumOfSeries ( n ) : NEW_LINE INDENT x = 0 NEW_LINE if n % 2 == 0 : NEW_LINE INDENT x = ( n / 2 ) * ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT x = ( ( n + 1 ) / 2 ) * n NEW_LINE DEDENT return ( int ) ( x * x ) NEW_LINE DEDENT n = 5 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
def findValue ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT ans = ans if ans > ( abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ) else ( abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findValue ( arr , n ) ) ; NEW_LINE
def findValue ( arr , n ) : NEW_LINE INDENT a = [ ] NEW_LINE b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT a . append ( arr [ i ] + i ) NEW_LINE b . append ( arr [ i ] - i ) NEW_LINE DEDENT x = a [ 0 ] NEW_LINE y = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT x = a [ i ] NEW_LINE DEDENT if ( a [ i ] < y ) : NEW_LINE INDENT y = a [ i ] NEW_LINE DEDENT DEDENT ans1 = ( x - y ) NEW_LINE x = b [ 0 ] NEW_LINE y = b [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( b [ i ] > x ) : NEW_LINE INDENT x = b [ i ] NEW_LINE DEDENT if ( b [ i ] < y ) : NEW_LINE INDENT y = b [ i ] NEW_LINE DEDENT DEDENT ans2 = ( x - y ) NEW_LINE return max ( ans1 , ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findValue ( arr , n ) ) NEW_LINE DEDENT
def countsubarray ( array , n , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if array [ i ] < k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT mul = array [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mul = mul * array [ j ] NEW_LINE if mul < k : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT array = [ 1 , 2 , 3 , 4 ] NEW_LINE k = 10 NEW_LINE size = len ( array ) NEW_LINE count = countsubarray ( array , size , k ) NEW_LINE print ( count , end = " ▁ " ) NEW_LINE
MAX = 1000001 ; NEW_LINE factor = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def generatePrimeFactors ( ) : NEW_LINE INDENT factor [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i ; NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT j = i * i ; NEW_LINE while ( j < MAX ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i ; NEW_LINE DEDENT j += i ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def calculateNoOFactors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT ans = 1 ; NEW_LINE dup = factor [ n ] ; NEW_LINE c = 1 ; NEW_LINE j = int ( n / factor [ n ] ) ; NEW_LINE while ( j > 1 ) : NEW_LINE INDENT if ( factor [ j ] == dup ) : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dup = factor [ j ] ; NEW_LINE ans = ans * ( c + 1 ) ; NEW_LINE c = 1 ; NEW_LINE DEDENT j = int ( j / factor [ j ] ) ; NEW_LINE DEDENT ans = ans * ( c + 1 ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT generatePrimeFactors ( ) NEW_LINE a = [ 10 , 30 , 100 , 450 , 987 ] NEW_LINE q = len ( a ) NEW_LINE for i in range ( 0 , q ) : NEW_LINE INDENT print ( calculateNoOFactors ( a [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def digit_product_Sum ( N ) : NEW_LINE INDENT a = [ 0 ] * ( N + 1 ) ; NEW_LINE product = 1 ; NEW_LINE a [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = int ( a [ i - 1 ] / 10 ) ; NEW_LINE if ( product == 0 ) : NEW_LINE INDENT product = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT product = a [ i - 1 ] % 10 ; NEW_LINE DEDENT val = int ( a [ i - 1 ] / 10 ) ; NEW_LINE if ( val == 0 ) : NEW_LINE INDENT val = a [ i - 1 ] ; NEW_LINE DEDENT a [ i ] = a [ i - 1 ] + ( val * product ) ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT N = 10 ; NEW_LINE digit_product_Sum ( N ) ; NEW_LINE
import math NEW_LINE def geometricMean ( arr , n ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * arr [ i ] NEW_LINE DEDENT gm = ( float ) ( math . pow ( product , ( 1 / n ) ) ) NEW_LINE return ( float ) ( gm ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ' { 0 : . 6f } ' . format ( geometricMean ( arr , n ) ) ) NEW_LINE
SIZE = 4 NEW_LINE def productOfSingelDgt ( n ) : NEW_LINE INDENT if n >= 0 and n <= 9 : NEW_LINE INDENT return True NEW_LINE DEDENT prime = [ 2 , 3 , 5 , 7 ] NEW_LINE i = 0 NEW_LINE while i < SIZE and n > 1 : NEW_LINE INDENT while n % prime [ i ] == 0 : NEW_LINE INDENT n = n / prime [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n == 1 NEW_LINE DEDENT n = 24 NEW_LINE if productOfSingelDgt ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * ( n + 1 ) NEW_LINE DEDENT else : NEW_LINE return ( ( n + 1 ) / 2 ) * n NEW_LINE DEDENT n = 5 NEW_LINE print findSum ( n ) NEW_LINE
def maxPrimefactorNum ( N ) : NEW_LINE INDENT if ( N < 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT arr = [ True ] * ( N + 1 ) ; NEW_LINE prod = 1 ; NEW_LINE res = 0 ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( arr [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , N + 1 , p ) : NEW_LINE INDENT arr [ i ] = False ; NEW_LINE DEDENT prod *= p ; NEW_LINE if ( prod > N ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT res += 1 ; NEW_LINE DEDENT p += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT N = 500 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE
def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 NEW_LINE while ( n / divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor NEW_LINE trailing = n % 10 NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = ( n % divisor ) // 10 NEW_LINE divisor = divisor / 100 NEW_LINE DEDENT return True NEW_LINE DEDENT if ( isPalindrome ( 1001 ) ) : NEW_LINE INDENT print ( ' Yes , ▁ it ▁ is ▁ palindrome ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No , ▁ not ▁ palindrome ' ) NEW_LINE DEDENT
def check ( n ) : NEW_LINE INDENT return 1162261467 % n == 0 NEW_LINE DEDENT n = 9 NEW_LINE if ( check ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def printDemlo ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE res = " " NEW_LINE for i in range ( 1 , l + 1 ) : NEW_LINE INDENT res = res + str ( i ) NEW_LINE DEDENT for i in range ( l - 1 , 0 , - 1 ) : NEW_LINE INDENT res = res + str ( i ) NEW_LINE DEDENT return res NEW_LINE DEDENT s = "111111" NEW_LINE print printDemlo ( s ) NEW_LINE
def NumberofTimes ( s ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE count = 0 NEW_LINE while ( len ( s ) > 1 ) : NEW_LINE INDENT temporary_sum = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT temporary_sum += ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT s = str ( temporary_sum ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "991" NEW_LINE print ( NumberofTimes ( s ) ) NEW_LINE DEDENT
def calculateLeaps ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT leaps = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leaps = leaps + calculateLeaps ( i ) ; NEW_LINE DEDENT return leaps ; NEW_LINE DEDENT DEDENT print ( calculateLeaps ( 4 ) ) ; NEW_LINE
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def numberOfDigits ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x //= 10 NEW_LINE i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT def printLastKDigits ( a , b , k ) : NEW_LINE INDENT print ( " Last ▁ " + str ( k ) + " ▁ digits ▁ of ▁ " + str ( a ) + " ^ " + str ( b ) , end = " ▁ = ▁ " ) NEW_LINE temp = 1 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT temp *= 10 NEW_LINE DEDENT temp = power ( a , b , temp ) NEW_LINE for i in range ( k - numberOfDigits ( temp ) ) : NEW_LINE INDENT print ( "0" ) NEW_LINE DEDENT if ( temp ) : NEW_LINE INDENT print ( temp ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 11 NEW_LINE b = 3 NEW_LINE k = 2 NEW_LINE printLastKDigits ( a , b , k ) NEW_LINE DEDENT
def reverseDigits ( num ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev = rev * 10 + num % 10 NEW_LINE num /= 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def square ( num ) : NEW_LINE INDENT return ( num * num ) NEW_LINE DEDENT def checkAdamNumber ( num ) : NEW_LINE INDENT a = square ( num ) NEW_LINE b = square ( reverseDigits ( num ) ) NEW_LINE if ( a == reverseDigits ( b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT num = 13 NEW_LINE if ( checkAdamNumber ( num ) ) : NEW_LINE INDENT print " Adam ▁ Number " NEW_LINE DEDENT else : NEW_LINE INDENT print " Not ▁ a ▁ Adam ▁ Number " NEW_LINE DEDENT
def P2 ( n , table ) : NEW_LINE INDENT table . extend ( [ n , n ^ 1 , n ^ 1 , n ] ) NEW_LINE DEDENT def P4 ( n , table ) : NEW_LINE INDENT return ( P2 ( n , table ) , P2 ( n ^ 1 , table ) , P2 ( n ^ 1 , table ) , P2 ( n , table ) ) NEW_LINE DEDENT def P6 ( n , table ) : NEW_LINE INDENT return ( P4 ( n , table ) , P4 ( n ^ 1 , table ) , P4 ( n ^ 1 , table ) , P4 ( n , table ) ) NEW_LINE DEDENT def LOOK_UP ( table ) : NEW_LINE INDENT return ( P6 ( 0 , table ) , P6 ( 1 , table ) , P6 ( 1 , table ) , P6 ( 0 , table ) ) NEW_LINE DEDENT table = [ 0 ] * 256 NEW_LINE LOOK_UP ( table ) NEW_LINE def Parity ( num ) : NEW_LINE INDENT max = 16 NEW_LINE while ( max >= 8 ) : NEW_LINE INDENT num = num ^ ( num >> max ) NEW_LINE max = max // 2 NEW_LINE DEDENT return table [ num & 0xff ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 1742346774 NEW_LINE result = Parity ( num ) NEW_LINE print ( " Odd ▁ Parity " ) if result else print ( " Even ▁ Parity " ) NEW_LINE DEDENT
def totalDigits ( n ) : NEW_LINE INDENT number_of_digits = 0 ; NEW_LINE for i in range ( 1 , n , 10 ) : NEW_LINE INDENT number_of_digits = ( number_of_digits + ( n - i + 1 ) ) ; NEW_LINE DEDENT return number_of_digits ; NEW_LINE DEDENT n = 13 ; NEW_LINE s = totalDigits ( n ) + 1 ; NEW_LINE print ( s ) ; NEW_LINE
def numbersWith3Divisors ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT print ( " Numbers ▁ with ▁ 3 ▁ divisors ▁ : " ) ; NEW_LINE i = 0 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i * i , end = " ▁ " ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT n = 96 ; NEW_LINE numbersWith3Divisors ( n ) ; NEW_LINE
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 NEW_LINE i = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 NEW_LINE temp = n % 16 NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) NEW_LINE i = i + 1 NEW_LINE DEDENT n = int ( n / 16 ) NEW_LINE DEDENT j = i - 1 NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( ( hexaDeciNum [ j ] ) , end = " " ) NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT n = 2545 NEW_LINE decToHexa ( n ) NEW_LINE
def decToBinary ( n ) : NEW_LINE INDENT binaryNum = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT binaryNum [ i ] = n % 2 ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( binaryNum [ j ] , end = " " ) ; NEW_LINE DEDENT DEDENT n = 17 ; NEW_LINE decToBinary ( n ) ; NEW_LINE
def count_of_ways ( n ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( n + 1 ) * ( n + 2 ) // 2 NEW_LINE return count NEW_LINE DEDENT n = 3 NEW_LINE print ( count_of_ways ( n ) ) NEW_LINE
def flipSign ( a ) : NEW_LINE INDENT neg = 0 ; NEW_LINE tmp = 1 if a < 0 else - 1 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT neg += tmp ; NEW_LINE a += tmp ; NEW_LINE DEDENT return neg ; NEW_LINE DEDENT def areDifferentSign ( a , b ) : NEW_LINE INDENT return ( ( a < 0 and b > 0 ) or ( a > 0 and b < 0 ) ) ; NEW_LINE DEDENT def sub ( a , b ) : NEW_LINE INDENT return a + flipSign ( b ) ; NEW_LINE DEDENT def mul ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return mul ( b , a ) ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for i in range ( abs ( b ) , 0 , - 1 ) : NEW_LINE INDENT sum += a ; NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT sum = flipSign ( sum ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def division ( a , b ) : NEW_LINE INDENT quotient = 0 ; NEW_LINE divisor = flipSign ( abs ( b ) ) ; NEW_LINE for dividend in range ( abs ( a ) , abs ( divisor ) + divisor , divisor ) : NEW_LINE INDENT quotient += 1 ; NEW_LINE DEDENT if ( areDifferentSign ( a , b ) ) : NEW_LINE INDENT quotient = flipSign ( quotient ) ; NEW_LINE DEDENT return quotient ; NEW_LINE DEDENT print ( " Subtraction ▁ is " , sub ( 4 , - 2 ) ) ; NEW_LINE print ( " Product ▁ is " , mul ( - 9 , 6 ) ) ; NEW_LINE a , b = 8 , 2 ; NEW_LINE if ( b ) : NEW_LINE INDENT print ( " Division ▁ is " , division ( a , b ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Exception ▁ : - ▁ Divide ▁ by ▁ 0" ) ; NEW_LINE DEDENT
def numOfCombinations ( arr , N ) : NEW_LINE INDENT C = [ 0 , 0 , 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT C [ arr [ i ] % 3 ] = C [ arr [ i ] % 3 ] + 1 NEW_LINE DEDENT return ( C [ 1 ] * C [ 2 ] + C [ 0 ] * ( C [ 0 ] - 1 ) / 2 + C [ 0 ] * ( C [ 0 ] - 1 ) * ( C [ 0 ] - 2 ) / 6 + C [ 1 ] * ( C [ 1 ] - 1 ) * ( C [ 1 ] - 2 ) / 6 + C [ 2 ] * ( C [ 2 ] - 1 ) * ( C [ 2 ] - 2 ) / 6 + C [ 0 ] * C [ 1 ] * C [ 2 ] ) NEW_LINE DEDENT arr1 = [ 1 , 5 , 7 , 2 , 9 , 14 ] NEW_LINE print ( int ( numOfCombinations ( arr1 , 6 ) ) ) NEW_LINE arr2 = [ 3 , 6 , 9 , 12 ] NEW_LINE print ( int ( numOfCombinations ( arr2 , 4 ) ) ) NEW_LINE
def isprime ( x ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= x ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def isSumOfKprimes ( N , K ) : NEW_LINE INDENT if ( N < 2 * K ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( K == 1 ) : NEW_LINE INDENT return isprime ( N ) NEW_LINE DEDENT if ( K == 2 ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return isprime ( N - 2 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT n = 15 NEW_LINE k = 2 NEW_LINE if ( isSumOfKprimes ( n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def __gcd ( x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT small = y NEW_LINE DEDENT else : NEW_LINE INDENT small = x NEW_LINE DEDENT for i in range ( 1 , small + 1 ) : NEW_LINE INDENT if ( ( x % i == 0 ) and ( y % i == 0 ) ) : NEW_LINE INDENT gcd = i NEW_LINE DEDENT DEDENT return gcd NEW_LINE DEDENT def FindLCM ( a , b ) : NEW_LINE INDENT return ( a * b ) / __gcd ( a , b ) ; NEW_LINE DEDENT def rangeDivisor ( m , n , a , b ) : NEW_LINE INDENT lcm = FindLCM ( a , b ) NEW_LINE a_divisor = int ( n / a - ( m - 1 ) / a ) NEW_LINE b_divisor = int ( n / b - ( m - 1 ) / b ) NEW_LINE common_divisor = int ( n / lcm - ( m - 1 ) / lcm ) NEW_LINE ans = a_divisor + b_divisor - common_divisor NEW_LINE return ans NEW_LINE DEDENT m = 3 NEW_LINE n = 11 NEW_LINE a = 2 NEW_LINE b = 3 ; NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE m = 11 NEW_LINE n = 1000000 NEW_LINE a = 6 NEW_LINE b = 35 NEW_LINE print ( rangeDivisor ( m , n , a , b ) ) NEW_LINE
def printUnique ( l , r ) : NEW_LINE INDENT for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i ; NEW_LINE visited = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; NEW_LINE while ( num ) : NEW_LINE INDENT if visited [ num % 10 ] == 1 : NEW_LINE INDENT break ; NEW_LINE DEDENT visited [ num % 10 ] = 1 ; NEW_LINE num = ( int ) ( num / 10 ) ; NEW_LINE DEDENT if num == 0 : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT l = 1 ; NEW_LINE r = 20 ; NEW_LINE printUnique ( l , r ) ; NEW_LINE
def findMinZero ( p ) : NEW_LINE INDENT first = 1 NEW_LINE second = 1 NEW_LINE number = 2 NEW_LINE next = 1 NEW_LINE while ( next ) : NEW_LINE INDENT next = ( first + second ) % p NEW_LINE first = second NEW_LINE second = next NEW_LINE number = number + 1 NEW_LINE DEDENT return number NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 7 NEW_LINE print ( " Minimal ▁ zero ▁ is : " , findMinZero ( p ) ) NEW_LINE DEDENT
def printCubes ( a , b ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE for j in range ( j ** 3 , i + 1 ) : NEW_LINE INDENT if ( j ** 3 == i ) : NEW_LINE INDENT print ( j ** 3 , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT a = 1 ; b = 100 NEW_LINE print ( " Perfect ▁ cubes ▁ in ▁ given ▁ range : ▁ " ) NEW_LINE printCubes ( a , b ) NEW_LINE
def toBinary ( n ) : NEW_LINE INDENT if ( n >= 1 or n <= 0 ) : NEW_LINE INDENT return " ERROR " ; NEW_LINE DEDENT frac = 0.5 ; NEW_LINE answer = " . " ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( len ( answer ) >= 32 ) : NEW_LINE INDENT return " ERROR " ; NEW_LINE DEDENT if ( n >= frac ) : NEW_LINE INDENT answer += "1" ; NEW_LINE n = n - frac ; NEW_LINE DEDENT else : NEW_LINE INDENT answer += "0" ; NEW_LINE DEDENT frac = ( frac / 2 ) ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT n = 0.625 ; NEW_LINE result = toBinary ( n ) ; NEW_LINE print ( " ( ▁ 0" , result , " ) ▁ in ▁ base ▁ 2" ) ; NEW_LINE m = 0.72 ; NEW_LINE result = toBinary ( m ) ; NEW_LINE print ( " ( " , result , " ) " ) ; NEW_LINE
def firstkdigits ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT product *= n NEW_LINE DEDENT while ( ( product // pow ( 10 , k ) ) != 0 ) : NEW_LINE INDENT product = product // 10 NEW_LINE DEDENT return product NEW_LINE DEDENT n = 15 NEW_LINE k = 4 NEW_LINE print ( firstkdigits ( n , k ) ) NEW_LINE
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 9 == 0 ) NEW_LINE DEDENT st = "99333" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i , N ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT res = res ^ arr [ k ] NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT freq = ( i + 1 ) * ( N - i ) NEW_LINE if ( freq % 2 == 1 ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE
import math NEW_LINE def isRefactorableNumber ( n ) : NEW_LINE INDENT divCount = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT divCount += 1 NEW_LINE divCount += 2 NEW_LINE DEDENT DEDENT DEDENT return n % divCount == 0 NEW_LINE DEDENT n = 8 NEW_LINE if isRefactorableNumber ( n ) : NEW_LINE INDENT print " yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " no " NEW_LINE DEDENT n = 14 NEW_LINE if ( isRefactorableNumber ( n ) ) : NEW_LINE INDENT print " yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " no " NEW_LINE DEDENT
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sq = ( int ) ( math . sqrt ( x ) ) NEW_LINE return ( x == sq * sq ) NEW_LINE DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if isPerfectSquare ( i ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT if n / i != i and isPerfectSquare ( n / i ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT print ( " Total ▁ perfect ▁ divisor ▁ of ▁ 16 ▁ = ▁ " , countPerfectDivisors ( 16 ) ) NEW_LINE print ( " Total ▁ perfect ▁ divisor ▁ of ▁ 12 ▁ = ▁ " , countPerfectDivisors ( 12 ) ) NEW_LINE
import math NEW_LINE def nearestGcd ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT closest = - 1 NEW_LINE j = i - 1 NEW_LINE k = i + 1 NEW_LINE while j > 0 or k <= n : NEW_LINE INDENT if ( j >= 0 and math . gcd ( arr [ i ] , arr [ j ] ) > 1 ) : NEW_LINE INDENT closest = j + 1 NEW_LINE break NEW_LINE DEDENT if ( k < n and math . gcd ( arr [ i ] , arr [ k ] ) > 1 ) : NEW_LINE INDENT closest = k + 1 NEW_LINE break NEW_LINE DEDENT k += 1 NEW_LINE j -= 1 NEW_LINE DEDENT print ( closest , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 9 , 4 , 3 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE nearestGcd ( arr , n ) NEW_LINE DEDENT
import math as mt NEW_LINE MAX = 100001 NEW_LINE prime = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE countdiv = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for i in range ( 2 , mt . ceil ( mt . sqrt ( MAX + 1 ) ) ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT if ( prime [ i ] == 0 ) : NEW_LINE INDENT prime [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT element = arr [ i ] NEW_LINE while ( element > 1 ) : NEW_LINE INDENT div = prime [ element ] NEW_LINE countdiv [ div ] += 1 NEW_LINE ans = max ( ans , countdiv [ div ] ) NEW_LINE while ( element % div == 0 ) : NEW_LINE INDENT element = element // div NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE arr = [ 10 , 15 , 7 , 25 , 9 , 35 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE
from collections import deque NEW_LINE def countOfBinaryNumberLessThanN ( N ) : NEW_LINE INDENT q = deque ( ) NEW_LINE q . append ( 1 ) NEW_LINE cnt = 0 NEW_LINE while ( q ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( t <= N ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE q . append ( t * 10 ) NEW_LINE q . append ( t * 10 + 1 ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 200 NEW_LINE print ( countOfBinaryNumberLessThanN ( N ) ) NEW_LINE DEDENT
def sumofproduct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT y = int ( n / x ) NEW_LINE ans += ( y * x ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 10 NEW_LINE print ( sumofproduct ( n ) ) NEW_LINE
def fact ( n ) : NEW_LINE INDENT num = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = num * i NEW_LINE DEDENT return num NEW_LINE DEDENT def Special_Factorial_Number ( k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( fact ( i ) % k == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 16 NEW_LINE print ( Special_Factorial_Number ( k ) ) NEW_LINE DEDENT
def countMaxChoco ( money , price , wrap ) : NEW_LINE INDENT if ( money < price ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT choc = int ( money / price ) NEW_LINE choc = choc + ( choc - 1 ) / ( wrap - 1 ) NEW_LINE return int ( choc ) NEW_LINE DEDENT money = 15 NEW_LINE price = 1 NEW_LINE wrap = 3 NEW_LINE print ( countMaxChoco ( money , price , wrap ) ) NEW_LINE
def gcd ( i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return i NEW_LINE DEDENT if ( i > j ) : NEW_LINE INDENT return gcd ( i - j , j ) NEW_LINE DEDENT return gcd ( i , j - i ) NEW_LINE DEDENT def ispossible ( x , y , a , b ) : NEW_LINE INDENT x , y , a , b = abs ( x ) , abs ( y ) , abs ( a ) , abs ( b ) NEW_LINE return ( gcd ( x , y ) == gcd ( a , b ) ) NEW_LINE DEDENT x , y = 35 , 15 NEW_LINE a , b = 20 , 25 NEW_LINE if ( ispossible ( x , y , a , b ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
import math NEW_LINE MAX = 10000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * int ( MAX / 2 + 1 ) ; NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( i * ( i + 1 ) ) << 1 , int ( MAX / 2 ) + 1 , 2 * i + 1 ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX / 2 ) + 1 ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def isEquidigital ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT original_no = n ; NEW_LINE sumDigits = 0 ; NEW_LINE while ( original_no > 0 ) : NEW_LINE INDENT sumDigits += 1 ; NEW_LINE original_no = int ( original_no / 10 ) ; NEW_LINE DEDENT pDigit = 0 ; NEW_LINE count_exp = 0 ; NEW_LINE p = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( primes [ i ] <= int ( n / 2 ) ) : NEW_LINE INDENT while ( n % primes [ i ] == 0 ) : NEW_LINE INDENT p = primes [ i ] ; NEW_LINE n = int ( n / p ) ; NEW_LINE count_exp += 1 ; NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT pDigit += 1 ; NEW_LINE p = int ( p / 10 ) ; NEW_LINE DEDENT while ( count_exp > 1 ) : NEW_LINE INDENT pDigit += 1 ; NEW_LINE count_exp = int ( count_exp / 10 ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( n != 1 ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT pDigit += 1 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT DEDENT return ( pDigit == sumDigits ) ; NEW_LINE DEDENT sieveSundaram ( ) ; NEW_LINE print ( " Printing ▁ first ▁ few ▁ Equidigital " , " Numbers ▁ using ▁ isEquidigital ( ) " ) ; NEW_LINE for i in range ( 1 , 20 ) : NEW_LINE INDENT if ( isEquidigital ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
import math NEW_LINE def lcm ( n ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = int ( ( ans * i ) / math . gcd ( ans , i ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 20 NEW_LINE print ( lcm ( n ) ) NEW_LINE
def y ( x ) : NEW_LINE INDENT return ( 1 / ( 1 + x * x ) ) NEW_LINE DEDENT def trapezoidal ( a , b , n ) : NEW_LINE INDENT h = ( b - a ) / n NEW_LINE s = ( y ( a ) + y ( b ) ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT s += 2 * y ( a + i * h ) NEW_LINE i += 1 NEW_LINE DEDENT return ( ( h / 2 ) * s ) NEW_LINE DEDENT x0 = 0 NEW_LINE xn = 1 NEW_LINE n = 6 NEW_LINE print ( " Value ▁ of ▁ integral ▁ is ▁ " , " % .4f " % trapezoidal ( x0 , xn , n ) ) NEW_LINE
def countOddSquares ( n , m ) : NEW_LINE INDENT return int ( m ** 0.5 ) - int ( ( n - 1 ) ** 0.5 ) NEW_LINE DEDENT n = 5 NEW_LINE m = 100 NEW_LINE print ( " Count ▁ is " , countOddSquares ( n , m ) ) NEW_LINE
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if ( isPower ( 10 , 1 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT if ( isPower ( 1 , 20 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT if ( isPower ( 2 , 128 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT if ( isPower ( 2 , 30 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
import math NEW_LINE def CountSquares ( a , b ) : NEW_LINE INDENT return ( math . floor ( math . sqrt ( b ) ) - math . ceil ( math . sqrt ( a ) ) + 1 ) NEW_LINE DEDENT a = 9 NEW_LINE b = 25 NEW_LINE print " Count ▁ of ▁ squares ▁ is : " , int ( CountSquares ( a , b ) ) NEW_LINE
import math NEW_LINE def countDivisors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 2 NEW_LINE DEDENT DEDENT DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT DEDENT print ( " The ▁ count ▁ of ▁ divisor : ▁ " ) NEW_LINE countDivisors ( 10 ) NEW_LINE
def largestPower ( n , p ) : NEW_LINE INDENT x = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n //= p NEW_LINE x += n NEW_LINE DEDENT return x NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modFact ( n , p ) : NEW_LINE INDENT if ( n >= p ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE isPrime = [ 1 ] * ( n + 1 ) NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , n , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT k = largestPower ( n , i ) NEW_LINE res = ( res * power ( i , k , p ) ) % p NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 25 NEW_LINE p = 29 NEW_LINE print ( modFact ( n , p ) ) NEW_LINE DEDENT
def countSquares ( m , n ) : NEW_LINE INDENT if ( n < m ) : NEW_LINE INDENT temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT return ( ( m * ( m + 1 ) * ( 2 * m + 1 ) / 6 + ( n - m ) * m * ( m + 1 ) / 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 4 NEW_LINE n = 3 NEW_LINE print ( " Count ▁ of ▁ squares ▁ is ▁ " , countSquares ( m , n ) ) NEW_LINE DEDENT
def countFact ( low , high ) : NEW_LINE ' NEW_LINE INDENT fact = 1 NEW_LINE x = 1 NEW_LINE while ( fact < low ) : NEW_LINE INDENT fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT res = 0 NEW_LINE while ( fact <= high ) : NEW_LINE INDENT res += 1 NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( " Count ▁ is ▁ " , countFact ( 2 , 720 ) ) NEW_LINE
def getPeriod ( n ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 1 , n + 2 ) : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE DEDENT d = rem NEW_LINE DEDENT ' NEW_LINE INDENT count = 0 NEW_LINE rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE while rem != d : NEW_LINE INDENT rem = ( 10 * rem ) % n NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( getPeriod ( 3 ) ) NEW_LINE print ( getPeriod ( 7 ) ) NEW_LINE DEDENT
def getRemainder ( num , divisor ) : NEW_LINE INDENT return ( num - divisor * ( num // divisor ) ) NEW_LINE DEDENT num = 100 NEW_LINE divisor = 7 NEW_LINE print ( getRemainder ( num , divisor ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE fact = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE sum += 1.0 / fact NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT n = 5 NEW_LINE sum ( n ) NEW_LINE
import math NEW_LINE def Print ( n , k ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = " " ) NEW_LINE rem = ( 10 * rem ) % n NEW_LINE DEDENT DEDENT n = 7 NEW_LINE k = 3 NEW_LINE Print ( n , k ) ; NEW_LINE print ( " ▁ " ) NEW_LINE n = 21 NEW_LINE k = 4 NEW_LINE Print ( n , k ) ; NEW_LINE
def sum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s = s + 1 / i ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ is " , round ( sum ( n ) , 6 ) ) NEW_LINE
def gcd ( a , b ) : ' NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def rearrange ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] += ( arr [ arr [ i ] ] % n ) * n NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT arr [ i ] = int ( arr [ i ] / n ) NEW_LINE DEDENT DEDENT def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT arr = [ 3 , 2 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Given ▁ array ▁ is " ) NEW_LINE printArr ( arr , n ) NEW_LINE rearrange ( arr , n ) ; NEW_LINE print ( " Modified ▁ array ▁ is " ) NEW_LINE printArr ( arr , n ) NEW_LINE
def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE return ; NEW_LINE DEDENT def printSequencesRecur ( arr , n , k , index ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT printArray ( arr , index ) ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ index ] = i ; NEW_LINE printSequencesRecur ( arr , n , k - 1 , index + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def printSequences ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE printSequencesRecur ( arr , n , k , 0 ) ; NEW_LINE return ; NEW_LINE DEDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE printSequences ( n , k ) ; NEW_LINE
def isMultipleof5 ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT n = n - 5 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT i = 19 NEW_LINE if ( isMultipleof5 ( i ) == 1 ) : NEW_LINE INDENT print ( i , " is ▁ multiple ▁ of ▁ 5" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , " is ▁ not ▁ a ▁ multiple ▁ of ▁ 5" ) NEW_LINE DEDENT
def CalculatePairs ( a , n ) : NEW_LINE INDENT cnt_zero = 0 NEW_LINE cnt_one = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 NEW_LINE DEDENT DEDENT total_XOR_pairs = cnt_zero * cnt_one NEW_LINE total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 NEW_LINE total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 NEW_LINE print ( " cntXOR ▁ = ▁ " , int ( total_XOR_pairs ) ) NEW_LINE print ( " cntAND ▁ = ▁ " , int ( total_AND_pairs ) ) NEW_LINE print ( " cntOR ▁ = ▁ " , int ( total_OR_pairs ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE CalculatePairs ( a , n ) NEW_LINE DEDENT
def alternate ( a , b , x ) : NEW_LINE INDENT x = a + b - x NEW_LINE print ( " After ▁ change ▁ x ▁ is : " , x ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( " x ▁ is : " , x ) NEW_LINE alternate ( a , b , x ) NEW_LINE DEDENT
def highestPowerOf2 ( n ) : NEW_LINE INDENT return ( n & ( ~ ( n - 1 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 48 NEW_LINE print ( highestPowerOf2 ( n ) ) NEW_LINE DEDENT
def isSubsetAndZero ( array , length , N ) : NEW_LINE INDENT arrAnd = array [ 0 ] NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT arrAnd = arrAnd & array [ i ] NEW_LINE DEDENT if ( ( arrAnd & N ) == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ 1 , 2 , 4 ] NEW_LINE length = len ( array ) NEW_LINE N = 3 NEW_LINE isSubsetAndZero ( array , length , N ) NEW_LINE DEDENT
def findParity ( x ) : NEW_LINE INDENT y = x ^ ( x >> 1 ) ; NEW_LINE y = y ^ ( y >> 2 ) ; NEW_LINE y = y ^ ( y >> 4 ) ; NEW_LINE y = y ^ ( y >> 8 ) ; NEW_LINE y = y ^ ( y >> 16 ) ; NEW_LINE if ( y & 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if ( findParity ( 9 ) == 0 ) : NEW_LINE INDENT print ( " Even ▁ Parity " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd Parity " ) ; NEW_LINE DEDENT if ( findParity ( 13 ) == 0 ) : NEW_LINE INDENT print ( " Even ▁ Parity " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd ▁ Parity " ) ; NEW_LINE DEDENT
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( num == new_num ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def bitsAreComplement ( a , b , l , r ) : NEW_LINE INDENT xor_value = a ^ b NEW_LINE return allBitsSetInTheGivenRange ( xor_value , l , r ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10 NEW_LINE b = 5 NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE if ( bitsAreComplement ( a , b , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + ( 1 << i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( " Sum ▁ of ▁ series ▁ " , calculateSum ( n ) ) NEW_LINE
def printCombinations ( a , n , m ) : NEW_LINE INDENT for i in range ( 0 , ( 1 << n ) ) : NEW_LINE INDENT sum = 0 NEW_LINE num = 1 << ( n - 1 ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( i & num ) > 0 ) : NEW_LINE INDENT sum += a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT sum += ( - 1 * a [ j ] ) NEW_LINE DEDENT num = num >> 1 NEW_LINE DEDENT if ( sum % m == 0 ) : NEW_LINE INDENT num = 1 << ( n - 1 ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( i & num ) > 0 ) : NEW_LINE INDENT print ( " + " , a [ j ] , end = " ▁ " , sep = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - " , a [ j ] , end = " ▁ " , sep = " " ) NEW_LINE DEDENT num = num >> 1 NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT DEDENT a = [ 3 , 5 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE m = 5 NEW_LINE printCombinations ( a , n , m ) NEW_LINE
/ * returns number of set bits in a number * / NEW_LINE def __builtin_popcount ( n ) : NEW_LINE INDENT t = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT d = n % 2 NEW_LINE n = int ( n / 2 ) NEW_LINE if ( d == 1 ) : NEW_LINE INDENT t = t + 1 NEW_LINE DEDENT DEDENT return t NEW_LINE DEDENT def smallerNumsWithSameSetBits ( n ) : NEW_LINE INDENT temp = __builtin_popcount ( n ) NEW_LINE count = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( temp == __builtin_popcount ( i ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 4 NEW_LINE print ( smallerNumsWithSameSetBits ( n ) ) NEW_LINE
def multiplyWith4 ( n ) : NEW_LINE INDENT return ( n << 2 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( multiplyWith4 ( n ) ) NEW_LINE
def evenbitsetnumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE res = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( n res ) NEW_LINE DEDENT n = 10 NEW_LINE print ( evenbitsetnumber ( n ) ) NEW_LINE
def getmsb ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( n + 1 ) >> 1 NEW_LINE DEDENT def getevenbits ( n ) : NEW_LINE INDENT n = getmsb ( n ) NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE DEDENT return n NEW_LINE DEDENT def setallevenbits ( n ) : NEW_LINE INDENT return n | getevenbits ( n ) NEW_LINE DEDENT / * Driver code * / NEW_LINE n = 10 NEW_LINE print ( setallevenbits ( n ) ) NEW_LINE
def oddbitsetnumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE res = 0 NEW_LINE temp = n NEW_LINE while temp > 0 : NEW_LINE INDENT if count % 2 == 0 : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( n res ) NEW_LINE DEDENT n = 10 NEW_LINE print ( oddbitsetnumber ( n ) ) NEW_LINE
import math NEW_LINE def getmsb ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return ( n + 1 ) >> 1 NEW_LINE DEDENT def getevenbits ( n ) : NEW_LINE INDENT n = getmsb ( n ) NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE DEDENT return n NEW_LINE DEDENT def setalloddbits ( n ) : NEW_LINE INDENT return n | getevenbits ( n ) NEW_LINE DEDENT n = 10 NEW_LINE print ( setalloddbits ( n ) ) NEW_LINE
def printNumHavingAltBitPatrn ( n ) : NEW_LINE INDENT curr_num = 1 NEW_LINE print ( curr_num ) NEW_LINE while ( 1 ) : NEW_LINE INDENT curr_num = curr_num << 1 ; NEW_LINE if ( n < curr_num ) : NEW_LINE INDENT break ; NEW_LINE DEDENT print ( curr_num ) NEW_LINE curr_num = ( ( curr_num ) << 1 ) ^ 1 ; NEW_LINE if ( n < curr_num ) : NEW_LINE INDENT break NEW_LINE DEDENT print ( curr_num ) NEW_LINE DEDENT DEDENT n = 50 NEW_LINE printNumHavingAltBitPatrn ( n ) NEW_LINE
def perfectPowerOf2 ( n ) : NEW_LINE INDENT per_pow = 1 NEW_LINE while n > 0 : NEW_LINE INDENT per_pow = per_pow << 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return per_pow NEW_LINE DEDENT n = 128 NEW_LINE print ( " Perfect ▁ power ▁ of ▁ 2 ▁ greater ▁ than " , n , " : " , perfectPowerOf2 ( n ) ) NEW_LINE
def findUniquePair ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT XOR = XOR ^ arr [ i ] NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ unique ▁ pair ▁ is ▁ ( " , x , " , ▁ " , y , " ) " , sep = " " ) NEW_LINE DEDENT a = [ 6 , 1 , 3 , 5 , 1 , 3 , 7 , 6 ] NEW_LINE n = len ( a ) NEW_LINE findUniquePair ( a , n ) NEW_LINE
import math NEW_LINE def countUnsetBits ( n ) : NEW_LINE INDENT x = n NEW_LINE n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE t = math . log ( x ^ n , 2 ) NEW_LINE return math . floor ( t ) NEW_LINE DEDENT n = 17 NEW_LINE print ( countUnsetBits ( n ) ) NEW_LINE
def countBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT i = 65 NEW_LINE print ( countBits ( i ) ) NEW_LINE
def toggle ( n ) : NEW_LINE INDENT temp = 1 NEW_LINE while ( temp <= n ) : NEW_LINE INDENT n = n ^ temp NEW_LINE temp = temp << 1 NEW_LINE DEDENT return n NEW_LINE DEDENT n = 10 NEW_LINE n = toggle ( n ) NEW_LINE print ( n ) NEW_LINE
INT_MAX = 2147483647 NEW_LINE def isKthBitSet ( x , k ) : NEW_LINE INDENT return 1 if ( x & ( 1 << ( k - 1 ) ) ) else 0 NEW_LINE DEDENT def leftmostSetBit ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT count += 1 NEW_LINE x = x >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def isBinPalindrome ( x ) : NEW_LINE INDENT l = leftmostSetBit ( x ) NEW_LINE r = 1 NEW_LINE while ( l > r ) : NEW_LINE INDENT if ( isKthBitSet ( x , l ) != isKthBitSet ( x , r ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l -= 1 NEW_LINE r += 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def findNthPalindrome ( n ) : NEW_LINE INDENT pal_count = 0 NEW_LINE i = 0 NEW_LINE for i in range ( 1 , INT_MAX + 1 ) : NEW_LINE INDENT if ( isBinPalindrome ( i ) ) : NEW_LINE INDENT pal_count += 1 NEW_LINE DEDENT if ( pal_count == n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 9 NEW_LINE print ( findNthPalindrome ( n ) ) NEW_LINE DEDENT
def LSB ( num , K ) : NEW_LINE INDENT return bool ( num & ( 1 << ( K - 1 ) ) ) NEW_LINE DEDENT num , k = 10 , 4 NEW_LINE res = LSB ( num , k ) NEW_LINE if res : NEW_LINE INDENT print 1 NEW_LINE DEDENT else : NEW_LINE INDENT print 0 NEW_LINE DEDENT
def areSame ( a , b ) : NEW_LINE INDENT if ( not ( a - b ) ) : NEW_LINE INDENT print " Same " NEW_LINE DEDENT else : NEW_LINE INDENT print " Not ▁ Same " NEW_LINE DEDENT DEDENT areSame ( 10 , 20 ) NEW_LINE
def toggleBitsFromLToR ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 50 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE print ( toggleBitsFromLToR ( n , l , r ) ) NEW_LINE
import math NEW_LINE ' NEW_LINE def getRightMostSetBit ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return math . log2 ( n & - n ) + 1 NEW_LINE DEDENT ' NEW_LINE def posOfRightMostDiffBit ( m , n ) : NEW_LINE INDENT return getRightMostSetBit ( m ^ n ) NEW_LINE DEDENT m = 52 NEW_LINE n = 4 NEW_LINE print ( " position ▁ = ▁ " , int ( posOfRightMostDiffBit ( m , n ) ) ) NEW_LINE
def getNext ( n ) : NEW_LINE INDENT c = n NEW_LINE c0 = 0 NEW_LINE c1 = 0 NEW_LINE while ( ( ( c & 1 ) == 0 ) and ( c != 0 ) ) : NEW_LINE INDENT c0 = c0 + 1 NEW_LINE c >>= 1 NEW_LINE DEDENT while ( ( c & 1 ) == 1 ) : NEW_LINE INDENT c1 = c1 + 1 NEW_LINE c >>= 1 NEW_LINE DEDENT if ( c0 + c1 == 31 or c0 + c1 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return n + ( 1 << c0 ) + ( 1 << ( c1 - 1 ) ) - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( getNext ( n ) ) NEW_LINE n = 8 NEW_LINE print ( getNext ( n ) ) NEW_LINE DEDENT
def totalFlips ( A , B , C , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if A [ i ] == B [ i ] and C [ i ] == '1' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT elif A [ i ] != B [ i ] and C [ i ] == '0' : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT N = 5 NEW_LINE a = "10100" NEW_LINE b = "00010" NEW_LINE c = "10011" NEW_LINE print ( totalFlips ( a , b , c , N ) ) NEW_LINE
def swapThree ( a , b , c ) : NEW_LINE INDENT a [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE b [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE c [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE a [ 0 ] = a [ 0 ] ^ b [ 0 ] ^ c [ 0 ] NEW_LINE DEDENT a , b , c = [ 10 ] , [ 20 ] , [ 30 ] NEW_LINE print ( " Before ▁ swapping ▁ a ▁ = ▁ " , a [ 0 ] , " , ▁ b ▁ = ▁ " , b [ 0 ] , " , ▁ c ▁ = ▁ " , c [ 0 ] ) NEW_LINE swapThree ( a , b , c ) NEW_LINE print ( " After ▁ swapping ▁ a ▁ = ▁ " , a [ 0 ] , " , ▁ b ▁ = ▁ " , b [ 0 ] , " , ▁ c ▁ = ▁ " , c [ 0 ] ) NEW_LINE
def findTwoMissingNumbers ( arr , n ) : NEW_LINE INDENT XOR = arr [ 0 ] NEW_LINE for i in range ( 1 , n - 2 ) : NEW_LINE INDENT XOR ^= arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT XOR ^= i NEW_LINE DEDENT set_bit_no = XOR & ~ ( XOR - 1 ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT if arr [ i ] & set_bit_no : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i & set_bit_no : NEW_LINE INDENT x = x ^ i NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ i NEW_LINE DEDENT DEDENT print ( " Two Missing Numbers are % d % d " % ( x , y ) ) NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 6 ] NEW_LINE n = 2 + len ( arr ) NEW_LINE findTwoMissingNumbers ( arr , n ) NEW_LINE
import random NEW_LINE def rand2 ( ) : NEW_LINE INDENT tmp = random . randint ( 1 , 100 ) NEW_LINE return tmp % 2 NEW_LINE DEDENT def rand3 ( ) : NEW_LINE INDENT r = 2 * rand2 ( ) + rand2 ( ) NEW_LINE if r < 3 : NEW_LINE INDENT return r NEW_LINE DEDENT return rand3 ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT for i in range ( 100 ) : NEW_LINE INDENT print ( rand3 ( ) , end = " " ) NEW_LINE DEDENT DEDENT
def findpair ( l , r ) : NEW_LINE INDENT ans1 = l NEW_LINE ans2 = 2 * l NEW_LINE print ( ans1 , " , ▁ " , ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r = 1 , 10 NEW_LINE findpair ( l , r ) NEW_LINE DEDENT
def ElementsCalculationFunc ( pre , maxx , x , k , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = x NEW_LINE while j <= n : NEW_LINE INDENT if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT def MaxNumberOfElements ( a , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT pre [ i ] = 0 NEW_LINE maxx [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] NEW_LINE maxx [ i ] = max ( maxx [ i - 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT l = 1 NEW_LINE r = n NEW_LINE while ( l < r ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if ( ElementsCalculationFunc ( pre , maxx , mid - 1 , k , n ) ) : NEW_LINE INDENT ans = mid NEW_LINE l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE MaxNumberOfElements ( arr , n , k ) NEW_LINE DEDENT
MAX_STR_LEN = 1000 ; NEW_LINE P = [ [ 0 for x in range ( MAX_STR_LEN ) ] for y in range ( MAX_STR_LEN ) ] ; NEW_LINE for i in range ( 0 , MAX_STR_LEN ) : NEW_LINE INDENT for j in range ( 0 , MAX_STR_LEN ) : NEW_LINE INDENT P [ i ] [ j ] = False ; NEW_LINE DEDENT DEDENT Kpal = [ 0 ] * MAX_STR_LEN ; NEW_LINE def checkSubStrPal ( str , n ) : NEW_LINE INDENT global P , Kpal , MAX_STR_LEN ; NEW_LINE for i in range ( 0 , MAX_STR_LEN ) : NEW_LINE INDENT for j in range ( 0 , MAX_STR_LEN ) : NEW_LINE INDENT P [ i ] [ j ] = False ; NEW_LINE DEDENT Kpal [ i ] = 0 ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT P [ i ] [ i ] = True ; NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT P [ i ] [ i + 1 ] = True ; NEW_LINE DEDENT DEDENT for gap in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 0 , n - gap ) : NEW_LINE INDENT j = gap + i ; NEW_LINE if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT P [ i ] [ j ] = True ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def countKPalindromes ( i , j , k ) : NEW_LINE INDENT global Kpal , P ; NEW_LINE if ( i == j ) : NEW_LINE INDENT Kpal [ k ] = Kpal [ k ] + 1 ; NEW_LINE return ; NEW_LINE DEDENT if ( P [ i ] [ j ] == False ) : NEW_LINE INDENT return ; NEW_LINE DEDENT Kpal [ k ] = Kpal [ k ] + 1 ; NEW_LINE mid = int ( ( i + j ) / 2 ) ; NEW_LINE if ( ( j - i + 1 ) % 2 == 1 ) : NEW_LINE INDENT mid = mid - 1 ; NEW_LINE DEDENT countKPalindromes ( i , mid , k + 1 ) ; NEW_LINE DEDENT def printKPalindromes ( s ) : NEW_LINE INDENT global P , Kpal , MAX_STR_LEN ; NEW_LINE n = len ( s ) ; NEW_LINE checkSubStrPal ( s , n ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n - i ) : NEW_LINE INDENT countKPalindromes ( j , j + i , 1 ) ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( Kpal [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT s = " abacaba " ; NEW_LINE printKPalindromes ( s ) ; NEW_LINE
def countCountries ( ans , N ) : NEW_LINE INDENT total_countries = 0 NEW_LINE i = 0 NEW_LINE invalid = 0 NEW_LINE while ( i < N ) : NEW_LINE INDENT curr_size = ans [ i ] NEW_LINE num = ans [ i ] NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( ans [ i ] != curr_size ) : NEW_LINE INDENT print ( " Invalid ▁ Answer " ) NEW_LINE return ; NEW_LINE DEDENT else : NEW_LINE INDENT num = num - 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT total_countries = total_countries + 1 ; NEW_LINE DEDENT print ( " There ▁ are ▁ " , total_countries , " ▁ distinct ▁ companies ▁ in ▁ the ▁ group . " ) NEW_LINE DEDENT ans = [ 1 , 1 , 2 , 2 , 4 , 4 , 4 , 4 ] ; NEW_LINE n = len ( ans ) ; NEW_LINE countCountries ( ans , n ) ; NEW_LINE
def check_elements ( arr , n , A , B ) : NEW_LINE INDENT rangeV = B - A NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( abs ( arr [ i ] ) >= A and abs ( arr [ i ] ) <= B ) : NEW_LINE INDENT z = abs ( arr [ i ] ) - A NEW_LINE if ( arr [ z ] > 0 ) : NEW_LINE INDENT arr [ z ] = arr [ z ] * - 1 NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 0 , rangeV + 1 ) : NEW_LINE INDENT if i >= n : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count != ( rangeV + 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT arr = [ 1 , 4 , 5 , 2 , 7 , 8 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE A = 2 NEW_LINE B = 5 NEW_LINE if ( check_elements ( arr , n , A , B ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findMinRec ( A , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT return min ( A [ n - 1 ] , findMinRec ( A , n - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 4 , 45 , 6 , - 50 , 10 , 2 ] NEW_LINE n = len ( A ) NEW_LINE print ( findMinRec ( A , n ) ) NEW_LINE DEDENT
def isPossible ( arr , n , m , curr_min ) : NEW_LINE INDENT studentsRequired = 1 NEW_LINE curr_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > curr_min ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( curr_sum + arr [ i ] > curr_min ) : NEW_LINE INDENT studentsRequired += 1 NEW_LINE curr_sum = arr [ i ] NEW_LINE if ( studentsRequired > m ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT curr_sum += arr [ i ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def findPages ( arr , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE if ( n < m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT start , end = 0 , sum NEW_LINE result = 10 ** 9 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( isPossible ( arr , n , m , mid ) ) : NEW_LINE INDENT result = mid NEW_LINE end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 12 , 34 , 67 , 90 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ number ▁ of ▁ pages ▁ = ▁ " , findPages ( arr , n , m ) ) NEW_LINE
def countDistinct ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinct ( arr , n ) ) NEW_LINE
def findOptimalSolution ( a , N ) : NEW_LINE INDENT a . sort ( ) NEW_LINE points = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT points += a [ i ] * i NEW_LINE DEDENT return points NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 4 , 2 , 3 , 9 ] NEW_LINE N = len ( a ) NEW_LINE print ( findOptimalSolution ( a , N ) ) NEW_LINE DEDENT
def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT house = [ 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ] NEW_LINE r = 2 NEW_LINE n = len ( house ) NEW_LINE print ( number_of_tower ( house , r , n ) ) NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE c . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( c [ i ] != s [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " aabbbcc " NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printOrder ( arr , n , k ) : NEW_LINE INDENT a = arr [ 0 : k ] ; NEW_LINE a . sort ( ) ; NEW_LINE b = arr [ k : n ] ; NEW_LINE b . sort ( ) ; NEW_LINE b . reverse ( ) ; NEW_LINE return a + b ; NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] ; NEW_LINE k = 4 ; NEW_LINE n = len ( arr ) ; NEW_LINE arr = printOrder ( arr , n , k ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT
def descOrder ( s ) : NEW_LINE INDENT s . sort ( reverse = True ) NEW_LINE str1 = ' ' . join ( s ) NEW_LINE print ( str1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = list ( ' geeksforgeeks ' ) NEW_LINE descOrder ( s ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
MAX = 1000 NEW_LINE def findDuplicate ( arr , n , k ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 1 and arr [ i ] > MAX ) : NEW_LINE INDENT print " Out ▁ of ▁ range " NEW_LINE return - 1 NEW_LINE DEDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 1 , 3 , 1 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print findDuplicate ( arr , n , k ) NEW_LINE
def pendulumArrangement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE op = [ 0 ] * n NEW_LINE mid = int ( ( n - 1 ) / 2 ) NEW_LINE j = 1 NEW_LINE i = 1 NEW_LINE op [ mid ] = arr [ 0 ] NEW_LINE for i in range ( 1 , mid + 1 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE op [ mid - i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( int ( n % 2 ) == 0 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE DEDENT print ( " Pendulum ▁ arrangement : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( op [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 14 , 6 , 19 , 21 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE pendulumArrangement ( arr , n ) NEW_LINE
def minValue ( A , B , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += ( A [ i ] * B [ n - i - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT A = [ 3 , 1 , 1 ] NEW_LINE B = [ 6 , 5 , 4 ] NEW_LINE n = len ( A ) NEW_LINE print minValue ( A , B , n ) NEW_LINE
def printMaxNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT print ( "7" , end = " " ) ; NEW_LINE for i in range ( int ( ( n - 3 ) / 2 ) ) : NEW_LINE INDENT print ( "1" , end = " " ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n / 2 ) : NEW_LINE INDENT print ( "1" , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT n = 5 ; NEW_LINE printMaxNumber ( n ) ; NEW_LINE
import sys NEW_LINE def sorted_partitions ( arr , n ) : NEW_LINE INDENT right_min = [ 0 ] * ( n + 1 ) NEW_LINE right_min [ n ] = sys . maxsize NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT right_min [ i ] = min ( right_min [ i + 1 ] , arr [ i ] ) NEW_LINE DEDENT partitions = 0 NEW_LINE current_max = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_max = max ( current_max , arr [ i ] ) NEW_LINE if ( current_max <= right_min [ i + 1 ] ) : NEW_LINE INDENT partitions += 1 NEW_LINE DEDENT DEDENT return partitions NEW_LINE DEDENT arr = [ 3 , 1 , 2 , 4 , 100 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE ans = sorted_partitions ( arr , n ) NEW_LINE print ( ans ) NEW_LINE
def getMinCost ( arr , n ) : NEW_LINE INDENT min_ele = min ( arr ) NEW_LINE return min_ele * ( n - 1 ) NEW_LINE DEDENT arr = [ 4 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMinCost ( arr , n ) ) NEW_LINE
st = " NNNWEWESSS " NEW_LINE length = len ( st ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( st [ i ] == " N " ) : NEW_LINE INDENT n += 1 NEW_LINE DEDENT if ( st [ i ] == " S " ) : NEW_LINE INDENT s += 1 NEW_LINE DEDENT if ( st [ i ] == " W " ) : NEW_LINE INDENT w += 1 NEW_LINE DEDENT if ( st [ i ] == " E " ) : NEW_LINE INDENT e += 1 NEW_LINE DEDENT DEDENT if ( n == s and w == e ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def cost ( a , n ) : NEW_LINE INDENT return ( ( n - 1 ) * min ( a ) ) NEW_LINE DEDENT a = [ 4 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( cost ( a , n ) ) NEW_LINE
import math NEW_LINE def minCost ( coin , n , k ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE coins_needed = math . ceil ( 1.0 * n // ( k + 1 ) ) ; NEW_LINE ans = 0 NEW_LINE for i in range ( coins_needed - 1 + 1 ) : NEW_LINE INDENT ans += coin [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT coin = [ 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ] NEW_LINE n = len ( coin ) NEW_LINE k = 3 NEW_LINE print ( minCost ( coin , n , k ) ) NEW_LINE
def countOddNumber ( row_num ) : NEW_LINE INDENT count = 0 NEW_LINE while row_num != 0 : NEW_LINE INDENT count += row_num & 1 NEW_LINE row_num >>= 1 NEW_LINE DEDENT return ( 1 << count ) NEW_LINE DEDENT def gouldSequence ( n ) : NEW_LINE INDENT for row_num in range ( 0 , n ) : NEW_LINE INDENT print ( countOddNumber ( row_num ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 16 NEW_LINE gouldSequence ( n ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT A = [ 0 ] * ( n + 1 ) NEW_LINE B = [ 0 ] * ( n + 1 ) NEW_LINE A [ 0 ] = 1 NEW_LINE A [ 1 ] = 0 NEW_LINE B [ 0 ] = 0 NEW_LINE B [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT A [ i ] = A [ i - 2 ] + 2 * B [ i - 1 ] NEW_LINE B [ i ] = A [ i - 1 ] + B [ i - 2 ] NEW_LINE DEDENT return A [ n ] NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE
def sequence ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sequence ( sequence ( n - 1 ) ) + sequence ( n - sequence ( n - 1 ) ) ; NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT n = 10 NEW_LINE print sequence ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( dp [ x ] ) NEW_LINE DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for k in range ( n + 1 ) ] for l in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT
import numpy as np NEW_LINE def waysToArrange ( N , K , k ) : NEW_LINE INDENT C = np . zeros ( ( N + 1 , N + 1 ) ) NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT dp = np . zeros ( ( K + 1 ) ) NEW_LINE count = 0 NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( K ) : NEW_LINE INDENT dp [ i + 1 ] = ( dp [ i ] * C [ count + k [ i ] - 1 ] [ k [ i ] - 1 ] ) NEW_LINE count += k [ i ] NEW_LINE DEDENT return dp [ K ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE k = [ 2 , 2 ] NEW_LINE K = len ( k ) NEW_LINE print ( int ( waysToArrange ( N , K , k ) ) ) NEW_LINE DEDENT
SIZE = 100 NEW_LINE MAX = 10000000 NEW_LINE def minCells ( mat , m , n ) : NEW_LINE INDENT dp = [ [ MAX for i in range ( n ) ] for i in range ( m ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( dp [ i ] [ j ] != MAX and ( j + mat [ i ] [ j ] ) < n and ( dp [ i ] [ j ] + 1 ) < dp [ i ] [ j + mat [ i ] [ j ] ] ) : NEW_LINE INDENT dp [ i ] [ j + mat [ i ] [ j ] ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT if ( dp [ i ] [ j ] != MAX and ( i + mat [ i ] [ j ] ) < m and ( dp [ i ] [ j ] + 1 ) < dp [ i + mat [ i ] [ j ] ] [ j ] ) : NEW_LINE INDENT dp [ i + mat [ i ] [ j ] ] [ j ] = dp [ i ] [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT if ( dp [ m - 1 ] [ n - 1 ] != MAX ) : NEW_LINE INDENT return dp [ m - 1 ] [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT mat = [ [ 2 , 3 , 2 , 1 , 4 ] , [ 3 , 2 , 5 , 8 , 2 ] , [ 1 , 1 , 2 , 2 , 1 ] ] NEW_LINE m = 3 NEW_LINE n = 5 NEW_LINE print ( " Minimum ▁ number ▁ of ▁ cells ▁ = ▁ " , minCells ( mat , m , n ) ) NEW_LINE
R = 3 NEW_LINE C = 3 NEW_LINE def cal ( ones , x , y , k ) : NEW_LINE INDENT return ( ones [ x + k - 1 ] [ y + k - 1 ] - ones [ x - 1 ] [ y + k - 1 ] - ones [ x + k - 1 ] [ y - 1 ] + ones [ x - 1 ] [ y - 1 ] ) NEW_LINE DEDENT def sol ( mat ) : NEW_LINE INDENT ans = 0 NEW_LINE ones = [ [ 0 for i in range ( C + 1 ) ] for i in range ( R + 1 ) ] NEW_LINE for i in range ( 1 , R + 1 , 1 ) : NEW_LINE INDENT for j in range ( 1 , C + 1 , 1 ) : NEW_LINE INDENT ones [ i ] [ j ] = ( ones [ i - 1 ] [ j ] + ones [ i ] [ j - 1 ] - ones [ i - 1 ] [ j - 1 ] + ( mat [ i - 1 ] [ j - 1 ] == 1 ) ) NEW_LINE DEDENT DEDENT for k in range ( 1 , min ( R , C ) + 1 , 1 ) : NEW_LINE INDENT for i in range ( 1 , R - k + 2 , 1 ) : NEW_LINE INDENT for j in range ( 1 , C - k + 2 , 1 ) : NEW_LINE INDENT ans = max ( ans , ( ones [ R ] [ C ] + k * k - 2 * cal ( ones , i , j , k ) ) ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 0 , 0 , 1 ] , [ 0 , 0 , 1 ] , [ 1 , 0 , 1 ] ] NEW_LINE print ( sol ( mat ) ) NEW_LINE DEDENT
def getMinSteps ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = n - i NEW_LINE DEDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) NEW_LINE DEDENT if ( not ( i % 3 ) ) : NEW_LINE INDENT table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) NEW_LINE DEDENT DEDENT return table [ 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 14 NEW_LINE print ( getMinSteps ( n ) ) NEW_LINE DEDENT
def longestSubseqWithDiffOne ( arr , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ i ] == arr [ j ] + 1 ) or ( arr [ i ] == arr [ j ] - 1 ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT result = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < dp [ i ] ) : NEW_LINE INDENT result = dp [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print longestSubseqWithDiffOne ( arr , n ) NEW_LINE
def catalanDP ( n ) : NEW_LINE INDENT catalan = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT catalan [ i ] = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += ( catalan [ j ] * catalan [ i - j - 1 ] ) NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE return 0 NEW_LINE DEDENT return catalanDP ( n // 2 ) NEW_LINE DEDENT print ( countWays ( 6 ) ) NEW_LINE
MAX = 100 ; NEW_LINE dp = [ [ [ [ - 1 ] * 4 for i in range ( MAX ) ] for j in range ( MAX ) ] for k in range ( MAX ) ] ; NEW_LINE ' NEW_LINE def countWays ( p , q , r , last ) : NEW_LINE INDENT if ( p < 0 or q < 0 or r < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( p == 1 and q == 0 and r == 0 and last == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( p == 0 and q == 1 and r == 0 and last == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( p == 0 and q == 0 and r == 1 and last == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( dp [ p ] [ q ] [ r ] [ last ] != - 1 ) : NEW_LINE INDENT return dp [ p ] [ q ] [ r ] [ last ] ; NEW_LINE DEDENT if ( last == 0 ) : NEW_LINE INDENT dp [ p ] [ q ] [ r ] [ last ] = ( countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ) ; NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT elif ( last == 1 ) : NEW_LINE INDENT dp [ p ] [ q ] [ r ] [ last ] = ( countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ p ] [ q ] [ r ] [ last ] = ( countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ) ; NEW_LINE DEDENT return dp [ p ] [ q ] [ r ] [ last ] ; NEW_LINE DEDENT def countUtil ( p , q , r ) : NEW_LINE INDENT return ( countWays ( p , q , r , 0 ) + countWays ( p , q , r , 1 ) + countWays ( p , q , r , 2 ) ) ; NEW_LINE DEDENT p , q , r = 1 , 1 , 1 ; NEW_LINE print ( countUtil ( p , q , r ) ) ; NEW_LINE
def countDer ( n ) : NEW_LINE INDENT if ( n == 1 ) : return 0 NEW_LINE if ( n == 2 ) : return 1 NEW_LINE return ( n - 1 ) * ( countDer ( n - 1 ) + countDer ( n - 2 ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Count ▁ of ▁ Derangements ▁ is ▁ " , countDer ( n ) ) NEW_LINE
def countDer ( n ) : NEW_LINE INDENT der = [ 0 for i in range ( n + 1 ) ] NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT n = 4 NEW_LINE print ( " Count ▁ of ▁ Derangements ▁ is ▁ " , countDer ( n ) ) NEW_LINE
def countSol ( coeff , n , rhs ) : NEW_LINE INDENT dp = [ 0 for i in range ( rhs + 1 ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( coeff [ i ] , rhs + 1 ) : NEW_LINE INDENT dp [ j ] += dp [ j - coeff [ i ] ] NEW_LINE DEDENT DEDENT return dp [ rhs ] NEW_LINE DEDENT coeff = [ 2 , 2 , 5 ] NEW_LINE rhs = 4 NEW_LINE n = len ( coeff ) NEW_LINE print ( countSol ( coeff , n , rhs ) ) NEW_LINE
def maxProd ( n ) : NEW_LINE INDENT if ( n == 2 or n == 3 ) : NEW_LINE INDENT return ( n - 1 ) NEW_LINE DEDENT res = 1 NEW_LINE while ( n > 4 ) : NEW_LINE INDENT n -= 3 ; NEW_LINE res *= 3 ; NEW_LINE DEDENT return ( n * res ) NEW_LINE DEDENT print ( " Maximum ▁ Product ▁ is ▁ " , maxProd ( 10 ) ) ; NEW_LINE
def findWays ( m , n , x ) : NEW_LINE INDENT table = [ [ 0 ] * ( x + 1 ) for i in range ( n + 1 ) ] NEW_LINE for j in range ( 1 , min ( m + 1 , x + 1 ) ) : NEW_LINE INDENT table [ 1 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , x + 1 ) : NEW_LINE INDENT for k in range ( 1 , min ( m + 1 , j ) ) : NEW_LINE INDENT table [ i ] [ j ] += table [ i - 1 ] [ j - k ] NEW_LINE DEDENT DEDENT DEDENT return table [ - 1 ] [ - 1 ] NEW_LINE DEDENT print ( findWays ( 4 , 2 , 1 ) ) NEW_LINE print ( findWays ( 2 , 2 , 3 ) ) NEW_LINE print ( findWays ( 6 , 3 , 8 ) ) NEW_LINE print ( findWays ( 4 , 2 , 5 ) ) NEW_LINE print ( findWays ( 4 , 3 , 5 ) ) NEW_LINE
def max ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT def lps ( seq , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] and i + 1 == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is " , lps ( seq , 0 , n - 1 ) ) NEW_LINE DEDENT
import sys NEW_LINE def findCount ( str1 , str2 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE ans = sys . maxsize NEW_LINE hash1 = [ 0 ] * 26 NEW_LINE hash2 = [ 0 ] * 26 NEW_LINE for i in range ( 0 , len1 ) : NEW_LINE INDENT hash1 [ ord ( str1 [ i ] ) - 97 ] = hash1 [ ord ( str1 [ i ] ) - 97 ] + 1 NEW_LINE DEDENT for i in range ( 0 , len2 ) : NEW_LINE INDENT hash2 [ ord ( str2 [ i ] ) - 97 ] = hash2 [ ord ( str2 [ i ] ) - 97 ] + 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if ( hash2 [ i ] != 0 ) : NEW_LINE INDENT ans = min ( ans , hash1 [ i ] // hash2 [ i ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT str1 = " geeksclassesatnoida " NEW_LINE str2 = " sea " NEW_LINE print ( findCount ( str1 , str2 ) ) NEW_LINE
def isVowel ( c ) : NEW_LINE INDENT vowel = " aeiou " NEW_LINE for i in range ( len ( vowel ) ) : NEW_LINE INDENT if ( vowel [ i ] == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def printRLE ( str , typed ) : NEW_LINE INDENT n = len ( str ) NEW_LINE m = len ( typed ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] != typed [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT if isVowel ( str [ i ] ) == False : NEW_LINE INDENT j = j + 1 NEW_LINE continue NEW_LINE DEDENT count1 = 1 NEW_LINE while ( i < n - 1 and ( str [ i ] == str [ i + 1 ] ) ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT count2 = 1 NEW_LINE while ( j < m - 1 and typed [ j ] == str [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT if count1 > count2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT name = " alex " NEW_LINE typed = " aaalaeex " NEW_LINE if ( printRLE ( name , typed ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def censor ( text , word ) : NEW_LINE INDENT word_list = text . split ( ) NEW_LINE result = ' ' NEW_LINE stars = ' * ' * len ( word ) NEW_LINE count = 0 NEW_LINE index = 0 ; NEW_LINE for i in word_list : NEW_LINE INDENT if i == word : NEW_LINE INDENT word_list [ index ] = stars NEW_LINE DEDENT index += 1 NEW_LINE DEDENT result = ' ▁ ' . join ( word_list ) NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT extract = " GeeksforGeeks ▁ is ▁ a ▁ computer ▁ science ▁ portal ▁ for ▁ geeks . \ STRNEWLINE TABSYMBOL TABSYMBOL TABSYMBOL I ▁ am ▁ pursuing ▁ my ▁ major ▁ in ▁ computer ▁ science . ▁ " NEW_LINE cen = " computer " NEW_LINE print ( censor ( extract , cen ) ) NEW_LINE DEDENT
def getTime ( s , n ) : NEW_LINE INDENT res = " " NEW_LINE h = int ( s [ 0 : 2 ] ) ; NEW_LINE m = int ( s [ 3 : 5 ] ) ; NEW_LINE rev_h = ( h % 10 ) * 10 + ( ( h % 100 ) - ( h % 10 ) ) // 10 ; NEW_LINE rev_hs = str ( rev_h ) NEW_LINE temp = " " NEW_LINE if ( h == 23 and m >= 32 ) : NEW_LINE INDENT res = " - 1" ; NEW_LINE DEDENT elif ( m < rev_h ) : NEW_LINE INDENT if ( h < 10 ) : NEW_LINE INDENT temp = "0" ; NEW_LINE DEDENT temp = temp + str ( h ) ; NEW_LINE if ( rev_h < 10 ) : NEW_LINE INDENT res = res + temp + " : 0" + rev_hs ; NEW_LINE DEDENT else : NEW_LINE INDENT res = res + temp + " : " + rev_hs ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT h += 1 NEW_LINE rev_h = ( h % 10 ) * 10 + ( ( h % 100 ) - ( h % 10 ) ) // 10 ; NEW_LINE rev_hs = str ( rev_h ) ; NEW_LINE if ( h < 10 ) : NEW_LINE INDENT temp = "0" ; NEW_LINE DEDENT temp = temp + str ( h ) ; NEW_LINE if ( rev_h < 10 ) : NEW_LINE INDENT res = res + temp + " : 0" + rev_hs ; NEW_LINE DEDENT else : NEW_LINE INDENT res = res + temp + " : " + rev_hs ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "21:12" ; NEW_LINE n = len ( s ) ; NEW_LINE print ( getTime ( s , n ) ) ; NEW_LINE DEDENT
def CountSubString ( Str , n ) : NEW_LINE INDENT ans = ( n * ( n + 1 ) ) // 2 NEW_LINE a_index = 0 NEW_LINE b_index = 0 NEW_LINE c_index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str [ i ] == ' a ' ) : NEW_LINE INDENT a_index = i + 1 NEW_LINE ans -= min ( b_index , c_index ) NEW_LINE DEDENT elif ( Str [ i ] == ' b ' ) : NEW_LINE INDENT b_index = i + 1 NEW_LINE ans -= min ( a_index , c_index ) NEW_LINE DEDENT else : NEW_LINE INDENT c_index = i + 1 NEW_LINE ans -= min ( a_index , b_index ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT Str = " babac " NEW_LINE n = len ( Str ) NEW_LINE print ( CountSubString ( Str , n ) ) NEW_LINE
def isValid ( string , length ) : NEW_LINE INDENT for i in range ( 1 , length ) : NEW_LINE INDENT if string [ i ] == string [ i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "0110" NEW_LINE length = len ( string ) NEW_LINE if isValid ( string , length ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT DEDENT
def check ( s , K ) : NEW_LINE INDENT for ch in range ( 0 , 26 ) : NEW_LINE INDENT c = chr ( 97 + ch ) NEW_LINE last = - 1 NEW_LINE found = True NEW_LINE for i in range ( 0 , K ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT last = i NEW_LINE DEDENT DEDENT if last == - 1 : NEW_LINE INDENT continue NEW_LINE DEDENT for i in range ( K , len ( s ) ) : NEW_LINE INDENT if s [ i ] == c : NEW_LINE INDENT last = i NEW_LINE DEDENT if last <= ( i - K ) : NEW_LINE INDENT found = False NEW_LINE break NEW_LINE DEDENT DEDENT if found : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def binarySearch ( s ) : NEW_LINE INDENT low , high , ans = 1 , len ( s ) , None NEW_LINE while low <= high : NEW_LINE INDENT mid = ( high + low ) >> 1 NEW_LINE if check ( s , mid ) : NEW_LINE INDENT ans , high = mid , mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcde " NEW_LINE print ( binarySearch ( s ) ) NEW_LINE s = " aaaa " NEW_LINE print ( binarySearch ( s ) ) NEW_LINE DEDENT
seg = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 6 ] NEW_LINE def LedRequired ( s , led ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT count += seg [ ord ( s [ i ] ) - 48 ] NEW_LINE DEDENT if ( count <= led ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = "123456789" NEW_LINE led = 20 NEW_LINE print ( LedRequired ( S , led ) ) NEW_LINE DEDENT
def solve ( s , k ) : NEW_LINE INDENT count , length , pos = 0 , 0 , 0 NEW_LINE m = dict . fromkeys ( s , 0 ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE length += 1 NEW_LINE if length > k : NEW_LINE INDENT m [ s [ pos ] ] -= 1 NEW_LINE pos += 1 NEW_LINE length -= 1 NEW_LINE DEDENT if length == k and m [ s [ i ] ] == length : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaabbbccdddd " NEW_LINE k = 4 NEW_LINE solve ( s , k ) NEW_LINE DEDENT
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " A ▁ computer ▁ science ▁ portal ▁ for ▁ geeks " NEW_LINE for i in range ( 0 , len ( str ) , 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT str = str . replace ( str [ i ] , ' - ' ) NEW_LINE DEDENT DEDENT print ( str ) NEW_LINE DEDENT
def solve ( n , l ) : NEW_LINE INDENT if l < 3 : NEW_LINE INDENT if int ( n ) % 8 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT n = n [ : : - 1 ] NEW_LINE if int ( n ) % 8 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT hash = 10 * [ 0 ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT hash [ int ( n [ i ] ) - 0 ] += 1 ; NEW_LINE DEDENT for i in range ( 104 , 1000 , 8 ) : NEW_LINE INDENT dup = i NEW_LINE freq = 10 * [ 0 ] NEW_LINE freq [ int ( dup % 10 ) ] += 1 ; NEW_LINE dup = dup / 10 NEW_LINE freq [ int ( dup % 10 ) ] += 1 ; NEW_LINE dup = dup / 10 NEW_LINE freq [ int ( dup % 10 ) ] += 1 ; NEW_LINE dup = i NEW_LINE if ( freq [ int ( dup % 10 ) ] > hash [ int ( dup % 10 ) ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dup = dup / 10 ; NEW_LINE if ( freq [ int ( dup % 10 ) ] > hash [ int ( dup % 10 ) ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dup = dup / 10 NEW_LINE if ( freq [ int ( dup % 10 ) ] > hash [ int ( dup % 10 ) ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT number = "31462708" NEW_LINE l = len ( number ) NEW_LINE if solve ( number , l ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def newString ( s , k ) : NEW_LINE INDENT X = " " NEW_LINE while ( len ( s ) > 0 ) : NEW_LINE INDENT temp = s [ 0 ] NEW_LINE i = 1 NEW_LINE while ( i < k and i < len ( s ) ) : NEW_LINE INDENT if ( s [ i ] < temp ) : NEW_LINE INDENT temp = s [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT X = X + temp NEW_LINE for i in range ( k ) : NEW_LINE INDENT if ( s [ i ] == temp ) : NEW_LINE INDENT s = s [ 0 : i ] + s [ i + 1 : ] NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT return X NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " gaurang " NEW_LINE k = 3 NEW_LINE print ( newString ( s , k ) ) NEW_LINE DEDENT
def strToBinary ( s ) : NEW_LINE INDENT bin_conv = [ ] NEW_LINE for c in s : NEW_LINE INDENT ascii_val = ord ( c ) NEW_LINE binary_val = bin ( ascii_val ) NEW_LINE bin_conv . append ( binary_val [ 2 : ] ) NEW_LINE DEDENT return ( ' ▁ ' . join ( bin_conv ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = ' geeks ' NEW_LINE DEDENT print ( strToBinary ( s ) ) NEW_LINE
def printSequence ( arr , input ) : NEW_LINE INDENT n = len ( input ) NEW_LINE output = " " NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( input [ i ] == ' ▁ ' ) : NEW_LINE INDENT output = output + "0" NEW_LINE DEDENT else : NEW_LINE INDENT position = ord ( input [ i ] ) - ord ( ' A ' ) NEW_LINE output = output + arr [ position ] NEW_LINE DEDENT DEDENT return output NEW_LINE DEDENT str = [ "2" , "22" , "222" , "3" , "33" , "333" , "4" , "44" , "444" , "5" , "55" , "555" , "6" , "66" , "666" , "7" , "77" , "777" , "7777" , "8" , "88" , "888" , "9" , "99" , "999" , "9999" ] NEW_LINE input = " GEEKSFORGEEKS " ; NEW_LINE print ( printSequence ( str , input ) ) NEW_LINE
def isEven ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE dotSeen = False NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' and dotSeen == False ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( s [ i ] == ' . ' ) : NEW_LINE INDENT dotSeen = True NEW_LINE continue NEW_LINE DEDENT if ( ( int ) ( s [ i ] ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT DEDENT s = "100.70" NEW_LINE if ( isEven ( s ) ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT
import math as mt NEW_LINE def evaluateBoolExpr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n - 2 , 2 ) : NEW_LINE INDENT if ( s [ i + 1 ] == " A " ) : NEW_LINE INDENT if ( s [ i + 2 ] == "0" or s [ i ] == "0" ) : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT DEDENT elif ( s [ i + 1 ] == " B " ) : NEW_LINE INDENT if ( s [ i + 2 ] == "1" or s [ i ] == "1" ) : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s [ i + 2 ] == s [ i ] ) : NEW_LINE INDENT s [ i + 2 ] = "0" NEW_LINE DEDENT else : NEW_LINE INDENT s [ i + 2 ] = "1" NEW_LINE DEDENT DEDENT DEDENT return ord ( s [ n - 1 ] ) - ord ( "0" ) NEW_LINE DEDENT s = "1C1B1B0A0" NEW_LINE string = [ s [ i ] for i in range ( len ( s ) ) ] NEW_LINE print ( evaluateBoolExpr ( string ) ) NEW_LINE
def FirstRepeated ( string ) : NEW_LINE INDENT checker = 0 NEW_LINE pos = 0 NEW_LINE for i in string : NEW_LINE INDENT val = ord ( i ) - ord ( ' a ' ) ; NEW_LINE if ( ( checker & ( 1 << val ) ) > 0 ) : NEW_LINE INDENT return pos NEW_LINE DEDENT checker |= ( 1 << val ) NEW_LINE pos += 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT string = " abcfdeacf " NEW_LINE i = FirstRepeated ( string ) NEW_LINE if i != - 1 : NEW_LINE INDENT print " Char ▁ = ▁ " , string [ i ] , " ▁ and ▁ Index ▁ = ▁ " , i ; NEW_LINE DEDENT else : NEW_LINE INDENT print " No ▁ repeated ▁ Char " NEW_LINE DEDENT
def evenNumSubstring ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = [ '1' , '2' , '3' , '4' ] NEW_LINE print ( evenNumSubstring ( str ) ) NEW_LINE DEDENT
def isSubSequence ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) ; NEW_LINE n = len ( str2 ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( str1 [ j ] == str2 [ i ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return ( j == m ) ; NEW_LINE DEDENT def findLongestString ( dict1 , str1 ) : NEW_LINE INDENT result = " " ; NEW_LINE length = 0 ; NEW_LINE for word in dict1 : NEW_LINE INDENT if ( length < len ( word ) and isSubSequence ( word , str1 ) ) : NEW_LINE INDENT result = word ; NEW_LINE length = len ( word ) ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT dict1 = [ " ale " , " apple " , " monkey " , " plea " ] ; NEW_LINE str1 = " abpcplea " ; NEW_LINE print ( findLongestString ( dict1 , str1 ) ) ; NEW_LINE
def isEditDistanceOne ( s1 , s2 ) : NEW_LINE INDENT m = len ( s1 ) NEW_LINE n = len ( s2 ) NEW_LINE if abs ( m - n ) > 1 : NEW_LINE INDENT return false NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE while i < m and j < n : NEW_LINE INDENT if s1 [ i ] != s2 [ j ] : NEW_LINE INDENT if count == 1 : NEW_LINE INDENT return false NEW_LINE DEDENT if m > n : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif m < n : NEW_LINE INDENT j += 1 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT count += 1 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if i < m or j < n : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count == 1 NEW_LINE DEDENT s1 = " gfg " NEW_LINE s2 = " gf " NEW_LINE if isEditDistanceOne ( s1 , s2 ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def countSubStr ( st , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( st [ j ] == '1' ) : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return res NEW_LINE DEDENT st = "00100101" ; NEW_LINE list ( st ) NEW_LINE n = len ( st ) NEW_LINE print ( countSubStr ( st , n ) , end = " " ) NEW_LINE
def exponentMod ( A , B , C ) : NEW_LINE INDENT if ( A == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( B == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT y = 0 NEW_LINE if ( B % 2 == 0 ) : NEW_LINE INDENT y = exponentMod ( A , B / 2 , C ) NEW_LINE y = ( y * y ) % C NEW_LINE DEDENT else : NEW_LINE INDENT y = A % C NEW_LINE y = ( y * exponentMod ( A , B - 1 , C ) % C ) % C NEW_LINE DEDENT return ( ( y + C ) % C ) NEW_LINE DEDENT A = 2 NEW_LINE B = 5 NEW_LINE C = 13 NEW_LINE print ( " Power ▁ is " , exponentMod ( A , B , C ) ) NEW_LINE
def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) == 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 y = y / 2 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT x = 2 ; y = 5 ; p = 13 NEW_LINE print ( " Power ▁ is ▁ " , power ( x , y , p ) ) NEW_LINE
import math NEW_LINE def trianglearea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT area = ( 3 * math . sqrt ( 3 ) * math . pow ( a , 2 ) ) / 4 ; NEW_LINE return area ; NEW_LINE DEDENT a = 6 ; NEW_LINE print ( trianglearea ( a ) ) NEW_LINE
def equation_ellipse ( x1 , y1 , a , b , c , e ) : NEW_LINE INDENT t = a * a + b * b NEW_LINE a1 = t - e * ( a * a ) NEW_LINE b1 = t - e * ( b * b ) NEW_LINE c1 = ( - 2 * t * x1 ) - ( 2 * e * c * a ) NEW_LINE d1 = ( - 2 * t * y1 ) - ( 2 * e * c * b ) NEW_LINE e1 = - 2 * e * a * b NEW_LINE f1 = ( - e * c * c ) + ( t * x1 * x1 ) + ( t * y1 * y1 ) NEW_LINE print ( " Equation ▁ of ▁ ellipse ▁ is " , a1 , " x ^ 2 ▁ + " , b1 , " y ^ 2 ▁ + " , c1 , " x ▁ + " , d1 , " y ▁ + " , e1 , " xy ▁ + " , f1 , " = ▁ 0" ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 , y1 , a , b , c , e = 1 , 1 , 1 , - 1 , 3 , 0.5 * 0.5 NEW_LINE equation_ellipse ( x1 , y1 , a , b , c , e ) NEW_LINE DEDENT
from math import pi NEW_LINE def circle_inscribed ( a ) : NEW_LINE INDENT return pi * ( a * a ) / 12 NEW_LINE DEDENT a = 4 NEW_LINE print ( circle_inscribed ( a ) ) NEW_LINE
from math import * NEW_LINE def findVolume ( u , v , w , U , V , W , b ) : NEW_LINE INDENT uPow = pow ( u , 2 ) NEW_LINE vPow = pow ( v , 2 ) NEW_LINE wPow = pow ( w , 2 ) NEW_LINE UPow = pow ( U , 2 ) NEW_LINE VPow = pow ( V , 2 ) NEW_LINE WPow = pow ( W , 2 ) NEW_LINE a = ( 4 * ( uPow * vPow * wPow ) - uPow * pow ( ( vPow + wPow - UPow ) , 2 ) - vPow * pow ( ( wPow + uPow - VPow ) , 2 ) - wPow * pow ( ( uPow + vPow - WPow ) , 2 ) + ( vPow + wPow - UPow ) * ( wPow + uPow - VPow ) * ( uPow + vPow - WPow ) ) NEW_LINE vol = sqrt ( a ) NEW_LINE vol /= b NEW_LINE print ( round ( vol , 4 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT u , v , w = 1000 , 1000 , 1000 NEW_LINE U , V , W = 3 , 4 , 5 NEW_LINE b = 12 NEW_LINE findVolume ( u , v , w , U , V , W , b ) NEW_LINE DEDENT
def makePolygon ( a ) : NEW_LINE INDENT n = 360 / ( 180 - a ) NEW_LINE if n == int ( n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 90 NEW_LINE makePolygon ( a ) NEW_LINE DEDENT
import math NEW_LINE def getQuadrant ( X , Y , R , PX , PY ) : NEW_LINE INDENT if ( PX == X and PY == Y ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT val = ( math . pow ( ( PX - X ) , 2 ) + math . pow ( ( PY - Y ) , 2 ) ) ; NEW_LINE if ( val > pow ( R , 2 ) ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( PX > X and PY >= Y ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( PX <= X and PY > Y ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT if ( PX < X and PY <= Y ) : NEW_LINE INDENT return 3 ; NEW_LINE DEDENT if ( PX >= X and PY < Y ) : NEW_LINE INDENT return 4 ; NEW_LINE DEDENT DEDENT X = 0 ; NEW_LINE Y = 3 ; NEW_LINE R = 2 ; NEW_LINE PX = 1 ; NEW_LINE PY = 4 ; NEW_LINE ans = getQuadrant ( X , Y , R , PX , PY ) ; NEW_LINE if ( ans == - 1 ) : print ( " Lies ▁ Outside ▁ the ▁ circle " ) ; NEW_LINE elif ( ans == 0 ) : print ( " Coincides ▁ with ▁ centre " ) ; NEW_LINE else : print ( ans , " Quadrant " ) ; NEW_LINE
def hexadecagonalNum ( n ) : NEW_LINE INDENT return ( ( 14 * n * n ) - 12 * n ) // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( " % sth ▁ Hexadecagonal ▁ number ▁ : ▁ " % n , hexadecagonalNum ( n ) ) NEW_LINE n = 9 NEW_LINE print ( " % sth ▁ Hexadecagonal ▁ number ▁ : ▁ " % n , hexadecagonalNum ( n ) ) NEW_LINE
def perimeter ( diameter , height ) : NEW_LINE INDENT return 2 * ( diameter + height ) NEW_LINE DEDENT diameter = 5 ; NEW_LINE height = 10 ; NEW_LINE print ( " Perimeter ▁ = ▁ " , perimeter ( diameter , height ) ) NEW_LINE
ay = 0 NEW_LINE ax = 5 NEW_LINE by = 1 NEW_LINE bx = 1 NEW_LINE cy = 5 NEW_LINE cx = 2 NEW_LINE print ( ax + bx - cx , " , ▁ " , ay + by - cy ) NEW_LINE print ( ax + cx - bx , " , ▁ " , ay + cy - by ) NEW_LINE print ( cx + bx - ax , " , ▁ " , cy + by - ax ) NEW_LINE
def area ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) NEW_LINE DEDENT def check ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 , x , y ) : NEW_LINE INDENT A = ( area ( x1 , y1 , x2 , y2 , x3 , y3 ) + area ( x1 , y1 , x4 , y4 , x3 , y3 ) ) NEW_LINE A1 = area ( x , y , x1 , y1 , x2 , y2 ) NEW_LINE A2 = area ( x , y , x2 , y2 , x3 , y3 ) NEW_LINE A3 = area ( x , y , x3 , y3 , x4 , y4 ) NEW_LINE A4 = area ( x , y , x1 , y1 , x4 , y4 ) ; NEW_LINE return ( A == A1 + A2 + A3 + A4 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT if ( check ( 0 , 10 , 10 , 0 , 0 , - 10 , - 10 , 0 , 10 , 15 ) ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT return int ( 1 + n * ( n + 1 ) / 2 ) NEW_LINE DEDENT print ( findMaximumPieces ( 3 ) ) NEW_LINE
from math import sqrt , gcd NEW_LINE def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def findNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = True ) NEW_LINE freq = [ 0 for i in range ( arr [ 0 ] + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT size = int ( sqrt ( n ) ) NEW_LINE brr = [ 0 for i in range ( len ( arr ) ) ] NEW_LINE l = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( freq [ arr [ i ] ] > 0 ) : NEW_LINE INDENT brr [ l ] = arr [ i ] NEW_LINE freq [ brr [ l ] ] -= 1 NEW_LINE l += 1 NEW_LINE for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT x = gcd ( arr [ i ] , brr [ j ] ) NEW_LINE freq [ x ] -= 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT printArr ( brr , size ) NEW_LINE DEDENT / * reverse array * / NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 5 , 5 , 5 , 7 , 10 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE findNumbers ( arr , n ) NEW_LINE DEDENT
def AlternateRearrange ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT v1 . append ( arr [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v2 . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT index = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE flag = False NEW_LINE if ( arr [ 0 ] % 2 == 0 ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT while ( index < n ) : NEW_LINE INDENT if ( flag == True and i < len ( v1 ) ) : NEW_LINE INDENT arr [ index ] = v1 [ i ] NEW_LINE index += 1 NEW_LINE i += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT elif j < len ( v2 ) : NEW_LINE INDENT arr [ index ] = v2 [ j ] NEW_LINE index += 1 NEW_LINE j += 1 NEW_LINE flag = ~ flag NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 9 , 8 , 13 , 2 , 19 , 14 , 21 , 23 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE AlternateRearrange ( arr , n ) NEW_LINE
def getNumToAdd ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE numToAdd = - 1 NEW_LINE numAdded = False NEW_LINE for i in range ( 2 , n , 1 ) : NEW_LINE INDENT diff = arr [ i ] - arr [ i - 1 ] NEW_LINE if ( diff != d ) : NEW_LINE INDENT if ( numAdded ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( diff == 2 * d ) : NEW_LINE INDENT numToAdd = arr [ i ] - d NEW_LINE numAdded = True NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT if ( numToAdd == - 1 ) : NEW_LINE INDENT return ( arr [ n - 1 ] + d ) NEW_LINE DEDENT return numToAdd NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 7 , 11 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getNumToAdd ( arr , n ) ) NEW_LINE DEDENT
def items ( n , a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE z = a [ n - 1 ] NEW_LINE x = 1 NEW_LINE s = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT s += a [ i ] NEW_LINE if ( s <= z ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT / * Driver code * / NEW_LINE n = 5 NEW_LINE a = [ 5 , 3 , 1 , 5 , 6 ] NEW_LINE print ( items ( n , a ) ) NEW_LINE
def numBoxex ( A , n , K ) : NEW_LINE INDENT A . sort ( ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE ans = 0 NEW_LINE while i <= j : NEW_LINE INDENT ans += 1 NEW_LINE if A [ i ] + A [ j ] <= K : NEW_LINE INDENT i += 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 3 , 2 , 2 , 1 ] NEW_LINE K = 3 NEW_LINE n = len ( A ) NEW_LINE print ( numBoxex ( A , n , K ) ) NEW_LINE DEDENT
def solve ( N , M , cp , sp ) : NEW_LINE INDENT profit = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT profit . append ( sp [ i ] - cp [ i ] ) NEW_LINE DEDENT profit . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE for i in range ( M ) : NEW_LINE INDENT if profit [ i ] > 0 : NEW_LINE INDENT sum += profit [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , M = 5 , 3 NEW_LINE CP = [ 5 , 10 , 35 , 7 , 23 ] NEW_LINE SP = [ 11 , 10 , 0 , 9 , 19 ] NEW_LINE print ( solve ( N , M , CP , SP ) ) NEW_LINE DEDENT
def findMaxNum ( arr , n ) : NEW_LINE INDENT arr . sort ( rever num = arr [ 0 ] se = True ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT num = num * 10 + arr [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxNum ( arr , n ) ) NEW_LINE DEDENT
def minimumSets ( arr , n , key ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , j + 1 , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] <= key ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT return i + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE key = 5 NEW_LINE print ( minimumSets ( arr , n , key ) ) NEW_LINE DEDENT
import collections NEW_LINE def minimumBox ( arr , n ) : NEW_LINE INDENT q = collections . deque ( [ ] ) NEW_LINE arr . sort ( ) NEW_LINE q . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT now = q [ 0 ] NEW_LINE if ( arr [ i ] >= 2 * now ) : NEW_LINE INDENT q . popleft ( ) NEW_LINE DEDENT q . append ( arr [ i ] ) NEW_LINE DEDENT return len ( q ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 1 , 2 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumBox ( arr , n ) ) NEW_LINE DEDENT
def sortBinaryArray ( a , n ) : NEW_LINE INDENT j = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] < 1 : NEW_LINE INDENT j = j + 1 NEW_LINE a [ i ] , a [ j ] = a [ j ] , a [ i ] NEW_LINE DEDENT DEDENT DEDENT a = [ 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 ] NEW_LINE n = len ( a ) NEW_LINE sortBinaryArray ( a , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def findDuplicate ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j , count = i + 1 , 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT i = j NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 1 , 3 , 1 ] ; NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print findDuplicate ( arr , n , k ) NEW_LINE
def checkForSorting ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i + 1 ] == 1 ) : NEW_LINE INDENT arr [ i ] , arr [ i + 1 ] = arr [ i + 1 ] , arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 0 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkForSorting ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def ksmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE if ( k < arr [ 0 ] ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT if ( k == arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] + 1 ; NEW_LINE DEDENT if ( k > arr [ n - 1 ] ) : NEW_LINE INDENT return k + n ; NEW_LINE DEDENT if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= ( arr [ 0 ] - 1 ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT c = arr [ i ] - arr [ i - 1 ] - 1 ; NEW_LINE if ( k <= c ) : NEW_LINE INDENT return arr [ i - 1 ] + k ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= c ; NEW_LINE DEDENT DEDENT return arr [ n - 1 ] + k ; NEW_LINE DEDENT k = 1 ; NEW_LINE arr = [ 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ksmallest ( arr , n , k ) ) ; NEW_LINE
def isEven ( n ) : NEW_LINE INDENT return ( not ( n & 1 ) ) NEW_LINE DEDENT n = 101 ; NEW_LINE print ( " Even " if isEven ( n ) else " Odd " ) NEW_LINE
def findSubsequenceCount ( S , T ) : NEW_LINE INDENT m = len ( T ) NEW_LINE n = len ( S ) NEW_LINE if m > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT mat = [ [ 0 for _ in range ( n + 1 ) ] for __ in range ( m + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( n + 1 ) : NEW_LINE INDENT mat [ 0 ] [ j ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if T [ i - 1 ] != S [ j - 1 ] : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT mat [ i ] [ j ] = ( mat [ i ] [ j - 1 ] + mat [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return mat [ m ] [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT T = " ge " NEW_LINE S = " geeksforgeeks " NEW_LINE print ( findSubsequenceCount ( S , T ) ) NEW_LINE DEDENT
def smallestString ( N , A ) : NEW_LINE ' NEW_LINE INDENT ch = ' a ' NEW_LINE S = " " NEW_LINE if ( N < 1 or A [ 0 ] != 1 ) : NEW_LINE INDENT S = " - 1" NEW_LINE return S NEW_LINE DEDENT S += str ( ch ) NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT diff = A [ i ] - A [ i - 1 ] NEW_LINE if ( diff > 1 or diff < 0 or A [ i ] > 26 ) : NEW_LINE INDENT S = " - 1" NEW_LINE return S NEW_LINE DEDENT elif ( diff == 0 ) : NEW_LINE INDENT S += ' a ' NEW_LINE DEDENT else : NEW_LINE INDENT S += ch NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT DEDENT return S NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallestString ( n , arr ) ) NEW_LINE
import math NEW_LINE def canBePicked ( digits , num ) : NEW_LINE INDENT copyDigits = [ ] ; NEW_LINE for i in range ( len ( digits ) ) : NEW_LINE INDENT copyDigits . append ( digits [ i ] ) ; NEW_LINE DEDENT while ( num > 0 ) : NEW_LINE INDENT digit = num % 10 ; NEW_LINE if ( copyDigits [ digit ] == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT copyDigits [ digit ] -= 1 ; NEW_LINE DEDENT num = math . floor ( num / 10 ) ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def countAlphabets ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE digits = [ 0 ] * 10 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE digits [ digit ] += 1 ; NEW_LINE n = math . floor ( n / 10 ) ; NEW_LINE DEDENT for i in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT if ( canBePicked ( digits , i ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT for i in range ( ord ( ' A ' ) , ord ( ' Z ' ) + 1 ) : NEW_LINE INDENT if ( canBePicked ( digits , i ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT n = 1623455078 ; NEW_LINE print ( countAlphabets ( n ) ) ; NEW_LINE
from math import gcd as __gcd NEW_LINE def findTwoNumbers ( sum , gcd ) : NEW_LINE INDENT if ( __gcd ( gcd , sum - gcd ) == gcd and sum != gcd ) : NEW_LINE INDENT print ( " a ▁ = " , min ( gcd , sum - gcd ) , " , ▁ b ▁ = " , sum - min ( gcd , sum - gcd ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sum = 8 NEW_LINE gcd = 2 NEW_LINE findTwoNumbers ( sum , gcd ) NEW_LINE DEDENT
def findMaxDistance ( numOfCities , station ) : NEW_LINE INDENT hasStation = [ False ] * numOfCities NEW_LINE for city in station : NEW_LINE INDENT hasStation [ city ] = True NEW_LINE DEDENT dist , maxDist = 0 , min ( station ) NEW_LINE for city in range ( numOfCities ) : NEW_LINE INDENT if hasStation [ city ] == True : NEW_LINE INDENT maxDist = max ( ( dist + 1 ) // 2 , maxDist ) NEW_LINE dist = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dist += 1 NEW_LINE DEDENT DEDENT return max ( maxDist , dist ) NEW_LINE DEDENT / * Driver code * / NEW_LINE numOfCities = 6 NEW_LINE station = [ 3 , 1 ] NEW_LINE print ( " Max ▁ Distance : " , findMaxDistance ( numOfCities , station ) ) NEW_LINE
def split ( x , n ) : NEW_LINE INDENT if ( x < n ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT elif ( x % n == 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( x // n , end = " ▁ " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT zp = n - ( x % n ) NEW_LINE pp = x // n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i >= zp ) : NEW_LINE INDENT print ( pp + 1 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( pp , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT x = 5 NEW_LINE n = 3 NEW_LINE split ( x , n ) NEW_LINE
' NEW_LINE def cal_minimum_time ( X ) : NEW_LINE INDENT t = 0 NEW_LINE sum = 0 NEW_LINE while ( sum < X ) : NEW_LINE INDENT t = t + 1 NEW_LINE sum = sum + t ; NEW_LINE DEDENT return t ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE ans = cal_minimum_time ( n ) NEW_LINE print ( " The ▁ minimum ▁ time ▁ required ▁ is ▁ : " , ans ) NEW_LINE DEDENT
class pair : NEW_LINE INDENT first = 0 NEW_LINE second = 0 NEW_LINE def __init__ ( self , a , b ) : NEW_LINE INDENT self . first = a NEW_LINE self . second = b NEW_LINE DEDENT DEDENT def solve ( v , n ) : NEW_LINE INDENT ans = 0 ; ul = 0 ; ll = 0 ; NEW_LINE ll = v [ 0 ] . first NEW_LINE ul = v [ 0 ] . second NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( v [ i ] . first <= ul and v [ i ] . first >= ll ) or ( v [ i ] . second >= ll and v [ i ] . second <= ul ) : NEW_LINE INDENT if v [ i ] . first > ll : NEW_LINE INDENT ll = v [ i ] . first NEW_LINE DEDENT if v [ i ] . second < ul : NEW_LINE INDENT ul = v [ i ] . second ; NEW_LINE DEDENT DEDENT elif v [ i ] . first > ul : NEW_LINE INDENT ans += abs ( ul - v [ i ] . first ) NEW_LINE ul = v [ i ] . first NEW_LINE ll = v [ i ] . first NEW_LINE DEDENT elif v [ i ] . second < ll : NEW_LINE INDENT ans += abs ( ll - v [ i ] . second ) ; NEW_LINE ul = v [ i ] . second ; NEW_LINE ll = v [ i ] . second ; NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT v = [ pair ( 1 , 3 ) , pair ( 2 , 5 ) , pair ( 6 , 8 ) , pair ( 1 , 2 ) , pair ( 2 , 3 ) ] NEW_LINE n = len ( v ) NEW_LINE print ( solve ( v , n ) ) NEW_LINE
import math as mt NEW_LINE def preProcess ( n ) : NEW_LINE INDENT preProcessedCubes = list ( ) NEW_LINE for i in range ( 1 , mt . ceil ( n ** ( 1. / 3. ) ) ) : NEW_LINE INDENT iThCube = i ** 3 NEW_LINE cubeString = str ( iThCube ) NEW_LINE preProcessedCubes . append ( cubeString ) NEW_LINE DEDENT return preProcessedCubes NEW_LINE DEDENT def findLargestCubeUtil ( num , preProcessedCubes ) : NEW_LINE INDENT preProcessedCubes = preProcessedCubes [ : : - 1 ] NEW_LINE totalCubes = len ( preProcessedCubes ) NEW_LINE for i in range ( totalCubes ) : NEW_LINE INDENT currCube = preProcessedCubes [ i ] NEW_LINE digitsInCube = len ( currCube ) NEW_LINE index = 0 NEW_LINE digitsInNumber = len ( num ) NEW_LINE for j in range ( digitsInNumber ) : NEW_LINE INDENT if ( num [ j ] == currCube [ index ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if ( digitsInCube == index ) : NEW_LINE INDENT return currCube NEW_LINE DEDENT DEDENT DEDENT return " Not ▁ Possible " NEW_LINE DEDENT def findLargestCube ( n ) : NEW_LINE INDENT preProcessedCubes = preProcess ( n ) NEW_LINE num = str ( n ) NEW_LINE ans = findLargestCubeUtil ( num , preProcessedCubes ) NEW_LINE print ( " Largest ▁ Cube ▁ that ▁ can ▁ be ▁ formed ▁ from " , n , " is " , ans ) NEW_LINE DEDENT n = 4125 NEW_LINE findLargestCube ( n ) NEW_LINE n = 876 NEW_LINE findLargestCube ( n ) NEW_LINE
def noAdjacentDup ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = " a " NEW_LINE while ( s [ i ] == s [ i - 1 ] or ( i + 1 < n and s [ i ] == s [ i + 1 ] ) ) : NEW_LINE INDENT s [ i ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT s = list ( " geeksforgeeks " ) NEW_LINE print ( " " . join ( noAdjacentDup ( s ) ) ) NEW_LINE
def winner ( a , n , k ) : NEW_LINE INDENT if k >= n - 1 : NEW_LINE INDENT return n NEW_LINE DEDENT best = 0 NEW_LINE times = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > best : NEW_LINE INDENT best = a [ i ] NEW_LINE if i == True : NEW_LINE INDENT times = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE if times >= k : NEW_LINE INDENT return best NEW_LINE DEDENT DEDENT return best NEW_LINE DEDENT a = [ 2 , 1 , 3 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE print ( winner ( a , n , k ) ) NEW_LINE
import numpy as np NEW_LINE MAX = 100000 NEW_LINE bitscount = 32 NEW_LINE prefix_count = np . zeros ( ( bitscount , MAX ) ) ; NEW_LINE def findPrefixCount ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , bitscount ) : NEW_LINE INDENT prefix_count [ i ] [ 0 ] = ( ( arr [ 0 ] >> i ) & 1 ) ; NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT prefix_count [ i ] [ j ] = ( ( arr [ j ] >> i ) & 1 ) ; NEW_LINE prefix_count [ i ] [ j ] += prefix_count [ i ] [ j - 1 ] ; NEW_LINE DEDENT DEDENT DEDENT def rangeOr ( l , r ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( bitscount ) : NEW_LINE INDENT x = 0 ; NEW_LINE if ( l == 0 ) : NEW_LINE INDENT x = prefix_count [ i ] [ r ] ; NEW_LINE DEDENT else : NEW_LINE INDENT x = prefix_count [ i ] [ r ] - prefix_count [ i ] [ l - 1 ] ; NEW_LINE DEDENT if ( x != 0 ) : NEW_LINE INDENT ans = ( ans | ( 1 << i ) ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 7 , 5 , 3 , 5 , 2 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findPrefixCount ( arr , n ) ; NEW_LINE queries = [ [ 1 , 3 ] , [ 4 , 5 ] ] ; NEW_LINE q = len ( queries ) ; NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( rangeOr ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT
from sys import maxsize NEW_LINE def BellmanFord ( graph , V , E , src ) : NEW_LINE INDENT dis = [ maxsize ] * V NEW_LINE dis [ src ] = 0 NEW_LINE for i in range ( V - 1 ) : NEW_LINE INDENT for j in range ( E ) : NEW_LINE INDENT if dis [ graph [ j ] [ 0 ] ] + graph [ j ] [ 2 ] < dis [ graph [ j ] [ 1 ] ] : NEW_LINE INDENT dis [ graph [ j ] [ 1 ] ] = dis [ graph [ j ] [ 0 ] ] + graph [ j ] [ 2 ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( E ) : NEW_LINE INDENT x = graph [ i ] [ 0 ] NEW_LINE y = graph [ i ] [ 1 ] NEW_LINE weight = graph [ i ] [ 2 ] NEW_LINE if dis [ x ] != maxsize and dis [ x ] + weight < dis [ y ] : NEW_LINE INDENT print ( " Graph ▁ contains ▁ negative ▁ weight ▁ cycle " ) NEW_LINE DEDENT DEDENT print ( " Vertex ▁ Distance ▁ from ▁ Source " ) NEW_LINE for i in range ( V ) : NEW_LINE INDENT print ( " % d TABSYMBOL TABSYMBOL % d " % ( i , dis [ i ] ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT graph = [ [ 0 , 1 , - 1 ] , [ 0 , 2 , 4 ] , [ 1 , 2 , 3 ] , [ 1 , 3 , 2 ] , [ 1 , 4 , 2 ] , [ 3 , 2 , 5 ] , [ 3 , 1 , 1 ] , [ 4 , 3 , - 3 ] ] NEW_LINE BellmanFord ( graph , V , E , 0 ) NEW_LINE DEDENT
global maxn NEW_LINE maxn = 16 NEW_LINE def precompute ( ) : NEW_LINE INDENT dp = [ - 1 for i in range ( maxn ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE v = [ 4 , 6 , 9 ] NEW_LINE for i in range ( 1 , maxn , 1 ) : NEW_LINE INDENT for k in range ( 3 ) : NEW_LINE INDENT j = v [ k ] NEW_LINE if ( i >= j and dp [ i - j ] != - 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - j ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT return dp NEW_LINE DEDENT def Maximum_Summands ( dp , n ) : NEW_LINE INDENT if ( n < maxn ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT t = int ( ( n - maxn ) / 4 ) + 1 NEW_LINE return t + dp [ n - 4 * t ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE dp = precompute ( ) NEW_LINE print ( Maximum_Summands ( dp , n ) ) NEW_LINE DEDENT
N = 4 NEW_LINE def getSum ( r1 , r2 , c1 , c2 , dp ) : NEW_LINE INDENT return dp [ r2 ] [ c2 ] - dp [ r2 ] [ c1 ] - dp [ r1 ] [ c2 ] + dp [ r1 ] [ c1 ] NEW_LINE DEDENT def sumFound ( K , S , grid ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 1 ) ] for j in range ( N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT dp [ i + 1 ] [ j + 1 ] = dp [ i + 1 ] [ j ] + dp [ i ] [ j + 1 ] - dp [ i ] [ j ] + grid [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT sum = getSum ( i , i + K , j , j + K , dp ) NEW_LINE if ( sum == S ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT grid = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 ] ] NEW_LINE K = 2 NEW_LINE S = 14 NEW_LINE if ( sumFound ( K , S , grid ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findMinOperations ( S ) : NEW_LINE INDENT S = S [ : : - 1 ] NEW_LINE n = len ( S ) NEW_LINE dp = [ [ 0 ] * 2 ] * ( n + 1 ) NEW_LINE if ( S [ 0 ] == '0' ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT dp [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( S [ i ] == '0' ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 0 ] NEW_LINE dp [ i ] [ 1 ] = 1 + min ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 1 ] = dp [ i - 1 ] [ 1 ] ; NEW_LINE dp [ i ] [ 0 ] = 1 + min ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = "100" NEW_LINE print ( findMinOperations ( S ) ) NEW_LINE S = "111" ; NEW_LINE print ( findMinOperations ( S ) ) NEW_LINE DEDENT
def solve ( N , K ) : NEW_LINE INDENT Array = [ 0 ] * ( N + 1 ) NEW_LINE DEDENT ' NEW_LINE INDENT if ( N <= K ) : NEW_LINE INDENT print ( "1" ) NEW_LINE return NEW_LINE DEDENT i = 0 NEW_LINE sm = K NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT Array [ i ] = 1 NEW_LINE DEDENT Array [ i + 1 ] = sm NEW_LINE for i in range ( K + 2 , N + 1 ) : NEW_LINE INDENT Array [ i ] = sm - Array [ i - K - 1 ] + Array [ i - 1 ] NEW_LINE sm = Array [ i ] NEW_LINE DEDENT print ( Array [ N ] ) NEW_LINE DEDENT N = 4 NEW_LINE K = 2 NEW_LINE solve ( N , K ) NEW_LINE
MAX_VAL = 10000000 NEW_LINE dp = [ [ - 1 for i in range ( 100 ) ] for i in range ( 100 ) ] NEW_LINE def find ( index , openbrk , n , adj ) : NEW_LINE INDENT if ( openbrk < 0 ) : NEW_LINE INDENT return MAX_VAL NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT if ( openbrk == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return MAX_VAL NEW_LINE DEDENT DEDENT if ( dp [ index ] [ openbrk ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ openbrk ] NEW_LINE DEDENT dp [ index ] [ openbrk ] = min ( adj [ index ] [ 1 ] + find ( index + 1 , openbrk + 1 , n , adj ) , adj [ index ] [ 0 ] + find ( index + 1 , openbrk - 1 , n , adj ) ) NEW_LINE return dp [ index ] [ openbrk ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 ; NEW_LINE adj = [ [ 5000 , 3000 ] , [ 6000 , 2000 ] , [ 8000 , 1000 ] , [ 9000 , 6000 ] ] NEW_LINE print ( find ( 1 , 1 , n , adj ) + adj [ 0 ] [ 1 ] ) NEW_LINE DEDENT
def find ( start , adj , n , dp ) : NEW_LINE INDENT if ( start == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ start ] != - 1 ) : NEW_LINE INDENT return dp [ start ] NEW_LINE DEDENT dp [ start ] = 0 NEW_LINE one = 0 NEW_LINE zero = 0 NEW_LINE for k in range ( start , n , 1 ) : NEW_LINE INDENT if ( adj [ k ] == '1' ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero += 1 NEW_LINE DEDENT if ( one > zero ) : NEW_LINE INDENT dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) + k - start + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ start ] = max ( dp [ start ] , find ( k + 1 , adj , n , dp ) ) NEW_LINE DEDENT DEDENT return dp [ start ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT adj = "100110001010001" NEW_LINE n = len ( adj ) NEW_LINE dp = [ - 1 for i in range ( n + 1 ) ] NEW_LINE print ( find ( 0 , adj , n , dp ) ) NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE i , j = 0 , 0 NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( ( X [ i - 1 ] == Y [ j - 1 ] ) and isVowel ( X [ i - 1 ] ) ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT X = " aieef " NEW_LINE Y = " klaief " NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( " Length ▁ of ▁ LCS ▁ = " , lcs ( X , Y , m , n ) ) NEW_LINE
def check ( i , val ) : NEW_LINE INDENT if i - val < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def MinimumPrimes ( n ) : NEW_LINE INDENT dp = [ 10 ** 9 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if check ( i , 2 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 2 ] ) NEW_LINE DEDENT if check ( i , 3 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 3 ] ) NEW_LINE DEDENT if check ( i , 5 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 5 ] ) NEW_LINE DEDENT if check ( i , 7 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 7 ] ) NEW_LINE DEDENT DEDENT if dp [ n ] == 10 ** 9 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE minimal = MinimumPrimes ( n ) NEW_LINE if minimal != - 1 : NEW_LINE INDENT print ( " Minimum ▁ number ▁ of ▁ single ▁ digit ▁ primes ▁ required ▁ : ▁ " , minimal ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT
def numberOfBST ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] , dp [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i ] + ( dp [ i - j ] * dp [ j - 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( " Number ▁ of ▁ structurally ▁ Unique ▁ BST ▁ with " , n , " keys ▁ are ▁ : " , numberOfBST ( n ) ) NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT return n << ( n - 1 ) ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( summation ( n ) ) ; NEW_LINE
def minMaxValues ( arr , n , m ) : NEW_LINE INDENT sum = 0 NEW_LINE INF = 1000000000 NEW_LINE MAX = 50 NEW_LINE for i in range ( 0 , ( n + m ) ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE arr [ i ] += 50 NEW_LINE DEDENT dp = [ [ 0 for x in range ( MAX * MAX + 1 ) ] for y in range ( MAX + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 0 , ( n + m ) ) : NEW_LINE INDENT for k in range ( min ( n , i + 1 ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ k - 1 ] [ j ] ) : NEW_LINE INDENT dp [ k ] [ j + arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT max_value = - 1 * INF NEW_LINE min_value = INF NEW_LINE for i in range ( 0 , MAX * MAX + 1 ) : NEW_LINE INDENT if ( dp [ n ] [ i ] ) : NEW_LINE INDENT temp = i - 50 * n NEW_LINE max_value = max ( max_value , temp * ( sum - temp ) ) NEW_LINE min_value = min ( min_value , temp * ( sum - temp ) ) NEW_LINE DEDENT DEDENT print ( " Maximum Value : { } Minimum Value : { } " . format ( max_value , min_value ) ) NEW_LINE DEDENT n = 2 NEW_LINE m = 2 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE minMaxValues ( arr , n , m ) NEW_LINE
def findGolomb ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + findGolomb ( n - findGolomb ( findGolomb ( n - 1 ) ) ) NEW_LINE DEDENT def printGolomb ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( findGolomb ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE printGolomb ( n ) NEW_LINE
def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if res <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE printknapSack ( W , wt , val , n ) NEW_LINE
def maximumSegments ( n , a , b , c ) : NEW_LINE INDENT dp = [ - 1 ] * ( n + 10 ) NEW_LINE DEDENT / * initialize with - 1 * / NEW_LINE INDENT dp [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( dp [ i ] != - 1 ) : NEW_LINE INDENT dp [ i + a ] = max ( dp [ i ] + 1 , dp [ i + a ] ) NEW_LINE dp [ i + b ] = max ( dp [ i ] + 1 , dp [ i + b ] ) NEW_LINE dp [ i + c ] = max ( dp [ i ] + 1 , dp [ i + c ] ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT n = 7 NEW_LINE a = 5 NEW_LINE b = 2 NEW_LINE c = 5 NEW_LINE print ( maximumSegments ( n , a , b , c ) ) NEW_LINE
def sequence ( n ) : NEW_LINE INDENT f = [ 0 , 1 , 1 ] NEW_LINE print ( f [ 1 ] , end = " ▁ " ) , NEW_LINE print ( f [ 2 ] , end = " ▁ " ) , NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT f . append ( f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] ) NEW_LINE print ( f [ i ] , end = " ▁ " ) , NEW_LINE DEDENT DEDENT n = 13 NEW_LINE sequence ( n ) NEW_LINE
def zigzag ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ i - j ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( zigzag ( n , k ) ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for j in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def lobb ( n , m ) : NEW_LINE INDENT return ( ( ( 2 * m + 1 ) * binomialCoeff ( 2 * n , m + n ) ) / ( m + n + 1 ) ) NEW_LINE DEDENT n = 5 NEW_LINE m = 3 NEW_LINE print ( int ( lobb ( n , m ) ) ) NEW_LINE
def countarray ( n , k , x ) : NEW_LINE INDENT dp = list ( ) NEW_LINE dp . append ( 0 ) NEW_LINE dp . append ( 1 ) NEW_LINE i = 2 NEW_LINE while i < n : NEW_LINE INDENT dp . append ( ( k - 2 ) * dp [ i - 1 ] + ( k - 1 ) * dp [ i - 2 ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT return ( ( k - 1 ) * dp [ n - 2 ] if x == 1 else dp [ n - 1 ] ) NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE x = 2 NEW_LINE print ( countarray ( n , k , x ) ) NEW_LINE
MAX = 100 NEW_LINE MAX_CHAR = 26 NEW_LINE def precompute ( s , n , l , r ) : NEW_LINE INDENT l [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( MAX_CHAR ) : NEW_LINE INDENT l [ j ] [ i ] += l [ j ] [ i - 1 ] NEW_LINE DEDENT l [ ord ( s [ i ] ) - ord ( ' a ' ) ] [ i ] += 1 NEW_LINE DEDENT r [ ord ( s [ n - 1 ] ) - ord ( ' a ' ) ] [ n - 1 ] = 1 NEW_LINE k = n - 2 NEW_LINE while ( k >= 0 ) : NEW_LINE INDENT for j in range ( MAX_CHAR ) : NEW_LINE INDENT r [ j ] [ k ] += r [ j ] [ k + 1 ] NEW_LINE DEDENT r [ ord ( s [ k ] ) - ord ( ' a ' ) ] [ k ] += 1 NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT def countPalindromes ( k , n , l , r ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( k == 1 ) : NEW_LINE INDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT ans += l [ i ] [ n - 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if ( k == 2 ) : NEW_LINE INDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT ans += ( ( l [ i ] [ n - 1 ] * ( l [ i ] [ n - 1 ] - 1 ) ) / 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT for j in range ( MAX_CHAR ) : NEW_LINE INDENT ans += l [ j ] [ i - 1 ] * r [ j ] [ i + 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT s = " aabab " NEW_LINE k = 2 NEW_LINE n = len ( s ) NEW_LINE l = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX_CHAR ) ] NEW_LINE r = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX_CHAR ) ] NEW_LINE precompute ( s , n , l , r ) NEW_LINE print ( countPalindromes ( k , n , l , r ) ) NEW_LINE
SIZE = 10 NEW_LINE INT_MIN = - 10000000 NEW_LINE def maxSum ( mat , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return mat [ 0 ] [ 0 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE maxSum = INT_MIN NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ n - 1 ] [ j ] = mat [ n - 1 ] [ j ] NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxi = INT_MIN NEW_LINE if ( ( ( ( j - 1 ) >= 0 ) and ( maxi < dp [ i + 1 ] [ j - 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT if ( ( ( ( j + 1 ) < n ) and ( maxi < dp [ i + 1 ] [ j + 1 ] ) ) ) : NEW_LINE INDENT maxi = dp [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT dp [ i ] [ j ] = mat [ i ] [ j ] + maxi NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT if ( maxSum < dp [ 0 ] [ j ] ) : NEW_LINE INDENT maxSum = dp [ 0 ] [ j ] NEW_LINE DEDENT DEDENT return maxSum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 5 , 6 , 1 , 7 ] , [ - 2 , 10 , 8 , - 1 ] , [ 3 , - 7 , - 9 , 11 ] , [ 12 , - 4 , 2 , 6 ] ] NEW_LINE n = 4 NEW_LINE print ( " Maximum ▁ Sum = " , maxSum ( mat , n ) ) NEW_LINE DEDENT
def longestRepeatedSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT res = ' ' NEW_LINE i = n NEW_LINE j = n NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == dp [ i - 1 ] [ j - 1 ] + 1 ) : NEW_LINE INDENT res += str [ i - 1 ] NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT elif ( dp [ i ] [ j ] == dp [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT DEDENT res = ' ' . join ( reversed ( res ) ) NEW_LINE return res NEW_LINE DEDENT str = ' AABEBCDD ' NEW_LINE print ( longestRepeatedSubSeq ( str ) ) NEW_LINE
def ElementsCalculationFunc ( pre , maxx , x , k , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = x NEW_LINE while j <= n : NEW_LINE INDENT if ( x * maxx [ j ] - ( pre [ j ] - pre [ i ] ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT def MaxNumberOfElements ( a , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT pre [ i ] = 0 NEW_LINE maxx [ i ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + a [ i - 1 ] NEW_LINE maxx [ i ] = max ( maxx [ i - 1 ] , a [ i - 1 ] ) NEW_LINE DEDENT l = 1 NEW_LINE r = n NEW_LINE while ( l < r ) : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if ( ElementsCalculationFunc ( pre , maxx , mid - 1 , k , n ) ) : NEW_LINE INDENT ans = mid NEW_LINE l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE MaxNumberOfElements ( arr , n , k ) NEW_LINE DEDENT
MAX = 50 NEW_LINE def solve ( dp , a , low , high , turn ) : NEW_LINE INDENT if ( low == high ) : NEW_LINE INDENT return a [ low ] * turn NEW_LINE DEDENT if ( dp [ low ] [ high ] != 0 ) : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT dp [ low ] [ high ] = max ( a [ low ] * turn + solve ( dp , a , low + 1 , high , turn + 1 ) , a [ high ] * turn + solve ( dp , a , low , high - 1 , turn + 1 ) ) ; NEW_LINE return dp [ low ] [ high ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 1 , 5 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE dp = [ [ 0 for x in range ( MAX ) ] for y in range ( MAX ) ] NEW_LINE print ( solve ( dp , arr , 0 , n - 1 , 1 ) ) NEW_LINE DEDENT
def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT msis = [ None ] * n NEW_LINE msds = [ None ] * n NEW_LINE max_sum = 0 NEW_LINE msis [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT msis [ i ] = msis [ i - 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT msds [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT msds [ i ] = msds [ i + 1 ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT msds [ i ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max_sum < ( msis [ i ] + msds [ i ] - arr [ i ] ) ) : NEW_LINE INDENT max_sum = ( msis [ i ] + msds [ i ] - arr [ i ] ) NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ Sum ▁ = ▁ " + str ( maxSumBitonicSubArr ( arr , n ) ) ) NEW_LINE
def countWays ( n , m ) : NEW_LINE INDENT count = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT count [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i > m ) : NEW_LINE INDENT count [ i ] = count [ i - 1 ] + count [ i - m ] NEW_LINE DEDENT elif ( i < m or i == 1 ) : NEW_LINE INDENT count [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 2 NEW_LINE DEDENT DEDENT return count [ n ] NEW_LINE DEDENT n = 7 NEW_LINE m = 4 NEW_LINE print ( " Number ▁ of ▁ ways ▁ = ▁ " , countWays ( n , m ) ) NEW_LINE
MAX = 100 NEW_LINE def largestZigZagSumRec ( mat , i , j , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return mat [ i ] [ j ] NEW_LINE DEDENT zzs = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( k != j ) : NEW_LINE INDENT zzs = max ( zzs , largestZigZagSumRec ( mat , i + 1 , k , n ) ) NEW_LINE DEDENT DEDENT return zzs + mat [ i ] [ j ] NEW_LINE DEDENT def largestZigZag ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT res = max ( res , largestZigZagSumRec ( mat , 0 , j , n ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE mat = [ [ 4 , 2 , 1 ] , [ 3 , 9 , 6 ] , [ 11 , 3 , 15 ] ] NEW_LINE print ( " Largest ▁ zigzag ▁ sum : ▁ " , largestZigZag ( mat , n ) ) NEW_LINE DEDENT
def countStr ( n , bCount , cCount ) : NEW_LINE INDENT if ( bCount < 0 or cCount < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bCount == 0 and cCount == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = countStr ( n - 1 , bCount , cCount ) NEW_LINE res += countStr ( n - 1 , bCount - 1 , cCount ) NEW_LINE res += countStr ( n - 1 , bCount , cCount - 1 ) NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( countStr ( n , 1 , 2 ) ) NEW_LINE DEDENT
' NEW_LINE N = 4 NEW_LINE def MaximumPath ( Mat ) : NEW_LINE INDENT result = 0 NEW_LINE DEDENT ' NEW_LINE INDENT dp = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N ) ] NEW_LINE DEDENT / * initialize all dp matrix as '0' * / NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i - 1 ] [ j - 1 ] , max ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ j + 1 ] ) ) + Mat [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ' NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT result = max ( result , dp [ N - 1 ] [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT Mat = [ [ 4 , 2 , 3 , 4 ] , [ 2 , 9 , 1 , 10 ] , [ 15 , 1 , 3 , 0 ] , [ 16 , 92 , 41 , 44 ] ] NEW_LINE print ( MaximumPath ( Mat ) ) NEW_LINE
from math import log2 NEW_LINE MAX = 100001 NEW_LINE dp = [ 0 ] * MAX NEW_LINE def probability ( k , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( k , n + 1 ) : NEW_LINE INDENT res = dp [ n ] - dp [ i ] - dp [ n - i ] - n NEW_LINE ans = ans + pow ( 2.0 , res ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def precompute ( ) : NEW_LINE INDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT dp [ i ] = log2 ( i ) + dp [ i - 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT precompute ( ) NEW_LINE print ( probability ( 2 , 3 ) ) NEW_LINE print ( probability ( 3 , 6 ) ) NEW_LINE print ( probability ( 500 , 1000 ) ) NEW_LINE DEDENT
def printMaxSum ( arr , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = arr [ i ] NEW_LINE maxi = 0 NEW_LINE for j in range ( 1 , int ( ( i + 1 ) ** 0.5 ) + 1 ) : NEW_LINE INDENT if ( ( i + 1 ) % j == 0 and ( i + 1 ) != j ) : NEW_LINE INDENT if ( dp [ j - 1 ] > maxi ) : NEW_LINE INDENT maxi = dp [ j - 1 ] NEW_LINE DEDENT if ( dp [ ( i + 1 ) // j - 1 ] > maxi and j != 1 ) : NEW_LINE INDENT maxi = dp [ ( i + 1 ) // j - 1 ] NEW_LINE DEDENT DEDENT DEDENT dp [ i ] += maxi NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( dp [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 1 , 4 , 6 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE / * Function calling * / NEW_LINE printMaxSum ( arr , n ) NEW_LINE
def maxAlternateSum ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT min = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( min > arr [ i ] ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT if ( arr [ 0 ] == min ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT dec = [ 0 for i in range ( n + 1 ) ] NEW_LINE inc = [ 0 for i in range ( n + 1 ) ] NEW_LINE dec [ 0 ] = inc [ 0 ] = arr [ 0 ] NEW_LINE flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT dec [ i ] = max ( dec [ i ] , inc [ j ] + arr [ i ] ) NEW_LINE flag = 1 NEW_LINE DEDENT elif ( arr [ j ] < arr [ i ] and flag == 1 ) : NEW_LINE INDENT inc [ i ] = max ( inc [ i ] , dec [ j ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT result = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( result < inc [ i ] ) : NEW_LINE INDENT result = inc [ i ] NEW_LINE DEDENT if ( result < dec [ i ] ) : NEW_LINE INDENT result = dec [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 8 , 2 , 3 , 5 , 7 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ sum ▁ = ▁ " , maxAlternateSum ( arr , n ) ) NEW_LINE
def pad ( n ) : NEW_LINE INDENT pPrevPrev , pPrev , pCurr , pNext = 1 , 1 , 1 , 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT pNext = pPrevPrev + pPrev NEW_LINE pPrevPrev = pPrev NEW_LINE pPrev = pCurr NEW_LINE pCurr = pNext NEW_LINE DEDENT return pNext ; NEW_LINE DEDENT print pad ( 12 ) NEW_LINE
def lucas ( n ) : NEW_LINE INDENT a = 2 NEW_LINE b = 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return b NEW_LINE DEDENT n = 9 NEW_LINE print ( lucas ( n ) ) NEW_LINE
MAX = 1000000 NEW_LINE def breakSum ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ int ( i / 2 ) ] + dp [ int ( i / 3 ) ] + dp [ int ( i / 4 ) ] , i ) ; NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT n = 24 NEW_LINE print ( breakSum ( n ) ) NEW_LINE
def minTime ( arr , n ) : NEW_LINE INDENT if ( n <= 0 ) : return 0 NEW_LINE DEDENT incl = arr [ 0 ] NEW_LINE excl = 0 NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT incl_new = arr [ i ] + min ( excl , incl ) NEW_LINE excl_new = incl NEW_LINE incl = incl_new NEW_LINE excl = excl_new NEW_LINE DEDENT return min ( incl , excl ) NEW_LINE DEDENT arr1 = [ 10 , 5 , 2 , 7 , 10 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( minTime ( arr1 , n1 ) ) NEW_LINE arr2 = [ 10 , 5 , 7 , 10 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( minTime ( arr2 , n2 ) ) NEW_LINE arr3 = [ 10 , 5 , 2 , 4 , 8 , 6 , 7 , 10 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE print ( minTime ( arr3 , n3 ) ) NEW_LINE
def multiply ( a , b ) : NEW_LINE INDENT mul = [ [ 0 for x in range ( 3 ) ] for y in range ( 3 ) ] ; NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] = 0 ; NEW_LINE for k in range ( 3 ) : NEW_LINE INDENT mul [ i ] [ j ] += a [ i ] [ k ] * b [ k ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE a [ i ] [ j ] = mul [ i ] [ j ] ; NEW_LINE DEDENT return a ; NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; NEW_LINE DEDENT power ( F , int ( n / 2 ) ) ; NEW_LINE F = multiply ( F , F ) ; NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT F = multiply ( F , M ) ; NEW_LINE DEDENT return F [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] ; NEW_LINE DEDENT def findNthTerm ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] ; NEW_LINE return power ( F , n - 2 ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( " F ( 5 ) ▁ is " , findNthTerm ( n ) ) ; NEW_LINE
def count ( n ) : NEW_LINE INDENT dp = [ 0 for _ in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if i <= 3 : NEW_LINE INDENT dp [ i ] = 1 NEW_LINE DEDENT elif i == 4 : NEW_LINE INDENT dp [ i ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 4 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT n = 5 NEW_LINE print ( " Count ▁ of ▁ ways ▁ is " ) , NEW_LINE print ( count ( n ) ) NEW_LINE
def nCrModp ( n , r , p ) : NEW_LINE INDENT if ( r > n - r ) : NEW_LINE INDENT r = n - r NEW_LINE DEDENT C = [ 0 for i in range ( r + 1 ) ] NEW_LINE C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , r ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = ( C [ j ] + C [ j - 1 ] ) % p NEW_LINE DEDENT DEDENT return C [ r ] NEW_LINE DEDENT n = 10 NEW_LINE r = 2 NEW_LINE p = 13 NEW_LINE print ( ' Value ▁ of ▁ nCr ▁ % ▁ p ▁ is ' , nCrModp ( n , r , p ) ) NEW_LINE
/ * Function to find n ' th Bell Number * / NEW_LINE def bellNumber ( n ) : NEW_LINE INDENT bell = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE bell [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bell [ i ] [ 0 ] = bell [ i - 1 ] [ i - 1 ] NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT bell [ i ] [ j ] = bell [ i - 1 ] [ j - 1 ] + bell [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return bell [ n ] [ 0 ] NEW_LINE DEDENT for n in range ( 6 ) : NEW_LINE INDENT print ( ' Bell ▁ Number ' , n , ' is ' , bellNumber ( n ) ) NEW_LINE DEDENT
def printCountDP ( dist ) : NEW_LINE INDENT count = [ 0 ] * ( dist + 1 ) NEW_LINE count [ 0 ] = 1 NEW_LINE if dist >= 1 : NEW_LINE INDENT count [ 1 ] = 1 NEW_LINE DEDENT if dist >= 2 : NEW_LINE INDENT count [ 2 ] = 2 NEW_LINE DEDENT for i in range ( 3 , dist + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + count [ i - 2 ] + count [ i - 3 ] ) NEW_LINE DEDENT return count [ dist ] ; NEW_LINE DEDENT dist = 4 ; NEW_LINE print ( printCountDP ( dist ) ) NEW_LINE
def countSeq ( n ) : NEW_LINE INDENT nCr = 1 NEW_LINE res = 1 NEW_LINE for r in range ( 1 , n + 1 ) : NEW_LINE INDENT nCr = ( nCr * ( n + 1 - r ) ) / r ; NEW_LINE res += nCr * nCr ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT n = 2 NEW_LINE print ( " Count ▁ of ▁ sequences ▁ is " ) , NEW_LINE print ( int ( countSeq ( n ) ) ) NEW_LINE
/ * A utility function to find minimum of two numbers * / NEW_LINE def min1 ( arr , l , h ) : NEW_LINE INDENT mn = arr [ l ] ; NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( mn > arr [ i ] ) : NEW_LINE INDENT mn = arr [ i ] ; NEW_LINE DEDENT DEDENT return mn ; NEW_LINE DEDENT def max1 ( arr , l , h ) : NEW_LINE INDENT mx = arr [ l ] ; NEW_LINE for i in range ( l + 1 , h + 1 ) : NEW_LINE INDENT if ( mx < arr [ i ] ) : NEW_LINE INDENT mx = arr [ i ] ; NEW_LINE DEDENT DEDENT return mx ; NEW_LINE DEDENT def minRemovalsDP ( arr , n ) : NEW_LINE INDENT table = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] ; NEW_LINE for gap in range ( n ) : NEW_LINE INDENT i = 0 ; NEW_LINE for j in range ( gap , n ) : NEW_LINE INDENT mn = min1 ( arr , i , j ) ; NEW_LINE mx = max1 ( arr , i , j ) ; NEW_LINE table [ i ] [ j ] = 0 if ( 2 * mn > mx ) else min ( table [ i ] [ j - 1 ] + 1 , table [ i + 1 ] [ j ] + 1 ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT return table [ 0 ] [ n - 1 ] ; NEW_LINE DEDENT arr = [ 20 , 4 , 1 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( minRemovalsDP ( arr , n ) ) ; NEW_LINE
def numberOfPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE DEDENT m = 3 NEW_LINE n = 3 NEW_LINE print ( numberOfPaths ( m , n ) ) NEW_LINE
def numberOfPaths ( m , n ) : NEW_LINE INDENT for i in range ( n , ( m + n - 1 ) ) : NEW_LINE INDENT path *= i ; NEW_LINE path //= ( i - n + 1 ) ; NEW_LINE DEDENT return path ; NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) ; NEW_LINE
def lenghtOfLongestAP ( set , n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE llap = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE DEDENT for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while ( i >= 0 and k <= n - 1 ) : NEW_LINE INDENT if ( set [ i ] + set [ k ] < 2 * set [ j ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif ( set [ i ] + set [ k ] > 2 * set [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE llap = max ( llap , L [ i ] [ j ] ) NEW_LINE i -= 1 NEW_LINE k += 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return llap NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT set1 = [ 1 , 7 , 10 , 13 , 14 , 19 ] NEW_LINE n1 = len ( set1 ) NEW_LINE print ( lenghtOfLongestAP ( set1 , n1 ) ) NEW_LINE set2 = [ 1 , 7 , 10 , 15 , 27 , 29 ] NEW_LINE n2 = len ( set2 ) NEW_LINE print ( lenghtOfLongestAP ( set2 , n2 ) ) NEW_LINE set3 = [ 2 , 4 , 6 , 8 , 10 ] NEW_LINE n3 = len ( set3 ) NEW_LINE print ( lenghtOfLongestAP ( set3 , n3 ) ) NEW_LINE DEDENT
def lbs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT lds = [ 1 for i in range ( n + 1 ) ] NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT maximum = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT arr = [ 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 ] NEW_LINE print " Length ▁ of ▁ LBS ▁ is " , lbs ( arr ) NEW_LINE
INT_MAX = 32767 NEW_LINE def eggDrop ( n , k ) : NEW_LINE INDENT eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ 1 ] = 1 NEW_LINE eggFloor [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT eggFloor [ 1 ] [ j ] = j NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , k + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ j ] = INT_MAX NEW_LINE for x in range ( 1 , j + 1 ) : NEW_LINE INDENT res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) NEW_LINE if res < eggFloor [ i ] [ j ] : NEW_LINE INDENT eggFloor [ i ] [ j ] = res NEW_LINE DEDENT DEDENT DEDENT DEDENT return eggFloor [ n ] [ k ] NEW_LINE DEDENT n = 2 NEW_LINE k = 36 NEW_LINE print ( " Minimum ▁ number ▁ of ▁ trials ▁ in ▁ worst ▁ case ▁ with " + str ( n ) + " eggs ▁ and ▁ " + str ( k ) + " ▁ floors ▁ is ▁ " + str ( eggDrop ( n , k ) ) ) NEW_LINE
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE print knapSack ( W , wt , val , n ) NEW_LINE
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT def countBST ( n ) : NEW_LINE INDENT count = catalan ( n ) NEW_LINE return count NEW_LINE DEDENT def countBT ( n ) : NEW_LINE INDENT count = catalan ( n ) NEW_LINE return count * factorial ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE count1 = countBST ( n ) NEW_LINE count2 = countBT ( n ) NEW_LINE print ( " Count ▁ of ▁ BST ▁ with " , n , " nodes ▁ is " , count1 ) NEW_LINE print ( " Count ▁ of ▁ binary ▁ trees ▁ with " , n , " nodes ▁ is " , count2 ) NEW_LINE DEDENT
def printPermutation ( N , K ) : NEW_LINE INDENT res = list ( ) ; NEW_LINE l , r , flag = 1 , N , 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT if flag == False : NEW_LINE INDENT res . append ( l ) NEW_LINE l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res . append ( r ) ; NEW_LINE r -= 1 ; NEW_LINE DEDENT flag = flag ^ 1 ; NEW_LINE DEDENT if flag == False : NEW_LINE INDENT for i in range ( r , 2 , - 1 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( l , r ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT for i in res : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT N , K = 10 , 4 NEW_LINE printPermutation ( N , K ) NEW_LINE
def fact ( N ) : NEW_LINE INDENT product = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = product * i NEW_LINE DEDENT return product NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( N * N ) * fact ( N ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
d = 256 NEW_LINE def search ( pat , txt , q ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE h = 1 NEW_LINE for i in xrange ( M - 1 ) : NEW_LINE INDENT h = ( h * d ) % q NEW_LINE DEDENT for i in xrange ( M ) : NEW_LINE INDENT p = ( d * p + ord ( pat [ i ] ) ) % q NEW_LINE t = ( d * t + ord ( txt [ i ] ) ) % q NEW_LINE DEDENT for i in xrange ( N - M + 1 ) : NEW_LINE INDENT if p == t : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT else : j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT print " Pattern ▁ found ▁ at ▁ index ▁ " + str ( i ) NEW_LINE DEDENT DEDENT if i < N - M : NEW_LINE INDENT t = ( d * ( t - ord ( txt [ i ] ) * h ) + ord ( txt [ i + M ] ) ) % q NEW_LINE if t < 0 : NEW_LINE INDENT t = t + q NEW_LINE DEDENT DEDENT DEDENT DEDENT txt = " GEEKS ▁ FOR ▁ GEEKS " NEW_LINE pat = " GEEK " NEW_LINE q = 101 NEW_LINE search ( pat , txt , q ) NEW_LINE
def number_of_tower ( house , r , n ) : NEW_LINE INDENT house . sort ( ) NEW_LINE numOfTower = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT numOfTower += 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE loc = house [ i ] + r NEW_LINE while ( i < n and house [ i ] <= loc ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return numOfTower NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT house = [ 7 , 2 , 4 , 6 , 5 , 9 , 12 , 11 ] NEW_LINE r = 2 NEW_LINE n = len ( house ) NEW_LINE print ( number_of_tower ( house , r , n ) ) NEW_LINE DEDENT
MAX = 1000 NEW_LINE def findDuplicate ( arr , n , k ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 1 and arr [ i ] > MAX ) : NEW_LINE INDENT print " Out ▁ of ▁ range " NEW_LINE return - 1 NEW_LINE DEDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 1 , 3 , 1 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print findDuplicate ( arr , n , k ) NEW_LINE
def pendulumArrangement ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE op = [ 0 ] * n NEW_LINE mid = int ( ( n - 1 ) / 2 ) NEW_LINE j = 1 NEW_LINE i = 1 NEW_LINE op [ mid ] = arr [ 0 ] NEW_LINE for i in range ( 1 , mid + 1 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE op [ mid - i ] = arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT if ( int ( n % 2 ) == 0 ) : NEW_LINE INDENT op [ mid + i ] = arr [ j ] NEW_LINE DEDENT print ( " Pendulum ▁ arrangement : " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( op [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 14 , 6 , 19 , 21 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE pendulumArrangement ( arr , n ) NEW_LINE
MAX = 256 NEW_LINE freq = [ [ 0 for i in range ( 256 ) ] for j in range ( 1000 ) ] NEW_LINE def preCalculate ( string , n ) : NEW_LINE INDENT freq [ ord ( string [ 0 ] ) ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE for j in range ( MAX ) : NEW_LINE INDENT charToUpdate = chr ( j ) NEW_LINE if charToUpdate == ch : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT freq [ j ] [ i ] = freq [ j ] [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def getFrequency ( ch , l , r ) : NEW_LINE INDENT if l == 0 : NEW_LINE INDENT return freq [ ord ( ch ) ] [ r ] NEW_LINE DEDENT else : NEW_LINE INDENT return ( freq [ ord ( ch ) ] [ r ] - freq [ ord ( ch ) ] [ l - 1 ] ) NEW_LINE DEDENT DEDENT def lastNonRepeating ( string , n , l , r ) : NEW_LINE INDENT for i in range ( r , l - 1 , - 1 ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE if getFrequency ( ch , l , r ) == 1 : NEW_LINE INDENT return ch NEW_LINE DEDENT DEDENT return " - 1" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksForGeeks " NEW_LINE n = len ( string ) NEW_LINE queries = [ ( 2 , 9 ) , ( 2 , 3 ) , ( 0 , 12 ) ] NEW_LINE q = len ( queries ) NEW_LINE preCalculate ( string , n ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( lastNonRepeating ( string , n , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) NEW_LINE DEDENT DEDENT
def minCost ( str1 , K ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 999999999 NEW_LINE count = 0 NEW_LINE cnt = [ 0 for i in range ( 27 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ ord ( str1 [ i ] ) - ord ( ' a ' ) + 1 ] += 1 NEW_LINE DEDENT for i in range ( 1 , 26 - K + 1 , 1 ) : NEW_LINE INDENT a = i NEW_LINE b = i + K NEW_LINE count = 0 NEW_LINE for j in range ( 1 , 27 , 1 ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT if ( j >= a and j >= b ) : NEW_LINE INDENT count = count + ( min ( j - b , 25 - j + a + 1 ) ) * cnt [ j ] NEW_LINE DEDENT elif ( j <= a and j <= b ) : NEW_LINE INDENT count = count + ( min ( a - j , 25 + j - b + 1 ) ) * cnt [ j ] NEW_LINE DEDENT DEDENT DEDENT res = min ( res , count ) NEW_LINE DEDENT for i in range ( 26 - K + 1 , 27 , 1 ) : NEW_LINE INDENT a = i NEW_LINE b = ( i + K ) % 26 NEW_LINE count = 0 NEW_LINE for j in range ( 1 , 27 , 1 ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT if ( j >= b and j <= a ) : NEW_LINE INDENT count = count + ( min ( j - b , a - j ) ) * cnt [ j ] NEW_LINE DEDENT DEDENT DEDENT res = min ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = " abcdefghi " NEW_LINE K = 2 NEW_LINE print ( minCost ( str1 , K ) ) NEW_LINE DEDENT
def printLastChar ( string ) : NEW_LINE INDENT string = string + " ▁ " NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] == ' ▁ ' : NEW_LINE INDENT print ( string [ i - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT string = " Geeks ▁ for ▁ Geeks " NEW_LINE printLastChar ( string ) NEW_LINE
def maxBalancedStr ( s ) : NEW_LINE INDENT open1 = 0 NEW_LINE close1 = 0 NEW_LINE open2 = 0 NEW_LINE close2 = 0 NEW_LINE open3 = 0 NEW_LINE close3 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : open1 += 1 continue if s [ i ] == ' ) ' : NEW_LINE INDENT close1 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' { ' : NEW_LINE INDENT open2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' } ' : NEW_LINE INDENT close2 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' [ ' : NEW_LINE INDENT open3 += 1 NEW_LINE continue NEW_LINE DEDENT if s [ i ] == ' ] ' : NEW_LINE INDENT close3 += 1 NEW_LINE continue NEW_LINE DEDENT DEDENT maxLen = ( 2 * min ( open1 , close1 ) + 2 * min ( open2 , close2 ) + 2 * min ( open3 , close3 ) ) NEW_LINE return maxLen NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : s = " ) ) [ ] ] ( ( " NEW_LINE INDENT print ( maxBalancedStr ( s ) ) NEW_LINE DEDENT
def extractSecretMessage ( Str , Sub ) : NEW_LINE INDENT Str = Str . replace ( Sub , " ▁ " ) NEW_LINE return Str . strip ( ) NEW_LINE DEDENT Str = " LIELIEILIEAMLIECOOL " NEW_LINE Sub = " LIE " NEW_LINE print ( extractSecretMessage ( Str , Sub ) ) NEW_LINE
def binarySearch ( arr , x ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( arr ) NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = l + ( ( r - l ) // 2 ) NEW_LINE res = ( x == arr [ m ] ) NEW_LINE if ( res == 0 ) : NEW_LINE INDENT return m - 1 NEW_LINE DEDENT if ( res > 0 ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ " contribute " , " geeks " , " ide " , " practice " ] ; NEW_LINE x = " ide " NEW_LINE result = binarySearch ( arr , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ not ▁ present " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ found ▁ at ▁ index " , result ) NEW_LINE DEDENT DEDENT
def getStudentsList ( file ) : NEW_LINE INDENT maxAvgScore = 0 NEW_LINE names = [ ] NEW_LINE for i in range ( 0 , len ( file ) , 4 ) : NEW_LINE INDENT avgScore = ( int ( file [ i + 1 ] ) + int ( file [ i + 2 ] ) + int ( file [ i + 3 ] ) ) // 3 NEW_LINE if avgScore > maxAvgScore : NEW_LINE INDENT maxAvgScore = avgScore NEW_LINE names . clear ( ) NEW_LINE names . append ( file [ i ] ) NEW_LINE DEDENT elif avgScore == maxAvgScore : NEW_LINE INDENT names . add ( file [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( len ( names ) ) : NEW_LINE INDENT print ( names [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( maxAvgScore ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT file = [ " Shrikanth " , "20" , "30" , "10" , " Ram " , "100" , "50" , "10" ] NEW_LINE getStudentsList ( file ) NEW_LINE DEDENT
def strScore ( str , s , n ) : NEW_LINE INDENT score = 0 NEW_LINE index = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == s ) : NEW_LINE INDENT for j in range ( len ( s ) ) : NEW_LINE INDENT score += ( ord ( s [ j ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT index = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT score = score * index NEW_LINE return score NEW_LINE DEDENT str = [ " sahil " , " shashanak " , " sanjit " , " abhinav " , " mohit " ] NEW_LINE s = " abhinav " NEW_LINE n = len ( str ) NEW_LINE score = strScore ( str , s , n ) ; NEW_LINE print ( score ) NEW_LINE
def minParentheses ( p ) : NEW_LINE INDENT bal = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , len ( p ) ) : NEW_LINE INDENT if ( p [ i ] == ' ( ' ) : NEW_LINE INDENT bal += 1 NEW_LINE DEDENT else : NEW_LINE INDENT bal += - 1 NEW_LINE DEDENT if ( bal == - 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE bal += 1 NEW_LINE DEDENT DEDENT return bal + ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = " ( ) ) " NEW_LINE print ( minParentheses ( p ) ) NEW_LINE DEDENT
def isPalindrome ( r ) : NEW_LINE INDENT p = r [ : : - 1 ] NEW_LINE return r == p NEW_LINE DEDENT def CheckStr ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE i = 0 NEW_LINE for i in range ( 2 , l + 1 ) : NEW_LINE INDENT if isPalindrome ( s [ 0 : i ] ) == True : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if i == ( l + 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , l + 1 ) : NEW_LINE INDENT if isPalindrome ( s [ l - i : l ] ) == True : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abccbarfgdbd " NEW_LINE if CheckStr ( s ) == True : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def oddEquivalent ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "1011011" NEW_LINE n = len ( s ) NEW_LINE print ( oddEquivalent ( s , n ) ) NEW_LINE DEDENT
import sys NEW_LINE def findNumberOfTimes ( str1 , str2 ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l1 = len ( str1 ) NEW_LINE freq2 = [ 0 ] * 26 NEW_LINE l2 = len ( str2 ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( " a " ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( " a " ) ] += 1 NEW_LINE DEDENT count = sys . maxsize NEW_LINE for i in range ( l2 ) : NEW_LINE count = min ( count , freq [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] / freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] ) NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = " foreeksgekseg " NEW_LINE str2 = " geeks " NEW_LINE print ( findNumberOfTimes ( str1 , str2 ) ) NEW_LINE DEDENT
def solve ( s1 , s2 ) : NEW_LINE INDENT flag1 = 0 NEW_LINE flag2 = 0 NEW_LINE if ( len ( s1 ) != len ( s2 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT l = len ( s1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( s1 [ i ] == '1' ) : NEW_LINE INDENT flag1 = 1 ; NEW_LINE DEDENT if ( s2 [ i ] == '1' ) : NEW_LINE INDENT flag2 = 1 NEW_LINE DEDENT if ( flag1 & flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ! flag1 &   ! flag2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s1 = "100101" NEW_LINE s2 = "100000" NEW_LINE if solve ( s1 , s2 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def subzero ( str , k ) : NEW_LINE INDENT ans = 0 NEW_LINE curr = 0 NEW_LINE n = len ( str ) NEW_LINE for i in str : NEW_LINE INDENT if ( i == '0' ) : NEW_LINE INDENT curr += 1 NEW_LINE DEDENT else : NEW_LINE INDENT curr = 0 NEW_LINE DEDENT ans = max ( ans , curr ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( ans == n ) : NEW_LINE INDENT print ( n * k ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT pre = suff = 0 NEW_LINE for i in str : NEW_LINE INDENT if ( i == '0' ) : NEW_LINE INDENT pre += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT suff += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if ( k > 1 ) : NEW_LINE INDENT ans = max ( ans , pre + suff ) NEW_LINE DEDENT print ( ans ) NEW_LINE return NEW_LINE DEDENT k = 5 NEW_LINE str = '00100110' NEW_LINE subzero ( str , k ) NEW_LINE
def countNonEmptySubstr ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE return int ( n * ( n + 1 ) / 2 ) ; NEW_LINE DEDENT s = " abcde " ; NEW_LINE print ( countNonEmptySubstr ( s ) ) ; NEW_LINE
MAX = 26 NEW_LINE def targetstring ( str1 , str2 ) : NEW_LINE INDENT l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE if ( l1 != l2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT map = [ 0 ] * MAX NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT map [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT map [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE if ( map [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " geeksforgeeks " NEW_LINE str2 = " geegeeksksfor " NEW_LINE if ( targetstring ( str1 , str2 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def isDigitPresent ( x , d ) : NEW_LINE INDENT while ( x > 0 ) : NEW_LINE INDENT if ( x % 10 == d ) : NEW_LINE INDENT break NEW_LINE DEDENT x = x / 10 NEW_LINE DEDENT return ( x > 0 ) NEW_LINE DEDENT def printNumbers ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if ( i == d or isDigitPresent ( i , d ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 47 NEW_LINE d = 7 NEW_LINE print ( " The ▁ number ▁ of ▁ values ▁ are " ) NEW_LINE printNumbers ( n , d ) NEW_LINE
def findExtraCharcter ( strA , strB ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , len ( strA ) ) : NEW_LINE INDENT res = res ^ ( ord ) ( strA [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( strB ) ) : NEW_LINE INDENT res = res ^ ( ord ) ( strB [ i ] ) NEW_LINE DEDENT return ( ( chr ) ( res ) ) ; NEW_LINE DEDENT strA = " abcd " NEW_LINE strB = " cbdad " NEW_LINE print ( findExtraCharcter ( strA , strB ) ) NEW_LINE
def calculateSum ( arr , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT s = arr [ 0 ] NEW_LINE value = int ( s ) NEW_LINE sum = value NEW_LINE for i in range ( 2 , n , 2 ) : NEW_LINE INDENT s = arr [ i ] NEW_LINE value = int ( s ) NEW_LINE operation = arr [ i - 1 ] [ 0 ] NEW_LINE if ( operation == ' + ' ) : NEW_LINE INDENT sum += value NEW_LINE DEDENT else : NEW_LINE INDENT sum -= value NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ "3" , " + " , "4" , " - " , "7" , " + " , "13" ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateSum ( arr , n ) ) NEW_LINE
def LargestString ( na ) : NEW_LINE INDENT N = len ( na ) NEW_LINE c = [ 0 ] * N NEW_LINE m = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT character = [ False ] * 26 NEW_LINE for k in range ( len ( na [ j ] ) ) : NEW_LINE INDENT x = ord ( na [ j ] [ k ] ) - ord ( ' A ' ) NEW_LINE if ( ( na [ j ] [ k ] != ' ▁ ' ) and ( character [ x ] == False ) ) : NEW_LINE INDENT c [ j ] += 1 NEW_LINE character [ x ] = True NEW_LINE DEDENT if ( c [ j ] > c [ m ] ) : NEW_LINE INDENT m = j NEW_LINE DEDENT DEDENT DEDENT print ( na [ m ] ) NEW_LINE DEDENT na = [ " BOB " , " A ▁ AB ▁ C ▁ JOHNSON " , " ANJALI " , " ASKRIT " , " ARMAN ▁ MALLIK " ] NEW_LINE LargestString ( na ) NEW_LINE
def morseEncode ( x ) : NEW_LINE INDENT if x is ' a ' : NEW_LINE INDENT return " . - " NEW_LINE DEDENT elif x is ' b ' : NEW_LINE INDENT return " - . . . " NEW_LINE DEDENT elif x is ' c ' : NEW_LINE INDENT return " - . - . " NEW_LINE DEDENT elif x is ' d ' : NEW_LINE INDENT return " - . . " NEW_LINE DEDENT elif x is ' e ' : NEW_LINE INDENT return " . " NEW_LINE DEDENT elif x is ' f ' : NEW_LINE INDENT return " . . - . " NEW_LINE DEDENT elif x is ' g ' : NEW_LINE INDENT return " - - . " NEW_LINE DEDENT elif x is ' h ' : NEW_LINE INDENT return " . . . . " NEW_LINE DEDENT elif x is ' i ' : NEW_LINE INDENT return " . . " NEW_LINE DEDENT elif x is ' j ' : NEW_LINE INDENT return " . - - - " NEW_LINE DEDENT elif x is ' k ' : NEW_LINE INDENT return " - . - " NEW_LINE DEDENT elif x is ' l ' : NEW_LINE INDENT return " . - . . " NEW_LINE DEDENT elif x is ' m ' : NEW_LINE INDENT return " - - " NEW_LINE DEDENT elif x is ' n ' : NEW_LINE INDENT return " - . " NEW_LINE DEDENT elif x is ' o ' : NEW_LINE INDENT return " - - - " NEW_LINE DEDENT elif x is ' p ' : NEW_LINE INDENT return " . - - . " NEW_LINE DEDENT elif x is ' q ' : NEW_LINE INDENT return " - - . - " NEW_LINE DEDENT elif x is ' r ' : NEW_LINE INDENT return " . - . " NEW_LINE DEDENT elif x is ' s ' : NEW_LINE INDENT return " . . . " NEW_LINE DEDENT elif x is ' t ' : NEW_LINE INDENT return " - " NEW_LINE DEDENT elif x is ' u ' : NEW_LINE INDENT return " . . - " NEW_LINE DEDENT elif x is ' v ' : NEW_LINE INDENT return " . . . - " NEW_LINE DEDENT elif x is ' w ' : NEW_LINE INDENT return " . - - " NEW_LINE DEDENT elif x is ' x ' : NEW_LINE INDENT return " - . . - " NEW_LINE DEDENT elif x is ' y ' : NEW_LINE INDENT return " - . - - " NEW_LINE DEDENT elif x is ' z ' : NEW_LINE INDENT return " - - . . " NEW_LINE DEDENT elif x is '1' : NEW_LINE INDENT return " . - - - - " ; NEW_LINE DEDENT elif x is '2' : NEW_LINE INDENT return " . . - - - " ; NEW_LINE DEDENT elif x is '3' : NEW_LINE INDENT return " . . . - - " ; NEW_LINE DEDENT elif x is '4' : NEW_LINE INDENT return " . . . . - " ; NEW_LINE DEDENT elif x is '5' : NEW_LINE INDENT return " . . . . . " ; NEW_LINE DEDENT elif x is '6' : NEW_LINE INDENT return " - . . . . " ; NEW_LINE DEDENT elif x is '7' : NEW_LINE INDENT return " - - . . . " ; NEW_LINE DEDENT elif x is '8' : NEW_LINE INDENT return " - - - . . " ; NEW_LINE DEDENT elif x is '9' : NEW_LINE INDENT return " - - - - . " ; NEW_LINE DEDENT elif x is '0' : NEW_LINE INDENT return " - - - - - " ; NEW_LINE DEDENT DEDENT def morseCode ( s ) : NEW_LINE INDENT for character in s : NEW_LINE INDENT print ( morseEncode ( character ) , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE morseCode ( s ) NEW_LINE DEDENT
def polybiusCipher ( s ) : NEW_LINE INDENT for char in s : NEW_LINE INDENT row = int ( ( ord ( char ) - ord ( ' a ' ) ) / 5 ) + 1 NEW_LINE col = ( ( ord ( char ) - ord ( ' a ' ) ) % 5 ) + 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if char == ' k ' : NEW_LINE INDENT row = row - 1 NEW_LINE col = 5 - col + 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT elif ord ( char ) >= ord ( ' j ' ) : NEW_LINE INDENT if col == 1 : NEW_LINE INDENT col = 6 NEW_LINE row = row - 1 NEW_LINE DEDENT col = col - 1 NEW_LINE DEDENT print ( row , col , end = ' ' , sep = ' ' ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE polybiusCipher ( s ) NEW_LINE DEDENT
def minRemoval ( strr ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for char in strr : NEW_LINE INDENT hash [ ord ( char ) - ord ( ' a ' ) ] = hash [ ord ( char ) - ord ( ' a ' ) ] + 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if hash [ i ] % 2 : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return 0 if count == 0 else count - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT strr = " geeksforgeeks " ; NEW_LINE DEDENT
import math NEW_LINE def findLUSlength ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return max ( len ( a ) , len ( b ) ) NEW_LINE DEDENT a = " abcdabcd " NEW_LINE b = " abcabc " NEW_LINE print ( findLUSlength ( a , b ) ) NEW_LINE
def swapTwoHalves ( a , b ) : NEW_LINE INDENT la = len ( a ) NEW_LINE lb = len ( b ) NEW_LINE c = a [ 0 : la // 2 ] + b [ lb // 2 : lb ] NEW_LINE d = b [ 0 : lb // 2 ] + a [ la // 2 : la ] NEW_LINE print ( c ,   " " , d ) NEW_LINE DEDENT a = " remuneration " NEW_LINE b = " day " NEW_LINE / * Calling function * / NEW_LINE swapTwoHalves ( a , b ) NEW_LINE
def solve ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE parent = [ None ] * ( n + 1 ) NEW_LINE vis = [ None ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT parent [ i ] = - 1 NEW_LINE vis [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT j = i NEW_LINE if ( parent [ j ] == - 1 ) : NEW_LINE INDENT while ( parent [ j ] == - 1 ) : NEW_LINE INDENT parent [ j ] = i NEW_LINE j = ( j + A [ j ] + 1 ) % n NEW_LINE DEDENT if ( parent [ j ] == i ) : NEW_LINE INDENT while ( vis [ j ] == 0 ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE cnt = cnt + 1 NEW_LINE j = ( j + A [ j ] + 1 ) % n NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 0 , 0 , 0 , 2 ] NEW_LINE n = len ( A ) NEW_LINE print ( solve ( A , n ) ) NEW_LINE
def TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , min_diff , Sum , curr_sum , curr_position ) : NEW_LINE INDENT if ( curr_position == n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( ( int ( n / 2 ) - no_of_selected_elements ) > ( n - curr_position ) ) : NEW_LINE INDENT return NEW_LINE DEDENT TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , min_diff , Sum , curr_sum , curr_position + 1 ) NEW_LINE no_of_selected_elements += 1 NEW_LINE curr_sum = curr_sum + arr [ curr_position ] NEW_LINE curr_elements [ curr_position ] = True NEW_LINE if ( no_of_selected_elements == int ( n / 2 ) ) : NEW_LINE INDENT if ( abs ( int ( Sum / 2 ) - curr_sum ) < min_diff [ 0 ] ) : NEW_LINE INDENT min_diff [ 0 ] = abs ( int ( Sum / 2 ) - curr_sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT soln [ i ] = curr_elements [ i ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT TOWUtil ( arr , n , curr_elements , no_of_selected_elements , soln , min_diff , Sum , curr_sum , curr_position + 1 ) NEW_LINE DEDENT curr_elements [ curr_position ] = False NEW_LINE DEDENT def tugOfWar ( arr , n ) : NEW_LINE INDENT curr_elements = [ None ] * n NEW_LINE soln = [ None ] * n NEW_LINE min_diff = [ 999999999999 ] NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE curr_elements [ i ] = soln [ i ] = False NEW_LINE DEDENT TOWUtil ( arr , n , curr_elements , 0 , soln , min_diff , Sum , 0 , 0 ) NEW_LINE print ( " The ▁ first ▁ subset ▁ is : ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( soln [ i ] == True ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE print ( " The ▁ second ▁ subset ▁ is : ▁ " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( soln [ i ] == False ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 23 , 45 , - 34 , 12 , 0 , 98 , - 99 , 4 , 189 , - 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE tugOfWar ( arr , n ) NEW_LINE DEDENT
NO_OF_CHARS = 256 NEW_LINE def max_distinct_char ( str , n ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT max_distinct = 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT max_distinct += 1 NEW_LINE DEDENT DEDENT return max_distinct NEW_LINE DEDENT def smallesteSubstr_maxDistictChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE max_distinct = max_distinct_char ( str , n ) NEW_LINE minl = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT subs = str [ i : j ] NEW_LINE subs_lenght = len ( subs ) NEW_LINE sub_distinct_char = max_distinct_char ( subs , subs_lenght ) NEW_LINE if ( subs_lenght < minl and max_distinct == sub_distinct_char ) : NEW_LINE INDENT minl = subs_lenght NEW_LINE DEDENT DEDENT DEDENT return minl NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " AABBBCBB " NEW_LINE l = smallesteSubstr_maxDistictChar ( str ) ; NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ smallest ▁ substring " , " consisting ▁ of ▁ maximum ▁ distinct " , " characters ▁ : " , l ) NEW_LINE DEDENT
def evenNumSubstring ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , length , 1 ) : NEW_LINE INDENT temp = ord ( str [ i ] ) - ord ( '0' ) NEW_LINE if ( temp % 2 == 0 ) : NEW_LINE INDENT count += ( i + 1 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = [ '1' , '2' , '3' , '4' ] NEW_LINE print ( evenNumSubstring ( str ) ) NEW_LINE DEDENT
def findIndex ( a , n ) : NEW_LINE INDENT res , min_diff = None , float ( ' inf ' ) NEW_LINE prod = [ None ] * n NEW_LINE prod [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prod [ i ] = prod [ i - 1 ] * a [ i ] NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT curr_diff = abs ( ( prod [ n - 1 ] // prod [ i ] ) - prod [ i ] ) NEW_LINE if curr_diff < min_diff : NEW_LINE INDENT min_diff = curr_diff NEW_LINE res = i NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 5 , 7 , 2 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findIndex ( arr , N ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def printNumbers ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE g = gcd ( num , x ) NEW_LINE while ( g != 1 ) : NEW_LINE INDENT num //= g NEW_LINE g = gcd ( num , x ) NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT flag = True ; NEW_LINE print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if ( not flag ) : NEW_LINE INDENT print ( " There ▁ are ▁ no ▁ such ▁ numbers " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 60 NEW_LINE a = [ 2 , 5 , 10 , 7 , 17 ] NEW_LINE n = len ( a ) NEW_LINE printNumbers ( a , n , x ) NEW_LINE DEDENT
def printf ( rStation , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT print ( rStation [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " , ▁ end ▁ = ▁ "   " ) NEW_LINE DEDENT def radiated_Station ( station , n ) : NEW_LINE INDENT rStation = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT li = i - 1 NEW_LINE ri = i + 1 NEW_LINE lRad = station [ i ] - 1 NEW_LINE rRad = station [ i ] - 1 NEW_LINE rStation [ i ] += station [ i ] NEW_LINE while ( li >= 1 and lRad >= 1 ) : NEW_LINE INDENT rStation [ li ] += lRad NEW_LINE lRad -= 1 NEW_LINE li -= 1 NEW_LINE DEDENT while ( ri <= n and rRad >= 1 ) : NEW_LINE INDENT rStation [ ri ] += rRad NEW_LINE rRad -= 1 NEW_LINE ri += 1 NEW_LINE DEDENT DEDENT printf ( rStation , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT station = [ 0 , 7 , 9 , 12 , 2 , 5 ] NEW_LINE n = len ( station ) - 1 NEW_LINE radiated_Station ( station , n ) NEW_LINE DEDENT
def findMaximumDiff ( a , n ) : NEW_LINE INDENT ind1 = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ 0 ] != a [ i ] ) : NEW_LINE INDENT ind1 = i NEW_LINE break NEW_LINE DEDENT DEDENT ind2 = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ n - 1 ] != a [ i ] ) : NEW_LINE INDENT ind2 = ( n - 1 - i ) NEW_LINE break NEW_LINE DEDENT DEDENT return max ( ind1 , ind2 ) NEW_LINE DEDENT a = [ 1 , 2 , 3 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMaximumDiff ( a , n ) ) NEW_LINE
def sum ( k , n ) : NEW_LINE INDENT sum = ( pow ( k , n + 1 ) - pow ( k - 1 , n + 1 ) ) ; NEW_LINE return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE K = 3 ; NEW_LINE print ( sum ( K , n ) ) ; NEW_LINE
def is_prime ( num ) : NEW_LINE ' NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT if i * i > num : NEW_LINE INDENT break NEW_LINE DEDENT if ( ( num ) % i == 0 ) : NEW_LINE INDENT if ( i * i != ( num ) ) : NEW_LINE INDENT count += 2 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT if ( count == 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def is_divisible ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE DEDENT ' NEW_LINE INDENT if ( is_prime ( n + 1 ) ) : NEW_LINE INDENT return " NO " NEW_LINE DEDENT else : NEW_LINE INDENT return " YES " NEW_LINE DEDENT DEDENT n = 3 NEW_LINE print ( is_divisible ( n ) ) NEW_LINE n = 4 NEW_LINE print ( is_divisible ( n ) ) NEW_LINE
mod = 1000000007 NEW_LINE def BitOperations ( a , n , b , m ) : NEW_LINE INDENT a = a [ : : - 1 ] NEW_LINE b = b [ : : - 1 ] NEW_LINE c = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] == '1' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT power = [ None ] * n NEW_LINE power [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT power [ i ] = ( power [ i - 1 ] * 2 ) % mod NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == '1' ) : NEW_LINE INDENT ans += c * power [ i ] NEW_LINE if ( ans >= mod ) : NEW_LINE INDENT ans %= mod NEW_LINE DEDENT DEDENT if ( b [ i ] == '1' ) : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT if ( c == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = "1001" NEW_LINE b = "10101" NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( BitOperations ( a , n , b , m ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def sieve ( maxEle , prime ) : NEW_LINE INDENT prime [ 0 ] , prime [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , int ( sqrt ( maxEle ) ) + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , maxEle + 1 , i ) : NEW_LINE INDENT prime [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def digitSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT sum += n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def printAdditivePrime ( arr , n ) : NEW_LINE INDENT maxEle = max ( arr ) NEW_LINE prime = [ 0 ] * ( maxEle + 1 ) NEW_LINE sieve ( maxEle , prime ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == 0 ) : NEW_LINE INDENT sum = digitSum ( arr [ i ] ) NEW_LINE if ( prime [ sum ] == 0 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 4 , 6 , 11 , 12 , 18 , 7 ] NEW_LINE n = len ( a ) NEW_LINE printAdditivePrime ( a , n ) NEW_LINE DEDENT
def nthterm ( n ) : NEW_LINE INDENT An = ( 1 ** n + 2 ** n ) * ( 3 ** n ) NEW_LINE return An ; NEW_LINE DEDENT n = 3 NEW_LINE print ( nthterm ( n ) ) NEW_LINE
def countDivisors ( n ) : NEW_LINE INDENT x , ans = 0 , 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT x += 1 NEW_LINE n = n / 2 NEW_LINE DEDENT ans = ans * ( x + 1 ) NEW_LINE for i in range ( 3 , int ( n ** 1 / 2 ) + 1 , 2 ) : NEW_LINE INDENT x = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT x += 1 NEW_LINE n = n / i NEW_LINE DEDENT ans = ans * ( x + 1 ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = ans * 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT def getTotalCount ( n , k ) : NEW_LINE INDENT k_count = countDivisors ( k ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( k_count == countDivisors ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( k < n ) : NEW_LINE INDENT count = count - 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , k = 500 , 6 NEW_LINE print ( getTotalCount ( n , k ) ) NEW_LINE DEDENT
def term ( n ) : NEW_LINE INDENT d = 2 NEW_LINE a1 = 0 NEW_LINE An = a1 + ( n - 1 ) * d NEW_LINE An = An ** 3 NEW_LINE return An ; NEW_LINE DEDENT n = 5 NEW_LINE print ( term ( n ) ) NEW_LINE
MAX_VAL = 200000 NEW_LINE def countIntervals ( arr , V , N ) : NEW_LINE INDENT minimum = float ( " inf " ) NEW_LINE maximum = 0 NEW_LINE freq = [ 0 ] * ( MAX_VAL ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT li = arr [ i ] [ 0 ] NEW_LINE freq [ li ] = freq [ li ] + 1 NEW_LINE ri = arr [ i ] [ 1 ] NEW_LINE freq [ ri + 1 ] = freq [ ri + 1 ] - 1 NEW_LINE if li < minimum : NEW_LINE INDENT minimum = li NEW_LINE DEDENT if ri > maximum : NEW_LINE INDENT maximum = ri NEW_LINE DEDENT DEDENT for i in range ( minimum , maximum + 1 ) : NEW_LINE INDENT freq [ i ] = freq [ i ] + freq [ i - 1 ] NEW_LINE DEDENT return freq [ V ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 10 ] , [ 5 , 10 ] , [ 15 , 25 ] , [ 7 , 12 ] , [ 20 , 25 ] ] NEW_LINE V = 7 NEW_LINE N = len ( arr ) NEW_LINE print ( countIntervals ( arr , V , N ) ) NEW_LINE DEDENT
def printGroups ( n ) : NEW_LINE INDENT x = 1 NEW_LINE y = n * n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT print ( " { " , x , " , " , y , " } " , end = " ▁ " ) NEW_LINE x += 1 NEW_LINE y -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE printGroups ( n ) NEW_LINE DEDENT
import math NEW_LINE def breakEvenPoint ( exp , S , M ) : NEW_LINE INDENT earn = S - M NEW_LINE if res != 0 : NEW_LINE res = math . ceil ( exp / earn ) NEW_LINE else : NEW_LINE res = float ( ' inf ' ) NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT exp = 3550 NEW_LINE S = 90 NEW_LINE M = 65 NEW_LINE print ( int ( breakEvenPoint ( exp , S , M ) ) ) NEW_LINE DEDENT
def minimum ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE DEDENT product = product * i NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT product = product * n NEW_LINE DEDENT return product NEW_LINE DEDENT n = 20 NEW_LINE print ( minimum ( n ) ) NEW_LINE
def numbers ( n , arr , m ) : NEW_LINE INDENT isZero = 0 NEW_LINE isFive = 0 NEW_LINE result = 0 NEW_LINE if ( m < n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZero = 1 NEW_LINE DEDENT if ( arr [ i ] == 5 ) : NEW_LINE INDENT isFive = 1 NEW_LINE DEDENT DEDENT if ( isZero and isFive ) : NEW_LINE INDENT result = 2 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT m -= 1 NEW_LINE result = result * ( m ) NEW_LINE DEDENT DEDENT elif ( isZero or isFive ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT m -= 1 NEW_LINE result = result * ( m ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT result = - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE m = 6 NEW_LINE arr = [ 2 , 3 , 5 , 6 , 7 , 9 ] NEW_LINE print ( numbers ( n , arr , m ) ) NEW_LINE DEDENT
a , b , c = 5 , 7 , 10 NEW_LINE if ( a <= b and a <= c ) : NEW_LINE INDENT print ( a , " is ▁ the ▁ smallest " ) NEW_LINE DEDENT elif ( b <= a and b <= c ) : NEW_LINE INDENT print ( b , " is ▁ the ▁ smallest " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , " is ▁ the ▁ smallest " ) NEW_LINE DEDENT
def maxSum ( a , n ) : NEW_LINE INDENT maxAnd = max ( a ) NEW_LINE maxOR = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT maxOR |= a [ i ] NEW_LINE DEDENT print ( maxAnd + maxOR ) NEW_LINE DEDENT n = 4 NEW_LINE a = [ 3 , 5 , 6 , 1 ] NEW_LINE maxSum ( a , n ) NEW_LINE
import sys NEW_LINE def getMin ( arr , n , k ) : NEW_LINE INDENT res = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT res = min ( res , arr [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT def getMax ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 1230 , 45 , 67 , 1 ] NEW_LINE k = 10 NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ element ▁ of ▁ array ▁ which " , " is ▁ divisible ▁ by ▁ k : ▁ " , getMin ( arr , n , k ) ) NEW_LINE print ( " Maximum ▁ element ▁ of ▁ array ▁ which " , " is ▁ divisible ▁ by ▁ k : ▁ " , getMax ( arr , n , k ) ) NEW_LINE DEDENT
def printNumberWithDR ( k , d ) : NEW_LINE INDENT if d == 0 and k != 1 : NEW_LINE INDENT print ( - 1 , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( d , end = " " ) NEW_LINE k -= 1 NEW_LINE while k : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k , d = 4 , 4 NEW_LINE printNumberWithDR ( k , d ) NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE limit = int ( n ** ( 0.5 ) ) NEW_LINE prime = [ i for i in range ( limit + 1 ) ] NEW_LINE i = 2 NEW_LINE while i * i <= limit : NEW_LINE INDENT if prime [ i ] == i : NEW_LINE INDENT for j in range ( i * i , limit + 1 , i ) : NEW_LINE INDENT if prime [ j ] == j : NEW_LINE INDENT prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT p = prime [ i ] NEW_LINE q = prime [ i // prime [ i ] ] NEW_LINE if p * q == i and q != 1 and p != q : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif prime [ i ] == i : NEW_LINE INDENT if i ** 8 <= n : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1000 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isInterprime ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_prime = n NEW_LINE next_prime = n NEW_LINE while ( isPrime ( prev_prime ) == 0 ) : NEW_LINE INDENT prev_prime = prev_prime - 1 NEW_LINE DEDENT while ( isPrime ( next_prime ) == 0 ) : NEW_LINE INDENT next_prime = next_prime + 1 NEW_LINE DEDENT if ( ( prev_prime + next_prime ) == 2 * n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 9 NEW_LINE if ( isInterprime ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def get_unit_digit ( N ) : NEW_LINE INDENT if ( N == 0 or N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return 3 NEW_LINE DEDENT elif ( N == 3 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT N = 1 NEW_LINE for N in range ( 11 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = ▁ " , N , " : " , get_unit_digit ( N ) , sep = ' ▁ ' ) NEW_LINE DEDENT
MAX = 1000 NEW_LINE f = [ 0 for i in range ( MAX ) ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 1 or n == 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if f [ n ] : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT if n & 1 : NEW_LINE INDENT k = ( n + 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT k = n // 2 NEW_LINE DEDENT if n & 1 : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def calculateSumOfSquares ( n ) : NEW_LINE INDENT return fib ( n ) * fib ( n + 1 ) NEW_LINE DEDENT n = 6 NEW_LINE print ( " Sum ▁ of ▁ Squares ▁ of ▁ " " Fibonacci ▁ numbers ▁ is ▁ : " , calculateSumOfSquares ( n ) ) NEW_LINE
def NumberOfSolutions ( x , y , z , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT temp = n - i - j NEW_LINE if temp >= 0 : NEW_LINE INDENT temp = min ( temp , z ) NEW_LINE ans += temp + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y , z , n = 1 , 2 , 3 , 4 NEW_LINE print ( NumberOfSolutions ( x , y , z , n ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return n ** 2 + 4 * n ; NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) NEW_LINE return ( ( sr - math . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isProduct ( num ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 2 NEW_LINE while cnt < 2 and i * i <= num : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num //= i NEW_LINE cnt += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt == 2 NEW_LINE DEDENT def findNumbers ( N ) : NEW_LINE INDENT vec = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( isProduct ( i ) and not isPerfectSquare ( i ) ) : NEW_LINE INDENT vec . append ( i ) NEW_LINE DEDENT DEDENT for i in range ( len ( vec ) ) : NEW_LINE INDENT print ( vec [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 30 NEW_LINE findNumbers ( N ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 3 ) + pow ( n , 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def NthTerm ( N ) : NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( NthTerm ( N ) ) NEW_LINE DEDENT
def findSum ( N ) : NEW_LINE INDENT return ( ( N * ( N + 1 ) * ( 2 * N - 5 ) + 4 * N ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( ( 3 * N * N ) - ( 6 * N ) + 2 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE DEDENT
import math NEW_LINE MAX = 16 NEW_LINE nCr = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def binomial ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT if j == 0 or j == i : NEW_LINE INDENT nCr [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def findTanNTheta ( tanTheta , n ) : NEW_LINE INDENT numerator = 0 NEW_LINE denominator = 1 NEW_LINE ans = 0 NEW_LINE toggle = 1 NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT numerator = ( numerator + nCr [ n ] [ i ] * ( tanTheta ** ( i ) ) * toggle ) NEW_LINE toggle = toggle * - 1 NEW_LINE DEDENT toggle = - 1 NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT numerator = ( numerator + nCr [ n ] [ i ] * ( tanTheta ** i ) * toggle ) NEW_LINE toggle = toggle * - 1 NEW_LINE DEDENT ans = numerator / denominator NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT binomial ( ) NEW_LINE tanTheta = 0.3 NEW_LINE n = 10 NEW_LINE print ( findTanNTheta ( tanTheta , n ) ) NEW_LINE DEDENT
def findMaximumPieces ( n ) : NEW_LINE INDENT return int ( 1 + n * ( n + 1 ) / 2 ) NEW_LINE DEDENT print ( findMaximumPieces ( 3 ) ) NEW_LINE
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( 4 * n * n + 6 * n - 1 ) / 3 ) ; NEW_LINE DEDENT n = 4 NEW_LINE print ( " Sum ▁ = " , calculateSum ( n ) ) NEW_LINE
def printCombination ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( i % 3 != 0 ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( j % 3 != 0 ) : NEW_LINE INDENT for k in range ( 1 , n ) : NEW_LINE INDENT if ( k % 3 != 0 and ( i + j + k ) == n ) : NEW_LINE INDENT print ( i , j , k ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE
def percent ( a , b ) : NEW_LINE INDENT result = int ( ( ( b - a ) * 100 ) / a ) NEW_LINE return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 20 , 25 NEW_LINE print ( percent ( a , b ) , " % " ) NEW_LINE DEDENT
/ * Python program to Count numbers NEW_LINE which can be represented as NEW_LINE sum of same parity primes * / NEW_LINE def calculate ( array , size ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( array [ i ] % 2 == 0 and array [ i ] != 0 and array [ i ] != 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 3 , 4 , 6 ] NEW_LINE size = len ( a ) NEW_LINE print ( calculate ( a , size ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT
def dig ( a ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( a > 0 ) : NEW_LINE INDENT a /= 10 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def required_number ( num , n , d ) : NEW_LINE INDENT flag = 0 NEW_LINE power = 0 NEW_LINE a = 0 NEW_LINE for i in range ( num , 0 , - 1 ) : NEW_LINE INDENT power = pow ( 10 , i ) NEW_LINE a = n % power NEW_LINE if ( d > a ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( 0 , i ) : NEW_LINE INDENT t += 9 * pow ( 10 , j ) NEW_LINE DEDENT if ( n % power == t ) : NEW_LINE INDENT print ( n , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - ( n % power ) - 1 ) , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( n , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1029 NEW_LINE d = 102 NEW_LINE num = dig ( n ) NEW_LINE required_number ( num , n , d ) NEW_LINE DEDENT
import math as mt NEW_LINE def twoEggDrop ( k ) : NEW_LINE INDENT return mt . ceil ( ( - 1.0 + mt . sqrt ( 1 + 8 * k ) ) / 2 ) NEW_LINE DEDENT k = 100 NEW_LINE print ( twoEggDrop ( k ) ) NEW_LINE
from math import sqrt NEW_LINE def findArea ( a ) : NEW_LINE INDENT area = 5 * sqrt ( 3 ) * a * a NEW_LINE return area NEW_LINE DEDENT def findVolume ( a ) : NEW_LINE INDENT volume = ( ( 5 / 12 ) * ( 3 + sqrt ( 5 ) ) * a * a * a ) NEW_LINE return volume NEW_LINE DEDENT a = 5 NEW_LINE print ( " Area : ▁ " , findArea ( a ) ) NEW_LINE print ( " Volume : ▁ " , findVolume ( a ) ) NEW_LINE
def ways ( n ) : NEW_LINE INDENT first = 2 ; NEW_LINE second = 3 ; NEW_LINE res = 0 ; NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res = first + second ; NEW_LINE first = second ; NEW_LINE second = res ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT n = 7 ; NEW_LINE print ( " Total ▁ ways ▁ are : ▁ " , ways ( n ) ) ; NEW_LINE
import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += math . log10 ( i ) NEW_LINE DEDENT ans = ans * n NEW_LINE return 1 + math . floor ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( countDigits ( n ) ) NEW_LINE DEDENT
cm = 1000 ; NEW_LINE meter = cm / 100.0 ; NEW_LINE kilometer = cm / 100000.0 ; NEW_LINE print ( " Length ▁ in ▁ meter ▁ = ▁ " , meter , " m " ) ; NEW_LINE print ( " Length ▁ in ▁ Kilometer ▁ = ▁ " , kilometer , " km " ) ; NEW_LINE
def everMeet ( x1 , x2 , v1 , v2 ) : NEW_LINE INDENT if ( x1 < x2 and v1 <= v2 ) : NEW_LINE INDENT return False ; NEW_LINE if ( x1 > x2 and v1 >= v2 ) : NEW_LINE INDENT return False ; NEW_LINE if ( x1 < x2 ) : NEW_LINE INDENT swap ( x1 , x2 ) NEW_LINE swap ( v1 , v2 ) NEW_LINE return ( ( x1 - x2 ) % ( v1 - v2 ) == 0 ) NEW_LINE def swap ( a , b ) : NEW_LINE INDENT t = a NEW_LINE a = b NEW_LINE b = t NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def main ( ) : NEW_LINE INDENT x1 , v1 , x2 , v2 = 5 , 8 , 4 , 7 NEW_LINE if ( everMeet ( x1 , x2 , v1 , v2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE a = 4 ; NEW_LINE b = 3 ; NEW_LINE val = ( a + b - 1 ) / b ; NEW_LINE print ( " The ▁ ceiling ▁ value ▁ of ▁ 4/3 ▁ is ▁ " , math . floor ( val ) ) ; NEW_LINE a = 6 ; NEW_LINE b = 3 ; NEW_LINE val = ( a + b - 1 ) / b ; NEW_LINE print ( " The ▁ ceiling ▁ value ▁ of ▁ 6/3 ▁ is ▁ " , math . floor ( val ) ) ; NEW_LINE
import math NEW_LINE def sumTillX ( x , n ) : NEW_LINE INDENT odd = math . ceil ( n / 2.0 ) NEW_LINE if ( x <= odd ) : NEW_LINE INDENT return x * x ; NEW_LINE DEDENT even = x - odd ; NEW_LINE return ( ( odd * odd ) + ( even * even ) + even ) ; NEW_LINE DEDENT def rangeSum ( N , L , R ) : NEW_LINE INDENT return ( sumTillX ( R , N ) - sumTillX ( L - 1 , N ) ) ; NEW_LINE DEDENT N = 10 NEW_LINE L = 1 NEW_LINE R = 6 NEW_LINE print ( rangeSum ( N , L , R ) ) NEW_LINE
def printTwinPrime ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 2 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 2 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , n - 1 ) : NEW_LINE INDENT if prime [ p ] and prime [ p + 2 ] : NEW_LINE INDENT print ( " ( " , p , " , " , ( p + 2 ) , " ) " , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 25 NEW_LINE printTwinPrime ( n ) NEW_LINE DEDENT
import math NEW_LINE def isCubeFree ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( n ** ( 1 / 3 ) + 1 ) ) : NEW_LINE INDENT if ( n % ( i * i * i ) == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def printCubeFree ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( isCubeFree ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 20 NEW_LINE printCubeFree ( n ) NEW_LINE
def inversegrayCode ( n ) : NEW_LINE INDENT inv = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT inv = inv ^ n ; NEW_LINE n = n >> 1 ; NEW_LINE DEDENT return inv ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( inversegrayCode ( n ) ) ; NEW_LINE
import math NEW_LINE def productPrimeFactors ( n ) : NEW_LINE INDENT product = 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT product *= 2 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT product = product * i NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = n / i NEW_LINE DEDENT DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT product = product * n NEW_LINE DEDENT return product NEW_LINE DEDENT n = 44 NEW_LINE print ( int ( productPrimeFactors ( n ) ) ) NEW_LINE
def calculateProbability ( N ) : NEW_LINE INDENT probability = N / ( N + 1 ) NEW_LINE return probability NEW_LINE DEDENT N = 1 NEW_LINE probabilityMax = calculateProbability ( N ) NEW_LINE print ( " Maximum ▁ Probability ▁ for ▁ N ▁ = ▁ " , N , " is , ▁ % .4f " % probabilityMax ) NEW_LINE N = 2 NEW_LINE probabilityMax = calculateProbability ( N ) ; NEW_LINE print ( " Maximum ▁ Probability ▁ for ▁ N ▁ = " , N , " is , ▁ % .4f " % probabilityMax ) NEW_LINE N = 10 NEW_LINE probabilityMax = calculateProbability ( N ) ; NEW_LINE print ( " Maximum ▁ Probability ▁ for ▁ N ▁ = " , N , " is , ▁ % .4f " % probabilityMax ) NEW_LINE
import math NEW_LINE def mean ( mid , freq , n ) : NEW_LINE INDENT sum = 0 NEW_LINE freqSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + mid [ i ] * freq [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT return sum / freqSum NEW_LINE DEDENT def groupedSD ( lower_limit , upper_limit , freq , n ) : NEW_LINE INDENT mid = [ [ 0 ] for i in range ( 0 , n ) ] NEW_LINE sum = 0 NEW_LINE freqSum = 0 NEW_LINE sd = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mid [ i ] = ( lower_limit [ i ] + upper_limit [ i ] ) / 2 NEW_LINE sum = sum + freq [ i ] * mid [ i ] * mid [ i ] NEW_LINE freqSum = freqSum + freq [ i ] NEW_LINE DEDENT sd = math . sqrt ( ( sum - freqSum * mean ( mid , freq , n ) * mean ( mid , freq , n ) ) / ( freqSum - 1 ) ) NEW_LINE return sd NEW_LINE DEDENT lower_limit = [ 50 , 61 , 71 , 86 , 96 ] NEW_LINE upper_limit = [ 60 , 70 , 85 , 95 , 100 ] NEW_LINE freq = [ 9 , 7 , 9 , 12 , 8 ] NEW_LINE n = len ( lower_limit ) NEW_LINE print ( groupedSD ( lower_limit , upper_limit , freq , n ) ) NEW_LINE
def avg_of_even_num ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + 2 * i NEW_LINE DEDENT return sum / n NEW_LINE DEDENT n = 9 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE
def avg_of_even_num ( n ) : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT n = 8 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE
def squareSum ( n ) : NEW_LINE INDENT return int ( n * ( 4 * n * n - 1 ) / 3 ) NEW_LINE DEDENT ans = squareSum ( 8 ) NEW_LINE print ( ans ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 2 NEW_LINE DEDENT return True NEW_LINE DEDENT def nextPrime ( start ) : NEW_LINE INDENT nxt = start + 1 NEW_LINE while ( isPrime ( nxt ) == False ) : NEW_LINE INDENT nxt = nxt + 1 NEW_LINE DEDENT return nxt NEW_LINE DEDENT def areAdjacentPrimes ( a , b , c ) : NEW_LINE INDENT if ( isPrime ( a ) == False or isPrime ( b ) == False or isPrime ( c ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT nxt = nextPrime ( a ) NEW_LINE DEDENT ' NEW_LINE INDENT if ( nxt != b ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( nextPrime ( b ) != c ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if ( areAdjacentPrimes ( 11 , 13 , 19 ) ) : NEW_LINE INDENT print ( " Yes " ) , NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + i * i NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return ( ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for x in range ( k + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] ; NEW_LINE DEDENT def maxcoefficientvalue ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return binomialCoeff ( n , int ( n / 2 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return binomialCoeff ( n , int ( ( n + 1 ) / 2 ) ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 ; NEW_LINE print ( maxcoefficientvalue ( n ) ) ; NEW_LINE DEDENT
from fractions import gcd NEW_LINE import math NEW_LINE def LCM ( x , y , z ) : NEW_LINE INDENT ans = int ( ( x * y ) / ( gcd ( x , y ) ) ) NEW_LINE return int ( ( z * ans ) / ( gcd ( ans , z ) ) ) NEW_LINE DEDENT def findDivisible ( n , x , y , z ) : NEW_LINE INDENT lcm = LCM ( x , y , z ) NEW_LINE ndigitnumber = math . pow ( 10 , n - 1 ) NEW_LINE reminder = ndigitnumber % lcm NEW_LINE if reminder == 0 : NEW_LINE INDENT return ndigitnumber NEW_LINE DEDENT ndigitnumber += lcm - reminder NEW_LINE if ndigitnumber < math . pow ( 10 , n ) : NEW_LINE INDENT return int ( ndigitnumber ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE x = 2 NEW_LINE y = 3 NEW_LINE z = 5 NEW_LINE res = findDivisible ( n , x , y , z ) NEW_LINE if res != 0 : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT
def squaresum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) ; NEW_LINE
import math NEW_LINE def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) * 1.0 ) NEW_LINE DEDENT print ( " % .6f " % distance ( 3 , 4 , 4 , 3 ) ) NEW_LINE
def accumulate ( s ) : NEW_LINE INDENT acc = 0 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT acc += ord ( s [ i ] ) - 48 ; NEW_LINE DEDENT return acc ; NEW_LINE DEDENT def isDivisible ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE if ( s [ n - 1 ] != '5' and s [ n - 1 ] != '0' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT sum = accumulate ( s ) ; NEW_LINE return ( sum % 3 == 0 ) ; NEW_LINE DEDENT s = "15645746327462384723984023940239" ; NEW_LINE if isDivisible ( s ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT s = "15645746327462384723984023940235" ; NEW_LINE if isDivisible ( s ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
from math import sqrt NEW_LINE def checkPerfectSquare ( n ) : NEW_LINE INDENT d = sqrt ( n ) NEW_LINE if d * d == n : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectSquare ( a [ i ] ) ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestPerfectSquareNumber ( a , n ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def find_LCM ( x , y ) : NEW_LINE INDENT return ( x * y ) // gcd ( x , y ) NEW_LINE DEDENT def CountPairs ( n , m , A , B ) : NEW_LINE INDENT cnt = 0 NEW_LINE lcm = find_LCM ( A , B ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT cnt += ( m + ( i % lcm ) ) // lcm NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m , A , B = 60 , 90 , 5 , 10 NEW_LINE print ( CountPairs ( n , m , A , B ) ) NEW_LINE DEDENT
MAX = 1001 NEW_LINE prefix = [ [ 0 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE ar = [ 0 for i in range ( MAX ) ] NEW_LINE def cal_prefix ( n , arr ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT ar [ i + 1 ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , 1001 , 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT prefix [ i ] [ j ] = 0 NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ar [ j ] <= i : NEW_LINE INDENT k = 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 0 NEW_LINE DEDENT prefix [ i ] [ j ] = prefix [ i ] [ j - 1 ] + k NEW_LINE DEDENT DEDENT DEDENT def ksub ( l , r , n , k ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = 1000 NEW_LINE while ( lo + 1 < hi ) : NEW_LINE INDENT mid = int ( ( lo + hi ) / 2 ) NEW_LINE if ( prefix [ mid ] [ r ] - prefix [ mid ] [ l - 1 ] >= k ) : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT if ( prefix [ lo ] [ r ] - prefix [ lo ] [ l - 1 ] >= k ) : NEW_LINE INDENT hi = lo NEW_LINE DEDENT return hi NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 2 , 3 , 5 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE cal_prefix ( n , arr ) NEW_LINE queries = [ [ 1 , n , 1 ] , [ 2 , n - 2 , 2 ] , [ 3 , n - 1 , 3 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT print ( ksub ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , n , queries [ i ] [ 2 ] ) ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def max_min ( a , n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT f_min = a [ 0 ] NEW_LINE s_min = sys . maxsize NEW_LINE f_max = a [ 0 ] NEW_LINE s_max = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] <= f_min ) : NEW_LINE INDENT s_min = f_min NEW_LINE f_min = a [ i ] NEW_LINE DEDENT elif ( a [ i ] < s_min ) : NEW_LINE INDENT s_min = a [ i ] NEW_LINE DEDENT if ( a [ i ] >= f_max ) : NEW_LINE INDENT s_max = f_max NEW_LINE f_max = a [ i ] NEW_LINE DEDENT elif ( a [ i ] > s_max ) : NEW_LINE INDENT s_max = a [ i ] NEW_LINE DEDENT DEDENT return min ( ( f_max - s_min ) , ( s_max - f_min ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 3 , 3 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( max_min ( a , n ) ) NEW_LINE DEDENT
def minimal ( a , n ) : NEW_LINE INDENT lo , hi = 0 , n - 1 NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE if a [ mid ] < a [ mid + 1 ] : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT return lo NEW_LINE return lo NEW_LINE DEDENT DEDENT a = [ 8 , 5 , 4 , 3 , 4 , 10 ] NEW_LINE n = len ( a ) NEW_LINE ind = minimal ( a , n ) NEW_LINE print ( a [ ind ] ) NEW_LINE
def findIndices ( arr , n ) : NEW_LINE INDENT leftMin , rightMin = 0 , 0 NEW_LINE leftMax , rightMax = 0 , 0 NEW_LINE min_element = arr [ 0 ] NEW_LINE max_element = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < min_element ) : NEW_LINE INDENT leftMin = rightMin = i NEW_LINE min_element = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] == min_element ) : NEW_LINE INDENT rightMin = i NEW_LINE DEDENT if ( arr [ i ] > max_element ) : NEW_LINE INDENT leftMax = rightMax = i NEW_LINE max_element = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] == max_element ) : NEW_LINE INDENT rightMax = i NEW_LINE DEDENT DEDENT print ( " Minimum ▁ left ▁ : ▁ " , leftMin ) NEW_LINE print ( " Minimum ▁ right ▁ : ▁ " , rightMin ) NEW_LINE print ( " Maximum ▁ left ▁ : ▁ " , leftMax ) NEW_LINE print ( " Maximum ▁ right ▁ : ▁ " , rightMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 1 , 1 , 2 , 1 , 5 , 6 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findIndices ( arr , n ) NEW_LINE DEDENT
def diagonalsMinMax ( mat ) : NEW_LINE INDENT n = len ( mat ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ 0 ] [ n - 1 ] NEW_LINE secondaryMax = mat [ 0 ] [ n - 1 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > principalMax ) : NEW_LINE INDENT principalMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT if ( mat [ i ] [ j ] < secondaryMin ) : NEW_LINE INDENT secondaryMin = mat [ i ] [ j ] NEW_LINE DEDENT if ( mat [ i ] [ j ] > secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " , principalMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE DEDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE diagonalsMinMax ( matrix ) NEW_LINE
def indexedSequentialSearch ( arr , n , k ) : NEW_LINE INDENT elements = [ 0 ] * 20 NEW_LINE indices = [ 0 ] * 20 NEW_LINE j , ind , start , end = 0 , 0 , 0 , 0 NEW_LINE set_flag = 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT elements [ ind ] = arr [ i ] NEW_LINE indices [ ind ] = i NEW_LINE ind += 1 NEW_LINE DEDENT if k < elements [ 0 ] : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE exit ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , ind + 1 ) : NEW_LINE INDENT if k <= elements [ i ] : NEW_LINE INDENT start = indices [ i - 1 ] NEW_LINE end = indices [ i ] NEW_LINE set_flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if set_flag == 0 : NEW_LINE INDENT start = indices [ i - 1 ] NEW_LINE end = n NEW_LINE DEDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if k == arr [ i ] : NEW_LINE INDENT j = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 1 : NEW_LINE INDENT print ( " Found ▁ at ▁ index " , i ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE indexedSequentialSearch ( arr , n , k ) NEW_LINE DEDENT
def countSegments ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT flag = False NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 ] NEW_LINE n = len ( a ) NEW_LINE x = 13 NEW_LINE print ( countSegments ( a , n , x ) ) NEW_LINE DEDENT
def count_triples ( n , k ) : NEW_LINE INDENT count , i , j , l = 0 , 0 , 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for l in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( ( i + j ) % k == 0 and ( i + l ) % k == 0 and ( j + l ) % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 3 , 2 NEW_LINE ans = count_triples ( n , k ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def kthSmallestLargest ( arr , n , k ) : NEW_LINE INDENT max_val = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT hash = [ 0 for i in range ( max_val + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( max_val + 1 ) : NEW_LINE INDENT while ( hash [ i ] > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT hash [ i ] -= 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 11 , 6 , 2 , 9 , 4 , 3 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( " kth ▁ smallest ▁ number ▁ is : " , kthSmallestLargest ( arr , n , k ) ) NEW_LINE DEDENT
import math NEW_LINE def bsearch ( A , key_to_search ) : NEW_LINE INDENT n = len ( A ) NEW_LINE lg = int ( math . log2 ( n - 1 ) ) + 1 ; NEW_LINE pos = 0 NEW_LINE for i in range ( lg - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( A [ pos ] == key_to_search ) : NEW_LINE INDENT return pos NEW_LINE DEDENT new_pos = pos | ( 1 << i ) NEW_LINE if ( ( new_pos < n ) and ( A [ new_pos ] <= key_to_search ) ) : NEW_LINE INDENT pos = new_pos NEW_LINE DEDENT DEDENT return ( pos if ( A [ pos ] == key_to_search ) else - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ - 2 , 10 , 100 , 250 , 32315 ] NEW_LINE print ( bsearch ( A , 10 ) ) NEW_LINE DEDENT
def findmedian ( a , n1 , b , n2 ) : NEW_LINE INDENT j = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE for k in range ( ( ( n1 + n2 ) // 2 ) + 1 ) : NEW_LINE INDENT if ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( a [ i ] < b [ j ] ) : NEW_LINE INDENT m2 = m1 NEW_LINE m1 = a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m2 = m1 NEW_LINE m1 = b [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT elif ( i == n1 ) : NEW_LINE INDENT m2 = m1 NEW_LINE m1 = b [ j ] NEW_LINE j += 1 NEW_LINE DEDENT elif ( j == n2 ) : NEW_LINE INDENT m2 = m1 NEW_LINE m1 = a [ i ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT if ( ( n1 + n2 ) % 2 == 0 ) : NEW_LINE INDENT return ( m1 + m2 ) * 1.0 / 2 NEW_LINE DEDENT return m1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 12 , 15 , 26 , 38 ] NEW_LINE b = [ 2 , 13 , 24 ] NEW_LINE n1 = len ( a ) NEW_LINE n2 = len ( b ) NEW_LINE print ( findmedian ( a , n1 , b , n2 ) ) NEW_LINE DEDENT
def printNSE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] > arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + " ▁ - - ▁ " + str ( next ) ) NEW_LINE DEDENT DEDENT arr = [ 11 , 13 , 21 , 3 ] NEW_LINE printNSE ( arr ) NEW_LINE
def longestSubarray ( input , length ) : NEW_LINE INDENT prev = - 1 NEW_LINE prevCount = 0 NEW_LINE currentCount = 1 NEW_LINE longest = 1 NEW_LINE current = input [ 0 ] NEW_LINE for i in range ( 1 , length ) : NEW_LINE INDENT next = input [ i ] NEW_LINE if next == current : NEW_LINE INDENT currentCount += 1 NEW_LINE DEDENT elif next == prev : NEW_LINE INDENT prevCount += currentCount NEW_LINE prev = current NEW_LINE current = next NEW_LINE currentCount = 1 NEW_LINE DEDENT else : NEW_LINE INDENT longest = max ( longest , currentCount + prevCount ) NEW_LINE prev = current NEW_LINE prevCount = currentCount NEW_LINE current = next NEW_LINE currentCount = 1 NEW_LINE DEDENT DEDENT return max ( longest , currentCount + prevCount ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT input = [ 5 , 5 , 6 , 7 , 6 ] NEW_LINE n = len ( input ) NEW_LINE print ( longestSubarray ( input , n ) ) NEW_LINE DEDENT
def binarySearch ( searchSpace , s , e , num ) : NEW_LINE INDENT while ( s <= e ) : NEW_LINE INDENT mid = ( s + e ) // 2 NEW_LINE if searchSpace [ mid ] >= num : NEW_LINE INDENT ans = mid NEW_LINE e = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def longestSubArr ( arr , n ) : NEW_LINE INDENT searchSpace = [ None ] * n NEW_LINE index = [ None ] * n NEW_LINE j = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( j == 0 or searchSpace [ j - 1 ] < arr [ i ] ) : NEW_LINE INDENT searchSpace [ j ] = arr [ i ] NEW_LINE index [ j ] = i NEW_LINE j += 1 NEW_LINE DEDENT idx = binarySearch ( searchSpace , 0 , j - 1 , arr [ i ] ) NEW_LINE ans = max ( ans , i - index [ idx ] + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 5 , - 1 , 7 , 5 , 1 , - 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArr ( arr , n ) ) NEW_LINE DEDENT
def isSuffix ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if ( n1 > n2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( s1 [ n1 - i - 1 ] != s2 [ n2 - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " geeks " NEW_LINE s2 = " geeksforgeeks " NEW_LINE result = isSuffix ( s1 , s2 ) NEW_LINE if ( result ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def checkIfAllTogether ( s , c ) : NEW_LINE INDENT oneSeen = False NEW_LINE i = 0 NEW_LINE n = len ( s ) NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == c ) : NEW_LINE INDENT if ( oneSeen == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i < n and s [ i ] == c ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = "110029" ; NEW_LINE if ( checkIfAllTogether ( s , '1' ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT front = 0 ; back = n - 1 NEW_LINE while ( front <= back ) : NEW_LINE INDENT if ( arr [ front ] == x or arr [ back ] == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT front += 1 NEW_LINE back -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 10 , 20 , 80 , 30 , 60 , 50 , 110 , 100 , 130 , 170 ] NEW_LINE x = 130 NEW_LINE n = len ( arr ) NEW_LINE if ( search ( arr , n , x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findValue ( X , Y , P ) : NEW_LINE INDENT if P % 2 == 0 : NEW_LINE INDENT return int ( max ( X , Y ) / min ( X , Y ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return int ( max ( 2 * X , Y ) / min ( 2 * X , Y ) ) NEW_LINE DEDENT DEDENT X = 1 NEW_LINE Y = 2 NEW_LINE P = 1 NEW_LINE print ( findValue ( X , Y , P ) ) NEW_LINE X = 3 NEW_LINE Y = 7 NEW_LINE P = 2 NEW_LINE print ( ( findValue ( X , Y , P ) ) ) NEW_LINE
def sum ( arr , start , to ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( start , to + 1 ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT return total NEW_LINE DEDENT def findMax ( arr , n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( k + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ 1 ] [ i ] = sum ( arr , 0 , i - 1 ) NEW_LINE DEDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = arr [ 0 ] NEW_LINE for j in range ( 2 , n + 1 ) : NEW_LINE INDENT best = 100000000 NEW_LINE for p in range ( 1 , j + 1 ) : NEW_LINE INDENT best = min ( best , max ( dp [ i - 1 ] [ p ] , sum ( arr , p , j - 1 ) ) ) NEW_LINE DEDENT dp [ i ] [ j ] = best NEW_LINE DEDENT DEDENT return dp [ k ] [ n ] NEW_LINE DEDENT arr = [ 10 , 20 , 60 , 50 , 30 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( findMax ( arr , n , k ) ) NEW_LINE INDENT n = len ( arr ) NEW_LINE DEDENT k = 3 NEW_LINE print ( findMax ( arr , n , k ) ) NEW_LINE
def countCrossLine ( arr , n ) : NEW_LINE INDENT count_crossline = 0 ; NEW_LINE i , key , j = 0 , 0 , 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT key = arr [ i ] ; NEW_LINE j = i - 1 ; NEW_LINE while ( j >= 0 and arr [ j ] > key ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] ; NEW_LINE j = j - 1 ; NEW_LINE count_crossline += 1 ; NEW_LINE DEDENT arr [ j + 1 ] = key ; NEW_LINE DEDENT return count_crossline ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 3 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countCrossLine ( arr , n ) ) ; NEW_LINE DEDENT
def findMaxRec ( A , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return A [ 0 ] NEW_LINE DEDENT return max ( A [ n - 1 ] , findMaxRec ( A , n - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 4 , 45 , 6 , - 50 , 10 , 2 ] NEW_LINE n = len ( A ) NEW_LINE print ( findMaxRec ( A , n ) ) NEW_LINE DEDENT
def findSquare ( n ) : NEW_LINE INDENT points = [ [ 1 , 2 ] , [ - 3 , 4 ] , [ 1 , 78 ] , [ - 3 , - 7 ] ] NEW_LINE a = [ None ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT x = points [ i ] [ 0 ] NEW_LINE y = points [ i ] [ 1 ] NEW_LINE a [ i ] = max ( abs ( x ) , abs ( y ) ) NEW_LINE DEDENT a . sort ( ) NEW_LINE index = n // 2 - 1 NEW_LINE print ( " Minimum ▁ M ▁ required ▁ is : " , a [ index ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE findSquare ( N ) NEW_LINE DEDENT
def odd_even ( n ) : NEW_LINE INDENT odd_indexes = [ ] NEW_LINE even_indexes = [ ] NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if i % 2 == 0 : odd_indexes . append ( n [ i ] ) NEW_LINE else : even_indexes . append ( n [ i ] ) NEW_LINE DEDENT for i in sorted ( odd_indexes ) : print ( i , end = " ▁ " ) NEW_LINE for i in sorted ( even_indexes ) : print ( i , end = " ▁ " ) NEW_LINE DEDENT n = [ 3 , 2 , 7 , 6 , 8 ] NEW_LINE odd_even ( n ) NEW_LINE
def minimumIncrease ( a , b , c ) : NEW_LINE INDENT arr = [ a , b , c ] NEW_LINE arr . sort ( ) NEW_LINE if arr [ 0 ] + arr [ 1 ] >= arr [ 2 ] : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return arr [ 2 ] - ( arr [ 0 ] + arr [ 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c = 3 , 5 , 10 NEW_LINE print ( minimumIncrease ( a , b , c ) ) NEW_LINE DEDENT
def absSumDidd ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE midValue = a [ ( int ) ( n // 2 ) ] NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + abs ( a [ i ] - midValue ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 5 , 11 , 14 , 10 , 17 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( absSumDidd ( arr , n ) ) NEW_LINE
def findOccurrences ( str , substr ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == substr [ 0 ] ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ j ] == substr [ 1 ] ) : NEW_LINE INDENT for k in range ( j + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ k ] == substr [ 2 ] ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT str = " GFGFGYSYIOIWIN " NEW_LINE substr = " GFG " NEW_LINE print ( findOccurrences ( str , substr ) ) NEW_LINE
def findOccurrences ( str1 , substr ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE preLeft = [ 0 for i in range ( n ) ] NEW_LINE preRight = [ 0 for i in range ( n ) ] NEW_LINE if ( str1 [ 0 ] == substr [ 0 ] ) : NEW_LINE INDENT preLeft [ 0 ] += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( str1 [ i ] == substr [ 0 ] ) : NEW_LINE INDENT preLeft [ i ] = preLeft [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT preLeft [ i ] = preLeft [ i - 1 ] NEW_LINE DEDENT DEDENT if ( str1 [ n - 1 ] == substr [ 2 ] ) : NEW_LINE INDENT preRight [ n - 1 ] += 1 NEW_LINE DEDENT i = n - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str1 [ i ] == substr [ 2 ] ) : NEW_LINE INDENT preRight [ i ] = preRight [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT preRight [ i ] = preRight [ i + 1 ] NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( str1 [ i ] == str1 [ 1 ] ) : NEW_LINE INDENT total = preLeft [ i - 1 ] * preRight [ i + 1 ] NEW_LINE counter += total NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = " GFGFGYSYIOIWIN " NEW_LINE substr = " GFG " NEW_LINE print ( findOccurrences ( str1 , substr ) ) NEW_LINE DEDENT
from math import pow NEW_LINE def printSubsequences ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE opsize = int ( pow ( 2 , n - 1 ) ) NEW_LINE for counter in range ( opsize ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( str [ j ] , end = " " ) NEW_LINE if ( counter & ( 1 << j ) ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( " " , ▁ end ▁ = ▁ " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " ABC " NEW_LINE printSubsequences ( str ) NEW_LINE DEDENT
def countDeletions ( string ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( len ( string ) - 1 ) : NEW_LINE INDENT if ( string [ i ] == string [ i + 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT string = " AAABBB " NEW_LINE print countDeletions ( string ) NEW_LINE
import math as mt NEW_LINE def evenlength ( n ) : NEW_LINE INDENT res = n NEW_LINE for j in range ( len ( n ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT res += n [ j ] NEW_LINE DEDENT return res NEW_LINE DEDENT n = "10" NEW_LINE print ( evenlength ( n ) ) NEW_LINE
def uniqueCharacters ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT str = " GeeksforGeeks " ; NEW_LINE if ( uniqueCharacters ( str ) ) : NEW_LINE INDENT print ( " The ▁ String ▁ " , str , " ▁ has ▁ all ▁ unique ▁ characters " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ String ▁ " , str , " ▁ has ▁ duplicate ▁ characters " ) ; NEW_LINE DEDENT
def findIndex ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE open = [ 0 ] * ( l + 1 ) NEW_LINE close = [ 0 ] * ( l + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ l ] = 0 NEW_LINE if ( str [ 0 ] == ' ( ' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ l - 1 ] == ' ) ' ) : NEW_LINE INDENT close [ l - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ) ' ) : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT close [ i ] = close [ i + 1 ] NEW_LINE DEDENT DEDENT if ( open [ l ] == 0 ) : NEW_LINE INDENT return len NEW_LINE DEDENT if ( close [ 0 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( l + 1 ) : NEW_LINE INDENT if ( open [ i ] == close [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT str = " ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) " NEW_LINE print ( findIndex ( str ) ) NEW_LINE
def decimalToBinary ( num , k_prec ) : NEW_LINE INDENT binary = " " NEW_LINE Integral = int ( num ) NEW_LINE fractional = num - Integral NEW_LINE while ( Integral ) : NEW_LINE INDENT rem = Integral % 2 NEW_LINE binary += str ( rem ) ; NEW_LINE Integral //= 2 NEW_LINE DEDENT binary = binary [ : : - 1 ] NEW_LINE binary += ' . ' NEW_LINE while ( k_prec ) : NEW_LINE INDENT fractional *= 2 NEW_LINE fract_bit = int ( fractional ) NEW_LINE if ( fract_bit == 1 ) : NEW_LINE INDENT fractional -= fract_bit NEW_LINE binary += '1' NEW_LINE DEDENT else : NEW_LINE INDENT binary += '0' NEW_LINE DEDENT k_prec -= 1 NEW_LINE DEDENT return binary NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4.47 NEW_LINE k = 3 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE n = 6.986 NEW_LINE k = 5 NEW_LINE print ( decimalToBinary ( n , k ) ) NEW_LINE DEDENT
def isSmaller ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE if ( n1 < n2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n2 < n1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( n1 ) : NEW_LINE INDENT if ( str1 [ i ] < str2 [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( str1 [ i ] > str2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findDiff ( str1 , str2 ) : NEW_LINE INDENT if ( isSmaller ( str1 , str2 ) ) : NEW_LINE INDENT str1 , str2 = str2 , str1 NEW_LINE DEDENT Str = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE diff = n1 - n2 NEW_LINE carry = 0 NEW_LINE for i in range ( n2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sub = ( ( ord ( str1 [ i + diff ] ) - ord ( '0' ) ) - ( ord ( str2 [ i ] ) - ord ( '0' ) ) - carry ) NEW_LINE if ( sub < 0 ) : NEW_LINE INDENT sub += 10 NEW_LINE carry = 1 NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 NEW_LINE DEDENT Str += chr ( sub + ord ( '0' ) ) NEW_LINE DEDENT for i in range ( n1 - n2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i ] == '0' and carry ) : NEW_LINE INDENT Str += '9' NEW_LINE continue NEW_LINE DEDENT sub = ( ord ( str1 [ i ] ) - ord ( '0' ) ) - carry NEW_LINE if ( i > 0 or sub > 0 ) : NEW_LINE INDENT Str += chr ( sub + ord ( '0' ) ) NEW_LINE DEDENT carry = 0 NEW_LINE DEDENT Str = Str [ : : - 1 ] NEW_LINE return Str NEW_LINE DEDENT str1 = "88" NEW_LINE str2 = "1079" NEW_LINE print ( findDiff ( str1 , str2 ) ) NEW_LINE
MAX_CHAR = 26 ; NEW_LINE def areKAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) ; NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT hash_str1 = [ 0 ] * ( MAX_CHAR ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash_str1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hash_str1 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] > 0 ) : NEW_LINE INDENT hash_str1 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count > k ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT str1 = " fodr " ; NEW_LINE str2 = " gork " ; NEW_LINE k = 2 ; NEW_LINE if ( areKAnagrams ( str1 , str2 , k ) == True ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def getDigit ( N , d ) : NEW_LINE INDENT string = str ( N ) NEW_LINE return string [ d - 1 ] ; NEW_LINE DEDENT def getNthChar ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE nine = 9 NEW_LINE dist = 0 NEW_LINE for len in range ( 1 , N ) : NEW_LINE INDENT sum += nine * len NEW_LINE dist += nine NEW_LINE if ( sum >= N ) : NEW_LINE INDENT sum -= nine * len NEW_LINE dist -= nine NEW_LINE N -= sum NEW_LINE break NEW_LINE DEDENT nine *= 10 NEW_LINE DEDENT diff = ( N / len ) + 1 NEW_LINE d = N % len NEW_LINE if ( d == 0 ) : NEW_LINE INDENT d = len NEW_LINE DEDENT return getDigit ( dist + diff , d ) ; NEW_LINE DEDENT N = 251 NEW_LINE print getNthChar ( N ) NEW_LINE
def findCount ( str ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( ( i == ord ( str [ i ] ) - ord ( ' a ' ) ) or ( i == ord ( str [ i ] ) - ord ( ' A ' ) ) ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT str = ' AbgdeF ' NEW_LINE print ( findCount ( str ) ) NEW_LINE
def _print ( string , index ) : NEW_LINE INDENT if index == len ( string ) : NEW_LINE INDENT print ( ' ' . join ( string ) ) NEW_LINE return NEW_LINE DEDENT if string [ index ] == " ? " : NEW_LINE INDENT string [ index ] = '0' NEW_LINE _print ( string , index + 1 ) NEW_LINE string [ index ] = '1' NEW_LINE _print ( string , index + 1 ) NEW_LINE string [ index ] = ' ? ' NEW_LINE DEDENT else : NEW_LINE INDENT _print ( string , index + 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "1 ? ? 0?101" NEW_LINE string = list ( string ) NEW_LINE _print ( string , 0 ) NEW_LINE DEDENT
def countOccurrences ( x , d ) : NEW_LINE INDENT while ( x ) : NEW_LINE INDENT if ( x % 10 == d ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT x = int ( x / 10 ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def maxOccurring ( x ) : NEW_LINE INDENT if ( x < 0 ) : NEW_LINE INDENT x = - x ; NEW_LINE DEDENT for d in range ( 10 ) : NEW_LINE INDENT count = countOccurrences ( x , d ) ; NEW_LINE if ( count >= max_count ) : NEW_LINE INDENT max_count = count ; NEW_LINE result = d ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT x = 1223355 ; NEW_LINE print ( " Max ▁ occurring ▁ digit ▁ is " , maxOccurring ( x ) ) ; NEW_LINE
def maxSubarrayXOR ( arr , n ) : NEW_LINE INDENT ans = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr_xor = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT curr_xor = curr_xor ^ arr [ j ] NEW_LINE ans = max ( ans , curr_xor ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 8 , 1 , 2 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Max ▁ subarray ▁ XOR ▁ is ▁ " , maxSubarrayXOR ( arr , n ) ) NEW_LINE
NO_OF_CHARS = 256 NEW_LINE def getCharCountArray ( string ) : NEW_LINE INDENT count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in string : NEW_LINE INDENT count [ ord ( i ) ] += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def firstNonRepeating ( string ) : NEW_LINE INDENT count = getCharCountArray ( string ) NEW_LINE index = - 1 NEW_LINE k = 0 NEW_LINE for i in string : NEW_LINE INDENT if count [ ord ( i ) ] == 1 : NEW_LINE INDENT index = k NEW_LINE break NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return index NEW_LINE DEDENT string = " geeksforgeeks " NEW_LINE index = firstNonRepeating ( string ) NEW_LINE if index == 1 : NEW_LINE INDENT print " Either ▁ all ▁ characters ▁ are ▁ repeating ▁ or ▁ string ▁ is ▁ empty " NEW_LINE DEDENT else : NEW_LINE INDENT print " First ▁ non - repeating ▁ character ▁ is ▁ " + string [ index ] NEW_LINE DEDENT
def divideString ( string , n ) : NEW_LINE INDENT str_size = len ( string ) NEW_LINE if str_size % n != 0 : NEW_LINE INDENT print " Invalid ▁ Input : ▁ String ▁ size ▁ is ▁ not ▁ divisible ▁ by ▁ n " NEW_LINE return NEW_LINE DEDENT part_size = str_size / n NEW_LINE k = 0 NEW_LINE for i in string : NEW_LINE INDENT if k % part_size == 0 : NEW_LINE INDENT print   " NEW_LINE DEDENT DEDENT DEDENT " , NEW_LINE INDENT print i , NEW_LINE k += 1 NEW_LINE DEDENT string = " a _ simple _ divide _ string _ quest " NEW_LINE / * length od string is 28 * / NEW_LINE divideString ( string , 4 ) NEW_LINE
MOD = 1000000009 ; NEW_LINE def power ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT n -= 1 ; NEW_LINE res = [ [ 1 , 0 ] , [ 0 , 1 ] ] ; NEW_LINE tMat = [ [ 2 , 3 ] , [ 1 , 0 ] ] ; NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT tmp = [ [ 0 for x in range ( 2 ) ] for y in range ( 2 ) ] ; NEW_LINE tmp [ 0 ] [ 0 ] = ( res [ 0 ] [ 0 ] * tMat [ 0 ] [ 0 ] + res [ 0 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; NEW_LINE tmp [ 0 ] [ 1 ] = ( res [ 0 ] [ 0 ] * tMat [ 0 ] [ 1 ] + res [ 0 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; NEW_LINE tmp [ 1 ] [ 0 ] = ( res [ 1 ] [ 0 ] * tMat [ 0 ] [ 0 ] + res [ 1 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; NEW_LINE tmp [ 1 ] [ 1 ] = ( res [ 1 ] [ 0 ] * tMat [ 0 ] [ 1 ] + res [ 1 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; NEW_LINE res [ 0 ] [ 0 ] = tmp [ 0 ] [ 0 ] ; NEW_LINE res [ 0 ] [ 1 ] = tmp [ 0 ] [ 1 ] ; NEW_LINE res [ 1 ] [ 0 ] = tmp [ 1 ] [ 0 ] ; NEW_LINE res [ 1 ] [ 1 ] = tmp [ 1 ] [ 1 ] ; NEW_LINE DEDENT n = n // 2 ; NEW_LINE tmp = [ [ 0 for x in range ( 2 ) ] for y in range ( 2 ) ] ; NEW_LINE tmp [ 0 ] [ 0 ] = ( tMat [ 0 ] [ 0 ] * tMat [ 0 ] [ 0 ] + tMat [ 0 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; NEW_LINE tmp [ 0 ] [ 1 ] = ( tMat [ 0 ] [ 0 ] * tMat [ 0 ] [ 1 ] + tMat [ 0 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; NEW_LINE tmp [ 1 ] [ 0 ] = ( tMat [ 1 ] [ 0 ] * tMat [ 0 ] [ 0 ] + tMat [ 1 ] [ 1 ] * tMat [ 1 ] [ 0 ] ) % MOD ; NEW_LINE tmp [ 1 ] [ 1 ] = ( tMat [ 1 ] [ 0 ] * tMat [ 0 ] [ 1 ] + tMat [ 1 ] [ 1 ] * tMat [ 1 ] [ 1 ] ) % MOD ; NEW_LINE tMat [ 0 ] [ 0 ] = tmp [ 0 ] [ 0 ] ; NEW_LINE tMat [ 0 ] [ 1 ] = tmp [ 0 ] [ 1 ] ; NEW_LINE tMat [ 1 ] [ 0 ] = tmp [ 1 ] [ 0 ] ; NEW_LINE tMat [ 1 ] [ 1 ] = tmp [ 1 ] [ 1 ] ; NEW_LINE DEDENT return ( res [ 0 ] [ 0 ] * 1 + res [ 0 ] [ 1 ] * 1 ) % MOD ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( power ( n ) ) ; NEW_LINE
def isFeasible ( mid , arr , n , k ) : NEW_LINE INDENT pos = arr [ 0 ] NEW_LINE elements = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] - pos >= mid ) : NEW_LINE INDENT pos = arr [ i ] NEW_LINE elements += 1 NEW_LINE if ( elements == k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return 0 NEW_LINE DEDENT def largestMinDist ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE res = - 1 NEW_LINE left = 1 NEW_LINE right = arr [ n - 1 ] NEW_LINE while ( left < right ) : NEW_LINE INDENT mid = ( left + right ) / 2 NEW_LINE if ( isFeasible ( mid , arr , n , k ) ) : NEW_LINE INDENT res = max ( res , mid ) NEW_LINE left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right = mid NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 8 , 4 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( largestMinDist ( arr , n , k ) ) NEW_LINE DEDENT
def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT start = 1 NEW_LINE end = x NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( mid * mid == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid * mid < x ) : NEW_LINE INDENT start = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT x = 11 NEW_LINE print ( floorSqrt ( x ) ) NEW_LINE
def countOdd ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( n - i ) / 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) / 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) / 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) / 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return coun NEW_LINE DEDENT def countEven ( n ) : NEW_LINE INDENT coun = 0 NEW_LINE i = n - 2 NEW_LINE while ( i >= 1 ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT m = int ( ( ( n - 1 ) - i ) / 2 ) NEW_LINE j = int ( ( i * ( i + 1 ) ) / 2 ) NEW_LINE coun += j * m NEW_LINE DEDENT else : NEW_LINE INDENT m = int ( ( n - i ) / 2 ) NEW_LINE j = ( i * ( i + 1 ) ) // 2 NEW_LINE coun += j * m NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT print ( countOdd ( n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( countEven ( n ) ) NEW_LINE DEDENT DEDENT
def ellipse ( l , b ) : NEW_LINE INDENT if l < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 3.14 * l * b ) / 4 NEW_LINE return x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , b = 5 , 3 NEW_LINE print ( ellipse ( l , b ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def noOfSquares ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT dx = abs ( x2 - x1 ) ; NEW_LINE dy = abs ( y2 - y1 ) ; NEW_LINE ans = dx + dy - gcd ( dx , dy ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 = 1 ; y1 = 1 ; x2 = 4 ; y2 = 3 ; NEW_LINE noOfSquares ( x1 , y1 , x2 , y2 ) ; NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def countPaths ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT m = abs ( x1 - x2 ) NEW_LINE n = abs ( y1 - y2 ) NEW_LINE return ( binomialCoeff ( m + n , n ) ) NEW_LINE DEDENT x1 , y1 , x2 , y2 = 2 , 3 , 4 , 5 NEW_LINE print ( countPaths ( x1 , y1 , x2 , y2 ) ) NEW_LINE
import math NEW_LINE def areaCircle ( b ) : NEW_LINE INDENT area = math . pi * b * b NEW_LINE return area NEW_LINE DEDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( areaCircle ( b ) ) NEW_LINE
def section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) : NEW_LINE INDENT x = ( ( m * x2 ) + ( n * x1 ) ) / ( m + n ) NEW_LINE y = ( ( m * y2 ) + ( n * y1 ) ) / ( m + n ) NEW_LINE z = ( ( m * z2 ) + ( n * z1 ) ) / ( m + n ) NEW_LINE print ( " ( " , x , " , " , y , " , " , z , " ) " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 2 NEW_LINE x2 = 4 NEW_LINE y1 = - 1 NEW_LINE y2 = 3 NEW_LINE z1 = 4 NEW_LINE z2 = 2 NEW_LINE m = 2 NEW_LINE n = 3 NEW_LINE section ( x1 , x2 , y1 , y2 , z1 , z2 , m , n ) NEW_LINE DEDENT
from math import * NEW_LINE def findRadiusOfcircumcircle ( n , a ) : NEW_LINE INDENT if n < 0 or a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT radius = a / sqrt ( 2 - ( 2 * cos ( 360 / n ) ) ) NEW_LINE return radius NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , a = 5 , 6 NEW_LINE print ( round ( findRadiusOfcircumcircle ( n , a ) , 5 ) ) NEW_LINE DEDENT
def findRadiusOfIncircle ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT p = ( a + b + c ) / 2 NEW_LINE area = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) NEW_LINE radius = area / p NEW_LINE return radius NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c = 2 , 2 , 3 NEW_LINE print ( round ( findRadiusOfIncircle ( a , b , c ) , 6 ) ) NEW_LINE DEDENT
import math NEW_LINE def area ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT area = math . sqrt ( ( y1 * z2 - y2 * z1 ) ** 2 + ( x1 * z2 - x2 * z1 ) ** 2 + ( x1 * y2 - x2 * y1 ) ** 2 ) NEW_LINE area = area / 2 NEW_LINE return area NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x1 = - 2 NEW_LINE y1 = 0 NEW_LINE z1 = - 5 NEW_LINE x2 = 1 NEW_LINE y2 = - 2 NEW_LINE z2 = - 1 NEW_LINE a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) NEW_LINE print ( " Area ▁ = ▁ " , a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
from math import * NEW_LINE def trapezoidarea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 3 * sqrt ( 3 ) * pow ( r , 2 ) ) / 4 NEW_LINE return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 NEW_LINE print ( round ( trapezoidarea ( r ) , 3 ) ) NEW_LINE DEDENT
def rectanglearea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = r * r NEW_LINE return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 NEW_LINE DEDENT
import sys NEW_LINE def maxLines ( n , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT s = [ ] ; NEW_LINE slope = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( x1 [ i ] == x2 [ i ] ) : NEW_LINE INDENT slope = sys . maxsize ; NEW_LINE DEDENT else : NEW_LINE INDENT slope = ( y2 [ i ] - y1 [ i ] ) * 1.0 / ( x2 [ i ] - x1 [ i ] ) * 1.0 ; NEW_LINE DEDENT s . append ( slope ) ; NEW_LINE DEDENT return len ( s ) ; NEW_LINE DEDENT n = 2 ; NEW_LINE x1 = [ 1 , 2 ] ; NEW_LINE y1 = [ 1 , 2 ] ; NEW_LINE x2 = [ 2 , 4 ] ; NEW_LINE y2 = [ 2 , 10 ] ; NEW_LINE print ( maxLines ( n , x1 , y1 , x2 , y2 ) ) ; NEW_LINE
import math NEW_LINE def area ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT area = math . sqrt ( ( y1 * z2 - y2 * z1 ) ** 2 + ( x1 * z2 - x2 * z1 ) ** 2 + ( x1 * y2 - x2 * y1 ) ** 2 ) NEW_LINE return area NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x1 = 3 NEW_LINE y1 = 1 NEW_LINE z1 = - 2 NEW_LINE x2 = 1 NEW_LINE y2 = - 3 NEW_LINE z2 = 4 NEW_LINE a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) NEW_LINE print ( " Area ▁ = ▁ " , a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def max_intersection ( center , length , k ) : NEW_LINE INDENT center . sort ( ) ; NEW_LINE if ( center [ 2 ] - center [ 0 ] >= 2 * k + length ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( center [ 2 ] - center [ 0 ] >= 2 * k ) : NEW_LINE INDENT return ( 2 * k - ( center [ 2 ] - center [ 0 ] - length ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return length ; NEW_LINE DEDENT DEDENT center = [ 1 , 2 , 3 ] ; NEW_LINE L = 1 ; NEW_LINE K = 1 ; NEW_LINE print ( max_intersection ( center , L , K ) ) ; NEW_LINE
import math NEW_LINE def haversine ( lat1 , lon1 , lat2 , lon2 ) : NEW_LINE INDENT dLat = ( lat2 - lat1 ) * math . pi / 180.0 NEW_LINE dLon = ( lon2 - lon1 ) * math . pi / 180.0 NEW_LINE lat1 = ( lat1 ) * math . pi / 180.0 NEW_LINE lat2 = ( lat2 ) * math . pi / 180.0 NEW_LINE a = ( pow ( math . sin ( dLat / 2 ) , 2 ) + pow ( math . sin ( dLon / 2 ) , 2 ) * math . cos ( lat1 ) * math . cos ( lat2 ) ) ; NEW_LINE rad = 6371 NEW_LINE c = 2 * math . asin ( math . sqrt ( a ) ) NEW_LINE return rad * c NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT lat1 = 51.5007 NEW_LINE lon1 = 0.1246 NEW_LINE lat2 = 40.6892 NEW_LINE lon2 = 74.0445 NEW_LINE print ( haversine ( lat1 , lon1 , lat2 , lon2 ) , " K . M . " ) NEW_LINE DEDENT
def heptagonalNumber ( n ) : NEW_LINE INDENT return ( ( 5 * n * n ) - ( 3 * n ) ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( heptagonalNumber ( n ) ) NEW_LINE n = 15 NEW_LINE print ( heptagonalNumber ( n ) ) NEW_LINE DEDENT
def icosidigonal_num ( n ) : NEW_LINE INDENT return ( 20 * n * n - 18 * n ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( n , " th ▁ Icosidigonal ▁ " + " number ▁ : ▁ " , icosidigonal_num ( n ) ) NEW_LINE n = 8 NEW_LINE print ( n , " th ▁ Icosidigonal ▁ " + " number ▁ : ▁ " , icosidigonal_num ( n ) ) NEW_LINE DEDENT
def power ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 2 * power ( n - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( power ( n ) ) NEW_LINE
def findPoint ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT print ( " ( " , 2 * x2 - x1 , " , " , 2 * y2 - y1 , " ) " ) ; NEW_LINE DEDENT x1 = 0 ; NEW_LINE y1 = 0 ; NEW_LINE x2 = 1 ; NEW_LINE y2 = 1 ; NEW_LINE findPoint ( x1 , y1 , x2 , y2 ) ; NEW_LINE
def parallel ( n , a ) : NEW_LINE INDENT x = True ; NEW_LINE y = True ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] [ 0 ] != a [ i + 1 ] [ 0 ] ) : NEW_LINE INDENT x = False ; NEW_LINE DEDENT if ( a [ i ] [ 1 ] != a [ i + 1 ] [ 1 ] ) : NEW_LINE INDENT y = False ; NEW_LINE DEDENT DEDENT if ( x ) : NEW_LINE INDENT print ( " Parallel ▁ to ▁ Y ▁ Axis " ) ; NEW_LINE DEDENT elif ( y ) : NEW_LINE INDENT print ( " Parallel ▁ to ▁ X ▁ Axis " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Parallel ▁ to ▁ X ▁ and ▁ Y ▁ Axis " ) ; NEW_LINE DEDENT DEDENT a = [ [ 1 , 2 ] , [ 1 , 4 ] , [ 1 , 6 ] , [ 1 , 0 ] ] ; NEW_LINE n = len ( a ) ; NEW_LINE parallel ( n , a ) ; NEW_LINE
def numberOfSticks ( x ) : NEW_LINE INDENT return ( 3 * x * ( x + 1 ) ) / 2 NEW_LINE DEDENT print ( int ( numberOfSticks ( 7 ) ) ) NEW_LINE
def find_Area ( r ) : NEW_LINE INDENT return ( 2 * r * r ) NEW_LINE DEDENT r = 3 NEW_LINE print ( " ▁ Area ▁ of ▁ square ▁ = ▁ " , find_Area ( r ) ) NEW_LINE
def checkValidity ( a , b , c ) : NEW_LINE INDENT if ( a + b <= c ) or ( a + c <= b ) or ( b + c <= a ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT a = 7 NEW_LINE b = 10 NEW_LINE c = 5 NEW_LINE if checkValidity ( a , b , c ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT
M = 3 ; NEW_LINE N = 3 ; NEW_LINE def contribution_height ( current , previous ) : NEW_LINE INDENT return abs ( current - previous ) ; NEW_LINE DEDENT def surfaceArea ( A ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT up = 0 ; NEW_LINE left = 0 ; NEW_LINE if ( i > 0 ) : NEW_LINE INDENT up = A [ i - 1 ] [ j ] ; NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT left = A [ i ] [ j - 1 ] ; NEW_LINE DEDENT ans += contribution_height ( A [ i ] [ j ] , up ) + contribution_height ( A [ i ] [ j ] , left ) ; NEW_LINE if ( i == N - 1 ) : NEW_LINE INDENT ans += A [ i ] [ j ] ; NEW_LINE DEDENT if ( j == M - 1 ) : NEW_LINE INDENT ans += A [ i ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT ans += N * M * 2 ; NEW_LINE return ans ; NEW_LINE DEDENT A = [ [ 1 , 3 , 4 ] , [ 2 , 2 , 3 ] , [ 1 , 2 , 4 ] ] ; NEW_LINE print ( surfaceArea ( A ) ) ; NEW_LINE
import math NEW_LINE / * Utility Function * / NEW_LINE def area_of_tetrahedron ( side ) : NEW_LINE INDENT return ( math . sqrt ( 3 ) * ( side * side ) ) ; NEW_LINE DEDENT side = 3 ; NEW_LINE print ( " Area ▁ of ▁ Tetrahedron ▁ = ▁ " , round ( area_of_tetrahedron ( side ) , 4 ) ) ; NEW_LINE
import math NEW_LINE def vol_tetra ( side ) : NEW_LINE INDENT volume = ( side ** 3 / ( 6 * math . sqrt ( 2 ) ) ) NEW_LINE return round ( volume , 2 ) NEW_LINE DEDENT side = 3 NEW_LINE vol = vol_tetra ( side ) NEW_LINE print ( vol ) NEW_LINE
def numberOfWays ( x ) : NEW_LINE INDENT dp = [ ] NEW_LINE dp . append ( 1 ) NEW_LINE dp . append ( 1 ) NEW_LINE for i in range ( 2 , x + 1 ) : NEW_LINE INDENT dp . append ( dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ) NEW_LINE DEDENT return ( dp [ x ] ) NEW_LINE DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
from math import * NEW_LINE def area_equilateral ( side ) : NEW_LINE INDENT area = ( sqrt ( 3 ) / 4 ) * side * side NEW_LINE print ( " Area ▁ of ▁ Equilateral ▁ Triangle : ▁ % ▁ f " % area ) NEW_LINE DEDENT def perimeter ( side ) : NEW_LINE INDENT perimeter = 3 * side NEW_LINE print ( " Perimeter ▁ of ▁ Equilateral ▁ Triangle : ▁ % ▁ f " % perimeter ) NEW_LINE DEDENT side = 4 NEW_LINE area_equilateral ( side ) NEW_LINE perimeter ( side ) NEW_LINE
def volumeCuboid ( l , h , w ) : NEW_LINE INDENT return ( l * h * w ) NEW_LINE DEDENT def surfaceAreaCuboid ( l , h , w ) : NEW_LINE INDENT return ( 2 * l * w + 2 * w * h + 2 * l * h ) NEW_LINE DEDENT l = 1 NEW_LINE h = 5 NEW_LINE w = 7 NEW_LINE print ( " Volume ▁ = " , volumeCuboid ( l , h , w ) ) NEW_LINE print ( " Total ▁ Surface ▁ Area ▁ = " , surfaceAreaCuboid ( l , h , w ) ) NEW_LINE
PI = 3.1415 NEW_LINE def circumference ( r ) : NEW_LINE INDENT return ( 2 * PI * r ) NEW_LINE DEDENT print ( ' % .3f ' % circumference ( 5 ) ) NEW_LINE
def collinear ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT if ( ( y3 - y2 ) * ( x2 - x1 ) == ( y2 - y1 ) * ( x3 - x2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT x1 , x2 , x3 , y1 , y2 , y3 = 1 , 1 , 0 , 1 , 6 , 9 NEW_LINE collinear ( x1 , y1 , x2 , y2 , x3 , y3 ) ; NEW_LINE
def rectCount ( n , m ) : NEW_LINE INDENT return ( m * n * ( n + 1 ) * ( m + 1 ) ) // 4 NEW_LINE DEDENT n , m = 5 , 4 NEW_LINE print ( rectCount ( n , m ) ) NEW_LINE
import math NEW_LINE def countRect ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for length in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT height = length NEW_LINE while ( height * length <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE height += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE print ( countRect ( n ) ) NEW_LINE
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT ax , ay = 5 , 0 NEW_LINE bx , by = 1 , 1 NEW_LINE cx , cy = 2 , 5 NEW_LINE print ( ax + cx - bx , " , " , ay + cy - by ) NEW_LINE DEDENT
def bestApproximate ( x , y , n ) : NEW_LINE INDENT sum_x = 0 NEW_LINE sum_y = 0 NEW_LINE sum_xy = 0 NEW_LINE sum_x2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum_x += x [ i ] NEW_LINE sum_y += y [ i ] NEW_LINE sum_xy += x [ i ] * y [ i ] NEW_LINE sum_x2 += pow ( x [ i ] , 2 ) NEW_LINE DEDENT m = ( float ) ( ( n * sum_xy - sum_x * sum_y ) / ( n * sum_x2 - pow ( sum_x , 2 ) ) ) ; NEW_LINE c = ( float ) ( sum_y - m * sum_x ) / n ; NEW_LINE print ( " m ▁ = ▁ " , m ) ; NEW_LINE print ( " c ▁ = ▁ " , c ) ; NEW_LINE DEDENT x = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE y = [ 14 , 27 , 40 , 55 , 68 ] NEW_LINE n = len ( x ) NEW_LINE bestApproximate ( x , y , n ) NEW_LINE
size = 4 NEW_LINE def checkStar ( mat ) : NEW_LINE INDENT global size NEW_LINE vertexD1 = 0 NEW_LINE vertexDn_1 = 0 NEW_LINE if ( size == 1 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 ) NEW_LINE DEDENT if ( size == 2 ) : NEW_LINE INDENT return ( mat [ 0 ] [ 0 ] == 0 and mat [ 0 ] [ 1 ] == 1 and mat [ 1 ] [ 0 ] == 1 and mat [ 1 ] [ 1 ] == 0 ) NEW_LINE DEDENT for i in range ( 0 , size ) : NEW_LINE INDENT degreeI = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT degreeI = degreeI + 1 NEW_LINE DEDENT DEDENT if ( degreeI == 1 ) : NEW_LINE INDENT vertexD1 = vertexD1 + 1 NEW_LINE DEDENT elif ( degreeI == size - 1 ) : NEW_LINE INDENT vertexDn_1 = vertexDn_1 + 1 NEW_LINE DEDENT DEDENT return ( vertexD1 == ( size - 1 ) and vertexDn_1 == 1 ) NEW_LINE DEDENT mat = [ [ 0 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] NEW_LINE if ( checkStar ( mat ) ) : NEW_LINE INDENT print ( " Star ▁ Graph " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Star ▁ Graph " ) NEW_LINE DEDENT
def getMinSteps ( n ) : NEW_LINE INDENT table = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT table [ i ] = n - i NEW_LINE DEDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( not ( i % 2 ) ) : NEW_LINE INDENT table [ i // 2 ] = min ( table [ i ] + 1 , table [ i // 2 ] ) NEW_LINE DEDENT if ( not ( i % 3 ) ) : NEW_LINE INDENT table [ i // 3 ] = min ( table [ i ] + 1 , table [ i // 3 ] ) NEW_LINE DEDENT DEDENT return table [ 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 14 NEW_LINE print ( getMinSteps ( n ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT vowel = " aeiou " NEW_LINE for i in range ( len ( vowel ) ) : NEW_LINE INDENT if ( vowel [ i ] == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def printRLE ( str , typed ) : NEW_LINE INDENT n = len ( str ) NEW_LINE m = len ( typed ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] != typed [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT if isVowel ( str [ i ] ) == False : NEW_LINE INDENT j = j + 1 NEW_LINE continue NEW_LINE DEDENT count1 = 1 NEW_LINE while ( i < n - 1 and ( str [ i ] == str [ i + 1 ] ) ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT count2 = 1 NEW_LINE while ( j < m - 1 and typed [ j ] == str [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT if count1 > count2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT name = " alex " NEW_LINE typed = " aaalaeex " NEW_LINE if ( printRLE ( name , typed ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def check ( degree , n ) : NEW_LINE INDENT deg_sum = sum ( degree ) NEW_LINE if ( 2 * ( n - 1 ) == deg_sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 5 NEW_LINE degree = [ 2 , 3 , 1 , 1 , 1 ] ; NEW_LINE if ( check ( degree , n ) ) : NEW_LINE INDENT print " Tree " NEW_LINE DEDENT else : NEW_LINE INDENT print " Graph " NEW_LINE DEDENT
def isInorder ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 19 , 23 , 25 , 30 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isInorder ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printSorted ( arr , start , end ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return NEW_LINE DEDENT printSorted ( arr , start * 2 + 1 , end ) NEW_LINE print ( arr [ start ] , end = " ▁ " ) NEW_LINE printSorted ( arr , start * 2 + 2 , end ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printSorted ( arr , 0 , arr_size - 1 ) NEW_LINE DEDENT
def isLeaf ( pre , i , n , Min , Max ) : NEW_LINE INDENT if i [ 0 ] >= n : NEW_LINE INDENT return False NEW_LINE DEDENT if pre [ i [ 0 ] ] > Min and pre [ i [ 0 ] ] < Max : NEW_LINE INDENT i [ 0 ] += 1 NEW_LINE left = isLeaf ( pre , i , n , Min , pre [ i [ 0 ] - 1 ] ) NEW_LINE right = isLeaf ( pre , i , n , pre [ i [ 0 ] - 1 ] , Max ) NEW_LINE if left == False and right == False : NEW_LINE INDENT print ( pre [ i [ 0 ] - 1 ] , end = " ▁ " ) NEW_LINE DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def printLeaves ( preorder , n ) : NEW_LINE INDENT i = [ 0 ] NEW_LINE INT_MIN , INT_MAX = - 999999999999 , 999999999999 NEW_LINE isLeaf ( preorder , i , n , INT_MIN , INT_MAX ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT preorder = [ 890 , 325 , 290 , 530 , 965 ] NEW_LINE n = len ( preorder ) NEW_LINE printLeaves ( preorder , n ) NEW_LINE DEDENT
def pairs ( arr , n , k ) : NEW_LINE INDENT smallest = 999999999999 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if abs ( arr [ i ] + arr [ j ] - k ) < smallest : NEW_LINE INDENT smallest = abs ( arr [ i ] + arr [ j ] - k ) NEW_LINE count = 1 NEW_LINE DEDENT elif abs ( arr [ i ] + arr [ j ] - k ) == smallest : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " Minimal ▁ Value ▁ = ▁ " , smallest ) NEW_LINE print ( " Total ▁ Pairs ▁ = ▁ " , count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 7 , 5 , 1 , 9 , 9 ] NEW_LINE k = 12 NEW_LINE n = len ( arr ) NEW_LINE pairs ( arr , n , k ) NEW_LINE DEDENT
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 1 , 14 , 4 , 15 , 9 , 7 , 20 , 11 ] NEW_LINE key = 20 NEW_LINE arraySize = len ( a ) NEW_LINE count = 0 NEW_LINE for i in range ( arraySize ) : NEW_LINE INDENT if a [ i ] <= key : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( " Rank ▁ of " , key , " in ▁ stream ▁ is : " , count - 1 ) NEW_LINE DEDENT
def middlesum ( mat , n ) : NEW_LINE INDENT row_sum = 0 NEW_LINE col_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT row_sum += mat [ n // 2 ] [ i ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ row ▁ = ▁ " , row_sum ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT col_sum += mat [ i ] [ n // 2 ] NEW_LINE DEDENT print ( " Sum ▁ of ▁ middle ▁ column ▁ = ▁ " , col_sum ) NEW_LINE DEDENT mat = [ [ 2 , 5 , 7 ] , [ 3 , 7 , 2 ] , [ 5 , 6 , 9 ] ] NEW_LINE middlesum ( mat , 3 ) NEW_LINE
M = 3 NEW_LINE N = 3 NEW_LINE matrix = [ [ 12 , 23 , 34 ] , [ 45 , 56 , 67 ] , [ 78 , 89 , 91 ] ] NEW_LINE def rotateMatrix ( k ) : NEW_LINE INDENT global M , N , matrix NEW_LINE temp = [ 0 ] * M NEW_LINE k = k % M NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for t in range ( 0 , M - k ) : NEW_LINE INDENT temp [ t ] = matrix [ i ] [ t ] NEW_LINE DEDENT for j in range ( M - k , M ) : NEW_LINE INDENT matrix [ i ] [ j - M + k ] = matrix [ i ] [ j ] NEW_LINE DEDENT for j in range ( k , M ) : NEW_LINE INDENT matrix [ i ] [ j ] = temp [ j - k ] NEW_LINE DEDENT DEDENT DEDENT def displayMatrix ( ) : NEW_LINE INDENT global M , N , matrix NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , M ) : NEW_LINE INDENT print ( " { } ▁ " . format ( matrix [ i ] [ j ] ) , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT k = 2 NEW_LINE rotateMatrix ( k ) NEW_LINE displayMatrix ( ) NEW_LINE
N = 3 ; NEW_LINE def multiply ( mat , res ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] = 0 ; NEW_LINE for k in range ( N ) : NEW_LINE INDENT res [ i ] [ j ] += mat [ i ] [ k ] * mat [ k ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return res ; NEW_LINE DEDENT def InvolutoryMatrix ( mat ) : NEW_LINE INDENT res = [ [ 0 for i in range ( N ) ] for j in range ( N ) ] ; NEW_LINE res = multiply ( mat , res ) ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( i == j and res [ i ] [ j ] != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( i != j and res [ i ] [ j ] != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT mat = [ [ 1 , 0 , 0 ] , [ 0 , - 1 , 0 ] , [ 0 , 0 , - 1 ] ] ; NEW_LINE if ( InvolutoryMatrix ( mat ) ) : NEW_LINE INDENT print ( " Involutory ▁ Matrix " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Involutory ▁ Matrix " ) ; NEW_LINE DEDENT
def interchangeFirstLast ( mat , n , m ) : NEW_LINE INDENT rows = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = mat [ 0 ] [ i ] NEW_LINE mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] NEW_LINE mat [ rows - 1 ] [ i ] = t NEW_LINE DEDENT DEDENT mat = [ [ 8 , 9 , 7 , 6 ] , [ 4 , 7 , 6 , 5 ] , [ 3 , 2 , 1 , 8 ] , [ 9 , 9 , 7 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE interchangeFirstLast ( mat , n , m ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT
def checkMarkov ( m ) : NEW_LINE INDENT for i in range ( 0 , len ( m ) ) : NEW_LINE INDENT sm = 0 NEW_LINE for j in range ( 0 , len ( m [ i ] ) ) : NEW_LINE INDENT sm = sm + m [ i ] [ j ] NEW_LINE DEDENT if ( sm != 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT m = [ [ 0 , 0 , 1 ] , [ 0.5 , 0 , 0.5 ] , [ 1 , 0 , 0 ] ] NEW_LINE if ( checkMarkov ( m ) ) : NEW_LINE INDENT print ( " ▁ yes ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ no ▁ " ) NEW_LINE DEDENT
N = 4 NEW_LINE def isDiagonalMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 4 , 0 , 0 , 0 ] , [ 0 , 7 , 0 , 0 ] , [ 0 , 0 , 5 , 0 ] , [ 0 , 0 , 0 , 1 ] ] NEW_LINE if ( isDiagonalMatrix ( mat ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
N = 4 NEW_LINE def isScalarMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( ( i != j ) and ( mat [ i ] [ j ] != 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ i ] != mat [ i + 1 ] [ i + 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 2 , 0 , 0 , 0 ] , [ 0 , 2 , 0 , 0 ] , [ 0 , 0 , 2 , 0 ] , [ 0 , 0 , 0 , 2 ] ] NEW_LINE if ( isScalarMatrix ( mat ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
N = 3 NEW_LINE def isMagicSquare ( mat ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT s = s + mat [ i ] [ i ] NEW_LINE DEDENT s2 = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT s2 = s2 + mat [ i ] [ N - i - 1 ] NEW_LINE DEDENT if ( s != s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT rowSum = 0 ; NEW_LINE for j in range ( 0 , N ) : NEW_LINE INDENT rowSum += mat [ i ] [ j ] NEW_LINE DEDENT if ( rowSum != s ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT colSum = 0 NEW_LINE for j in range ( 0 , N ) : NEW_LINE INDENT colSum += mat [ j ] [ i ] NEW_LINE DEDENT if ( s != colSum ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT mat = [ [ 2 , 7 , 6 ] , [ 9 , 5 , 1 ] , [ 4 , 3 , 8 ] ] NEW_LINE if ( isMagicSquare ( mat ) ) : NEW_LINE INDENT print ( " Magic ▁ Square " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ magic ▁ Square " ) NEW_LINE DEDENT
def subCount ( arr , n , k ) : NEW_LINE INDENT mod = [ 0 ] * k ; NEW_LINE cumSum = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cumSum = cumSum + arr [ i ] ; NEW_LINE mod [ ( ( cumSum % k ) + k ) % k ] = mod [ ( ( cumSum % k ) + k ) % k ] + 1 ; NEW_LINE DEDENT result = 0 ; NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT if ( mod [ i ] > 1 ) : NEW_LINE INDENT result = result + int ( ( mod [ i ] * ( mod [ i ] - 1 ) ) / 2 ) ; NEW_LINE DEDENT DEDENT result = result + mod [ 0 ] ; NEW_LINE return result ; NEW_LINE DEDENT def countSubmatrix ( mat , n , k ) : NEW_LINE INDENT tot_count = 0 ; NEW_LINE temp = [ 0 ] * n ; NEW_LINE for left in range ( 0 , n - 1 ) : NEW_LINE INDENT for right in range ( left , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT temp [ i ] = ( temp [ i ] + mat [ i ] [ right ] ) ; NEW_LINE DEDENT tot_count = ( tot_count + subCount ( temp , n , k ) ) ; NEW_LINE DEDENT DEDENT return tot_count ; NEW_LINE DEDENT mat = [ [ 5 , - 1 , 6 ] , [ - 2 , 3 , 8 ] , [ 7 , 4 , - 9 ] ] ; NEW_LINE n = 3 ; NEW_LINE k = 4 ; NEW_LINE print ( " Count ▁ = ▁ { } " . format ( countSubmatrix ( mat , n , k ) ) ) ; NEW_LINE
import math NEW_LINE def find ( n , k ) : NEW_LINE INDENT if ( n + 1 >= k ) : NEW_LINE INDENT return ( k - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * n + 1 - k ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE k = 7 NEW_LINE freq = find ( n , k ) NEW_LINE if ( freq < 0 ) : NEW_LINE INDENT print ( " ▁ element ▁ not ▁ exist " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ Frequency ▁ of ▁ " , k , " ▁ is ▁ " , freq ) NEW_LINE DEDENT
def ZigZag ( rows , columns , numbers ) : NEW_LINE INDENT k = 0 NEW_LINE arr = [ [ 0 for i in range ( columns ) ] for j in range ( rows ) ] NEW_LINE for i in range ( rows ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < columns and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT j = columns - 1 NEW_LINE while j >= 0 and numbers [ k ] > 0 : NEW_LINE INDENT arr [ i ] [ j ] = k + 1 NEW_LINE numbers [ k ] -= 1 NEW_LINE if numbers [ k ] == 0 : NEW_LINE INDENT k += 1 NEW_LINE DEDENT j -= 1 NEW_LINE DEDENT DEDENT DEDENT for i in arr : NEW_LINE INDENT for j in i : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT rows = 4 ; NEW_LINE columns = 5 ; NEW_LINE Numbers = [ 3 , 4 , 2 , 2 , 3 , 1 , 5 ] NEW_LINE ZigZag ( rows , columns , Numbers ) NEW_LINE
n = 5 NEW_LINE def FindMaxProduct ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i ] [ j - 1 ] * arr [ i ] [ j - 2 ] * arr [ i ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j ] * arr [ i - 2 ] [ j ] * arr [ i - 3 ] [ j ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 3 ) >= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j - 1 ] * arr [ i - 2 ] [ j - 2 ] * arr [ i - 3 ] [ j - 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT if ( ( i - 3 ) >= 0 and ( j - 1 ) <= 0 ) : NEW_LINE INDENT result = ( arr [ i ] [ j ] * arr [ i - 1 ] [ j + 1 ] * arr [ i - 2 ] [ j + 2 ] * arr [ i - 3 ] [ j + 3 ] ) NEW_LINE if ( max < result ) : NEW_LINE INDENT max = result NEW_LINE DEDENT DEDENT DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 6 , 7 , 8 , 9 , 1 ] , [ 2 , 3 , 4 , 5 , 6 ] , [ 7 , 8 , 9 , 1 , 0 ] , [ 9 , 6 , 4 , 2 , 3 ] ] NEW_LINE print ( FindMaxProduct ( arr , n ) ) NEW_LINE DEDENT
N = 3 NEW_LINE def minimumflip ( mat , n ) : NEW_LINE INDENT transpose = [ [ 0 ] * n ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT transpose [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE DEDENT DEDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if transpose [ i ] [ j ] != mat [ i ] [ j ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return int ( flip / 2 ) NEW_LINE DEDENT n = 3 NEW_LINE mat = [ [ 0 , 0 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] ] NEW_LINE print ( minimumflip ( mat , n ) ) NEW_LINE
N = 3 NEW_LINE def minimumflip ( mat , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if mat [ i ] [ j ] != mat [ j ] [ i ] : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT DEDENT return flip NEW_LINE DEDENT n = 3 NEW_LINE mat = [ [ 0 , 0 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] ] NEW_LINE print ( minimumflip ( mat , n ) ) NEW_LINE
MAX = 100 NEW_LINE def freq ( ar , m , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( ar [ i ] [ j ] % 2 ) == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT DEDENT print ( " ▁ Frequency ▁ of ▁ odd ▁ number ▁ = " , odd ) NEW_LINE print ( " ▁ Frequency ▁ of ▁ even ▁ number ▁ = " , even ) NEW_LINE DEDENT m = 3 NEW_LINE n = 3 NEW_LINE array = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE freq ( array , m , n ) NEW_LINE
MAX = 100 NEW_LINE def HalfDiagonalSums ( mat , n ) : NEW_LINE INDENT diag1_left = 0 NEW_LINE diag1_right = 0 NEW_LINE diag2_left = 0 NEW_LINE diag2_right = 0 NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE while i < n : NEW_LINE INDENT if ( i < n // 2 ) : NEW_LINE INDENT diag1_left += mat [ i ] [ i ] NEW_LINE diag2_left += mat [ j ] [ i ] NEW_LINE DEDENT elif ( i > n // 2 ) : NEW_LINE INDENT diag1_right += mat [ i ] [ i ] NEW_LINE diag2_right += mat [ j ] [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return ( diag1_left == diag2_right and diag2_right == diag2_left and diag1_right == diag2_left and diag2_right == mat [ n // 2 ] [ n // 2 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ [ 2 , 9 , 1 , 4 , - 2 ] , [ 6 , 7 , 2 , 11 , 4 ] , [ 4 , 2 , 9 , 2 , 4 ] , [ 1 , 9 , 2 , 4 , 4 ] , [ 0 , 2 , 4 , 2 , 5 ] ] NEW_LINE print ( " Yes " ) if ( HalfDiagonalSums ( a , 5 ) ) else print ( " No " ) NEW_LINE DEDENT
def Identity ( size ) : NEW_LINE INDENT for row in range ( 0 , size ) : NEW_LINE INDENT for col in range ( 0 , size ) : NEW_LINE INDENT if ( row == col ) : NEW_LINE INDENT print ( "1 ▁ " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "0 ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT size = 5 NEW_LINE Identity ( size ) NEW_LINE
MAX = 100 ; NEW_LINE def isIdentity ( mat , N ) : NEW_LINE INDENT for row in range ( N ) : NEW_LINE INDENT for col in range ( N ) : NEW_LINE INDENT if ( row == col and mat [ row ] [ col ] != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT elif ( row != col and mat [ row ] [ col ] != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT N = 4 ; NEW_LINE mat = [ [ 1 , 0 , 0 , 0 ] , [ 0 , 1 , 0 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 1 ] ] ; NEW_LINE if ( isIdentity ( mat , N ) ) : NEW_LINE INDENT print ( " Yes ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) ; NEW_LINE DEDENT
def modPower ( a , t ) : NEW_LINE INDENT now = a ; NEW_LINE ret = 1 ; NEW_LINE mod = 100000007 ; NEW_LINE while ( t ) : NEW_LINE INDENT if ( t & 1 ) : NEW_LINE INDENT ret = now * ( ret % mod ) ; NEW_LINE DEDENT now = now * ( now % mod ) ; NEW_LINE t >>= 1 ; NEW_LINE DEDENT return ret ; NEW_LINE DEDENT def countWays ( n , m , k ) : NEW_LINE INDENT mod = 100000007 ; NEW_LINE if ( k == - 1 and ( ( n + m ) % 2 == 1 ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n == 1 or m == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return ( modPower ( modPower ( 2 , n - 1 ) , m - 1 ) % mod ) ; NEW_LINE DEDENT n = 2 ; NEW_LINE m = 7 ; NEW_LINE k = 1 ; NEW_LINE print ( countWays ( n , m , k ) ) ; NEW_LINE
from builtins import range NEW_LINE MAX = 100 ; NEW_LINE def imageSwap ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT t = mat [ i ] [ j ] ; NEW_LINE mat [ i ] [ j ] = mat [ j ] [ i ] NEW_LINE mat [ j ] [ i ] = t NEW_LINE DEDENT DEDENT DEDENT def printMatrix ( mat , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 9 , 10 , 11 , 12 ] , [ 13 , 14 , 15 , 16 ] ; NEW_LINE n = 4 ; NEW_LINE imageSwap ( mat , n ) ; NEW_LINE printMatrix ( mat , n ) ; NEW_LINE DEDENT
def search ( mat , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE j = n - 1 NEW_LINE while ( i < n and j >= 0 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == x ) : NEW_LINE INDENT print ( " n ▁ Found ▁ at ▁ " , i , " , ▁ " , j ) NEW_LINE return 1 NEW_LINE DEDENT if ( mat [ i ] [ j ] > x ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT print ( " Element ▁ not ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] ] NEW_LINE search ( mat , 4 , 29 ) NEW_LINE
def fill0X ( m , n ) : NEW_LINE INDENT i , k , l = 0 , 0 , 0 NEW_LINE r = m NEW_LINE c = n NEW_LINE a = [ [ None ] * n for i in range ( m ) ] NEW_LINE x = ' X ' NEW_LINE while k < m and l < n : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = x NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = x NEW_LINE DEDENT n -= 1 NEW_LINE if k < m : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = x NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if l < n : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = x NEW_LINE DEDENT l += 1 NEW_LINE DEDENT x = ' X ' if x == '0' else '0' NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT for j in range ( c ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " Output ▁ for ▁ m ▁ = ▁ 5 , ▁ n ▁ = ▁ 6" ) NEW_LINE fill0X ( 5 , 6 ) NEW_LINE print ( " Output ▁ for ▁ m ▁ = ▁ 4 , ▁ n ▁ = ▁ 4" ) NEW_LINE fill0X ( 4 , 4 ) NEW_LINE print ( " Output ▁ for ▁ m ▁ = ▁ 3 , ▁ n ▁ = ▁ 4" ) NEW_LINE fill0X ( 3 , 4 ) NEW_LINE DEDENT
n = 4 NEW_LINE def calculateEnergy ( mat , n ) : NEW_LINE INDENT tot_energy = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT q = mat [ i ] [ j ] // n NEW_LINE i_des = q NEW_LINE j_des = mat [ i ] [ j ] - ( n * q ) NEW_LINE tot_energy += ( abs ( i_des - i ) + abs ( j_des - j ) ) NEW_LINE DEDENT DEDENT return tot_energy NEW_LINE DEDENT mat = [ [ 4 , 7 , 0 , 3 ] , [ 8 , 5 , 6 , 1 ] , [ 9 , 11 , 10 , 2 ] , [ 15 , 13 , 14 , 12 ] ] NEW_LINE print ( " Total ▁ energy ▁ required ▁ = ▁ " , calculateEnergy ( mat , n ) , " units " ) NEW_LINE
MAX = 100 NEW_LINE def isUnique ( mat , i , j , n , m ) : NEW_LINE INDENT sumrow = 0 NEW_LINE for k in range ( m ) : NEW_LINE INDENT sumrow += mat [ i ] [ k ] NEW_LINE if ( sumrow > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT sumcol = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT sumcol += mat [ k ] [ j ] NEW_LINE if ( sumcol > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countUnique ( mat , n , m ) : NEW_LINE INDENT uniquecount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] and isUnique ( mat , i , j , n , m ) ) : NEW_LINE INDENT uniquecount += 1 NEW_LINE DEDENT DEDENT DEDENT return uniquecount NEW_LINE DEDENT mat = [ [ 0 , 1 , 0 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] ] NEW_LINE print ( countUnique ( mat , 3 , 4 ) ) NEW_LINE
MAX = 100 NEW_LINE def isSparse ( array , m , n ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( array [ i ] [ j ] == 0 ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT return ( counter > ( ( m * n ) // 2 ) ) NEW_LINE DEDENT array = [ [ 1 , 0 , 3 ] , [ 0 , 0 , 4 ] , [ 6 , 0 , 0 ] ] NEW_LINE m = 3 NEW_LINE n = 3 NEW_LINE if ( isSparse ( array , m , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
Max = 100 NEW_LINE def countCommon ( mat , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if mat [ i ] [ i ] == mat [ i ] [ n - i - 1 ] : NEW_LINE INDENT res = res + 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( countCommon ( mat , 3 ) ) NEW_LINE
MAX = 100 ; NEW_LINE def areSumSame ( a , n , m ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for j in range ( 0 , m ) : NEW_LINE INDENT sum1 += a [ i ] [ j ] NEW_LINE sum2 += a [ j ] [ i ] NEW_LINE DEDENT if ( sum1 == sum2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT n = 4 ; NEW_LINE m = 4 ; NEW_LINE M = [ [ 1 , 2 , 3 , 4 ] , [ 9 , 5 , 3 , 1 ] , [ 0 , 3 , 5 , 6 ] , [ 0 , 4 , 5 , 6 ] ] NEW_LINE print ( areSumSame ( M , n , m ) ) NEW_LINE
N = 4 NEW_LINE def findMax ( arr ) : NEW_LINE INDENT row = 0 NEW_LINE j = N - 1 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT while ( arr [ i ] [ j ] == 1 and j >= 0 ) : NEW_LINE INDENT row = i NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT print ( " Row ▁ number ▁ = ▁ " , row + 1 , " , ▁ MaxCount ▁ = ▁ " , N - 1 - j ) NEW_LINE DEDENT arr = [ [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 1 , 1 , 1 ] ] NEW_LINE findMax ( arr ) NEW_LINE
n = 4 ; NEW_LINE m = 4 ; NEW_LINE def findPossibleMoves ( mat , p , q ) : NEW_LINE INDENT global n , m ; NEW_LINE X = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] ; NEW_LINE Y = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] ; NEW_LINE count = 0 ; NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT x = p + X [ i ] ; NEW_LINE y = q + Y [ i ] ; NEW_LINE if ( x >= 0 and y >= 0 and x < n and y < m and mat [ x ] [ y ] == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 0 , 1 , 0 ] , [ 0 , 1 , 1 , 1 ] , [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 1 ] ] ; NEW_LINE p , q = 2 , 2 ; NEW_LINE print ( findPossibleMoves ( mat , p , q ) ) ; NEW_LINE DEDENT
MAX = 100 NEW_LINE def printDiagonalSums ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT principal += mat [ i ] [ j ] NEW_LINE DEDENT if ( ( i + j ) == ( n - 1 ) ) : NEW_LINE INDENT secondary += mat [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( " Principal ▁ Diagonal : " , principal ) NEW_LINE print ( " Secondary ▁ Diagonal : " , secondary ) NEW_LINE DEDENT a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE printDiagonalSums ( a , 4 ) NEW_LINE
MAX = 100 NEW_LINE def printDiagonalSums ( mat , n ) : NEW_LINE INDENT principal = 0 NEW_LINE secondary = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT principal += mat [ i ] [ i ] NEW_LINE secondary += mat [ i ] [ n - i - 1 ] NEW_LINE DEDENT print ( " Principal ▁ Diagonal : " , principal ) NEW_LINE print ( " Secondary ▁ Diagonal : " , secondary ) NEW_LINE DEDENT a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE printDiagonalSums ( a , 4 ) NEW_LINE
MAX = 100 NEW_LINE def printBoundary ( a , m , n ) : NEW_LINE INDENT for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT print a [ i ] [ j ] , NEW_LINE DEDENT elif ( i == m - 1 ) : NEW_LINE INDENT print a [ i ] [ j ] , NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT print a [ i ] [ j ] , NEW_LINE DEDENT elif ( j == n - 1 ) : NEW_LINE INDENT print a [ i ] [ j ] , NEW_LINE DEDENT else : NEW_LINE INDENT print " ▁ " , NEW_LINE DEDENT DEDENT print NEW_LINE DEDENT DEDENT a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE printBoundary ( a , 4 , 4 ) NEW_LINE
MAX = 100 NEW_LINE def printBoundary ( a , m , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( i == m - 1 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT elif ( j == n - 1 ) : NEW_LINE INDENT sum += a [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT a = [ [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] , [ 1 , 2 , 3 , 4 ] , [ 5 , 6 , 7 , 8 ] ] NEW_LINE sum = printBoundary ( a , 4 , 4 ) NEW_LINE print " Sum ▁ of ▁ boundary ▁ elements ▁ is " , sum NEW_LINE
MAX = 100 NEW_LINE def printSpiral ( mat , r , c ) : NEW_LINE INDENT a = 0 NEW_LINE b = 2 NEW_LINE low_row = 0 if ( 0 > a ) else a NEW_LINE low_column = 0 if ( 0 > b ) else b - 1 NEW_LINE high_row = r - 1 if ( ( a + 1 ) >= r ) else a + 1 NEW_LINE high_column = c - 1 if ( ( b + 1 ) >= c ) else b + 1 NEW_LINE while ( ( low_row > 0 - r and low_column > 0 - c ) ) : NEW_LINE INDENT i = low_column + 1 NEW_LINE while ( i <= high_column and i < c and low_row >= 0 ) : NEW_LINE INDENT print ( mat [ low_row ] [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT low_row -= 1 NEW_LINE i = low_row + 2 NEW_LINE while ( i <= high_row and i < r and high_column < c ) : NEW_LINE INDENT print ( mat [ i ] [ high_column ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT high_column += 1 NEW_LINE i = high_column - 2 NEW_LINE while ( i >= low_column and i >= 0 and high_row < r ) : NEW_LINE INDENT print ( mat [ high_row ] [ i ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT high_row += 1 NEW_LINE i = high_row - 2 NEW_LINE while ( i > low_row and i >= 0 and low_column >= 0 ) : NEW_LINE INDENT print ( mat [ i ] [ low_column ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT low_column -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE r = 3 NEW_LINE c = 3 NEW_LINE printSpiral ( mat , r , c ) NEW_LINE DEDENT
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT d1 += arr [ i ] [ j ] NEW_LINE DEDENT if ( i == n - j - 1 ) : NEW_LINE INDENT d2 += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return abs ( d1 - d2 ) ; NEW_LINE DEDENT n = 3 NEW_LINE arr = [ [ 11 , 2 , 4 ] , [ 4 , 5 , 6 ] , [ 10 , 8 , - 12 ] ] NEW_LINE print ( difference ( arr , n ) ) NEW_LINE
def difference ( arr , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT d1 = d1 + arr [ i ] [ i ] NEW_LINE d2 = d2 + arr [ i ] [ n - i - 1 ] NEW_LINE DEDENT return abs ( d1 - d2 ) NEW_LINE DEDENT n = 3 NEW_LINE arr = [ [ 11 , 2 , 4 ] , [ 4 , 5 , 6 ] , [ 10 , 8 , - 12 ] ] NEW_LINE print ( difference ( arr , n ) ) NEW_LINE
def spiralFill ( m , n , a ) : NEW_LINE INDENT val = 1 NEW_LINE k , l = 0 , 0 NEW_LINE while ( k < m and l < n ) : NEW_LINE INDENT for i in range ( l , n ) : NEW_LINE INDENT a [ k ] [ i ] = val NEW_LINE val += 1 NEW_LINE DEDENT k += 1 NEW_LINE for i in range ( k , m ) : NEW_LINE INDENT a [ i ] [ n - 1 ] = val NEW_LINE val += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if ( k < m ) : NEW_LINE INDENT for i in range ( n - 1 , l - 1 , - 1 ) : NEW_LINE INDENT a [ m - 1 ] [ i ] = val NEW_LINE val += 1 NEW_LINE DEDENT m -= 1 NEW_LINE DEDENT if ( l < n ) : NEW_LINE INDENT for i in range ( m - 1 , k - 1 , - 1 ) : NEW_LINE INDENT a [ i ] [ l ] = val NEW_LINE val += 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m , n = 4 , 4 NEW_LINE a = [ [ 0 for j in range ( m ) ] for i in range ( n ) ] NEW_LINE spiralFill ( m , n , a ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ' ' ) NEW_LINE DEDENT DEDENT
MAX = 100 NEW_LINE def MAXMIN ( arr , n ) : NEW_LINE INDENT MIN = 10 ** 9 NEW_LINE MAX = - 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n // 2 + 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT if ( MIN > arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT MIN = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT if ( MAX < arr [ i ] [ j ] ) : NEW_LINE INDENT MAX = arr [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( MIN > arr [ i ] [ j ] ) : NEW_LINE INDENT MIN = arr [ i ] [ j ] NEW_LINE DEDENT if ( MAX < arr [ i ] [ n - j - 1 ] ) : NEW_LINE INDENT MAX = arr [ i ] [ n - j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( " MAXimum ▁ = " , MAX , " , ▁ MINimum ▁ = " , MIN ) NEW_LINE DEDENT arr = [ [ 5 , 9 , 11 ] , [ 25 , 0 , 14 ] , [ 21 , 6 , 4 ] ] NEW_LINE MAXMIN ( arr , 3 ) NEW_LINE
def minOperation ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE for k in range ( i + 1 ) : NEW_LINE INDENT for h in range ( j + 1 ) : NEW_LINE INDENT if ( arr [ k ] [ h ] == 1 ) : NEW_LINE INDENT arr [ k ] [ h ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ k ] [ h ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ 0 , 0 , 1 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] ] NEW_LINE M = 5 NEW_LINE N = 5 NEW_LINE print ( minOperation ( mat ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT ans = 0 ; temp = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if temp < n : NEW_LINE INDENT temp = i - 1 NEW_LINE num = 1 NEW_LINE while temp < n : NEW_LINE INDENT if temp + i <= n : NEW_LINE INDENT ans += i * num NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( n - temp ) * num NEW_LINE DEDENT temp += i NEW_LINE num += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT N = 2 NEW_LINE print ( findSum ( N ) ) NEW_LINE
def countOps ( A , B , m , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT A [ i ] [ j ] -= B [ i ] [ j ] ; NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( A [ i ] [ j ] - A [ i ] [ 0 ] - A [ 0 ] [ j ] + A [ 0 ] [ 0 ] != 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT DEDENT result = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result += abs ( A [ i ] [ 0 ] ) ; NEW_LINE DEDENT for j in range ( m ) : NEW_LINE INDENT result += abs ( A [ 0 ] [ j ] - A [ 0 ] [ 0 ] ) ; NEW_LINE DEDENT return ( result ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; NEW_LINE B = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEW_LINE print ( countOps ( A , B , 3 , 3 ) ) ; NEW_LINE DEDENT
def printCoils ( n ) : NEW_LINE INDENT m = 8 * n * n NEW_LINE coil1 = [ 0 ] * m NEW_LINE coil1 [ 0 ] = 8 * n * n + 2 * n NEW_LINE curr = coil1 [ 0 ] NEW_LINE nflg = 1 NEW_LINE step = 2 NEW_LINE index = 1 NEW_LINE while ( index < m ) : NEW_LINE INDENT for i in range ( step ) : NEW_LINE INDENT curr = coil1 [ index ] = ( curr - 4 * n * nflg ) NEW_LINE index += 1 NEW_LINE if ( index >= m ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( index >= m ) : NEW_LINE INDENT break NEW_LINE DEDENT for i in range ( step ) : NEW_LINE INDENT curr = coil1 [ index ] = curr + nflg NEW_LINE index += 1 NEW_LINE if ( index >= m ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT nflg = nflg * ( - 1 ) NEW_LINE step += 2 NEW_LINE DEDENT coil2 = [ 0 ] * m NEW_LINE i = 0 NEW_LINE while ( i < 8 * n * n ) : NEW_LINE INDENT coil2 [ i ] = 16 * n * n + 1 - coil1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT print ( " Coil ▁ 1 ▁ : " , end = " ▁ " ) NEW_LINE i = 0 NEW_LINE while ( i < 8 * n * n ) : NEW_LINE INDENT print ( coil1 [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT print ( " Coil 2 : " , ▁ end ▁ = ▁ "   " ) NEW_LINE i = 0 NEW_LINE while ( i < 8 * n * n ) : NEW_LINE INDENT print ( coil2 [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 1 NEW_LINE printCoils ( n ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT arr = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = abs ( i - j ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT sum += arr [ i ] [ j ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += i * ( n - i ) NEW_LINE DEDENT return 2 * sum NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def spiralDiaSum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 4 * n * n - 6 * n + 6 + spiralDiaSum ( n - 2 ) ) NEW_LINE DEDENT n = 7 ; NEW_LINE print ( spiralDiaSum ( n ) ) NEW_LINE
R = 3 NEW_LINE C = 5 NEW_LINE def numofneighbour ( mat , i , j ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( i > 0 and mat [ i - 1 ] [ j ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( j > 0 and mat [ i ] [ j - 1 ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( i < R - 1 and mat [ i + 1 ] [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( j < C - 1 and mat [ i ] [ j + 1 ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def findperimeter ( mat ) : NEW_LINE INDENT perimeter = 0 ; NEW_LINE for i in range ( 0 , R ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT if ( mat [ i ] [ j ] ) : NEW_LINE INDENT perimeter += ( 4 - numofneighbour ( mat , i , j ) ) ; NEW_LINE DEDENT DEDENT DEDENT return perimeter ; NEW_LINE DEDENT mat = [ [ 0 , 1 , 0 , 0 , 0 ] , [ 1 , 1 , 1 , 0 , 0 ] , [ 1 , 0 , 0 , 0 , 0 ] ] NEW_LINE print ( findperimeter ( mat ) , end = " " ) ; NEW_LINE
MAX = 100 NEW_LINE def printMatrixDiagonal ( mat , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE isUp = True NEW_LINE while k < n * n : NEW_LINE INDENT if isUp : NEW_LINE INDENT while i >= 0 and j < n : NEW_LINE INDENT print ( str ( mat [ i ] [ j ] ) , end = " ▁ " ) NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE i -= 1 NEW_LINE DEDENT if i < 0 and j <= n - 1 : NEW_LINE INDENT i = 0 NEW_LINE DEDENT if j == n : NEW_LINE INDENT i = i + 2 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while j >= 0 and i < n : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT if j < 0 and i <= n - 1 : NEW_LINE INDENT j = 0 NEW_LINE DEDENT if i == n : NEW_LINE INDENT j = j + 2 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT isUp = not isUp NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE n = 3 NEW_LINE printMatrixDiagonal ( mat , n ) NEW_LINE DEDENT
def maxRowDiff ( mat , m , n ) : NEW_LINE INDENT rowSum = [ 0 ] * m NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT sum += mat [ i ] [ j ] NEW_LINE DEDENT rowSum [ i ] = sum NEW_LINE DEDENT max_diff = rowSum [ 1 ] - rowSum [ 0 ] NEW_LINE min_element = rowSum [ 0 ] NEW_LINE for i in range ( 1 , m ) : NEW_LINE INDENT if ( rowSum [ i ] - min_element > max_diff ) : NEW_LINE INDENT max_diff = rowSum [ i ] - min_element NEW_LINE DEDENT if ( rowSum [ i ] < min_element ) : NEW_LINE INDENT min_element = rowSum [ i ] NEW_LINE DEDENT DEDENT return max_diff NEW_LINE DEDENT m = 5 NEW_LINE n = 4 NEW_LINE mat = [ [ - 1 , 2 , 3 , 4 ] , [ 5 , 3 , - 2 , 1 ] , [ 6 , 7 , 2 , - 3 ] , [ 2 , 9 , 1 , 4 ] , [ 2 , 1 , - 2 , 0 ] ] NEW_LINE print ( maxRowDiff ( mat , m , n ) ) NEW_LINE
def sortedCount ( mat , r , c ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( r ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( c - 1 ) : NEW_LINE INDENT if mat [ i ] [ j + 1 ] <= mat [ i ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j == c - 2 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , r ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( c - 1 , 0 , - 1 ) : NEW_LINE INDENT if mat [ i ] [ j - 1 ] <= mat [ i ] [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if c > 1 and j == 1 : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT m , n = 4 , 5 NEW_LINE mat = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 4 , 3 , 1 , 2 , 6 ] , [ 8 , 7 , 6 , 5 , 4 ] , [ 5 , 7 , 8 , 9 , 10 ] ] NEW_LINE print ( sortedCount ( mat , m , n ) ) NEW_LINE
MAX = 1000 NEW_LINE def maxXOR ( mat , N ) : NEW_LINE INDENT max_xor = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT r_xor = 0 NEW_LINE c_xor = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT r_xor = r_xor ^ mat [ i ] [ j ] NEW_LINE c_xor = c_xor ^ mat [ j ] [ i ] NEW_LINE DEDENT if ( max_xor < max ( r_xor , c_xor ) ) : NEW_LINE INDENT max_xor = max ( r_xor , c_xor ) NEW_LINE DEDENT DEDENT return max_xor NEW_LINE DEDENT N = 3 NEW_LINE mat = [ [ 1 , 5 , 4 ] , [ 3 , 7 , 2 ] , [ 5 , 9 , 10 ] ] NEW_LINE print ( " maximum ▁ XOR ▁ value ▁ : ▁ " , maxXOR ( mat , N ) ) NEW_LINE
def direction ( R , C ) : NEW_LINE INDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if R == C and R % 2 != 0 and C % 2 != 0 : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT if R == C and R % 2 == 0 and C % 2 == 0 : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Left " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 == 0 and C % 2 == 0 and R > C ) : NEW_LINE INDENT print ( " Up " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R > C ) : NEW_LINE INDENT print ( " Down " ) NEW_LINE return NEW_LINE DEDENT if ( R != C and R % 2 != 0 and C % 2 != 0 and R < C ) : NEW_LINE INDENT print ( " Right " ) NEW_LINE return NEW_LINE DEDENT DEDENT R = 3 ; C = 1 NEW_LINE direction ( R , C ) NEW_LINE
N = 5 NEW_LINE M = 4 NEW_LINE def checkDiagonal ( mat , i , j ) : NEW_LINE INDENT res = mat [ i ] [ j ] NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE while ( i < N and j < M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != res ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def isToeplitz ( mat ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if not ( checkDiagonal ( mat , 0 , j ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT if not ( checkDiagonal ( mat , i , 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 6 , 7 , 8 , 9 ] , [ 4 , 6 , 7 , 8 ] , [ 1 , 4 , 6 , 7 ] , [ 0 , 1 , 4 , 6 ] , [ 2 , 0 , 1 , 4 ] ] NEW_LINE if ( isToeplitz ( mat ) ) : NEW_LINE INDENT print ( " Matrix ▁ is ▁ a ▁ Toeplitz " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Matrix ▁ is ▁ not ▁ a ▁ Toeplitz " ) NEW_LINE DEDENT DEDENT
N = 5 ; NEW_LINE def countZeroes ( mat ) : NEW_LINE INDENT row = N - 1 ; NEW_LINE col = 0 ; NEW_LINE count = 0 ; NEW_LINE while ( col < N ) : NEW_LINE INDENT while ( mat [ row ] [ col ] ) : NEW_LINE INDENT if ( row < 0 ) : NEW_LINE INDENT return count ; NEW_LINE DEDENT row = row - 1 ; NEW_LINE DEDENT count = count + ( row + 1 ) ; NEW_LINE col = col + 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT mat = [ [ 0 , 0 , 0 , 0 , 1 ] , [ 0 , 0 , 0 , 1 , 1 ] , [ 0 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 ] ] ; NEW_LINE print ( countZeroes ( mat ) ) ; NEW_LINE
N = 10 NEW_LINE def findLargestPlus ( mat ) : NEW_LINE INDENT left = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE right = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE top = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE bottom = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT top [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE bottom [ N - 1 ] [ i ] = mat [ N - 1 ] [ i ] NEW_LINE left [ i ] [ 0 ] = mat [ i ] [ 0 ] NEW_LINE right [ i ] [ N - 1 ] = mat [ i ] [ N - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT left [ i ] [ j ] = left [ i ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] [ j ] = 0 NEW_LINE DEDENT if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT top [ j ] [ i ] = top [ j - 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT top [ j ] [ i ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE if ( mat [ j ] [ i ] == 1 ) : NEW_LINE INDENT bottom [ j ] [ i ] = bottom [ j + 1 ] [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT bottom [ j ] [ i ] = 0 NEW_LINE DEDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT right [ i ] [ j ] = right [ i ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] [ j ] = 0 NEW_LINE DEDENT j = N - 1 - j NEW_LINE DEDENT DEDENT n = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT l = min ( min ( top [ i ] [ j ] , bottom [ i ] [ j ] ) , min ( left [ i ] [ j ] , right [ i ] [ j ] ) ) NEW_LINE if ( l > n ) : NEW_LINE INDENT n = l NEW_LINE DEDENT DEDENT DEDENT if ( n ) : NEW_LINE INDENT return 4 * ( n - 1 ) + 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ] , [ 1 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 ] , [ 1 , 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 ] , [ 0 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 0 ] , [ 1 , 1 , 1 , 0 , 1 , 1 , 1 , 1 , 1 , 1 ] , [ 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 1 , 1 , 1 , 0 , 0 , 1 , 1 ] , [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 0 ] ] NEW_LINE print ( findLargestPlus ( mat ) ) NEW_LINE DEDENT
def findLeft ( str ) : NEW_LINE INDENT n = len ( str ) - 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( str [ n ] == ' d ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' c ' + str [ n + 1 : ] ; NEW_LINE break ; NEW_LINE DEDENT if ( str [ n ] == ' b ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' a ' + str [ n + 1 : ] ; NEW_LINE break ; NEW_LINE DEDENT if ( str [ n ] == ' a ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' b ' + str [ n + 1 : ] ; NEW_LINE DEDENT elif ( str [ n ] == ' c ' ) : NEW_LINE INDENT str = str [ 0 : n ] + ' d ' + str [ n + 1 : ] ; NEW_LINE DEDENT n -= 1 ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " aacbddc " ; NEW_LINE print ( " Left ▁ of " , str , " is " , findLeft ( str ) ) ; NEW_LINE DEDENT
def printSpiral ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT x = min ( min ( i , j ) , min ( n - 1 - i , n - 1 - j ) ) NEW_LINE if ( i <= j ) : NEW_LINE INDENT print ( ( n - 2 * x ) * ( n - 2 * x ) - ( i - x ) - ( j - x ) , end = " TABSYMBOL " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( ( n - 2 * x - 2 ) * ( n - 2 * x - 2 ) + ( i - x ) + ( j - x ) ) , end = " TABSYMBOL " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printSpiral ( n ) NEW_LINE
R = 3 NEW_LINE C = 4 NEW_LINE def modifyMatrix ( mat ) : NEW_LINE INDENT row = [ 0 ] * R NEW_LINE col = [ 0 ] * C NEW_LINE for i in range ( 0 , R ) : NEW_LINE INDENT row [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , C ) : NEW_LINE INDENT col [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , R ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT row [ i ] = 1 NEW_LINE col [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , R ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT if ( row [ i ] == 1 or col [ j ] == 1 ) : NEW_LINE INDENT mat [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def printMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , R ) : NEW_LINE INDENT for j in range ( 0 , C ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 0 , 0 , 1 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE print ( " Input ▁ Matrix ▁ n " ) NEW_LINE printMatrix ( mat ) NEW_LINE modifyMatrix ( mat ) NEW_LINE print ( " Matrix ▁ after ▁ modification ▁ n " ) NEW_LINE printMatrix ( mat ) NEW_LINE
def modifyMatrix ( mat ) : NEW_LINE INDENT row_flag = False NEW_LINE col_flag = False NEW_LINE for i in range ( 0 , len ( mat ) ) : NEW_LINE INDENT for j in range ( 0 , len ( mat ) ) : NEW_LINE INDENT if ( i == 0 and mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT row_flag = True NEW_LINE DEDENT if ( j == 0 and mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT col_flag = True NEW_LINE DEDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT mat [ 0 ] [ j ] = 1 NEW_LINE mat [ i ] [ 0 ] = 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , len ( mat ) ) : NEW_LINE INDENT for j in range ( 1 , len ( mat ) + 1 ) : NEW_LINE INDENT if ( mat [ 0 ] [ j ] == 1 or mat [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT mat [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT DEDENT if ( row_flag == True ) : NEW_LINE INDENT for i in range ( 0 , len ( mat ) ) : NEW_LINE INDENT mat [ 0 ] [ i ] = 1 NEW_LINE DEDENT DEDENT if ( col_flag == True ) : NEW_LINE INDENT for i in range ( 0 , len ( mat ) ) : NEW_LINE INDENT mat [ i ] [ 0 ] = 1 NEW_LINE DEDENT DEDENT DEDENT def printMatrix ( mat ) : NEW_LINE INDENT for i in range ( 0 , len ( mat ) ) : NEW_LINE INDENT for j in range ( 0 , len ( mat ) + 1 ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT mat = [ [ 1 , 0 , 0 , 1 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE print ( " Input ▁ Matrix ▁ : " ) NEW_LINE printMatrix ( mat ) NEW_LINE modifyMatrix ( mat ) NEW_LINE print ( " Matrix ▁ After ▁ Modification ▁ : " ) NEW_LINE printMatrix ( mat ) NEW_LINE
def find ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE i = 0 NEW_LINE j = n - 1 NEW_LINE res = - 1 NEW_LINE while i < n and j >= 0 : NEW_LINE INDENT if arr [ i ] [ j ] == 0 : NEW_LINE INDENT while j >= 0 and ( arr [ i ] [ j ] == 0 or i == j ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT if j == - 1 : NEW_LINE INDENT res = i NEW_LINE break NEW_LINE DEDENT else : i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT while i < n and ( arr [ i ] [ j ] == 1 or i == j ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT res = j NEW_LINE break NEW_LINE DEDENT else : j -= 1 NEW_LINE DEDENT DEDENT if res == - 1 : NEW_LINE INDENT return res NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if res != i and arr [ i ] [ res ] != 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for j in range ( 0 , j ) : NEW_LINE INDENT if res != j and arr [ res ] [ j ] != 0 : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT arr = [ [ 0 , 0 , 1 , 1 , 0 ] , [ 0 , 0 , 0 , 1 , 0 ] , [ 1 , 1 , 1 , 1 , 0 ] , [ 0 , 0 , 0 , 0 , 0 ] , [ 1 , 1 , 1 , 1 , 1 ] ] NEW_LINE print find ( arr ) NEW_LINE
M = 4 NEW_LINE N = 5 NEW_LINE def preProcess ( mat , aux ) : NEW_LINE INDENT for i in range ( 0 , N , 1 ) : NEW_LINE INDENT aux [ 0 ] [ i ] = mat [ 0 ] [ i ] NEW_LINE DEDENT for i in range ( 1 , M , 1 ) : NEW_LINE INDENT for j in range ( 0 , N , 1 ) : NEW_LINE INDENT aux [ i ] [ j ] = mat [ i ] [ j ] + aux [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , M , 1 ) : NEW_LINE INDENT for j in range ( 1 , N , 1 ) : NEW_LINE INDENT aux [ i ] [ j ] += aux [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT def sumQuery ( aux , tli , tlj , rbi , rbj ) : NEW_LINE INDENT res = aux [ rbi ] [ rbj ] NEW_LINE if ( tli > 0 ) : NEW_LINE INDENT res = res - aux [ tli - 1 ] [ rbj ] NEW_LINE DEDENT if ( tlj > 0 ) : NEW_LINE INDENT res = res - aux [ rbi ] [ tlj - 1 ] NEW_LINE DEDENT if ( tli > 0 and tlj > 0 ) : NEW_LINE INDENT res = res + aux [ tli - 1 ] [ tlj - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 , 4 , 6 ] , [ 5 , 3 , 8 , 1 , 2 ] , [ 4 , 6 , 7 , 5 , 5 ] , [ 2 , 4 , 8 , 9 , 4 ] ] NEW_LINE DEDENT aux = [ [ 0 for i in range ( N ) ] for j in range ( M ) ] NEW_LINE preProcess ( mat , aux ) NEW_LINE tli = 2 NEW_LINE tlj = 2 NEW_LINE rbi = 3 NEW_LINE rbj = 4 NEW_LINE print ( " Query1 : " , sumQuery ( aux , tli , tlj , rbi , rbj ) ) NEW_LINE tli = 0 NEW_LINE tlj = 0 NEW_LINE rbi = 1 NEW_LINE rbj = 1 NEW_LINE print ( " Query2 : " , sumQuery ( aux , tli , tlj , rbi , rbj ) ) NEW_LINE tli = 1 NEW_LINE tlj = 2 NEW_LINE rbi = 3 NEW_LINE rbj = 3 NEW_LINE print ( " Query3 : " , sumQuery ( aux , tli , tlj , rbi , rbj ) ) NEW_LINE
class rankMatrix ( object ) : NEW_LINE INDENT def __init__ ( self , Matrix ) : NEW_LINE INDENT self . R = len ( Matrix ) NEW_LINE self . C = len ( Matrix [ 0 ] ) NEW_LINE DEDENT def swap ( self , Matrix , row1 , row2 , col ) : NEW_LINE INDENT for i in range ( col ) : NEW_LINE INDENT temp = Matrix [ row1 ] [ i ] NEW_LINE Matrix [ row1 ] [ i ] = Matrix [ row2 ] [ i ] NEW_LINE Matrix [ row2 ] [ i ] = temp NEW_LINE DEDENT DEDENT def rankOfMatrix ( self , Matrix ) : NEW_LINE INDENT rank = self . C NEW_LINE for row in range ( 0 , rank , 1 ) : NEW_LINE INDENT if Matrix [ row ] [ row ] != 0 : NEW_LINE INDENT for col in range ( 0 , self . R , 1 ) : NEW_LINE INDENT if col != row : NEW_LINE INDENT multiplier = ( Matrix [ col ] [ row ] / Matrix [ row ] [ row ] ) NEW_LINE for i in range ( rank ) : NEW_LINE INDENT Matrix [ col ] [ i ] -= ( multiplier * Matrix [ row ] [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT reduce = True NEW_LINE for i in range ( row + 1 , self . R , 1 ) : NEW_LINE INDENT if Matrix [ i ] [ row ] != 0 : NEW_LINE INDENT self . swap ( Matrix , row , i , rank ) NEW_LINE reduce = False NEW_LINE break NEW_LINE DEDENT DEDENT if reduce : NEW_LINE INDENT rank -= 1 NEW_LINE for i in range ( 0 , self . R , 1 ) : NEW_LINE INDENT Matrix [ i ] [ row ] = Matrix [ i ] [ rank ] NEW_LINE DEDENT DEDENT row -= 1 NEW_LINE DEDENT DEDENT return ( rank ) NEW_LINE DEDENT def Display ( self , Matrix , row , col ) : NEW_LINE INDENT for i in range ( row ) : NEW_LINE INDENT for j in range ( col ) : NEW_LINE INDENT print ( " ▁ " + str ( Matrix [ i ] [ j ] ) ) NEW_LINE DEDENT print ( ' ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Matrix = [ [ 10 , 20 , 10 ] , [ - 20 , - 30 , 10 ] , [ 30 , 50 , 0 ] ] NEW_LINE RankMatrix = rankMatrix ( Matrix ) NEW_LINE print ( " Rank ▁ of ▁ the ▁ Matrix ▁ is : " , ( RankMatrix . rankOfMatrix ( Matrix ) ) ) NEW_LINE DEDENT
def countIslands ( mat ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' X ' ) : NEW_LINE INDENT if ( ( i == 0 or mat [ i - 1 ] [ j ] == ' O ' ) and ( j == 0 or mat [ i ] [ j - 1 ] == ' O ' ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT M = 6 NEW_LINE N = 3 NEW_LINE mat = [ [ ' O ' , ' O ' , ' O ' ] , [ ' X ' , ' X ' , ' O ' ] , [ ' X ' , ' X ' , ' O ' ] , [ ' O ' , ' O ' , ' X ' ] , [ ' O ' , ' O ' , ' X ' ] , [ ' X ' , ' X ' , ' O ' ] ] NEW_LINE print ( " Number ▁ of ▁ rectangular ▁ islands ▁ is " , countIslands ( mat ) ) NEW_LINE
M = 6 NEW_LINE N = 6 NEW_LINE def floodFillUtil ( mat , x , y , prevV , newV ) : NEW_LINE INDENT if ( x < 0 or x >= M or y < 0 or y >= N ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( mat [ x ] [ y ] != prevV ) : NEW_LINE INDENT return NEW_LINE DEDENT mat [ x ] [ y ] = newV NEW_LINE floodFillUtil ( mat , x + 1 , y , prevV , newV ) NEW_LINE floodFillUtil ( mat , x - 1 , y , prevV , newV ) NEW_LINE floodFillUtil ( mat , x , y + 1 , prevV , newV ) NEW_LINE floodFillUtil ( mat , x , y - 1 , prevV , newV ) NEW_LINE DEDENT def replaceSurrounded ( mat ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' O ' ) : NEW_LINE INDENT mat [ i ] [ j ] = ' - ' NEW_LINE DEDENT DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ 0 ] == ' - ' ) : NEW_LINE INDENT floodFillUtil ( mat , i , 0 , ' - ' , ' O ' ) NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ N - 1 ] == ' - ' ) : NEW_LINE INDENT floodFillUtil ( mat , i , N - 1 , ' - ' , ' O ' ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( mat [ 0 ] [ i ] == ' - ' ) : NEW_LINE INDENT floodFillUtil ( mat , 0 , i , ' - ' , ' O ' ) NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( mat [ M - 1 ] [ i ] == ' - ' ) : NEW_LINE INDENT floodFillUtil ( mat , M - 1 , i , ' - ' , ' O ' ) NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == ' - ' ) : NEW_LINE INDENT mat [ i ] [ j ] = ' X ' NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ ' X ' , ' O ' , ' X ' , ' O ' , ' X ' , ' X ' ] , [ ' X ' , ' O ' , ' X ' , ' X ' , ' O ' , ' X ' ] , [ ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' X ' ] , [ ' O ' , ' X ' , ' X ' , ' X ' , ' X ' , ' X ' ] , [ ' X ' , ' X ' , ' X ' , ' O ' , ' X ' , ' O ' ] , [ ' O ' , ' O ' , ' X ' , ' O ' , ' O ' , ' O ' ] ] ; NEW_LINE replaceSurrounded ( mat ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT print ( * mat [ i ] ) NEW_LINE DEDENT DEDENT
R = 3 NEW_LINE C = 3 NEW_LINE x = [ 0 , 1 , 1 , - 1 , 1 , 0 , - 1 , - 1 ] NEW_LINE y = [ 1 , 0 , 1 , 1 , - 1 , - 1 , 0 , - 1 ] NEW_LINE dp = [ [ 0 for i in range ( C ) ] for i in range ( R ) ] NEW_LINE def isvalid ( i , j ) : NEW_LINE INDENT if ( i < 0 or j < 0 or i >= R or j >= C ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def isadjacent ( prev , curr ) : NEW_LINE INDENT if ( ord ( curr ) - ord ( prev ) ) == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def getLenUtil ( mat , i , j , prev ) : NEW_LINE INDENT if ( isvalid ( i , j ) == False or isadjacent ( prev , mat [ i ] [ j ] ) == False ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT ans = 0 NEW_LINE for k in range ( 8 ) : NEW_LINE INDENT ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , mat [ i ] [ j ] ) ) NEW_LINE DEDENT dp [ i ] [ j ] = ans NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT def getLen ( mat , s ) : NEW_LINE INDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == s ) : NEW_LINE INDENT for k in range ( 8 ) : NEW_LINE INDENT ans = max ( ans , 1 + getLenUtil ( mat , i + x [ k ] , j + y [ k ] , s ) ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT mat = [ [ ' a ' , ' c ' , ' d ' ] , [ ' h ' , ' b ' , ' a ' ] , [ ' i ' , ' g ' , ' f ' ] ] NEW_LINE print ( getLen ( mat , ' a ' ) ) NEW_LINE print ( getLen ( mat , ' e ' ) ) NEW_LINE print ( getLen ( mat , ' b ' ) ) NEW_LINE print ( getLen ( mat , ' f ' ) ) NEW_LINE
import math as mt NEW_LINE R = 3 NEW_LINE C = 3 NEW_LINE def minInitialPoints ( points ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( C + 1 ) ] for y in range ( R + 1 ) ] NEW_LINE m , n = R , C NEW_LINE if points [ m - 1 ] [ n - 1 ] > 0 : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ m - 1 ] [ n - 1 ] = abs ( points [ m - 1 ] [ n - 1 ] ) + 1 NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ n - 1 ] = max ( dp [ i + 1 ] [ n - 1 ] - points [ i ] [ n - 1 ] , 1 ) NEW_LINE DEDENT for i in range ( 2 , - 1 , - 1 ) : NEW_LINE INDENT dp [ m - 1 ] [ i ] = max ( dp [ m - 1 ] [ i + 1 ] - points [ m - 1 ] [ i ] , 1 ) NEW_LINE DEDENT for i in range ( m - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT min_points_on_exit = min ( dp [ i + 1 ] [ j ] , dp [ i ] [ j + 1 ] ) NEW_LINE dp [ i ] [ j ] = max ( min_points_on_exit - points [ i ] [ j ] , 1 ) NEW_LINE DEDENT DEDENT return dp [ 0 ] [ 0 ] NEW_LINE DEDENT points = [ [ - 2 , - 3 , 3 ] , [ - 5 , - 10 , 1 ] , [ 10 , 30 , - 5 ] ] NEW_LINE print ( " Minimum ▁ Initial ▁ Points ▁ Required : " , minInitialPoints ( points ) ) NEW_LINE
def findPeakUtil ( arr , low , high , n ) : NEW_LINE INDENT mid = low + ( high - low ) / 2 NEW_LINE mid = int ( mid ) NEW_LINE if ( ( mid == 0 or arr [ mid - 1 ] <= arr [ mid ] ) and ( mid == n - 1 or arr [ mid + 1 ] <= arr [ mid ] ) ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( mid > 0 and arr [ mid - 1 ] > arr [ mid ] ) : NEW_LINE INDENT return findPeakUtil ( arr , low , ( mid - 1 ) , n ) NEW_LINE DEDENT else : NEW_LINE INDENT return findPeakUtil ( arr , ( mid + 1 ) , high , n ) NEW_LINE DEDENT DEDENT def findPeak ( arr , n ) : NEW_LINE INDENT return findPeakUtil ( arr , 0 , n - 1 , n ) NEW_LINE DEDENT arr = [ 1 , 3 , 20 , 4 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Index ▁ of ▁ a ▁ peak ▁ point ▁ is " , findPeak ( arr , n ) ) NEW_LINE
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " Repeating ▁ elements ▁ are ▁ " , end = ' ' ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT for j in range ( i + 1 , size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE
def printRepeating ( arr , size ) : NEW_LINE INDENT count = [ 0 ] * size NEW_LINE print ( " ▁ Repeating ▁ elements ▁ are ▁ " , end = " " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( count [ arr [ i ] ] == 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT count [ arr [ i ] ] = count [ arr [ i ] ] + 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE
import math NEW_LINE def printRepeating ( arr , size ) : NEW_LINE INDENT S = 0 ; NEW_LINE P = 1 ; NEW_LINE n = size - 2 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT S = S + arr [ i ] NEW_LINE P = P * arr [ i ] NEW_LINE DEDENT S = S - n * ( n + 1 ) // 2 NEW_LINE P = P // fact ( n ) NEW_LINE D = math . sqrt ( S * S - 4 * P ) NEW_LINE x = ( D + S ) // 2 NEW_LINE y = ( S - D ) // 2 NEW_LINE print ( " The ▁ two ▁ Repeating ▁ elements ▁ are ▁ " , ( int ) ( x ) , " ▁ & ▁ " , ( int ) ( y ) ) NEW_LINE DEDENT def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * fact ( n - 1 ) ) NEW_LINE DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE
def printRepeating ( arr , size ) : NEW_LINE INDENT xor = arr [ 0 ] NEW_LINE n = size - 2 NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor ^= arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT xor ^= i NEW_LINE DEDENT set_bit_no = xor & ~ ( xor - 1 ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i & set_bit_no ) : NEW_LINE INDENT x = x ^ i NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ i NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ repeating " , " elements ▁ are " , y , x ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE
def printRepeating ( arr , size ) : NEW_LINE INDENT print ( " ▁ The ▁ repeating ▁ elements ▁ are " , end = " ▁ " ) NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ abs ( arr [ i ] ) ] > 0 ) : NEW_LINE INDENT arr [ abs ( arr [ i ] ) ] = ( - 1 ) * arr [ abs ( arr [ i ] ) ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( abs ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE
def subArraySum ( arr , n , sum_ ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT curr_sum = arr [ i ] NEW_LINE j = i + 1 NEW_LINE while j <= n : NEW_LINE INDENT if curr_sum == sum_ : NEW_LINE INDENT print ( " Sum ▁ found ▁ between " ) NEW_LINE print ( " indexes ▁ % ▁ d ▁ and ▁ % ▁ d " % ( i , j - 1 ) ) NEW_LINE return 1 NEW_LINE DEDENT if curr_sum > sum_ or j == n : NEW_LINE INDENT break NEW_LINE DEDENT curr_sum = curr_sum + arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT arr = [ 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 ] NEW_LINE n = len ( arr ) NEW_LINE sum_ = 23 NEW_LINE subArraySum ( arr , n , sum_ ) NEW_LINE
def subArraySum ( arr , n , sum_ ) : NEW_LINE INDENT curr_sum = arr [ 0 ] NEW_LINE start = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT while curr_sum > sum_ and start < i - 1 : NEW_LINE INDENT curr_sum = curr_sum - arr [ start ] NEW_LINE start += 1 NEW_LINE DEDENT if curr_sum == sum_ : NEW_LINE INDENT print ( " Sum ▁ found ▁ between ▁ indexes " ) NEW_LINE print ( " % ▁ d ▁ and ▁ % ▁ d " % ( start , i - 1 ) ) NEW_LINE return 1 NEW_LINE DEDENT if i < n : NEW_LINE INDENT curr_sum = curr_sum + arr [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT print ( " No ▁ subarray ▁ found " ) NEW_LINE return 0 NEW_LINE DEDENT arr = [ 15 , 2 , 4 , 8 , 9 , 5 , 10 , 23 ] NEW_LINE n = len ( arr ) NEW_LINE sum_ = 23 NEW_LINE subArraySum ( arr , n , sum_ ) NEW_LINE
def maximum ( a , b , c ) : NEW_LINE INDENT return max ( max ( a , b ) , c ) NEW_LINE DEDENT def minimum ( a , b , c ) : NEW_LINE INDENT return min ( min ( a , b ) , c ) NEW_LINE DEDENT def smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) : NEW_LINE INDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE arr3 . sort ( ) NEW_LINE res_min = 0 ; res_max = 0 ; res_mid = 0 NEW_LINE i = 0 ; j = 0 ; k = 0 NEW_LINE diff = 2147483647 NEW_LINE while ( i < n and j < n and k < n ) : NEW_LINE INDENT sum = arr1 [ i ] + arr2 [ j ] + arr3 [ k ] NEW_LINE max = maximum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) NEW_LINE min = minimum ( arr1 [ i ] , arr2 [ j ] , arr3 [ k ] ) NEW_LINE if ( min == arr1 [ i ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT elif ( min == arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT k += 1 NEW_LINE DEDENT if ( diff > ( max - min ) ) : NEW_LINE INDENT diff = max - min NEW_LINE res_max = max NEW_LINE res_mid = sum - ( max + min ) NEW_LINE res_min = min NEW_LINE DEDENT DEDENT print ( res_max , " , " , res_mid , " , " , res_min ) NEW_LINE DEDENT arr1 = [ 5 , 2 , 8 ] NEW_LINE arr2 = [ 10 , 7 , 12 ] NEW_LINE arr3 = [ 9 , 14 , 6 ] NEW_LINE n = len ( arr1 ) NEW_LINE smallestDifferenceTriplet ( arr1 , arr2 , arr3 , n ) NEW_LINE
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , arr_size ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] == sum : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , " , ▁ " , A [ j ] , " , ▁ " , A [ k ] ) NEW_LINE return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT A = [ 1 , 4 , 45 , 6 , 10 , 8 ] NEW_LINE sum = 22 NEW_LINE arr_size = len ( A ) NEW_LINE find3Numbers ( A , arr_size , sum ) NEW_LINE
def find3Numbers ( A , arr_size , sum ) : NEW_LINE INDENT A . sort ( ) NEW_LINE for i in range ( 0 , arr_size - 2 ) : NEW_LINE INDENT l = i + 1 NEW_LINE r = arr_size - 1 NEW_LINE while ( l < r ) : NEW_LINE INDENT if ( A [ i ] + A [ l ] + A [ r ] == sum ) : NEW_LINE INDENT print ( " Triplet ▁ is " , A [ i ] , ' , ▁ ' , A [ l ] , ' , ▁ ' , A [ r ] ) ; NEW_LINE return True NEW_LINE DEDENT elif ( A [ i ] + A [ l ] + A [ r ] < sum ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT A = [ 1 , 4 , 45 , 6 , 10 , 8 ] NEW_LINE sum = 22 NEW_LINE arr_size = len ( A ) NEW_LINE find3Numbers ( A , arr_size , sum ) NEW_LINE
def subArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " All ▁ Non - empty ▁ Subarrays " ) NEW_LINE subArray ( arr , n ) ; NEW_LINE
import math NEW_LINE def printSubsequences ( arr , n ) : NEW_LINE INDENT opsize = math . pow ( 2 , n ) NEW_LINE for counter in range ( 1 , ( int ) ( opsize ) ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( counter & ( 1 << j ) ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " All ▁ Non - empty ▁ Subsequences " ) NEW_LINE printSubsequences ( arr , n ) NEW_LINE
def productArray ( arr , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( 0 ) NEW_LINE return NEW_LINE DEDENT i , temp = 1 , 1 NEW_LINE prod = [ 1 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prod [ i ] = temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT temp = 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT prod [ i ] *= temp NEW_LINE temp *= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( prod [ i ] , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ product ▁ array ▁ is : ▁ n " ) NEW_LINE productArray ( arr , n ) NEW_LINE
def areConsecutive ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT Min = min ( arr ) NEW_LINE Max = max ( arr ) NEW_LINE if ( Max - Min + 1 == n ) : NEW_LINE INDENT visited = [ False for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( visited [ arr [ i ] - Min ] != False ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited [ arr [ i ] - Min ] = True NEW_LINE DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 5 , 4 , 2 , 3 , 1 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areConsecutive ( arr , n ) == True ) : NEW_LINE INDENT print ( " Array ▁ elements ▁ are ▁ consecutive ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Array ▁ elements ▁ are ▁ not ▁ consecutive ▁ " ) NEW_LINE DEDENT
def areConsecutive ( arr , n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE if ( max - min + 1 == n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < 0 ) : NEW_LINE INDENT j = - arr [ i ] - min NEW_LINE DEDENT else : NEW_LINE INDENT j = arr [ i ] - min NEW_LINE DEDENT if ( arr [ j ] > 0 ) : NEW_LINE INDENT arr [ j ] = - arr [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def getMin ( arr , n ) : NEW_LINE INDENT min = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT return min NEW_LINE DEDENT def getMax ( arr , n ) : NEW_LINE INDENT max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 5 , 3 , 2 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if ( areConsecutive ( arr , n ) == True ) : NEW_LINE INDENT print ( " ▁ Array ▁ elements ▁ are ▁ consecutive ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ Array ▁ elements ▁ are ▁ not ▁ consecutive ▁ " ) NEW_LINE DEDENT DEDENT
def relativeComplement ( arr1 , arr2 , n , m ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , " ▁ " , end = " " ) NEW_LINE i += 1 NEW_LINE DEDENT elif ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif ( arr1 [ i ] == arr2 [ j ] ) : NEW_LINE INDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while ( i < n ) : NEW_LINE INDENT print ( arr1 [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT arr1 = [ 3 , 6 , 10 , 12 , 15 ] NEW_LINE arr2 = [ 1 , 3 , 5 , 10 , 16 ] NEW_LINE n = len ( arr1 ) NEW_LINE m = len ( arr2 ) NEW_LINE relativeComplement ( arr1 , arr2 , n , m ) NEW_LINE
def minOps ( arr , n , k ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max1 - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max1 - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return int ( res ) NEW_LINE DEDENT arr = [ 21 , 33 , 9 , 45 , 63 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( minOps ( arr , n , k ) ) NEW_LINE
def solve ( A , B , C ) : NEW_LINE INDENT i = len ( A ) - 1 NEW_LINE j = len ( B ) - 1 NEW_LINE k = len ( C ) - 1 NEW_LINE min_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE while i != - 1 and j != - 1 and k != - 1 : NEW_LINE INDENT current_diff = abs ( max ( A [ i ] , B [ j ] , C [ k ] ) - min ( A [ i ] , B [ j ] , C [ k ] ) ) NEW_LINE if current_diff < min_diff : NEW_LINE INDENT min_diff = current_diff NEW_LINE DEDENT max_term = max ( A [ i ] , B [ j ] , C [ k ] ) NEW_LINE if A [ i ] == max_term : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT elif B [ j ] == max_term : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT DEDENT return min_diff NEW_LINE DEDENT A = [ 5 , 8 , 10 , 15 ] NEW_LINE B = [ 6 , 9 , 15 , 78 , 89 ] NEW_LINE C = [ 2 , 3 , 6 , 6 , 8 , 8 , 10 ] NEW_LINE print ( solve ( A , B , C ) ) NEW_LINE
def search ( arr , x ) : NEW_LINE INDENT for index , value in enumerate ( arr ) : NEW_LINE INDENT if value == x : NEW_LINE INDENT return index NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 10 , 30 , 15 ] NEW_LINE x = 30 NEW_LINE print ( x , " is ▁ present ▁ at ▁ index " , search ( arr , x ) ) NEW_LINE
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) // 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , 0 , len ( arr ) - 1 , x ) NEW_LINE if result != - 1 : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d " % result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = l + ( r - l ) // 2 ; NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] < x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE x = 10 NEW_LINE result = binarySearch ( arr , 0 , len ( arr ) - 1 , x ) NEW_LINE if result != - 1 : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index ▁ % ▁ d " % result ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT
import math NEW_LINE def jumpSearch ( arr , x , n ) : NEW_LINE INDENT step = math . sqrt ( n ) NEW_LINE prev = 0 NEW_LINE while arr [ int ( min ( step , n ) - 1 ) ] < x : NEW_LINE INDENT prev = step NEW_LINE step += math . sqrt ( n ) NEW_LINE if prev >= n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT while arr [ int ( prev ) ] < x : NEW_LINE INDENT prev += 1 NEW_LINE if prev == min ( step , n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if arr [ int ( prev ) ] == x : NEW_LINE INDENT return prev NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 2 , 3 , 5 , 8 , 13 , 21 , 34 , 55 , 89 , 144 , 233 , 377 , 610 ] NEW_LINE x = 55 NEW_LINE n = len ( arr ) NEW_LINE index = jumpSearch ( arr , x , n ) NEW_LINE print ( " Number " , x , " is ▁ at ▁ index " , " % .0f " % index ) NEW_LINE
def exponentialSearch ( arr , n , x ) : NEW_LINE INDENT if arr [ 0 ] == x : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 1 NEW_LINE while i < n and arr [ i ] <= x : NEW_LINE INDENT i = i * 2 NEW_LINE DEDENT return binarySearch ( arr , i / 2 , min ( i , n - 1 ) , x ) NEW_LINE DEDENT def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if r >= l : NEW_LINE INDENT mid = l + ( r - l ) / 2 NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 10 NEW_LINE result = exponentialSearch ( arr , n , x ) NEW_LINE if result == - 1 : NEW_LINE INDENT print " Element ▁ not ▁ found ▁ in ▁ thye ▁ array " NEW_LINE DEDENT else : NEW_LINE INDENT print " Element ▁ is ▁ present ▁ at ▁ index ▁ % d " % ( result ) NEW_LINE DEDENT
def countingSort ( arr , exp1 ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE output = [ 0 ] * ( n ) NEW_LINE count = [ 0 ] * ( 10 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT index = ( arr [ i ] / exp1 ) NEW_LINE count [ int ( index % 10 ) ] += 1 NEW_LINE DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] NEW_LINE DEDENT i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT index = ( arr [ i ] / exp1 ) NEW_LINE output [ count [ int ( index % 10 ) ] - 1 ] = arr [ i ] NEW_LINE count [ int ( index % 10 ) ] -= 1 NEW_LINE i -= 1 NEW_LINE DEDENT i = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT arr [ i ] = output [ i ] NEW_LINE DEDENT DEDENT def radixSort ( arr ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE exp = 1 NEW_LINE while max1 / exp > 0 : NEW_LINE INDENT countingSort ( arr , exp ) NEW_LINE exp *= 10 NEW_LINE DEDENT DEDENT arr = [ 170 , 45 , 75 , 90 , 802 , 24 , 2 , 66 ] NEW_LINE radixSort ( arr ) NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE DEDENT
def partition ( arr , low , high ) : NEW_LINE INDENT i = ( low - 1 ) NEW_LINE pivot = arr [ high ] NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if arr [ j ] <= pivot : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if low < high : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 6 , 9 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def partition ( arr , l , h ) : NEW_LINE INDENT i = ( l - 1 ) NEW_LINE x = arr [ h ] NEW_LINE for j in range ( l , h ) : NEW_LINE INDENT if arr [ j ] <= x : NEW_LINE INDENT i = i + 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ h ] = arr [ h ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSortIterative ( arr , l , h ) : NEW_LINE INDENT size = h - l + 1 NEW_LINE stack = [ 0 ] * ( size ) NEW_LINE top = - 1 NEW_LINE top = top + 1 NEW_LINE stack [ top ] = l NEW_LINE top = top + 1 NEW_LINE stack [ top ] = h NEW_LINE while top >= 0 : NEW_LINE INDENT h = stack [ top ] NEW_LINE top = top - 1 NEW_LINE l = stack [ top ] NEW_LINE top = top - 1 NEW_LINE p = partition ( arr , l , h ) NEW_LINE if p - 1 > l : NEW_LINE INDENT top = top + 1 NEW_LINE stack [ top ] = l NEW_LINE top = top + 1 NEW_LINE stack [ top ] = p - 1 NEW_LINE DEDENT if p + 1 < h : NEW_LINE INDENT top = top + 1 NEW_LINE stack [ top ] = p + 1 NEW_LINE top = top + 1 NEW_LINE stack [ top ] = h NEW_LINE DEDENT DEDENT DEDENT arr = [ 4 , 3 , 5 , 2 , 1 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE quickSortIterative ( arr , 0 , n - 1 ) NEW_LINE print ( " Sorted ▁ array ▁ is : " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " % ▁ d " % arr [ i ] ) , NEW_LINE DEDENT
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r >= l ) : NEW_LINE INDENT mid = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ mid ] == x ) : return mid NEW_LINE if ( mid > l and arr [ mid - 1 ] == x ) : NEW_LINE INDENT return ( mid - 1 ) NEW_LINE DEDENT if ( mid < r and arr [ mid + 1 ] == x ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT if ( arr [ mid ] > x ) : NEW_LINE INDENT return binarySearch ( arr , l , mid - 2 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 2 , r , x ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 3 , 2 , 10 , 4 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 4 NEW_LINE result = binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if ( result == - 1 ) : NEW_LINE INDENT print ( " Element ▁ is ▁ not ▁ present ▁ in ▁ array " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Element ▁ is ▁ present ▁ at ▁ index " , result ) NEW_LINE DEDENT
import sys NEW_LINE def printClosest ( ar1 , ar2 , m , n , x ) : NEW_LINE INDENT diff = sys . maxsize NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE while ( l < m and r >= 0 ) : NEW_LINE INDENT if abs ( ar1 [ l ] + ar2 [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( ar1 [ l ] + ar2 [ r ] - x ) NEW_LINE DEDENT if ar1 [ l ] + ar2 [ r ] > x : NEW_LINE INDENT r = r - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = l + 1 NEW_LINE DEDENT DEDENT print ( " The ▁ closest ▁ pair ▁ is ▁ [ " , ar1 [ res_l ] , " , " , ar2 [ res_r ] , " ] " ) NEW_LINE DEDENT ar1 = [ 1 , 4 , 5 , 7 ] NEW_LINE ar2 = [ 10 , 20 , 30 , 40 ] NEW_LINE m = len ( ar1 ) NEW_LINE n = len ( ar2 ) NEW_LINE x = 38 NEW_LINE printClosest ( ar1 , ar2 , m , n , x ) NEW_LINE
MAX_VAL = 1000000000 NEW_LINE def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 22 , 28 , 29 , 30 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 54 NEW_LINE printClosest ( arr , n , x ) NEW_LINE DEDENT
def countOnes ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if arr [ mid ] == 1 : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , mid - 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 0 , 0 , 0 ] NEW_LINE print ( " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is " , countOnes ( arr , 0 , len ( arr ) - 1 ) ) NEW_LINE
def minSwaps ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE maxx , minn , l , r = - 1 , arr [ 0 ] , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > maxx : NEW_LINE INDENT maxx = arr [ i ] NEW_LINE l = i NEW_LINE DEDENT if arr [ i ] <= minn : NEW_LINE INDENT minn = arr [ i ] NEW_LINE r = i NEW_LINE DEDENT DEDENT if r < l : NEW_LINE INDENT print ( l + ( n - r - 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l + ( n - r - 1 ) ) NEW_LINE DEDENT DEDENT arr = [ 5 , 6 , 1 , 3 ] NEW_LINE minSwaps ( arr ) NEW_LINE
def printMaxActivities ( s , f ) : NEW_LINE INDENT n = len ( f ) NEW_LINE print " The ▁ following ▁ activities ▁ are ▁ selected " NEW_LINE i = 0 NEW_LINE print i , NEW_LINE for j in xrange ( n ) : NEW_LINE INDENT if s [ j ] >= f [ i ] : NEW_LINE INDENT print j , NEW_LINE i = j NEW_LINE DEDENT DEDENT DEDENT s = [ 1 , 3 , 0 , 5 , 8 , 5 ] NEW_LINE f = [ 2 , 4 , 6 , 7 , 9 , 9 ] NEW_LINE printMaxActivities ( s , f ) NEW_LINE
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if m == 0 or n == 0 : NEW_LINE return 0 ; NEW_LINE elif X [ m - 1 ] == Y [ n - 1 ] : NEW_LINE return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; NEW_LINE else : NEW_LINE return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; NEW_LINE DEDENT X = " AGGTAB " NEW_LINE Y = " GXTXAYB " NEW_LINE print " Length ▁ of ▁ LCS ▁ is ▁ " , lcs ( X , Y , len ( X ) , len ( Y ) ) NEW_LINE
def lcs ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ None ] * ( n + 1 ) for i in xrange ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT X = " AGGTAB " NEW_LINE Y = " GXTXAYB " NEW_LINE print " Length ▁ of ▁ LCS ▁ is ▁ " , lcs ( X , Y ) NEW_LINE
R = 3 NEW_LINE C = 3 NEW_LINE import sys NEW_LINE def min ( x , y , z ) : NEW_LINE INDENT if ( x < y ) : NEW_LINE INDENT return x if ( x < z ) else z NEW_LINE DEDENT else : NEW_LINE INDENT return y if ( y < z ) else z NEW_LINE DEDENT DEDENT def minCost ( cost , m , n ) : NEW_LINE INDENT if ( n < 0 or m < 0 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT elif ( m == 0 and n == 0 ) : NEW_LINE INDENT return cost [ m ] [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return cost [ m ] [ n ] + min ( minCost ( cost , m - 1 , n - 1 ) , minCost ( cost , m - 1 , n ) , minCost ( cost , m , n - 1 ) ) NEW_LINE DEDENT DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE
R = 3 NEW_LINE C = 3 NEW_LINE def minCost ( cost , m , n ) : NEW_LINE INDENT tc = [ [ 0 for x in range ( C ) ] for x in range ( R ) ] NEW_LINE tc [ 0 ] [ 0 ] = cost [ 0 ] [ 0 ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT tc [ i ] [ 0 ] = tc [ i - 1 ] [ 0 ] + cost [ i ] [ 0 ] NEW_LINE DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ 0 ] [ j ] = tc [ 0 ] [ j - 1 ] + cost [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT tc [ i ] [ j ] = min ( tc [ i - 1 ] [ j - 1 ] , tc [ i - 1 ] [ j ] , tc [ i ] [ j - 1 ] ) + cost [ i ] [ j ] NEW_LINE DEDENT DEDENT return tc [ m ] [ n ] NEW_LINE DEDENT cost = [ [ 1 , 2 , 3 ] , [ 4 , 8 , 2 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( minCost ( cost , 2 , 2 ) ) NEW_LINE
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT if n == 0 or W == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt [ n - 1 ] > W ) : NEW_LINE INDENT return knapSack ( W , wt , val , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( val [ n - 1 ] + knapSack ( W - wt [ n - 1 ] , wt , val , n - 1 ) , knapSack ( W , wt , val , n - 1 ) ) NEW_LINE DEDENT DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE print knapSack ( W , wt , val , n ) NEW_LINE
def knapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for x in range ( W + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT return K [ n ] [ W ] NEW_LINE DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE print ( knapSack ( W , wt , val , n ) ) NEW_LINE
INT_MAX = 32767 NEW_LINE def eggDrop ( n , k ) : NEW_LINE INDENT eggFloor = [ [ 0 for x in range ( k + 1 ) ] for x in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ 1 ] = 1 NEW_LINE eggFloor [ i ] [ 0 ] = 0 NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT eggFloor [ 1 ] [ j ] = j NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 2 , k + 1 ) : NEW_LINE INDENT eggFloor [ i ] [ j ] = INT_MAX NEW_LINE for x in range ( 1 , j + 1 ) : NEW_LINE INDENT res = 1 + max ( eggFloor [ i - 1 ] [ x - 1 ] , eggFloor [ i ] [ j - x ] ) NEW_LINE if res < eggFloor [ i ] [ j ] : NEW_LINE INDENT eggFloor [ i ] [ j ] = res NEW_LINE DEDENT DEDENT DEDENT DEDENT return eggFloor [ n ] [ k ] NEW_LINE DEDENT n = 2 NEW_LINE k = 36 NEW_LINE print ( " Minimum ▁ number ▁ of ▁ trials ▁ in ▁ worst ▁ case ▁ with " + str ( n ) + " eggs ▁ and ▁ " + str ( k ) + " ▁ floors ▁ is ▁ " + str ( eggDrop ( n , k ) ) ) NEW_LINE
def max ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return x NEW_LINE DEDENT return y NEW_LINE DEDENT def lps ( seq , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] and i + 1 == j ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( seq [ i ] == seq [ j ] ) : NEW_LINE INDENT return lps ( seq , i + 1 , j - 1 ) + 2 NEW_LINE DEDENT return max ( lps ( seq , i , j - 1 ) , lps ( seq , i + 1 , j ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT seq = " GEEKSFORGEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is " , lps ( seq , 0 , n - 1 ) ) NEW_LINE DEDENT
def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if str [ i ] == str [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif str [ i ] == str [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT seq = " GEEKS ▁ FOR ▁ GEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " + str ( lps ( seq ) ) ) NEW_LINE
def lbs ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE lis = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( 0 , i ) : NEW_LINE INDENT if ( ( arr [ i ] > arr [ j ] ) and ( lis [ i ] < lis [ j ] + 1 ) ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT lds = [ 1 for i in range ( n + 1 ) ] NEW_LINE for i in reversed ( range ( n - 1 ) ) : NEW_LINE INDENT for j in reversed ( range ( i - 1 , n ) ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT maximum = lis [ 0 ] + lds [ 0 ] - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maximum = max ( ( lis [ i ] + lds [ i ] - 1 ) , maximum ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT arr = [ 0 , 8 , 4 , 12 , 2 , 10 , 6 , 14 , 1 , 9 , 5 , 13 , 3 , 11 , 7 , 15 ] NEW_LINE print " Length ▁ of ▁ LBS ▁ is " , lbs ( arr ) NEW_LINE
def maxDivide ( a , b ) : NEW_LINE INDENT while a % b == 0 : NEW_LINE INDENT a = a / b NEW_LINE DEDENT return a NEW_LINE DEDENT def isUgly ( no ) : NEW_LINE INDENT no = maxDivide ( no , 2 ) NEW_LINE no = maxDivide ( no , 3 ) NEW_LINE no = maxDivide ( no , 5 ) NEW_LINE return 1 if no == 1 else 0 NEW_LINE DEDENT def getNthUglyNo ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 1 NEW_LINE while n > count : NEW_LINE INDENT i += 1 NEW_LINE if isUgly ( i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT no = getNthUglyNo ( 150 ) NEW_LINE print ( "150th ▁ ugly ▁ no . ▁ is ▁ " , no ) NEW_LINE
def countRec ( n , sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return ( sum == 0 ) NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def finalCount ( n , sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( sum - i >= 0 ) : NEW_LINE INDENT ans = ans + countRec ( n - 1 , sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n = 2 NEW_LINE sum = 5 NEW_LINE print ( finalCount ( n , sum ) ) NEW_LINE
lookup = [ [ - 1 for i in range ( 501 ) ] for i in range ( 101 ) ] NEW_LINE def countRec ( n , Sum ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return Sum == 0 NEW_LINE DEDENT if ( lookup [ n ] [ Sum ] != - 1 ) : NEW_LINE INDENT return lookup [ n ] [ Sum ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( Sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , Sum - i ) NEW_LINE DEDENT DEDENT lookup [ n ] [ Sum ] = ans NEW_LINE return lookup [ n ] [ Sum ] NEW_LINE DEDENT def finalCount ( n , Sum ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( Sum - i >= 0 ) : NEW_LINE INDENT ans += countRec ( n - 1 , Sum - i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n , Sum = 3 , 5 NEW_LINE print ( finalCount ( n , Sum ) ) NEW_LINE
import math NEW_LINE def findCount ( n , sum ) : NEW_LINE INDENT start = math . pow ( 10 , n - 1 ) ; NEW_LINE end = math . pow ( 10 , n ) - 1 ; NEW_LINE count = 0 ; NEW_LINE i = start ; NEW_LINE while ( i <= end ) : NEW_LINE INDENT cur = 0 ; NEW_LINE temp = i ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT cur += temp % 10 ; NEW_LINE temp = temp // 10 ; NEW_LINE DEDENT if ( cur == sum ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE i += 9 ; NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 ; NEW_LINE DEDENT DEDENT print ( count ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE sum = 5 ; NEW_LINE findCount ( n , sum ) ; NEW_LINE
def countNonDecreasing ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n + 1 ) ] for i in range ( 10 ) ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT dp [ i ] [ 1 ] = 1 NEW_LINE DEDENT for digit in range ( 10 ) : NEW_LINE INDENT for len in range ( 2 , n + 1 ) : NEW_LINE INDENT for x in range ( digit + 1 ) : NEW_LINE INDENT dp [ digit ] [ len ] += dp [ x ] [ len - 1 ] NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT count += dp [ i ] [ n ] NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = int ( count * ( N + i - 1 ) ) NEW_LINE count = int ( count / i ) NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 ; NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE
def getMinSquares ( n ) : NEW_LINE INDENT if n <= 3 : NEW_LINE INDENT return n ; NEW_LINE DEDENT res = n NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT temp = x * x ; NEW_LINE if temp > n : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT res = min ( res , 1 + getMinSquares ( n - temp ) ) NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT print ( getMinSquares ( 6 ) ) NEW_LINE
from math import ceil , sqrt NEW_LINE def getMinSquares ( n ) : NEW_LINE INDENT dp = [ 0 , 1 , 2 , 3 ] NEW_LINE for i in range ( 4 , n + 1 ) : NEW_LINE INDENT dp . append ( i ) NEW_LINE for x in range ( 1 , int ( ceil ( sqrt ( i ) ) ) + 1 ) : NEW_LINE INDENT temp = x * x ; NEW_LINE if temp > i : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - temp ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT print ( getMinSquares ( 6 ) ) NEW_LINE
import sys NEW_LINE def minCoins ( coins , m , V ) : NEW_LINE INDENT if ( V == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = sys . maxsize NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( coins [ i ] <= V ) : NEW_LINE INDENT sub_res = minCoins ( coins , m , V - coins [ i ] ) NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < res ) : NEW_LINE INDENT res = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT coins = [ 9 , 6 , 5 , 1 ] NEW_LINE m = len ( coins ) NEW_LINE V = 11 NEW_LINE print ( " Minimum ▁ coins ▁ required ▁ is " , minCoins ( coins , m , V ) ) NEW_LINE
import sys NEW_LINE def minCoins ( coins , m , V ) : NEW_LINE INDENT table = [ 0 for i in range ( V + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE for i in range ( 1 , V + 1 ) : NEW_LINE INDENT table [ i ] = sys . maxsize NEW_LINE DEDENT for i in range ( 1 , V + 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( coins [ j ] <= i ) : NEW_LINE INDENT sub_res = table [ i - coins [ j ] ] NEW_LINE if ( sub_res != sys . maxsize and sub_res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = sub_res + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if table [ V ] == sys . maxsize : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return table [ V ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT coins = [ 9 , 6 , 5 , 1 ] NEW_LINE m = len ( coins ) NEW_LINE V = 11 NEW_LINE print ( " Minimum ▁ coins ▁ required ▁ is ▁ " , minCoins ( coins , m , V ) ) NEW_LINE DEDENT
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT if ( not m ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT return m NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + superSeq ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT return 1 + min ( superSeq ( X , Y , m - 1 , n ) , superSeq ( X , Y , m , n - 1 ) ) NEW_LINE DEDENT X = " AGGTAB " NEW_LINE Y = " GXTXAYB " NEW_LINE print ( " Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is ▁ % d " % superSeq ( X , Y , len ( X ) , len ( Y ) ) ) NEW_LINE
def superSeq ( X , Y , m , n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 2 ) for i in range ( m + 2 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( not i ) : NEW_LINE INDENT dp [ i ] [ j ] = j NEW_LINE DEDENT elif ( not j ) : NEW_LINE INDENT dp [ i ] [ j ] = i NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT X = " AGGTAB " NEW_LINE Y = " GXTXAYB " NEW_LINE print ( " Length ▁ of ▁ the ▁ shortest ▁ supersequence ▁ is ▁ % d " % superSeq ( X , Y , len ( X ) , len ( Y ) ) ) NEW_LINE
def sumOfDigitsFrom1ToN ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for x in range ( 1 , n + 1 ) : NEW_LINE INDENT result = result + sumOfDigits ( x ) NEW_LINE DEDENT return result NEW_LINE DEDENT def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sum = sum + x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 328 NEW_LINE print ( " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ from ▁ 1 ▁ to " , n , " is " , sumOfDigitsFrom1ToN ( n ) ) NEW_LINE
import math NEW_LINE def sumOfDigitsFrom1ToN ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT d = ( int ) ( math . log10 ( n ) ) NEW_LINE a = [ 0 ] * ( d + 1 ) NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 45 NEW_LINE for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 10 + 45 * ( int ) ( math . ceil ( math . pow ( 10 , i - 1 ) ) ) NEW_LINE DEDENT p = ( int ) ( math . ceil ( math . pow ( 10 , d ) ) ) NEW_LINE msd = n // p NEW_LINE return ( int ) ( msd * a [ d ] + ( msd * ( msd - 1 ) // 2 ) * p + msd * ( 1 + n % p ) + sumOfDigitsFrom1ToN ( n % p ) ) NEW_LINE DEDENT n = 328 NEW_LINE print ( " Sum ▁ of ▁ digits ▁ in ▁ numbers ▁ from ▁ 1 ▁ to " , n , " is " , sumOfDigitsFrom1ToN ( n ) ) NEW_LINE
def countWays ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT countB = 1 NEW_LINE countS = 1 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT prev_countB = countB NEW_LINE prev_countS = countS NEW_LINE countS = prev_countB + prev_countS NEW_LINE countB = prev_countS NEW_LINE DEDENT result = countS + countB NEW_LINE return ( result * result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 3 NEW_LINE print ( " Count ▁ of ▁ ways ▁ for ▁ " , N , " ▁ sections ▁ is ▁ " , countWays ( N ) ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT table = [ 0 for i in range ( n + 1 ) ] NEW_LINE table [ 0 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 3 ] NEW_LINE DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 5 ] NEW_LINE DEDENT for i in range ( 10 , n + 1 ) : NEW_LINE INDENT table [ i ] += table [ i - 10 ] NEW_LINE DEDENT return table [ n ] NEW_LINE DEDENT n = 20 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE n = 13 NEW_LINE print ( ' Count ▁ for ' , n , ' is ' , count ( n ) ) NEW_LINE
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < M ) : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT print ( " Pattern ▁ found ▁ at ▁ index ▁ " , i ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT txt = " AABAACAADAABAAABAA " NEW_LINE pat = " AABA " NEW_LINE search ( pat , txt ) NEW_LINE DEDENT
d = 256 NEW_LINE def search ( pat , txt , q ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE p = 0 NEW_LINE t = 0 NEW_LINE h = 1 NEW_LINE for i in xrange ( M - 1 ) : NEW_LINE INDENT h = ( h * d ) % q NEW_LINE DEDENT for i in xrange ( M ) : NEW_LINE INDENT p = ( d * p + ord ( pat [ i ] ) ) % q NEW_LINE t = ( d * t + ord ( txt [ i ] ) ) % q NEW_LINE DEDENT for i in xrange ( N - M + 1 ) : NEW_LINE INDENT if p == t : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT else : j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT print " Pattern ▁ found ▁ at ▁ index ▁ " + str ( i ) NEW_LINE DEDENT DEDENT if i < N - M : NEW_LINE INDENT t = ( d * ( t - ord ( txt [ i ] ) * h ) + ord ( txt [ i + M ] ) ) % q NEW_LINE if t < 0 : NEW_LINE INDENT t = t + q NEW_LINE DEDENT DEDENT DEDENT DEDENT txt = " GEEKS ▁ FOR ▁ GEEKS " NEW_LINE pat = " GEEK " NEW_LINE q = 101 NEW_LINE search ( pat , txt , q ) NEW_LINE
def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while i <= N - M : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == M : NEW_LINE INDENT print " Pattern ▁ found ▁ at ▁ index ▁ " + str ( i ) NEW_LINE i = i + M NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT txt = " ABCEABCDABCEABCD " NEW_LINE pat = " ABCD " NEW_LINE search ( pat , txt ) NEW_LINE
def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE count = 0 NEW_LINE while count < n + 1 : NEW_LINE INDENT count += 1 NEW_LINE if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ar1 [ i ] <= ar2 [ j ] : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) / 2 NEW_LINE DEDENT ar1 = [ 1 , 12 , 15 , 26 , 38 ] NEW_LINE ar2 = [ 2 , 13 , 17 , 30 , 45 ] NEW_LINE n1 = len ( ar1 ) NEW_LINE n2 = len ( ar2 ) NEW_LINE if n1 == n2 : NEW_LINE INDENT print ( " Median ▁ is ▁ " , getMedian ( ar1 , ar2 , n1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size " ) NEW_LINE DEDENT
def area ( x1 , y1 , x2 , y2 , x3 , y3 ) : NEW_LINE INDENT return abs ( ( x1 * ( y2 - y3 ) + x2 * ( y3 - y1 ) + x3 * ( y1 - y2 ) ) / 2.0 ) NEW_LINE DEDENT def isInside ( x1 , y1 , x2 , y2 , x3 , y3 , x , y ) : NEW_LINE INDENT A = area ( x1 , y1 , x2 , y2 , x3 , y3 ) NEW_LINE A1 = area ( x , y , x2 , y2 , x3 , y3 ) NEW_LINE A2 = area ( x1 , y1 , x , y , x3 , y3 ) NEW_LINE A3 = area ( x1 , y1 , x2 , y2 , x , y ) NEW_LINE if ( A == A1 + A2 + A3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( isInside ( 0 , 0 , 20 , 0 , 10 , 30 , 10 , 15 ) ) : NEW_LINE INDENT print ( ' Inside ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Not ▁ Inside ' ) NEW_LINE DEDENT
def isLucky ( n ) : NEW_LINE INDENT next_position = n NEW_LINE if isLucky . counter > n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n % isLucky . counter == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT next_position = next_position - next_position / isLucky . counter NEW_LINE isLucky . counter = isLucky . counter + 1 NEW_LINE return isLucky ( next_position ) NEW_LINE DEDENT isLucky . counter = 2 NEW_LINE x = 5 NEW_LINE if isLucky ( x ) : NEW_LINE INDENT print x , " is ▁ a ▁ Lucky ▁ number " NEW_LINE DEDENT else : NEW_LINE INDENT print x , " is ▁ not ▁ a ▁ Lucky ▁ number " NEW_LINE DEDENT
def pow ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT answer = a NEW_LINE increment = a NEW_LINE for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( 1 , a ) : NEW_LINE INDENT answer += increment NEW_LINE DEDENT increment = answer NEW_LINE DEDENT return answer NEW_LINE DEDENT print ( pow ( 5 , 3 ) ) NEW_LINE
def multiply ( x , y ) : NEW_LINE INDENT if ( y ) : NEW_LINE INDENT return ( x + multiply ( x , y - 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def pow ( a , b ) : NEW_LINE INDENT if ( b ) : NEW_LINE INDENT return multiply ( a , pow ( a , b - 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT print ( pow ( 5 , 3 ) ) ; NEW_LINE
def count ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return n NEW_LINE DEDENT elif n >= 3 and n < 10 : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT po = 1 NEW_LINE while n / po > 9 : NEW_LINE INDENT po = po * 10 NEW_LINE DEDENT msd = n / po NEW_LINE if msd != 3 : NEW_LINE INDENT return count ( msd ) * count ( po - 1 ) + count ( msd ) + count ( n % po ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( msd * po - 1 ) NEW_LINE DEDENT DEDENT n = 578 NEW_LINE print count ( n ) NEW_LINE
def maximumNumberDistinctPrimeRange ( m , n ) : NEW_LINE INDENT factorCount = [ 0 ] * ( n + 1 ) NEW_LINE prime = [ False ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT factorCount [ i ] = 0 NEW_LINE prime [ i ] = True NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT factorCount [ i ] = 1 NEW_LINE for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT factorCount [ j ] += 1 NEW_LINE prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT max = factorCount [ m ] NEW_LINE num = m NEW_LINE for i in range ( m , n + 1 ) : NEW_LINE INDENT if ( factorCount [ i ] > max ) : NEW_LINE INDENT max = factorCount [ i ] NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 4 NEW_LINE n = 6 NEW_LINE print ( maximumNumberDistinctPrimeRange ( m , n ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT f = 1 NEW_LINE while n >= 1 : NEW_LINE INDENT f = f * n NEW_LINE n = n - 1 NEW_LINE DEDENT return f NEW_LINE DEDENT def findSmallerInRight ( st , low , high ) : NEW_LINE INDENT countRight = 0 NEW_LINE i = low + 1 NEW_LINE while i <= high : NEW_LINE INDENT if st [ i ] < st [ low ] : NEW_LINE INDENT countRight = countRight + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return countRight NEW_LINE DEDENT def findRank ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE mul = fact ( ln ) NEW_LINE rank = 1 NEW_LINE i = 0 NEW_LINE while i < ln : NEW_LINE INDENT mul = mul / ( ln - i ) NEW_LINE countRight = findSmallerInRight ( st , i , ln - 1 ) NEW_LINE rank = rank + countRight * mul NEW_LINE i = i + 1 NEW_LINE DEDENT return rank NEW_LINE DEDENT st = " string " NEW_LINE print ( findRank ( st ) ) NEW_LINE
MAX_CHAR = 256 ; NEW_LINE count = [ 0 ] * ( MAX_CHAR + 1 ) ; NEW_LINE def fact ( n ) : NEW_LINE INDENT return 1 if ( n <= 1 ) else ( n * fact ( n - 1 ) ) ; NEW_LINE DEDENT def populateAndIncreaseCount ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( 1 , MAX_CHAR ) : NEW_LINE INDENT count [ i ] += count [ i - 1 ] ; NEW_LINE DEDENT DEDENT def updatecount ( ch ) : NEW_LINE INDENT for i in range ( ord ( ch ) , MAX_CHAR ) : NEW_LINE INDENT count [ i ] -= 1 ; NEW_LINE DEDENT DEDENT def findRank ( str ) : NEW_LINE INDENT len1 = len ( str ) ; NEW_LINE mul = fact ( len1 ) ; NEW_LINE rank = 1 ; NEW_LINE populateAndIncreaseCount ( str ) ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT mul = mul // ( len1 - i ) ; NEW_LINE rank += count [ ord ( str [ i ] ) - 1 ] * mul ; NEW_LINE updatecount ( str [ i ] ) ; NEW_LINE DEDENT return rank ; NEW_LINE DEDENT str = " string " ; NEW_LINE print ( findRank ( str ) ) ; NEW_LINE
def exponential ( n , x ) : NEW_LINE INDENT sum = 1.0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT sum = 1 + x * sum / i NEW_LINE DEDENT print ( " e ^ x ▁ = " , sum ) NEW_LINE DEDENT n = 10 NEW_LINE x = 1.0 NEW_LINE exponential ( n , x ) NEW_LINE
import math NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT s = int ( math . sqrt ( x ) ) NEW_LINE return s * s == x NEW_LINE DEDENT def isFibonacci ( n ) : NEW_LINE INDENT return isPerfectSquare ( 5 * n * n + 4 ) or isPerfectSquare ( 5 * n * n - 4 ) NEW_LINE DEDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT if ( isFibonacci ( i ) == True ) : NEW_LINE INDENT print i , " is ▁ a ▁ Fibonacci ▁ Number " NEW_LINE DEDENT else : NEW_LINE INDENT print i , " is ▁ a ▁ not ▁ Fibonacci ▁ Number ▁ " NEW_LINE DEDENT DEDENT
def findTrailingZeros ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n >= 5 ) : NEW_LINE INDENT n //= 5 NEW_LINE count += n NEW_LINE DEDENT return count NEW_LINE DEDENT n = 100 NEW_LINE print ( " Count ▁ of ▁ trailing ▁ 0s ▁ " + " in ▁ 100 ! ▁ is " , findTrailingZeros ( n ) ) NEW_LINE
def catalan ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += catalan ( i ) * catalan ( n - i - 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print catalan ( i ) , NEW_LINE DEDENT
def catalan ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT catalan = [ 0 ] * ( n + 1 ) NEW_LINE catalan [ 0 ] = 1 NEW_LINE catalan [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT catalan [ i ] += catalan [ j ] * catalan [ i - j - 1 ] NEW_LINE DEDENT DEDENT return catalan [ n ] NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = " ▁ " ) NEW_LINE DEDENT
def binomialCoefficient ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res / ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoefficient ( 2 * n , n ) NEW_LINE return c / ( n + 1 ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT print ( catalan ( i ) , end = " ▁ " ) NEW_LINE DEDENT
def calcAngle ( h , m ) : NEW_LINE INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) : NEW_LINE INDENT print ( ' Wrong ▁ input ' ) NEW_LINE DEDENT if ( h == 12 ) : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if ( m == 60 ) : NEW_LINE INDENT m = 0 NEW_LINE h += 1 ; NEW_LINE if ( h > 12 ) : NEW_LINE INDENT h = h - 12 ; NEW_LINE DEDENT DEDENT hour_angle = 0.5 * ( h * 60 + m ) NEW_LINE minute_angle = 6 * m NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT h = 9 NEW_LINE m = 60 NEW_LINE print ( ' Angle ▁ ' , calcAngle ( h , m ) ) NEW_LINE
def getInvCount ( arr ) : NEW_LINE INDENT inv_count = 0 NEW_LINE for i in range ( 0 , 2 ) : NEW_LINE INDENT for j in range ( i + 1 , 3 ) : NEW_LINE INDENT if ( arr [ j ] [ i ] > 0 and arr [ j ] [ i ] > arr [ i ] [ j ] ) : NEW_LINE INDENT inv_count += 1 NEW_LINE DEDENT DEDENT DEDENT return inv_count NEW_LINE DEDENT def isSolvable ( puzzle ) : NEW_LINE INDENT invCount = getInvCount ( puzzle ) NEW_LINE return ( invCount % 2 == 0 ) NEW_LINE DEDENT puzzle = [ [ 1 , 8 , 2 ] , [ 0 , 4 , 3 ] , [ 7 , 6 , 5 ] ] NEW_LINE if ( isSolvable ( puzzle ) ) : NEW_LINE INDENT print ( " Solvable " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Solvable " ) NEW_LINE DEDENT
import math NEW_LINE def find ( p ) : NEW_LINE INDENT return math . ceil ( math . sqrt ( 2 * 365 * math . log ( 1 / ( 1 - p ) ) ) ) ; NEW_LINE DEDENT print ( find ( 0.70 ) ) NEW_LINE
def countSolutions ( n ) : NEW_LINE INDENT res = 0 NEW_LINE x = 0 NEW_LINE while ( x * x < n ) : NEW_LINE INDENT y = 0 NEW_LINE while ( x * x + y * y < n ) : NEW_LINE INDENT res = res + 1 NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " Total ▁ Number ▁ of ▁ distinct ▁ Non - Negative ▁ pairs ▁ is ▁ " , countSolutions ( 6 ) ) NEW_LINE DEDENT
def countSolutions ( n ) : NEW_LINE INDENT x = 0 NEW_LINE res = 0 NEW_LINE yCount = 0 NEW_LINE while ( yCount * yCount < n ) : NEW_LINE INDENT yCount = yCount + 1 NEW_LINE DEDENT while ( yCount != 0 ) : NEW_LINE INDENT res = res + yCount NEW_LINE x = x + 1 NEW_LINE while ( yCount != 0 and ( x * x + ( yCount - 1 ) * ( yCount - 1 ) >= n ) ) : NEW_LINE INDENT yCount = yCount - 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT print ( " Total ▁ Number ▁ of ▁ distinct ▁ " , , countSolutions ( 6 ) )
def func ( x ) : NEW_LINE INDENT return x * x * x - x * x + 2 NEW_LINE DEDENT def derivFunc ( x ) : NEW_LINE INDENT return 3 * x * x - 2 * x NEW_LINE DEDENT def newtonRaphson ( x ) : NEW_LINE INDENT h = func ( x ) / derivFunc ( x ) NEW_LINE while abs ( h ) >= 0.0001 : NEW_LINE INDENT h = func ( x ) / derivFunc ( x ) NEW_LINE x = x - h NEW_LINE DEDENT print ( " The ▁ value ▁ of ▁ the ▁ root ▁ is ▁ : ▁ " , " % .4f " % x ) NEW_LINE DEDENT x0 = - 20 NEW_LINE newtonRaphson ( x0 ) NEW_LINE
def getSingle ( arr , n ) : NEW_LINE INDENT ones = 0 NEW_LINE twos = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twos = twos | ( ones & arr [ i ] ) NEW_LINE ones = ones ^ arr [ i ] NEW_LINE common_bit_mask = ~ ( ones & twos ) NEW_LINE ones &= common_bit_mask NEW_LINE twos &= common_bit_mask NEW_LINE DEDENT return ones NEW_LINE DEDENT arr = [ 3 , 3 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " , getSingle ( arr , n ) ) NEW_LINE
INT_SIZE = 32 NEW_LINE def getSingle ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , INT_SIZE ) : NEW_LINE INDENT sm = 0 NEW_LINE x = ( 1 << i ) NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & x ) : NEW_LINE INDENT sm = sm + 1 NEW_LINE DEDENT DEDENT if ( ( sm % 3 ) != 0 ) : NEW_LINE INDENT result = result | x NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " , getSingle ( arr , n ) ) NEW_LINE
def oppositeSigns ( x , y ) : NEW_LINE INDENT return ( ( x ^ y ) < 0 ) ; NEW_LINE DEDENT x = 100 NEW_LINE y = 1 NEW_LINE if ( oppositeSigns ( x , y ) == True ) : NEW_LINE INDENT print " Signs ▁ are ▁ opposite " NEW_LINE DEDENT else : NEW_LINE INDENT print " Signs ▁ are ▁ not ▁ opposite " NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += countSetBitsUtil ( i ) NEW_LINE DEDENT return bitCount NEW_LINE DEDENT def countSetBitsUtil ( x ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 0 if int ( x % 2 ) == 0 else 1 ) + countSetBitsUtil ( int ( x / 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( " Total ▁ set ▁ bit ▁ count ▁ is " , countSetBits ( n ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT i = 0 NEW_LINE ans = 0 NEW_LINE while ( ( 1 << i ) <= n ) : NEW_LINE INDENT k = 0 NEW_LINE change = 1 << i NEW_LINE for j in range ( 0 , n + 1 ) : NEW_LINE INDENT ans += k NEW_LINE if change == 1 : NEW_LINE INDENT k = not k NEW_LINE change = 1 << i NEW_LINE DEDENT else : NEW_LINE INDENT change -= 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 17 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE DEDENT
def swapBits ( x , p1 , p2 , n ) : NEW_LINE INDENT set1 = ( x >> p1 ) & ( ( 1 << n ) - 1 ) NEW_LINE set2 = ( x >> p2 ) & ( ( 1 << n ) - 1 ) NEW_LINE xor = ( set1 ^ set2 ) NEW_LINE xor = ( xor << p1 ) | ( xor << p2 ) NEW_LINE result = x ^ xor NEW_LINE return result NEW_LINE DEDENT res = swapBits ( 28 , 0 , 3 , 2 ) NEW_LINE print ( " Result ▁ = " , res ) NEW_LINE
def smallest ( x , y , z ) : NEW_LINE INDENT c = 0 NEW_LINE while ( x and y and z ) : NEW_LINE INDENT x = x - 1 NEW_LINE y = y - 1 NEW_LINE z = z - 1 NEW_LINE c = c + 1 NEW_LINE DEDENT return c NEW_LINE DEDENT x = 12 NEW_LINE y = 15 NEW_LINE z = 5 NEW_LINE print ( " Minimum ▁ of ▁ 3 ▁ numbers ▁ is " , smallest ( x , y , z ) ) NEW_LINE
def snoob ( x ) : NEW_LINE INDENT next = 0 NEW_LINE if ( x ) : NEW_LINE INDENT rightOne = x & - ( x ) NEW_LINE nextHigherOneBit = x + int ( rightOne ) NEW_LINE rightOnesPattern = x ^ int ( nextHigherOneBit ) NEW_LINE rightOnesPattern = ( int ( rightOnesPattern ) / int ( rightOne ) ) NEW_LINE rightOnesPattern = int ( rightOnesPattern ) >> 2 NEW_LINE next = nextHigherOneBit | rightOnesPattern NEW_LINE DEDENT return next NEW_LINE DEDENT x = 156 NEW_LINE print ( " Next ▁ higher ▁ number ▁ with ▁ " + " same ▁ number ▁ of ▁ set ▁ bits ▁ is " , snoob ( x ) ) NEW_LINE
def addOne ( x ) : NEW_LINE INDENT m = 1 ; NEW_LINE while ( x & m ) : NEW_LINE INDENT x = x ^ m NEW_LINE m <<= 1 NEW_LINE DEDENT x = x ^ m NEW_LINE return x NEW_LINE DEDENT n = 13 NEW_LINE print addOne ( n ) NEW_LINE
def addOne ( x ) : NEW_LINE INDENT return ( - ( ~ x ) ) ; NEW_LINE DEDENT print ( addOne ( 13 ) ) NEW_LINE
def multiplyWith3Point5 ( x ) : NEW_LINE INDENT return ( x << 1 ) + x + ( x >> 1 ) NEW_LINE DEDENT x = 4 NEW_LINE print ( multiplyWith3Point5 ( x ) ) NEW_LINE
def fun ( n ) : NEW_LINE INDENT return n & ( n - 1 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " The ▁ number ▁ after ▁ unsetting ▁ the ▁ rightmost ▁ set ▁ bit " , fun ( n ) ) NEW_LINE
def isPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 4 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return True NEW_LINE DEDENT test_no = 64 NEW_LINE if ( isPowerOfFour ( 64 ) ) : NEW_LINE INDENT print ( test_no , ' is ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( test_no , ' is ▁ not ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and ( not ( n & ( n - 1 ) ) ) ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT test_no = 64 NEW_LINE if ( isPowerOfFour ( 64 ) ) : NEW_LINE INDENT print ( test_no , ' is ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( test_no , ' is ▁ not ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT
def min ( x , y ) : NEW_LINE INDENT return y ^ ( ( x ^ y ) & - ( x < y ) ) NEW_LINE DEDENT def max ( x , y ) : NEW_LINE INDENT return x ^ ( ( x ^ y ) & - ( x < y ) ) NEW_LINE DEDENT x = 15 NEW_LINE y = 6 NEW_LINE print ( " Minimum ▁ of " , x , " and " , y , " is " , end = " ▁ " ) NEW_LINE print ( min ( x , y ) ) NEW_LINE print ( " Maximum ▁ of " , x , " and " , y , " is " , end = " ▁ " ) NEW_LINE print ( max ( x , y ) ) NEW_LINE
def getOddOccurrence ( arr , arr_size ) : NEW_LINE INDENT for i in range ( 0 , arr_size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getOddOccurrence ( arr , n ) ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT count += 1 NEW_LINE n &= ( n - 1 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def FlippedCount ( a , b ) : NEW_LINE INDENT return countSetBits ( a ^ b ) NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print ( FlippedCount ( a , b ) ) NEW_LINE
import math NEW_LINE def getFirstSetBitPos ( n ) : NEW_LINE INDENT return math . log2 ( n & - n ) + 1 NEW_LINE DEDENT n = 12 NEW_LINE print ( int ( getFirstSetBitPos ( n ) ) ) NEW_LINE
def PositionRightmostSetbit ( n ) : NEW_LINE INDENT position = 1 NEW_LINE m = 1 NEW_LINE while ( not ( n & m ) ) : NEW_LINE INDENT m = m << 1 NEW_LINE position += 1 NEW_LINE DEDENT return position NEW_LINE DEDENT n = 16 NEW_LINE print ( PositionRightmostSetbit ( n ) ) NEW_LINE
INT_SIZE = 32 NEW_LINE def Right_most_setbit ( num ) : NEW_LINE INDENT pos = 1 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT if not ( num & ( 1 << i ) ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return pos NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 18 NEW_LINE pos = Right_most_setbit ( num ) NEW_LINE print ( pos ) NEW_LINE DEDENT
def bin ( n ) : NEW_LINE INDENT if ( n > 1 ) : NEW_LINE INDENT bin ( n >> 1 ) NEW_LINE DEDENT print ( n & 1 , end = " " ) NEW_LINE DEDENT bin ( 131 ) NEW_LINE print ( ) NEW_LINE bin ( 3 ) NEW_LINE
def swapBits ( x ) : NEW_LINE INDENT even_bits = x & 0xAAAAAAAA NEW_LINE odd_bits = x & 0x55555555 NEW_LINE even_bits >>= 1 NEW_LINE odd_bits <<= 1 NEW_LINE return ( even_bits odd_bits ) NEW_LINE DEDENT x = 23 NEW_LINE print ( swapBits ( x ) ) NEW_LINE
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( True if ( n > 0 and ( ( n & ( n - 1 ) ) > 0 ) ) else False ) ; NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if ( isPowerOfTwo ( n ) == True ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT i = 1 ; NEW_LINE pos = 1 ; NEW_LINE while ( ( i & n ) == 0 ) : NEW_LINE INDENT i = i << 1 ; NEW_LINE pos += 1 ; NEW_LINE DEDENT return pos ; NEW_LINE DEDENT n = 16 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( " n ▁ = " , n , " , ▁ Invalid ▁ number " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " n ▁ = " , n , " , ▁ Position ▁ " , pos ) ; NEW_LINE DEDENT n = 12 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( " n ▁ = " , n , " , ▁ Invalid ▁ number " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " n ▁ = " , n , " , ▁ Position ▁ " , pos ) ; NEW_LINE DEDENT n = 128 ; NEW_LINE pos = findPosition ( n ) ; NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT print ( " n ▁ = " , n , " , ▁ Invalid ▁ number " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " n ▁ = " , n , " , ▁ Position ▁ " , pos ) ; NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def findPosition ( n ) : NEW_LINE INDENT if not isPowerOfTwo ( n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n >> 1 NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 0 NEW_LINE pos = findPosition ( n ) NEW_LINE if pos == - 1 : NEW_LINE INDENT print ( " n ▁ = " , n , " Invalid ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " n ▁ = " , n , " Position " , pos ) NEW_LINE DEDENT n = 12 NEW_LINE pos = findPosition ( n ) NEW_LINE if pos == - 1 : NEW_LINE INDENT print ( " n ▁ = " , n , " Invalid ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " n ▁ = " , n , " Position " , pos ) NEW_LINE DEDENT n = 128 NEW_LINE pos = findPosition ( n ) NEW_LINE if pos == - 1 : NEW_LINE INDENT print ( " n ▁ = " , n , " Invalid ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " n ▁ = " , n , " Position " , pos ) NEW_LINE DEDENT DEDENT
x = 10 NEW_LINE y = 5 NEW_LINE x = x * y NEW_LINE y = x // y ; NEW_LINE x = x // y ; NEW_LINE print ( " After ▁ Swapping : ▁ x ▁ = " , x , " ▁ y ▁ = " , y ) ; NEW_LINE
x = 10 NEW_LINE y = 5 NEW_LINE x = x ^ y ; NEW_LINE y = x ^ y ; NEW_LINE x = x ^ y ; NEW_LINE print ( " After ▁ Swapping : ▁ x ▁ = ▁ " , x , " ▁ y ▁ = " , y ) NEW_LINE
def swap ( xp , yp ) : NEW_LINE INDENT xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE yp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE xp [ 0 ] = xp [ 0 ] ^ yp [ 0 ] NEW_LINE DEDENT x = [ 10 ] NEW_LINE swap ( x , x ) NEW_LINE print ( " After ▁ swap ( & x , ▁ & x ) : ▁ x ▁ = ▁ " , x [ 0 ] ) NEW_LINE
def maxOnesIndex ( arr , n ) : NEW_LINE INDENT max_count = 0 NEW_LINE max_index = 0 NEW_LINE prev_zero = - 1 NEW_LINE prev_prev_zero = - 1 NEW_LINE for curr in range ( n ) : NEW_LINE INDENT if ( arr [ curr ] == 0 ) : NEW_LINE INDENT if ( curr - prev_prev_zero > max_count ) : NEW_LINE INDENT max_count = curr - prev_prev_zero NEW_LINE max_index = prev_zero NEW_LINE DEDENT prev_prev_zero = prev_zero NEW_LINE prev_zero = curr NEW_LINE DEDENT DEDENT if ( n - prev_prev_zero > max_count ) : NEW_LINE INDENT max_index = prev_zero NEW_LINE DEDENT return max_index NEW_LINE DEDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 1 , 1 , 0 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Index ▁ of ▁ 0 ▁ to ▁ be ▁ replaced ▁ is ▁ " , maxOnesIndex ( arr , n ) ) NEW_LINE
def min ( x , y ) : NEW_LINE INDENT return x if ( x < y ) else y NEW_LINE DEDENT def max ( x , y ) : NEW_LINE INDENT return x if ( x > y ) else y NEW_LINE DEDENT def findLength ( arr , n ) : NEW_LINE INDENT max_len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT mn = arr [ i ] NEW_LINE mx = arr [ i ] NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT mn = min ( mn , arr [ j ] ) NEW_LINE mx = max ( mx , arr [ j ] ) NEW_LINE if ( ( mx - mn ) == j - i ) : NEW_LINE INDENT max_len = max ( max_len , mx - mn + 1 ) NEW_LINE DEDENT DEDENT DEDENT return max_len NEW_LINE DEDENT arr = [ 1 , 56 , 58 , 57 , 90 , 92 , 94 , 93 , 91 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ the ▁ longest ▁ contiguous ▁ subarray ▁ is ▁ " , findLength ( arr , n ) ) NEW_LINE
def printArr ( arr , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT def printSeqUtil ( n , k , len1 , arr ) : NEW_LINE INDENT if ( len1 == k ) : NEW_LINE INDENT printArr ( arr , k ) ; NEW_LINE return ; NEW_LINE DEDENT i = 1 if ( len1 == 0 ) else ( arr [ len1 - 1 ] + 1 ) ; NEW_LINE len1 += 1 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT arr [ len1 - 1 ] = i ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT len1 -= 1 ; NEW_LINE DEDENT def printSeq ( n , k ) : NEW_LINE INDENT arr = [ 0 ] * k ; NEW_LINE len1 = 0 ; NEW_LINE printSeqUtil ( n , k , len1 , arr ) ; NEW_LINE DEDENT k = 3 ; NEW_LINE n = 7 ; NEW_LINE printSeq ( n , k ) ; NEW_LINE
def isSubSequence ( string1 , string2 , m , n ) : NEW_LINE INDENT if m == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if string1 [ m - 1 ] == string2 [ n - 1 ] : NEW_LINE INDENT return isSubSequence ( string1 , string2 , m - 1 , n - 1 ) NEW_LINE DEDENT return isSubSequence ( string1 , string2 , m , n - 1 ) NEW_LINE DEDENT string1 = " gksrek " NEW_LINE string2 = " geeksforgeeks " NEW_LINE if isSubSequence ( string1 , string2 , len ( string1 ) , len ( string2 ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def nextGreatest ( arr ) : NEW_LINE INDENT size = len ( arr ) NEW_LINE max_from_right = arr [ size - 1 ] NEW_LINE arr [ size - 1 ] = - 1 NEW_LINE for i in range ( size - 2 , - 1 , - 1 ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = max_from_right NEW_LINE if max_from_right < temp : NEW_LINE INDENT max_from_right = temp NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT print arr [ i ] , NEW_LINE DEDENT DEDENT arr = [ 16 , 17 , 4 , 3 , 5 , 2 ] NEW_LINE nextGreatest ( arr ) NEW_LINE print " Modified ▁ array ▁ is " NEW_LINE printArray ( arr ) NEW_LINE
def GetCeilIndex ( arr , T , l , r , key ) : NEW_LINE INDENT while ( r - l > 1 ) : NEW_LINE INDENT m = l + ( r - l ) // 2 NEW_LINE if ( arr [ T [ m ] ] >= key ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def LongestIncreasingSubsequence ( arr , n ) : NEW_LINE INDENT tailIndices = [ 0 for i in range ( n + 1 ) ] NEW_LINE prevIndices = [ - 1 for i in range ( n + 1 ) ] NEW_LINE len = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ tailIndices [ 0 ] ] ) : NEW_LINE INDENT tailIndices [ 0 ] = i NEW_LINE DEDENT elif ( arr [ i ] > arr [ tailIndices [ len - 1 ] ] ) : NEW_LINE INDENT prevIndices [ i ] = tailIndices [ len - 1 ] NEW_LINE tailIndices [ len ] = i NEW_LINE len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT pos = GetCeilIndex ( arr , tailIndices , - 1 , len - 1 , arr [ i ] ) NEW_LINE prevIndices [ i ] = tailIndices [ pos - 1 ] NEW_LINE tailIndices [ pos ] = i NEW_LINE DEDENT DEDENT print ( " LIS ▁ of ▁ given ▁ input " ) NEW_LINE i = tailIndices [ len - 1 ] NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT print ( arr [ i ] , " ▁ " , end = " " ) NEW_LINE i = prevIndices [ i ] NEW_LINE DEDENT print ( ) NEW_LINE return len NEW_LINE DEDENT arr = [ 2 , 5 , 3 , 7 , 11 , 8 , 10 , 13 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " LIS size " , LongestIncreasingSubsequence ( arr , n ) ) NEW_LINE
def generateUtil ( A , B , C , i , j , m , n , len , flag ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT if ( len ) : NEW_LINE INDENT printArr ( C , len + 1 ) NEW_LINE DEDENT for k in range ( i , m ) : NEW_LINE INDENT if ( not len ) : NEW_LINE INDENT C [ len ] = A [ k ] NEW_LINE generateUtil ( A , B , C , k + 1 , j , m , n , len , not flag ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( A [ k ] > C [ len ] ) : NEW_LINE INDENT C [ len + 1 ] = A [ k ] NEW_LINE generateUtil ( A , B , C , k + 1 , j , m , n , len + 1 , not flag ) NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT for l in range ( j , n ) : NEW_LINE INDENT if ( B [ l ] > C [ len ] ) : NEW_LINE INDENT C [ len + 1 ] = B [ l ] NEW_LINE generateUtil ( A , B , C , i , l + 1 , m , n , len + 1 , not flag ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def generate ( A , B , m , n ) : NEW_LINE INDENT C = [ ] NEW_LINE for i in range ( m + n + 1 ) : NEW_LINE INDENT C . append ( 0 ) NEW_LINE DEDENT generateUtil ( A , B , C , 0 , 0 , m , n , 0 , True ) NEW_LINE DEDENT def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT A = [ 10 , 15 , 25 ] NEW_LINE B = [ 5 , 20 , 30 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE generate ( A , B , n , m ) NEW_LINE
from __future__ import print_function NEW_LINE def replace_elements ( arr , n ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT arr [ pos ] = arr [ i ] NEW_LINE pos = pos + 1 NEW_LINE while ( pos > 1 and arr [ pos - 2 ] == arr [ pos - 1 ] ) : NEW_LINE INDENT pos -= 1 NEW_LINE arr [ pos - 1 ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , pos ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 6 , 4 , 3 , 4 , 3 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE replace_elements ( arr , n ) NEW_LINE
def arrangeString ( str1 , x , y ) : NEW_LINE INDENT count_0 = 0 NEW_LINE count_1 = 0 NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str1 [ i ] == '0' : NEW_LINE INDENT count_0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_1 += 1 NEW_LINE DEDENT DEDENT while count_0 > 0 or count_1 > 0 : NEW_LINE INDENT for i in range ( 0 , x ) : NEW_LINE INDENT if count_0 > 0 : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE count_0 -= 1 NEW_LINE DEDENT DEDENT for j in range ( 0 , y ) : NEW_LINE INDENT if count_1 > 0 : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE count_1 -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = "01101101101101101000000" NEW_LINE x = 1 NEW_LINE y = 2 NEW_LINE arrangeString ( str1 , x , y ) NEW_LINE DEDENT
arr = [ 1 , 3 , 5 , 2 , 4 , 6 ] NEW_LINE def rearrange ( n ) : NEW_LINE INDENT global arr NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT currIdx = int ( ( n - 1 ) / 2 ) NEW_LINE while ( currIdx > 0 ) : NEW_LINE INDENT count = currIdx NEW_LINE swapIdx = currIdx NEW_LINE while ( count > 0 ) : NEW_LINE INDENT temp = arr [ swapIdx + 1 ] NEW_LINE arr [ swapIdx + 1 ] = arr [ swapIdx ] NEW_LINE arr [ swapIdx ] = temp NEW_LINE swapIdx = swapIdx + 1 NEW_LINE count = count - 1 NEW_LINE DEDENT currIdx = currIdx - 1 NEW_LINE DEDENT DEDENT n = len ( arr ) NEW_LINE rearrange ( n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " { } ▁ " . format ( arr [ i ] ) , end = " " ) NEW_LINE DEDENT
def maxDiff ( arr , arr_size ) : NEW_LINE INDENT max_diff = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT for j in range ( i + 1 , arr_size ) : NEW_LINE INDENT if ( arr [ j ] - arr [ i ] > max_diff ) : NEW_LINE INDENT max_diff = arr [ j ] - arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return max_diff NEW_LINE DEDENT arr = [ 1 , 2 , 90 , 10 , 110 ] NEW_LINE size = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , size ) ) NEW_LINE
def maxDiff ( arr , n ) : NEW_LINE INDENT maxDiff = - 1 NEW_LINE maxRight = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > maxRight ) : NEW_LINE INDENT maxRight = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT diff = maxRight - arr [ i ] NEW_LINE if ( diff > maxDiff ) : NEW_LINE INDENT maxDiff = diff NEW_LINE DEDENT DEDENT DEDENT return maxDiff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 90 , 10 , 110 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , n ) ) NEW_LINE DEDENT
def maxDiff ( arr , n ) : NEW_LINE INDENT diff = arr [ 1 ] - arr [ 0 ] NEW_LINE curr_sum = diff NEW_LINE max_sum = curr_sum NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT diff = arr [ i + 1 ] - arr [ i ] NEW_LINE if ( curr_sum > 0 ) : NEW_LINE INDENT curr_sum += diff NEW_LINE DEDENT else : NEW_LINE INDENT curr_sum = diff NEW_LINE DEDENT if ( curr_sum > max_sum ) : NEW_LINE INDENT max_sum = curr_sum NEW_LINE DEDENT DEDENT return max_sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 80 , 2 , 6 , 3 , 100 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ difference ▁ is " , maxDiff ( arr , n ) ) NEW_LINE DEDENT
def findMaximum ( arr , low , high ) : NEW_LINE INDENT max = arr [ low ] NEW_LINE i = low NEW_LINE for i in range ( high + 1 ) : NEW_LINE INDENT if arr [ i ] > max : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 1 , 30 , 40 , 50 , 60 , 70 , 23 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ maximum ▁ element ▁ is ▁ % d " % findMaximum ( arr , 0 , n - 1 ) ) NEW_LINE
def findMaximum ( arr , low , high ) : NEW_LINE INDENT if low == high : NEW_LINE INDENT return arr [ low ] NEW_LINE DEDENT if high == low + 1 and arr [ low ] >= arr [ high ] : NEW_LINE INDENT return arr [ low ] ; NEW_LINE DEDENT if high == low + 1 and arr [ low ] < arr [ high ] : NEW_LINE INDENT return arr [ high ] NEW_LINE DEDENT mid = ( low + high ) // 2 NEW_LINE if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] > arr [ mid - 1 ] : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if arr [ mid ] > arr [ mid + 1 ] and arr [ mid ] < arr [ mid - 1 ] : NEW_LINE INDENT return findMaximum ( arr , low , mid - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return findMaximum ( arr , mid + 1 , high ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 50 , 10 , 9 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ maximum ▁ element ▁ is ▁ % d " % findMaximum ( arr , 0 , n - 1 ) ) NEW_LINE
def maxPathSum ( ar1 , ar2 , m , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE result , sum1 , sum2 = 0 , 0 , 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ar1 [ i ] < ar2 [ j ] : NEW_LINE INDENT sum1 += ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT elif ar1 [ i ] > ar2 [ j ] : NEW_LINE INDENT sum2 += ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += max ( sum1 , sum2 ) + ar1 [ i ] NEW_LINE sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT while i < m : NEW_LINE INDENT sum1 += ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT while j < n : NEW_LINE INDENT sum2 += ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT result += max ( sum1 , sum2 ) NEW_LINE return result NEW_LINE DEDENT ar1 = [ 2 , 3 , 7 , 10 , 12 , 15 , 30 , 34 ] NEW_LINE ar2 = [ 1 , 5 , 7 , 8 , 10 , 15 , 16 , 19 ] NEW_LINE m = len ( ar1 ) NEW_LINE n = len ( ar2 ) NEW_LINE print " Maximum ▁ sum ▁ path ▁ is " , maxPathSum ( ar1 , ar2 , m , n ) NEW_LINE
def smallestGreater ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT diff = 1000 ; NEW_LINE closest = - 1 ; NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] and arr [ j ] - arr [ i ] < diff ) : NEW_LINE INDENT diff = arr [ j ] - arr [ i ] ; NEW_LINE closest = j ; NEW_LINE DEDENT DEDENT if ( closest == - 1 ) : NEW_LINE INDENT print ( " _ ▁ " , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " { } ▁ " . format ( arr [ closest ] ) , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT ar = [ 6 , 3 , 9 , 8 , 10 , 2 , 1 , 15 , 7 ] ; NEW_LINE n = len ( ar ) ; NEW_LINE smallestGreater ( ar , n ) ; NEW_LINE
def findZeroes ( arr , n , m ) : NEW_LINE INDENT wL = wR = 0 NEW_LINE bestL = bestWindow = 0 NEW_LINE zeroCount = 0 NEW_LINE while wR < n : NEW_LINE INDENT if zeroCount <= m : NEW_LINE INDENT if arr [ wR ] == 0 : NEW_LINE INDENT zeroCount += 1 NEW_LINE DEDENT wR += 1 NEW_LINE DEDENT if zeroCount > m : NEW_LINE INDENT if arr [ wL ] == 0 : NEW_LINE INDENT zeroCount -= 1 NEW_LINE DEDENT wL += 1 NEW_LINE DEDENT if ( wR - wL > bestWindow ) and ( zeroCount <= m ) : NEW_LINE INDENT bestWindow = wR - wL NEW_LINE bestL = wL NEW_LINE DEDENT DEDENT for i in range ( 0 , bestWindow ) : NEW_LINE INDENT if arr [ bestL + i ] == 0 : NEW_LINE INDENT print ( bestL + i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE m = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( " Indexes ▁ of ▁ zeroes ▁ to ▁ be ▁ flipped ▁ are " , end = " ▁ " ) NEW_LINE findZeroes ( arr , n , m ) NEW_LINE
def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ j - 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is " , countIncreasing ( arr , n ) ) NEW_LINE
def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE len = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if arr [ i + 1 ] > arr [ i ] : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) / 2 ) NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if len > 1 : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) / 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is " , int ( countIncreasing ( arr , n ) ) ) NEW_LINE
def arraySum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT def maxDiff ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE arraysum = arraySum ( arr , n ) NEW_LINE diff1 = abs ( arraysum - 2 * arraySum ( arr , k ) ) NEW_LINE arr . reverse ( ) NEW_LINE diff2 = abs ( arraysum - 2 * arraySum ( arr , k ) ) NEW_LINE return ( max ( diff1 , diff2 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 7 , 4 , 8 , - 1 , 5 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( " Maximum ▁ Difference ▁ = " , maxDiff ( arr , n , k ) ) NEW_LINE DEDENT
def minNumber ( a , n , x ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE k = 0 NEW_LINE while ( a [ int ( ( n - 1 ) / 2 ) ] != x ) : NEW_LINE INDENT a [ n - 1 ] = x NEW_LINE n += 1 NEW_LINE a . sort ( reverse = False ) NEW_LINE k += 1 NEW_LINE DEDENT return k NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE a = [ 10 , 20 , 30 ] NEW_LINE n = 3 NEW_LINE print ( minNumber ( a , n , x ) ) NEW_LINE DEDENT
def minNumber ( a , n , x ) : NEW_LINE INDENT l = 0 NEW_LINE h = 0 NEW_LINE e = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == x : NEW_LINE INDENT e += 1 NEW_LINE DEDENT elif a [ i ] > x : NEW_LINE INDENT h += 1 NEW_LINE DEDENT elif a [ i ] < x : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE if l > h : NEW_LINE INDENT ans = l - h NEW_LINE DEDENT elif l < h : NEW_LINE INDENT ans = h - l - 1 ; NEW_LINE DEDENT return ans + 1 - e NEW_LINE DEDENT x = 10 NEW_LINE a = [ 10 , 20 , 30 ] NEW_LINE n = len ( a ) NEW_LINE print ( minNumber ( a , n , x ) ) NEW_LINE
def checkEVENodd ( arr , n , l , r ) : NEW_LINE INDENT if ( arr [ r ] == 1 ) : NEW_LINE INDENT print ( " odd " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " even " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 1 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE checkEVENodd ( arr , n , 1 , 3 ) NEW_LINE
import math NEW_LINE def findMean ( arr , l , r ) : NEW_LINE INDENT sum , count = 0 , 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE count += 1 NEW_LINE DEDENT mean = math . floor ( sum / count ) NEW_LINE return mean NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE print ( findMean ( arr , 0 , 2 ) ) NEW_LINE print ( findMean ( arr , 1 , 3 ) ) NEW_LINE print ( findMean ( arr , 0 , 4 ) ) NEW_LINE
def calculateProduct ( A , L , R , P ) : NEW_LINE INDENT L = L - 1 NEW_LINE R = R - 1 NEW_LINE ans = 1 NEW_LINE for i in range ( R + 1 ) : NEW_LINE INDENT ans = ans * A [ i ] NEW_LINE ans = ans % P NEW_LINE DEDENT return ans NEW_LINE DEDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE P = 229 NEW_LINE L = 2 NEW_LINE R = 5 NEW_LINE print ( calculateProduct ( A , L , R , P ) ) NEW_LINE L = 1 NEW_LINE R = 3 NEW_LINE print ( calculateProduct ( A , L , R , P ) ) NEW_LINE
MAX = 10000 NEW_LINE prefix = [ 0 ] * ( MAX + 1 ) NEW_LINE def buildPrefix ( ) : NEW_LINE INDENT prime = [ 1 ] * ( MAX + 1 ) NEW_LINE p = 2 NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = 0 NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT prefix [ p ] = prefix [ p - 1 ] NEW_LINE if ( prime [ p ] == 1 ) : NEW_LINE INDENT prefix [ p ] += 1 NEW_LINE DEDENT DEDENT DEDENT def query ( L , R ) : NEW_LINE INDENT return prefix [ R ] - prefix [ L - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT buildPrefix ( ) NEW_LINE L = 5 NEW_LINE R = 10 NEW_LINE print ( query ( L , R ) ) NEW_LINE L = 1 NEW_LINE R = 10 NEW_LINE print ( query ( L , R ) ) NEW_LINE DEDENT
def command ( brr , a , b ) : NEW_LINE INDENT arr [ a ] ^= 1 NEW_LINE arr [ b + 1 ] ^= 1 NEW_LINE DEDENT def process ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT arr [ k ] ^= arr [ k - 1 ] NEW_LINE DEDENT DEDENT def result ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT print ( arr [ k ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 3 NEW_LINE arr = [ 0 for i in range ( n + 2 ) ] NEW_LINE command ( arr , 1 , 5 ) NEW_LINE command ( arr , 2 , 5 ) NEW_LINE command ( arr , 3 , 5 ) NEW_LINE process ( arr , n ) NEW_LINE result ( arr , n ) NEW_LINE DEDENT
import sys NEW_LINE def probability ( a , b , size1 , size2 ) : NEW_LINE INDENT max1 = - ( sys . maxsize - 1 ) NEW_LINE count1 = 0 NEW_LINE for i in range ( size1 ) : NEW_LINE INDENT if a [ i ] > max1 : NEW_LINE INDENT count1 = 1 NEW_LINE DEDENT elif a [ i ] == max1 : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT DEDENT max2 = - ( sys . maxsize - 1 ) NEW_LINE count2 = 0 NEW_LINE for i in range ( size2 ) : NEW_LINE INDENT if b [ i ] > max2 : NEW_LINE INDENT max2 = b [ i ] NEW_LINE count2 = 1 NEW_LINE DEDENT elif b [ i ] == max2 : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT DEDENT return round ( ( count1 * count2 ) / ( size1 * size2 ) , 6 ) NEW_LINE DEDENT a = [ 1 , 2 , 3 ] NEW_LINE b = [ 1 , 3 , 3 ] NEW_LINE size1 = len ( a ) NEW_LINE size2 = len ( b ) NEW_LINE print ( probability ( a , b , size1 , size2 ) ) NEW_LINE
def countDe ( arr , n ) : NEW_LINE INDENT i = 0 NEW_LINE v = arr . copy ( ) NEW_LINE arr . sort ( ) NEW_LINE count1 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != v [ i ] ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE count2 = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] != v [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return ( min ( count1 , count2 ) ) NEW_LINE DEDENT arr = [ 5 , 9 , 21 , 17 , 13 ] NEW_LINE n = 5 NEW_LINE print ( " Minimum ▁ Dearrangement ▁ = " , countDe ( arr , n ) ) NEW_LINE
def maxOfSegmentMins ( a , n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return min ( a ) NEW_LINE DEDENT if k == 2 : NEW_LINE INDENT return max ( a [ 0 ] , a [ n - 1 ] ) NEW_LINE DEDENT return max ( a ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 10 , - 9 , - 8 , 2 , 7 , - 6 , - 5 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE print ( maxOfSegmentMins ( a , n , k ) ) NEW_LINE DEDENT
def printMinimumProduct ( arr , n ) : NEW_LINE INDENT first_min = min ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE second_min = max ( arr [ 0 ] , arr [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] < first_min ) : NEW_LINE INDENT second_min = first_min NEW_LINE first_min = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < second_min ) : NEW_LINE INDENT second_min = arr [ i ] NEW_LINE DEDENT DEDENT return first_min * second_min NEW_LINE DEDENT a = [ 11 , 8 , 5 , 7 , 5 , 100 ] NEW_LINE n = len ( a ) NEW_LINE print ( printMinimumProduct ( a , n ) ) NEW_LINE
def noOfTriples ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == arr [ 2 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if arr [ 0 ] == arr [ 2 ] : NEW_LINE INDENT return ( count - 2 ) * ( count - 1 ) * ( count ) / 6 NEW_LINE DEDENT elif arr [ 1 ] == arr [ 2 ] : NEW_LINE INDENT return ( count - 1 ) * ( count ) / 2 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 1 , 3 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( noOfTriples ( arr , n ) ) NEW_LINE
def checkReverse ( arr , n ) : NEW_LINE INDENT temp = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ i ] = arr [ i ] NEW_LINE DEDENT temp . sort ( ) NEW_LINE for front in range ( n ) : NEW_LINE INDENT if temp [ front ] != arr [ front ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for back in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if temp [ back ] != arr [ back ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if front >= back : NEW_LINE INDENT return True NEW_LINE DEDENT while front != back : NEW_LINE INDENT front += 1 NEW_LINE if arr [ front - 1 ] < arr [ front ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 2 , 5 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if checkReverse ( arr , n ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math as mt NEW_LINE def checkReverse ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i - 1 ] < arr [ i ] : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT j = i NEW_LINE while ( j < n and arr [ j ] < arr [ j - 1 ] ) : NEW_LINE INDENT if ( i > 1 and arr [ j ] < arr [ i - 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT k = j NEW_LINE if ( arr [ k ] < arr [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( k > 1 and k < n ) : NEW_LINE INDENT if ( arr [ k ] < arr [ k - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 10 , 9 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE if checkReverse ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def MinOperation ( a , b , n ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE b . sort ( reverse = False ) NEW_LINE result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( a [ i ] > b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT elif ( a [ i ] < b [ i ] ) : NEW_LINE INDENT result = result + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 1 , 1 ] NEW_LINE b = [ 1 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( MinOperation ( a , b , n ) ) NEW_LINE DEDENT
def sortExceptUandL ( a , l , u , n ) : NEW_LINE INDENT b = [ 0 ] * ( n - ( u - l + 1 ) ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT b [ i ] = a [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT b [ l + ( i - ( u + 1 ) ) ] = a [ i ] NEW_LINE DEDENT b . sort ( ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT a [ i ] = b [ i ] NEW_LINE DEDENT for i in range ( u + 1 , n ) : NEW_LINE INDENT a [ i ] = b [ l + ( i - ( u + 1 ) ) ] NEW_LINE DEDENT DEDENT a = [ 5 , 4 , 3 , 12 , 14 , 9 ] NEW_LINE n = len ( a ) NEW_LINE l = 2 NEW_LINE u = 4 NEW_LINE sortExceptUandL ( a , l , u , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( " { } ▁ " . format ( a [ i ] ) , end = " " ) NEW_LINE DEDENT
def sortExcept ( arr , k , n ) : NEW_LINE INDENT arr [ k ] , arr [ - 1 ] = arr [ - 1 ] , arr [ k ] NEW_LINE arr = sorted ( arr , key = lambda i : ( i is arr [ - 1 ] , i ) ) NEW_LINE last = arr [ - 1 ] NEW_LINE i = n - 1 NEW_LINE while i > k : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ k ] = last NEW_LINE return arr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 4 , 11 , 7 , 6 , 20 ] NEW_LINE k = 2 NEW_LINE n = len ( a ) NEW_LINE a = sortExcept ( a , k , n ) NEW_LINE print ( " ▁ " . join ( list ( map ( str , a ) ) ) ) NEW_LINE DEDENT
def maxPartitions ( arr , n ) : NEW_LINE INDENT ans = 0 ; max_so_far = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT max_so_far = max ( max_so_far , arr [ i ] ) NEW_LINE if ( max_so_far == i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxPartitions ( arr , n ) ) NEW_LINE
def rankify ( A ) : NEW_LINE INDENT R = [ 0 for x in range ( len ( A ) ) ] NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT ( r , s ) = ( 1 , 1 ) NEW_LINE for j in range ( len ( A ) ) : NEW_LINE INDENT if j != i and A [ j ] < A [ i ] : NEW_LINE INDENT r += 1 NEW_LINE DEDENT if j != i and A [ j ] == A [ i ] : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT R [ i ] = r + ( s - 1 ) / 2 NEW_LINE DEDENT return R NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 5 , 2 , 1 , 25 , 2 ] NEW_LINE print ( A ) NEW_LINE print ( rankify ( A ) ) NEW_LINE DEDENT
def min_noOf_operation ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT noOfSubtraction = 0 NEW_LINE if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT noOfSubtraction = ( arr [ i ] - arr [ i - 1 ] ) / k ; NEW_LINE if ( ( arr [ i ] - arr [ i - 1 ] ) % k != 0 ) : NEW_LINE INDENT noOfSubtraction += 1 NEW_LINE DEDENT arr [ i ] = arr [ i ] - k * noOfSubtraction NEW_LINE DEDENT res = res + noOfSubtraction NEW_LINE DEDENT return int ( res ) NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( min_noOf_operation ( arr , N , k ) ) NEW_LINE
def maxSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] * i NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE
def countPairs ( a , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( a [ j ] - a [ i ] ) < k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT a = [ 1 , 10 , 4 , 2 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE print ( countPairs ( a , n , k ) , end = " " ) NEW_LINE
def countPairs ( a , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and a [ j ] - a [ i ] < k ) : NEW_LINE INDENT res += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT a = [ 1 , 10 , 4 , 2 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE print ( countPairs ( a , n , k ) , end = " " ) NEW_LINE
def sumOfMinAbsDifferences ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE sum = 0 NEW_LINE sum += abs ( arr [ 0 ] - arr [ 1 ] ) ; NEW_LINE sum += abs ( arr [ n - 1 ] - arr [ n - 2 ] ) ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT sum += min ( abs ( arr [ i ] - arr [ i - 1 ] ) , abs ( arr [ i ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT return sum ; NEW_LINE DEDENT arr = [ 5 , 10 , 1 , 4 , 8 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum ▁ = ▁ " , sumOfMinAbsDifferences ( arr , n ) ) NEW_LINE
import sys NEW_LINE def findSmallestDifference ( A , B , m , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE B . sort ( ) NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE result = sys . maxsize NEW_LINE while ( a < m and b < n ) : NEW_LINE INDENT if ( abs ( A [ a ] - B [ b ] ) < result ) : NEW_LINE INDENT result = abs ( A [ a ] - B [ b ] ) NEW_LINE DEDENT if ( A [ a ] < B [ b ] ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT A = [ 1 , 2 , 11 , 5 ] NEW_LINE B = [ 4 , 12 , 19 , 23 , 127 , 235 ] NEW_LINE m = len ( A ) NEW_LINE n = len ( B ) NEW_LINE print ( findSmallestDifference ( A , B , m , n ) ) NEW_LINE
def findLarger ( arr , n ) : NEW_LINE INDENT x = sorted ( arr ) NEW_LINE for i in range ( n / 2 , n ) : NEW_LINE INDENT print ( x [ i ] ) , NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 6 , 1 , 0 , 9 ] NEW_LINE n = len ( arr ) ; NEW_LINE findLarger ( arr , n ) NEW_LINE
def getMissingNo ( A ) : NEW_LINE INDENT n = len ( A ) NEW_LINE total = ( n + 1 ) * ( n + 2 ) / 2 NEW_LINE sum_of_A = sum ( A ) NEW_LINE return total - sum_of_A NEW_LINE DEDENT A = [ 1 , 2 , 4 , 5 , 6 ] NEW_LINE miss = getMissingNo ( A ) NEW_LINE print ( miss ) NEW_LINE
def countOccurrences ( arr , n , x ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if x == arr [ i ] : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( countOccurrences ( arr , n , x ) ) NEW_LINE
def binarySearch ( arr , l , r , x ) : NEW_LINE INDENT if ( r < l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = int ( l + ( r - l ) / 2 ) NEW_LINE if arr [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT if arr [ mid ] > x : NEW_LINE INDENT return binarySearch ( arr , l , mid - 1 , x ) NEW_LINE DEDENT return binarySearch ( arr , mid + 1 , r , x ) NEW_LINE DEDENT def countOccurrences ( arr , n , x ) : NEW_LINE INDENT ind = binarySearch ( arr , 0 , n - 1 , x ) NEW_LINE if ind == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 1 NEW_LINE left = ind - 1 NEW_LINE while ( left >= 0 and arr [ left ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE left -= 1 NEW_LINE DEDENT right = ind + 1 ; NEW_LINE while ( right < n and arr [ right ] == x ) : NEW_LINE INDENT count += 1 NEW_LINE right += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 2 , 2 , 3 , 4 , 7 , 8 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( countOccurrences ( arr , n , x ) ) NEW_LINE
MAX_VAL = 1000000000 NEW_LINE def printClosest ( arr , n , x ) : NEW_LINE INDENT res_l , res_r = 0 , 0 NEW_LINE l , r , diff = 0 , n - 1 , MAX_VAL NEW_LINE while r > l : NEW_LINE INDENT if abs ( arr [ l ] + arr [ r ] - x ) < diff : NEW_LINE INDENT res_l = l NEW_LINE res_r = r NEW_LINE diff = abs ( arr [ l ] + arr [ r ] - x ) NEW_LINE DEDENT if arr [ l ] + arr [ r ] > x : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT l += 1 NEW_LINE DEDENT DEDENT print ( ' The ▁ closest ▁ pair ▁ is ▁ { } ▁ and ▁ { } ' . format ( arr [ res_l ] , arr [ res_r ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 22 , 28 , 29 , 30 , 40 ] NEW_LINE n = len ( arr ) NEW_LINE x = 54 NEW_LINE printClosest ( arr , n , x ) NEW_LINE DEDENT
def countOnes ( arr , low , high ) : NEW_LINE INDENT if high >= low : NEW_LINE INDENT mid = low + ( high - low ) // 2 NEW_LINE if ( ( mid == high or arr [ mid + 1 ] == 0 ) and ( arr [ mid ] == 1 ) ) : NEW_LINE INDENT return mid + 1 NEW_LINE DEDENT if arr [ mid ] == 1 : NEW_LINE INDENT return countOnes ( arr , ( mid + 1 ) , high ) NEW_LINE DEDENT return countOnes ( arr , low , mid - 1 ) NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 1 , 1 , 1 , 0 , 0 , 0 ] NEW_LINE print ( " Count ▁ of ▁ 1 ' s ▁ in ▁ given ▁ array ▁ is " , countOnes ( arr , 0 , len ( arr ) - 1 ) ) NEW_LINE
def findMissingUtil ( arr1 , arr2 , N ) : NEW_LINE INDENT if N == 1 : NEW_LINE INDENT return arr1 [ 0 ] ; NEW_LINE DEDENT if arr1 [ 0 ] != arr2 [ 0 ] : NEW_LINE INDENT return arr1 [ 0 ] NEW_LINE DEDENT lo = 0 NEW_LINE hi = N - 1 NEW_LINE while ( lo < hi ) : NEW_LINE INDENT mid = ( lo + hi ) / 2 NEW_LINE if arr1 [ mid ] == arr2 [ mid ] : NEW_LINE INDENT lo = mid NEW_LINE DEDENT else : NEW_LINE INDENT hi = mid NEW_LINE DEDENT if lo == hi - 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return arr1 [ hi ] NEW_LINE DEDENT def findMissing ( arr1 , arr2 , M , N ) : NEW_LINE INDENT if N == M - 1 : NEW_LINE INDENT print ( " Missing ▁ Element ▁ is " , findMissingUtil ( arr1 , arr2 , M ) ) NEW_LINE DEDENT elif M == N - 1 : NEW_LINE INDENT print ( " Missing ▁ Element ▁ is " , findMissingUtil ( arr2 , arr1 , N ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE DEDENT DEDENT arr1 = [ 1 , 4 , 5 , 7 , 9 ] NEW_LINE arr2 = [ 4 , 5 , 7 , 9 ] NEW_LINE M = len ( arr1 ) NEW_LINE N = len ( arr2 ) NEW_LINE findMissing ( arr1 , arr2 , M , N ) NEW_LINE
def findMissing ( arr1 , arr2 , M , N ) : NEW_LINE INDENT if ( M != N - 1 and N != M - 1 ) : NEW_LINE INDENT print ( " Invalid ▁ Input " ) NEW_LINE return NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT res = res ^ arr1 [ i ] ; NEW_LINE DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT res = res ^ arr2 [ i ] NEW_LINE DEDENT print ( " Missing ▁ element ▁ is " , res ) NEW_LINE DEDENT arr1 = [ 4 , 1 , 5 , 9 , 7 ] NEW_LINE arr2 = [ 7 , 5 , 9 , 4 ] NEW_LINE M = len ( arr1 ) NEW_LINE N = len ( arr2 ) NEW_LINE findMissing ( arr1 , arr2 , M , N ) NEW_LINE
def printTwoElements ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT if arr [ abs ( arr [ i ] ) - 1 ] > 0 : NEW_LINE INDENT arr [ abs ( arr [ i ] ) - 1 ] = - arr [ abs ( arr [ i ] ) - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ repeating ▁ element ▁ is " , abs ( arr [ i ] ) ) NEW_LINE DEDENT DEDENT for i in range ( size ) : NEW_LINE INDENT if arr [ i ] > 0 : NEW_LINE INDENT print ( " and ▁ the ▁ missing ▁ element ▁ is " , i + 1 ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 7 , 3 , 4 , 5 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE printTwoElements ( arr , n ) NEW_LINE
def getTwoElements ( arr , n ) : NEW_LINE INDENT global x , y NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE xor1 = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT xor1 = xor1 ^ arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT xor1 = xor1 ^ i NEW_LINE DEDENT set_bit_no = xor1 & ~ ( xor1 - 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) != 0 : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i & set_bit_no ) != 0 : NEW_LINE INDENT x = x ^ i NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ i NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 3 , 4 , 5 , 5 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE getTwoElements ( arr , n ) NEW_LINE print ( " The ▁ missing ▁ element ▁ is " , x , " and ▁ the ▁ repeating ▁ number ▁ is " , y ) NEW_LINE
def findFourElements ( A , n , X ) : NEW_LINE INDENT for i in range ( 0 , n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if A [ i ] + A [ j ] + A [ k ] + A [ l ] == X : NEW_LINE INDENT print ( " % d , ▁ % d , ▁ % d , ▁ % d " % ( A [ i ] , A [ j ] , A [ k ] , A [ l ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT A = [ 10 , 2 , 3 , 4 , 5 , 9 , 7 , 8 ] NEW_LINE n = len ( A ) NEW_LINE X = 23 NEW_LINE findFourElements ( A , n , X ) NEW_LINE
def search ( arr , n , x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i + abs ( arr [ i ] - x ) NEW_LINE DEDENT print ( " number ▁ is ▁ not ▁ present ! " ) NEW_LINE return - 1 NEW_LINE DEDENT arr = [ 8 , 7 , 6 , 7 , 6 , 5 , 4 , 3 , 2 , 3 , 4 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( " Element " , x , " ▁ is ▁ present ▁ at ▁ index ▁ " , search ( arr , n , 3 ) ) NEW_LINE
import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT first = arr [ i ] NEW_LINE DEDENT DEDENT second = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > second and arr [ i ] < first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT third = - sys . maxsize NEW_LINE for i in range ( 0 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > third and arr [ i ] < second ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ Third ▁ Largest " , " element ▁ is " , third ) NEW_LINE DEDENT arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE
import sys NEW_LINE def thirdLargest ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 3 ) : NEW_LINE INDENT print ( " ▁ Invalid ▁ Input ▁ " ) NEW_LINE return NEW_LINE DEDENT first = arr [ 0 ] NEW_LINE second = - sys . maxsize NEW_LINE third = - sys . maxsize NEW_LINE for i in range ( 1 , arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT third = second NEW_LINE second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second ) : NEW_LINE INDENT third = second NEW_LINE second = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > third ) : NEW_LINE INDENT third = arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ third ▁ Largest " , " element ▁ is " , third ) NEW_LINE DEDENT arr = [ 12 , 13 , 1 , 10 , 34 , 16 ] NEW_LINE n = len ( arr ) NEW_LINE thirdLargest ( arr , n ) NEW_LINE
def checkPair ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if sum % 2 != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT sum = sum / 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = sum - arr [ i ] NEW_LINE if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT if val in s : NEW_LINE INDENT print ( " Pair ▁ elements ▁ are " , arr [ i ] , " and " , int ( val ) ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 2 , 11 , 5 , 1 , 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if checkPair ( arr , n ) == False : NEW_LINE INDENT print ( " No ▁ pair ▁ found " ) NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT if ( arr [ n - 1 ] == x ) : NEW_LINE INDENT return " Found " NEW_LINE DEDENT backup = arr [ n - 1 ] NEW_LINE arr [ n - 1 ] = x NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT arr [ n - 1 ] = backup NEW_LINE if ( i < n - 1 ) : NEW_LINE INDENT return " Found " NEW_LINE DEDENT return " Not ▁ Found " NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT arr = [ 4 , 6 , 1 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE x = 1 NEW_LINE print ( search ( arr , n , x ) ) NEW_LINE
def findMajority ( arr , n ) : NEW_LINE INDENT return arr [ int ( n / 2 ) ] NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMajority ( arr , n ) ) NEW_LINE
def minAdjDifference ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : return NEW_LINE res = abs ( arr [ 1 ] - arr [ 0 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT res = min ( res , abs ( arr [ i ] - arr [ i - 1 ] ) ) NEW_LINE DEDENT res = min ( res , abs ( arr [ n - 1 ] - arr [ 0 ] ) ) NEW_LINE print ( " Min ▁ Difference ▁ = ▁ " , res ) NEW_LINE DEDENT a = [ 10 , 12 , 13 , 15 , 10 ] NEW_LINE n = len ( a ) NEW_LINE minAdjDifference ( a , n ) NEW_LINE
MAX = 100000 NEW_LINE def Print3Smallest ( arr , n ) : NEW_LINE INDENT firstmin = MAX NEW_LINE secmin = MAX NEW_LINE thirdmin = MAX NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] < firstmin : NEW_LINE INDENT thirdmin = secmin NEW_LINE secmin = firstmin NEW_LINE firstmin = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < secmin : NEW_LINE INDENT thirdmin = secmin NEW_LINE secmin = arr [ i ] NEW_LINE DEDENT elif arr [ i ] < thirdmin : NEW_LINE INDENT thirdmin = arr [ i ] NEW_LINE DEDENT DEDENT print ( " First ▁ min ▁ = ▁ " , firstmin ) NEW_LINE print ( " Second ▁ min ▁ = ▁ " , secmin ) NEW_LINE print ( " Third ▁ min ▁ = ▁ " , thirdmin ) NEW_LINE DEDENT arr = [ 4 , 9 , 1 , 32 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE Print3Smallest ( arr , n ) NEW_LINE
def getMin ( arr , n ) : NEW_LINE INDENT return min ( arr ) NEW_LINE DEDENT def getMax ( arr , n ) : NEW_LINE INDENT return max ( arr ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 1234 , 45 , 67 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ element ▁ of ▁ array : ▁ " , getMin ( arr , n ) ) NEW_LINE print ( " Maximum ▁ element ▁ of ▁ array : ▁ " , getMax ( arr , n ) ) NEW_LINE DEDENT
def printfrequency ( arr , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ j ] = arr [ j ] - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ arr [ i ] % n ] = arr [ arr [ i ] % n ] + n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( i + 1 , " - > " , arr [ i ] // n ) NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 3 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printfrequency ( arr , n ) NEW_LINE
def getInvCount ( arr , n ) : NEW_LINE INDENT invcount = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT small = 0 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT small += 1 NEW_LINE DEDENT DEDENT great = 0 ; NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT great += 1 NEW_LINE DEDENT DEDENT invcount += great * small NEW_LINE DEDENT return invcount NEW_LINE DEDENT arr = [ 8 , 4 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Inversion ▁ Count ▁ : " , getInvCount ( arr , n ) ) NEW_LINE
def findWater ( arr , n ) : NEW_LINE INDENT left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE water = 0 NEW_LINE left [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT left [ i ] = max ( left [ i - 1 ] , arr [ i ] ) NEW_LINE DEDENT right [ n - 1 ] = arr [ n - 1 ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT right [ i ] = max ( right [ i + 1 ] , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT water += min ( left [ i ] , right [ i ] ) - arr [ i ] NEW_LINE DEDENT return water NEW_LINE DEDENT arr = [ 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ water ▁ that ▁ can ▁ be ▁ accumulated ▁ is " , findWater ( arr , n ) ) NEW_LINE
def findWater ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE left_max = 0 NEW_LINE right_max = 0 NEW_LINE lo = 0 NEW_LINE hi = n - 1 NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT if ( arr [ lo ] < arr [ hi ] ) : NEW_LINE INDENT if ( arr [ lo ] > left_max ) : NEW_LINE INDENT left_max = arr [ lo ] NEW_LINE DEDENT else : NEW_LINE INDENT result += left_max - arr [ lo ] NEW_LINE DEDENT lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( arr [ hi ] > right_max ) : NEW_LINE INDENT right_max = arr [ hi ] NEW_LINE DEDENT else : NEW_LINE INDENT result += right_max - arr [ hi ] NEW_LINE DEDENT hi -= 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT arr = [ 0 , 1 , 0 , 2 , 1 , 0 , 1 , 3 , 2 , 1 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ water ▁ that ▁ can ▁ be ▁ accumulated ▁ is ▁ " , findWater ( arr , n ) ) NEW_LINE
median = 0 NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE def maximum ( a , b ) : NEW_LINE INDENT return a if a > b else b NEW_LINE DEDENT def minimum ( a , b ) : NEW_LINE INDENT return a if a < b else b NEW_LINE DEDENT def findMedianSortedArrays ( a , n , b , m ) : NEW_LINE INDENT global median , i , j NEW_LINE min_index = 0 NEW_LINE max_index = n NEW_LINE while ( min_index <= max_index ) : NEW_LINE INDENT i = int ( ( min_index + max_index ) / 2 ) NEW_LINE j = int ( ( ( n + m + 1 ) / 2 ) - i ) NEW_LINE if ( i < n and j > 0 and b [ j - 1 ] > a [ i ] ) : NEW_LINE INDENT min_index = i + 1 NEW_LINE DEDENT elif ( i > 0 and j < m and b [ j ] < a [ i - 1 ] ) : NEW_LINE INDENT max_index = i - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT median = b [ j - 1 ] NEW_LINE DEDENT elif ( j == 0 ) : NEW_LINE INDENT median = a [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT median = maximum ( a [ i - 1 ] , b [ j - 1 ] ) NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT if ( ( n + m ) % 2 == 1 ) : NEW_LINE INDENT return median NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return ( ( median + b [ j ] ) / 2.0 ) NEW_LINE DEDENT if ( j == m ) : NEW_LINE INDENT return ( ( median + a [ i ] ) / 2.0 ) NEW_LINE DEDENT return ( ( median + minimum ( a [ i ] , b [ j ] ) ) / 2.0 ) NEW_LINE DEDENT a = [ 900 ] NEW_LINE b = [ 10 , 13 , 14 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE if ( n < m ) : NEW_LINE INDENT print ( " The ▁ median ▁ is ▁ : ▁ { } " . format ( findMedianSortedArrays ( a , n , b , m ) ) ) NEW_LINE DEDENT else : NEW_LINE INDENT echo ( " The ▁ median ▁ is ▁ : ▁ { } " . format ( findMedianSortedArrays ( b , m , a , n ) ) ) NEW_LINE DEDENT
def printUncommon ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( i < n1 and j < n2 ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT print ( arr1 [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT elif ( arr2 [ j ] < arr1 [ i ] ) : NEW_LINE INDENT print ( arr2 [ j ] , end = " ▁ " ) NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT while ( i < n1 ) : NEW_LINE INDENT print ( arr1 [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( j < n2 ) : NEW_LINE INDENT print ( arr2 [ j ] , end = " ▁ " ) NEW_LINE j = j + 1 NEW_LINE k = k + 1 NEW_LINE DEDENT DEDENT arr1 = [ 10 , 20 , 30 ] NEW_LINE arr2 = [ 20 , 25 , 30 , 40 , 50 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE n2 = len ( arr2 ) NEW_LINE printUncommon ( arr1 , arr2 , n1 , n2 ) NEW_LINE
def leastFrequent ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE min_count = n + 1 NEW_LINE res = - 1 NEW_LINE curr_count = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT curr_count = curr_count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( curr_count < min_count ) : NEW_LINE INDENT min_count = curr_count NEW_LINE res = arr [ i - 1 ] NEW_LINE DEDENT curr_count = 1 NEW_LINE DEDENT DEDENT if ( curr_count < min_count ) : NEW_LINE INDENT min_count = curr_count NEW_LINE res = arr [ n - 1 ] NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 3 , 2 , 1 , 2 , 2 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( leastFrequent ( arr , n ) ) NEW_LINE
M = 4 ; NEW_LINE def maximumSum ( a , n ) : NEW_LINE INDENT global M ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a [ i ] . sort ( ) ; NEW_LINE DEDENT sum = a [ n - 1 ] [ M - 1 ] ; NEW_LINE prev = a [ n - 1 ] [ M - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( M - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] [ j ] < prev ) : NEW_LINE INDENT prev = a [ i ] [ j ] ; NEW_LINE sum += prev ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( j == - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT arr = [ [ 1 , 7 , 3 , 4 ] , [ 4 , 2 , 5 , 1 ] , [ 9 , 5 , 1 , 8 ] ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maximumSum ( arr , n ) ) ; NEW_LINE
import math NEW_LINE def countPairs ( A , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE A . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = 0 NEW_LINE while ( ( A [ i ] * math . pow ( k , x ) ) <= A [ j ] ) : NEW_LINE INDENT if ( ( A [ i ] * math . pow ( k , x ) ) == A [ j ] ) : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT A = [ 3 , 8 , 9 , 12 , 18 , 4 , 24 , 2 , 6 ] NEW_LINE n = len ( A ) NEW_LINE k = 3 NEW_LINE print ( countPairs ( A , n , k ) ) NEW_LINE
def minDistance ( arr , n ) : NEW_LINE INDENT maximum_element = arr [ 0 ] NEW_LINE min_dis = n NEW_LINE index = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( maximum_element == arr [ i ] ) : NEW_LINE INDENT min_dis = min ( min_dis , ( i - index ) ) NEW_LINE index = i NEW_LINE DEDENT elif ( maximum_element < arr [ i ] ) : NEW_LINE INDENT maximum_element = arr [ i ] NEW_LINE min_dis = n NEW_LINE index = i NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT return min_dis NEW_LINE DEDENT arr = [ 6 , 3 , 1 , 3 , 6 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ distance ▁ = " , minDistance ( arr , n ) ) NEW_LINE
def findValue ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == k ) : NEW_LINE INDENT k = k * 2 NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 10 , 8 , 1 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( findValue ( arr , n , k ) ) NEW_LINE
def dupLastIndex ( arr , n ) : NEW_LINE INDENT if ( arr == None or n <= 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT print ( " Last ▁ index : " , i ,   " Last " , ▁ " duplicate item : " , arr [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " no ▁ duplicate ▁ found " ) NEW_LINE DEDENT arr = [ 1 , 5 , 5 , 6 , 6 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE dupLastIndex ( arr , n ) NEW_LINE
def findSmallest ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( a [ j ] % a [ i ] ) >= 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == n - 1 ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT a = [ 25 , 20 , 5 , 10 , 100 ] NEW_LINE n = len ( a ) NEW_LINE print ( findSmallest ( a , n ) ) NEW_LINE
def min_element ( a ) : NEW_LINE INDENT m = 10000000 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT if ( a [ i ] < m ) : NEW_LINE INDENT m = a [ i ] NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT def findSmallest ( a , n ) : NEW_LINE INDENT smallest = min_element ( a ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] % smallest >= 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return smallest NEW_LINE DEDENT a = [ 25 , 20 , 5 , 10 , 100 ] NEW_LINE n = len ( a ) NEW_LINE print ( findSmallest ( a , n ) ) NEW_LINE
def findIndex ( arr ) : NEW_LINE INDENT maxIndex = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > arr [ maxIndex ] ) : NEW_LINE INDENT maxIndex = i NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT if ( maxIndex != i and arr [ maxIndex ] < ( 2 * arr [ i ] ) ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return maxIndex NEW_LINE DEDENT arr = [ 3 , 6 , 1 , 0 ] NEW_LINE print ( findIndex ( arr ) ) NEW_LINE
import math NEW_LINE def find_consecutive_steps ( arr , len ) : NEW_LINE INDENT count = 0 ; maximum = 0 NEW_LINE for index in range ( 1 , len ) : NEW_LINE INDENT if ( arr [ index ] > arr [ index - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT maximum = max ( maximum , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max ( maximum , count ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE len = len ( arr ) NEW_LINE print ( find_consecutive_steps ( arr , len ) ) NEW_LINE
def CalculateMax ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE min_sum = arr [ 0 ] + arr [ 1 ] NEW_LINE max_sum = arr [ n - 1 ] + arr [ n - 2 ] NEW_LINE return abs ( max_sum - min_sum ) NEW_LINE DEDENT arr = [ 6 , 7 , 1 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CalculateMax ( arr , n ) ) NEW_LINE
def calculate ( a , n ) : NEW_LINE INDENT a . sort ( ) ; NEW_LINE s = [ ] ; NEW_LINE i = 0 ; NEW_LINE j = n - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT s . append ( ( a [ i ] + a [ j ] ) ) ; NEW_LINE i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT mini = min ( s ) ; NEW_LINE maxi = max ( s ) ; NEW_LINE return abs ( maxi - mini ) ; NEW_LINE DEDENT a = [ 2 , 6 , 4 , 3 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( calculate ( a , n ) ) ; NEW_LINE
def printMinDiffPairs ( arr , n ) : NEW_LINE INDENT if n <= 1 : return NEW_LINE arr . sort ( ) NEW_LINE minDiff = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT minDiff = min ( minDiff , arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] ) == minDiff : NEW_LINE INDENT print ( " ( " + str ( arr [ i - 1 ] ) + " , ▁ " + str ( arr [ i ] ) + " ) , ▁ " , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 5 , 3 , 2 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printMinDiffPairs ( arr , n ) NEW_LINE
def calculateDiff ( i , j , arr ) : NEW_LINE INDENT return abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) NEW_LINE DEDENT def maxDistance ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( calculateDiff ( i , j , arr ) > result ) : NEW_LINE INDENT result = calculateDiff ( i , j , arr ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT arr = [ - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxDistance ( arr , n ) ) NEW_LINE
def maxDistance ( array ) : NEW_LINE INDENT max1 = - 2147483648 NEW_LINE min1 = + 2147483647 NEW_LINE max2 = - 2147483648 NEW_LINE min2 = + 2147483647 NEW_LINE for i in range ( len ( array ) ) : NEW_LINE INDENT max1 = max ( max1 , array [ i ] + i ) NEW_LINE min1 = min ( min1 , array [ i ] + i ) NEW_LINE max2 = max ( max2 , array [ i ] - i ) NEW_LINE min2 = min ( min2 , array [ i ] - i ) NEW_LINE DEDENT return max ( max1 - min1 , max2 - min2 ) NEW_LINE DEDENT array = [ - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 ] NEW_LINE print ( maxDistance ( array ) ) NEW_LINE
def extrema ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT count += ( a [ i ] > a [ i - 1 ] and a [ i ] > a [ i + 1 ] ) ; NEW_LINE count += ( a [ i ] < a [ i - 1 ] and a [ i ] < a [ i + 1 ] ) ; NEW_LINE DEDENT return count NEW_LINE DEDENT a = [ 1 , 0 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( extrema ( a , n ) ) NEW_LINE
def findClosest ( arr , n , target ) : NEW_LINE INDENT if ( target <= arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] NEW_LINE DEDENT if ( target >= arr [ n - 1 ] ) : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT i = 0 ; j = n ; mid = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT mid = ( i + j ) // 2 NEW_LINE if ( arr [ mid ] == target ) : NEW_LINE INDENT return arr [ mid ] NEW_LINE DEDENT if ( target < arr [ mid ] ) : NEW_LINE INDENT if ( mid > 0 and target > arr [ mid - 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid - 1 ] , arr [ mid ] , target ) NEW_LINE DEDENT j = mid NEW_LINE DEDENT else : NEW_LINE INDENT if ( mid < n - 1 and target < arr [ mid + 1 ] ) : NEW_LINE INDENT return getClosest ( arr [ mid ] , arr [ mid + 1 ] , target ) NEW_LINE DEDENT i = mid + 1 NEW_LINE DEDENT DEDENT return arr [ mid ] NEW_LINE DEDENT def getClosest ( val1 , val2 , target ) : NEW_LINE INDENT if ( target - val1 >= val2 - target ) : NEW_LINE INDENT return val2 NEW_LINE DEDENT else : NEW_LINE INDENT return val1 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 5 , 6 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE target = 11 NEW_LINE print ( findClosest ( arr , n , target ) ) NEW_LINE
def _sum ( a , n ) : NEW_LINE INDENT maxSum = - 9999999 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT maxSum = max ( maxSum , a [ i ] + a [ j ] ) NEW_LINE DEDENT DEDENT c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ i ] + a [ j ] == maxSum : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT DEDENT return c NEW_LINE DEDENT array = [ 1 , 1 , 1 , 2 , 2 , 2 ] NEW_LINE n = len ( array ) NEW_LINE print ( _sum ( array , n ) ) NEW_LINE
import sys NEW_LINE def sum ( a , n ) : NEW_LINE INDENT maxVal = a [ 0 ] ; maxCount = 1 NEW_LINE secondMax = sys . maxsize NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] == maxVal ) : NEW_LINE INDENT maxCount += 1 NEW_LINE DEDENT elif ( a [ i ] > maxVal ) : NEW_LINE INDENT secondMax = maxVal NEW_LINE secondMaxCount = maxCount NEW_LINE maxVal = a [ i ] NEW_LINE maxCount = 1 NEW_LINE DEDENT elif ( a [ i ] == secondMax ) : NEW_LINE INDENT secondMax = a [ i ] NEW_LINE secondMaxCount += 1 NEW_LINE DEDENT elif ( a [ i ] > secondMax ) : NEW_LINE INDENT secondMax = a [ i ] NEW_LINE secondMaxCount = 1 NEW_LINE DEDENT DEDENT if ( maxCount > 1 ) : NEW_LINE INDENT return maxCount * ( maxCount - 1 ) / 2 NEW_LINE DEDENT return secondMaxCount NEW_LINE DEDENT array = [ 1 , 1 , 1 , 2 , 2 , 2 , 3 ] NEW_LINE n = len ( array ) NEW_LINE print ( sum ( array , n ) ) NEW_LINE
def printKMissing ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n and arr [ i ] <= 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT count = 0 NEW_LINE curr = 1 NEW_LINE while ( count < k and i < n ) : NEW_LINE INDENT if ( arr [ i ] != curr ) : NEW_LINE INDENT print ( str ( curr ) + " ▁ " , end = ' ' ) NEW_LINE count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT curr = curr + 1 NEW_LINE DEDENT while ( count < k ) : NEW_LINE INDENT print ( str ( curr ) + " ▁ " , end = ' ' ) NEW_LINE curr = curr + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT DEDENT arr = [ 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE printKMissing ( arr , n , k ) ; NEW_LINE
def nobleInteger ( arr , size ) : NEW_LINE INDENT for i in range ( 0 , size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , size ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == arr [ i ] ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 3 , 20 , 40 , 2 ] NEW_LINE size = len ( arr ) NEW_LINE res = nobleInteger ( arr , size ) NEW_LINE if ( res != - 1 ) : NEW_LINE INDENT print ( " The ▁ noble ▁ integer ▁ is ▁ " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Noble ▁ Integer ▁ Found " ) NEW_LINE DEDENT
def nobleInteger ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE n = len ( arr ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if arr [ i ] == arr [ i + 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT if arr [ i ] == n - i - 1 : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT if arr [ n - 1 ] == 0 : NEW_LINE INDENT return arr [ n - 1 ] NEW_LINE DEDENT return - 1 NEW_LINE DEDENT arr = [ 10 , 3 , 20 , 40 , 2 ] NEW_LINE res = nobleInteger ( arr ) NEW_LINE if res != - 1 : NEW_LINE INDENT print ( " The ▁ noble ▁ integer ▁ is " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ Noble ▁ Integer ▁ Found " ) NEW_LINE DEDENT
def findMinSum ( a , b , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + abs ( a [ i ] - b [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT a = [ 4 , 1 , 8 , 7 ] NEW_LINE b = [ 2 , 3 , 6 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMinSum ( a , b , n ) ) NEW_LINE
def minProductSubset ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = float ( ' - inf ' ) NEW_LINE min_pos = float ( ' inf ' ) NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT count_zero = count_zero + 1 NEW_LINE continue NEW_LINE DEDENT if ( a [ i ] < 0 ) : NEW_LINE INDENT count_neg = count_neg + 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT min_pos = min ( min_pos , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if ( count_zero == n or ( count_neg == 0 and count_zero > 0 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( count_neg == 0 ) : NEW_LINE INDENT return min_pos NEW_LINE DEDENT if ( ( count_neg & 1 ) == 0 and count_neg != 0 ) : NEW_LINE INDENT prod = int ( prod / max_neg ) NEW_LINE DEDENT return prod NEW_LINE DEDENT a = [ - 1 , - 1 , - 2 , 4 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( minProductSubset ( a , n ) ) NEW_LINE
def binary_search ( a , x , lo = 0 , hi = None ) : NEW_LINE INDENT if hi is None : NEW_LINE INDENT hi = len ( a ) NEW_LINE DEDENT while lo < hi : NEW_LINE INDENT mid = ( lo + hi ) // 2 NEW_LINE midval = a [ mid ] NEW_LINE if midval < x : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT elif midval > x : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT return mid NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def findElement ( a , n , b ) : NEW_LINE INDENT a . sort ( ) NEW_LINE mx = a [ n - 1 ] NEW_LINE while ( b < max ) : NEW_LINE INDENT if ( binary_search ( a , b , 0 , n ) != - 1 ) : NEW_LINE INDENT b *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE b = 1 NEW_LINE print findElement ( a , n , b ) NEW_LINE
Mod = 1000000007 NEW_LINE def findSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = 0 NEW_LINE while i < n and arr [ i ] < 0 : NEW_LINE INDENT if i != n - 1 and arr [ i + 1 ] <= 0 : NEW_LINE INDENT sum = ( sum + ( arr [ i ] * arr [ i + 1 ] ) % Mod ) % Mod NEW_LINE i += 2 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT j = n - 1 NEW_LINE while j >= 0 and arr [ j ] > 0 : NEW_LINE INDENT if j != 0 and arr [ j - 1 ] > 0 : NEW_LINE INDENT sum = ( sum + ( arr [ j ] * arr [ j - 1 ] ) % Mod ) % Mod NEW_LINE j -= 2 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j > i : NEW_LINE INDENT sum = ( sum + ( arr [ i ] * arr [ j ] ) % Mod ) % Mod NEW_LINE DEDENT elif i == j : NEW_LINE INDENT sum = ( sum + arr [ i ] ) % Mod NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ - 1 , 9 , 4 , 5 , - 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE
def countOddRotations ( n ) : NEW_LINE INDENT odd_count = 0 ; even_count = 0 NEW_LINE while n != 0 : NEW_LINE INDENT digit = n % 10 NEW_LINE if digit % 2 == 0 : NEW_LINE INDENT odd_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even_count += 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT print ( " Odd ▁ = " , odd_count ) NEW_LINE print ( " Even ▁ = " , even_count ) NEW_LINE DEDENT n = 1234 NEW_LINE countOddRotations ( n ) NEW_LINE
def numberofDigits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def cal ( num ) : NEW_LINE INDENT digit = numberofDigits ( num ) NEW_LINE powTen = pow ( 10 , digit - 1 ) NEW_LINE for i in range ( digit - 1 ) : NEW_LINE INDENT firstDigit = num // powTen NEW_LINE left = ( num * 10 + firstDigit - ( firstDigit * powTen * 10 ) ) NEW_LINE print ( left , end = " ▁ " ) NEW_LINE num = left NEW_LINE DEDENT DEDENT num = 1445 NEW_LINE cal ( num ) NEW_LINE
def CheckKCycles ( n , s ) : NEW_LINE INDENT ff = True NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT x = int ( s [ i : ] + s [ 0 : i ] ) NEW_LINE if ( x >= int ( s ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT ff = False NEW_LINE break NEW_LINE DEDENT if ( ff ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE s = "123" NEW_LINE CheckKCycles ( n , s ) NEW_LINE
from math import log10 NEW_LINE def rightRotationDivisor ( N ) : NEW_LINE INDENT lastDigit = N % 10 NEW_LINE rightRotation = ( lastDigit * 10 ** int ( log10 ( N ) ) + N // 10 ) NEW_LINE return rightRotation % N == 0 NEW_LINE DEDENT def generateNumbers ( m ) : NEW_LINE INDENT for i in range ( 10 ** ( m - 1 ) , 10 ** m ) : NEW_LINE INDENT if rightRotationDivisor ( i ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT m = 3 NEW_LINE generateNumbers ( m ) NEW_LINE
import sys NEW_LINE def checkIfSortRotated ( arr , n ) : NEW_LINE INDENT minEle = sys . maxsize NEW_LINE maxEle = - sys . maxsize - 1 NEW_LINE minIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < minEle : NEW_LINE INDENT minEle = arr [ i ] NEW_LINE minIndex = i NEW_LINE DEDENT DEDENT flag1 = 1 NEW_LINE for i in range ( 1 , minIndex ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag1 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT flag2 = 2 NEW_LINE for i in range ( minIndex + 1 , n ) : NEW_LINE INDENT if arr [ i ] < arr [ i - 1 ] : NEW_LINE INDENT flag2 = 0 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag1 and flag2 and arr [ n - 1 ] < arr [ 0 ] ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT arr = [ 3 , 4 , 5 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE checkIfSortRotated ( arr , n ) NEW_LINE
def occurredOnce ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE if arr [ 0 ] != arr [ 1 ] : NEW_LINE INDENT print ( arr [ 0 ] , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] != arr [ i + 1 ] and arr [ i ] != arr [ i - 1 ] ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if arr [ n - 2 ] != arr [ n - 1 ] : NEW_LINE INDENT print ( arr [ n - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE occurredOnce ( arr , n ) NEW_LINE DEDENT
def occurredOnce ( arr , n ) : NEW_LINE INDENT i = 1 NEW_LINE len = n NEW_LINE if arr [ 0 ] == arr [ len - 1 ] : NEW_LINE INDENT i = 2 NEW_LINE len -= 1 NEW_LINE DEDENT while i < n : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT print ( arr [ i - 1 ] , end = " ▁ " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( arr [ n - 1 ] != arr [ 0 ] and arr [ n - 1 ] != arr [ n - 2 ] ) : NEW_LINE INDENT print ( arr [ n - 1 ] ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 7 , 7 , 8 , 8 , 9 , 1 , 1 , 4 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE occurredOnce ( arr , n ) NEW_LINE DEDENT
def rvereseArray ( arr , start , end ) : NEW_LINE INDENT while start < end : NEW_LINE INDENT temp = arr [ start ] NEW_LINE arr [ start ] = arr [ end ] NEW_LINE arr [ end ] = temp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def splitArr ( arr , k , n ) : NEW_LINE INDENT rvereseArray ( arr , 0 , n - 1 ) NEW_LINE rvereseArray ( arr , 0 , n - k - 1 ) NEW_LINE rvereseArray ( arr , n - k , n - 1 ) NEW_LINE DEDENT arr = [ 12 , 10 , 5 , 6 , 52 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE splitArr ( arr , k , n ) NEW_LINE printArray ( arr , n ) NEW_LINE
def countRotationsDivBy8 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE count = 0 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = int ( n [ 0 ] ) NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( l == 2 ) : NEW_LINE INDENT first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) NEW_LINE second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT threeDigit = 0 NEW_LINE for i in range ( 0 , ( l - 2 ) ) : NEW_LINE INDENT threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = "43262488612" NEW_LINE print ( " Rotations : " , countRotationsDivBy8 ( n ) ) NEW_LINE DEDENT
def isRotation ( x , y ) : NEW_LINE INDENT x64 = x | ( x << 32 ) NEW_LINE while ( x64 >= y ) : NEW_LINE INDENT if ( ( x64 ) == y ) : NEW_LINE INDENT return True NEW_LINE DEDENT x64 >>= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 122 NEW_LINE y = 2147483678 NEW_LINE if ( isRotation ( x , y ) == False ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT DEDENT
def countRotations ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = ( int ) ( n [ 0 ] ) NEW_LINE if ( oneDigit % 4 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT twoDigit = ( int ) ( n [ i ] ) * 10 + ( int ) ( n [ i + 1 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT twoDigit = ( int ) ( n [ l - 1 ] ) * 10 + ( int ) ( n [ 0 ] ) NEW_LINE if ( twoDigit % 4 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = "4834" NEW_LINE print ( " Rotations : ▁ " , countRotations ( n ) ) NEW_LINE
def maxLength ( a , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE return n NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT Len = max ( Len , max ( n - i - 1 , i ) ) NEW_LINE DEDENT DEDENT return Len NEW_LINE DEDENT a = [ 1 , 2 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( maxLength ( a , n ) ) NEW_LINE
def solve ( n ) : NEW_LINE INDENT initial_array = [ [ 0 for i in range ( n - 1 ) ] for j in range ( n - 1 ) ] NEW_LINE final_array = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT initial_array [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT initial_array [ i ] [ j ] = initial_array [ i - 1 ] [ ( j + 1 ) % ( n - 1 ) ] NEW_LINE DEDENT DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( n - 1 ) : NEW_LINE INDENT final_array [ i ] [ j ] = initial_array [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT final_array [ i ] [ n - 1 ] = final_array [ n - 1 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT t0 = final_array [ i ] [ i ] NEW_LINE t1 = final_array [ i ] [ n - 1 ] NEW_LINE temp = final_array [ i ] [ i ] NEW_LINE final_array [ i ] [ i ] = final_array [ i ] [ n - 1 ] NEW_LINE final_array [ i ] [ n - 1 ] = temp NEW_LINE final_array [ n - 1 ] [ i ] = t0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( final_array [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " , end ▁ = ▁ " " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE solve ( n ) NEW_LINE DEDENT
def getMinVal ( p , q ) : NEW_LINE INDENT if q % p == 0 : NEW_LINE INDENT return p NEW_LINE DEDENT return - 1 NEW_LINE DEDENT p = 24 ; q = 48 NEW_LINE print ( getMinVal ( p , q ) ) NEW_LINE
import math as mt NEW_LINE def isPalindrome ( str1 , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( str1 [ i ] != str1 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def countPrimePalindrome ( str1 , Len ) : NEW_LINE INDENT prime = [ True for i in range ( Len + 1 ) ] NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( Len + 1 ) ) ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , Len + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for j in range ( 2 , Len + 1 ) : NEW_LINE INDENT if ( prime [ j ] ) : NEW_LINE INDENT for i in range ( Len + 1 - j ) : NEW_LINE INDENT if ( isPalindrome ( str1 , i , i + j - 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE Len = len ( s ) NEW_LINE print ( countPrimePalindrome ( s , Len ) ) NEW_LINE
from math import log2 , ceil NEW_LINE def minOperations ( N ) : NEW_LINE INDENT x = log2 ( N ) NEW_LINE ans = ceil ( x ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( minOperations ( N ) ) NEW_LINE DEDENT
def find_greatest_divisor ( l , r ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT return l ; NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT l = 2 ; NEW_LINE r = 12 ; NEW_LINE print ( find_greatest_divisor ( l , r ) ) ; NEW_LINE
def getProbability ( p , q ) : NEW_LINE INDENT p /= 100 NEW_LINE q /= 100 NEW_LINE probability = ( p * p + q * q ) / ( p + q ) NEW_LINE return probability NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT p = 80 NEW_LINE q = 40 NEW_LINE print ( getProbability ( p , q ) ) NEW_LINE DEDENT
def check ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] & 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 9 , 12 , 13 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE if check ( arr , n ) : NEW_LINE INDENT print ( " Odd ▁ Bit - wise ▁ OR " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even ▁ Bit - wise ▁ OR " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def _log ( x , base ) : NEW_LINE INDENT return ( int ) ( math . log ( x ) / math . log ( base ) ) NEW_LINE DEDENT def recursiveLogStar ( n , b ) : NEW_LINE INDENT if ( n > 1.0 ) : NEW_LINE INDENT return 1.0 + recursiveLogStar ( _log ( n , b ) , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 100 NEW_LINE base = 5 NEW_LINE print ( " Log * ( " , n , " ) ▁ = ▁ " , recursiveLogStar ( n , base ) ) NEW_LINE DEDENT
def isPossible ( box , truck , n , m , min_time ) : NEW_LINE INDENT temp = 0 NEW_LINE count = 0 NEW_LINE while ( count < m ) : NEW_LINE INDENT j = 0 NEW_LINE while ( j < min_time and temp < n and truck [ count ] >= box [ temp ] ) : NEW_LINE INDENT temp += 1 NEW_LINE j += 2 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT if ( temp == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def minTime ( box , truck , n , m ) : NEW_LINE INDENT box . sort ( ) ; NEW_LINE truck . sort ( ) ; NEW_LINE l = 0 NEW_LINE h = 2 * n NEW_LINE min_time = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT mid = ( l + h ) // 2 NEW_LINE if ( isPossible ( box , truck , n , m , mid ) ) : NEW_LINE INDENT min_time = mid NEW_LINE h = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return min_time NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT box = [ 10 , 2 , 16 , 19 ] NEW_LINE truck = [ 29 , 25 ] NEW_LINE n = len ( box ) NEW_LINE m = len ( truck ) NEW_LINE print ( minTime ( box , truck , n , m ) ) NEW_LINE DEDENT
def isPossible ( arr , n , dist , k ) : NEW_LINE INDENT req = 0 NEW_LINE curr = 0 NEW_LINE prev = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( curr != n and ( arr [ curr ] - arr [ prev ] ) <= dist ) : NEW_LINE INDENT curr = curr + 1 NEW_LINE DEDENT req = req + 1 NEW_LINE if ( curr == n ) : NEW_LINE INDENT break NEW_LINE DEDENT prev = curr - 1 NEW_LINE DEDENT if ( curr != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( req <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def minDistance ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE h = arr [ n - 1 ] NEW_LINE ans = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 ; NEW_LINE if ( isPossible ( arr , n , m , k ) ) : NEW_LINE INDENT ans = m NEW_LINE h = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 2 , 15 , 36 , 43 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( minDistance ( arr , n , k ) ) NEW_LINE
def getKthElement ( n , k , L , R ) : NEW_LINE INDENT l = 1 NEW_LINE h = n NEW_LINE total = [ 0 for i in range ( n + 1 ) ] NEW_LINE total [ 0 ] = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total [ i + 1 ] = total [ i ] + ( R [ i ] - L [ i ] ) + 1 NEW_LINE DEDENT index = - 1 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( total [ m ] > k ) : NEW_LINE INDENT index = m NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( total [ m ] < k ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = m NEW_LINE break NEW_LINE DEDENT DEDENT l = L [ index - 1 ] NEW_LINE h = R [ index - 1 ] NEW_LINE x = k - total [ index - 1 ] NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( m - L [ index - 1 ] ) + 1 == x ) : NEW_LINE INDENT return m NEW_LINE DEDENT elif ( ( m - L [ index - 1 ] ) + 1 > x ) : NEW_LINE INDENT h = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT DEDENT L = [ 1 , 8 , 21 ] NEW_LINE R = [ 4 , 10 , 23 ] NEW_LINE n = len ( L ) NEW_LINE k = 6 NEW_LINE print ( getKthElement ( n , k , L , R ) ) NEW_LINE
def MinimumX ( a , b , c , k ) : NEW_LINE INDENT x = 10 ** 9 NEW_LINE if ( k <= c ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT h = k - c NEW_LINE l = 0 NEW_LINE while ( l <= h ) : NEW_LINE INDENT m = ( l + h ) // 2 NEW_LINE if ( ( a * m * m ) + ( b * m ) > ( k - c ) ) : NEW_LINE INDENT x = min ( x , m ) NEW_LINE h = m - 1 NEW_LINE DEDENT elif ( ( a * m * m ) + ( b * m ) < ( k - c ) ) : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return m NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT a , b , c , k = 3 , 2 , 4 , 15 NEW_LINE print ( MinimumX ( a , b , c , k ) ) NEW_LINE
def IfExists ( arr , n ) : NEW_LINE INDENT sum = [ 0 ] * n ; NEW_LINE arr . sort ( ) ; NEW_LINE sum [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max = arr [ n - 1 ] ; NEW_LINE flag = False ; NEW_LINE for i in range ( 1 , max + 1 ) : NEW_LINE INDENT findex = 0 ; NEW_LINE lindex = 0 ; NEW_LINE l = 0 ; NEW_LINE r = n - 1 ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( l + r ) // 2 ; NEW_LINE if ( arr [ m ] < i ) : NEW_LINE INDENT findex = m ; NEW_LINE l = m + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 ; NEW_LINE DEDENT DEDENT l = 1 ; NEW_LINE r = n ; NEW_LINE flag = False ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = ( r + l ) // 2 ; NEW_LINE if ( arr [ m ] > i ) : NEW_LINE INDENT lindex = m ; NEW_LINE r = m - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 ; NEW_LINE DEDENT DEDENT if ( sum [ findex ] == sum [ n - 1 ] - sum [ lindex - 1 ] ) : NEW_LINE INDENT flag = True ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE IfExists ( arr , n ) ; NEW_LINE DEDENT
def findMissing ( arr , n ) : NEW_LINE INDENT l , h = 0 , n - 1 NEW_LINE mid = 0 NEW_LINE while ( h > l ) : NEW_LINE INDENT mid = l + ( h - l ) // 2 NEW_LINE if ( arr [ mid ] - mid == arr [ 0 ] ) : NEW_LINE INDENT if ( arr [ mid + 1 ] - arr [ mid ] > 1 ) : NEW_LINE INDENT return arr [ mid ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( arr [ mid ] - arr [ mid - 1 ] > 1 ) : NEW_LINE INDENT return arr [ mid ] - 1 NEW_LINE DEDENT else : NEW_LINE INDENT h = mid - 1 NEW_LINE DEDENT DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ - 9 , - 8 , - 7 , - 5 , - 4 , - 3 , - 2 , - 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMissing ( arr , n ) ) NEW_LINE
import sys NEW_LINE def maxSum ( arr , n , K ) : NEW_LINE INDENT maximum = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sumk = 0 NEW_LINE for j in range ( i , n , K ) : NEW_LINE INDENT sumk = sumk + arr [ j ] NEW_LINE DEDENT maximum = max ( maximum , sumk ) NEW_LINE DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 4 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE K = 2 NEW_LINE print ( maxSum ( arr , n , K ) ) NEW_LINE DEDENT
def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - leftGreater ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 7 NEW_LINE print ( countGreater ( arr , n , k ) ) NEW_LINE DEDENT
def operations ( op , n , k ) : NEW_LINE INDENT i , count = 0 , 0 NEW_LINE nVal = 0 NEW_LINE minimum = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT nVal += op [ i ] NEW_LINE minimum = min ( minimum , nVal ) NEW_LINE if ( ( k + nVal ) <= 0 ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT if ( nVal >= 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT times = ( k - abs ( minimum ) ) // abs ( nVal ) NEW_LINE k = ( k - ( times * abs ( nVal ) ) ) NEW_LINE count = ( times * n ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT k = k + op [ i ] NEW_LINE count += 1 NEW_LINE if ( k <= 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT op = [ - 60 , 65 , - 1 , 14 , - 25 ] NEW_LINE n = len ( op ) NEW_LINE k = 100000 NEW_LINE print ( operations ( op , n , k ) ) NEW_LINE
def countFactor ( P , X ) : NEW_LINE INDENT if ( X < P ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return ( X // P + countFactor ( P , X // P ) ) ; NEW_LINE DEDENT def findSmallestX ( Y ) : NEW_LINE INDENT low = 0 ; NEW_LINE high = 5 * Y ; NEW_LINE N = 0 ; NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( high + low ) // 2 ; NEW_LINE if ( countFactor ( 5 , mid ) < Y ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT N = mid ; NEW_LINE high = mid - 1 ; NEW_LINE DEDENT DEDENT return N ; NEW_LINE DEDENT Y = 10 ; NEW_LINE print ( findSmallestX ( Y ) ) ; NEW_LINE
def squareSum ( N ) : NEW_LINE INDENT Sum = ( N * ( N + 1 ) * ( 2 * N + 1 ) ) // 6 NEW_LINE return Sum NEW_LINE DEDENT def findMaxN ( X ) : NEW_LINE INDENT low , high , N = 1 , 100000 , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( high + low ) // 2 NEW_LINE if squareSum ( mid ) <= X : NEW_LINE INDENT N = mid NEW_LINE low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return N NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 25 NEW_LINE print ( findMaxN ( X ) ) NEW_LINE DEDENT
def findRing ( arr , x ) : NEW_LINE INDENT if arr [ 0 ] [ 0 ] > x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT l , r = 0 , ( n + 1 ) // 2 - 1 NEW_LINE if n % 2 == 1 and arr [ r ] [ r ] < x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if n % 2 == 0 and arr [ r + 1 ] [ r ] < x : NEW_LINE INDENT return - 1 NEW_LINE DEDENT while l < r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if arr [ mid ] [ mid ] <= x : NEW_LINE INDENT if ( mid == ( n + 1 ) // 2 - 1 or arr [ mid + 1 ] [ mid + 1 ] > x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return r NEW_LINE DEDENT def binarySearchRowInc ( arr , row , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if arr [ row ] [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ row ] [ mid ] < x : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def binarySearchColumnInc ( arr , col , t , b , x ) : NEW_LINE INDENT while t <= b : NEW_LINE INDENT mid = ( t + b ) // 2 NEW_LINE if arr [ mid ] [ col ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] [ col ] < x : NEW_LINE INDENT t = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT b = mid - 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def binarySearchRowDec ( arr , row , l , r , x ) : NEW_LINE INDENT while l <= r : NEW_LINE INDENT mid = ( l + r ) // 2 NEW_LINE if arr [ row ] [ mid ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ row ] [ mid ] < x : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def binarySearchColumnDec ( arr , col , t , b , x ) : NEW_LINE INDENT while t <= b : NEW_LINE INDENT mid = ( t + b ) // 2 NEW_LINE if arr [ mid ] [ col ] == x : NEW_LINE INDENT return mid NEW_LINE DEDENT elif arr [ mid ] [ col ] < x : NEW_LINE INDENT b = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT t = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def spiralBinary ( arr , x ) : NEW_LINE INDENT f1 = findRing ( arr , x ) NEW_LINE r , c = None , None NEW_LINE if f1 == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT if n % 2 == 1 and f1 == ( n + 1 ) // 2 - 1 : NEW_LINE INDENT print ( f1 , f1 ) NEW_LINE return NEW_LINE DEDENT if x < arr [ f1 ] [ n - f1 - 1 ] : NEW_LINE INDENT c = binarySearchRowInc ( arr , f1 , f1 , n - f1 - 2 , x ) NEW_LINE r = f1 NEW_LINE DEDENT elif x < arr [ n - f1 - 1 ] [ n - f1 - 1 ] : NEW_LINE INDENT c = n - f1 - 1 NEW_LINE r = binarySearchColumnInc ( arr , n - f1 - 1 , f1 , n - f1 - 2 , x ) NEW_LINE DEDENT elif x < arr [ n - f1 - 1 ] [ f1 ] : NEW_LINE INDENT c = binarySearchRowDec ( arr , n - f1 - 1 , f1 + 1 , n - f1 - 1 , x ) NEW_LINE r = n - f1 - 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = binarySearchColumnDec ( arr , f1 , f1 + 1 , n - f1 - 1 , x ) NEW_LINE c = f1 NEW_LINE DEDENT if c == - 1 or r == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " { 0 } ▁ { 1 } " . format ( r , c ) ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE arr = [ [ 1 , 2 , 3 , 4 ] , [ 12 , 13 , 14 , 5 ] , [ 11 , 16 , 15 , 6 ] , [ 10 , 9 , 8 , 7 ] ] NEW_LINE spiralBinary ( arr , 7 ) NEW_LINE DEDENT
def countSubArrays ( arr , n , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT bitwise_or = 0 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT bitwise_or = bitwise_or | arr [ k ] NEW_LINE DEDENT if ( bitwise_or >= K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( countSubArrays ( arr , n , k ) ) NEW_LINE DEDENT
def countPattern ( n , pat ) : NEW_LINE INDENT pattern_int = 0 NEW_LINE power_two = 1 NEW_LINE all_ones = 0 NEW_LINE i = len ( pat ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT current_bit = ord ( pat [ i ] ) - ord ( '0' ) NEW_LINE pattern_int += ( power_two * current_bit ) NEW_LINE all_ones = all_ones + power_two NEW_LINE power_two = power_two * 2 NEW_LINE i -= 1 NEW_LINE DEDENT count = 0 NEW_LINE while ( n != 0 and n >= pattern_int ) : NEW_LINE INDENT if ( ( n & all_ones ) == pattern_int ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 500 NEW_LINE pat = "10" NEW_LINE print ( countPattern ( n , pat ) ) NEW_LINE DEDENT
def max_min ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE return min ( a [ n - 2 ] - a [ 0 ] , a [ n - 1 ] - a [ 1 ] ) NEW_LINE DEDENT a = [ 1 , 3 , 3 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( max_min ( a , n ) ) NEW_LINE
MAX = 1000001 NEW_LINE MAX_sqrt = MAX ** ( 0.5 ) NEW_LINE primeUpto = [ 0 ] * ( MAX ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ 1 ] * ( MAX ) NEW_LINE isPrime [ 0 ] , isPrime [ 1 ] = 0 , 0 NEW_LINE for i in range ( 2 , int ( MAX_sqrt ) ) : NEW_LINE INDENT if isPrime [ i ] == 1 : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT primeUpto [ i ] = primeUpto [ i - 1 ] NEW_LINE if isPrime [ i ] == 1 : NEW_LINE INDENT primeUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid - primeUpto [ mid ] >= K : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ( N - ans + 1 ) if ans else 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , K = 10 , 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT
def minIndex ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( 2 * arr [ i ] == sum ) : NEW_LINE INDENT return ( i + 1 ) NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 1 , 3 , - 5 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( minIndex ( arr , n ) ) NEW_LINE
N , M = 4 , 4 NEW_LINE def printIntersection ( A , B ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT if ( A [ i ] [ j ] == B [ i ] [ j ] ) : NEW_LINE INDENT print ( A [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " * ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ [ 2 , 4 , 6 , 8 ] , [ 1 , 3 , 5 , 7 ] , [ 8 , 6 , 4 , 2 ] , [ 7 , 5 , 3 , 1 ] ] NEW_LINE B = [ [ 2 , 3 , 6 , 8 ] , [ 1 , 3 , 5 , 2 ] , [ 8 , 1 , 4 , 2 ] , [ 3 , 5 , 4 , 1 ] ] NEW_LINE printIntersection ( A , B ) NEW_LINE DEDENT
import math as mt NEW_LINE def countWays ( arr , n ) : NEW_LINE INDENT max_val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_val = max ( max_val , arr [ i ] ) NEW_LINE DEDENT freq = [ 0 for i in range ( max_val + 1 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT ans += ( freq [ 0 ] * ( freq [ 0 ] - 1 ) * ( freq [ 0 ] - 2 ) // 6 ) NEW_LINE for i in range ( 1 , max_val + 1 ) : NEW_LINE INDENT ans += ( freq [ 0 ] * freq [ i ] * ( freq [ i ] - 1 ) // 2 ) NEW_LINE DEDENT for i in range ( 1 , ( max_val + 1 ) // 2 ) : NEW_LINE INDENT ans += ( freq [ i ] * ( freq [ i ] - 1 ) // 2 * freq [ 2 * i ] ) NEW_LINE DEDENT for i in range ( 1 , max_val + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , max_val - i + 1 ) : NEW_LINE INDENT ans += freq [ i ] * freq [ j ] * freq [ i + j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countWays ( arr , n ) ) NEW_LINE
def LongestSubarray ( arr , n , k ) : NEW_LINE INDENT count = 1 NEW_LINE max_lenght = 1 NEW_LINE prev_mod = arr [ 0 ] % k NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_mod = arr [ i ] % k NEW_LINE if curr_mod == prev_mod : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_lenght = max ( max_lenght , count ) NEW_LINE count = 1 NEW_LINE prev_mod = curr_mod NEW_LINE DEDENT DEDENT return max ( max_lenght , count ) NEW_LINE DEDENT arr = [ 4 , 9 , 7 , 18 , 29 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE k = 11 NEW_LINE print ( LongestSubarray ( arr , n , k ) ) NEW_LINE
M = 3 NEW_LINE N = 4 NEW_LINE def binarySearch1D ( arr , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = N - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + int ( ( high - low ) / 2 ) NEW_LINE if ( arr [ mid ] == K ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ mid ] < K ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def searchMatrix ( matrix , K ) : NEW_LINE INDENT low = 0 NEW_LINE high = M - 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = low + int ( ( high - low ) / 2 ) NEW_LINE if ( K >= matrix [ mid ] [ 0 ] and K <= matrix [ mid ] [ N - 1 ] ) : NEW_LINE INDENT return binarySearch1D ( matrix [ mid ] , K ) NEW_LINE DEDENT if ( K < matrix [ mid ] [ 0 ] ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT matrix = [ [ 1 , 3 , 5 , 7 ] , [ 10 , 11 , 16 , 20 ] , [ 23 , 30 , 34 , 50 ] ] NEW_LINE K = 3 NEW_LINE if ( searchMatrix ( matrix , K ) ) : NEW_LINE INDENT print ( " Found " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ found " ) NEW_LINE DEDENT DEDENT
def numberOfElements ( height , n ) : NEW_LINE INDENT max_so_far = 0 NEW_LINE coun = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if height [ i ] > max_so_far : NEW_LINE INDENT max_so_far = height [ i ] NEW_LINE coun = coun + 1 NEW_LINE DEDENT DEDENT return coun NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE height = [ 4 , 8 , 2 , 0 , 0 , 5 ] NEW_LINE print ( numberOfElements ( height , n ) ) NEW_LINE DEDENT
def solve ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE if ( k == 1 and arr [ n - 2 ] != arr [ n - 1 ] ) : NEW_LINE INDENT print ( arr [ n - 1 ] ) NEW_LINE return NEW_LINE DEDENT count = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 1 NEW_LINE DEDENT if ( count == k and ( i == 0 or ( arr [ i - 1 ] != arr [ i ] ) ) ) : NEW_LINE INDENT print ( arr [ i ] ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " No ▁ such ▁ element " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 3 , 3 , 4 , 5 , 5 , 6 , 6 , 6 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE solve ( arr , n , k ) NEW_LINE DEDENT
def getMin ( arr , n ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = min ( res , arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def getMax ( arr , n ) : NEW_LINE INDENT res = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT def findSum ( arr , n ) : NEW_LINE INDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE return min + max NEW_LINE DEDENT def findProduct ( arr , n ) : NEW_LINE INDENT min = getMin ( arr , n ) NEW_LINE max = getMax ( arr , n ) NEW_LINE return min * max NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 12 , 1234 , 45 , 67 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum ▁ = ▁ " , findSum ( arr , n ) ) NEW_LINE print ( " Product ▁ = ▁ " , findProduct ( arr , n ) ) NEW_LINE DEDENT
def countChar ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n <= 2 ) : NEW_LINE INDENT return n NEW_LINE DEDENT count = 2 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " egeeksk " NEW_LINE print ( countChar ( str ) ) NEW_LINE DEDENT
def next ( arr , target ) : NEW_LINE INDENT start = 0 ; NEW_LINE end = len ( arr ) - 1 ; NEW_LINE if ( end == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( target > arr [ end ] ) : NEW_LINE INDENT return end ; NEW_LINE DEDENT ans = - 1 ; NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 ; NEW_LINE if ( arr [ mid ] >= target ) : NEW_LINE INDENT end = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid ; NEW_LINE start = mid + 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 5 , 8 , 12 ] ; NEW_LINE print ( next ( arr , 5 ) ) ; NEW_LINE DEDENT
def next ( arr , target ) : NEW_LINE INDENT start = 0 ; NEW_LINE end = len ( arr ) - 1 ; NEW_LINE ans = - 1 ; NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 ; NEW_LINE if ( arr [ mid ] <= target ) : NEW_LINE INDENT start = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = mid ; NEW_LINE end = mid - 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 5 , 8 , 12 ] ; NEW_LINE print ( next ( arr , 8 ) ) ; NEW_LINE DEDENT
def search ( arr , n , x ) : NEW_LINE INDENT res = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( x == arr [ i ] ) : NEW_LINE INDENT res = i NEW_LINE DEDENT DEDENT if ( res == - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT temp = arr [ res ] NEW_LINE i = res NEW_LINE while ( i > 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT arr [ 0 ] = temp NEW_LINE return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 25 , 36 , 85 , 98 , 75 , 89 , 15 , 63 , 66 , 64 , 74 , 27 , 83 , 97 ] NEW_LINE q = [ 63 , 63 , 86 , 63 , 78 ] NEW_LINE n = len ( arr ) NEW_LINE m = len ( q ) NEW_LINE for i in range ( 0 , m , 1 ) : NEW_LINE INDENT if ( search ( arr , n , q [ i ] ) ) : NEW_LINE INDENT print ( " Yes " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def kPresentProbability ( a , n , k ) : NEW_LINE INDENT count = a . count ( k ) NEW_LINE return round ( count / n , 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 4 , 7 , 2 , 0 , 8 , 7 , 5 ] NEW_LINE K = 2 NEW_LINE N = len ( A ) NEW_LINE print ( kPresentProbability ( A , N , K ) ) NEW_LINE DEDENT
def slopeOfNum ( num , n ) : NEW_LINE ' NEW_LINE INDENT slope = 0 NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( num [ i ] > num [ i - 1 ] and num [ i ] > num [ i + 1 ] ) : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT elif ( num [ i ] < num [ i - 1 ] and num [ i ] < num [ i + 1 ] ) : NEW_LINE INDENT slope += 1 NEW_LINE DEDENT DEDENT return slope NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = "1213321" NEW_LINE n = len ( num ) NEW_LINE print ( " Slope ▁ = " , slopeOfNum ( num , n ) ) NEW_LINE DEDENT
def prevGreater ( arr , n ) : NEW_LINE INDENT print ( " - 1" , end = " , ▁ " ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT flag = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT print ( arr [ j ] , end = " , ▁ " ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if j == 0 and flag == 0 : NEW_LINE INDENT print ( " - 1" , end = " , ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 4 , 2 , 20 , 40 , 12 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE prevGreater ( arr , n ) NEW_LINE DEDENT
def printDuplicates ( arr , n ) : NEW_LINE INDENT fl = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] >= n ) : NEW_LINE INDENT if ( arr [ arr [ i ] % n ] < 2 * n ) : NEW_LINE INDENT print ( arr [ i ] % n , end = " ▁ " ) NEW_LINE fl = 1 ; NEW_LINE DEDENT DEDENT arr [ arr [ i ] % n ] += n ; NEW_LINE DEDENT if ( fl == 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT arr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ] ; NEW_LINE arr_size = len ( arr ) ; NEW_LINE printDuplicates ( arr , arr_size ) ; NEW_LINE
def findMissingNo ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] <= 0 or arr [ i ] > n ) : NEW_LINE INDENT continue NEW_LINE DEDENT val = arr [ i ] NEW_LINE while ( arr [ val - 1 ] != val ) : NEW_LINE INDENT nextval = arr [ val - 1 ] NEW_LINE arr [ val - 1 ] = val NEW_LINE val = nextval NEW_LINE if ( val <= 0 or val > n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] != i + 1 ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT return n + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 7 , 6 , 8 , - 1 , - 10 , 15 ] NEW_LINE arr_size = len ( arr ) NEW_LINE missing = findMissingNo ( arr , arr_size ) NEW_LINE print ( " The ▁ smallest ▁ positive " , " missing ▁ number ▁ is ▁ " , missing ) NEW_LINE DEDENT
def findTriplets ( arr , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] == sum ) : NEW_LINE INDENT print ( arr [ i ] , " ▁ " , arr [ j ] , " ▁ " , arr [ k ] , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT arr = [ 0 , - 1 , 2 , - 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE findTriplets ( arr , n , - 2 ) NEW_LINE
import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT max_product = - sys . maxsize ; NEW_LINE for i in range ( n - 3 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 2 ) : NEW_LINE INDENT for k in range ( j + 1 , n - 1 ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] * arr [ l ] ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return max_product ; NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE max = maxProduct ( arr , n ) ; NEW_LINE if ( max == - 1 ) : NEW_LINE INDENT print ( " No ▁ Quadruple ▁ Exists " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Maximum ▁ product ▁ is " , max ) ; NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE x = ( arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] * arr [ n - 4 ] ) NEW_LINE y = arr [ 0 ] * arr [ 1 ] * arr [ 2 ] * arr [ 3 ] NEW_LINE z = ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] * arr [ n - 2 ] ) NEW_LINE return max ( x , max ( y , z ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 10 , - 3 , 5 , 6 , - 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if ( max == - 1 ) : NEW_LINE INDENT print ( " No ▁ Quadruple ▁ Exists " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Maximum ▁ product ▁ is " , max ) NEW_LINE DEDENT DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT ans = arr [ 0 ] + arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 , 1 ) : NEW_LINE INDENT ans = min ( ans , ( arr [ i ] + arr [ i + 1 ] ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 12 , 2 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT
N = 3 NEW_LINE def getGreatestSum ( a ) : NEW_LINE INDENT prev_max = 0 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( prev_max < a [ N - 1 ] [ j ] ) : NEW_LINE INDENT prev_max = a [ N - 1 ] [ j ] NEW_LINE DEDENT DEDENT sum = prev_max NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT curr_max = - 2147483648 NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( prev_max > a [ i ] [ j ] and a [ i ] [ j ] > curr_max ) : NEW_LINE INDENT curr_max = a [ i ] [ j ] NEW_LINE DEDENT DEDENT if ( curr_max == - 2147483648 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT prev_max = curr_max NEW_LINE sum = sum + prev_max NEW_LINE DEDENT return sum NEW_LINE DEDENT a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( getGreatestSum ( a ) ) NEW_LINE b = [ [ 4 , 5 , 6 ] , [ 4 , 5 , 6 ] , [ 4 , 5 , 6 ] ] NEW_LINE print ( getGreatestSum ( b ) ) NEW_LINE
import math NEW_LINE def findElement ( n , k ) : NEW_LINE INDENT left = 1 NEW_LINE right = math . pow ( 2 , n ) - 1 NEW_LINE while 1 : NEW_LINE INDENT mid = int ( ( left + right ) / 2 ) NEW_LINE if k == mid : NEW_LINE INDENT print ( ans ) NEW_LINE break NEW_LINE DEDENT ans -= 1 NEW_LINE if k < mid : NEW_LINE INDENT right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE k = 8 NEW_LINE findElement ( n , k ) NEW_LINE
def checkBit ( pattern , arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( pattern & arr [ i ] ) == pattern ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for bit in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT count = checkBit ( res | ( 1 << bit ) , arr , n ) NEW_LINE if ( count >= 2 ) : NEW_LINE INDENT res |= ( 1 << bit ) NEW_LINE DEDENT DEDENT if ( res == 0 ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Pair ▁ = ▁ " , end = " " ) NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE while ( i < n and count < 2 ) : NEW_LINE INDENT if ( ( arr [ i ] & res ) == res ) : NEW_LINE INDENT count += 1 NEW_LINE print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum AND Value =   " , maxAND ( arr , n ) ) NEW_LINE
def countMaxSumPairs ( a , n ) : NEW_LINE INDENT first = 0 NEW_LINE second = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = a [ i ] NEW_LINE DEDENT elif ( a [ i ] > second and a [ i ] != first ) : NEW_LINE INDENT second = a [ i ] NEW_LINE DEDENT DEDENT cnt1 = 0 NEW_LINE cnt2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == first ) : NEW_LINE if ( a [ i ] == second ) : NEW_LINE DEDENT if ( cnt1 == 1 ) : NEW_LINE INDENT return cnt2 NEW_LINE DEDENT if ( cnt1 > 1 ) : NEW_LINE INDENT return cnt1 * ( cnt1 - 1 ) / 2 NEW_LINE DEDENT DEDENT def findMaxSumProbability ( a , n ) : NEW_LINE INDENT total = n * ( n - 1 ) / 2 NEW_LINE max_sum_pairs = countMaxSumPairs ( a , n ) NEW_LINE return max_sum_pairs / total NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMaxSumProbability ( a , n ) ) NEW_LINE DEDENT
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = 15 NEW_LINE n = findS ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
import math NEW_LINE def calcSafe ( pos ) : NEW_LINE INDENT j = pos % 10 NEW_LINE i = pos / 10 NEW_LINE dis_11 = min ( abs ( 1 - i ) , abs ( 1 - j ) ) NEW_LINE dis_18 = min ( abs ( 1 - i ) , abs ( 8 - j ) ) NEW_LINE dis_81 = min ( abs ( 8 - i ) , abs ( 1 - j ) ) NEW_LINE dis_88 = min ( abs ( 8 - i ) , abs ( 8 - j ) ) NEW_LINE sum = ( dis_11 + dis_18 + dis_81 + dis_88 + 1 ) NEW_LINE return ( 64 - sum ) NEW_LINE DEDENT pos = 34 NEW_LINE print ( " Safe ▁ Positions ▁ = ▁ " , math . ceil ( calcSafe ( pos ) ) ) NEW_LINE
def getCount ( arr , n , num1 , num2 ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == num1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i >= n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for j in range ( n - 1 , i + 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] == num2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( j == i ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( j - i - 1 ) NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 6 , 4 , 9 , 12 , 4 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE num1 = 5 NEW_LINE num2 = 4 NEW_LINE print ( getCount ( arr , n , num1 , num2 ) ) NEW_LINE
def sumOfDigit ( K ) : NEW_LINE INDENT sod = 0 NEW_LINE while ( K ) : NEW_LINE INDENT sod = sod + K % 10 NEW_LINE K = K // 10 NEW_LINE DEDENT return sod NEW_LINE DEDENT def totalNumbersWithSpecificDifference ( N , diff ) : NEW_LINE INDENT low = 1 NEW_LINE high = N NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( mid - sumOfDigit ( mid ) < diff ) : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ( N - high ) NEW_LINE DEDENT N = 13 NEW_LINE diff = 2 NEW_LINE print ( totalNumbersWithSpecificDifference ( N , diff ) ) NEW_LINE
def countBuildings ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE curr_max = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > curr_max or arr [ i ] == curr_max ) : NEW_LINE INDENT count += 1 NEW_LINE curr_max = arr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 7 , 4 , 8 , 2 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countBuildings ( arr , n ) ) NEW_LINE
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] != arr2 [ i ] ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE
def findExtra ( arr1 , arr2 , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = n - 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( int ) ( ( left + right ) / 2 ) NEW_LINE if ( arr2 [ mid ] == arr1 [ mid ] ) : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT index = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT arr1 = [ 2 , 4 , 6 , 8 , 10 , 12 , 13 ] NEW_LINE arr2 = [ 2 , 4 , 6 , 8 , 10 , 12 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( findExtra ( arr1 , arr2 , n ) ) NEW_LINE
def computeCost ( arr , N , X ) : NEW_LINE INDENT cost = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cost += abs ( arr [ i ] - X ) NEW_LINE DEDENT return cost NEW_LINE DEDENT def minCostToMakeElementEqual ( arr , N ) : NEW_LINE INDENT low = high = arr [ 0 ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( low > arr [ i ] ) : low = arr [ i ] NEW_LINE if ( high < arr [ i ] ) : high = arr [ i ] NEW_LINE DEDENT while ( ( high - low ) > 2 ) : NEW_LINE INDENT mid1 = low + ( high - low ) // 3 NEW_LINE mid2 = high - ( high - low ) // 3 NEW_LINE cost1 = computeCost ( arr , N , mid1 ) NEW_LINE cost2 = computeCost ( arr , N , mid2 ) NEW_LINE if ( cost1 < cost2 ) : NEW_LINE INDENT high = mid2 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid1 NEW_LINE DEDENT DEDENT return computeCost ( arr , N , ( low + high ) // 2 ) NEW_LINE DEDENT arr = [ 1 , 100 , 101 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minCostToMakeElementEqual ( arr , N ) ) NEW_LINE
def Next_greater ( a , n , x ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE low , high , ans = 0 , n - 1 , x + 1 NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( a [ mid ] <= ans ) : NEW_LINE INDENT if ( a [ mid ] == ans ) : NEW_LINE INDENT ans += 1 NEW_LINE high = n - 1 NEW_LINE DEDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 1 , 5 , 10 , 4 , 7 ] NEW_LINE x = 4 NEW_LINE n = len ( a ) NEW_LINE print ( Next_greater ( a , n , x ) ) NEW_LINE
mod = 1000000007 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return int ( fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT def powmod ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT pt = powmod ( a , int ( n / 2 ) ) NEW_LINE pt = ( pt * pt ) % mod NEW_LINE if ( n % 2 ) : NEW_LINE INDENT return ( pt * a ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return pt NEW_LINE DEDENT DEDENT def CountSubset ( arr , n ) : NEW_LINE INDENT ans = powmod ( 2 , n - 1 ) NEW_LINE arr . sort ( reverse = False ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = i + 1 NEW_LINE while ( j < n and arr [ j ] == arr [ i ] ) : NEW_LINE INDENT r = n - 1 - j NEW_LINE l = i NEW_LINE ans = ( ans + nCr ( l + r , l ) ) % mod NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountSubset ( arr , n ) ) NEW_LINE DEDENT
def reArrange ( words , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ words [ i ] ] = i + 1 NEW_LINE DEDENT words . sort ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( mp [ words [ i ] ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT words = [ " live " , " place " , " travel " , " word " , " sky " ] NEW_LINE n = len ( words ) NEW_LINE reArrange ( words , n ) ; NEW_LINE
MAX = 100000 NEW_LINE def findSumofEle ( arr1 , m , arr2 , n ) : NEW_LINE INDENT hash = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr2 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , MAX , 1 ) : NEW_LINE INDENT hash [ i ] = hash [ i ] + hash [ i - 1 ] NEW_LINE DEDENT maximumFreq = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT maximumFreq = max ( maximumFreq , hash [ arr1 [ i ] ] ) NEW_LINE DEDENT sumOfElements = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( maximumFreq == hash [ arr1 [ i ] ] ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 2 , 5 , 6 , 8 ] NEW_LINE arr2 = [ 4 , 10 ] NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( findSumofEle ( arr1 , m , arr2 , n ) ) NEW_LINE DEDENT
def printNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE A , B = arr [ n - 1 ] , - 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if A % arr [ i ] != 0 : NEW_LINE INDENT B = arr [ i ] NEW_LINE break NEW_LINE DEDENT if i - 1 >= 0 and arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT B = arr [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( " A ▁ = " , A , " , ▁ B ▁ = " , B ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 16 , 1 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE printNumbers ( arr , n ) NEW_LINE DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT def removeMin ( arr , n ) : NEW_LINE INDENT minVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minVal = min ( minVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = arr [ i ] - minVal ; NEW_LINE DEDENT DEDENT def removeFromMax ( arr , n ) : NEW_LINE INDENT maxVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT maxVal = max ( maxVal , arr [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = maxVal - arr [ i ] ; NEW_LINE DEDENT DEDENT def modifyArray ( arr , n , k ) : NEW_LINE INDENT if ( k % 2 == 0 ) : NEW_LINE INDENT removeMin ( arr , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT removeFromMax ( arr , n ) ; NEW_LINE DEDENT printArray ( arr , n ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 12 , 16 ] ; NEW_LINE n = len ( arr ) NEW_LINE k = 2 ; NEW_LINE modifyArray ( arr , n , k ) ; NEW_LINE DEDENT
def findAnswer ( n , arr ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE sum = 0 NEW_LINE for i in range ( int ( n / 2 ) ) : NEW_LINE INDENT sum += ( ( arr [ i ] + arr [ n - i - 1 ] ) * ( arr [ i ] + arr [ n - i - 1 ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 53 , 28 , 143 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAnswer ( n , arr ) ) NEW_LINE DEDENT
n = 4 ; NEW_LINE def merge ( l , r , output ) : NEW_LINE INDENT l_in = l * n ; NEW_LINE r_in = ( ( l + r ) // 2 + 1 ) * n ; NEW_LINE l_c = ( ( l + r ) // 2 - l + 1 ) * n ; NEW_LINE r_c = ( r - ( l + r ) // 2 ) * n ; NEW_LINE l_arr = [ 0 ] * l_c ; r_arr = [ 0 ] * r_c ; NEW_LINE for i in range ( l_c ) : NEW_LINE INDENT l_arr [ i ] = output [ l_in + i ] ; NEW_LINE DEDENT for i in range ( r_c ) : NEW_LINE INDENT r_arr [ i ] = output [ r_in + i ] ; NEW_LINE DEDENT l_curr = 0 ; r_curr = 0 ; NEW_LINE in1 = l_in ; NEW_LINE while ( l_curr + r_curr < l_c + r_c ) : NEW_LINE INDENT if ( r_curr == r_c or ( l_curr != l_c and l_arr [ l_curr ] < r_arr [ r_curr ] ) ) : NEW_LINE INDENT output [ in1 ] = l_arr [ l_curr ] ; NEW_LINE l_curr += 1 ; in1 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT output [ in1 ] = r_arr [ r_curr ] ; NEW_LINE r_curr += 1 ; in1 += 1 ; NEW_LINE DEDENT DEDENT DEDENT def divide ( l , r , output , arr ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT output [ l * n + i ] = arr [ l ] [ i ] ; NEW_LINE DEDENT return ; NEW_LINE DEDENT divide ( l , ( l + r ) // 2 , output , arr ) ; NEW_LINE divide ( ( l + r ) // 2 + 1 , r , output , arr ) ; NEW_LINE merge ( l , r , output ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 5 , 7 , 15 , 18 ] , [ 1 , 8 , 9 , 17 ] , [ 1 , 4 , 7 , 7 ] ] ; NEW_LINE k = len ( arr ) ; NEW_LINE output = [ 0 ] * ( n * k ) ; NEW_LINE divide ( 0 , k - 1 , output , arr ) ; NEW_LINE for i in range ( n * k ) : NEW_LINE INDENT print ( output [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def countDistinct ( arr , n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT j = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] == arr [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == j + 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 12 , 10 , 9 , 45 , 2 , 10 , 10 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countDistinct ( arr , n ) ) NEW_LINE
def countDistinct ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n - 1 and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT res += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT arr = [ 6 , 10 , 5 , 4 , 9 , 120 , 4 , 6 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countDistinct ( arr , n ) ) ; NEW_LINE
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def printMaxMean ( arr , n ) : NEW_LINE INDENT newArr = [ 0 ] * n NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT newArr [ i ] = arr [ i + n ] NEW_LINE DEDENT printArray ( newArr , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 3 , 1 , 3 , 7 , 0 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxMean ( arr , n // 2 ) NEW_LINE DEDENT
def average ( arr , n , k ) : NEW_LINE INDENT total = 0 NEW_LINE if ( 2 * k >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE start , end = k , n - k - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT total += arr [ i ] NEW_LINE DEDENT return ( total / ( n - 2 * k ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( average ( arr , n , k ) ) NEW_LINE DEDENT
def min_sum ( n , k , a ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE if ( a [ 0 ] < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT if ( a [ 0 ] == a [ n - 1 ] ) : NEW_LINE INDENT return ( n * a [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT f = 0 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT p = a [ i ] - a [ 0 ] NEW_LINE if ( p % k == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT f = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( f ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( a [ 0 ] % k ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 ] NEW_LINE K = 1 NEW_LINE N = len ( arr ) NEW_LINE print ( min_sum ( N , K , arr ) ) NEW_LINE DEDENT
def minCost ( A , n ) : NEW_LINE INDENT cost = 0 NEW_LINE A . sort ( ) ; NEW_LINE K = A [ int ( n / 2 ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cost = cost + abs ( A [ i ] - K ) NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT tempCost = 0 NEW_LINE K = A [ int ( n / 2 ) - 1 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tempCost = tempCost + abs ( A [ i ] - K ) NEW_LINE DEDENT cost = min ( cost , tempCost ) NEW_LINE DEDENT return cost NEW_LINE DEDENT A = [ 1 , 6 , 7 , 10 ] NEW_LINE n = len ( A ) NEW_LINE print ( minCost ( A , n ) ) NEW_LINE
def printArray ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE l = 0 NEW_LINE r = n - 1 NEW_LINE flag = 0 NEW_LINE k = 2 NEW_LINE while ( l <= r ) : NEW_LINE INDENT if ( flag == 0 ) : NEW_LINE INDENT i = l NEW_LINE while i < l + k and i <= r : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT flag = 1 NEW_LINE l = i NEW_LINE i = r NEW_LINE while i > r - k and i >= l : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE i -= 1 NEW_LINE DEDENT flag = 0 NEW_LINE r = i NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT
def isAlphabaticOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] < s [ i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbbcc " NEW_LINE if ( isAlphabaticOrder ( s ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import sys ; NEW_LINE def rotateRec ( n , L , B ) : NEW_LINE INDENT m = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = max ( L [ i ] , B [ i ] ) ; NEW_LINE DEDENT elif ( min ( L [ i ] , B [ i ] ) <= m ) : NEW_LINE INDENT m = min ( L [ i ] , B [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT n = 3 ; NEW_LINE L = [ 5 , 5 , 6 ] ; NEW_LINE B = [ 6 , 7 , 8 ] ; NEW_LINE if ( rotateRec ( n , L , B ) == 1 ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def minDistance ( n , k , point ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT point [ i ] . sort ( ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( point [ i ] [ ( ( n + 1 ) // 2 ) - 1 ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 4 NEW_LINE k = 4 NEW_LINE point = [ [ 1 , 5 , 2 , 4 ] , [ 6 , 2 , 0 , 6 ] , [ 9 , 5 , 1 , 3 ] , [ 6 , 7 , 5 , 9 ] ] NEW_LINE minDistance ( n , k , point ) NEW_LINE
def printOrder ( arr , n , k ) : NEW_LINE INDENT len1 = k NEW_LINE len2 = n - k NEW_LINE arr1 = [ 0 ] * k NEW_LINE arr2 = [ 0 ] * ( n - k ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT arr1 [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( k , n ) : NEW_LINE INDENT arr2 [ i - k ] = arr [ i ] NEW_LINE DEDENT arr1 . sort ( ) NEW_LINE arr2 . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < k ) : NEW_LINE INDENT arr [ i ] = arr1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr2 [ len2 - 1 ] NEW_LINE len2 -= 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , - 1 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , n , k ) NEW_LINE DEDENT
def findMaxNum ( arr , n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 9 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( hash [ i ] ) : NEW_LINE INDENT print ( i , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE findMaxNum ( arr , n ) NEW_LINE DEDENT
def distribution ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] > arr [ i - 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return min ( count , n / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 1 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( int ( distribution ( arr , n ) ) ) NEW_LINE DEDENT
a = [ 10 , 12 , 5 ] NEW_LINE a . sort ( ) NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT
def printTriplets ( arr , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n - 2 , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] < sum ) : NEW_LINE INDENT print ( arr [ i ] , " , " , arr [ j ] , " , " , arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 12 NEW_LINE printTriplets ( arr , n , sum ) NEW_LINE DEDENT
def countTriplets ( arr , n , a , b ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] + arr [ j ] + arr [ k ] >= a ) and ( arr [ i ] + arr [ j ] + arr [ k ] <= b ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE a = 8 ; b = 16 NEW_LINE print ( countTriplets ( arr , n , a , b ) ) NEW_LINE DEDENT
def countTripletsLessThan ( arr , n , val ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ans = 0 NEW_LINE j = 0 ; k = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT j = i + 1 NEW_LINE k = n - 1 NEW_LINE while j != k : NEW_LINE INDENT sum = arr [ i ] + arr [ j ] + arr [ k ] NEW_LINE if sum > val : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( k - j ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT def countTriplets ( arr , n , a , b ) : NEW_LINE INDENT res = 0 NEW_LINE res = ( countTripletsLessThan ( arr , n , b ) - countTripletsLessThan ( arr , n , a - 1 ) ) NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 7 , 5 , 3 , 8 , 4 , 1 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE a = 8 ; b = 16 NEW_LINE print ( countTriplets ( arr , n , a , b ) ) NEW_LINE DEDENT
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i = i + 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT a = [ 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxTotalRectangleArea ( a , n ) ) NEW_LINE
def print1 ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT def sort ( a , n ) : NEW_LINE INDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT for j in range ( n , n - i , - 1 ) : NEW_LINE INDENT if ( a [ j ] > a [ j - 1 ] ) : NEW_LINE INDENT a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] NEW_LINE DEDENT DEDENT DEDENT print1 ( a , n ) NEW_LINE DEDENT n = 7 NEW_LINE a = [ 2 , 4 , 3 , 2 , 4 , 5 , 3 ] NEW_LINE sort ( a , n - 1 ) NEW_LINE
def distancesum ( x , y , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum += ( abs ( x [ i ] - x [ j ] ) + abs ( y [ i ] - y [ j ] ) ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( distancesum ( x , y , n ) ) NEW_LINE
def distancesum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += ( arr [ i ] * i - sum ) NEW_LINE sum += arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT def totaldistancesum ( x , y , n ) : NEW_LINE INDENT return distancesum ( x , n ) + distancesum ( y , n ) NEW_LINE DEDENT x = [ - 1 , 1 , 3 , 2 ] NEW_LINE y = [ 5 , 6 , 5 , 3 ] NEW_LINE n = len ( x ) NEW_LINE print ( totaldistancesum ( x , y , n ) ) NEW_LINE
def printMedian ( arr , n , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE print ( arr [ int ( ( n + K ) / 2 ) ] ) NEW_LINE DEDENT arr = [ 5 , 3 , 2 , 8 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE printMedian ( arr , n , k ) NEW_LINE
def arrange ( arr , n , x ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( arr [ i ] - x ) NEW_LINE j = i - 1 NEW_LINE if ( abs ( arr [ j ] - x ) > diff ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE while ( abs ( arr [ j ] - x ) > diff and j >= 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT def print_1 ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 5 , 3 , 9 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE x = 7 NEW_LINE arrange ( arr , n , x ) NEW_LINE print_1 ( arr , n ) NEW_LINE DEDENT
def printOrder ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT for j in range ( n - 1 , n // 2 - 1 , - 1 ) : NEW_LINE INDENT print ( arr [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , - 1 ] NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , n ) NEW_LINE DEDENT
def findMinimum ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE i = 0 NEW_LINE while ( n ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE n = n - k NEW_LINE i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def findMaximum ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE index = 0 NEW_LINE i = n - 1 NEW_LINE while ( i >= index ) : NEW_LINE INDENT res += arr [ i ] NEW_LINE index += k NEW_LINE i -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 NEW_LINE arr . sort ( ) NEW_LINE print ( findMinimum ( arr , n , k ) , " ▁ " , findMaximum ( arr , n , k ) ) NEW_LINE
def maxLevel ( boxes , n ) : NEW_LINE INDENT boxes . sort ( ) NEW_LINE prev_width = boxes [ 0 ] NEW_LINE prev_count = 1 NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_width += boxes [ i ] NEW_LINE curr_count += 1 NEW_LINE if ( curr_width > prev_width and curr_count > prev_count ) : NEW_LINE INDENT prev_width = curr_width NEW_LINE prev_count = curr_count NEW_LINE curr_count = 0 NEW_LINE curr_width = 0 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT boxes = [ 10 , 20 , 30 , 50 , 60 , 70 ] NEW_LINE n = len ( boxes ) NEW_LINE print ( maxLevel ( boxes , n ) ) NEW_LINE DEDENT
def twoWaySort ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT arr . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & 1 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 3 , 2 , 7 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE twoWaySort ( arr , n ) ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def isPossibleTriangle ( arr , N ) : NEW_LINE INDENT if N < 3 : NEW_LINE INDENT return False NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( N - 2 ) : NEW_LINE INDENT if arr [ i ] + arr [ i + 1 ] > arr [ i + 2 ] : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT arr = [ 5 , 4 , 3 , 1 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE print ( " Yes " if isPossibleTriangle ( arr , N ) else " No " ) NEW_LINE
MAX = 1000000 NEW_LINE def ksmallest ( arr , n , k ) : NEW_LINE INDENT b = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ arr [ i ] ] = 1 ; NEW_LINE DEDENT for j in range ( 1 , MAX ) : NEW_LINE INDENT if ( b [ j ] != 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT if ( k is not 1 ) : NEW_LINE INDENT return j ; NEW_LINE DEDENT DEDENT DEDENT k = 1 ; NEW_LINE arr = [ 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ksmallest ( arr , n , k ) ) ; NEW_LINE
def mergeTwoHalf ( A , n ) : NEW_LINE INDENT A . sort ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 3 , 8 , - 1 , 7 , 10 ] NEW_LINE n = len ( A ) NEW_LINE mergeTwoHalf ( A , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minDiff ( arr , n , k ) : NEW_LINE INDENT result = + 2147483647 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT result = int ( min ( result , arr [ i + k - 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 10 , 100 , 300 , 200 , 1000 , 20 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE k = 3 NEW_LINE print ( minDiff ( arr , n , k ) ) NEW_LINE
def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE DEDENT i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE INDENT while ( ( i <= mid - 1 ) and ( j <= right ) ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE inv_count = inv_count + ( mid - i ) NEW_LINE DEDENT DEDENT while ( i <= mid - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( left , right + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if ( right > left ) : NEW_LINE INDENT mid = int ( ( right + left ) / 2 ) NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def countSwaps ( arr , n ) : NEW_LINE INDENT temp = [ 0 for i in range ( n ) ] NEW_LINE return _mergeSort ( arr , temp , 0 , n - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 20 , 6 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number ▁ of ▁ swaps ▁ is " , countSwaps ( arr , n ) ) NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( n % 2 == 0 ) NEW_LINE DEDENT n = 101 NEW_LINE print ( " Even " if isEven ( n ) else " Odd " ) NEW_LINE
def findSurpasser ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ j ] > arr [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count , end = " ▁ " ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 2 , 7 , 5 , 3 , 0 , 8 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Given ▁ array ▁ is " ) NEW_LINE printArray ( arr , n ) NEW_LINE print ( " Surpasser Count of array is " ) ; NEW_LINE findSurpasser ( arr , n ) NEW_LINE
def solve ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE a = 0 ; b = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT a = a * 10 + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT b = b * 10 + arr [ i ] NEW_LINE DEDENT DEDENT return a + b NEW_LINE DEDENT arr = [ 6 , 8 , 4 , 5 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum ▁ is ▁ " , solve ( arr , n ) ) NEW_LINE
import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_product = - ( sys . maxsize - 1 ) NEW_LINE for i in range ( 0 , n - 2 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT max_product = max ( max_product , arr [ i ] * arr [ j ] * arr [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return max_product NEW_LINE DEDENT arr = [ 10 , 3 , 5 , 6 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE max = maxProduct ( arr , n ) NEW_LINE if max == - 1 : NEW_LINE INDENT print ( " No ▁ Tripplet ▁ Exits " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Maximum ▁ product ▁ is " , max ) NEW_LINE DEDENT
import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT leftMin = [ - 1 for i in range ( n ) ] NEW_LINE rightMin = [ - 1 for i in range ( n ) ] NEW_LINE leftMax = [ - 1 for i in range ( n ) ] NEW_LINE rightMax = [ - 1 for i in range ( n ) ] NEW_LINE max_product = - sys . maxsize - 1 NEW_LINE max_sum = arr [ 0 ] NEW_LINE min_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT leftMax [ i ] = max_sum NEW_LINE if ( arr [ i ] > max_sum ) : NEW_LINE INDENT max_sum = arr [ i ] NEW_LINE DEDENT leftMin [ i ] = min_sum NEW_LINE if ( arr [ i ] < min_sum ) : NEW_LINE INDENT min_sum = arr [ i ] NEW_LINE DEDENT DEDENT max_sum = arr [ n - 1 ] NEW_LINE min_sum = arr [ n - 1 ] NEW_LINE for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rightMax [ j ] = max_sum NEW_LINE if ( arr [ j ] > max_sum ) : NEW_LINE INDENT max_sum = arr [ j ] NEW_LINE DEDENT rightMin [ j ] = min_sum NEW_LINE if ( arr [ j ] < min_sum ) : NEW_LINE INDENT min_sum = arr [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT max1 = max ( arr [ i ] * leftMax [ i ] * rightMax [ i ] , arr [ i ] * leftMin [ i ] * rightMin [ i ] ) NEW_LINE max2 = max ( arr [ i ] * leftMax [ i ] * rightMin [ i ] , arr [ i ] * leftMin [ i ] * rightMax [ i ] ) NEW_LINE max_product = max ( max_product , max ( max1 , max2 ) ) NEW_LINE DEDENT return max_product NEW_LINE DEDENT arr = [ 1 , 4 , 3 , - 6 , - 7 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE Max = maxProduct ( arr , n ) NEW_LINE if ( Max == - 1 ) : NEW_LINE INDENT print ( " No ▁ Triplet ▁ Exists " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Maximum ▁ product ▁ is " , Max ) NEW_LINE DEDENT
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 10 , - 3 , 5 , 6 , - 20 ] NEW_LINE n = len ( arr ) NEW_LINE _max = maxProduct ( arr , n ) NEW_LINE if _max == - 1 : NEW_LINE INDENT print ( " No ▁ Triplet ▁ Exists " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Maximum ▁ product ▁ is " , _max ) NEW_LINE DEDENT DEDENT
def Substring ( s ) : NEW_LINE INDENT ans , temp = 1 , 1 NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT temp += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , temp ) NEW_LINE temp = 1 NEW_LINE DEDENT DEDENT ans = max ( ans , temp ) NEW_LINE return ans NEW_LINE DEDENT s = " abcdddddeff " NEW_LINE print ( Substring ( s ) ) NEW_LINE
def solve ( n , k ) : NEW_LINE INDENT mini = 0 NEW_LINE x1 = 1 NEW_LINE a = [ 0 for i in range ( k ) ] NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT mini += x1 NEW_LINE a [ i - 1 ] = x1 NEW_LINE x1 += 1 NEW_LINE DEDENT if ( n < mini ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE return NEW_LINE DEDENT rem = n - mini NEW_LINE cnt = int ( rem / k ) NEW_LINE rem = rem % k NEW_LINE for i in range ( k ) : NEW_LINE INDENT a [ i ] += cnt NEW_LINE DEDENT i = k - 1 NEW_LINE while ( i > 0 and rem > 0 ) : NEW_LINE INDENT xx = a [ i - 1 ] * 2 NEW_LINE left = xx - a [ i ] NEW_LINE if ( rem >= left ) : NEW_LINE INDENT a [ i ] = xx NEW_LINE rem -= left NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] += rem NEW_LINE rem = 0 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT sum = a [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT if ( a [ i ] > 2 * a [ i - 1 ] ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE return NEW_LINE DEDENT sum += a [ i ] NEW_LINE DEDENT if ( sum != n ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE return NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 26 NEW_LINE k = 6 NEW_LINE solve ( n , k ) NEW_LINE DEDENT
def maxCoins ( X , Y ) : NEW_LINE INDENT if ( X < Y ) : NEW_LINE INDENT X , Y = Y , X ; NEW_LINE DEDENT coins = X ; NEW_LINE X -= 1 ; NEW_LINE coins += max ( X , Y ) ; NEW_LINE return coins ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 7 ; Y = 5 ; NEW_LINE print ( maxCoins ( X , Y ) ) ; NEW_LINE DEDENT
def findElementsCrossed ( arr , a , b , n ) : NEW_LINE INDENT aa = a NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( a == 0 ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT b -= 1 NEW_LINE a = min ( aa , a + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b -= 1 NEW_LINE DEDENT DEDENT elif ( b == 0 ) : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT elif ( arr [ i ] == 1 and a < aa ) : NEW_LINE INDENT b -= 1 NEW_LINE a = min ( aa , a + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT a -= 1 NEW_LINE DEDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 0 , 1 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE a = 1 NEW_LINE b = 2 NEW_LINE print ( findElementsCrossed ( arr , a , b , n ) ) NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def vowelPairs ( s , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) and isVowel ( s [ i + 1 ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT s = " abaebio " NEW_LINE n = len ( s ) NEW_LINE print ( vowelPairs ( s , n ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def solve ( health , n ) : NEW_LINE INDENT currentgcd = gcd ( health [ 0 ] , health [ 1 ] ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT currentgcd = gcd ( currentgcd , health [ i ] ) NEW_LINE DEDENT return currentgcd NEW_LINE DEDENT health = [ 4 , 6 , 8 , 12 ] NEW_LINE n = len ( health ) NEW_LINE print ( solve ( health , n ) ) NEW_LINE
def Find_Sequence ( array , n ) : NEW_LINE INDENT inc_arr , dec_arr = [ ] , [ ] NEW_LINE inc , dec = - 1 , 1e7 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if inc < array [ i ] < dec : NEW_LINE INDENT if array [ i ] < array [ i + 1 ] : NEW_LINE INDENT inc = array [ i ] NEW_LINE inc_arr . append ( array [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dec = array [ i ] NEW_LINE dec_arr . append ( array [ i ] ) NEW_LINE DEDENT DEDENT elif inc < array [ i ] : NEW_LINE INDENT inc = array [ i ] NEW_LINE inc_arr . append ( array [ i ] ) NEW_LINE DEDENT elif dec > array [ i ] : NEW_LINE INDENT dec = array [ i ] NEW_LINE dec_arr . append ( array [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( inc_arr , dec_arr ) NEW_LINE DEDENT DEDENT arr = [ 5 , 1 , 3 , 6 , 8 , 2 , 9 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE Find_Sequence ( arr , n ) NEW_LINE
def reverse ( n ) : NEW_LINE INDENT rev = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return rev NEW_LINE DEDENT def getSum ( n ) : NEW_LINE INDENT n = reverse ( n ) NEW_LINE sumOdd = 0 NEW_LINE sumEven = 0 NEW_LINE c = 1 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( c % 2 == 0 ) : NEW_LINE INDENT sumEven += n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sumOdd += n % 10 NEW_LINE DEDENT n //= 10 NEW_LINE c += 1 NEW_LINE DEDENT print ( " Sum ▁ odd ▁ = " , sumOdd ) NEW_LINE print ( " Sum ▁ even ▁ = " , sumEven ) NEW_LINE DEDENT n = 457892 NEW_LINE getSum ( n ) NEW_LINE
def bankNotes ( A , B , S , N ) : NEW_LINE INDENT numerator = S - ( B * N ) NEW_LINE denominator = A - B NEW_LINE if ( numerator % denominator == 0 ) : NEW_LINE INDENT return ( numerator // denominator ) NEW_LINE DEDENT return - 1 NEW_LINE DEDENT A , B , S , N = 1 , 2 , 7 , 5 NEW_LINE print ( bankNotes ( A , B , S , N ) ) NEW_LINE
def longestSubstring ( s ) : NEW_LINE INDENT cnt = 1 ; NEW_LINE maxi = 1 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT maxi = max ( cnt , maxi ) ; NEW_LINE cnt = 1 ; NEW_LINE DEDENT DEDENT maxi = max ( cnt , maxi ) ; NEW_LINE return maxi ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ccccdeededff " ; NEW_LINE print ( longestSubstring ( s ) ) ; NEW_LINE DEDENT
def Minimum_Operations ( a , n ) : NEW_LINE INDENT np = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT np [ i ] = np [ i + 1 ] NEW_LINE if ( a [ i ] <= 0 ) : NEW_LINE INDENT np [ i ] += 1 NEW_LINE DEDENT DEDENT pos = 0 NEW_LINE ans = n NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] >= 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE DEDENT ans = min ( ans , pos + np [ i + 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ - 1 , 0 , 1 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( Minimum_Operations ( a , n ) ) NEW_LINE
def findSumofEle ( arr1 , m , arr2 , n , k ) : NEW_LINE INDENT arraySum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT arraySum += arr2 [ i ] NEW_LINE DEDENT mean = arraySum / n NEW_LINE sumOfElements = 0 NEW_LINE difference = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT difference = arr1 [ i ] - mean NEW_LINE if ( ( difference < 0 ) and ( k > ( - 1 ) * difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT if ( ( difference >= 0 ) and ( k > difference ) ) : NEW_LINE INDENT sumOfElements += arr1 [ i ] NEW_LINE DEDENT DEDENT return sumOfElements NEW_LINE DEDENT arr1 = [ 1 , 2 , 3 , 4 , 7 , 9 ] NEW_LINE arr2 = [ 0 , 1 , 2 , 1 , 1 , 4 ] NEW_LINE k = 2 NEW_LINE m = len ( arr1 ) NEW_LINE n = len ( arr2 ) NEW_LINE print ( findSumofEle ( arr1 , m , arr2 , n , k ) ) NEW_LINE
def findIntegers ( n , x , y ) : NEW_LINE INDENT ans = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans . append ( 1 ) NEW_LINE DEDENT if ( y - ( n - 1 ) <= 0 ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE return NEW_LINE DEDENT ans . append ( y - ( n - 1 ) ) NEW_LINE store = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT store += ans [ i ] * ans [ i ] NEW_LINE DEDENT if ( store < x ) : NEW_LINE INDENT print ( " - 1" , end = " " ) NEW_LINE return ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n , x , y = 3 , 254 , 18 NEW_LINE findIntegers ( n , x , y ) NEW_LINE
def Minsteps ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( m > n ) : NEW_LINE INDENT if ( m & 1 ) : NEW_LINE INDENT m += 1 NEW_LINE ans += 1 NEW_LINE DEDENT m //= 2 NEW_LINE ans += 1 NEW_LINE DEDENT return ans + n - m NEW_LINE DEDENT n = 4 NEW_LINE m = 6 NEW_LINE print ( Minsteps ( n , m ) ) NEW_LINE
def getsum ( x ) : NEW_LINE INDENT return int ( ( x * ( x + 1 ) ) / 2 ) NEW_LINE DEDENT def countJumps ( n ) : NEW_LINE INDENT n = abs ( n ) NEW_LINE ans = 0 NEW_LINE while ( getsum ( ans ) < n or ( getsum ( ans ) - n ) & 1 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE print ( countJumps ( n ) ) NEW_LINE DEDENT
def maxCandies ( arr , n ) : NEW_LINE INDENT prevBought = arr [ n - 1 ] ; NEW_LINE candies = prevBought ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT x = min ( prevBought - 1 , arr [ i ] ) ; NEW_LINE if ( x >= 0 ) : NEW_LINE INDENT candies += x ; NEW_LINE prevBought = x ; NEW_LINE DEDENT DEDENT return candies ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 1 , 3 , 6 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( maxCandies ( arr , n ) ) ; NEW_LINE DEDENT
def minChanges ( str , n ) : NEW_LINE INDENT count , zeros , ones = 0 , 0 , 0 NEW_LINE DEDENT ' NEW_LINE INDENT if ( ord ( str [ 0 ] ) != ord ( '1' ) ) : NEW_LINE INDENT count += 1 NEW_LINE ones += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( ord ( str [ i ] ) == ord ( '0' ) ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( zeros > ones ) : NEW_LINE INDENT zeros -= 1 NEW_LINE ones += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "0000" NEW_LINE n = len ( str ) NEW_LINE print ( minChanges ( str , n ) ) NEW_LINE DEDENT
def steps ( cur , x , n ) : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT elif x > 0 : NEW_LINE INDENT return abs ( ( n - cur ) // x ) NEW_LINE DEDENT else : NEW_LINE INDENT return abs ( int ( ( cur - 1 ) / x ) ) NEW_LINE DEDENT DEDENT def countSteps ( curx , cury , n , m , moves ) : NEW_LINE INDENT count = 0 NEW_LINE k = len ( moves ) NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT x = moves [ i ] [ 0 ] NEW_LINE y = moves [ i ] [ 1 ] NEW_LINE stepct = min ( steps ( curx , x , n ) , steps ( cury , y , m ) ) NEW_LINE count += stepct NEW_LINE curx += stepct * x NEW_LINE cury += stepct * y NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m , x , y = 4 , 5 , 1 , 1 NEW_LINE moves = [ [ 1 , 1 ] , [ 1 , 1 ] , [ 0 , - 2 ] ] NEW_LINE print ( countSteps ( x , y , n , m , moves ) ) NEW_LINE DEDENT
def min_elimination ( n , arr ) : NEW_LINE INDENT count = 0 NEW_LINE prev_val = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_val = arr [ i ] ; NEW_LINE if ( curr_val % 2 == prev_val % 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT prev_val = curr_val NEW_LINE DEDENT return count NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( min_elimination ( n , arr ) ) ; NEW_LINE
def getCount ( N ) : NEW_LINE INDENT if ( N % 2 == 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = "9" NEW_LINE for i in range ( 1 , N // 2 ) : NEW_LINE INDENT result = result + "0" NEW_LINE DEDENT return result NEW_LINE DEDENT N = 4 NEW_LINE print ( getCount ( N ) ) NEW_LINE
def canFormTeam ( n , m ) : NEW_LINE INDENT if ( n >= 1 and m >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( m >= 1 and n >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def maxTeams ( n , m ) : NEW_LINE INDENT count = 0 NEW_LINE while ( canFormTeam ( n , m ) ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT n -= 2 NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT m -= 2 NEW_LINE n -= 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE print ( maxTeams ( n , m ) ) NEW_LINE DEDENT
def max ( a , b ) : NEW_LINE INDENT if ( a > b ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT def smallestSide ( a ) : NEW_LINE INDENT a . sort ( reverse = False ) NEW_LINE side1 = a [ 0 ] + a [ 3 ] NEW_LINE side2 = a [ 1 ] + a [ 2 ] NEW_LINE side3 = a [ 0 ] + a [ 1 ] NEW_LINE side4 = a [ 2 ] + a [ 3 ] NEW_LINE side11 = max ( side1 , side2 ) NEW_LINE side12 = max ( side3 , side4 ) NEW_LINE sideOfSquare = max ( side11 , side12 ) NEW_LINE return sideOfSquare NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT side = [ 0 for i in range ( 4 ) ] NEW_LINE print ( " Test ▁ Case ▁ 1" ) NEW_LINE side [ 0 ] = 2 NEW_LINE side [ 1 ] = 2 NEW_LINE side [ 2 ] = 2 NEW_LINE side [ 3 ] = 2 NEW_LINE print ( smallestSide ( side ) ) NEW_LINE print ( " " , ▁ end ▁ = ▁ " " ) NEW_LINE print ( " Test ▁ Case ▁ 2" ) NEW_LINE side [ 0 ] = 100000000000000 NEW_LINE side [ 1 ] = 123450000000000 NEW_LINE side [ 2 ] = 987650000000000 NEW_LINE side [ 3 ] = 987654321000000 NEW_LINE print ( smallestSide ( side ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def find_rectangle ( area ) : NEW_LINE INDENT l , b = 0 , 0 NEW_LINE M = mt . ceil ( mt . sqrt ( area ) ) NEW_LINE ans = 0 NEW_LINE for i in range ( M , 0 , - 1 ) : NEW_LINE INDENT if ( area % i == 0 ) : NEW_LINE INDENT l = ( area // i ) NEW_LINE b = i NEW_LINE break NEW_LINE DEDENT DEDENT print ( " l ▁ = " , l , " , ▁ b ▁ = " , b ) NEW_LINE DEDENT area = 99 NEW_LINE find_rectangle ( area ) NEW_LINE
import math as mt NEW_LINE def sizeSubSet ( a , k , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE s = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % k != 0 or a [ i ] // k not in s ) : NEW_LINE INDENT s . add ( a [ i ] ) NEW_LINE DEDENT DEDENT return len ( s ) NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE k = 2 NEW_LINE print ( sizeSubSet ( a , k , n ) ) NEW_LINE
import math as mt NEW_LINE def minimumSets ( s , y ) : NEW_LINE INDENT cnt = 0 NEW_LINE num = 0 NEW_LINE l = len ( s ) NEW_LINE f = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE if ( num <= y ) : NEW_LINE INDENT f = 1 NEW_LINE if ( f ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT num = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE f = 0 NEW_LINE if ( num <= y ) : NEW_LINE INDENT f = 1 NEW_LINE DEDENT else : NEW_LINE INDENT num = 0 NEW_LINE DEDENT DEDENT DEDENT if ( f ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT s = "1234" NEW_LINE y = 30 NEW_LINE print ( minimumSets ( s , y ) ) NEW_LINE
import sys NEW_LINE def printArr ( b , n ) : NEW_LINE INDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( b [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def ModifiedArray ( a , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = sys . maxsize NEW_LINE b = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( 0 , int ( n / 2 ) , 1 ) : NEW_LINE INDENT b [ i ] = max ( l , a [ i ] - r ) NEW_LINE b [ n - i - 1 ] = a [ i ] - b [ i ] NEW_LINE l = b [ i ] NEW_LINE r = b [ n - i - 1 ] NEW_LINE DEDENT printArr ( b , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE ModifiedArray ( a , 2 * n ) NEW_LINE DEDENT
import sys NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT def maxSum ( a , n ) : NEW_LINE INDENT S = 0 ; NEW_LINE S1 = maxSubArraySum ( a , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += a [ i ] NEW_LINE DEDENT return ( 2 * S1 - S ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ - 35 , 32 , - 24 , 0 , 27 , - 10 , 0 , - 19 ] NEW_LINE n = len ( a ) NEW_LINE print ( maxSum ( a , n ) ) NEW_LINE DEDENT
def minimizeDiff ( arr , n , k ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE if ( ( max_element - min_element ) <= k ) : NEW_LINE INDENT return ( max_element - min_element ) NEW_LINE DEDENT avg = ( max_element + min_element ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > avg ) : NEW_LINE INDENT arr [ i ] -= k NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += k NEW_LINE DEDENT DEDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE return ( max_element - min_element ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 16 , 12 , 9 , 20 ] NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( " Max ▁ height ▁ difference ▁ = " , minimizeDiff ( arr , n , k ) ) NEW_LINE DEDENT
def maxLitres ( budget , plastic , glass , refund ) : NEW_LINE INDENT if glass - refund < plastic : NEW_LINE INDENT ans = max ( ( budget - refund ) // ( glass - refund ) , 0 ) NEW_LINE budget -= ans * ( glass - refund ) NEW_LINE ans += budget // plastic NEW_LINE print ( ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( budget // plastic ) NEW_LINE DEDENT DEDENT budget , plastic , glass , refund = 10 , 11 , 9 , 8 NEW_LINE maxLitres ( budget , plastic , glass , refund ) NEW_LINE
def leastValue ( P , A , N , a ) : NEW_LINE INDENT ans = - 1 NEW_LINE tmp = float ( ' inf ' ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = P - a [ i ] * 0.006 NEW_LINE if abs ( t - A ) < tmp : NEW_LINE INDENT tmp = abs ( t - A ) NEW_LINE ans = i NEW_LINE DEDENT DEDENT return a [ ans ] NEW_LINE DEDENT N , P , A = 2 , 12 , 5 NEW_LINE a = [ 1000 , 2000 ] NEW_LINE print ( leastValue ( P , A , N , a ) ) NEW_LINE
from math import log10 , ceil , pow NEW_LINE def findPermutation ( n ) : NEW_LINE INDENT len = ceil ( log10 ( n ) ) NEW_LINE for i in range ( 0 , len , 1 ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT n = ( ( n / 10 ) + ( n % 10 ) * pow ( 10 , len - i - 1 ) ) NEW_LINE continue NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 132 NEW_LINE print ( int ( findPermutation ( n ) ) ) NEW_LINE DEDENT
def isSellingPossible ( n , a ) : NEW_LINE INDENT c25 = 0 ; NEW_LINE c50 = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( a [ i ] == 25 ) : NEW_LINE INDENT c25 += 1 ; NEW_LINE DEDENT elif ( a [ i ] == 50 ) : NEW_LINE INDENT c50 += 1 ; NEW_LINE if ( c25 == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT c25 -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( c50 > 0 and c25 > 0 ) : NEW_LINE INDENT c50 -= 1 ; NEW_LINE c25 -= 1 ; NEW_LINE DEDENT elif ( c25 >= 3 ) : NEW_LINE INDENT c25 -= 3 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT a = [ 25 , 25 , 50 , 100 ] ; NEW_LINE n = len ( a ) ; NEW_LINE if ( isSellingPossible ( n , a ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def checkIfOverlap ( str ) : NEW_LINE INDENT length = len ( str ) NEW_LINE visited = [ 0 ] * ( length + 1 ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT if str [ i ] == " . " : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( max ( 0 , i - ord ( str [ i ] ) , min ( length , i + ord ( str [ i ] ) ) + 1 ) ) : NEW_LINE INDENT visited [ j ] += 1 NEW_LINE DEDENT DEDENT for i in range ( length ) : NEW_LINE INDENT if visited [ i ] > 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " . 2 . . 2 . " NEW_LINE if checkIfOverlap ( str ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def isCorrectOrder ( n ) : NEW_LINE INDENT flag = True ; NEW_LINE prev = - 1 ; NEW_LINE type = - 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( type == - 1 ) : NEW_LINE INDENT if ( prev == - 1 ) : NEW_LINE INDENT prev = n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT if ( prev > n % 10 ) : NEW_LINE INDENT type = 1 ; NEW_LINE prev = n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE continue ; NEW_LINE DEDENT prev = n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT if ( prev < n % 10 ) : NEW_LINE INDENT flag = False ; NEW_LINE break ; NEW_LINE DEDENT prev = n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT DEDENT return flag ; NEW_LINE DEDENT n = 123454321 ; NEW_LINE if ( isCorrectOrder ( n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def printCoins ( arr , n ) : NEW_LINE INDENT oddSum = 0 NEW_LINE for i in range ( 0 , n , 2 ) : NEW_LINE INDENT oddSum += arr [ i ] NEW_LINE DEDENT evenSum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT evenSum += arr [ i ] NEW_LINE DEDENT if oddSum > evenSum : NEW_LINE INDENT start = 0 NEW_LINE DEDENT else : NEW_LINE INDENT start = 1 NEW_LINE DEDENT for i in range ( start , n , 2 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr1 = [ 8 , 15 , 3 , 7 ] NEW_LINE n = len ( arr1 ) NEW_LINE printCoins ( arr1 , n ) NEW_LINE print ( ) NEW_LINE arr2 = [ 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr2 ) NEW_LINE printCoins ( arr2 , n ) NEW_LINE print ( ) NEW_LINE arr3 = [ 20 , 30 , 2 , 2 , 2 , 10 ] NEW_LINE n = len ( arr3 ) NEW_LINE printCoins ( arr3 , n ) NEW_LINE DEDENT
def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = - arr [ i ] NEW_LINE DEDENT sum_here = arr [ 0 ] NEW_LINE max_sum = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum_here = max ( sum_here + arr [ i ] , arr [ i ] ) NEW_LINE max_sum = max ( max_sum , sum_here ) NEW_LINE DEDENT return ( - 1 ) * max_sum NEW_LINE DEDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Smallest ▁ sum : " , smallestSumSubarr ( arr , n ) ) NEW_LINE
def printLargest ( a , n ) : NEW_LINE INDENT max = - 1 NEW_LINE ind = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE while ( num ) : NEW_LINE INDENT r = num % 10 ; NEW_LINE num = num / 10 ; NEW_LINE if ( num == 0 ) : NEW_LINE INDENT if ( max < r ) : NEW_LINE INDENT max = r NEW_LINE ind = i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( ind , n ) : NEW_LINE INDENT print ( a [ i ] , end = ' ' ) , NEW_LINE DEDENT for i in range ( 0 , ind ) : NEW_LINE INDENT print ( a [ i ] , end = ' ' ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 54 , 546 , 548 , 60 ] NEW_LINE n = len ( a ) NEW_LINE printLargest ( a , n ) NEW_LINE DEDENT
def MinOperation ( a , n , k ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != 1 and a [ i ] > k ) : NEW_LINE INDENT result = ( result + min ( a [ i ] % k , k - a [ i ] % k ) ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + k - a [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE print ( MinOperation ( arr , n , k ) ) NEW_LINE DEDENT
def maxProductSubset ( a , n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return a [ 0 ] NEW_LINE DEDENT max_neg = - 999999999999 NEW_LINE count_neg = 0 NEW_LINE count_zero = 0 NEW_LINE prod = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] == 0 : NEW_LINE INDENT count_zero += 1 NEW_LINE continue NEW_LINE DEDENT if a [ i ] < 0 : NEW_LINE INDENT count_neg += 1 NEW_LINE max_neg = max ( max_neg , a [ i ] ) NEW_LINE DEDENT prod = prod * a [ i ] NEW_LINE DEDENT if count_zero == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if count_neg & 1 : NEW_LINE INDENT if ( count_neg == 1 and count_zero > 0 and count_zero + count_neg == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT prod = int ( prod / max_neg ) NEW_LINE DEDENT return prod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 1 , - 1 , - 2 , 4 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( maxProductSubset ( a , n ) ) NEW_LINE DEDENT
import math NEW_LINE def digitsNum ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT if ( N % 9 != 0 ) : NEW_LINE INDENT print ( N % 9 , end = " " ) NEW_LINE DEDENT for i in range ( 1 , int ( N / 9 ) + 1 ) : NEW_LINE INDENT print ( "9" , end = " " ) NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( "0" , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 5 NEW_LINE print ( " The ▁ number ▁ is ▁ : ▁ " , end = " " ) NEW_LINE digitsNum ( N ) NEW_LINE
import math NEW_LINE def printVector ( v ) : NEW_LINE INDENT print ( len ( v ) ) NEW_LINE for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def findTwoGroup ( n ) : NEW_LINE INDENT sum = n * ( n + 1 ) / 2 NEW_LINE group1Sum = sum / 2 NEW_LINE group1 = [ ] NEW_LINE group2 = [ ] NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( group1Sum - i >= 0 ) : NEW_LINE INDENT group1 . append ( i ) NEW_LINE group1Sum -= i NEW_LINE DEDENT else : NEW_LINE INDENT group2 . append ( i ) NEW_LINE DEDENT DEDENT printVector ( group1 ) NEW_LINE printVector ( group2 ) NEW_LINE DEDENT n = 5 NEW_LINE findTwoGroup ( n ) NEW_LINE
def maxDifference ( arr , N , k ) : NEW_LINE INDENT S = 0 NEW_LINE S1 = 0 NEW_LINE max_difference = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT S += arr [ i ] NEW_LINE DEDENT arr . sort ( reverse = True ) NEW_LINE M = max ( k , N - k ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT max_difference = S1 - ( S - S1 ) NEW_LINE return max_difference NEW_LINE DEDENT arr = [ 8 , 4 , 5 , 2 , 10 ] NEW_LINE N = len ( arr ) NEW_LINE k = 2 NEW_LINE print ( maxDifference ( arr , N , k ) ) NEW_LINE
def minproduct ( a , b , n , k ) : NEW_LINE INDENT diff = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pro = a [ i ] * b [ i ] NEW_LINE res = res + pro NEW_LINE if ( pro < 0 and b [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro < 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] < 0 ) : NEW_LINE INDENT temp = ( a [ i ] + 2 * k ) * b [ i ] NEW_LINE DEDENT elif ( pro > 0 and a [ i ] > 0 ) : NEW_LINE INDENT temp = ( a [ i ] - 2 * k ) * b [ i ] NEW_LINE DEDENT d = abs ( pro - temp ) NEW_LINE if ( d > diff ) : NEW_LINE INDENT diff = d NEW_LINE DEDENT DEDENT return res - diff NEW_LINE DEDENT a = [ 2 , 3 , 4 , 5 , 4 ] NEW_LINE b = [ 3 , 4 , 2 , 3 , 2 ] NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( minproduct ( a , b , n , k ) ) NEW_LINE
def count ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT rem = n % 4 NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return n // 4 NEW_LINE DEDENT if ( rem == 1 ) : NEW_LINE INDENT if ( n < 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 9 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 2 ) : NEW_LINE INDENT return ( n - 6 ) // 4 + 1 NEW_LINE DEDENT if ( rem == 3 ) : NEW_LINE INDENT if ( n < 15 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n - 15 ) // 4 + 2 NEW_LINE DEDENT DEDENT n = 90 NEW_LINE print ( count ( n ) ) NEW_LINE n = 143 NEW_LINE print ( count ( n ) ) NEW_LINE
def minRotation ( input , unlock_code ) : NEW_LINE INDENT rotation = 0 ; NEW_LINE while ( input > 0 or unlock_code > 0 ) : NEW_LINE INDENT input_digit = input % 10 ; NEW_LINE code_digit = unlock_code % 10 ; NEW_LINE rotation += min ( abs ( input_digit - code_digit ) , 10 - abs ( input_digit - code_digit ) ) ; NEW_LINE input = int ( input / 10 ) ; NEW_LINE unlock_code = int ( unlock_code / 10 ) ; NEW_LINE DEDENT return rotation ; NEW_LINE DEDENT input = 28756 ; NEW_LINE unlock_code = 98234 ; NEW_LINE print ( " Minimum ▁ Rotation ▁ = " , minRotation ( input , unlock_code ) ) ; NEW_LINE
import math as mt NEW_LINE def preprocess ( coin , n ) : NEW_LINE INDENT coin . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT coin [ i ] += coin [ i - 1 ] NEW_LINE DEDENT DEDENT def minCost ( coin , n , k ) : NEW_LINE INDENT coins_needed = mt . ceil ( 1.0 * n / ( k + 1 ) ) NEW_LINE return coin [ coins_needed - 1 ] NEW_LINE DEDENT coin = [ 8 , 5 , 3 , 10 , 2 , 1 , 15 , 25 ] NEW_LINE n = len ( coin ) NEW_LINE preprocess ( coin , n ) NEW_LINE k = 3 NEW_LINE print ( minCost ( coin , n , k ) ) NEW_LINE k = 7 NEW_LINE print ( minCost ( coin , n , k ) ) NEW_LINE
def maximumSum ( arr , n , k ) : NEW_LINE INDENT for i in range ( 1 , k + 1 ) : NEW_LINE INDENT min = + 2147483647 NEW_LINE index = - 1 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] < min ) : NEW_LINE INDENT min = arr [ j ] NEW_LINE index = j NEW_LINE DEDENT DEDENT if ( min == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT arr [ index ] = - arr [ index ] NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ - 2 , 0 , 5 , - 1 , 2 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( maximumSum ( arr , n , k ) ) NEW_LINE
maxLen = 10 NEW_LINE dp = [ 0 for i in range ( maxLen ) ] NEW_LINE v = [ 0 for i in range ( maxLen ) ] NEW_LINE def maxSum ( arr , i , n ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] ) : NEW_LINE INDENT return dp [ i ] NEW_LINE DEDENT v [ i ] = 1 NEW_LINE dp [ i ] = max ( maxSum ( arr , i + 1 , n ) , arr [ i ] + maxSum ( arr , i + 2 , n ) ) NEW_LINE return dp [ i ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 9 , 7 , 33 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , 0 , n ) ) NEW_LINE DEDENT
N = 5 NEW_LINE def func ( idx , cur , a , dp , n , x ) : NEW_LINE INDENT if ( idx == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ cur ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] [ cur ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( cur == 0 ) : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 0 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE DEDENT elif ( cur == 1 ) : NEW_LINE INDENT ans = max ( ans , x * a [ idx ] + func ( idx + 1 , 1 , a , dp , n , x ) ) NEW_LINE ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( ans , a [ idx ] + func ( idx + 1 , 2 , a , dp , n , x ) ) NEW_LINE DEDENT dp [ idx ] [ cur ] = ans NEW_LINE return dp [ idx ] [ cur ] NEW_LINE DEDENT def getMaximumSum ( a , n , x ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( 3 ) ] for j in range ( n ) ] NEW_LINE maxi = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxi = max ( maxi , func ( i , 0 , a , dp , n , x ) ) NEW_LINE DEDENT return maxi NEW_LINE DEDENT a = [ - 3 , 8 , - 2 , 1 , - 6 ] NEW_LINE n = len ( a ) NEW_LINE x = - 1 NEW_LINE print ( getMaximumSum ( a , n , x ) ) NEW_LINE
N = 100 NEW_LINE def pre_process ( dp , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - j + 1 ) : NEW_LINE INDENT if ( j <= 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = True NEW_LINE DEDENT DEDENT elif ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def countPairs ( s ) : NEW_LINE INDENT dp = [ [ False for i in range ( N ) ] for j in range ( N ) ] NEW_LINE pre_process ( dp , s ) NEW_LINE n = len ( s ) NEW_LINE left = [ 0 for i in range ( n ) ] NEW_LINE right = [ 0 for i in range ( n ) ] NEW_LINE left [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( dp [ j ] [ i ] == 1 ) : NEW_LINE INDENT left [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT right [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ i ] [ j ] == 1 ) : NEW_LINE INDENT right [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT ans += left [ i ] * right [ i + 1 ] NEW_LINE DEDENT return ans NEW_LINE DEDENT s = " abacaba " NEW_LINE print ( countPairs ( s ) ) NEW_LINE
N = 100 NEW_LINE def pre_process ( dp , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - j + 1 ) : NEW_LINE INDENT if ( j <= 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = True NEW_LINE DEDENT DEDENT elif ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def answerQuery ( l , r , dp ) : NEW_LINE INDENT if ( dp [ l ] [ r ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT s = " abaaab " NEW_LINE dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE pre_process ( dp , s ) NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT answerQuery ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , dp ) NEW_LINE DEDENT
N = 100005 NEW_LINE def LIS ( a , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE d = [ 0 for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ a [ i ] ] = 1 NEW_LINE for j in range ( 2 , a [ i ] ) : NEW_LINE INDENT if j * j > a [ i ] : NEW_LINE INDENT break NEW_LINE DEDENT if ( a [ i ] % j == 0 ) : NEW_LINE INDENT dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ j ] ] + 1 ) NEW_LINE dp [ a [ i ] ] = max ( dp [ a [ i ] ] , dp [ d [ a [ i ] // j ] ] + 1 ) NEW_LINE d [ j ] = a [ i ] NEW_LINE d [ a [ i ] // j ] = a [ i ] NEW_LINE DEDENT DEDENT ans = max ( ans , dp [ a [ i ] ] ) NEW_LINE d [ a [ i ] ] = a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( LIS ( a , n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT dp [ i ] = ( ( 4 * ( i * i ) ) - 6 * ( i - 1 ) + dp [ i - 2 ] ) NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
n = 3 NEW_LINE MAX = 60 NEW_LINE dp = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ] NEW_LINE v = [ [ [ 0 for i in range ( 30 ) ] for i in range ( 30 ) ] for i in range ( MAX + 1 ) ] NEW_LINE def findCount ( mat , i , j , m ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT if ( m == mat [ 0 ] [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( m < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( v [ i ] [ j ] [ m ] > 0 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT v [ i ] [ j ] [ m ] = True NEW_LINE dp [ i ] [ j ] [ m ] = ( findCount ( mat , i - 1 , j , m - mat [ i ] [ j ] ) + findCount ( mat , i , j - 1 , m - mat [ i ] [ j ] ) ) NEW_LINE return dp [ i ] [ j ] [ m ] NEW_LINE DEDENT mat = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] NEW_LINE m = 5 NEW_LINE print ( findCount ( mat , n - 1 , n - 1 , m ) ) NEW_LINE
def findMinimumDeletion ( l , r , dp , s ) : NEW_LINE INDENT if l > r : NEW_LINE INDENT return 0 NEW_LINE DEDENT if l == r : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ l ] [ r ] != - 1 : NEW_LINE INDENT return dp [ l ] [ r ] NEW_LINE DEDENT res = 1 + findMinimumDeletion ( l + 1 , r , dp , s ) NEW_LINE for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if s [ l ] == s [ i ] : NEW_LINE INDENT res = min ( res , findMinimumDeletion ( l + 1 , i - 1 , dp , s ) + findMinimumDeletion ( i , r , dp , s ) ) NEW_LINE DEDENT DEDENT dp [ l ] [ r ] = res NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcddcba " NEW_LINE n = len ( s ) NEW_LINE N = 10 NEW_LINE dp = [ [ - 1 for i in range ( N ) ] for j in range ( N ) ] NEW_LINE print ( findMinimumDeletion ( 0 , n - 1 , dp , s ) ) NEW_LINE DEDENT
N = 5005 NEW_LINE n , k = 0 , 0 NEW_LINE gr = [ [ ] for i in range ( N ) ] NEW_LINE d = [ [ 0 for i in range ( 505 ) ] for i in range ( N ) ] NEW_LINE ans = 0 NEW_LINE def Add_edge ( x , y ) : NEW_LINE INDENT gr [ x ] . append ( y ) NEW_LINE gr [ y ] . append ( x ) NEW_LINE DEDENT def dfs ( v , par ) : NEW_LINE INDENT global ans NEW_LINE d [ v ] [ 0 ] = 1 NEW_LINE for i in gr [ v ] : NEW_LINE INDENT if ( i != par ) : NEW_LINE INDENT dfs ( i , v ) NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT ans += d [ i ] [ j - 1 ] * d [ v ] [ k - j ] NEW_LINE DEDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT d [ v ] [ j ] += d [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 5 NEW_LINE k = 2 NEW_LINE Add_edge ( 1 , 2 ) NEW_LINE Add_edge ( 2 , 3 ) NEW_LINE Add_edge ( 3 , 4 ) NEW_LINE Add_edge ( 2 , 5 ) NEW_LINE dfs ( 1 , 0 ) NEW_LINE print ( ans ) NEW_LINE
def findXorSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT c_odd = 0 NEW_LINE odd = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT odd = ( ~ odd ) NEW_LINE DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 NEW_LINE DEDENT DEDENT for j in range ( n ) : NEW_LINE INDENT Sum += ( mul * c_odd ) NEW_LINE if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT c_odd = ( n - j - c_odd ) NEW_LINE DEDENT DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 3 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findXorSum ( arr , n ) ) NEW_LINE
n = 4 NEW_LINE m = 4 NEW_LINE def calcProbability ( M , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( m ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT dp [ 0 ] [ j ] = M [ 0 ] [ j ] NEW_LINE Sum [ 0 ] += dp [ 0 ] [ j ] NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] += ( dp [ i - 1 ] [ j ] / Sum [ i - 1 ] + M [ i ] [ j ] ) NEW_LINE Sum [ i ] += dp [ i ] [ j ] NEW_LINE DEDENT DEDENT return dp [ n - 1 ] [ k - 1 ] / Sum [ n - 1 ] NEW_LINE DEDENT M = [ [ 1 , 1 , 0 , 3 ] , [ 2 , 3 , 2 , 3 ] , [ 9 , 3 , 0 , 2 ] , [ 2 , 3 , 2 , 2 ] ] NEW_LINE k = 3 NEW_LINE print ( calcProbability ( M , k ) ) NEW_LINE
import math as mt NEW_LINE def MaximumNumbers ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE remIndex = [ - 1 for i in range ( 3 ) ] NEW_LINE remIndex [ 0 ] = 0 NEW_LINE res = [ - 1 for i in range ( n + 1 ) ] NEW_LINE r = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT r = ( r + ord ( string [ i - 1 ] ) - ord ( '0' ) ) % 3 NEW_LINE res [ i ] = res [ i - 1 ] NEW_LINE if ( remIndex [ r ] != - 1 ) : NEW_LINE INDENT res [ i ] = max ( res [ i ] , res [ remIndex [ r ] ] + 1 ) NEW_LINE DEDENT remIndex [ r ] = i + 1 NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT s = "12345" NEW_LINE print ( MaximumNumbers ( s ) ) NEW_LINE
Max = 4 NEW_LINE c = 2 NEW_LINE def countPaths ( Sum , get , m , n , dp ) : NEW_LINE INDENT if ( Sum < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( Sum == 0 ) : NEW_LINE INDENT return get NEW_LINE DEDENT if ( dp [ Sum ] [ get ] != - 1 ) : NEW_LINE INDENT return dp [ Sum ] [ get ] NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT res += countPaths ( Sum - i , 1 , m , n , dp ) NEW_LINE res += countPaths ( Sum - i , get , m , n , dp ) NEW_LINE DEDENT DEDENT dp [ Sum ] [ get ] = res NEW_LINE return dp [ Sum ] [ get ] NEW_LINE DEDENT n = 3 NEW_LINE m = 2 NEW_LINE x = 3 NEW_LINE dp = [ [ - 1 for i in range ( 2 ) ] for i in range ( Max + 1 ) ] NEW_LINE for i in range ( Max + 1 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT print ( countPaths ( x , 0 , m , n , dp ) ) NEW_LINE
MAX_K = 15 NEW_LINE fac = [ 1 for i in range ( MAX_K ) ] NEW_LINE def factorial ( k ) : NEW_LINE INDENT fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , k + 2 ) : NEW_LINE INDENT fac [ i ] = ( i * fac [ i - 1 ] ) NEW_LINE DEDENT DEDENT def bin ( a , b ) : NEW_LINE INDENT ans = fac [ a ] // ( fac [ a - b ] * fac [ b ] ) NEW_LINE return ans NEW_LINE DEDENT def sumofn ( n , k ) : NEW_LINE INDENT p = 0 NEW_LINE num1 , temp = 1 , 1 NEW_LINE arr = [ 1 for i in range ( 1000 ) ] NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j == 1 : NEW_LINE INDENT num1 = ( n * ( n + 1 ) ) // 2 NEW_LINE arr [ p ] = num1 NEW_LINE p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = pow ( n + 1 , j + 1 ) - 1 - n NEW_LINE for s in range ( 1 , j ) : NEW_LINE INDENT temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) NEW_LINE DEDENT temp = temp // ( j + 1 ) NEW_LINE arr [ p ] = temp NEW_LINE p += 1 NEW_LINE DEDENT DEDENT temp = arr [ p - 1 ] NEW_LINE return temp NEW_LINE DEDENT n , k = 5 , 2 NEW_LINE factorial ( k ) NEW_LINE print ( sumofn ( n , k ) ) NEW_LINE
max = 4 NEW_LINE def countWays ( index , cnt , dp , n , m , k ) : NEW_LINE INDENT if ( index == n ) : NEW_LINE INDENT if ( cnt == k ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( dp [ index ] [ cnt ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ cnt ] NEW_LINE DEDENT ans = 0 NEW_LINE ans += countWays ( index + 1 , cnt , dp , n , m , k ) NEW_LINE ans += ( m - 1 ) * countWays ( index + 1 , cnt + 1 , dp , n , m , k ) NEW_LINE dp [ index ] [ cnt ] = ans NEW_LINE return dp [ index ] [ cnt ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE k = 2 NEW_LINE dp = [ [ - 1 for x in range ( n + 1 ) ] for y in range ( max ) ] NEW_LINE print ( m * countWays ( 1 , 0 , dp , n , m , k ) ) NEW_LINE DEDENT
def calculateEvenSum ( n ) : NEW_LINE INDENT if n <= 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( 2 * n + 1 ) NEW_LINE fibo [ 0 ] , fibo [ 1 ] = 0 , 1 NEW_LINE sum = 0 NEW_LINE for i in range ( 2 , 2 * n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE if i % 2 == 0 : NEW_LINE INDENT sum += fibo [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 8 NEW_LINE print ( " Even ▁ indexed ▁ Fibonacci ▁ Sum ▁ upto " , n , " terms : " , calculateEvenSum ( n ) ) NEW_LINE DEDENT
MAX = 32768 NEW_LINE arr = [ None ] * ( 2 * MAX ) NEW_LINE def gouldSequence ( ) : NEW_LINE INDENT arr [ 0 ] = 1 NEW_LINE i = 1 NEW_LINE p = 1 NEW_LINE while i <= MAX : NEW_LINE INDENT j = 0 NEW_LINE while j < i : NEW_LINE INDENT arr [ i + j ] = 2 * arr [ j ] NEW_LINE j += 1 NEW_LINE DEDENT i = ( 1 << p ) NEW_LINE p += 1 NEW_LINE DEDENT DEDENT def printSequence ( n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT gouldSequence ( ) NEW_LINE n = 16 NEW_LINE printSequence ( n ) NEW_LINE DEDENT
def MatrixChainOrder ( p , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT dp [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 1 , n - 1 ) : NEW_LINE INDENT for i in range ( n - L ) : NEW_LINE INDENT dp [ i ] [ i + L ] = min ( dp [ i + 1 ] [ i + L ] + p [ i - 1 ] * p [ i ] * p [ i + L ] , dp [ i ] [ i + L - 1 ] + p [ i - 1 ] * p [ i + L - 1 ] * p [ i + L ] ) NEW_LINE DEDENT DEDENT return dp [ 1 ] [ n - 1 ] NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 30 ] NEW_LINE size = len ( arr ) NEW_LINE print ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is " , MatrixChainOrder ( arr , size ) ) NEW_LINE
def CommomSubsequencesCount ( s , t ) : NEW_LINE INDENT n1 = len ( s ) NEW_LINE n2 = len ( t ) NEW_LINE dp = [ [ 0 for i in range ( n2 + 1 ) ] for i in range ( n1 + 1 ) ] NEW_LINE for i in range ( 1 , n1 + 1 ) : NEW_LINE INDENT for j in range ( 1 , n2 + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == t [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( 1 + dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i - 1 ] [ j ] - dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n1 ] [ n2 ] NEW_LINE DEDENT s = " ajblqcpdz " NEW_LINE t = " aefcnbtdi " NEW_LINE print ( CommomSubsequencesCount ( s , t ) ) NEW_LINE
fib = [ 0 ] * 43 NEW_LINE def fibonacci ( ) : NEW_LINE INDENT fib [ 0 ] = 1 NEW_LINE fib [ 1 ] = 2 NEW_LINE for i in range ( 2 , 43 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DEDENT def rec ( x , y , last ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT if x == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT Sum , i = 0 , last NEW_LINE while i >= 0 and fib [ i ] * y >= x : NEW_LINE INDENT if fib [ i ] > x : NEW_LINE INDENT i -= 1 NEW_LINE continue NEW_LINE DEDENT Sum += rec ( x - fib [ i ] , y - 1 , i ) NEW_LINE i -= 1 NEW_LINE DEDENT return Sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT fibonacci ( ) NEW_LINE n , k = 13 , 3 NEW_LINE print ( " Possible ▁ ways ▁ are : " , rec ( n , k , 42 ) ) NEW_LINE DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp = [ None ] * n NEW_LINE if n == 1 : NEW_LINE INDENT return cost [ 0 ] NEW_LINE DEDENT dp [ 0 ] = cost [ 0 ] NEW_LINE dp [ 1 ] = cost [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] NEW_LINE DEDENT return min ( dp [ n - 2 ] , dp [ n - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 16 , 19 , 10 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT
def minimumCost ( cost , n ) : NEW_LINE INDENT dp1 = 0 NEW_LINE dp2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp0 = cost [ i ] + min ( dp1 , dp2 ) NEW_LINE dp2 = dp1 NEW_LINE dp1 = dp0 NEW_LINE DEDENT return min ( dp1 , dp2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 3 , 1 , 7 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT
def editDistanceWith2Ops ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for x in range ( n + 1 ) ] for y in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT lcs = L [ m ] [ n ] NEW_LINE return ( m - lcs ) + ( n - lcs ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = " abc " NEW_LINE Y = " acd " NEW_LINE print ( editDistanceWith2Ops ( X , Y ) ) NEW_LINE DEDENT
def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = " AGGTAB " NEW_LINE Y = " GXTXAYB " NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( " Length ▁ of ▁ LCS : " , lcs ( X , Y , m , n ) ) NEW_LINE DEDENT
def countPaths ( n ) : NEW_LINE INDENT zB = 1 NEW_LINE zADC = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT nzB = zADC * 3 NEW_LINE nzADC = ( zADC * 2 + zB ) NEW_LINE zB = nzB NEW_LINE zADC = nzADC NEW_LINE DEDENT return zB NEW_LINE DEDENT n = 3 NEW_LINE print ( countPaths ( n ) ) NEW_LINE
def lds ( arr , n ) : NEW_LINE INDENT lds = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lds [ i ] ) : NEW_LINE INDENT max = lds [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ LDS ▁ is " , lds ( arr , n ) ) NEW_LINE DEDENT
MAX = 100 ; NEW_LINE def binomialCoeff ( C , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] ; NEW_LINE DEDENT DEDENT return C ; NEW_LINE DEDENT def sumOfproduct ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE C = [ 0 ] * MAX ; NEW_LINE C = binomialCoeff ( C , n ) ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += C [ i ] * C [ i + 1 ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( sumOfproduct ( n ) ) ; NEW_LINE
MAX = 100 NEW_LINE def binomialCoeff ( n , C ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) , - 1 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT def summation ( n ) : NEW_LINE INDENT C = [ 0 ] * MAX NEW_LINE binomialCoeff ( n , C ) NEW_LINE sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += ( i * C [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] ; NEW_LINE DEDENT DEDENT return C [ k ] ; NEW_LINE DEDENT def countArray ( N , K ) : NEW_LINE INDENT return binomialCoeff ( K - 1 , N - 1 ) ; NEW_LINE DEDENT N = 2 ; NEW_LINE K = 3 ; NEW_LINE print ( countArray ( N , K ) ) ; NEW_LINE
def findMaxVal ( arr , n , num , maxLimit ) : NEW_LINE INDENT ind = - 1 ; NEW_LINE val = - 1 ; NEW_LINE dp = [ [ 0 for i in range ( maxLimit + 1 ) ] for j in range ( n ) ] ; NEW_LINE for ind in range ( n ) : NEW_LINE INDENT for val in range ( maxLimit + 1 ) : NEW_LINE INDENT if ( ind == 0 ) : NEW_LINE INDENT if ( num - arr [ ind ] == val or num + arr [ ind ] == val ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( val - arr [ ind ] >= 0 and val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT if ( dp [ ind - 1 ] [ val - arr [ ind ] ] == 1 or dp [ ind - 1 ] [ val + arr [ ind ] ] == 1 ) : NEW_LINE INDENT dp [ ind ] [ val ] = 1 ; NEW_LINE DEDENT DEDENT elif ( val - arr [ ind ] >= 0 ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val - arr [ ind ] ] ; NEW_LINE DEDENT elif ( val + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT dp [ ind ] [ val ] = dp [ ind - 1 ] [ val + arr [ ind ] ] ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ ind ] [ val ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT for val in range ( maxLimit , - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ n - 1 ] [ val ] == 1 ) : NEW_LINE INDENT return val ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 1 ; NEW_LINE arr = [ 3 , 10 , 6 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE maxLimit = 15 ; NEW_LINE print ( findMaxVal ( arr , n , num , maxLimit ) ) ; NEW_LINE DEDENT
def gen ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 4 * gen ( n // 2 ) NEW_LINE DEDENT elif n % 2 == 1 : NEW_LINE INDENT return 4 * gen ( n // 2 ) + 1 NEW_LINE DEDENT DEDENT def moserDeBruijn ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( gen ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE print ( " First " , n , " terms ▁ of ▁ " , " Moser - de ▁ Bruijn ▁ Sequence : " ) NEW_LINE moserDeBruijn ( n ) NEW_LINE
def minSumPath ( A ) : NEW_LINE INDENT memo = [ None ] * len ( A ) NEW_LINE n = len ( A ) - 1 NEW_LINE for i in range ( len ( A [ n ] ) ) : NEW_LINE INDENT memo [ i ] = A [ n ] [ i ] NEW_LINE DEDENT for i in range ( len ( A ) - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( len ( A [ i ] ) ) : NEW_LINE INDENT memo [ j ] = A [ i ] [ j ] + min ( memo [ j ] , memo [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT return memo [ 0 ] NEW_LINE DEDENT A = [ [ 2 ] , [ 3 , 9 ] , [ 1 , 6 , 7 ] ] NEW_LINE print ( minSumPath ( A ) ) NEW_LINE
MAX = 100 NEW_LINE dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT for j in range ( 0 , MAX ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT def countRemovals ( a , i , j , k ) : NEW_LINE INDENT global dp NEW_LINE if ( i >= j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( a [ j ] - a [ i ] ) <= k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT elif ( ( a [ j ] - a [ i ] ) > k ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + min ( countRemovals ( a , i + 1 , j , k ) , countRemovals ( a , i , j - 1 , k ) ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def removals ( a , n , k ) : NEW_LINE INDENT a . sort ( ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return countRemovals ( a , 0 , n - 1 , k ) NEW_LINE DEDENT DEDENT a = [ 1 , 3 , 4 , 9 , 10 , 11 , 12 , 17 , 20 ] NEW_LINE n = len ( a ) NEW_LINE k = 4 NEW_LINE print ( removals ( a , n , k ) ) NEW_LINE
def countPairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] & a [ j ] ) == 0 : NEW_LINE INDENT count += 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = [ 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( countPairs ( a , n ) ) NEW_LINE
import numpy as np NEW_LINE import sys NEW_LINE dp = np . zeros ( ( 1000 , 1000 ) ) NEW_LINE def sum ( a , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for m in range ( i , j + 1 ) : NEW_LINE INDENT ans = ( ans + a [ m ] ) % 100 NEW_LINE DEDENT return ans NEW_LINE DEDENT def solve ( a , i , j ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT dp [ i ] [ j ] = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , ( solve ( a , i , k ) + solve ( a , k + 1 , j ) + ( sum ( a , i , k ) * sum ( a , k + 1 , j ) ) ) ) NEW_LINE DEDENT return dp [ i ] [ j ] NEW_LINE DEDENT def initialize ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 40 , 60 , 20 ] NEW_LINE n = len ( a ) NEW_LINE initialize ( n ) NEW_LINE print ( int ( solve ( a , 0 , n - 1 ) ) ) NEW_LINE DEDENT
def reverseFibonacci ( n ) : NEW_LINE INDENT a = [ 0 ] * n NEW_LINE a [ 0 ] = 0 NEW_LINE a [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT a [ i ] = a [ i - 2 ] + a [ i - 1 ] NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE reverseFibonacci ( n ) NEW_LINE
def find_prob ( N , P ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 0 NEW_LINE dp [ 2 ] = P NEW_LINE dp [ 3 ] = 1 - P NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT dp [ i ] = ( P ) * dp [ i - 2 ] + ( 1 - P ) * dp [ i - 3 ] NEW_LINE DEDENT return dp [ N ] NEW_LINE DEDENT n = 5 NEW_LINE p = 0.2 NEW_LINE print ( round ( find_prob ( n , p ) , 2 ) ) NEW_LINE
N = 5 NEW_LINE def printHosoya ( n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE dp [ 0 ] [ 0 ] = dp [ 1 ] [ 0 ] = dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 2 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 2 ] [ j - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printHosoya ( n ) NEW_LINE
MAX = 100 NEW_LINE import numpy as np NEW_LINE def numberofways ( n , m ) : NEW_LINE INDENT dp = np . zeros ( ( n + 2 , n + 2 ) ) NEW_LINE dp [ 0 ] [ n + 1 ] = 1 NEW_LINE for k in range ( n , m - 1 , - 1 ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ k ] = dp [ i ] [ k + 1 ] NEW_LINE if ( i - k >= 0 ) : NEW_LINE INDENT dp [ i ] [ k ] = ( dp [ i ] [ k ] + dp [ i - k ] [ k ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m = 3 , 1 NEW_LINE print ( numberofways ( n , m ) ) NEW_LINE DEDENT
def zigzag ( n , k ) : NEW_LINE INDENT if ( n == 0 and k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return zigzag ( n , k - 1 ) + zigzag ( n - 1 , n - k ) ; NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( zigzag ( n , k ) ) NEW_LINE
def eulerian ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( m + 1 ) ] for y in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , m + 1 ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( ( ( i - j ) * dp [ i - 1 ] [ j - 1 ] ) + ( ( j + 1 ) * dp [ i - 1 ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ m ] NEW_LINE DEDENT n = 3 NEW_LINE m = 1 NEW_LINE print ( eulerian ( n , m ) ) NEW_LINE
def dealnnoy ( n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return dealnnoy ( m - 1 , n ) + dealnnoy ( m - 1 , n - 1 ) + dealnnoy ( m , n - 1 ) NEW_LINE DEDENT n = 3 NEW_LINE m = 4 ; NEW_LINE print ( dealnnoy ( n , m ) ) NEW_LINE
def dealnnoy ( n , m ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n + 1 ) ] for x in range ( m + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT dp [ 0 ] [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] + dp [ i ] [ j - 1 ] ; NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT n = 3 NEW_LINE m = 4 NEW_LINE print ( dealnnoy ( n , m ) ) NEW_LINE
def longestAlternating ( arr , n ) : NEW_LINE INDENT count = [ None ] * n NEW_LINE count [ n - 1 ] = 1 NEW_LINE i = n - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( arr [ i ] * arr [ i + 1 ] < 0 ) : NEW_LINE INDENT count [ i ] = count [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count [ i ] = 1 ; NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT i = 0 NEW_LINE while i < n : NEW_LINE INDENT print ( count [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT a = [ - 5 , - 1 , - 1 , 2 , - 2 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE longestAlternating ( a , n ) ; NEW_LINE
def maxDP ( n ) : NEW_LINE INDENT res = list ( ) NEW_LINE res . append ( 0 ) NEW_LINE res . append ( 1 ) NEW_LINE i = 2 NEW_LINE while i < n + 1 : NEW_LINE INDENT res . append ( max ( i , ( res [ int ( i / 2 ) ] + res [ int ( i / 3 ) ] + res [ int ( i / 4 ) ] + res [ int ( i / 5 ) ] ) ) ) NEW_LINE i = i + 1 NEW_LINE DEDENT return res [ n ] NEW_LINE DEDENT n = 60 NEW_LINE print ( " MaxSum ▁ = " , maxDP ( n ) ) NEW_LINE
R = 4 NEW_LINE C = 3 NEW_LINE def isSafe ( x , y ) : NEW_LINE INDENT return ( x < R and y < C ) NEW_LINE DEDENT def minJump ( height , x , y ) : NEW_LINE INDENT if ( x == R - 1 and y == C - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT diag = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y + 1 ) ) : NEW_LINE INDENT diag = ( minJump ( height , x + 1 , y + 1 ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y + 1 ] ) ) NEW_LINE DEDENT down = 10 ** 9 NEW_LINE if ( isSafe ( x + 1 , y ) ) : NEW_LINE INDENT down = ( minJump ( height , x + 1 , y ) + abs ( height [ x ] [ y ] - height [ x + 1 ] [ y ] ) ) NEW_LINE DEDENT right = 10 ** 9 NEW_LINE if ( isSafe ( x , y + 1 ) ) : NEW_LINE INDENT right = ( minJump ( height , x , y + 1 ) + abs ( height [ x ] [ y ] - height [ x ] [ y + 1 ] ) ) NEW_LINE DEDENT return min ( [ down , right , diag ] ) NEW_LINE DEDENT height = [ [ 5 , 4 , 2 ] , [ 9 , 2 , 1 ] , [ 2 , 5 , 9 ] , [ 1 , 3 , 11 ] ] NEW_LINE print ( minJump ( height , 0 , 0 ) ) NEW_LINE
def maxSum ( arr , N , k ) : NEW_LINE INDENT MS = [ 0 for i in range ( N ) ] NEW_LINE MS [ N - 1 ] = arr [ N - 1 ] NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( i + k + 1 >= N ) : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] , MS [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT MS [ i ] = max ( arr [ i ] + MS [ i + k + 1 ] , MS [ i + 1 ] ) NEW_LINE DEDENT DEDENT return MS [ 0 ] NEW_LINE DEDENT N = 10 ; k = 2 NEW_LINE arr = [ 50 , 70 , 40 , 50 , 90 , 70 , 60 , 40 , 70 , 50 ] NEW_LINE print ( maxSum ( arr , N , k ) ) NEW_LINE
def alternateSubarray ( arr , n ) : NEW_LINE INDENT len = [ ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT len . append ( 0 ) NEW_LINE DEDENT len [ n - 1 ] = 1 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] ^ arr [ i + 1 ] == True ) : NEW_LINE INDENT len [ i ] = len [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT len [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( len [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT arr = [ True , False , True , False , False , True ] NEW_LINE n = len ( arr ) NEW_LINE alternateSubarray ( arr , n ) NEW_LINE
def alternateSubarray ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE DEDENT ' NEW_LINE INDENT prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ prev ) == 0 ) : NEW_LINE INDENT while ( count ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT count += 1 NEW_LINE prev = arr [ i ] NEW_LINE DEDENT while ( count ) : NEW_LINE INDENT print ( count , end = " ▁ " ) NEW_LINE count -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 0 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE alternateSubarray ( arr , n ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 1 ) for i in range ( 2 ) ] NEW_LINE dp [ 0 ] [ 1 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = 2 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = dp [ 0 ] [ i - 1 ] + dp [ 1 ] [ i - 1 ] NEW_LINE dp [ 1 ] [ i ] = ( dp [ 0 ] [ i - 1 ] * 2 + dp [ 1 ] [ i - 1 ] ) NEW_LINE DEDENT return dp [ 0 ] [ n ] + dp [ 1 ] [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( " Total ▁ no ▁ of ▁ ways ▁ with ▁ n ▁ = " , n , " are : " , countWays ( n ) ) NEW_LINE DEDENT
def maxLenSub ( arr , n ) : NEW_LINE INDENT mls = [ ] NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mls . append ( 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( abs ( arr [ i ] - arr [ j ] ) <= 1 and mls [ i ] < mls [ j ] + 1 ) : NEW_LINE INDENT mls [ i ] = mls [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT ' NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( max < mls [ i ] ) : NEW_LINE INDENT max = mls [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 2 , 5 , 6 , 3 , 7 , 6 , 5 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ length ▁ subsequence ▁ = ▁ " , maxLenSub ( arr , n ) ) NEW_LINE
def findWinner ( x , y , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = False NEW_LINE dp [ 1 ] = True NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( i - 1 >= 0 and not dp [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT elif ( i - x >= 0 and not dp [ i - x ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT elif ( i - y >= 0 and not dp [ i - y ] ) : NEW_LINE INDENT dp [ i ] = True NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = False NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT x = 3 ; y = 4 ; n = 5 NEW_LINE if ( findWinner ( x , y , n ) ) : NEW_LINE INDENT print ( ' A ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' B ' ) NEW_LINE DEDENT
def maxGameByWinner ( N ) : NEW_LINE INDENT dp = [ 0 for i in range ( N ) ] NEW_LINE dp [ 0 ] = 1 NEW_LINE dp [ 1 ] = 2 NEW_LINE i = 1 NEW_LINE while dp [ i ] <= N : NEW_LINE INDENT i = i + 1 NEW_LINE dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] NEW_LINE DEDENT return ( i - 1 ) NEW_LINE DEDENT N = 10 NEW_LINE print ( maxGameByWinner ( N ) ) NEW_LINE
def minRemove ( arr , n ) : NEW_LINE INDENT LIS = [ 0 for i in range ( n ) ] NEW_LINE len = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and ( i - j ) <= ( arr [ i ] - arr [ j ] ) ) : NEW_LINE INDENT LIS [ i ] = max ( LIS [ i ] , LIS [ j ] + 1 ) NEW_LINE DEDENT DEDENT len = max ( len , LIS [ i ] ) NEW_LINE DEDENT return ( n - len ) NEW_LINE DEDENT arr = [ 1 , 2 , 6 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minRemove ( arr , n ) ) NEW_LINE
MAX = 1000 NEW_LINE def maxSubsequenceSubstring ( x , y , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( x [ j - 1 ] == y [ i - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] [ n ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT x = " ABCD " NEW_LINE y = " BACDBDCD " NEW_LINE n = len ( x ) NEW_LINE m = len ( y ) NEW_LINE print ( maxSubsequenceSubstring ( x , y , n , m ) ) NEW_LINE
def maxSum ( grid , n ) : NEW_LINE INDENT incl = max ( grid [ 0 ] [ 0 ] , grid [ 1 ] [ 0 ] ) NEW_LINE excl = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT excl_new = max ( excl , incl ) NEW_LINE incl = excl + max ( grid [ 0 ] [ i ] , grid [ 1 ] [ i ] ) NEW_LINE excl = excl_new NEW_LINE DEDENT return max ( excl , incl ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT grid = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 6 , 7 , 8 , 9 , 10 ] ] NEW_LINE n = 5 NEW_LINE print ( maxSum ( grid , n ) ) NEW_LINE DEDENT // This code is contributed by Ryuga NEW_LINE
' NEW_LINE def minInsertionStepToSortArray ( arr , N ) : NEW_LINE INDENT lis = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] >= arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT max = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( max < lis [ i ] ) : NEW_LINE INDENT max = lis [ i ] NEW_LINE DEDENT DEDENT return ( N - max ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 1 , 4 , 7 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( minInsertionStepToSortArray ( arr , N ) ) NEW_LINE DEDENT
MAX = 1005 NEW_LINE def shortestSeq ( S : list , T : list ) : NEW_LINE INDENT m = len ( S ) NEW_LINE n = len ( T ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ 0 ] [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT ch = S [ i - 1 ] NEW_LINE k = j - 1 NEW_LINE while k >= 0 : NEW_LINE INDENT if T [ k ] == ch : NEW_LINE INDENT break NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT if k == - 1 : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i - 1 ] [ j ] , dp [ i - 1 ] [ k ] + 1 ) NEW_LINE DEDENT DEDENT DEDENT ans = dp [ m ] [ n ] NEW_LINE if ans >= MAX : NEW_LINE INDENT ans = - 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = " babab " NEW_LINE T = " babba " NEW_LINE print ( " Length ▁ of ▁ shortest ▁ subsequence ▁ is : " , shortestSeq ( S , T ) ) NEW_LINE DEDENT
def countWaysToJump ( arr , n ) : NEW_LINE INDENT count_jump = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] >= n - i - 1 ) : NEW_LINE INDENT count_jump [ i ] += 1 NEW_LINE DEDENT j = i + 1 NEW_LINE while ( j < n - 1 and j <= arr [ i ] + i ) : NEW_LINE INDENT if ( count_jump [ j ] != - 1 ) : NEW_LINE INDENT count_jump [ i ] += count_jump [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( count_jump [ i ] == 0 ) : NEW_LINE INDENT count_jump [ i ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT print ( count_jump [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 8 , 9 , 1 , 0 , 7 , 6 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE countWaysToJump ( arr , n ) NEW_LINE
def minStepToDeleteString ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] NEW_LINE for l in range ( 1 , N + 1 ) : NEW_LINE INDENT i = 0 NEW_LINE j = l - 1 NEW_LINE while j < N : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i + 1 ] [ j ] NEW_LINE if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( 1 + dp [ i + 2 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT for K in range ( i + 2 , j + 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ K ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i + 1 ] [ K - 1 ] + dp [ K + 1 ] [ j ] , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return dp [ 0 ] [ N - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "2553432" NEW_LINE print ( minStepToDeleteString ( str ) ) NEW_LINE DEDENT
inf = 1000000000 NEW_LINE ans = inf NEW_LINE def solve ( i , par , a , n , k , current_ans ) : NEW_LINE INDENT if ( par > k ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT global ans NEW_LINE if ( par == k and i == n - 1 ) : NEW_LINE INDENT ans = min ( ans , current_ans ) NEW_LINE return 0 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT solve ( j , par + 1 , a , n , k , current_ans + ( a [ j ] - a [ i + 1 ] ) * ( a [ j ] - a [ i + 1 ] ) ) NEW_LINE DEDENT DEDENT k = 2 NEW_LINE a = [ 1 , 5 , 8 , 10 ] NEW_LINE n = len ( a ) NEW_LINE solve ( - 1 , 0 , a , n , k , 0 ) NEW_LINE print ( ans ) NEW_LINE
def getMinSteps ( n , memo ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( memo [ n ] != - 1 ) : NEW_LINE INDENT return memo [ n ] NEW_LINE DEDENT res = getMinSteps ( n - 1 , memo ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT res = min ( res , getMinSteps ( n // 2 , memo ) ) NEW_LINE DEDENT if ( n % 3 == 0 ) : NEW_LINE INDENT res = min ( res , getMinSteps ( n // 3 , memo ) ) NEW_LINE DEDENT memo [ n ] = 1 + res NEW_LINE return memo [ n ] NEW_LINE DEDENT def getsMinSteps ( n ) : NEW_LINE INDENT memo = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT memo [ i ] = - 1 NEW_LINE DEDENT return getMinSteps ( n , memo ) NEW_LINE DEDENT n = 10 NEW_LINE print ( getsMinSteps ( n ) ) NEW_LINE
def stringReduction ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = [ 0 ] * 3 NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT if ( count [ 0 ] == n or count [ 1 ] == n or count [ 2 ] == n ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( ( count [ 0 ] % 2 ) == ( count [ 1 ] % 2 ) and ( count [ 1 ] % 2 ) == ( count [ 2 ] % 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abcbbaacb " NEW_LINE print ( stringReduction ( str ) ) NEW_LINE DEDENT
def countSubsequences ( s ) : NEW_LINE ' NEW_LINE INDENT aCount = 0 NEW_LINE DEDENT ' NEW_LINE INDENT bCount = 0 NEW_LINE cCount = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT aCount = ( 1 + 2 * aCount ) NEW_LINE DEDENT elif ( s [ i ] == ' b ' ) : NEW_LINE INDENT bCount = ( aCount + 2 * bCount ) NEW_LINE DEDENT elif ( s [ i ] == ' c ' ) : NEW_LINE INDENT cCount = ( bCount + 2 * cCount ) NEW_LINE DEDENT DEDENT return cCount NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abbc " NEW_LINE print ( countSubsequences ( s ) ) NEW_LINE DEDENT
def maxRevenue ( m , x , revenue , n , t ) : NEW_LINE INDENT maxRev = [ 0 ] * ( m + 1 ) NEW_LINE nxtbb = 0 ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( nxtbb < n ) : NEW_LINE INDENT if ( x [ nxtbb ] != i ) : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT if ( i <= t ) : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - 1 ] , revenue [ nxtbb ] ) NEW_LINE DEDENT else : NEW_LINE INDENT maxRev [ i ] = max ( maxRev [ i - t - 1 ] + revenue [ nxtbb ] , maxRev [ i - 1 ] ) ; NEW_LINE DEDENT nxtbb += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxRev [ i ] = maxRev [ i - 1 ] NEW_LINE DEDENT DEDENT return maxRev [ m ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 20 NEW_LINE x = [ 6 , 7 , 12 , 13 , 14 ] NEW_LINE revenue = [ 5 , 6 , 5 , 3 , 1 ] NEW_LINE n = len ( x ) NEW_LINE t = 5 NEW_LINE print ( maxRevenue ( m , x , revenue , n , t ) ) NEW_LINE DEDENT
Row = 6 NEW_LINE Col = 6 NEW_LINE def largestKSubmatrix ( a ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( Row ) ] for y in range ( Col ) ] NEW_LINE result = 0 NEW_LINE for i in range ( Row ) : NEW_LINE INDENT for j in range ( Col ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( a [ i ] [ j ] == a [ i - 1 ] [ j ] and a [ i ] [ j ] == a [ i ] [ j - 1 ] and a [ i ] [ j ] == a [ i - 1 ] [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( min ( dp [ i - 1 ] [ j ] , dp [ i ] [ j - 1 ] ) , dp [ i - 1 ] [ j - 1 ] ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT DEDENT result = max ( result , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT a = [ [ 2 , 2 , 3 , 3 , 4 , 4 ] , [ 5 , 5 , 7 , 7 , 7 , 4 ] , [ 1 , 2 , 7 , 7 , 7 , 4 ] , [ 4 , 4 , 7 , 7 , 7 , 4 ] , [ 5 , 5 , 5 , 1 , 2 , 7 ] , [ 8 , 7 , 9 , 4 , 4 , 4 ] ] ; NEW_LINE print ( largestKSubmatrix ( a ) ) NEW_LINE
MAX = 21 NEW_LINE fact = [ 0 ] * MAX NEW_LINE def probability ( k , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( k , n + 1 ) : NEW_LINE INDENT ans += fact [ n ] / ( fact [ i ] * fact [ n - i ] ) NEW_LINE DEDENT ans = ans / ( 1 << n ) NEW_LINE return ans NEW_LINE DEDENT def precompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE fact [ 1 ] = 1 NEW_LINE for i in range ( 2 , 20 ) : NEW_LINE INDENT fact [ i ] = fact [ i - 1 ] * i NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT precompute ( ) NEW_LINE print ( probability ( 2 , 3 ) ) NEW_LINE print ( probability ( 3 , 6 ) ) NEW_LINE print ( probability ( 12 , 18 ) ) NEW_LINE DEDENT
def countStrings ( n , k ) : NEW_LINE INDENT dp = [ [ [ 0 , 0 ] for __ in range ( k + 1 ) ] for _ in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 0 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( k + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ 0 ] = ( dp [ i - 1 ] [ j ] [ 0 ] + dp [ i - 1 ] [ j ] [ 1 ] ) NEW_LINE dp [ i ] [ j ] [ 1 ] = dp [ i - 1 ] [ j ] [ 0 ] NEW_LINE if j >= 1 : NEW_LINE INDENT dp [ i ] [ j ] [ 1 ] += dp [ i - 1 ] [ j - 1 ] [ 1 ] NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] [ 0 ] + dp [ n ] [ k ] [ 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( countStrings ( n , k ) ) NEW_LINE DEDENT
dp = [ - 1 ] * 1000 NEW_LINE def countFriendsPairings ( n ) : NEW_LINE INDENT global dp NEW_LINE if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT dp [ n ] = ( countFriendsPairings ( n - 1 ) + ( n - 1 ) * countFriendsPairings ( n - 2 ) ) NEW_LINE return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ n ] = n NEW_LINE return dp [ n ] NEW_LINE DEDENT DEDENT n = 4 NEW_LINE print ( countFriendsPairings ( n ) ) NEW_LINE
N = 3 NEW_LINE def maxPathSum ( tri , m , n ) : NEW_LINE INDENT for i in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT if ( tri [ i + 1 ] [ j ] > tri [ i + 1 ] [ j + 1 ] ) : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT return tri [ 0 ] [ 0 ] NEW_LINE DEDENT tri = [ [ 1 , 0 , 0 ] , [ 4 , 8 , 0 ] , [ 1 , 5 , 3 ] ] NEW_LINE print ( maxPathSum ( tri , 2 , 2 ) ) NEW_LINE
X = " AGGT12" NEW_LINE Y = "12TXAYB " NEW_LINE Z = "12XBA " NEW_LINE dp = [ [ [ - 1 for i in range ( 100 ) ] for j in range ( 100 ) ] for k in range ( 100 ) ] NEW_LINE def lcsOf3 ( i , j , k ) : NEW_LINE INDENT if ( i == - 1 or j == - 1 or k == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT if ( X [ i ] == Y [ j ] and Y [ j ] == Z [ k ] ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 1 + lcsOf3 ( i - 1 , j - 1 , k - 1 ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = max ( max ( lcsOf3 ( i - 1 , j , k ) , lcsOf3 ( i , j - 1 , k ) ) , lcsOf3 ( i , j , k - 1 ) ) NEW_LINE return dp [ i ] [ j ] [ k ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( " Length ▁ of ▁ LCS ▁ is " , lcsOf3 ( m - 1 , n - 1 , o - 1 ) ) NEW_LINE DEDENT
R = 4 NEW_LINE C = 4 NEW_LINE def countPaths ( maze ) : NEW_LINE INDENT if ( maze [ 0 ] [ 0 ] == - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( R ) : NEW_LINE INDENT if ( maze [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT maze [ i ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( maze [ 0 ] [ i ] == 0 ) : NEW_LINE INDENT maze [ 0 ] [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( 1 , R , 1 ) : NEW_LINE INDENT for j in range ( 1 , C , 1 ) : NEW_LINE INDENT if ( maze [ i ] [ j ] == - 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( maze [ i - 1 ] [ j ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i - 1 ] [ j ] ) NEW_LINE DEDENT if ( maze [ i ] [ j - 1 ] > 0 ) : NEW_LINE INDENT maze [ i ] [ j ] = ( maze [ i ] [ j ] + maze [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( maze [ R - 1 ] [ C - 1 ] > 0 ) : NEW_LINE INDENT return maze [ R - 1 ] [ C - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT maze = [ [ 0 , 0 , 0 , 0 ] , [ 0 , - 1 , 0 , 0 ] , [ - 1 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE print ( countPaths ( maze ) ) NEW_LINE DEDENT
N = 4 NEW_LINE def maxDecimalValue ( mat , i , j , p ) : NEW_LINE INDENT if i >= N or j >= N : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = max ( maxDecimalValue ( mat , i , j + 1 , p + 1 ) , maxDecimalValue ( mat , i + 1 , j , p + 1 ) ) NEW_LINE if mat [ i ] [ j ] == 1 : NEW_LINE INDENT return pow ( 2 , p ) + result NEW_LINE DEDENT else : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT mat = [ [ 1 , 1 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 1 , 1 ] ] NEW_LINE print ( maxDecimalValue ( mat , 0 , 0 , 0 ) ) NEW_LINE
def CountPS ( str , n ) : NEW_LINE INDENT dp = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE P = [ [ False for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT P [ i ] [ i ] = True NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT P [ i ] [ i + 1 ] = True NEW_LINE dp [ i ] [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT for gap in range ( 2 , n ) : NEW_LINE INDENT for i in range ( n - gap ) : NEW_LINE INDENT j = gap + i NEW_LINE if ( str [ i ] == str [ j ] and P [ i + 1 ] [ j - 1 ] ) : NEW_LINE INDENT P [ i ] [ j ] = True NEW_LINE DEDENT if ( P [ i ] [ j ] == True ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] + 1 - dp [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i ] [ j - 1 ] + dp [ i + 1 ] [ j ] - dp [ i + 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abaab " NEW_LINE n = len ( str ) NEW_LINE print ( CountPS ( str , n ) ) NEW_LINE DEDENT
def maxSumWO3Consec ( arr , n ) : NEW_LINE INDENT sum = [ 0 for k in range ( n ) ] NEW_LINE if n >= 1 : NEW_LINE INDENT sum [ 0 ] = arr [ 0 ] NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT sum [ 1 ] = arr [ 0 ] + arr [ 1 ] NEW_LINE DEDENT if n > 2 : NEW_LINE INDENT sum [ 2 ] = max ( sum [ 1 ] , max ( arr [ 1 ] + arr [ 2 ] , arr [ 0 ] + arr [ 2 ] ) ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT sum [ i ] = max ( max ( sum [ i - 1 ] , sum [ i - 2 ] + arr [ i ] ) , arr [ i ] + arr [ i - 1 ] + sum [ i - 3 ] ) NEW_LINE DEDENT return sum [ n - 1 ] NEW_LINE DEDENT arr = [ 100 , 1000 , 100 , 1000 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print maxSumWO3Consec ( arr , n ) NEW_LINE
def maxSumPairWithDifferenceLessThanK ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE dp = [ 0 ] * N NEW_LINE dp [ 0 ] = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] NEW_LINE if ( arr [ i ] - arr [ i - 1 ] < K ) : NEW_LINE INDENT if ( i >= 2 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , dp [ i - 2 ] + arr [ i ] + arr [ i - 1 ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , arr [ i ] + arr [ i - 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ N - 1 ] NEW_LINE DEDENT arr = [ 3 , 5 , 10 , 15 , 17 , 12 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE K = 4 NEW_LINE print ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) NEW_LINE
def breakSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return max ( ( breakSum ( n // 2 ) + breakSum ( n // 3 ) + breakSum ( n // 4 ) ) , n ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE print ( breakSum ( n ) ) NEW_LINE DEDENT
def countPS ( str ) : NEW_LINE INDENT N = len ( str ) NEW_LINE cps = [ [ 0 for i in range ( N + 2 ) ] for j in range ( N + 2 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT cps [ i ] [ i ] = 1 NEW_LINE DEDENT for L in range ( 2 , N + 1 ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT k = L + i - 1 NEW_LINE if ( k < N ) : NEW_LINE INDENT if ( str [ i ] == str [ k ] ) : NEW_LINE INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT cps [ i ] [ k ] = ( cps [ i ] [ k - 1 ] + cps [ i + 1 ] [ k ] - cps [ i + 1 ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return cps [ 0 ] [ N - 1 ] NEW_LINE DEDENT str = " abcb " NEW_LINE print ( " Total ▁ palindromic ▁ subsequence ▁ are ▁ : ▁ " , countPS ( str ) ) NEW_LINE
str = " abcb " NEW_LINE def countPS ( i , j ) : NEW_LINE INDENT if ( i > j ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) + 1 ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( countPS ( i + 1 , j ) + countPS ( i , j - 1 ) - countPS ( i + 1 , j - 1 ) ) NEW_LINE return dp [ i ] [ j ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT dp = [ [ - 1 for x in range ( 1000 ) ] for y in range ( 1000 ) ] NEW_LINE n = len ( str ) NEW_LINE print ( " Total ▁ palindromic ▁ subsequence ▁ are ▁ : " , countPS ( 0 , n - 1 ) ) NEW_LINE DEDENT
def minimum ( a , b , c ) : NEW_LINE INDENT return min ( min ( a , b ) , c ) ; NEW_LINE DEDENT def findMinSum ( arr , n ) : NEW_LINE INDENT sum = [ ] NEW_LINE sum . append ( arr [ 0 ] ) NEW_LINE sum . append ( arr [ 1 ] ) NEW_LINE sum . append ( arr [ 2 ] ) NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT sum . append ( arr [ i ] + minimum ( sum [ i - 3 ] , sum [ i - 2 ] , sum [ i - 1 ] ) ) NEW_LINE DEDENT return minimum ( sum [ n - 1 ] , sum [ n - 2 ] , sum [ n - 3 ] ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 20 , 2 , 10 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Min ▁ Sum ▁ is ▁ " , findMinSum ( arr , n ) ) NEW_LINE
INF = 1000000 NEW_LINE def MinimumCost ( cost , n , W ) : NEW_LINE INDENT val = list ( ) NEW_LINE wt = list ( ) NEW_LINE size = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( cost [ i ] != - 1 ) : NEW_LINE INDENT val . append ( cost [ i ] ) NEW_LINE wt . append ( i + 1 ) NEW_LINE size += 1 NEW_LINE DEDENT DEDENT n = size NEW_LINE min_cost = [ [ 0 for i in range ( W + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( W + 1 ) : NEW_LINE INDENT min_cost [ 0 ] [ i ] = INF NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT min_cost [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , W + 1 ) : NEW_LINE INDENT if ( wt [ i - 1 ] > j ) : NEW_LINE INDENT min_cost [ i ] [ j ] = min_cost [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT min_cost [ i ] [ j ] = min ( min_cost [ i - 1 ] [ j ] , min_cost [ i ] [ j - wt [ i - 1 ] ] + val [ i - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT if ( min_cost [ n ] [ W ] == INF ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return min_cost [ n ] [ W ] NEW_LINE DEDENT DEDENT cost = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE W = 5 NEW_LINE n = len ( cost ) NEW_LINE print ( MinimumCost ( cost , n , W ) ) NEW_LINE
def count ( a , b , m , n ) : NEW_LINE INDENT if ( ( m == 0 and n == 0 ) or n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ m - 1 ] == b [ n - 1 ] ) : NEW_LINE INDENT return ( count ( a , b , m - 1 , n - 1 ) + count ( a , b , m - 1 , n ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return count ( a , b , m - 1 , n ) NEW_LINE DEDENT DEDENT a = " GeeksforGeeks " NEW_LINE b = " Gks " NEW_LINE print ( count ( a , b , len ( a ) , len ( b ) ) ) NEW_LINE
def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif X [ i - 1 ] == Y [ j - 1 ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT def findMinCost ( X , Y , costX , costY ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE len_LCS = lcs ( X , Y , m , n ) NEW_LINE return ( costX * ( m - len_LCS ) + costY * ( n - len_LCS ) ) NEW_LINE DEDENT X = " ef " NEW_LINE Y = " gh " NEW_LINE print ( ' Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ ' , end = ' ' ) NEW_LINE print ( ' identical ▁ is ▁ = ▁ ' , findMinCost ( X , Y , 10 , 20 ) ) NEW_LINE
def countIntegralSolutions ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT if i + j + k == n : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE
def countIntegralSolutions ( n ) : NEW_LINE INDENT return int ( ( ( n + 1 ) * ( n + 2 ) ) / 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( countIntegralSolutions ( n ) ) NEW_LINE
def maxLeftSubArraySum ( a , size , sum ) : NEW_LINE INDENT max_so_far = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE sum [ 0 ] = max_so_far NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE sum [ i ] = max_so_far NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def maxRightSubArraySum ( a , n , sum ) : NEW_LINE INDENT max_so_far = a [ n ] NEW_LINE curr_max = a [ n ] NEW_LINE sum [ n ] = max_so_far NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE sum [ i ] = max_so_far NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def findMaxAbsDiff ( arr , n ) : NEW_LINE INDENT leftMax = [ 0 for i in range ( n ) ] NEW_LINE maxLeftSubArraySum ( arr , n , leftMax ) NEW_LINE rightMax = [ 0 for i in range ( n ) ] NEW_LINE maxRightSubArraySum ( arr , n - 1 , rightMax ) NEW_LINE invertArr = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT invertArr [ i ] = - arr [ i ] NEW_LINE DEDENT leftMin = [ 0 for i in range ( n ) ] NEW_LINE maxLeftSubArraySum ( invertArr , n , leftMin ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT leftMin [ i ] = - leftMin [ i ] NEW_LINE DEDENT rightMin = [ 0 for i in range ( n ) ] NEW_LINE maxRightSubArraySum ( invertArr , n - 1 , rightMin ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT rightMin [ i ] = - rightMin [ i ] NEW_LINE DEDENT result = - 2147483648 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT absValue = max ( abs ( leftMax [ i ] - rightMin [ i + 1 ] ) , abs ( leftMin [ i ] - rightMax [ i + 1 ] ) ) NEW_LINE if ( absValue > result ) : NEW_LINE INDENT result = absValue NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT a = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMaxAbsDiff ( a , n ) ) NEW_LINE
' NEW_LINE def countWays ( p , q , r , last ) : NEW_LINE INDENT if ( p < 0 or q < 0 or r < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( p == 1 and q == 0 and r == 0 and last == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( p == 0 and q == 1 and r == 0 and last == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( p == 0 and q == 0 and r == 1 and last == 2 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( last == 0 ) : NEW_LINE INDENT return ( countWays ( p - 1 , q , r , 1 ) + countWays ( p - 1 , q , r , 2 ) ) ; NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( last == 1 ) : NEW_LINE INDENT return ( countWays ( p , q - 1 , r , 0 ) + countWays ( p , q - 1 , r , 2 ) ) ; NEW_LINE DEDENT if ( last == 2 ) : NEW_LINE INDENT return ( countWays ( p , q , r - 1 , 0 ) + countWays ( p , q , r - 1 , 1 ) ) ; NEW_LINE DEDENT DEDENT def countUtil ( p , q , r ) : NEW_LINE INDENT return ( countWays ( p , q , r , 0 ) + countWays ( p , q , r , 1 ) + countWays ( p , q , r , 2 ) ) ; NEW_LINE DEDENT p = 1 ; NEW_LINE q = 1 ; NEW_LINE r = 1 ; NEW_LINE print ( countUtil ( p , q , r ) ) ; NEW_LINE
def countP ( n , k ) : NEW_LINE INDENT if ( n == 0 or k == 0 or k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( k == 1 or k == n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( k * countP ( n - 1 , k ) + countP ( n - 1 , k - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( countP ( 3 , 2 ) ) NEW_LINE DEDENT
def countP ( n , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 0 NEW_LINE DEDENT for i in range ( k + 1 ) : NEW_LINE INDENT dp [ 0 ] [ k ] = 0 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( j == 1 or i == j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( j * dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( countP ( 5 , 2 ) ) NEW_LINE DEDENT
' NEW_LINE def printCountRec ( dist ) : NEW_LINE INDENT if dist < 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dist == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( printCountRec ( dist - 1 ) + printCountRec ( dist - 2 ) + printCountRec ( dist - 3 ) ) NEW_LINE DEDENT dist = 4 NEW_LINE print ( printCountRec ( dist ) ) NEW_LINE
def countNumbersWith4 ( n ) : NEW_LINE INDENT for x in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( has4 ( x ) == True ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def has4 ( x ) : NEW_LINE INDENT while ( x != 0 ) : NEW_LINE INDENT if ( x % 10 == 4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 328 NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to ▁ " , n , " ▁ that ▁ have ▁ 4 ▁ as ▁ a ▁ a ▁ digit ▁ is ▁ " , countNumbersWith4 ( n ) ) NEW_LINE
import math as mt NEW_LINE def countNumbersWith4 ( n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT d = int ( mt . log10 ( n ) ) NEW_LINE a = [ 1 for i in range ( d + 1 ) ] NEW_LINE a [ 0 ] = 0 NEW_LINE if len ( a ) > 1 : NEW_LINE INDENT a [ 1 ] = 1 NEW_LINE DEDENT for i in range ( 2 , d + 1 ) : NEW_LINE INDENT a [ i ] = a [ i - 1 ] * 9 + mt . ceil ( pow ( 10 , i - 1 ) ) NEW_LINE DEDENT p = mt . ceil ( pow ( 10 , d ) ) NEW_LINE msd = n // p NEW_LINE if ( msd == 4 ) : NEW_LINE INDENT return ( msd ) * a [ d ] + ( n % p ) + 1 NEW_LINE DEDENT if ( msd > 4 ) : NEW_LINE INDENT return ( ( msd - 1 ) * a [ d ] + p + countNumbersWith4 ( n % p ) ) NEW_LINE DEDENT return ( msd ) * a [ d ] + countNumbersWith4 ( n % p ) NEW_LINE DEDENT n = 328 NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to " , n , " that ▁ have ▁ 4 ▁ as ▁ a ▁ digit ▁ is " , countNumbersWith4 ( n ) ) NEW_LINE
import sys ; NEW_LINE def minRemovalsDP ( arr , n ) : NEW_LINE INDENT longest_start = - 1 ; NEW_LINE longest_end = 0 ; NEW_LINE for start in range ( n ) : NEW_LINE INDENT min = sys . maxsize ; NEW_LINE max = - sys . maxsize ; NEW_LINE for end in range ( start , n ) : NEW_LINE INDENT val = arr [ end ] ; NEW_LINE if ( val < min ) : NEW_LINE INDENT min = val ; NEW_LINE DEDENT if ( val > max ) : NEW_LINE INDENT max = val ; NEW_LINE DEDENT if ( 2 * min <= max ) : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( end - start > longest_end - longest_start or longest_start == - 1 ) : NEW_LINE INDENT longest_start = start ; NEW_LINE longest_end = end ; NEW_LINE DEDENT DEDENT DEDENT if ( longest_start == - 1 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT return ( n - ( longest_end - longest_start + 1 ) ) ; NEW_LINE DEDENT arr = [ 4 , 5 , 100 , 9 , 10 , 11 , 12 , 15 , 200 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( minRemovalsDP ( arr , n ) ) ; NEW_LINE
def optimalStrategyOfGame ( arr , n ) : NEW_LINE INDENT table = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for gap in range ( n ) : NEW_LINE INDENT for j in range ( gap , n ) : NEW_LINE INDENT i = j - gap NEW_LINE x = 0 NEW_LINE if ( ( i + 2 ) <= j ) : NEW_LINE INDENT x = table [ i + 2 ] [ j ] NEW_LINE DEDENT y = 0 NEW_LINE if ( ( i + 1 ) <= ( j - 1 ) ) : NEW_LINE INDENT y = table [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT z = 0 NEW_LINE if ( i <= ( j - 2 ) ) : NEW_LINE INDENT z = table [ i ] [ j - 2 ] NEW_LINE DEDENT table [ i ] [ j ] = max ( arr [ i ] + min ( x , y ) , arr [ j ] + min ( y , z ) ) NEW_LINE DEDENT DEDENT return table [ 0 ] [ n - 1 ] NEW_LINE DEDENT arr1 = [ 8 , 15 , 3 , 7 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( optimalStrategyOfGame ( arr1 , n ) ) NEW_LINE arr2 = [ 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( optimalStrategyOfGame ( arr2 , n ) ) NEW_LINE arr3 = [ 20 , 30 , 2 , 2 , 2 , 10 ] NEW_LINE n = len ( arr3 ) NEW_LINE print ( optimalStrategyOfGame ( arr3 , n ) ) NEW_LINE
def maxSumIS ( arr , n ) : NEW_LINE INDENT max = 0 NEW_LINE msis = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT msis [ i ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and msis [ i ] < msis [ j ] + arr [ i ] ) : NEW_LINE INDENT msis [ i ] = msis [ j ] + arr [ i ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if max < msis [ i ] : NEW_LINE INDENT max = msis [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT arr = [ 1 , 101 , 2 , 3 , 100 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Sum ▁ of ▁ maximum ▁ sum ▁ increasing ▁ " + " subsequence ▁ is ▁ " + str ( maxSumIS ( arr , n ) ) ) NEW_LINE
def endsWith ( str1 , pat ) : NEW_LINE INDENT patLen = len ( pat ) NEW_LINE str1Len = len ( str1 ) NEW_LINE if ( patLen > str1Len ) : NEW_LINE INDENT return False NEW_LINE DEDENT patLen -= 1 NEW_LINE str1Len -= 1 NEW_LINE while ( patLen >= 0 ) : NEW_LINE INDENT if ( pat [ patLen ] != str1 [ str1Len ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT patLen -= 1 NEW_LINE str1Len -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def countOfstr1ings ( pat , n , sArr ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( endsWith ( sArr [ i ] , pat ) == True ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT pat = " ks " NEW_LINE n = 4 NEW_LINE sArr = [ " geeks " , " geeksforgeeks " , " games " , " unit " ] NEW_LINE print ( countOfstr1ings ( pat , n , sArr ) ) NEW_LINE
def getEndingIndex ( str1 , n , i ) : NEW_LINE INDENT i += 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT curr = str1 [ i ] NEW_LINE prev = str1 [ i - 1 ] NEW_LINE if ( ( curr == ' a ' and prev == ' z ' ) or ( ord ( curr ) - ord ( prev ) == 1 ) ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i - 1 NEW_LINE DEDENT def largestSubstr1 ( str1 , n ) : NEW_LINE INDENT Len = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT end = getEndingIndex ( str1 , n , i ) NEW_LINE Len = max ( end - i + 1 , Len ) NEW_LINE i = end + 1 NEW_LINE DEDENT return Len NEW_LINE DEDENT str1 = " abcabcdefabc " NEW_LINE n = len ( str1 ) NEW_LINE print ( largestSubstr1 ( str1 , n ) ) NEW_LINE
def getSum ( n , d ) : NEW_LINE INDENT if ( n < d ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n % 10 != d ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT k = n // 10 NEW_LINE return ( ( k + 1 ) * d + ( k * 10 + 10 * k * k ) // 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 30 NEW_LINE d = 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE DEDENT
def replace ( A , B ) : NEW_LINE INDENT n , m = len ( A ) , len ( B ) NEW_LINE count , i = 0 , 0 NEW_LINE while i < n : NEW_LINE INDENT j = 0 NEW_LINE while j < m : NEW_LINE INDENT if i + j >= n or A [ i + j ] != B [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == m : NEW_LINE INDENT count += 1 NEW_LINE i += m - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " aaaaaaaa " NEW_LINE str2 = " aaa " NEW_LINE print ( replace ( str1 , str2 ) ) NEW_LINE DEDENT
def isSubstring ( s1 , s2 ) : NEW_LINE INDENT M = len ( s1 ) NEW_LINE N = len ( s2 ) NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( s2 [ i + j ] != s1 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if j + 1 == M : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " for " NEW_LINE s2 = " geeksforgeeks " NEW_LINE res = isSubstring ( s1 , s2 ) NEW_LINE if res == - 1 : NEW_LINE INDENT print ( " Not ▁ present " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Present ▁ at ▁ index ▁ " + str ( res ) ) NEW_LINE DEDENT DEDENT
def patternCount ( str ) : NEW_LINE INDENT last = str [ 0 ] NEW_LINE i = 1 ; counter = 0 NEW_LINE while ( i < len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' and last == '1' ) : NEW_LINE INDENT while ( str [ i ] == '0' ) : NEW_LINE INDENT i += 1 NEW_LINE if ( str [ i ] == '1' ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT last = str [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return counter NEW_LINE DEDENT str = "1001ab010abc01001" NEW_LINE ans = patternCount ( str ) NEW_LINE print ( ans ) NEW_LINE
def maxPrefix ( s , t ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , len ( t ) ) : NEW_LINE INDENT if ( count == len ( s ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( t [ i ] == s [ count ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT S = " digger " NEW_LINE T = " biggerdiagram " NEW_LINE print ( maxPrefix ( S , T ) ) NEW_LINE
def translate ( st ) : NEW_LINE INDENT for i in range ( 1 , len ( st ) ) : NEW_LINE INDENT if ( st [ i - 1 ] == ' A ' and st [ i ] == ' B ' ) : NEW_LINE INDENT st [ i - 1 ] = ' C ' NEW_LINE for j in range ( i , len ( st ) - 1 ) : NEW_LINE INDENT st [ j ] = st [ j + 1 ] NEW_LINE DEDENT st [ len ( st ) - 1 ] = ' ▁ ' NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT st = list ( " helloABworldABGfG " ) NEW_LINE translate ( st ) NEW_LINE print ( " The ▁ modified ▁ string ▁ is ▁ : " ) NEW_LINE print ( ' ' . join ( st ) ) NEW_LINE
NUM = 31 NEW_LINE def positions ( str ) : NEW_LINE INDENT for i in str : NEW_LINE INDENT print ( ( ord ( i ) & NUM ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT str = " Geeks " NEW_LINE positions ( str ) NEW_LINE
def lenoflongestnonpalindrome ( s ) : NEW_LINE INDENT max1 , length = 1 , 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT length = 0 NEW_LINE DEDENT elif s [ i + 1 ] == s [ i - 1 ] and i > 0 : NEW_LINE INDENT length = 1 NEW_LINE length += 1 NEW_LINE DEDENT DEDENT if max1 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " synapse " NEW_LINE print ( lenoflongestnonpalindrome ( s ) ) NEW_LINE DEDENT
def calcScore ( str ) : NEW_LINE INDENT score = 0 NEW_LINE len1 = len ( str ) NEW_LINE i = 0 NEW_LINE while ( i < len1 ) : NEW_LINE INDENT chunkSize = 1 NEW_LINE currentChar = str [ i ] NEW_LINE i += 1 NEW_LINE while ( i < len1 and str [ i ] == currentChar ) : NEW_LINE INDENT chunkSize += 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( currentChar == '1' ) : NEW_LINE INDENT score += pow ( chunkSize , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT score -= pow ( chunkSize , 2 ) NEW_LINE DEDENT DEDENT return score NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "11011" NEW_LINE print ( calcScore ( str ) ) NEW_LINE DEDENT
def countSubString ( s , c , k ) : NEW_LINE INDENT leftCount = 0 NEW_LINE rightCount = 0 NEW_LINE left = 0 NEW_LINE right = 0 NEW_LINE freq = 0 NEW_LINE result = 0 NEW_LINE len1 = len ( s ) NEW_LINE while ( s [ left ] != c and left < len1 ) : NEW_LINE INDENT left += 1 NEW_LINE leftCount += 1 NEW_LINE DEDENT right = left + 1 NEW_LINE while ( freq != ( k - 1 ) and ( right - 1 ) < len1 ) : NEW_LINE INDENT if ( s [ right ] == c ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT right += 1 NEW_LINE DEDENT while ( left < len1 and ( right - 1 ) < len1 ) : NEW_LINE INDENT while ( s [ left ] != c and left < len1 ) : NEW_LINE INDENT left += 1 NEW_LINE leftCount += 1 NEW_LINE DEDENT while ( right < len1 and s [ right ] != c ) : NEW_LINE INDENT if ( s [ right ] == c ) : NEW_LINE INDENT freq += 1 NEW_LINE DEDENT right += 1 NEW_LINE rightCount += 1 NEW_LINE DEDENT result = ( result + ( leftCount + 1 ) * ( rightCount + 1 ) ) NEW_LINE freq = k - 1 NEW_LINE leftCount = 0 NEW_LINE rightCount = 0 NEW_LINE left += 1 NEW_LINE right += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " abada " NEW_LINE c = ' a ' NEW_LINE k = 2 NEW_LINE print ( countSubString ( s , c , k ) ) NEW_LINE DEDENT
def isValid ( str1 , n ) : NEW_LINE INDENT if ( ( ( ord ( str1 [ 0 ] ) >= ord ( ' a ' ) and ord ( str1 [ 0 ] ) <= ord ( ' z ' ) ) or ( ord ( str1 [ 0 ] ) >= ord ( ' A ' ) and ord ( str1 [ 0 ] ) <= ord ( ' Z ' ) ) or ord ( str1 [ 0 ] ) == ord ( ' _ ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 1 , len ( str1 ) ) : NEW_LINE INDENT if ( ( ( ord ( str1 [ i ] ) >= ord ( ' a ' ) and ord ( str1 [ i ] ) <= ord ( ' z ' ) ) or ( ord ( str1 [ i ] ) >= ord ( ' A ' ) and ord ( str1 [ i ] ) <= ord ( ' Z ' ) ) or ( ord ( str1 [ i ] ) >= ord ( '0' ) and ord ( str1 [ i ] ) <= ord ( '9' ) ) or ord ( str1 [ i ] ) == ord ( ' _ ' ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str1 = " _ geeks123" NEW_LINE n = len ( str1 ) NEW_LINE if ( isValid ( str1 , n ) ) : NEW_LINE INDENT print ( " Valid " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE DEDENT
def FirstAndLast ( string ) : NEW_LINE INDENT ch = list ( string ) ; NEW_LINE i = 0 ; NEW_LINE while i < len ( ch ) : NEW_LINE INDENT k = i ; NEW_LINE while ( i < len ( ch ) and ch [ i ] != ' ▁ ' ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT if ( ord ( ch [ k ] ) >= 97 and ord ( ch [ k ] ) <= 122 ) : NEW_LINE INDENT ch [ k ] = chr ( ord ( ch [ k ] ) - 32 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ch [ k ] = ch [ k ] NEW_LINE DEDENT if ( ord ( ch [ i - 1 ] ) >= 90 and ord ( ch [ i - 1 ] ) <= 122 ) : NEW_LINE INDENT ch [ i - 1 ] = chr ( ord ( ch [ i - 1 ] ) - 32 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT ch [ i - 1 ] = ch [ i - 1 ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return " " . join ( ch ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " Geeks ▁ for ▁ Geeks " ; NEW_LINE print ( string ) ; NEW_LINE print ( FirstAndLast ( string ) ) ; NEW_LINE DEDENT
def findM ( s , x ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) != x ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "3662123" NEW_LINE x = 6 NEW_LINE print ( findM ( s , x ) ) NEW_LINE DEDENT
def compute_lps ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE Len = 0 NEW_LINE lps [ 0 ] = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ Len ] ) : NEW_LINE INDENT Len += 1 NEW_LINE lps [ i ] = Len NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( Len != 0 ) : NEW_LINE INDENT Len = lps [ Len - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT return lps NEW_LINE DEDENT def Longestsubstring ( s ) : NEW_LINE INDENT lps = compute_lps ( s ) NEW_LINE n = len ( s ) NEW_LINE if ( lps [ n - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( lps [ i ] == lps [ n - 1 ] ) : NEW_LINE INDENT print ( s [ 0 : lps [ i ] ] ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT if ( lps [ lps [ n - 1 ] - 1 ] == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( s [ 0 : lps [ lps [ n - 1 ] - 1 ] ] ) NEW_LINE DEDENT DEDENT s = " fixprefixsuffix " NEW_LINE Longestsubstring ( s ) NEW_LINE
MAX = 64 NEW_LINE def getBitmask ( s ) : NEW_LINE INDENT temp = 0 NEW_LINE for j in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ j ] == ' s ' ) : NEW_LINE INDENT temp = temp | 1 NEW_LINE DEDENT elif ( s [ j ] == ' t ' ) : NEW_LINE INDENT temp = temp | 2 NEW_LINE DEDENT elif ( s [ j ] == ' r ' ) : NEW_LINE INDENT temp = temp | 4 NEW_LINE DEDENT elif ( s [ j ] == ' i ' ) : NEW_LINE INDENT temp = temp | 8 NEW_LINE DEDENT elif ( s [ j ] == ' n ' ) : NEW_LINE INDENT temp = temp | 16 NEW_LINE DEDENT elif ( s [ j ] == ' g ' ) : NEW_LINE INDENT temp = temp | 32 NEW_LINE DEDENT DEDENT return temp NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT bitMask = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT bitMask [ getBitmask ( arr [ i ] ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i , MAX ) : NEW_LINE INDENT if ( ( i j ) == ( MAX - 1 ) ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT cnt += ( ( bitMask [ i ] * bitMask [ i ] - 1 ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( bitMask [ i ] * bitMask [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ " strrr " , " string " , " gstrin " ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
def calculateWays ( s , n , l , r ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < l or i > r ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT ways = 1 NEW_LINE for i in range ( l , r + 1 , 1 ) : NEW_LINE INDENT if ( freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT ways = ways * freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] NEW_LINE freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT ways = 0 NEW_LINE break NEW_LINE DEDENT DEDENT return ways NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " cabcaab " NEW_LINE n = len ( s ) NEW_LINE l = 1 NEW_LINE r = 3 NEW_LINE print ( calculateWays ( s , n , l , r ) ) NEW_LINE DEDENT
def asciiToSentence ( string , length ) : NEW_LINE INDENT num = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT num = num * 10 + ( ord ( string [ i ] ) - ord ( '0' ) ) ; NEW_LINE if ( num >= 32 and num <= 122 ) : NEW_LINE INDENT ch = chr ( num ) ; NEW_LINE print ( ch , end = " " ) ; NEW_LINE num = 0 ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "7110110110711510211111471101101107115" ; NEW_LINE length = len ( string ) ; NEW_LINE asciiToSentence ( string , length ) ; NEW_LINE DEDENT
arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ] ; NEW_LINE def countKeyPressed ( string , length ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT count += arr [ ord ( string [ i ] ) - ord ( ' a ' ) ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " abcdef " ; NEW_LINE length = len ( string ) ; NEW_LINE print ( countKeyPressed ( string , length ) ) ; NEW_LINE DEDENT
def isReverseEqual ( s1 , s2 ) : NEW_LINE INDENT if len ( s1 ) != len ( s2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT l = len ( s1 ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if s1 [ i ] != s2 [ l - i - 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def getWord ( str , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( isReverseEqual ( str [ i ] , str [ j ] ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT DEDENT return " - 1" NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = [ " geeks " , " for " , " skeeg " ] NEW_LINE print ( getWord ( str , 3 ) ) NEW_LINE DEDENT
def isPrefix ( string , length , i , k ) : NEW_LINE INDENT if i + k > length : NEW_LINE INDENT return False NEW_LINE DEDENT for j in range ( 0 , k ) : NEW_LINE INDENT if string [ i ] != string [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def isKPeriodic ( string , length , k ) : NEW_LINE INDENT for i in range ( k , length , k ) : NEW_LINE INDENT if isPrefix ( string , length , i , k ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksgeeks " NEW_LINE length = len ( string ) NEW_LINE k = 5 NEW_LINE if isKPeriodic ( string , length , k ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def minLettersNeeded ( n ) : NEW_LINE INDENT if n % 26 == 0 : NEW_LINE INDENT return ( n // 26 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( n // 26 ) + 1 ) NEW_LINE DEDENT DEDENT n = 52 NEW_LINE print ( minLettersNeeded ( n ) ) NEW_LINE
def minReplacement ( s , length ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if i % 2 == 0 and s [ i ] == '1' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if i % 2 == 1 and s [ i ] == '0' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return min ( ans , length - ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "1100" NEW_LINE length = len ( s ) NEW_LINE print ( minReplacement ( s , length ) ) NEW_LINE DEDENT
def groupCharacters ( s , l ) : NEW_LINE INDENT temp = " " NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] != ' ▁ ' ) : NEW_LINE INDENT temp = temp + s [ i ] NEW_LINE DEDENT DEDENT l = len ( temp ) NEW_LINE ans = " " NEW_LINE i = 0 NEW_LINE while ( i < l ) : NEW_LINE INDENT if ( ord ( temp [ i ] ) >= ord ( ' A ' ) and ord ( temp [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT while ( i < l and ord ( temp [ i ] ) >= ord ( ' A ' ) and ord ( temp [ i ] ) <= ord ( ' Z ' ) ) : NEW_LINE INDENT ans = ans + temp [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ans = ans + " ▁ " NEW_LINE DEDENT elif ( ord ( temp [ i ] ) >= ord ( '0' ) and ord ( temp [ i ] ) <= ord ( '9' ) ) : NEW_LINE INDENT while ( i < l and ord ( temp [ i ] ) >= ord ( '0' ) and ord ( temp [ i ] ) <= ord ( '9' ) ) : NEW_LINE INDENT ans = ans + temp [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ans = ans + " ▁ " NEW_LINE DEDENT else : NEW_LINE INDENT while ( i < l and ord ( temp [ i ] ) >= ord ( ' * ' ) and ord ( temp [ i ] ) <= ord ( ' / ' ) ) : NEW_LINE INDENT ans = ans + temp [ i ] NEW_LINE i += 1 NEW_LINE DEDENT ans = ans + " ▁ " NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "34FTG234 + ▁ + - ▁ * " NEW_LINE l = len ( s ) NEW_LINE print ( groupCharacters ( s , l ) ) NEW_LINE DEDENT
def Preprocess ( A , B ) : NEW_LINE INDENT n = len ( A ) NEW_LINE ans = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE mp [ A [ i ] ] = 1 NEW_LINE if A [ i ] == A [ n - i - 1 ] : NEW_LINE INDENT mp [ A [ n - i - 1 ] ] += 1 NEW_LINE DEDENT if B [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ B [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ B [ i ] ] = 1 NEW_LINE DEDENT if B [ n - i - 1 ] in mp . keys ( ) : NEW_LINE INDENT mp [ B [ n - 1 - i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ B [ n - 1 - i ] ] = 1 NEW_LINE DEDENT sz = len ( mp ) NEW_LINE if ( sz == 4 ) : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT elif ( sz == 3 ) : NEW_LINE INDENT ans += 1 + ( A [ i ] == A [ n - i - 1 ] ) NEW_LINE DEDENT elif ( sz == 2 ) : NEW_LINE INDENT ans += mp [ A [ i ] ] != 2 NEW_LINE DEDENT DEDENT if ( n % 2 == 1 and A [ n // 2 ] != B [ n // 2 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT A = " abacaba " NEW_LINE B = " bacabaa " NEW_LINE print ( Preprocess ( A , B ) ) NEW_LINE
def leastLexiString ( s ) : NEW_LINE INDENT if ( len ( s ) & 1 != 0 ) : NEW_LINE INDENT return s NEW_LINE DEDENT x = leastLexiString ( s [ 0 : int ( len ( s ) / 2 ) ] ) NEW_LINE y = leastLexiString ( s [ int ( len ( s ) / 2 ) : len ( s ) ] ) NEW_LINE return min ( x + y , y + x ) NEW_LINE DEDENT def areEquivalent ( a , b ) : NEW_LINE INDENT return ( leastLexiString ( a ) == leastLexiString ( b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = " aaba " NEW_LINE b = " abaa " NEW_LINE if ( areEquivalent ( a , b ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT a = " aabb " NEW_LINE b = " abab " NEW_LINE if ( areEquivalent ( a , b ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def generateString ( A , B ) : NEW_LINE INDENT rt = " " NEW_LINE while ( 0 < A or 0 < B ) : NEW_LINE INDENT if ( A < B ) : NEW_LINE INDENT if ( 0 < B ) : NEW_LINE INDENT rt = rt + ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT DEDENT elif ( B < A ) : NEW_LINE INDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( 0 < A ) : NEW_LINE INDENT rt += ' a ' NEW_LINE A -= 1 NEW_LINE DEDENT if ( 0 < B ) : NEW_LINE INDENT rt += ' b ' NEW_LINE B -= 1 NEW_LINE DEDENT DEDENT DEDENT print ( rt ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = 2 NEW_LINE B = 6 NEW_LINE generateString ( A , B ) NEW_LINE DEDENT
def getSubSeq ( s , n ) : NEW_LINE INDENT res = " " NEW_LINE cr = 0 NEW_LINE while ( cr < n ) : NEW_LINE INDENT mx = s [ cr ] NEW_LINE for i in range ( cr + 1 , n ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT lst = cr NEW_LINE for i in range ( cr , n ) : NEW_LINE INDENT if ( s [ i ] == mx ) : NEW_LINE INDENT res += s [ i ] NEW_LINE lst = i NEW_LINE DEDENT DEDENT cr = lst + 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE n = len ( s ) NEW_LINE print ( getSubSeq ( s , n ) ) NEW_LINE DEDENT
def countSubStr ( str , l , k ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT n = 0 NEW_LINE for j in range ( i , l , 1 ) : NEW_LINE INDENT n = n * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE if ( n % k == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "33445" NEW_LINE l = len ( str ) NEW_LINE k = 11 NEW_LINE print ( countSubStr ( str , l , k ) ) NEW_LINE DEDENT
def Colour_Combination ( s ) : NEW_LINE INDENT temp = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) , 1 ) : NEW_LINE INDENT if ( temp != s [ i ] ) : NEW_LINE INDENT if ( ( temp == ' B ' or temp == ' G ' ) and ( s [ i ] == ' G ' or s [ i ] == ' B ' ) ) : NEW_LINE INDENT temp = ' Y ' NEW_LINE DEDENT elif ( ( temp == ' B ' or temp == ' Y ' ) and ( s [ i ] == ' Y ' or s [ i ] == ' B ' ) ) : NEW_LINE INDENT temp = ' G ' NEW_LINE DEDENT else : NEW_LINE INDENT temp = ' B ' NEW_LINE DEDENT DEDENT DEDENT return temp NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " GBYGB " NEW_LINE print ( Colour_Combination ( s ) ) NEW_LINE DEDENT
def reverse ( str1 , x ) : NEW_LINE INDENT n = ( len ( str1 ) - x ) // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x - 1 , n - 1 , - 1 ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT for i in range ( n + x , len ( str1 ) ) : NEW_LINE INDENT print ( str1 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT str1 = " geeksforgeeks " NEW_LINE x = 3 NEW_LINE reverse ( str1 , x ) NEW_LINE
def lexoSmallest ( s , n ) : NEW_LINE INDENT ca = 0 NEW_LINE cb = 0 NEW_LINE cc = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT ca += 1 NEW_LINE DEDENT elif ( s [ i ] == ' b ' ) : NEW_LINE INDENT cb += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cc += 1 NEW_LINE DEDENT DEDENT if ( ca == cb and cb == cc ) : NEW_LINE INDENT return s NEW_LINE DEDENT cnt = n // 3 NEW_LINE if ( cnt * 3 != n ) : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT i = 0 NEW_LINE while ( ca < cnt and i < n ) : NEW_LINE INDENT if ( s [ i ] == ' b ' and cb > cnt ) : NEW_LINE INDENT cb -= 1 NEW_LINE s [ i ] = ' a ' NEW_LINE ca += 1 NEW_LINE DEDENT elif ( s [ i ] == ' c ' and cc > cnt ) : NEW_LINE INDENT cc -= 1 NEW_LINE s [ i ] = ' a ' NEW_LINE ca += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = 0 NEW_LINE DEDENT ' NEW_LINE INDENT while ( cb < cnt and i < n ) : NEW_LINE INDENT if ( s [ i ] == ' c ' and cc > cnt ) : NEW_LINE INDENT cc -= 1 NEW_LINE s [ i ] = '1' NEW_LINE cb += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT i = n - 1 NEW_LINE while ( cc < cnt and i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == ' a ' and ca > cnt ) : NEW_LINE INDENT ca -= 1 NEW_LINE s [ i ] = ' c ' NEW_LINE cc += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT i = n - 1 NEW_LINE while ( cb < cnt and i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == ' a ' and ca > cnt ) : NEW_LINE INDENT ca -= 1 NEW_LINE s [ i ] = ' b ' NEW_LINE cb += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT i = n - 1 NEW_LINE while ( cc < cnt and i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == ' b ' and cb > cnt ) : NEW_LINE INDENT cb -= 1 NEW_LINE s [ i ] = ' c ' NEW_LINE cc += 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT s = " aaaaaa " NEW_LINE n = len ( s ) NEW_LINE print ( * lexoSmallest ( list ( s ) , n ) , sep = " " ) NEW_LINE
def getSteps ( str , i , j , n ) : NEW_LINE INDENT k = i + 1 NEW_LINE steps = 0 NEW_LINE ch = str [ i ] NEW_LINE while ( k <= j ) : NEW_LINE INDENT if ( str [ k ] != ch ) : NEW_LINE INDENT steps = steps + 1 NEW_LINE ch = str [ k ] NEW_LINE DEDENT k = k + 1 NEW_LINE DEDENT return steps NEW_LINE DEDENT def getMinSteps ( str , i , j , n ) : NEW_LINE INDENT if ( j < i ) : NEW_LINE INDENT temp = i NEW_LINE i = j NEW_LINE j = temp NEW_LINE DEDENT stepsToRight = getSteps ( str , i , j , n ) NEW_LINE stepsToLeft = getSteps ( str , 0 , i , n ) + getSteps ( str , j , n - 1 , n ) NEW_LINE if ( str [ 0 ] != str [ n - 1 ] ) : NEW_LINE INDENT stepsToLeft = stepsToLeft + 1 NEW_LINE DEDENT return min ( stepsToLeft , stepsToRight ) NEW_LINE DEDENT str = " SSNSS " NEW_LINE n = len ( str ) NEW_LINE i = 0 NEW_LINE j = 3 NEW_LINE print ( getMinSteps ( str , i , j , n ) ) NEW_LINE
def removeChars ( s ) : NEW_LINE INDENT modifiedStr = " " NEW_LINE modifiedStr += s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] . isupper ( ) and s [ i - 1 ] . islower ( ) or s [ i ] . islower ( ) and s [ i - 1 ] . isupper ( ) ) : NEW_LINE INDENT modifiedStr += s [ i ] NEW_LINE DEDENT DEDENT return modifiedStr NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " GeeksForGeeks " NEW_LINE print ( removeChars ( s ) ) NEW_LINE DEDENT
def pangramCost ( arr , string ) : NEW_LINE INDENT cost = 0 NEW_LINE occurred = [ False ] * 26 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT occurred [ ord ( string [ i ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( not occurred [ i ] ) : NEW_LINE INDENT cost += arr [ i ] NEW_LINE DEDENT DEDENT return cost NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 ] NEW_LINE string = " abcdefghijklmopqrstuvwz " NEW_LINE print ( pangramCost ( arr , string ) ) NEW_LINE DEDENT
def pairStar ( Input , Output , i = 0 ) : NEW_LINE INDENT Output = Output + Input [ i ] NEW_LINE if ( i == len ( Input ) - 1 ) : NEW_LINE INDENT print ( Output ) NEW_LINE return ; NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( Input [ i ] == Input [ i + 1 ] ) : NEW_LINE INDENT Output = Output + ' * ' ; NEW_LINE DEDENT pairStar ( Input , Output , i + 1 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Input = " geeks " NEW_LINE Output = " " NEW_LINE pairStar ( Input , Output ) ; NEW_LINE DEDENT
def K_String ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE fre = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT fre [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT str = " " NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( fre [ i ] % k == 0 ) : NEW_LINE INDENT x = fre [ i ] // k NEW_LINE while ( x ) : NEW_LINE INDENT str += chr ( i + ord ( ' a ' ) ) NEW_LINE x -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " - 1" NEW_LINE DEDENT DEDENT return str NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabb " NEW_LINE k = 2 NEW_LINE print ( K_String ( s , k ) ) NEW_LINE DEDENT
def CountCharacters ( str , l , r ) : NEW_LINE INDENT cnt = 0 NEW_LINE m = { } NEW_LINE length = len ( str ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if ( not ( l <= ord ( str [ i ] ) and ord ( str [ i ] ) <= r ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE if ord ( str [ i ] ) not in m : NEW_LINE INDENT m [ ord ( str [ i ] ) ] = 0 NEW_LINE print ( str [ i ] , end = " ▁ " ) NEW_LINE DEDENT m [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE str = str . strip ( ) NEW_LINE l = 102 NEW_LINE r = 111 NEW_LINE print ( " Characters ▁ with ▁ ASCII ▁ values " , end = " " ) NEW_LINE print ( " not in the range [ l , r ] " , ▁ " in the given string are : " , ▁ end ▁ = ▁ " " ) NEW_LINE print ( " and their count is   " , CountCharacters ( str , l , r ) ) NEW_LINE DEDENT
def CountWords ( str , k ) : NEW_LINE INDENT sum = 0 NEW_LINE NumberOfWords = 0 NEW_LINE counter = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( str [ i ] == ' ▁ ' ) : NEW_LINE INDENT if ( sum < k ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT sum = 0 NEW_LINE NumberOfWords += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sum += ord ( str [ i ] ) NEW_LINE DEDENT DEDENT NumberOfWords += 1 NEW_LINE if ( sum < k ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT print ( " Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ ASCII " , " values ▁ less ▁ than ▁ k ▁ = " , counter ) NEW_LINE print ( " Number ▁ of ▁ words ▁ having ▁ sum ▁ of ▁ ASCII ▁ values " , " greater ▁ than ▁ or ▁ equal ▁ to ▁ k ▁ = " , NumberOfWords - counter ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " Learn ▁ how ▁ to ▁ code " NEW_LINE k = 400 NEW_LINE CountWords ( str , k ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def countPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE sum = 0 NEW_LINE hashTable = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( hashTable [ i ] ) : NEW_LINE INDENT sum += ( hashTable [ i ] * ( hashTable [ i ] + 1 ) // 2 ) NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " ananananddd " NEW_LINE print ( countPalindrome ( str ) ) NEW_LINE DEDENT
def countConsecutive ( s ) : NEW_LINE INDENT count = - 1 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( i <= len ( s ) ) : NEW_LINE INDENT if ( s [ i ] is s [ i + 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "44522255" NEW_LINE print ( countConsecutive ( str ) ) NEW_LINE DEDENT
def check_digits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT i = n NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( check_digits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2397 NEW_LINE print ( smallest_number ( N ) ) NEW_LINE DEDENT
def CountCharacters ( str1 , l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len1 = len ( str1 ) NEW_LINE for i in str1 : NEW_LINE INDENT if ( l <= ord ( i ) and ord ( i ) <= r ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = " geeksforgeeks " NEW_LINE l = 102 NEW_LINE r = 111 NEW_LINE print ( " Characters ▁ with ▁ ASCII ▁ values ▁ " + " in ▁ the ▁ range ▁ [ l , ▁ r ] ▁ are " ) NEW_LINE print ( " and their count is   " , CountCharacters ( str1 , l , r ) ) NEW_LINE DEDENT
def minSteps ( str ) : NEW_LINE INDENT count = 0 NEW_LINE i = 0 NEW_LINE while i < len ( str ) - 2 : NEW_LINE INDENT if str [ i ] == '0' : NEW_LINE INDENT if ( str [ i + 1 ] == '1' ) : NEW_LINE INDENT if ( str [ i + 2 ] == '0' ) : NEW_LINE INDENT count = count + 1 NEW_LINE i = i + 2 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT str = "0101010" NEW_LINE print ( minSteps ( str ) ) NEW_LINE
def CountCharacters ( str , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE l = len ( str ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( ord ( str [ i ] ) < k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " GeeksForGeeks " NEW_LINE k = 90 NEW_LINE count = CountCharacters ( str , k ) NEW_LINE print ( " Characters ▁ with ▁ ASCII ▁ values " , " less ▁ than ▁ K ▁ are " , count ) NEW_LINE print ( " Characters ▁ with ▁ ASCII ▁ values " , " greater ▁ than ▁ or ▁ equal ▁ to ▁ K ▁ are " , len ( str ) - count ) NEW_LINE DEDENT
import math NEW_LINE def fact ( n ) : NEW_LINE INDENT f = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f = f * i ; NEW_LINE DEDENT return f ; NEW_LINE DEDENT def npr ( n , r ) : NEW_LINE INDENT return fact ( n ) / fact ( n - r ) ; NEW_LINE DEDENT def countPermutations ( str ) : NEW_LINE INDENT even = math . floor ( len ( str ) / 2 ) ; NEW_LINE odd = len ( str ) - even ; NEW_LINE ways = 0 ; NEW_LINE freq = [ 0 ] * 26 ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT nvowels = ( freq [ 0 ] + freq [ 4 ] + freq [ 8 ] + freq [ 14 ] + freq [ 20 ] ) ; NEW_LINE nconsonants = len ( str ) - nvowels ; NEW_LINE ways = ( npr ( odd , nvowels ) * npr ( nconsonants , nconsonants ) ) ; NEW_LINE return int ( ways ) ; NEW_LINE DEDENT str = " geeks " ; NEW_LINE print ( countPermutations ( str ) ) ; NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT if ( ch != ' a ' and ch != ' e ' and ch != ' i ' and ch != ' o ' and ch != ' u ' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def replaceConsonants ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) == False ) : NEW_LINE INDENT if ( s [ i ] == ' z ' ) : NEW_LINE INDENT s [ i ] = ' b ' ; NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = chr ( ord ( s [ i ] ) + 1 ) ; NEW_LINE if ( isVowel ( s [ i ] ) == True ) : NEW_LINE INDENT s [ i ] = chr ( ord ( s [ i ] ) + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return ' ' . join ( s ) ; NEW_LINE DEDENT s = " geeksforgeeks " ; NEW_LINE print ( replaceConsonants ( list ( s ) ) ) ; NEW_LINE
def countOnOff ( n ) : NEW_LINE INDENT Led = [ 6 , 2 , 5 , 5 , 4 , 5 , 6 , 3 , 7 , 5 ] NEW_LINE leng = len ( n ) NEW_LINE sum = Led [ int ( n [ 0 ] ) - int ( '0' ) ] NEW_LINE for i in range ( 1 , leng ) : NEW_LINE INDENT sum = ( sum + abs ( Led [ int ( n [ i ] ) - int ( '0' ) ] - Led [ int ( n [ i - 1 ] ) - int ( '0' ) ] ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = "082" NEW_LINE print ( countOnOff ( n ) ) NEW_LINE DEDENT
def max_length_substring ( st , n , k ) : NEW_LINE INDENT max_len = 0 NEW_LINE len = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '0' ) : NEW_LINE INDENT len = len + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT len = 0 NEW_LINE DEDENT max_len = max ( max_len , len ) NEW_LINE DEDENT if ( max_len == n ) : NEW_LINE INDENT return n * k NEW_LINE DEDENT pref = 0 NEW_LINE suff = 0 NEW_LINE i = 0 NEW_LINE while ( st [ i ] == '0' ) : NEW_LINE INDENT i = i + 1 NEW_LINE pref = pref + 1 NEW_LINE DEDENT i = n - 1 NEW_LINE while ( st [ i ] == '0' ) : NEW_LINE INDENT i = i - 1 NEW_LINE suff = suff + 1 NEW_LINE DEDENT if ( k > 1 ) : NEW_LINE INDENT max_len = max ( max_len , pref + suff ) NEW_LINE DEDENT return max_len NEW_LINE DEDENT n = 6 NEW_LINE k = 3 NEW_LINE st = "110010" NEW_LINE ans = max_length_substring ( st , n , k ) NEW_LINE print ( ans ) NEW_LINE
def countSubStr ( S , X ) : NEW_LINE INDENT cnt = 0 NEW_LINE N = len ( S ) NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( S [ i ] != '0' ) : NEW_LINE INDENT j = 1 NEW_LINE while ( ( j + i ) <= N ) : NEW_LINE INDENT num = int ( S [ i : i + j ] ) NEW_LINE if ( num > X ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT S = "2222" ; NEW_LINE X = 97 ; NEW_LINE print ( countSubStr ( S , X ) ) NEW_LINE
' NEW_LINE def isBinary ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT temp = n % 10 NEW_LINE if temp != 0 and temp != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def formBinaryStr ( n , a ) : NEW_LINE INDENT flag = True NEW_LINE s = " " NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isBinary ( a [ i ] ) == True : NEW_LINE INDENT s += str ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT cout <<   " - 1 NEW_LINE DEDENT DEDENT " NEW_LINE if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , 1 , 0 , 11 , 10 ] NEW_LINE N = len ( a ) NEW_LINE formBinaryStr ( N , a ) NEW_LINE DEDENT
def checkPalindrome ( s ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != s [ len ( s ) - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def CheckOdd ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = " " NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT x += s [ j ] NEW_LINE if ( len ( x ) % 2 == 0 and checkPalindrome ( x ) == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE if ( CheckOdd ( s ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result *= i NEW_LINE DEDENT return result NEW_LINE DEDENT def getResult ( string , ch ) : NEW_LINE INDENT has = [ 0 ] * 26 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT has [ ord ( string [ i ] ) - ord ( ' A ' ) ] += 1 NEW_LINE DEDENT particular = has [ ord ( ch ) - ord ( ' A ' ) ] NEW_LINE if particular == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT has [ ord ( ch ) - ord ( ' A ' ) ] = 0 NEW_LINE total = len ( string ) NEW_LINE total = total - particular + 1 NEW_LINE result = fact ( total ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if has [ i ] > 1 : NEW_LINE INDENT result /= fact ( has [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " MISSISSIPPI " NEW_LINE print ( getResult ( string , ' S ' ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def count ( word ) : NEW_LINE INDENT freq = [ 0 for i in range ( 30 ) ] NEW_LINE vowel = 0 NEW_LINE consonant = 0 NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT freq [ ord ( word [ i ] ) - 65 ] += 1 NEW_LINE if ( word [ i ] == ' A ' or word [ i ] == ' E ' or word [ i ] == ' I ' or word [ i ] == ' O ' or word [ i ] == ' U ' ) : NEW_LINE INDENT vowel += 1 NEW_LINE DEDENT else : NEW_LINE INDENT consonant += 1 NEW_LINE DEDENT DEDENT vowelArrange = factorial ( vowel ) NEW_LINE vowelArrange //= factorial ( freq [ 0 ] ) NEW_LINE vowelArrange //= factorial ( freq [ 4 ] ) NEW_LINE vowelArrange //= factorial ( freq [ 8 ] ) NEW_LINE vowelArrange //= factorial ( freq [ 14 ] ) NEW_LINE vowelArrange //= factorial ( freq [ 20 ] ) NEW_LINE consonantArrange = factorial ( consonant ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( i != 0 and i != 4 and i != 8 and i != 14 and i != 20 ) : NEW_LINE INDENT consonantArrange //= factorial ( freq [ i ] ) NEW_LINE DEDENT DEDENT total = vowelArrange * consonantArrange NEW_LINE return total NEW_LINE DEDENT word = " COMPUTER " NEW_LINE ans = count ( word ) NEW_LINE print ( ans ) NEW_LINE
def productAscii ( str ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT prod = prod * ord ( str [ i ] ) NEW_LINE DEDENT return prod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " GfG " NEW_LINE print ( productAscii ( str ) ) NEW_LINE DEDENT
def balancedString ( str ) : NEW_LINE INDENT count , i = 0 , 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE count += 1 NEW_LINE DEDENT elif ( str [ i ] == ' ) ' and count != 0 ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE count -= 1 NEW_LINE DEDENT elif ( str [ i ] != ' ) ' ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if ( count != 0 ) : NEW_LINE INDENT for i in range ( count ) : NEW_LINE INDENT print ( " ) " , end = " " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : str = " gau ) ra ) v ( ku ( mar ( rajput ) ) " NEW_LINE INDENT balancedString ( str ) NEW_LINE DEDENT
def countStrings ( s ) : NEW_LINE INDENT sum = 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( i % 2 == 0 and s [ i ] == ' $ ' ) : NEW_LINE INDENT sum *= 21 NEW_LINE DEDENT elif ( s [ i ] == ' $ ' ) : NEW_LINE INDENT sum *= 5 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " s $ $ e $ " NEW_LINE print ( countStrings ( str ) ) NEW_LINE DEDENT
def removeDuplicatesFromString ( str2 ) : NEW_LINE INDENT counter = 0 ; NEW_LINE i = 0 ; NEW_LINE size = len ( str2 ) ; NEW_LINE str1 = list ( str2 ) ; NEW_LINE x = 0 ; NEW_LINE length = 0 ; NEW_LINE while ( i < size ) : NEW_LINE INDENT x = ord ( str1 [ i ] ) - 97 ; NEW_LINE if ( ( counter & ( 1 << x ) ) == 0 ) : NEW_LINE INDENT str1 [ length ] = chr ( 97 + x ) ; NEW_LINE counter = counter | ( 1 << x ) ; NEW_LINE length += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT str2 = ' ' . join ( str1 ) ; NEW_LINE return str2 [ 0 : length ] ; NEW_LINE DEDENT str1 = " geeksforgeeks " ; NEW_LINE print ( removeDuplicatesFromString ( str1 ) ) ; NEW_LINE
def firstPos ( str , start , end ) : NEW_LINE INDENT firstChar = - 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT firstChar = i NEW_LINE break NEW_LINE DEDENT DEDENT return firstChar NEW_LINE DEDENT def lastPos ( str , start , end ) : NEW_LINE INDENT lastChar = - 1 NEW_LINE for i in range ( start , end - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] >= ' a ' and str [ i ] <= ' z ' ) : NEW_LINE INDENT lastChar = i NEW_LINE break NEW_LINE DEDENT DEDENT return lastChar NEW_LINE DEDENT def isPalindrome ( str ) : NEW_LINE INDENT firstChar = 0 NEW_LINE lastChar = len ( str ) - 1 NEW_LINE ch = True NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT firstChar = firstPos ( str , firstChar , lastChar ) ; NEW_LINE lastChar = lastPos ( str , lastChar , firstChar ) ; NEW_LINE if ( lastChar < 0 or firstChar < 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( str [ firstChar ] == str [ lastChar ] ) : NEW_LINE INDENT firstChar += 1 NEW_LINE lastChar -= 1 NEW_LINE continue NEW_LINE DEDENT ch = False NEW_LINE break NEW_LINE DEDENT return ( ch ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " m TABSYMBOL a ▁ 343 ▁ la ▁ y ▁ a ▁ l ▁ am " NEW_LINE if ( isPalindrome ( str ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def powerOfJump ( s ) : NEW_LINE INDENT count = 1 NEW_LINE max_so_far = 0 NEW_LINE ch = s [ - 1 ] NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == ch : NEW_LINE INDENT if count > max_so_far : NEW_LINE INDENT max_so_far = count NEW_LINE DEDENT count = 1 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT st = "1010101" NEW_LINE print ( powerOfJump ( st ) ) NEW_LINE DEDENT
def averageValue ( s ) : NEW_LINE INDENT sum_char = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT sum_char += ord ( s [ i ] ) NEW_LINE DEDENT return sum_char // len ( s ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " GeeksforGeeks " NEW_LINE print ( averageValue ( s ) ) NEW_LINE DEDENT
def commonPrefixUtil ( str1 , str2 ) : NEW_LINE INDENT n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE result = " " NEW_LINE j = 0 NEW_LINE i = 0 NEW_LINE while ( i <= n1 - 1 and j <= n2 - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT result += ( str1 [ i ] ) NEW_LINE i += 1 NEW_LINE j += 1 NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE print ( commonPrefixUtil ( arr [ 0 ] , arr [ n - 1 ] ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ " geeksforgeeks " , " geeks " , " geek " , " geezer " ] NEW_LINE n = len ( arr ) NEW_LINE commonPrefix ( arr , n ) NEW_LINE DEDENT
def addBinaryUtil ( a , b ) : NEW_LINE result = " " ; NEW_LINE s = 0 ; NEW_LINE INDENT i = len ( a ) - 1 ; NEW_LINE j = len ( b ) - 1 ; NEW_LINE while ( i >= 0 or j >= 0 or s == 1 ) : NEW_LINE INDENT s += ( ord ( a [ i ] ) - ord ( '0' ) ) if ( i >= 0 ) else 0 ; NEW_LINE s += ( ord ( b [ j ] ) - ord ( '0' ) ) if ( j >= 0 ) else 0 ; NEW_LINE result = chr ( s % 2 + ord ( '0' ) ) + result ; NEW_LINE s //= 2 ; NEW_LINE i -= 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def addBinary ( arr , n ) : NEW_LINE INDENT result = " " ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = addBinaryUtil ( result , arr [ i ] ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT arr = [ "1" , "10" , "11" ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( addBinary ( arr , n ) ) ; NEW_LINE
def prefix ( k , n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 0 NEW_LINE count = 0 NEW_LINE i = 0 NEW_LINE Len = len ( k ) NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( k [ i ] == " a " ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT if ( k [ i ] == " b " ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count == 0 or n == 1 ) : NEW_LINE INDENT print ( count ) NEW_LINE return 0 NEW_LINE DEDENT if ( count == Len or a - b == 0 ) : NEW_LINE INDENT print ( count * n ) NEW_LINE return 0 NEW_LINE DEDENT n2 = n - 1 NEW_LINE count2 = 0 NEW_LINE while ( n2 != 0 ) : NEW_LINE INDENT for i in range ( Len ) : NEW_LINE INDENT if ( k [ i ] == " a " ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT if ( k [ i ] == " b " ) : NEW_LINE INDENT b += 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT DEDENT count += count2 NEW_LINE n2 -= 1 NEW_LINE if ( count2 == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( count2 == Len ) : NEW_LINE INDENT count += ( n2 * count2 ) NEW_LINE break NEW_LINE DEDENT count2 = 0 NEW_LINE DEDENT return count NEW_LINE DEDENT S = " aba " NEW_LINE N = 2 NEW_LINE print ( prefix ( S , N ) ) NEW_LINE S = " baa " NEW_LINE N = 3 NEW_LINE print ( prefix ( S , N ) ) NEW_LINE
def isCommonBase ( base , s1 , s2 ) : NEW_LINE ' NEW_LINE INDENT for j in range ( len ( s1 ) ) : NEW_LINE INDENT if ( base [ j % len ( base ) ] != s1 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT ' NEW_LINE INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( base [ j % len ( base ) ] != s2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonBases ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , min ( n1 , n2 ) + 1 ) : NEW_LINE INDENT base = s1 [ 0 : i ] NEW_LINE if ( isCommonBase ( base , s1 , s2 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " pqrspqrs " NEW_LINE s2 = " pqrspqrspqrspqrs " NEW_LINE print ( countCommonBases ( s1 , s2 ) ) NEW_LINE DEDENT
import math ; NEW_LINE def isPerfectSquareString ( str ) : NEW_LINE INDENT sum = 0 ; NEW_LINE l = len ( str ) ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT sum = sum + ord ( str [ i ] ) ; NEW_LINE DEDENT squareRoot = math . sqrt ( sum ) ; NEW_LINE return ( ( squareRoot - math . floor ( squareRoot ) ) == 0 ) ; NEW_LINE DEDENT str = " d " ; NEW_LINE if ( isPerfectSquareString ( str ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def is_vow ( c ) : NEW_LINE ' NEW_LINE INDENT return ( ( c == ' a ' ) or ( c == ' e ' ) or ( c == ' i ' ) or ( c == ' o ' ) or ( c == ' u ' ) ) ; NEW_LINE DEDENT def removeVowels ( str ) : NEW_LINE INDENT print ( str [ 0 ] , end = " " ) ; NEW_LINE for i in range ( 1 , len ( str ) ) : NEW_LINE INDENT if ( ( is_vow ( str [ i - 1 ] ) != True ) or ( is_vow ( str [ i ] ) != True ) ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT str = " ▁ geeks ▁ for ▁ geeks " ; NEW_LINE removeVowels ( str ) ; NEW_LINE
def transformString ( s ) : NEW_LINE ' NEW_LINE INDENT ch = ' a ' NEW_LINE if ( len ( s ) < 26 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( ord ( ch ) > ord ( ' z ' ) ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( s [ i ] <= ch ) : NEW_LINE INDENT s [ i ] = ch NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT DEDENT if ( ch <= ' z ' ) : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT print ( " " . join ( s ) ) NEW_LINE DEDENT s = list ( " aaaaaaaaaaaaaaaaaaaaaaaaaa " ) NEW_LINE transformString ( s ) NEW_LINE
def isPanDigital ( s ) : NEW_LINE INDENT digits = [ False ] * 10 ; NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT digits [ int ( s [ i ] ) - int ( '0' ) ] = True NEW_LINE DEDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT if ( digits [ i ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countPandigitalPairs ( v ) : NEW_LINE INDENT pairs = 0 NEW_LINE for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( v ) ) : NEW_LINE INDENT if ( isPanDigital ( v [ i ] + v [ j ] ) ) : NEW_LINE INDENT pairs = pairs + 1 NEW_LINE DEDENT DEDENT DEDENT return pairs NEW_LINE DEDENT v = [ "123567" , "098234" , "14765" , "19804" ] NEW_LINE print ( countPandigitalPairs ( v ) ) NEW_LINE
MAX_CHAR = [ 26 ] NEW_LINE def minChanges ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n > MAX_CHAR [ 0 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT dist_count = 0 NEW_LINE count = [ 0 ] * MAX_CHAR [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( count [ ord ( str [ i ] ) - ord ( ' a ' ) ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT count [ ( ord ( str [ i ] ) - ord ( ' a ' ) ) ] += 1 NEW_LINE DEDENT return ( n - dist_count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " aebaecedabbee " NEW_LINE print ( minChanges ( str ) ) NEW_LINE DEDENT
def numofstring ( n , m ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return m NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return m * ( m - 1 ) NEW_LINE DEDENT return m * ( m - 1 ) * pow ( m - 2 , n - 2 ) NEW_LINE DEDENT n = 2 NEW_LINE m = 3 NEW_LINE print ( numofstring ( n , m ) ) NEW_LINE
def CountSpecialPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE result = 0 ; NEW_LINE sameChar = [ 0 ] * n ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT sameCharCount = 1 ; NEW_LINE j = i + 1 ; NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT sameCharCount += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT result += int ( sameCharCount * ( sameCharCount + 1 ) / 2 ) ; NEW_LINE sameChar [ i ] = sameCharCount ; NEW_LINE i = j ; NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] ) : NEW_LINE INDENT sameChar [ j ] = sameChar [ j - 1 ] ; NEW_LINE DEDENT if ( j > 0 and j < ( n - 1 ) and ( str [ j - 1 ] == str [ j + 1 ] and str [ j ] != str [ j - 1 ] ) ) : NEW_LINE INDENT result += ( sameChar [ j - 1 ] if ( sameChar [ j - 1 ] < sameChar [ j + 1 ] ) else sameChar [ j + 1 ] ) ; NEW_LINE DEDENT DEDENT return result - n ; NEW_LINE DEDENT str = " abccba " ; NEW_LINE print ( CountSpecialPalindrome ( str ) ) ; NEW_LINE
def isCornerPresent ( str , corner ) : NEW_LINE INDENT n = len ( str ) NEW_LINE cl = len ( corner ) NEW_LINE if ( n < cl ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( str [ : cl ] == corner ) and ( str [ n - cl : ] == corner ) ) NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE corner = " geeks " NEW_LINE if ( isCornerPresent ( str , corner ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isConvertible ( str1 , str2 , k ) : NEW_LINE INDENT if ( ( len ( str1 ) + len ( str2 ) ) < k ) : NEW_LINE INDENT return True NEW_LINE DEDENT commonLength = 0 NEW_LINE for i in range ( 0 , min ( len ( str1 ) , len ( str2 ) ) , 1 ) : NEW_LINE INDENT if ( str1 [ i ] == str2 [ i ] ) : NEW_LINE INDENT commonLength += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( ( k - len ( str1 ) - len ( str2 ) + 2 * commonLength ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = " geek " NEW_LINE str2 = " geek " NEW_LINE k = 7 NEW_LINE if ( isConvertible ( str1 , str2 , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT str1 = " geeks " NEW_LINE str2 = " geek " NEW_LINE k = 5 NEW_LINE if ( isConvertible ( str1 , str2 , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 NEW_LINE def maxLower ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] >= ' A ' and str [ i ] <= ' Z ' : NEW_LINE INDENT i += 1 NEW_LINE break NEW_LINE DEDENT DEDENT maxCount = 0 NEW_LINE count = [ ] NEW_LINE for j in range ( MAX_CHAR ) : NEW_LINE INDENT count . append ( 0 ) NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT if str [ j ] >= ' A ' and str [ j ] <= ' Z ' : NEW_LINE INDENT currCount = 0 NEW_LINE for k in range ( MAX_CHAR ) : NEW_LINE INDENT if count [ k ] > 0 : NEW_LINE INDENT currCount += 1 NEW_LINE DEDENT DEDENT maxCount = max ( maxCount , currCount ) NEW_LINE for y in count : NEW_LINE INDENT y = 0 NEW_LINE DEDENT DEDENT if str [ j ] >= ' a ' and str [ j ] <= ' z ' : NEW_LINE INDENT count [ ord ( str [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT return maxCount NEW_LINE DEDENT str = " zACaAbbaazzC " ; NEW_LINE print ( maxLower ( str ) ) NEW_LINE
def first ( str ) : NEW_LINE INDENT for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if ( str [ i ] . istitle ( ) ) : NEW_LINE INDENT return str [ i ] NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT str = " geeksforGeeKS " NEW_LINE res = first ( str ) NEW_LINE if ( res == 0 ) : NEW_LINE INDENT print ( " No ▁ uppercase ▁ letter " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT
import math NEW_LINE def evenDecimalValue ( str , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT decimalValue = 0 ; NEW_LINE powerOf2 = 1 ; NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT decimalValue += ( ( int ( str [ k ] ) - 0 ) * powerOf2 ) NEW_LINE powerOf2 *= 2 NEW_LINE DEDENT if ( decimalValue % 2 == 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT str = "10010" NEW_LINE n = 5 NEW_LINE print ( evenDecimalValue ( str , n ) ) NEW_LINE
def solve ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE x = l // 2 NEW_LINE y = l NEW_LINE p = " " NEW_LINE while ( x > 0 and y > l / 2 ) : NEW_LINE INDENT p = p + s [ x - 1 ] NEW_LINE x = x - 1 NEW_LINE p = p + s [ y - 1 ] NEW_LINE y = y - 1 NEW_LINE DEDENT if ( y > l // 2 ) : NEW_LINE INDENT p = p + s [ y - 1 ] NEW_LINE y = y - 1 NEW_LINE DEDENT print ( p ) NEW_LINE DEDENT s = " sunshine " NEW_LINE solve ( s ) NEW_LINE
str = " GeeksforGeeks " NEW_LINE def string_length ( str ) : NEW_LINE INDENT if str == ' ' : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + string_length ( str [ 1 : ] ) NEW_LINE DEDENT DEDENT print ( string_length ( str ) ) NEW_LINE
def isConsonant ( ch ) : NEW_LINE INDENT ch = ch . upper ( ) NEW_LINE return not ( ch == ' A ' or ch == ' E ' or ch == ' I ' or ch == ' O ' or ch == ' U ' ) and ord ( ch ) >= 65 and ord ( ch ) <= 90 NEW_LINE DEDENT def totalConsonants ( string ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( isConsonant ( string [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT string = " abc ▁ de " NEW_LINE print ( totalConsonants ( string ) ) NEW_LINE
def solve ( n , t , p ) : NEW_LINE INDENT s = list ( p ) NEW_LINE for i in range ( 0 , t ) : NEW_LINE INDENT for j in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( s [ j ] == ' B ' and s [ j + 1 ] == ' G ' ) : NEW_LINE INDENT temp = s [ j ] ; NEW_LINE s [ j ] = s [ j + 1 ] ; NEW_LINE s [ j + 1 ] = temp ; NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT DEDENT print ( ' ' . join ( s ) ) NEW_LINE DEDENT n = 6 NEW_LINE t = 2 NEW_LINE p = " BBGBBG " NEW_LINE solve ( n , t , p ) NEW_LINE
def calSumUtil ( a , b , n , m ) : NEW_LINE INDENT sum = [ 0 ] * n NEW_LINE i = n - 1 NEW_LINE j = m - 1 NEW_LINE k = n - 1 NEW_LINE carry = 0 NEW_LINE s = 0 NEW_LINE while j >= 0 : NEW_LINE INDENT s = a [ i ] + b [ j ] + carry NEW_LINE sum [ k ] = ( s % 10 ) NEW_LINE carry = s // 10 NEW_LINE k -= 1 NEW_LINE i -= 1 NEW_LINE j -= 1 NEW_LINE DEDENT while i >= 0 : NEW_LINE INDENT s = a [ i ] + carry NEW_LINE sum [ k ] = ( s % 10 ) NEW_LINE carry = s // 10 NEW_LINE i -= 1 NEW_LINE k -= 1 NEW_LINE DEDENT ans = 0 NEW_LINE if carry : NEW_LINE INDENT ans = 10 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans += sum [ i ] NEW_LINE ans *= 10 NEW_LINE DEDENT return ans // 10 NEW_LINE DEDENT def calSum ( a , b , n , m ) : NEW_LINE INDENT if n >= m : NEW_LINE INDENT return calSumUtil ( a , b , n , m ) NEW_LINE DEDENT else : NEW_LINE INDENT return calSumUtil ( b , a , m , n ) NEW_LINE DEDENT DEDENT a = [ 9 , 3 , 9 ] NEW_LINE b = [ 6 , 1 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( calSum ( a , b , n , m ) ) NEW_LINE
SIZE = 26 NEW_LINE def longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) : NEW_LINE INDENT freq1 = [ 0 ] * SIZE NEW_LINE freq2 = [ 0 ] * SIZE NEW_LINE l = 0 NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( n1 ) : NEW_LINE INDENT freq1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for i in range ( n2 ) : NEW_LINE INDENT freq2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for i in range ( SIZE ) : NEW_LINE INDENT l += min ( freq1 [ i ] , freq2 [ i ] ) NEW_LINE DEDENT return l NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " abdacp " NEW_LINE str2 = " ckamb " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE print ( " Length ▁ = ▁ " , longCommomAnagramSubseq ( str1 , str2 , n1 , n2 ) ) NEW_LINE DEDENT
def isPanalphabeticWindow ( s , n ) : NEW_LINE INDENT ch = ' a ' NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ch ) : NEW_LINE INDENT ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT if ( ch == ' z ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = " abujm ▁ zvcd ▁ acefc ▁ deghf ▁ gijkle ▁ m ▁ n ▁ o ▁ p ▁ pafqrstuvwxyzfap " NEW_LINE n = len ( s ) NEW_LINE if ( isPanalphabeticWindow ( s , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def prime_index ( input ) : NEW_LINE INDENT p = list ( input ) NEW_LINE s = " " NEW_LINE for i in range ( 2 , len ( p ) + 1 ) : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT s = s + input [ i - 1 ] NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE DEDENT input = " GeeksforGeeks " NEW_LINE prime_index ( input ) NEW_LINE
def isHeterogram ( s , n ) : NEW_LINE INDENT hash = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] != ' ▁ ' : NEW_LINE INDENT if hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == 0 : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT s = " the ▁ big ▁ dwarf ▁ only ▁ jumps " NEW_LINE n = len ( s ) NEW_LINE print ( " YES " if isHeterogram ( s , n ) else " NO " ) NEW_LINE
def ASCIISentence ( str ) : NEW_LINE INDENT for i in str : NEW_LINE INDENT print ( ord ( i ) , end = ' ' ) NEW_LINE DEDENT print ( ' ' , ▁ end ▁ = ▁ ' ' ) NEW_LINE DEDENT str = " GeeksforGeeks " NEW_LINE print ( " ASCII ▁ Sentence : " ) NEW_LINE ASCIISentence ( str ) NEW_LINE
def convert ( string ) : NEW_LINE INDENT n = len ( string ) ; NEW_LINE string = list ( string ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == ' ▁ ' ) : NEW_LINE INDENT string [ i ] = ' _ ' ; NEW_LINE DEDENT else : NEW_LINE INDENT string [ i ] = string [ i ] . lower ( ) ; NEW_LINE DEDENT DEDENT string = " " . join ( string ) NEW_LINE print ( string ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " I ▁ got ▁ intern ▁ at ▁ geeksforgeeks " ; NEW_LINE convert ( string ) ; NEW_LINE DEDENT
def replace ( s , c1 , c2 ) : NEW_LINE INDENT l = len ( s ) NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] == c1 ) : NEW_LINE INDENT s = s [ 0 : i ] + c2 + s [ i + 1 : ] NEW_LINE DEDENT elif ( s [ i ] == c2 ) : NEW_LINE INDENT s = s [ 0 : i ] + c1 + s [ i + 1 : ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " grrksfoegrrks " NEW_LINE c1 = ' e ' NEW_LINE c2 = ' r ' NEW_LINE print ( replace ( s , c1 , c2 ) ) NEW_LINE DEDENT
max = 100 NEW_LINE def carveCross ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT print ( " Not ▁ possible . ▁ Please ▁ enter ▁ " ,   " odd length string . " ) NEW_LINE DEDENT else : NEW_LINE INDENT arr = [ [ False for x in range ( max ) ] for y in range ( max ) ] NEW_LINE m = n // 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT arr [ i ] [ j ] = ' X ' NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] [ m ] = str [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ m ] [ i ] = str [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " PICTURE " NEW_LINE carveCross ( str ) NEW_LINE DEDENT
def remainder ( st ) : NEW_LINE INDENT ln = len ( st ) NEW_LINE rem = 0 NEW_LINE for i in range ( 0 , ln ) : NEW_LINE INDENT num = rem * 10 + ( int ) ( st [ i ] ) NEW_LINE rem = num % 11 NEW_LINE DEDENT return rem NEW_LINE DEDENT st = "3435346456547566345436457867978" NEW_LINE print ( remainder ( st ) ) NEW_LINE
def findPermutations ( string , index , n ) : NEW_LINE INDENT if index >= n or ( index + 1 ) >= n : NEW_LINE INDENT print ( ' ' . join ( string ) ) NEW_LINE return NEW_LINE DEDENT findPermutations ( string , index + 1 , n ) NEW_LINE string [ index ] , string [ index + 1 ] = string [ index + 1 ] , string [ index ] NEW_LINE findPermutations ( string , index + 2 , n ) NEW_LINE string [ index ] , string [ index + 1 ] = string [ index + 1 ] , string [ index ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = list ( "12345" ) NEW_LINE n = len ( string ) NEW_LINE findPermutations ( string , 0 , n ) NEW_LINE DEDENT
def isUnique ( a , n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT sum += n - 1 NEW_LINE return ( sum == k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 3 , 3 ] NEW_LINE n = len ( a ) NEW_LINE k = 12 NEW_LINE if ( isUnique ( a , n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isPalindrome ( s , i , j ) : NEW_LINE INDENT p = j NEW_LINE for k in range ( i , p + 1 ) : NEW_LINE INDENT if ( s [ k ] != s [ p ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT p -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def countWays ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE count = 0 NEW_LINE if ( isPalindrome ( s , 0 , n - 1 ) ) : NEW_LINE INDENT for i in range ( n // 2 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT else : NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( n // 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ n - 1 - i ] ) : NEW_LINE INDENT j = n - 1 - i NEW_LINE if ( isPalindrome ( s , i , n - 2 - i ) ) : NEW_LINE INDENT for k in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ k ] != s [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT if ( isPalindrome ( s , i + 1 , n - 1 - i ) ) : NEW_LINE INDENT for k in range ( n - i , n ) : NEW_LINE INDENT if ( s [ k ] != s [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT count += 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT break NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abca " NEW_LINE print ( countWays ( s ) ) NEW_LINE DEDENT
def countOfSubstringWithKOnes ( s , K ) : NEW_LINE INDENT N = len ( s ) NEW_LINE res = 0 NEW_LINE countOfOne = 0 NEW_LINE freq = [ 0 for i in range ( N + 1 ) ] NEW_LINE freq [ 0 ] = 1 NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT countOfOne += ord ( s [ i ] ) - ord ( '0' ) NEW_LINE if ( countOfOne >= K ) : NEW_LINE INDENT res += freq [ countOfOne - K ] NEW_LINE DEDENT freq [ countOfOne ] += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "10010" NEW_LINE K = 1 NEW_LINE print ( countOfSubstringWithKOnes ( s , K ) ) NEW_LINE DEDENT
' NEW_LINE def reverse ( num , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT temp = num [ i ] NEW_LINE num [ i ] = num [ j ] NEW_LINE num [ j ] = temp NEW_LINE i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT def nextPalin ( num , n ) : NEW_LINE INDENT if ( n <= 3 ) : NEW_LINE INDENT print " Not ▁ Possible " NEW_LINE return NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT mid = n / 2 - 1 NEW_LINE i = mid - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( num [ i ] < num [ i + 1 ] ) : NEW_LINE INDENT break NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT if ( i < 0 ) : NEW_LINE INDENT print " Not ▁ Possible " NEW_LINE return NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT smallest = i + 1 NEW_LINE j = i + 2 NEW_LINE while j <= mid : NEW_LINE INDENT if ( num [ j ] > num [ i ] and num [ j ] < num [ smallest ] ) : NEW_LINE INDENT smallest = j NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT temp = num [ i ] NEW_LINE num [ i ] = num [ smallest ] NEW_LINE num [ smallest ] = temp NEW_LINE DEDENT ' NEW_LINE INDENT temp = num [ n - i - 1 ] NEW_LINE num [ n - i - 1 ] = num [ n - smallest - 1 ] NEW_LINE num [ n - smallest - 1 ] = temp NEW_LINE reverse ( num , i + 1 , mid ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT reverse ( num , mid + 1 , n - i - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT reverse ( num , mid + 2 , n - i - 2 ) NEW_LINE DEDENT result = ' ' . join ( num ) NEW_LINE print " Next ▁ Palindrome : ▁ " , result NEW_LINE DEDENT st = "4697557964" NEW_LINE num = list ( st ) NEW_LINE n = len ( st ) NEW_LINE nextPalin ( num , n ) NEW_LINE
def printRec ( number , extraOnes , remainingPlaces ) : NEW_LINE INDENT if ( 0 == remainingPlaces ) : NEW_LINE INDENT print ( number , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT printRec ( number + "1" , extraOnes + 1 , remainingPlaces - 1 ) NEW_LINE if ( 0 < extraOnes ) : NEW_LINE INDENT printRec ( number + "0" , extraOnes - 1 , remainingPlaces - 1 ) NEW_LINE DEDENT DEDENT def printNums ( n ) : NEW_LINE INDENT str = " " NEW_LINE printRec ( str , 0 , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE printNums ( n ) NEW_LINE DEDENT
def findstem ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE s = arr [ 0 ] NEW_LINE l = len ( s ) NEW_LINE res = " " NEW_LINE for i in range ( l ) : NEW_LINE INDENT for j in range ( i + 1 , l + 1 ) : NEW_LINE INDENT stem = s [ i : j ] NEW_LINE k = 1 NEW_LINE for k in range ( 1 , n ) : NEW_LINE INDENT if stem not in arr [ k ] : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( k + 1 == n and len ( res ) < len ( stem ) ) : NEW_LINE INDENT res = stem NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ " grace " , " graceful " , " disgraceful " , " gracefully " ] NEW_LINE stems = findstem ( arr ) NEW_LINE print ( stems ) NEW_LINE DEDENT
def nextHighUsingAtMostOneSwap ( st ) : NEW_LINE INDENT num = list ( st ) NEW_LINE l = len ( num ) NEW_LINE posRMax = l - 1 NEW_LINE index = - 1 NEW_LINE i = l - 2 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( num [ i ] >= num [ posRMax ] ) : NEW_LINE INDENT posRMax = i NEW_LINE DEDENT else : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT if ( index == - 1 ) : NEW_LINE INDENT return " Not ▁ Possible " NEW_LINE DEDENT greatSmallDgt = - 1 NEW_LINE i = l - 1 NEW_LINE while i > index : NEW_LINE INDENT if ( num [ i ] > num [ index ] ) : NEW_LINE INDENT if ( greatSmallDgt == - 1 ) : NEW_LINE INDENT greatSmallDgt = i NEW_LINE DEDENT elif ( num [ i ] <= num [ greatSmallDgt ] ) : NEW_LINE INDENT greatSmallDgt = i NEW_LINE DEDENT DEDENT i = i - 1 NEW_LINE DEDENT temp = num [ index ] NEW_LINE num [ index ] = num [ greatSmallDgt ] ; NEW_LINE num [ greatSmallDgt ] = temp ; NEW_LINE return ' ' . join ( num ) NEW_LINE DEDENT num = "218765" NEW_LINE print " Original ▁ number : ▁ " , num NEW_LINE print " Next ▁ higher ▁ number : ▁ " , nextHighUsingAtMostOneSwap ( num ) NEW_LINE
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) NEW_LINE DEDENT def longestVowel ( s ) : NEW_LINE INDENT count , res = 0 , 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( res , count ) NEW_LINE count = 0 NEW_LINE DEDENT DEDENT return max ( res , count ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " theeare " NEW_LINE print ( longestVowel ( s ) ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def check ( freq , k ) : NEW_LINE INDENT for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] and freq [ i ] != k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def substrings ( s , k ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for j in range ( i , len ( s ) ) : NEW_LINE INDENT index = ord ( s [ j ] ) - ord ( ' a ' ) NEW_LINE freq [ index ] += 1 NEW_LINE if ( freq [ index ] > k ) : NEW_LINE INDENT break NEW_LINE DEDENT elif ( freq [ index ] == k and check ( freq , k ) == True ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aabbcc " NEW_LINE k = 2 NEW_LINE print ( substrings ( s , k ) ) NEW_LINE s = " aabbc " ; NEW_LINE k = 2 ; NEW_LINE print ( substrings ( s , k ) ) NEW_LINE DEDENT
def countSubstrs ( str , i , j , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( countSubstrs ( str , i + 1 , j , n - 1 ) + countSubstrs ( str , i , j - 1 , n - 1 ) - countSubstrs ( str , i + 1 , j - 1 , n - 2 ) ) NEW_LINE if ( str [ i ] == str [ j ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT str = " abcab " NEW_LINE n = len ( str ) NEW_LINE print ( countSubstrs ( str , 0 , n - 1 , n ) ) NEW_LINE
def countManipulations ( s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE char_count = [ 0 ] * 26 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT char_count [ i ] = 0 NEW_LINE DEDENT for i in range ( len ( s1 ) ) : NEW_LINE INDENT char_count [ ord ( s1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT char_count [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if char_count [ i ] != 0 : NEW_LINE INDENT count += abs ( char_count [ i ] ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " ddcf " NEW_LINE s2 = " cedk " NEW_LINE print ( countManipulations ( s1 , s2 ) ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def stringPalindrome ( A , B ) : NEW_LINE INDENT countA = [ 0 ] * MAX_CHAR NEW_LINE countB = [ 0 ] * MAX_CHAR NEW_LINE l1 = len ( A ) NEW_LINE l2 = len ( B ) NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT countA [ ord ( A [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT countB [ ord ( B [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( ( countA [ i ] > 1 and countB [ i ] == 0 ) ) : NEW_LINE INDENT return ' A ' NEW_LINE DEDENT DEDENT return ' B ' NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = " abcdea " NEW_LINE b = " bcdesg " NEW_LINE print ( stringPalindrome ( a , b ) ) NEW_LINE DEDENT
MAX_CHAR = 256 NEW_LINE def countBalance ( string ) : NEW_LINE INDENT leftVisited = [ 0 ] * ( MAX_CHAR ) NEW_LINE rightVisited = [ 0 ] * ( MAX_CHAR ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT rightVisited [ ord ( string [ i ] ) ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT leftVisited [ ord ( string [ i ] ) ] += 1 NEW_LINE rightVisited [ ord ( string [ i ] ) ] -= 1 NEW_LINE j = 0 NEW_LINE while j < MAX_CHAR : NEW_LINE INDENT if ( ( leftVisited [ j ] == 0 and rightVisited [ j ] != 0 ) or ( leftVisited [ j ] != 0 and rightVisited [ j ] == 0 ) ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == MAX_CHAR : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " abaababa " NEW_LINE print ( countBalance ( string ) ) NEW_LINE DEDENT
def findFlips ( str , n ) : NEW_LINE INDENT last = ' ▁ ' NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( last != str [ i ] ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT last = str [ i ] NEW_LINE DEDENT return res // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "00011110001110" NEW_LINE n = len ( str ) NEW_LINE print ( findFlips ( str , n ) ) NEW_LINE DEDENT
def findLen ( A , n , k , ch ) : NEW_LINE INDENT maxlen = 1 NEW_LINE cnt = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r < n : NEW_LINE INDENT if A [ r ] != ch : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT while cnt > k : NEW_LINE INDENT if A [ l ] != ch : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT maxlen = max ( maxlen , r - l + 1 ) NEW_LINE r += 1 NEW_LINE DEDENT return maxlen NEW_LINE DEDENT def answer ( A , n , k ) : NEW_LINE INDENT maxlen = 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT maxlen = max ( maxlen , findLen ( A , n , k , chr ( i + ord ( ' A ' ) ) ) ) NEW_LINE maxlen = max ( maxlen , findLen ( A , n , k , chr ( i + ord ( ' a ' ) ) ) ) NEW_LINE DEDENT return maxlen NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE A = " ABABA " NEW_LINE print ( " Maximum ▁ length ▁ = " , answer ( A , n , k ) ) NEW_LINE n = 6 NEW_LINE k = 4 NEW_LINE B = " HHHHHH " NEW_LINE print ( " Maximum ▁ length ▁ = " , answer ( B , n , k ) ) NEW_LINE DEDENT
MAX_CHAR = 26 NEW_LINE def checkCorrectOrNot ( s ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 ; j = n - 1 NEW_LINE while ( i < j ) : NEW_LINE INDENT count1 [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count2 [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE i += 1 ; j -= 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count1 [ i ] != count2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = " ababc " NEW_LINE print ( " Yes " if checkCorrectOrNot ( s ) else " No " ) NEW_LINE
def maximumNum ( curr_num , res ) : NEW_LINE INDENT len1 = len ( curr_num ) ; NEW_LINE len2 = len ( res ) ; NEW_LINE if ( len1 == len2 ) : NEW_LINE INDENT i = 0 ; NEW_LINE while ( curr_num [ i ] == res [ i ] ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT if ( curr_num [ i ] < res [ i ] ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT else : NEW_LINE INDENT return curr_num ; NEW_LINE DEDENT DEDENT return res if ( len1 < len2 ) else curr_num ; NEW_LINE DEDENT def extractMaximum ( str ) : NEW_LINE INDENT n = len ( str ) ; NEW_LINE curr_num = " " ; NEW_LINE res = " " ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( i < n and str [ i ] == '0' ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT while ( i < n and str [ i ] >= '0' and str [ i ] <= '9' ) : NEW_LINE INDENT curr_num += str [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( len ( curr_num ) > 0 ) : NEW_LINE INDENT i -= 1 ; NEW_LINE DEDENT res = maximumNum ( curr_num , res ) ; NEW_LINE curr_num = " " ; NEW_LINE DEDENT if ( len ( curr_num ) == 0 and len ( res ) == 0 ) : NEW_LINE INDENT res += '0' ; NEW_LINE DEDENT return maximumNum ( curr_num , res ) ; NEW_LINE DEDENT str = "100klh564abc365bg " ; NEW_LINE print ( extractMaximum ( str ) ) ; NEW_LINE
def isDivisible999 ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE if ( n == 0 or num [ 0 ] == '0' ) : NEW_LINE INDENT return true NEW_LINE DEDENT if ( ( n % 3 ) == 1 ) : NEW_LINE INDENT num = "00" + num NEW_LINE DEDENT if ( ( n % 3 ) == 2 ) : NEW_LINE INDENT num = "0" + num NEW_LINE DEDENT gSum = 0 NEW_LINE for i in range ( 0 , n , 3 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ( ord ( num [ i ] ) - 48 ) * 100 NEW_LINE group += ( ord ( num [ i + 1 ] ) - 48 ) * 10 NEW_LINE group += ( ord ( num [ i + 2 ] ) - 48 ) NEW_LINE gSum += group NEW_LINE DEDENT if ( gSum > 1000 ) : NEW_LINE INDENT num = str ( gSum ) NEW_LINE n = len ( num ) NEW_LINE gSum = isDivisible999 ( num ) NEW_LINE DEDENT return ( gSum == 999 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = "1998" NEW_LINE n = len ( num ) NEW_LINE if ( isDivisible999 ( num ) ) : NEW_LINE INDENT print ( " Divisible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ divisible " ) NEW_LINE DEDENT DEDENT
MAX_CHAR = 26 NEW_LINE def arrangeString ( string ) : NEW_LINE INDENT char_count = [ 0 ] * MAX_CHAR NEW_LINE s = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] >= " A " and string [ i ] <= " Z " : NEW_LINE INDENT char_count [ ord ( string [ i ] ) - ord ( " A " ) ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s += ord ( string [ i ] ) - ord ( "0" ) NEW_LINE DEDENT DEDENT res = " " NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT ch = chr ( ord ( " A " ) + i ) NEW_LINE while char_count [ i ] : NEW_LINE INDENT res += ch NEW_LINE char_count [ i ] -= 1 NEW_LINE DEDENT DEDENT if s > 0 : NEW_LINE INDENT res += str ( s ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " ACCBA10D2EW30" NEW_LINE print ( arrangeString ( string ) ) NEW_LINE DEDENT
def subString ( Str , n ) : NEW_LINE INDENT for Len in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - Len + 1 ) : NEW_LINE INDENT j = i + Len - 1 NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT print ( Str [ k ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT DEDENT Str = " abc " NEW_LINE subString ( Str , len ( Str ) ) NEW_LINE
def isVowel ( ch ) : NEW_LINE INDENT return ch . upper ( ) in [ ' A ' , ' E ' , ' I ' , ' O ' , ' U ' ] NEW_LINE DEDENT def countVowels ( str ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if isVowel ( str [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT str = ' abc ▁ de ' NEW_LINE print ( countVowels ( str ) ) NEW_LINE
def printRotatedString ( str ) : NEW_LINE INDENT lenn = len ( str ) NEW_LINE temp = [ 0 ] * ( lenn ) NEW_LINE for i in range ( lenn ) : NEW_LINE DEDENT j = i NEW_LINE k = 0 NEW_LINE INDENT while ( j < len ( str ) ) : NEW_LINE INDENT temp [ k ] = str [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT j = 0 NEW_LINE while ( j < i ) : NEW_LINE INDENT temp [ k ] = str [ j ] NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT print ( * temp , sep = " " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " geeks " NEW_LINE printRotatedString ( str ) NEW_LINE DEDENT
def isPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def maxLengthNonPalinSubstring ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE ch = str [ 0 ] NEW_LINE i = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( str [ i ] != ch ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isPalindrome ( str ) ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT return n NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abba " NEW_LINE print ( " Maximum ▁ length ▁ = " , maxLengthNonPalinSubstring ( str ) ) NEW_LINE DEDENT
def isKthBitSet ( n , k ) : NEW_LINE INDENT if ( ( n >> ( k - 1 ) ) and 1 ) : NEW_LINE INDENT print ( " SET " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NOT ▁ SET " ) NEW_LINE DEDENT DEDENT n , k = 5 , 1 NEW_LINE isKthBitSet ( n , k ) NEW_LINE
MAX_CHAR = 26 ; NEW_LINE ' NEW_LINE def countFreq ( str1 , freq , len1 ) : NEW_LINE INDENT for i in range ( len1 ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT DEDENT def canMakePalindrome ( freq , len1 ) : NEW_LINE INDENT count_odd = 0 ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT DEDENT if ( len1 % 2 == 0 ) : NEW_LINE INDENT if ( count_odd > 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if ( count_odd != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def findOddAndRemoveItsFreq ( freq ) : NEW_LINE INDENT odd_str = " " ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT freq [ i ] -= 1 ; NEW_LINE odd_str += chr ( i + ord ( ' a ' ) ) ; NEW_LINE return odd_str ; NEW_LINE DEDENT DEDENT return odd_str ; NEW_LINE DEDENT def findPalindromicString ( str1 ) : NEW_LINE INDENT len1 = len ( str1 ) ; NEW_LINE freq = [ 0 ] * MAX_CHAR ; NEW_LINE countFreq ( str1 , freq , len1 ) ; NEW_LINE if ( canMakePalindrome ( freq , len1 ) == False ) : NEW_LINE INDENT return " No ▁ Palindromic ▁ String " ; NEW_LINE DEDENT odd_str = findOddAndRemoveItsFreq ( freq ) ; NEW_LINE front_str = " " ; NEW_LINE rear_str = " ▁ " ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT temp = " " ; NEW_LINE if ( freq [ i ] != 0 ) : NEW_LINE INDENT ch = chr ( i + ord ( ' a ' ) ) ; NEW_LINE for j in range ( 1 , int ( freq [ i ] / 2 ) + 1 ) : NEW_LINE INDENT temp += ch ; NEW_LINE DEDENT front_str += temp ; NEW_LINE rear_str = temp + rear_str ; NEW_LINE DEDENT DEDENT return ( front_str + odd_str + rear_str ) ; NEW_LINE DEDENT str1 = " malayalam " ; NEW_LINE print ( findPalindromicString ( str1 ) ) ; NEW_LINE
def checkEquality ( s ) : NEW_LINE INDENT return ( ord ( s [ 0 ] ) == ord ( s [ len ( s ) - 1 ] ) ) ; NEW_LINE DEDENT def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , n - i + 1 ) : NEW_LINE INDENT if ( checkEquality ( s [ i : i + j ] ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT s = " abcab " ; NEW_LINE print ( countSubstringWithEqualEnds ( s ) ) ; NEW_LINE
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT s = " abcab " ; NEW_LINE print ( countSubstringWithEqualEnds ( s ) ) NEW_LINE
def maxRepeating ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE for i in range ( l ) : NEW_LINE INDENT cur_count = 1 NEW_LINE for j in range ( i + 1 , l ) : NEW_LINE INDENT if ( str [ i ] != str [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT cur_count += 1 NEW_LINE DEDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " aaaabbaaccde " NEW_LINE print ( maxRepeating ( str ) ) NEW_LINE DEDENT
def findSum ( str1 , str2 ) : NEW_LINE INDENT if ( len ( str1 ) > len ( str2 ) ) : NEW_LINE INDENT t = str1 ; NEW_LINE str1 = str2 ; NEW_LINE str2 = t ; NEW_LINE DEDENT str = " " ; NEW_LINE n1 = len ( str1 ) ; NEW_LINE n2 = len ( str2 ) ; NEW_LINE str1 = str1 [ : : - 1 ] ; NEW_LINE str2 = str2 [ : : - 1 ] ; NEW_LINE carry = 0 ; NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - 48 ) + ( ( ord ( str2 [ i ] ) - 48 ) + carry ) ) ; NEW_LINE str += chr ( sum % 10 + 48 ) ; NEW_LINE carry = int ( sum / 10 ) ; NEW_LINE DEDENT for i in range ( n1 , n2 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - 48 ) + carry ) ; NEW_LINE str += chr ( sum % 10 + 48 ) ; NEW_LINE carry = ( int ) ( sum / 10 ) ; NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str += chr ( carry + 48 ) ; NEW_LINE DEDENT str = str [ : : - 1 ] ; NEW_LINE return str ; NEW_LINE DEDENT str1 = "12" ; NEW_LINE str2 = "198111" ; NEW_LINE print ( findSum ( str1 , str2 ) ) ; NEW_LINE
def findSum ( str1 , str2 ) : NEW_LINE INDENT if len ( str1 ) > len ( str2 ) : NEW_LINE INDENT temp = str1 NEW_LINE str1 = str2 NEW_LINE str2 = temp NEW_LINE DEDENT str3 = " " NEW_LINE n1 = len ( str1 ) NEW_LINE n2 = len ( str2 ) NEW_LINE diff = n2 - n1 NEW_LINE carry = 0 NEW_LINE for i in range ( n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( ( ord ( str1 [ i ] ) - ord ( '0' ) ) + int ( ( ord ( str2 [ i + diff ] ) - ord ( '0' ) ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT for i in range ( n2 - n1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = ( ( ord ( str2 [ i ] ) - ord ( '0' ) ) + carry ) NEW_LINE str3 = str3 + str ( sum % 10 ) NEW_LINE carry = sum // 10 NEW_LINE DEDENT if ( carry ) : NEW_LINE INDENT str3 + str ( carry + '0' ) NEW_LINE DEDENT str3 = str3 [ : : - 1 ] NEW_LINE return str3 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = "12" NEW_LINE str2 = "198111" NEW_LINE print ( findSum ( str1 , str2 ) ) NEW_LINE DEDENT
def areCharactersUnique ( s ) : NEW_LINE INDENT checker = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT val = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE if ( checker & ( 1 << val ) ) > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT checker |= ( 1 << val ) NEW_LINE DEDENT return True NEW_LINE DEDENT s = " aaabbccdaa " NEW_LINE if areCharactersUnique ( s ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def countWords ( str , l ) : NEW_LINE INDENT count = 1 ; NEW_LINE if ( l == 1 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( str [ 0 ] == str [ 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT for j in range ( 1 , l - 1 ) : NEW_LINE INDENT if ( str [ j ] == str [ j - 1 ] and str [ j ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT elif ( str [ j ] == str [ j - 1 ] or str [ j ] == str [ j + 1 ] or str [ j - 1 ] == str [ j + 1 ] ) : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 3 NEW_LINE DEDENT DEDENT if ( str [ l - 1 ] == str [ l - 2 ] ) : NEW_LINE INDENT count *= 1 NEW_LINE DEDENT else : NEW_LINE INDENT count *= 2 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abc " NEW_LINE l = len ( str ) NEW_LINE print ( countWords ( str , l ) ) NEW_LINE DEDENT
def replaceDig ( x , from1 , to ) : NEW_LINE INDENT result = 0 NEW_LINE multiply = 1 NEW_LINE while ( x > 0 ) : NEW_LINE INDENT reminder = x % 10 NEW_LINE if ( reminder == from1 ) : NEW_LINE INDENT result = result + to * multiply NEW_LINE DEDENT else : NEW_LINE INDENT result = result + reminder * multiply NEW_LINE DEDENT multiply *= 10 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT return result NEW_LINE DEDENT def calculateMinMaxSum ( x1 , x2 ) : NEW_LINE INDENT minSum = replaceDig ( x1 , 6 , 5 ) + replaceDig ( x2 , 6 , 5 ) NEW_LINE maxSum = replaceDig ( x1 , 5 , 6 ) + replaceDig ( x2 , 5 , 6 ) NEW_LINE print ( " Minimum ▁ sum ▁ = " , minSum ) NEW_LINE print ( " Maximum ▁ sum ▁ = " , maxSum , end = " ▁ " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 5466 NEW_LINE x2 = 4555 NEW_LINE calculateMinMaxSum ( x1 , x2 ) NEW_LINE DEDENT
def qType1 ( l , x , str1 ) : NEW_LINE INDENT str1 [ l - 1 ] = x NEW_LINE DEDENT def qType2 ( l , r , str1 ) : NEW_LINE INDENT freq = [ 0 for i in range ( 27 ) ] NEW_LINE for i in range ( l - 1 , r ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT if ( freq [ j ] % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if count <= 1 : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT str1 = " geeksforgeeks " NEW_LINE str2 = [ i for i in str1 ] NEW_LINE n = len ( str2 ) NEW_LINE qType1 ( 4 , ' g ' , str2 ) NEW_LINE qType2 ( 1 , 4 , str2 ) NEW_LINE qType2 ( 2 , 3 , str2 ) NEW_LINE qType1 ( 10 , ' t ' , str2 ) NEW_LINE qType2 ( 10 , 11 , str2 ) NEW_LINE
def findTwoscomplement ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return '1' + str NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT k = i - 1 NEW_LINE while ( k >= 0 ) : NEW_LINE INDENT if ( str [ k ] == '1' ) : NEW_LINE INDENT str = list ( str ) NEW_LINE str [ k ] = '0' NEW_LINE str = ' ' . join ( str ) NEW_LINE DEDENT else : NEW_LINE INDENT str = list ( str ) NEW_LINE str [ k ] = '1' NEW_LINE str = ' ' . join ( str ) NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT return str NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "00000101" NEW_LINE print ( findTwoscomplement ( str ) ) NEW_LINE DEDENT
def isequal ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE num = 0 NEW_LINE x = 1 NEW_LINE i = n - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( '0' <= str [ i ] and str [ i ] <= '9' ) : NEW_LINE INDENT num = ( ord ( str [ i ] ) - ord ( '0' ) ) * x + num NEW_LINE x = x * 10 NEW_LINE if ( num >= n ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return num == i + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks13" NEW_LINE print ( " Yes " ) if isequal ( str ) else print ( " No " ) NEW_LINE DEDENT
def countToMake0lternate ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( countToMake0lternate ( "000111" ) ) NEW_LINE print ( countToMake0lternate ( "11111" ) ) NEW_LINE print ( countToMake0lternate ( "01010101" ) ) NEW_LINE DEDENT
def flip ( ch ) : NEW_LINE INDENT return '1' if ( ch == '0' ) else '0' NEW_LINE DEDENT def getFlipWithStartingCharcter ( str , expected ) : NEW_LINE INDENT flipCount = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] != expected ) : NEW_LINE INDENT flipCount += 1 NEW_LINE DEDENT expected = flip ( expected ) NEW_LINE DEDENT return flipCount NEW_LINE DEDENT def minFlipToMakeStringAlternate ( str ) : NEW_LINE INDENT return min ( getFlipWithStartingCharcter ( str , '0' ) , getFlipWithStartingCharcter ( str , '1' ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "0001010111" NEW_LINE print ( minFlipToMakeStringAlternate ( str ) ) NEW_LINE DEDENT
def remainderWith7 ( num ) : NEW_LINE INDENT series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] ; NEW_LINE series_index = 0 ; NEW_LINE result = 0 ; NEW_LINE for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - 48 ; NEW_LINE result += digit * series [ series_index ] ; NEW_LINE series_index = ( series_index + 1 ) % 6 ; NEW_LINE result %= 7 ; NEW_LINE DEDENT if ( result < 0 ) : NEW_LINE INDENT result = ( result + 7 ) % 7 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT str = "12345" ; NEW_LINE print ( " Remainder ▁ with ▁ 7 ▁ is " , remainderWith7 ( str ) ) ; NEW_LINE
def intToRoman ( num ) : NEW_LINE INDENT m = [ " " , " M " , " MM " , " MMM " ] NEW_LINE c = [ " " , " C " , " CC " , " CCC " , " CD " , " D " , " DC " , " DCC " , " DCCC " , " CM ▁ " ] NEW_LINE x = [ " " , " X " , " XX " , " XXX " , " XL " , " L " , " LX " , " LXX " , " LXXX " , " XC " ] NEW_LINE i = [ " " , " I " , " II " , " III " , " IV " , " V " , " VI " , " VII " , " VIII " , " IX " ] NEW_LINE thousands = m [ num // 1000 ] NEW_LINE hundereds = c [ ( num % 1000 ) // 100 ] NEW_LINE tens = x [ ( num % 100 ) // 10 ] NEW_LINE ones = i [ num % 10 ] NEW_LINE ans = ( thousands + hundereds + tens + ones ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT number = 3549 NEW_LINE print ( intToRoman ( number ) ) NEW_LINE DEDENT
def pattern ( st , length ) : NEW_LINE INDENT for i in range ( length ) : NEW_LINE INDENT j = length - 1 - i NEW_LINE for k in range ( length ) : NEW_LINE INDENT if ( k == i or k == j ) : NEW_LINE INDENT print ( st [ k ] , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT st = " geeksforgeeks " NEW_LINE length = len ( st ) NEW_LINE pattern ( st , length ) NEW_LINE DEDENT
no_of_chars = 256 NEW_LINE ' NEW_LINE def findSubString ( string , pat ) : NEW_LINE INDENT len1 = len ( string ) NEW_LINE len2 = len ( pat ) NEW_LINE if len1 < len2 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT hash_pat = [ 0 ] * no_of_chars NEW_LINE hash_str = [ 0 ] * no_of_chars NEW_LINE for i in range ( 0 , len2 ) : NEW_LINE INDENT hash_pat [ ord ( pat [ i ] ) ] += 1 NEW_LINE DEDENT start , start_index , min_len = 0 , - 1 , float ( ' inf ' ) NEW_LINE for j in range ( 0 , len1 ) : NEW_LINE INDENT hash_str [ ord ( string [ j ] ) ] += 1 NEW_LINE if ( hash_str [ ord ( string [ j ] ) ] <= hash_pat [ ord ( string [ j ] ) ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == len2 : NEW_LINE INDENT while ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] or hash_pat [ ord ( string [ start ] ) ] == 0 ) : NEW_LINE INDENT if ( hash_str [ ord ( string [ start ] ) ] > hash_pat [ ord ( string [ start ] ) ] ) : NEW_LINE INDENT hash_str [ ord ( string [ start ] ) ] -= 1 NEW_LINE DEDENT start += 1 NEW_LINE DEDENT len_window = j - start + 1 NEW_LINE if min_len > len_window : NEW_LINE INDENT min_len = len_window NEW_LINE start_index = start NEW_LINE DEDENT DEDENT DEDENT if start_index == - 1 : NEW_LINE INDENT print ( " No ▁ such ▁ window ▁ exists " ) NEW_LINE return " " NEW_LINE DEDENT return string [ start_index : start_index + min_len ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " this ▁ is ▁ a ▁ test ▁ string " NEW_LINE pat = " tist " NEW_LINE print ( " Smallest ▁ window ▁ is ▁ : ▁ " ) NEW_LINE print ( findSubString ( string , pat ) ) NEW_LINE DEDENT
import math NEW_LINE set = [ ] NEW_LINE prime = [ ] NEW_LINE def isPrime ( x ) : NEW_LINE INDENT sqroot = int ( math . sqrt ( x ) ) NEW_LINE flag = True NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , sqroot + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def display ( ) : NEW_LINE INDENT global set , prime NEW_LINE length = len ( set ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT print ( set [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def primeSum ( total , N , S , index ) : NEW_LINE INDENT global set , prime NEW_LINE if ( total == S and len ( set ) == N ) : NEW_LINE INDENT display ( ) NEW_LINE return NEW_LINE DEDENT if ( total > S or index == len ( prime ) ) : NEW_LINE INDENT return NEW_LINE DEDENT set . append ( prime [ index ] ) NEW_LINE primeSum ( total + prime [ index ] , N , S , index + 1 ) NEW_LINE set . pop ( ) NEW_LINE primeSum ( total , N , S , index + 1 ) NEW_LINE DEDENT def allPrime ( N , S , P ) : NEW_LINE INDENT global set , prime NEW_LINE for i in range ( P + 1 , S + 1 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT prime . append ( i ) NEW_LINE DEDENT DEDENT if ( len ( prime ) < N ) : NEW_LINE INDENT return NEW_LINE DEDENT primeSum ( 0 , N , S , 0 ) NEW_LINE DEDENT S = 54 NEW_LINE N = 2 NEW_LINE P = 3 NEW_LINE allPrime ( N , S , P ) NEW_LINE
def F ( A , B ) : NEW_LINE INDENT if ( A == 1 ) : NEW_LINE INDENT return ( 4 % B ) ; NEW_LINE DEDENT else : NEW_LINE INDENT temp = F ( A - 1 , B ) ; NEW_LINE return ( temp * temp ) % B ; NEW_LINE DEDENT DEDENT A = 25 ; NEW_LINE B = 50 ; NEW_LINE print ( F ( A , B ) ) ; NEW_LINE
MOD = 1000000007 ; NEW_LINE def rangeSum ( l , r ) : NEW_LINE INDENT a = 1 ; b = 9 ; res = 0 ; NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT L = max ( l , a ) ; NEW_LINE R = min ( r , b ) ; NEW_LINE if ( L <= R ) : NEW_LINE INDENT sum = ( L + R ) * ( R - L + 1 ) // 2 ; NEW_LINE res += ( i * i ) * ( sum % MOD ) ; NEW_LINE res %= MOD ; NEW_LINE DEDENT a *= 10 ; NEW_LINE b = b * 10 + 9 ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 98 ; r = 102 ; NEW_LINE print ( rangeSum ( l , r ) ) ; NEW_LINE DEDENT
import random NEW_LINE permutation = [ ] NEW_LINE def printPermutation ( ) : NEW_LINE INDENT for i in permutation : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT def give_random_number ( l , r ) : NEW_LINE INDENT x = random . randint ( l , r ) NEW_LINE return x NEW_LINE DEDENT def generate_random_permutation ( l , r ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return NEW_LINE DEDENT n = give_random_number ( l , r ) NEW_LINE permutation . append ( n ) NEW_LINE generate_random_permutation ( l , n - 1 ) NEW_LINE generate_random_permutation ( n + 1 , r ) NEW_LINE DEDENT l = 5 NEW_LINE r = 15 NEW_LINE generate_random_permutation ( l , r ) NEW_LINE printPermutation ( ) NEW_LINE
INF = 99999 NEW_LINE size = 10 NEW_LINE def getSetBitsFromOneToN ( N ) : NEW_LINE INDENT two , ans = 2 , 0 NEW_LINE n = N NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( N // two ) * ( two >> 1 ) NEW_LINE if ( ( N & ( two - 1 ) ) > ( two >> 1 ) - 1 ) : NEW_LINE INDENT ans += ( N & ( two - 1 ) ) - ( two >> 1 ) + 1 NEW_LINE DEDENT two <<= 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def findMinimum ( x ) : NEW_LINE INDENT low = 0 NEW_LINE high = 100000 NEW_LINE ans = high NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( getSetBitsFromOneToN ( mid ) >= x ) : NEW_LINE INDENT ans = min ( ans , mid ) NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT x = 20 NEW_LINE print ( findMinimum ( x ) ) NEW_LINE
def trailingZeroes ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT n = int ( n / 5 ) NEW_LINE cnt += n NEW_LINE DEDENT return cnt NEW_LINE DEDENT def binarySearch ( n ) : NEW_LINE INDENT low = 0 NEW_LINE while low < high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE count = trailingZeroes ( mid ) NEW_LINE if count < n : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid NEW_LINE DEDENT DEDENT result = list ( ) NEW_LINE while trailingZeroes ( low ) == n : NEW_LINE INDENT result . append ( low ) NEW_LINE low += 1 NEW_LINE DEDENT for i in range ( len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 2 NEW_LINE binarySearch ( n ) NEW_LINE
import math NEW_LINE def minDaysToEmpty ( C , l ) : NEW_LINE INDENT if ( l >= C ) : return C NEW_LINE eq_root = ( math . sqrt ( 1 + 8 * ( C - l ) ) - 1 ) / 2 NEW_LINE return math . ceil ( eq_root ) + l NEW_LINE DEDENT print ( minDaysToEmpty ( 5 , 2 ) ) NEW_LINE print ( minDaysToEmpty ( 6514683 , 4965 ) ) NEW_LINE
def kth ( arr1 , arr2 , m , n , k ) : NEW_LINE INDENT sorted1 = [ 0 ] * ( m + n ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE d = 0 NEW_LINE while ( i < m and j < n ) : NEW_LINE INDENT if ( arr1 [ i ] < arr2 [ j ] ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT d += 1 NEW_LINE DEDENT while ( i < m ) : NEW_LINE INDENT sorted1 [ d ] = arr1 [ i ] NEW_LINE d += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j < n ) : NEW_LINE INDENT sorted1 [ d ] = arr2 [ j ] NEW_LINE d += 1 NEW_LINE j += 1 NEW_LINE DEDENT return sorted1 [ k - 1 ] NEW_LINE DEDENT arr1 = [ 2 , 3 , 6 , 7 , 9 ] NEW_LINE arr2 = [ 1 , 4 , 8 , 10 ] NEW_LINE k = 5 NEW_LINE print ( kth ( arr1 , arr2 , 5 , 4 , k ) ) NEW_LINE
def bsearch ( low , high , n , arr ) : NEW_LINE INDENT mid = ( low + high ) / 2 NEW_LINE if ( low <= high ) : NEW_LINE INDENT if ( arr [ mid ] < n ) : NEW_LINE INDENT return bsearch ( mid + 1 , high , n , arr ) ; NEW_LINE DEDENT return bsearch ( low , mid - 1 , n , arr ) ; NEW_LINE DEDENT return low ; NEW_LINE DEDENT def mindiff ( arr , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sorted ( arr ) NEW_LINE DEDENT ans = 2147483647 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT p = bsearch ( 0 , m - 1 , arr [ i ] [ j ] , arr [ i + 1 ] ) NEW_LINE ans = min ( ans , abs ( arr [ i + 1 ] [ p ] - arr [ i ] [ j ] ) ) NEW_LINE if ( p - 1 >= 0 ) : NEW_LINE INDENT ans = min ( ans , abs ( arr [ i + 1 ] [ p - 1 ] - arr [ i ] [ j ] ) ) NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT m = [ 8 , 5 ] , [ 6 , 8 ] NEW_LINE print mindiff ( m , 2 , 2 ) NEW_LINE
def binarySearch ( arr , left , right ) : NEW_LINE INDENT if ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 ; NEW_LINE if ( arr [ mid - 1 ] < arr [ mid ] and arr [ mid ] > arr [ mid + 1 ] ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT if ( arr [ mid ] < arr [ mid + 1 ] ) : NEW_LINE INDENT return binarySearch ( arr , mid + 1 , right ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return binarySearch ( arr , left , mid - 1 ) ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 6 , 7 , 8 , 11 , 9 , 5 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE index = binarySearch ( arr , 1 , n - 2 ) ; NEW_LINE if ( index != - 1 ) : NEW_LINE INDENT print ( arr [ index ] ) ; NEW_LINE DEDENT
def findRepeatingElement ( arr , low , high ) : NEW_LINE INDENT if low > high : NEW_LINE INDENT return - 1 NEW_LINE DEDENT mid = ( low + high ) / 2 NEW_LINE if ( arr [ mid ] != mid + 1 ) : NEW_LINE INDENT if ( mid > 0 and arr [ mid ] == arr [ mid - 1 ] ) : NEW_LINE INDENT return mid NEW_LINE DEDENT return findRepeatingElement ( arr , low , mid - 1 ) NEW_LINE DEDENT return findRepeatingElement ( arr , mid + 1 , high ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE index = findRepeatingElement ( arr , 0 , n - 1 ) NEW_LINE if ( index is not - 1 ) : NEW_LINE INDENT print arr [ index ] NEW_LINE DEDENT
def diff ( n , mid ) : NEW_LINE INDENT if ( n > ( mid * mid * mid ) ) : NEW_LINE INDENT return ( n - ( mid * mid * mid ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mid * mid * mid ) - n ) NEW_LINE DEDENT DEDENT def cubicRoot ( n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE e = 0.0000001 NEW_LINE while ( True ) : NEW_LINE INDENT mid = ( start + end ) / 2 NEW_LINE error = diff ( n , mid ) NEW_LINE if ( error <= e ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( ( mid * mid * mid ) > n ) : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT n = 3 NEW_LINE print ( " Cubic ▁ root ▁ of " , n , " is " , round ( cubicRoot ( n ) , 6 ) ) NEW_LINE
def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT i = 1 ; result = 1 NEW_LINE while ( result <= x ) : NEW_LINE INDENT i += 1 NEW_LINE result = i * i NEW_LINE DEDENT return i - 1 NEW_LINE DEDENT x = 11 NEW_LINE print ( floorSqrt ( x ) ) NEW_LINE
def sumOfInternalAngles ( n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( n - 2 ) * 180 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( sumOfInternalAngles ( n ) ) NEW_LINE
from math import sqrt NEW_LINE def diagonal_length ( a ) : NEW_LINE INDENT L = 0 NEW_LINE L = a * sqrt ( 3 ) NEW_LINE return L NEW_LINE DEDENT a = 5 NEW_LINE print ( diagonal_length ( a ) ) NEW_LINE
PI = 3.14 NEW_LINE from math import pow , sqrt NEW_LINE def find_area ( r , d ) : NEW_LINE INDENT R = d / PI NEW_LINE R += pow ( r , 2 ) NEW_LINE R = sqrt ( R ) NEW_LINE area = PI * pow ( R , 2 ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 4 NEW_LINE d = 5 NEW_LINE print ( find_area ( r , d ) ) NEW_LINE DEDENT
def Valid ( a , b , c , d ) : NEW_LINE INDENT if ( a + b + c + d == 360 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT a = 80 ; b = 70 ; c = 100 ; d = 110 ; NEW_LINE if ( Valid ( a , b , c , d ) ) : NEW_LINE INDENT print ( " Valid ▁ quadrilateral " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid ▁ quadrilateral " ) ; NEW_LINE DEDENT
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT x1 , y1 = - 10 , 8 ; NEW_LINE x2 , y2 = 14 , - 24 ; NEW_LINE r1 , r2 = 30 , 10 ; NEW_LINE t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) ; NEW_LINE if ( t == 1 ) : NEW_LINE INDENT print ( " There ▁ are ▁ 3 ▁ common ▁ tangents ▁ between ▁ the ▁ circles . " ) NEW_LINE DEDENT elif ( t < 0 ) : NEW_LINE INDENT print ( " There ▁ are ▁ 4 ▁ common ▁ tangents ▁ between ▁ the ▁ circles . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " There ▁ are ▁ 2 ▁ common ▁ tangents ▁ between ▁ the ▁ circles . " ) NEW_LINE DEDENT
def GCD ( a , b ) : NEW_LINE INDENT if ( b != 0 ) : NEW_LINE INDENT return GCD ( b , a % b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return a ; NEW_LINE DEDENT DEDENT def ratiotang ( r1 , r2 ) : NEW_LINE INDENT print ( " The ▁ ratio ▁ is " , r1 // GCD ( r1 , r2 ) , " : " , r2 // GCD ( r1 , r2 ) ) ; NEW_LINE DEDENT r1 = 4 ; r2 = 8 ; NEW_LINE ratiotang ( r1 , r2 ) ; NEW_LINE
def Regions ( Vertices , Edges ) : NEW_LINE INDENT R = Edges + 2 - Vertices ; NEW_LINE return R ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT V = 5 ; E = 7 ; NEW_LINE print ( Regions ( V , E ) ) ; NEW_LINE DEDENT
from math import gcd NEW_LINE def ratiotang ( r1 , r2 ) : NEW_LINE INDENT print ( " The ▁ ratio ▁ is " , int ( r1 / gcd ( r1 , r2 ) ) , " : " , int ( r2 / gcd ( r1 , r2 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r1 = 4 NEW_LINE r2 = 6 NEW_LINE ratiotang ( r1 , r2 ) NEW_LINE DEDENT
from math import sqrt , pow NEW_LINE def lengthOfTangent ( r1 , r2 , d ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ transverse " , " common ▁ tangent ▁ is " , ' { 0 : . 6g } ' . format ( sqrt ( pow ( d , 2 ) - pow ( ( r1 + r2 ) , 2 ) ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r1 = 4 NEW_LINE r2 = 6 NEW_LINE d = 12 NEW_LINE lengthOfTangent ( r1 , r2 , d ) NEW_LINE DEDENT
def remainingArea ( N , M , K ) : NEW_LINE INDENT while ( K > 0 and N > 0 and M > 0 ) : NEW_LINE INDENT if ( N > M ) : NEW_LINE INDENT N = N - M ; NEW_LINE DEDENT else : NEW_LINE INDENT M = M - N ; NEW_LINE DEDENT K = K - 1 ; NEW_LINE DEDENT if ( N > 0 and M > 0 ) : NEW_LINE INDENT return N * M ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT N = 5 ; NEW_LINE M = 3 ; NEW_LINE K = 2 ; NEW_LINE print ( remainingArea ( N , M , K ) ) ; NEW_LINE
def lengtang ( r1 , r2 ) : NEW_LINE INDENT print ( " The ▁ length ▁ of ▁ the ▁ direct " , " common ▁ tangent ▁ is " , 2 * ( r1 * r2 ) ** ( 1 / 2 ) ) ; NEW_LINE DEDENT r1 = 5 ; r2 = 9 ; NEW_LINE lengtang ( r1 , r2 ) ; NEW_LINE
def dist ( x1 , y1 , x2 , y2 , r ) : NEW_LINE INDENT print ( " The ▁ shortest ▁ distance ▁ between ▁ a ▁ point ▁ and ▁ a ▁ circle ▁ is ▁ " , ( ( ( ( x2 - x1 ) ** 2 ) + ( ( y2 - y1 ) ** 2 ) ) ** ( 1 / 2 ) ) - r ) ; NEW_LINE DEDENT x1 = 4 ; NEW_LINE y1 = 6 ; NEW_LINE x2 = 35 ; NEW_LINE y2 = 42 ; NEW_LINE r = 5 ; NEW_LINE dist ( x1 , y1 , x2 , y2 , r ) ; NEW_LINE
def dist ( m , b1 , b2 ) : NEW_LINE INDENT d = abs ( b2 - b1 ) / ( ( m * m ) - 1 ) ; NEW_LINE return d ; NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT m , b1 , b2 = 2 , 4 , 3 ; NEW_LINE print ( dist ( m , b1 , b2 ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math ; NEW_LINE def normal ( m , n ) : NEW_LINE INDENT N = ( ( abs ( m ) * abs ( n ) ) / math . sqrt ( ( abs ( m ) * abs ( m ) ) + ( abs ( n ) * abs ( n ) ) ) ) ; NEW_LINE return N ; NEW_LINE DEDENT m = - 5 ; n = 3 ; NEW_LINE print ( normal ( m , n ) ) ; NEW_LINE
def isPossible ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE maxS = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE maxS = max ( a [ i ] , maxS ) NEW_LINE DEDENT if ( ( sum - maxS ) > maxS ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = [ 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE if ( isPossible ( a , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findAreaShaded ( a ) : NEW_LINE INDENT sqArea = a * a ; NEW_LINE semiCircleArea = ( 3.14 * ( a * a ) / 8 ) NEW_LINE ShadedArea = 4 * semiCircleArea - sqArea ; NEW_LINE return ShadedArea ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE print ( findAreaShaded ( a ) ) NEW_LINE DEDENT
def countSteps ( x , y ) : NEW_LINE INDENT if x < y : NEW_LINE INDENT return x + y + 2 * ( ( y - x ) // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return x + y + 2 * ( ( ( x - y ) + 1 ) // 2 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y = 4 , 3 NEW_LINE print ( countSteps ( x , y ) ) NEW_LINE DEDENT
def isSlopeGood ( slope , arr , n ) : NEW_LINE INDENT setOfLines = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT setOfLines [ arr [ i ] - slope * ( i ) ] = 1 NEW_LINE DEDENT return len ( setOfLines ) == 2 NEW_LINE DEDENT def checkForParallel ( arr , n ) : NEW_LINE INDENT slope1 = isSlopeGood ( arr [ 1 ] - arr [ 0 ] , arr , n ) NEW_LINE slope2 = isSlopeGood ( arr [ 2 ] - arr [ 1 ] , arr , n ) NEW_LINE slope3 = isSlopeGood ( ( arr [ 2 ] - arr [ 0 ] ) // 2 , arr , n ) NEW_LINE return ( slope1 or slope2 or slope3 ) NEW_LINE DEDENT arr = [ 1 , 6 , 3 , 8 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if checkForParallel ( arr , n ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
def pointIsOnLine ( m , c , x , y ) : NEW_LINE INDENT if ( y == ( ( m * x ) + c ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT m = 3 ; c = 2 ; NEW_LINE x = 1 ; y = 5 ; NEW_LINE if ( pointIsOnLine ( m , c , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
import math ; NEW_LINE def Area ( a , b ) : NEW_LINE INDENT if ( a < 0 and b < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT h = math . sqrt ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) ; NEW_LINE A = 0.70477 * pow ( h , 2 ) ; NEW_LINE return A ; NEW_LINE DEDENT a = 5 ; NEW_LINE b = 4 ; NEW_LINE print ( round ( Area ( a , b ) , 7 ) ) ; NEW_LINE
def maxRectangles ( L , B , l , b ) : NEW_LINE INDENT horizontal , vertical = 0 , 0 NEW_LINE if l <= L and b <= B : NEW_LINE INDENT columns = B // b NEW_LINE rows = L // l NEW_LINE horizontal = rows * columns NEW_LINE DEDENT if l <= B and b <= L : NEW_LINE INDENT columns = L // b NEW_LINE rows = B // l NEW_LINE vertical = rows * columns NEW_LINE DEDENT return max ( horizontal , vertical ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L , B , l , b = 10 , 7 , 4 , 3 NEW_LINE print ( maxRectangles ( L , B , l , b ) ) NEW_LINE DEDENT
import math NEW_LINE def cone ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = ( a * math . sqrt ( 2 ) ) / 3 ; NEW_LINE h = ( 2 * a ) / 3 ; NEW_LINE V = 3.14 * math . pow ( r , 2 ) * h ; NEW_LINE return V ; NEW_LINE DEDENT a = 5 ; NEW_LINE print ( cone ( a ) ) ; NEW_LINE
import math NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = 1.268 * a NEW_LINE A = 0.70477 * math . pow ( h , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) , end =   " " ) NEW_LINE
import math as mt NEW_LINE def Area ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 2 * r ) / mt . sqrt ( 5 ) NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT r = 5 NEW_LINE print ( Area ( r ) ) NEW_LINE
import math as mt NEW_LINE def Area ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.464 * a NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT a = 5 NEW_LINE print ( Area ( a ) ) NEW_LINE
def areaSquare ( side , fold ) : NEW_LINE INDENT area = side * side NEW_LINE ans = area / pow ( 2 , fold ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT side = 4 NEW_LINE fold = 2 NEW_LINE print ( areaSquare ( side , fold ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def ReuleauxArea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = 0.70477 * 2 * pow ( r , 2 ) NEW_LINE return A NEW_LINE DEDENT r = 6 NEW_LINE print ( ReuleauxArea ( r ) ) NEW_LINE
import math as mt NEW_LINE def cyl ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = ( 2 * a * mt . sqrt ( 2 ) ) / 3 NEW_LINE h = ( 2 * a ) / 3 NEW_LINE V = 3.14 * pow ( r , 2 ) * h NEW_LINE return V NEW_LINE DEDENT a = 5 NEW_LINE print ( cyl ( a ) ) NEW_LINE
import math as mt NEW_LINE def Area ( l , b , h ) : NEW_LINE INDENT if ( l < 0 or b < 0 or h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( l * b ) / ( l + b ) NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT l , b , h = 5 , 12 , 13 NEW_LINE print ( Area ( l , b , h ) ) NEW_LINE
def squareSide ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = 0.423 * a NEW_LINE return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 8 NEW_LINE print ( squareSide ( a ) ) NEW_LINE DEDENT
from math import ceil , floor NEW_LINE def isPossible ( x , y , z ) : NEW_LINE INDENT a = x * x + y * y + z * z NEW_LINE a = round ( a , 8 ) NEW_LINE if ( ceil ( a ) == 1 & floor ( a ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 0.70710678 NEW_LINE m = 0.5 NEW_LINE n = 0.5 NEW_LINE if ( isPossible ( l , m , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import math as mt NEW_LINE def polydiagonal ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( 2 * a * mt . sin ( ( ( ( n - 2 ) * 180 ) / ( 2 * n ) ) * 3.14159 / 180 ) ) NEW_LINE DEDENT a , n = 9 , 10 NEW_LINE print ( polydiagonal ( n , a ) ) NEW_LINE
def decdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.902 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 9 NEW_LINE print ( decdiagonal ( a ) ) NEW_LINE DEDENT
def heptdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.802 * a NEW_LINE return round ( d , 3 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 6 NEW_LINE print ( heptdiagonal ( a ) ) NEW_LINE DEDENT
def hexDiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT d = 1.73 * a ; NEW_LINE return d ; NEW_LINE DEDENT a = 9 ; NEW_LINE print ( hexDiagonal ( a ) ) ; NEW_LINE
import math as mt NEW_LINE def ReuleauxArea ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 0.70477 * pow ( a , 2 ) NEW_LINE DEDENT a = 6 NEW_LINE print ( ReuleauxArea ( a ) ) NEW_LINE
def squareArea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT area = ( 1.268 ** 2 ) * ( a ** 2 ) ; NEW_LINE return area ; NEW_LINE DEDENT a = 6 ; NEW_LINE print ( squareArea ( a ) ) ; NEW_LINE
from math import sqrt , pow NEW_LINE def CubeVolume ( d ) : NEW_LINE INDENT Volume = ( sqrt ( 3 ) * pow ( d , 3 ) ) / 9 NEW_LINE return Volume NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d = 5 NEW_LINE print ( " Volume ▁ of ▁ Cube : " , ' { 0 : . 6 } ' . format ( CubeVolume ( d ) ) ) NEW_LINE DEDENT
def per ( a , b ) : NEW_LINE INDENT return ( a + b ) NEW_LINE DEDENT def area ( s ) : NEW_LINE INDENT return ( s / 2 ) NEW_LINE DEDENT a = 7 NEW_LINE b = 8 NEW_LINE s = 10 NEW_LINE print ( per ( a , b ) ) NEW_LINE print ( area ( s ) ) NEW_LINE
PI = 3.14159265 NEW_LINE def area_leaf ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 2 - 1 ) ) NEW_LINE DEDENT a = 7 NEW_LINE print ( area_leaf ( a ) ) NEW_LINE
PI = 3.14159265 NEW_LINE def length_rope ( r ) : NEW_LINE INDENT return ( ( 2 * PI * r ) + 6 * r ) NEW_LINE DEDENT r = 7 NEW_LINE print ( length_rope ( r ) ) NEW_LINE
PI = 3.14159265 NEW_LINE def area_inscribed ( P , B , H ) : NEW_LINE INDENT return ( ( P + B - H ) * ( P + B - H ) * ( PI / 4 ) ) NEW_LINE DEDENT P = 3 NEW_LINE B = 4 NEW_LINE H = 5 NEW_LINE print ( area_inscribed ( P , B , H ) ) NEW_LINE
PI = 3.14159265 NEW_LINE def area_cicumscribed ( c ) : NEW_LINE INDENT return ( c * c * ( PI / 4 ) ) NEW_LINE DEDENT c = 8.0 NEW_LINE print ( area_cicumscribed ( c ) ) NEW_LINE
import math NEW_LINE def cyl ( r , h ) : NEW_LINE INDENT if ( r < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = ( 2 * r ) / 3 NEW_LINE H = ( 2 * h ) / 3 NEW_LINE V = 3.14 * math . pow ( R , 2 ) * H NEW_LINE return V NEW_LINE DEDENT r = 4 ; h = 8 ; NEW_LINE print ( cyl ( r , h ) ,   " " ) NEW_LINE
import math NEW_LINE def cube ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = math . pow ( h , 3 ) NEW_LINE return a NEW_LINE DEDENT h = 5 ; r = 4 ; NEW_LINE print ( cube ( h , r ) ) ; NEW_LINE
def sph ( r , h ) : NEW_LINE INDENT if ( r < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = r NEW_LINE return float ( R ) NEW_LINE DEDENT r , h = 4 , 8 NEW_LINE print ( sph ( r , h ) ) NEW_LINE
import math NEW_LINE def cyl ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT V = ( ( 2 * 3.14 * math . pow ( R , 3 ) ) / ( 3 * math . sqrt ( 3 ) ) ) ; NEW_LINE return float ( V ) NEW_LINE DEDENT R = 4 NEW_LINE print ( cyl ( R ) ) NEW_LINE
import math NEW_LINE def rod ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT l = ( math . sqrt ( math . pow ( h , 2 ) + 4 * math . pow ( r , 2 ) ) ) NEW_LINE return float ( l ) NEW_LINE DEDENT h , r = 4 , 1.5 NEW_LINE print ( rod ( h , r ) ) NEW_LINE
import math NEW_LINE PI = 3.14159265 NEW_LINE def area_inscribed ( a ) : NEW_LINE INDENT return ( a * a * ( PI / 12 ) ) NEW_LINE DEDENT def perm_inscribed ( a ) : NEW_LINE INDENT return ( PI * ( a / math . sqrt ( 3 ) ) ) NEW_LINE DEDENT a = 6.0 NEW_LINE print ( " Area ▁ of ▁ inscribed ▁ circle ▁ is ▁ : % ▁ f " % area_inscribed ( a ) ) NEW_LINE print ( " Perimeter of inscribed circle is : % f " % perm_inscribed ( a ) ) NEW_LINE
import math NEW_LINE def cubeSide ( h , r ) : NEW_LINE INDENT if ( h < 0 and r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( ( h * r * math . sqrt ( 2 ) ) / ( h + math . sqrt ( 2 ) * r ) ) NEW_LINE return a NEW_LINE DEDENT h = 5 ; r = 6 ; NEW_LINE print ( cubeSide ( h , r ) ,   " " ) NEW_LINE
import math NEW_LINE def coner ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT r = ( 2 * math . sqrt ( 2 ) * R ) / 3 NEW_LINE return float ( r ) NEW_LINE DEDENT def coneh ( R ) : NEW_LINE INDENT if ( R < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT h = ( 4 * R ) / 3 NEW_LINE return float ( h ) NEW_LINE DEDENT R = 10 NEW_LINE print ( " r ▁ = ▁ " , coner ( R ) , " , ▁ " , " h ▁ = ▁ " , coneh ( R ) ) NEW_LINE
import math NEW_LINE def coneRadius ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / math . sqrt ( 2 ) NEW_LINE return r NEW_LINE DEDENT def coneHeight ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT h = a NEW_LINE return h NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 6 NEW_LINE print ( " r ▁ = ▁ " , coneRadius ( a ) , " h ▁ = ▁ " , coneHeight ( a ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def largestCube ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( 2 * r ) / sqrt ( 3 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 5 NEW_LINE print ( " { 0 : . 6 } " . format ( largestCube ( r ) ) ) NEW_LINE DEDENT
def sphere ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / 2 NEW_LINE return r NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE print ( sphere ( a ) ) NEW_LINE DEDENT
def numberOfCuts ( M , N ) : NEW_LINE INDENT result = 0 NEW_LINE result = ( M - 1 ) * ( N - 1 ) NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M , N = 4 , 4 NEW_LINE Cuts = numberOfCuts ( M , N ) NEW_LINE print ( " Maximum ▁ cuts ▁ = ▁ " , Cuts ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def maxVol ( P , A ) : NEW_LINE INDENT l = ( P - sqrt ( P * P - 24 * A ) ) / 12 NEW_LINE V = l * ( A / 2.0 - l * ( P / 4.0 - l ) ) NEW_LINE return V NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = 20 NEW_LINE A = 16 NEW_LINE print ( maxVol ( P , A ) ) NEW_LINE DEDENT
from math import sqrt , pow NEW_LINE def rhombusAreaPeri ( d1 , d2 ) : NEW_LINE INDENT area = ( d1 * d2 ) / 2 NEW_LINE perimeter = 2 * sqrt ( pow ( d1 , 2 ) + pow ( d2 , 2 ) ) NEW_LINE print ( " The ▁ area ▁ of ▁ rhombus ▁ with ▁ diagonals " , d1 , " and " , d2 , " is " , area , " . " ) NEW_LINE print ( " The ▁ perimeter ▁ of ▁ rhombus ▁ with ▁ diagonals " , d1 , " and " , d2 , " is " , perimeter , " . " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT d1 = 2 NEW_LINE d2 = 4 NEW_LINE rhombusAreaPeri ( d1 , d2 ) NEW_LINE DEDENT
from math import sqrt , pow NEW_LINE def area ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( 5 * pow ( r , 2 ) * ( 3 - sqrt ( 5 ) ) * ( sqrt ( 5 ) + ( 2 * sqrt ( 5 ) ) ) ) / 4 NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 8 NEW_LINE print ( area ( r ) ) NEW_LINE DEDENT
from math import ceil , floor NEW_LINE def maxArea ( perimeter ) : NEW_LINE INDENT length = int ( ceil ( perimeter / 4 ) ) NEW_LINE breadth = int ( floor ( perimeter / 4 ) ) NEW_LINE return length * breadth NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 38 NEW_LINE print ( " Maximum ▁ Area ▁ = " , maxArea ( n ) ) NEW_LINE DEDENT
def foot ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / ( a * a + b * b + c * c ) ; NEW_LINE x2 = a * k + x1 ; NEW_LINE y2 = b * k + y1 ; NEW_LINE z2 = c * k + z1 ; NEW_LINE print ( " x2 ▁ = " , round ( x2 , 1 ) ) NEW_LINE print ( " y2 ▁ = " , round ( y2 , 1 ) ) NEW_LINE print ( " z2 ▁ = " , round ( z2 , 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 4 NEW_LINE foot ( a , b , c , d , x1 , y1 , z1 ) NEW_LINE DEDENT
import math NEW_LINE def countRectangles ( l , w ) : NEW_LINE INDENT squareSide = math . gcd ( l , w ) NEW_LINE return ( l * w ) / ( squareSide * squareSide ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 4 NEW_LINE w = 6 NEW_LINE ans = countRectangles ( l , w ) NEW_LINE print ( int ( ans ) ) NEW_LINE DEDENT
def circle_equation ( x1 , y1 , r ) : NEW_LINE INDENT a = - 2 * x1 ; NEW_LINE b = - 2 * y1 ; NEW_LINE c = ( r * r ) - ( x1 * x1 ) - ( y1 * y1 ) ; NEW_LINE print ( " x ^ 2 ▁ + ▁ ( " , a , " x ) ▁ + ▁ " , end = " " ) ; NEW_LINE print ( " y ^ 2 ▁ + ▁ ( " , b , " y ) ▁ = ▁ " , end = " " ) ; NEW_LINE print ( c , " . " ) ; NEW_LINE DEDENT x1 = 2 ; NEW_LINE y1 = - 3 ; NEW_LINE r = 8 ; NEW_LINE circle_equation ( x1 , y1 , r ) ; NEW_LINE
def area ( r ) : NEW_LINE INDENT return ( 0.5 ) * ( 3.14 ) * ( r * r ) NEW_LINE DEDENT def perimeter ( r ) : NEW_LINE INDENT return ( 3.14 ) * ( r ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT r = 10 NEW_LINE print ( " The ▁ Area ▁ of ▁ Semicircle : ▁ " , area ( r ) ) NEW_LINE print ( " The ▁ Perimeter ▁ of ▁ Semicircle : ▁ " , perimeter ( r ) ) NEW_LINE DEDENT
def checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT resx = x1 + x2 + x3 NEW_LINE resy = y1 + y2 + y3 NEW_LINE resz = z1 + z2 + z3 NEW_LINE if ( resx == 0 and resy == 0 and resz == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT x1 = - 2 ; y1 = - 7 ; z1 = - 9 NEW_LINE x2 = 5 ; y2 = - 14 ; z2 = 14 NEW_LINE x3 = - 3 ; y3 = 21 ; z3 = - 5 NEW_LINE if ( checkEquilibrium ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ) : NEW_LINE INDENT print ( " The ▁ vectors ▁ are ▁ at ▁ equilibrium . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ vectors ▁ are ▁ not ▁ at ▁ equilibrium . " ) NEW_LINE DEDENT
def findTangent ( A , x , y ) : NEW_LINE INDENT dif = A - x * 2 NEW_LINE if y == ( 2 * x - x * x ) : NEW_LINE INDENT if dif < 0 : NEW_LINE INDENT print ( " y ▁ = " , dif , " x " , ( x * dif ) + ( y ) ) NEW_LINE DEDENT elif dif > 0 : NEW_LINE INDENT print ( " y ▁ = " , dif , " x + " , - x * dif + y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A , x , y = 2 , 2 , 0 NEW_LINE findTangent ( A , x , y ) NEW_LINE DEDENT
def hexadiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE print ( hexadiagonal ( a ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def octaside ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT s = a / ( sqrt ( 2 ) + 1 ) NEW_LINE return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE print ( " { 0 : . 6 } " . format ( octaside ( a ) ) ) NEW_LINE DEDENT
def Arrive ( a , b , n ) : NEW_LINE INDENT if ( n >= abs ( a ) + abs ( b ) and ( n - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 5 NEW_LINE b = 5 NEW_LINE n = 11 NEW_LINE if ( Arrive ( a , b , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def Move ( a , x , b ) : NEW_LINE INDENT if ( ( ( ( b - a ) % x == 0 ) or ( ( b - a - 1 ) % x == 0 ) and a + 1 != b ) and b >= a ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE x = 2 NEW_LINE b = 7 NEW_LINE if ( Move ( a , x , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def area ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = a * b NEW_LINE return A NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 2 NEW_LINE print ( area ( a , b ) ) NEW_LINE DEDENT
import math NEW_LINE def findRadiusOfcircumcircle ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT radius = ( math . sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ) ; NEW_LINE return radius ; NEW_LINE DEDENT l = 4 ; NEW_LINE b = 3 ; NEW_LINE print ( findRadiusOfcircumcircle ( l , b ) ) ; NEW_LINE
import math NEW_LINE def circlearea ( a , b , c ) : NEW_LINE INDENT if ( a < 0 or b < 0 or c < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT p = ( a + b + c ) / 2 ; NEW_LINE At = math . sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) ; NEW_LINE A = 3.14 * pow ( ( ( a * b * c ) / ( 4 * At ) ) , 2 ) ; NEW_LINE return A ; NEW_LINE DEDENT a = 4 ; NEW_LINE b = 5 ; NEW_LINE c = 3 ; NEW_LINE print ( float ( circlearea ( a , b , c ) ) ) ; NEW_LINE
import math NEW_LINE def altitude ( a , b ) : NEW_LINE INDENT return math . sqrt ( pow ( a , 2 ) - ( pow ( b , 2 ) / 4 ) ) NEW_LINE DEDENT def area ( b , h ) : NEW_LINE INDENT return ( 1 * b * h ) / 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 3 NEW_LINE h = altitude ( a , b ) NEW_LINE print ( " Altitude ▁ = ▁ " + str ( round ( h , 3 ) ) , end = " , ▁ " ) NEW_LINE print ( " Area ▁ = ▁ " + str ( round ( area ( b , h ) , 3 ) ) ) NEW_LINE DEDENT
def surfaceArea ( b , s ) : NEW_LINE INDENT return 2 * b * s + pow ( b , 2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT b = 3 NEW_LINE s = 4 NEW_LINE print ( surfaceArea ( b , s ) ) NEW_LINE DEDENT
def trianglearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( l * b ) / 2 NEW_LINE return area NEW_LINE DEDENT l = 5 NEW_LINE b = 4 NEW_LINE print ( trianglearea ( l , b ) ) NEW_LINE
def halfsquare ( n , x , y ) : NEW_LINE INDENT half = n // 2 NEW_LINE if ( ( half == x or half == x - 1 ) and ( half == y or half == y - 1 ) ) : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 100 NEW_LINE x , y = 51 , 100 NEW_LINE halfsquare ( n , x , y ) NEW_LINE DEDENT
def check ( a , b , p , q ) : NEW_LINE INDENT d = p * p + q * q ; NEW_LINE if ( d == 0 ) : NEW_LINE INDENT return a == 0 and b == 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( a * p + b * q ) % d == 0 and ( b * p - a * q ) % d == 0 ) ; NEW_LINE DEDENT DEDENT def checks ( a , b , x , y , p , q ) : NEW_LINE INDENT if ( check ( a - x , b - y , p , q ) or check ( a + x , b + y , p , q ) or check ( a - y , b + x , p , q ) or check ( a + y , b - x , p , q ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT a = - 4 ; NEW_LINE b = - 2 ; NEW_LINE x = 0 ; NEW_LINE y = 0 ; NEW_LINE p = - 2 ; NEW_LINE q = - 1 ; NEW_LINE if ( checks ( a , b , x , y , p , q ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
from math import * NEW_LINE def trianglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = ( 3 * sqrt ( 3 ) * pow ( a , 2 ) ) / ( 4 * b ) NEW_LINE return area NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 4 , 2 NEW_LINE print ( round ( trianglearea ( a , b ) , 4 ) ) NEW_LINE DEDENT
def squarearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 4 * ( ( ( pow ( a , 2 ) + pow ( b , 2 ) ) / ( pow ( a , 2 ) * pow ( b , 2 ) ) ) ) NEW_LINE return area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 2 NEW_LINE print ( squarearea ( a , b ) ) NEW_LINE DEDENT
def trianglearea ( r ) : NEW_LINE INDENT if r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return r * r NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 NEW_LINE print ( trianglearea ( r ) ) NEW_LINE DEDENT
def squarearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = 4 * ( pow ( r , 2 ) / 5 ) NEW_LINE return a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 NEW_LINE print ( int ( squarearea ( r ) ) ) NEW_LINE DEDENT
def rectanglearea ( a , b ) : NEW_LINE INDENT if a < 0 or b < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 * a * b NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 10 , 8 NEW_LINE print ( rectanglearea ( a , b ) ) NEW_LINE DEDENT
def squareArea ( l , b , h ) : NEW_LINE INDENT if l < 0 or b < 0 or h < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT a = ( l * b ) / ( l + b ) NEW_LINE return a * a NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , b , h = 5 , 12 , 13 NEW_LINE print ( round ( squareArea ( l , b , h ) , 4 ) ) NEW_LINE DEDENT
MAX = 50 NEW_LINE def solveQuery ( n , q , qi , qj ) : NEW_LINE INDENT arr = [ None ] * MAX NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT arr [ i ] = 0 NEW_LINE DEDENT for k in range ( q ) : NEW_LINE INDENT flag = 0 NEW_LINE if ( qj [ k ] < qi [ k ] ) : NEW_LINE INDENT qj [ k ] , qi [ k ] = qi [ k ] , qj [ k ] NEW_LINE DEDENT if ( arr [ qi [ k ] ] != 0 or arr [ qj [ k ] ] != 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT elif ( qi [ k ] == qj [ k ] ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , qi [ k ] ) : NEW_LINE INDENT if ( arr [ i ] != 0 and arr [ i ] < qj [ k ] and qi [ k ] < arr [ i ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT for i in range ( qi [ k ] + 1 , qj [ k ] ) : NEW_LINE INDENT if ( arr [ i ] != 0 and arr [ i ] > qj [ k ] ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE arr [ qi [ k ] ] = qj [ k ] NEW_LINE arr [ qj [ k ] ] = qi [ k ] NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE q = 7 NEW_LINE qi = [ 1 , 2 , 2 , 2 , 9 , 10 , 8 ] NEW_LINE qj = [ 5 , 7 , 3 , 4 , 9 , 9 , 6 ] NEW_LINE solveQuery ( n , q , qi , qj ) NEW_LINE DEDENT
import math NEW_LINE def squares ( l , b , a ) : NEW_LINE INDENT return math . ceil ( l / a ) * math . ceil ( b / a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 11 NEW_LINE b = 23 NEW_LINE a = 14 NEW_LINE print ( squares ( l , b , a ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def squarearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT n = ( l * b ) / gcd ( l , b ) NEW_LINE return n * n NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 6 NEW_LINE b = 4 NEW_LINE print ( int ( squarearea ( l , b ) ) ) NEW_LINE DEDENT
import math NEW_LINE def angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) : NEW_LINE INDENT num = ( x2 - x1 ) * ( x3 - x1 ) + ( y2 - y1 ) * ( y3 - y1 ) + ( z2 - z1 ) * ( z3 - z1 ) NEW_LINE den = math . sqrt ( ( x2 - x1 ) ** 2 + ( y2 - y1 ) ** 2 + ( z2 - z1 ) ** 2 ) * math . sqrt ( ( x3 - x1 ) ** 2 + ( y3 - y1 ) ** 2 + ( z3 - z1 ) ** 2 ) NEW_LINE angle = math . degrees ( math . acos ( num / den ) ) NEW_LINE return round ( angle , 3 ) NEW_LINE DEDENT x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 2 NEW_LINE x2 = 2 NEW_LINE y2 = 3 NEW_LINE z2 = 5 NEW_LINE x3 = 3 NEW_LINE y3 = 5 NEW_LINE z3 = - 2 NEW_LINE angle_A = angle_triangle ( x1 , x2 , x3 , y1 , y2 , y3 , z1 , z2 , z3 ) NEW_LINE angle_B = angle_triangle ( x2 , x3 , x1 , y2 , y3 , y1 , z2 , z3 , z1 ) NEW_LINE angle_C = angle_triangle ( x3 , x2 , x1 , y3 , y2 , y1 , z3 , z2 , z1 ) NEW_LINE print ( " Angles ▁ are ▁ : " ) NEW_LINE print ( " angle ▁ A ▁ = ▁ " , angle_A , " degree " ) NEW_LINE print ( " angle ▁ B ▁ = ▁ " , angle_B , " degree " ) NEW_LINE print ( " angle ▁ C ▁ = ▁ " , angle_C , " degree " ) NEW_LINE
def solve ( M , N , s ) : NEW_LINE INDENT if ( N % s == 0 ) : NEW_LINE INDENT N = N // s NEW_LINE DEDENT else : NEW_LINE INDENT N = ( N // s ) + 1 NEW_LINE DEDENT if ( M % s == 0 ) : NEW_LINE INDENT M = M // s NEW_LINE DEDENT else : NEW_LINE INDENT M = ( M // s ) + 1 NEW_LINE DEDENT return M * N NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , M , s = 12 , 13 , 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT
import math NEW_LINE def solve ( M , N , s ) : NEW_LINE INDENT ans = ( ( math . ceil ( M / s ) ) * ( math . ceil ( N / s ) ) ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 12 NEW_LINE M = 13 NEW_LINE s = 4 NEW_LINE print ( solve ( M , N , s ) ) NEW_LINE DEDENT
def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE a = b1 * c2 - b2 * c1 NEW_LINE b = a2 * c1 - a1 * c2 NEW_LINE c = a1 * b2 - b1 * a2 NEW_LINE d = ( - a * x1 - b * y1 - c * z1 ) NEW_LINE print " equation ▁ of ▁ plane ▁ is ▁ " , NEW_LINE print a , " x ▁ + " , NEW_LINE print b , " y ▁ + " , NEW_LINE print c , " z ▁ + " , NEW_LINE print d , " = ▁ 0 . " NEW_LINE DEDENT x1 = - 1 NEW_LINE y1 = 2 NEW_LINE z1 = 1 NEW_LINE x2 = 0 NEW_LINE y2 = - 3 NEW_LINE z2 = 2 NEW_LINE x3 = 1 NEW_LINE y3 = 1 NEW_LINE z3 = - 4 NEW_LINE equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) NEW_LINE
import math NEW_LINE def shortest_distance ( x1 , y1 , a , b , c ) : NEW_LINE INDENT d = abs ( ( a * x1 + b * y1 + c ) ) / ( math . sqrt ( a * a + b * b ) ) NEW_LINE print ( " Perpendicular ▁ distance ▁ is " ) , d NEW_LINE DEDENT x1 = 5 NEW_LINE y1 = 6 NEW_LINE a = - 2 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE shortest_distance ( x1 , y1 , a , b , c ) NEW_LINE
def octant ( x , y , z ) : NEW_LINE INDENT if x >= 0 and y >= 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 1st ▁ octant " NEW_LINE DEDENT elif x < 0 and y >= 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 2nd ▁ octant " NEW_LINE DEDENT elif x < 0 and y < 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 3rd ▁ octant " NEW_LINE DEDENT elif x >= 0 and y < 0 and z >= 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 4th ▁ octant " NEW_LINE DEDENT elif x >= 0 and y >= 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 5th ▁ octant " NEW_LINE DEDENT elif x < 0 and y >= 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 6th ▁ octant " NEW_LINE DEDENT elif x < 0 and y < 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 7th ▁ octant " NEW_LINE DEDENT elif x >= 0 and y < 0 and z < 0 : NEW_LINE INDENT print " Point ▁ lies ▁ in ▁ 8th ▁ octant " NEW_LINE DEDENT DEDENT x , y , z = 2 , 3 , 4 NEW_LINE octant ( x , y , z ) NEW_LINE x , y , z = - 4 , 2 , - 8 NEW_LINE octant ( x , y , z ) NEW_LINE x , y , z = - 6 , - 2 , 8 NEW_LINE octant ( x , y , z ) NEW_LINE
def countNumberOfTriangles ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) * ( n - 2 ) // 6 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( countNumberOfTriangles ( n ) ) NEW_LINE DEDENT
def centeredTridecagonalNum ( n ) : NEW_LINE INDENT return ( 13 * n * ( n - 1 ) + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( centeredTridecagonalNum ( n ) ) NEW_LINE n = 10 NEW_LINE print ( centeredTridecagonalNum ( n ) ) NEW_LINE DEDENT
def pentagon_pyramidal ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p = ( 3 * i * i - i ) / 2 NEW_LINE sum = sum + p NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE
def pentagon_pyramidal ( n ) : NEW_LINE INDENT return n * n * ( n + 1 ) / 2 NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( pentagon_pyramidal ( n ) ) ) NEW_LINE
def checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) : NEW_LINE INDENT return ( a3 * ( b1 * c2 - b2 * c1 ) + b3 * ( c1 * a2 - c2 * a1 ) + c3 * ( a1 * b2 - a2 * b1 ) == 0 ) NEW_LINE DEDENT a1 = 2 NEW_LINE b1 = - 3 NEW_LINE c1 = 5 NEW_LINE a2 = 3 NEW_LINE b2 = 4 NEW_LINE c2 = - 7 NEW_LINE a3 = 9 NEW_LINE b3 = - 5 NEW_LINE c3 = 8 NEW_LINE if ( checkConcurrent ( a1 , b1 , c1 , a2 , b2 , c2 , a3 , b3 , c3 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def center_octadecagon_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 9 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , " rd ▁ centered ▁ octadecagonal ▁ " + " number ▁ : ▁ " , center_octadecagon_num ( n ) ) NEW_LINE n = 13 NEW_LINE print ( n , " th ▁ centered ▁ octadecagonal ▁ " + " number ▁ : ▁ " , center_octadecagon_num ( n ) ) NEW_LINE DEDENT
def centereddecagonalnum ( n ) : NEW_LINE INDENT return ( 5 * n * n + 5 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( n , " th ▁ centered ▁ decagonal ▁ " + " number ▁ : ▁ " , centereddecagonalnum ( n ) ) NEW_LINE n = 9 NEW_LINE print ( n , " th ▁ centered ▁ decagonal ▁ " + " number ▁ : ▁ " , centereddecagonalnum ( n ) ) NEW_LINE DEDENT
def factorial ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , a + b + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT return res NEW_LINE DEDENT def Ksmallest ( x , y , k ) : NEW_LINE INDENT if x == 0 and y == 0 : NEW_LINE INDENT return NEW_LINE DEDENT elif x == 0 : NEW_LINE INDENT y -= 1 NEW_LINE print ( " V " , end = " " ) NEW_LINE Ksmallest ( x , y , k ) NEW_LINE DEDENT elif y == 0 : NEW_LINE INDENT x -= 1 NEW_LINE print ( " H " , end = " " ) NEW_LINE Ksmallest ( x , y , k ) NEW_LINE DEDENT else : NEW_LINE INDENT if factorial ( x - 1 , y ) > k : NEW_LINE INDENT print ( " H " , end = " " ) NEW_LINE Ksmallest ( x - 1 , y , k ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " V " , end = " " ) NEW_LINE Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y , k = 2 , 2 , 2 NEW_LINE Ksmallest ( x , y , k ) NEW_LINE DEDENT
def centered_pentagonal_Num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) // 2 NEW_LINE DEDENT n = 7 NEW_LINE print ( " % sth ▁ Centered ▁ pentagonal ▁ number ▁ : ▁ " % n , centered_pentagonal_Num ( n ) ) NEW_LINE
import math NEW_LINE def pivotDis ( x0 , y0 , x1 , y1 ) : NEW_LINE INDENT return math . sqrt ( ( x1 - x0 ) * ( x1 - x0 ) + ( y1 - y0 ) * ( y1 - y0 ) ) NEW_LINE DEDENT def minDis ( D , r1 , r2 ) : NEW_LINE INDENT return max ( ( D - r1 - r2 ) , 0 ) NEW_LINE DEDENT def maxDis ( D , r1 , r2 ) : NEW_LINE INDENT return D + r1 + r2 NEW_LINE DEDENT x0 = 0 NEW_LINE y0 = 0 NEW_LINE x1 = 8 NEW_LINE y1 = 0 NEW_LINE r1 = 4 NEW_LINE r2 = 5 NEW_LINE D = pivotDis ( x0 , y0 , x1 , y1 ) NEW_LINE print ( " Distance ▁ while ▁ repulsion ▁ = ▁ " , int ( maxDis ( D , r1 , r2 ) ) ) NEW_LINE print ( " Distance ▁ while ▁ attraction ▁ = ▁ " , minDis ( D , r1 , r2 ) ) NEW_LINE
def maximumValueOfF ( R ) : NEW_LINE INDENT return 4 * R * R + 0.25 NEW_LINE DEDENT R = 3 NEW_LINE print ( maximumValueOfF ( R ) ) NEW_LINE
def otherEndPoint ( x1 , y1 , m1 , m2 ) : NEW_LINE INDENT x2 = ( 2 * m1 - x1 ) NEW_LINE y2 = ( 2 * m2 - y1 ) NEW_LINE print ( " x2 ▁ = ▁ { } , ▁ y2 ▁ = ▁ { } " . format ( x2 , y2 ) ) NEW_LINE DEDENT x1 = - 4 NEW_LINE y1 = - 1 NEW_LINE m1 = 3 NEW_LINE m2 = 5 NEW_LINE otherEndPoint ( x1 , y1 , m1 , m2 ) NEW_LINE
def printRect ( X , Y , n ) : NEW_LINE INDENT Xmax = max ( X ) NEW_LINE Xmin = min ( X ) NEW_LINE Ymax = max ( Y ) NEW_LINE Ymin = min ( Y ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymin , " } " , sep = " " ) NEW_LINE print ( " { " , Xmin , " , ▁ " , Ymax , " } " , sep = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymax , " } " , sep = " " ) NEW_LINE print ( " { " , Xmax , " , ▁ " , Ymin , " } " , sep = " " ) NEW_LINE DEDENT X = [ 4 , 3 , 6 , 1 , - 1 , 12 ] NEW_LINE Y = [ 4 , 1 , 10 , 3 , 7 , - 1 ] NEW_LINE n = len ( X ) NEW_LINE printRect ( X , Y , n ) NEW_LINE
def checkOrigin ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return ( x1 * ( y2 - y1 ) == y1 * ( x2 - x1 ) ) NEW_LINE DEDENT if ( checkOrigin ( 1 , 28 , 2 , 56 ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def isBetween ( a , b , c ) : NEW_LINE INDENT return min ( a , b ) <= c and c <= max ( a , b ) NEW_LINE DEDENT def canJoin ( x , y , i , j , k ) : NEW_LINE INDENT return ( x [ k ] == x [ i ] or x [ k ] == x [ j ] ) and isBetween ( y [ i ] , y [ j ] , y [ k ] ) or ( y [ k ] == y [ i ] or y [ k ] == y [ j ] ) and isBetween ( x [ i ] , x [ j ] , x [ k ] ) NEW_LINE DEDENT def countLineSegments ( x , y ) : NEW_LINE INDENT if ( ( x [ 0 ] == x [ 1 ] and x [ 1 ] == x [ 2 ] ) or ( y [ 0 ] == y [ 1 ] and y [ 1 ] == y [ 2 ] ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( canJoin ( x , y , 0 , 1 , 2 ) or canJoin ( x , y , 0 , 2 , 1 ) or canJoin ( x , y , 1 , 2 , 0 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT else : NEW_LINE INDENT return 3 NEW_LINE DEDENT DEDENT x = [ - 1 , - 1 , 4 ] NEW_LINE y = [ - 1 , 3 , 3 ] NEW_LINE print ( countLineSegments ( x , y ) ) NEW_LINE
import math NEW_LINE def pythagorean_quadruple ( a , b , c , d ) : NEW_LINE INDENT sum = a * a + b * b + c * c ; NEW_LINE if ( d * d == sum ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 2 NEW_LINE d = 3 NEW_LINE if ( pythagorean_quadruple ( a , b , c , d ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE pi = math . pi NEW_LINE def volume ( r , R , h ) : NEW_LINE INDENT return 1 / 3 * pi * h * ( r * r + R * R + r * R ) NEW_LINE DEDENT def curved_surface_area ( r , R , l ) : NEW_LINE INDENT return pi * l * ( R + r ) NEW_LINE DEDENT def total_surface_area ( r , R , l , h ) : NEW_LINE INDENT return pi * l * ( R + r ) + pi * ( r * r + R * R ) NEW_LINE DEDENT small_radius = 3 NEW_LINE big_radius = 8 NEW_LINE slant_height = 13 NEW_LINE height = 12 NEW_LINE print ( " Volume ▁ Of ▁ Frustum ▁ of ▁ Cone ▁ : ▁ " , end = ' ' ) NEW_LINE print ( volume ( small_radius , big_radius , height ) ) NEW_LINE print ( " Curved ▁ Surface ▁ Area ▁ Of ▁ Frustum " + " ▁ of ▁ Cone ▁ : ▁ " , end = ' ' ) NEW_LINE print ( curved_surface_area ( small_radius , big_radius , slant_height ) ) NEW_LINE print ( " Total ▁ Surface ▁ Area ▁ Of ▁ Frustum " + " ▁ of ▁ Cone ▁ : ▁ " , end = ' ' ) NEW_LINE print ( total_surface_area ( small_radius , big_radius , slant_height , height ) ) NEW_LINE
def Circumference ( a ) : NEW_LINE INDENT return ( 4 * a ) NEW_LINE DEDENT a = 5 NEW_LINE c = Circumference ( a ) NEW_LINE print ( " Circumference ▁ of ▁ a ▁ " + " square ▁ is ▁ % ▁ d " % ( c ) ) NEW_LINE
import math NEW_LINE def maxArea ( a , b , c , d ) : NEW_LINE INDENT semiperimeter = ( a + b + c + d ) / 2 NEW_LINE return math . sqrt ( ( semiperimeter - a ) * ( semiperimeter - b ) * ( semiperimeter - c ) * ( semiperimeter - d ) ) NEW_LINE DEDENT a = 1 NEW_LINE b = 2 NEW_LINE c = 1 NEW_LINE d = 2 NEW_LINE print ( " % .2f " % maxArea ( a , b , c , d ) ) NEW_LINE
def minRadius ( k , x , y , n ) : NEW_LINE INDENT dis = [ 0 ] * n NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dis [ i ] = x [ i ] * x [ i ] + y [ i ] * y [ i ] NEW_LINE DEDENT dis . sort ( ) NEW_LINE return dis [ k - 1 ] NEW_LINE DEDENT k = 3 NEW_LINE x = [ 1 , - 1 , 1 ] NEW_LINE y = [ 1 , - 1 , - 1 ] NEW_LINE n = len ( x ) NEW_LINE print ( minRadius ( k , x , y , n ) ) NEW_LINE
def areaRectangle ( a , b ) : NEW_LINE INDENT return ( a * b ) NEW_LINE DEDENT def perimeterRectangle ( a , b ) : NEW_LINE INDENT return ( 2 * ( a + b ) ) NEW_LINE DEDENT a = 5 ; NEW_LINE b = 6 ; NEW_LINE print ( " Area ▁ = ▁ " , areaRectangle ( a , b ) ) NEW_LINE print ( " Perimeter ▁ = ▁ " , perimeterRectangle ( a , b ) ) NEW_LINE
def areaSquare ( side ) : NEW_LINE INDENT area = side * side NEW_LINE return area NEW_LINE DEDENT side = 4 NEW_LINE print ( areaSquare ( side ) ) NEW_LINE
import math NEW_LINE def minPerimeter ( n ) : NEW_LINE INDENT l = math . sqrt ( n ) NEW_LINE sq = l * l NEW_LINE if ( sq == n ) : NEW_LINE INDENT return l * 4 NEW_LINE DEDENT else : NEW_LINE INDENT row = n / l NEW_LINE perimeter = 2 * ( l + row ) NEW_LINE if ( n % l != 0 ) : NEW_LINE INDENT perimeter += 2 NEW_LINE DEDENT return perimeter NEW_LINE DEDENT DEDENT n = 10 NEW_LINE print ( int ( minPerimeter ( n ) ) ) NEW_LINE
def possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) : NEW_LINE INDENT dis1 = ( pow ( b1 - a1 , 2 ) + pow ( b2 - a2 , 2 ) ) NEW_LINE dis2 = ( pow ( c1 - b1 , 2 ) + pow ( c2 - b2 , 2 ) ) NEW_LINE if ( dis1 != dis2 ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT elif ( b1 == ( ( a1 + c1 ) // 2.0 ) and b2 == ( ( a2 + c2 ) // 2.0 ) ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT DEDENT a1 , b1 , c1 = 1 , 2 , 3 NEW_LINE a2 = b2 = c2 = 0 NEW_LINE possibleOrNot ( a1 , a2 , b1 , b2 , c1 , c2 ) NEW_LINE
def circle ( x1 , y1 , x2 , y2 , r1 , r2 ) : NEW_LINE INDENT distSq = ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ; NEW_LINE radSumSq = ( r1 + r2 ) * ( r1 + r2 ) ; NEW_LINE if ( distSq == radSumSq ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( distSq > radSumSq ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT x1 = - 10 NEW_LINE y1 = 8 NEW_LINE x2 = 14 NEW_LINE y2 = - 24 NEW_LINE r1 = 30 NEW_LINE r2 = 10 NEW_LINE t = circle ( x1 , y1 , x2 , y2 , r1 , r2 ) NEW_LINE if ( t == 1 ) : NEW_LINE INDENT print ( " Circle ▁ touch ▁ to ▁ each ▁ other . " ) NEW_LINE DEDENT elif ( t < 0 ) : NEW_LINE INDENT print ( " Circle ▁ not ▁ touch ▁ to ▁ each ▁ other . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Circle ▁ intersect ▁ to ▁ each ▁ other . " ) NEW_LINE DEDENT
def countObtuseAngles ( a , b , k ) : NEW_LINE INDENT c1 = ( b - a ) - 1 NEW_LINE c2 = ( k - b ) + ( a - 1 ) NEW_LINE if ( c1 == c2 ) : NEW_LINE return 0 NEW_LINE return min ( c1 , c2 ) NEW_LINE DEDENT k , a , b = 6 , 1 , 3 NEW_LINE print countObtuseAngles ( a , b , k ) NEW_LINE
def findTriangle ( a , n ) : NEW_LINE INDENT b = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT b . append ( a [ i ] * a [ i ] ) NEW_LINE DEDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE x , y , z = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT p = i + 1 NEW_LINE q = i + 1 NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT while ( p < n - 1 and b [ i ] + b [ j ] >= b [ p + 1 ] ) : NEW_LINE INDENT p += 1 NEW_LINE DEDENT q = max ( q , p ) NEW_LINE while ( q < n - 1 and a [ i ] + a [ j ] > a [ q + 1 ] ) : NEW_LINE INDENT q += 1 NEW_LINE DEDENT if ( b [ i ] + b [ j ] == b [ p ] ) : NEW_LINE INDENT x += max ( p - j - 1 , 0 ) NEW_LINE y += 1 NEW_LINE z += q - p NEW_LINE DEDENT else : NEW_LINE INDENT x += max ( p - j , 0 ) NEW_LINE z += q - p NEW_LINE DEDENT DEDENT DEDENT print ( " Acute ▁ Triangle : " , x ) NEW_LINE print ( " Right ▁ Triangle : " , y ) NEW_LINE print ( " Obtuse ▁ Triangle : " , z ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 9 , 10 , 12 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE findTriangle ( arr , n ) NEW_LINE DEDENT
def polygonArea ( X , Y , n ) : NEW_LINE INDENT area = 0.0 NEW_LINE j = n - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT area += ( X [ j ] + X [ i ] ) * ( Y [ j ] - Y [ i ] ) NEW_LINE DEDENT return int ( abs ( area / 2.0 ) ) NEW_LINE DEDENT X = [ 0 , 2 , 4 ] NEW_LINE Y = [ 1 , 3 , 7 ] NEW_LINE n = len ( X ) NEW_LINE print ( polygonArea ( X , Y , n ) ) NEW_LINE
def last_digit ( X , Y ) : NEW_LINE INDENT print ( X % Y ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 55 ; Y = 3 ; NEW_LINE last_digit ( X , Y ) ; NEW_LINE DEDENT
def printRoots ( a , b , c ) : NEW_LINE INDENT print ( 1 , " , " , c / ( a * 1.0 ) ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE c = - 5 NEW_LINE printRoots ( a , b , c ) NEW_LINE
MAX = 130 NEW_LINE def validQuadruple ( arr , n ) : NEW_LINE INDENT if ( n >= MAX ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT for l in range ( k + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ^ arr [ k ] ^ arr [ l ] ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 1 , 0 , 2 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( validQuadruple ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def solve ( n , k ) : NEW_LINE INDENT if ( n >= ( k * ( k + 1 ) ) // 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 4 NEW_LINE if ( solve ( n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def closetAND ( arr , n , k ) : NEW_LINE INDENT ans = 10 ** 9 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = arr [ i ] NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT X &= arr [ j ] NEW_LINE ans = min ( ans , abs ( k - X ) ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 4 , 7 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE k = 2 ; NEW_LINE print ( closetAND ( arr , n , k ) ) NEW_LINE
def Rate ( N1 , N2 ) : NEW_LINE INDENT rate = ( N2 - N1 ) * 100 // ( N1 ) ; NEW_LINE return rate NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N1 = 100 NEW_LINE N2 = 120 NEW_LINE print ( Rate ( N1 , N2 ) , " ▁ % " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def getPrime ( arr , n ) : NEW_LINE INDENT max_val = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( max_val ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT maximum = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT maximum = max ( maximum , arr [ i ] ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 10 , 15 , 7 , 6 , 8 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getPrime ( arr , n ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def getMinNum ( N ) : NEW_LINE INDENT lcm = 1 ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT lcm = ( ( i * lcm ) // ( gcd ( i , lcm ) ) ) ; NEW_LINE DEDENT return ( lcm + 1 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 ; NEW_LINE print ( getMinNum ( N ) ) ; NEW_LINE DEDENT
def maxEdges ( N ) : NEW_LINE INDENT edges = 0 ; NEW_LINE edges = ( N * N ) // 4 ; NEW_LINE return edges ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 ; NEW_LINE print ( maxEdges ( N ) ) ; NEW_LINE DEDENT
def Permutation ( n , k ) : NEW_LINE INDENT p = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT p [ i ] = i NEW_LINE DEDENT for i in range ( 1 , n - k ) : NEW_LINE INDENT p [ i + 1 ] = i NEW_LINE DEDENT p [ 1 ] = n - k NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( p [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE Permutation ( n , k ) NEW_LINE DEDENT
def validPosition ( arr , N , K ) : NEW_LINE INDENT count = 0 ; sum = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( ( arr [ i ] + K ) > ( sum - arr [ i ] ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT arr = [ 2 , 1 , 6 , 7 ] ; NEW_LINE K = 4 ; NEW_LINE N = len ( arr ) ; NEW_LINE print ( validPosition ( arr , N , K ) ) ; NEW_LINE
def maxBitElement ( arr , n ) : NEW_LINE INDENT num = 0 NEW_LINE max = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = bin ( arr [ i ] ) . count ( '1' ) NEW_LINE if ( cnt > max ) : NEW_LINE INDENT max = cnt NEW_LINE num = arr [ i ] NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 4 , 7 , 1 , 10 , 5 , 8 , 9 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxBitElement ( arr , n ) ) NEW_LINE DEDENT
def smallestSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 2 * pow ( 10 , n - 1 ) ) NEW_LINE DEDENT def largestSum ( n ) : NEW_LINE INDENT return ( 2 * ( pow ( 10 , n ) - 1 ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Largest ▁ = ▁ " , largestSum ( n ) ) NEW_LINE print ( " Smallest ▁ = ▁ " , smallestSum ( n ) ) NEW_LINE
def count_pairs ( a , b , n , m ) : NEW_LINE INDENT odd1 = 0 NEW_LINE even1 = 0 NEW_LINE odd2 = 0 NEW_LINE even2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 ) : NEW_LINE INDENT odd1 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even1 += 1 NEW_LINE DEDENT DEDENT for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] % 2 ) : NEW_LINE INDENT odd2 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even2 += 1 NEW_LINE DEDENT DEDENT pairs = ( min ( odd1 , even2 ) + min ( odd2 , even1 ) ) NEW_LINE return pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 9 , 14 , 6 , 2 , 11 ] NEW_LINE b = [ 8 , 4 , 7 , 20 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE print ( count_pairs ( a , b , n , m ) ) NEW_LINE DEDENT
def find_leftmost_unsetbit ( n ) : NEW_LINE INDENT ind = - 1 ; NEW_LINE i = 1 ; NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n % 2 ) != 1 ) : NEW_LINE INDENT ind = i ; NEW_LINE DEDENT i += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return ind ; NEW_LINE DEDENT def perform_steps ( n ) : NEW_LINE INDENT left = find_leftmost_unsetbit ( n ) ; NEW_LINE if ( left == - 1 ) : NEW_LINE INDENT print ( " No ▁ steps ▁ required " ) ; NEW_LINE return ; NEW_LINE DEDENT step = 1 ; NEW_LINE while ( find_leftmost_unsetbit ( n ) != - 1 ) : NEW_LINE INDENT if ( step % 2 == 0 ) : NEW_LINE INDENT n += 1 ; NEW_LINE print ( " Step " , step ,   " : Increase by 1 " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT m = find_leftmost_unsetbit ( n ) ; NEW_LINE num = ( 2 ** m ) - 1 ; NEW_LINE n = n ^ num ; NEW_LINE print ( " Step " , step , " : ▁ Xor ▁ with " , num ) ; NEW_LINE DEDENT step += 1 ; NEW_LINE DEDENT DEDENT n = 39 ; NEW_LINE perform_steps ( n ) ; NEW_LINE
def vertices ( N , A , B ) : NEW_LINE INDENT position = 0 NEW_LINE miniSum = 10 ** 9 NEW_LINE Sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i == A or i == B ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT x = abs ( i - A ) NEW_LINE y = abs ( i - B ) NEW_LINE Sum = x + y NEW_LINE if ( Sum < miniSum ) : NEW_LINE INDENT miniSum = Sum NEW_LINE position = i NEW_LINE DEDENT DEDENT DEDENT return position NEW_LINE DEDENT N = 3 NEW_LINE A = 1 NEW_LINE B = 2 NEW_LINE print ( " Vertex ▁ = ▁ " , vertices ( N , A , B ) ) NEW_LINE
def factorial ( n ) : NEW_LINE INDENT f = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT f *= i ; NEW_LINE DEDENT return f ; NEW_LINE DEDENT def sumFactorial ( arr , n ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s += factorial ( arr [ i ] ) ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT arr = [ 7 , 3 , 5 , 4 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( sumFactorial ( arr , n ) ) ; NEW_LINE
def highestPower ( str , length ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT str = "100100" ; NEW_LINE length = len ( str ) ; NEW_LINE print ( highestPower ( str , length ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
mod = 10 ** 9 + 7 NEW_LINE def factorial ( n , p ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = ( res * i ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( n , p ) : NEW_LINE INDENT return power ( n , p - 2 , p ) NEW_LINE DEDENT def nCrModP ( n , r , p ) : NEW_LINE INDENT if ( r == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT fac = [ 0 for i in range ( n + 1 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i % p NEW_LINE DEDENT return ( fac [ n ] * modInverse ( fac [ r ] , p ) % p * modInverse ( fac [ n - r ] , p ) % p ) % p NEW_LINE DEDENT def countArrangements ( n , k , p ) : NEW_LINE INDENT return ( factorial ( n , p ) * nCrModP ( k , n , p ) ) % p NEW_LINE DEDENT N = 5 NEW_LINE K = 8 NEW_LINE print ( countArrangements ( N , K , mod ) ) NEW_LINE
def maxProd ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( maxProd ( N // 10 ) * ( N % 10 ) , maxProd ( N // 10 - 1 ) * 9 ) NEW_LINE DEDENT N = 390 NEW_LINE print ( maxProd ( N ) ) NEW_LINE
N = 2 NEW_LINE M = 3 NEW_LINE def check ( mat ) : NEW_LINE INDENT xorr = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT xorr ^= mat [ i ] [ 0 ] NEW_LINE DEDENT if ( xorr != 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] != mat [ i ] [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT mat = [ [ 7 , 7 , 7 ] , [ 10 , 10 , 7 ] ] NEW_LINE if ( check ( mat ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def sumodd ( n ) : NEW_LINE INDENT return ( n * n ) NEW_LINE DEDENT def sumeven ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) NEW_LINE DEDENT def findSum ( num ) : NEW_LINE INDENT sumo = 0 NEW_LINE sume = 0 NEW_LINE x = 1 NEW_LINE cur = 0 NEW_LINE ans = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT inc = min ( x , num ) NEW_LINE num -= inc NEW_LINE if ( cur == 0 ) : NEW_LINE INDENT ans = ans + sumodd ( sumo + inc ) - sumodd ( sumo ) NEW_LINE sumo += inc NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + sumeven ( sume + inc ) - sumeven ( sume ) NEW_LINE sume += inc NEW_LINE DEDENT x *= 2 NEW_LINE cur ^= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 4 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def oddTriangularNumber ( N ) : NEW_LINE INDENT return ( N * ( ( 2 * N ) - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE print ( oddTriangularNumber ( N ) ) NEW_LINE DEDENT
def idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT if ( ( a1 // a2 == b1 // b2 ) and ( a1 // a2 == c1 // c2 ) and ( b1 // b2 == c1 // c2 ) ) : NEW_LINE INDENT print ( " The ▁ given ▁ straight ▁ lines " , " are ▁ identical " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ given ▁ straight ▁ lines " , " are ▁ not ▁ identical " ) ; NEW_LINE DEDENT DEDENT a1 , b1 = - 2 , 4 NEW_LINE c1 , a2 = 3 , - 6 NEW_LINE b2 , c2 = 12 , 9 NEW_LINE idstrt ( a1 , b1 , c1 , a2 , b2 , c2 ) NEW_LINE
def line ( x0 , y0 ) : NEW_LINE INDENT c = 2 * y0 * x0 NEW_LINE print ( y0 , " x " , " + " , x0 , " y = " , c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x0 = 4 NEW_LINE y0 = 3 NEW_LINE line ( x0 , y0 ) NEW_LINE DEDENT
N = 3 NEW_LINE M = 7 NEW_LINE def printOriginalMatrix ( a , b , mat ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT print ( min ( a [ i ] , b [ j ] ) , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 1 , 3 ] NEW_LINE b = [ 2 , 3 , 0 , 0 , 2 , 0 , 1 ] NEW_LINE mat = [ [ 1 , 0 , 0 , 0 , 1 , 0 , 0 ] , [ 0 , 0 , 0 , 0 , 0 , 0 , 1 ] , [ 1 , 1 , 0 , 0 , 0 , 0 , 0 ] ] ; NEW_LINE printOriginalMatrix ( a , b , mat ) ; NEW_LINE DEDENT
def percent ( n , x ) : NEW_LINE INDENT p = ( int ) ( n ) * x ; NEW_LINE p /= 100 ; NEW_LINE return p ; NEW_LINE DEDENT def getLoss ( price , quantity , X , n ) : NEW_LINE INDENT loss = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT originalPrice = price [ i ] ; NEW_LINE sellingPrice = originalPrice + percent ( originalPrice , X [ i ] ) ; NEW_LINE afterDiscount = sellingPrice - percent ( sellingPrice , X [ i ] ) ; NEW_LINE loss += ( ( originalPrice - afterDiscount ) * quantity [ i ] ) ; NEW_LINE DEDENT return round ( loss , 2 ) ; NEW_LINE DEDENT price = [ 20 , 48 , 200 , 100 ] ; NEW_LINE quantity = [ 20 , 48 , 1 , 1 ] ; NEW_LINE X = [ 0 , 48 , 200 , 5 ] ; NEW_LINE n = len ( X ) ; NEW_LINE print ( getLoss ( price , quantity , X , n ) ) ; NEW_LINE
def maxAbsDiff ( arr , n ) : NEW_LINE INDENT minEle = arr [ 0 ] NEW_LINE maxEle = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT minEle = min ( minEle , arr [ i ] ) NEW_LINE maxEle = max ( maxEle , arr [ i ] ) NEW_LINE DEDENT return ( maxEle - minEle ) NEW_LINE DEDENT arr = [ 2 , 1 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxAbsDiff ( arr , n ) ) NEW_LINE
import sys ; NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT DEDENT return max_so_far ; NEW_LINE DEDENT def maximizeSum ( a , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE mini = sys . maxsize ; NEW_LINE minSubarray = sys . maxsize ; NEW_LINE sum = maxSubArraySum ( a , n ) ; NEW_LINE max_so_far = - ( sys . maxsize - 1 ) ; NEW_LINE max_ending_here = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE cnt += 1 ; NEW_LINE minSubarray = min ( a [ i ] , minSubarray ) ; NEW_LINE if ( sum == max_ending_here ) : NEW_LINE INDENT if ( cnt == 1 ) : NEW_LINE INDENT mini = min ( mini , 0 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT mini = min ( mini , minSubarray ) ; NEW_LINE DEDENT DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE cnt = 0 ; NEW_LINE minSubarray = sys . maxsize ; NEW_LINE DEDENT DEDENT return sum - mini ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 , - 2 , 3 ] ; NEW_LINE n = len ( a ) NEW_LINE print ( maximizeSum ( a , n ) ) ; NEW_LINE DEDENT
def isOsiris ( n ) : NEW_LINE INDENT a = n % 10 NEW_LINE b = ( n // 10 ) % 10 NEW_LINE c = n // 100 NEW_LINE digit_sum = a + b + c NEW_LINE if ( n == ( 2 * ( digit_sum ) * 11 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 132 NEW_LINE if isOsiris ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isDudeney ( n ) : NEW_LINE INDENT cube_rt = int ( round ( ( pow ( n , 1.0 / 3.0 ) ) ) ) NEW_LINE if cube_rt * cube_rt * cube_rt != n : NEW_LINE INDENT return False NEW_LINE DEDENT dig_sum = 0 NEW_LINE temp = n NEW_LINE while temp > 0 : NEW_LINE INDENT rem = temp % 10 NEW_LINE dig_sum += rem NEW_LINE temp //= 10 NEW_LINE DEDENT if cube_rt != dig_sum : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 17576 NEW_LINE if isDudeney ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countTriangles ( a , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE pairs = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT pairs += a [ i ] // 2 NEW_LINE if ( a [ i ] % 2 == 1 and pairs > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE pairs -= 1 NEW_LINE DEDENT DEDENT cnt += ( 2 * pairs ) // 3 NEW_LINE return cnt NEW_LINE DEDENT a = [ 1 , 2 , 2 , 2 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( countTriangles ( a , n ) ) NEW_LINE
def smallestMultiple ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 5 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( smallestMultiple ( n ) ) NEW_LINE
def getHCF ( x , y ) : NEW_LINE INDENT minimum = min ( x , y ) NEW_LINE if ( x % minimum == 0 and y % minimum == 0 ) : NEW_LINE INDENT return minimum NEW_LINE DEDENT for i in range ( minimum // 2 , 1 , - 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT x , y = 16 , 32 NEW_LINE print ( getHCF ( x , y ) ) NEW_LINE
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isDivisible ( n ) : NEW_LINE INDENT if ( isPrime ( n + 1 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE if ( isDivisible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE R = 5 NEW_LINE C = 5 NEW_LINE def findMaxCock ( ar ) : NEW_LINE INDENT if ( R < 3 or C < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT max_sum = - sys . maxsize - 1 NEW_LINE for i in range ( R - 2 ) : NEW_LINE INDENT for j in range ( C - 2 ) : NEW_LINE INDENT sum = ( ( ar [ i ] [ j ] + ar [ i ] [ j + 2 ] ) + ( ar [ i + 1 ] [ j + 1 ] ) + ( ar [ i + 2 ] [ j ] + ar [ i + 2 ] [ j + 1 ] + ar [ i + 2 ] [ j + 2 ] ) ) NEW_LINE max_sum = max ( max_sum , sum ) NEW_LINE DEDENT DEDENT return max_sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ar = [ [ 0 , 3 , 0 , 6 , 0 ] , [ 0 , 1 , 1 , 0 , 0 ] , [ 1 , 1 , 1 , 0 , 0 ] , [ 0 , 0 , 2 , 0 , 1 ] , [ 0 , 2 , 0 , 1 , 3 ] ] NEW_LINE print ( findMaxCock ( ar ) ) NEW_LINE DEDENT
def segments ( n , p , m ) : NEW_LINE INDENT c = dict ( ) NEW_LINE c [ 0 ] = 1 NEW_LINE has = False NEW_LINE Sum = 0 NEW_LINE ans = 0 NEW_LINE for r in range ( n ) : NEW_LINE INDENT if ( p [ r ] < m ) : NEW_LINE INDENT Sum -= 1 NEW_LINE DEDENT elif ( p [ r ] > m ) : NEW_LINE INDENT Sum += 1 NEW_LINE DEDENT if ( p [ r ] == m ) : NEW_LINE INDENT has = True NEW_LINE DEDENT if ( has ) : NEW_LINE INDENT if ( Sum in c . keys ( ) ) : NEW_LINE INDENT ans += c [ Sum ] NEW_LINE DEDENT if Sum - 1 in c . keys ( ) : NEW_LINE INDENT ans += c [ Sum - 1 ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT c [ Sum ] = c . get ( Sum , 0 ) + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT a = [ 2 , 4 , 5 , 3 , 1 ] NEW_LINE n = len ( a ) NEW_LINE m = 4 NEW_LINE print ( segments ( n , a , m ) ) NEW_LINE
def oddDays ( N ) : NEW_LINE INDENT hund1 = N // 100 NEW_LINE hund4 = N // 400 NEW_LINE leap = N >> 2 NEW_LINE ordd = N - leap NEW_LINE if ( hund1 ) : NEW_LINE INDENT ordd += hund1 NEW_LINE leap -= hund1 NEW_LINE DEDENT if ( hund4 ) : NEW_LINE INDENT ordd -= hund4 NEW_LINE leap += hund4 NEW_LINE DEDENT days = ordd + leap * 2 NEW_LINE odd = days % 7 NEW_LINE return odd NEW_LINE DEDENT N = 100 NEW_LINE print ( oddDays ( N ) ) NEW_LINE
def ellipsearea ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT a = ( 3.14 * r * r ) / 4 ; NEW_LINE return a ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT r = 5 ; NEW_LINE print ( ellipsearea ( r ) ) ; NEW_LINE DEDENT
def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT number = number * 2 + arr [ i ] NEW_LINE if ( ( number % x == 0 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE x = 2 NEW_LINE print ( CntDivbyX ( arr , n , x ) ) NEW_LINE DEDENT
def countCon ( ar , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ar [ i ] == ar [ i + 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT ar = [ 1 , 2 , 2 , 3 , 4 , 4 , 5 , 5 , 5 , 5 ] NEW_LINE n = len ( ar ) NEW_LINE print ( countCon ( ar , n ) ) NEW_LINE
from math import gcd NEW_LINE def reduceFraction ( x , y ) : NEW_LINE INDENT d = gcd ( x , y ) ; NEW_LINE x = x // d ; NEW_LINE y = y // d ; NEW_LINE print ( " x ▁ = " , x , " , ▁ y ▁ = " , y ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 16 ; NEW_LINE y = 10 ; NEW_LINE reduceFraction ( x , y ) ; NEW_LINE DEDENT
def noOfYears ( t1 , n1 , t2 ) : NEW_LINE INDENT years = ( t2 - 1 ) * n1 / ( t1 - 1 ) NEW_LINE return years NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT T1 , N1 , T2 = 3 , 5 , 6 NEW_LINE print ( noOfYears ( T1 , N1 , T2 ) ) NEW_LINE DEDENT
def isPossible ( n ) : NEW_LINE INDENT fac = [ 0 for i in range ( 10 ) ] NEW_LINE fac [ 0 ] = 1 NEW_LINE fac [ 1 ] = 1 NEW_LINE for i in range ( 2 , 10 , 1 ) : NEW_LINE INDENT fac [ i ] = fac [ i - 1 ] * i NEW_LINE DEDENT sum = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT sum += fac [ x % 10 ] NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT if ( sum % n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19 NEW_LINE if ( isPossible ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
from collections import defaultdict NEW_LINE def findSubsequence ( arr , n , k ) : NEW_LINE INDENT M = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT M [ arr [ i ] ] += 1 NEW_LINE DEDENT numCount = [ 0 ] * ( k + 1 ) NEW_LINE for p in M : NEW_LINE INDENT if p <= k : NEW_LINE INDENT i = 1 NEW_LINE while p * i <= k : NEW_LINE INDENT numCount [ p * i ] += M [ p ] NEW_LINE i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT lcm , length = 0 , 0 NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if numCount [ i ] > length : NEW_LINE INDENT length = numCount [ i ] NEW_LINE lcm = i NEW_LINE DEDENT DEDENT if lcm == 0 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " LCM ▁ = ▁ { 0 } , ▁ Length ▁ = ▁ { 1 } " . format ( lcm , length ) ) NEW_LINE print ( " Indexes ▁ = ▁ " , end = " " ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if lcm % arr [ i ] == 0 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 14 NEW_LINE arr = [ 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findSubsequence ( arr , n , k ) NEW_LINE DEDENT
mod = 1000000007 NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findCount ( N ) : NEW_LINE INDENT count = power ( 2 , N , mod ) NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE print ( findCount ( N ) ) NEW_LINE DEDENT
def msb ( x ) : NEW_LINE INDENT ret = 0 NEW_LINE while ( ( x >> ( ret + 1 ) ) != 0 ) : NEW_LINE INDENT ret = ret + 1 NEW_LINE DEDENT return ret NEW_LINE DEDENT def xorRange ( l , r ) : NEW_LINE INDENT max_bit = msb ( r ) NEW_LINE mul = 2 NEW_LINE ans = 0 NEW_LINE for i in range ( 1 , max_bit + 1 ) : NEW_LINE INDENT if ( ( l // mul ) * mul == ( r // mul ) * mul ) : NEW_LINE INDENT if ( ( ( ( l & ( 1 << i ) ) != 0 ) and ( r - l + 1 ) % 2 == 1 ) ) : NEW_LINE INDENT ans = ans + mul NEW_LINE DEDENT mul = mul * 2 NEW_LINE continue NEW_LINE DEDENT odd_c = 0 NEW_LINE if ( ( ( l & ( 1 << i ) ) != 0 ) and l % 2 == 1 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( ( ( r & ( 1 << i ) ) != 0 ) and r % 2 == 0 ) : NEW_LINE INDENT odd_c = ( odd_c ^ 1 ) NEW_LINE DEDENT if ( odd_c ) : NEW_LINE INDENT ans = ans + mul NEW_LINE DEDENT mul = mul * 2 NEW_LINE DEDENT zero_bit_cnt = ( r - l + 1 ) // 2 NEW_LINE if ( ( l % 2 == 1 ) and ( r % 2 == 1 ) ) : NEW_LINE INDENT zero_bit_cnt = zero_bit_cnt + 1 NEW_LINE DEDENT if ( zero_bit_cnt % 2 == 1 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT l = 1 NEW_LINE r = 4 NEW_LINE print ( xorRange ( l , r ) ) NEW_LINE
def computeXOR ( n ) : NEW_LINE INDENT switch = { 0 : n , 1 : 1 , 2 : n + 1 , 3 : 0 , } NEW_LINE return switch . get ( n & 3 , " " ) NEW_LINE DEDENT l = 1 NEW_LINE r = 4 NEW_LINE print ( computeXOR ( r ) ^ computeXOR ( l - 1 ) ) NEW_LINE
def countNumbers ( x , n ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + countNumbers ( x * 10 , n ) + countNumbers ( x * 10 + 1 , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 ; NEW_LINE print ( countNumbers ( 1 , n ) ) ; NEW_LINE DEDENT
from math import sqrt NEW_LINE def checkfact ( N , countprime , prime ) : NEW_LINE INDENT countfact = 0 NEW_LINE if ( prime == 2 or prime == 3 ) : NEW_LINE INDENT countfact += 1 NEW_LINE DEDENT divide = prime NEW_LINE while ( int ( N / divide ) != 0 ) : NEW_LINE INDENT countfact += int ( N / divide ) NEW_LINE divide = divide * divide NEW_LINE DEDENT if ( countfact >= countprime ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def check ( N ) : NEW_LINE INDENT sumsquares = ( N + 1 ) * ( 2 * N + 1 ) NEW_LINE countprime = 0 NEW_LINE for i in range ( 2 , int ( sqrt ( sumsquares ) ) + 1 , 1 ) : NEW_LINE INDENT flag = 0 NEW_LINE while ( sumsquares % i == 0 ) : NEW_LINE INDENT flag = 1 NEW_LINE countprime += 1 NEW_LINE sumsquares /= i NEW_LINE DEDENT if ( flag ) : NEW_LINE INDENT if ( checkfact ( N - 1 , countprime , i ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT countprime = 0 NEW_LINE DEDENT DEDENT if ( sumsquares != 1 ) : NEW_LINE INDENT if ( checkfact ( N - 1 , 1 , sumsquares ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE if ( check ( N ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countNonIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE len = 1 ; NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if ( arr [ i + 1 ] <= arr [ i ] ) : NEW_LINE INDENT len += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) ; NEW_LINE len = 1 ; NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len + 1 ) * len ) / 2 ) ; NEW_LINE DEDENT return int ( cnt ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 2 , 3 , 7 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countNonIncreasing ( arr , n ) ) ; NEW_LINE DEDENT
def printPermutation ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT print ( - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 1 , ( n // 2 ) + 1 ) : NEW_LINE INDENT print ( ( 2 * i ) , ( 2 * i - 1 ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT n = 4 ; NEW_LINE printPermutation ( n ) ; NEW_LINE
MAXN = 10000000 NEW_LINE def minimumSteps ( n , m , a , b ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return MAXN NEW_LINE DEDENT if ( n == m ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return min ( 1 + minimumSteps ( n * a , m , a , b ) , 1 + minimumSteps ( n * b , m , a , b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 NEW_LINE m = 51840 NEW_LINE a = 2 NEW_LINE b = 3 NEW_LINE print ( minimumSteps ( n , m , a , b ) ) NEW_LINE DEDENT
def minOperations ( n , m ) : NEW_LINE INDENT if ( m % n != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = 0 NEW_LINE q = int ( m / n ) NEW_LINE while ( q % 2 == 0 ) : NEW_LINE INDENT q = int ( q / 2 ) NEW_LINE minOperations += 1 NEW_LINE DEDENT while ( q % 3 == 0 ) : NEW_LINE INDENT q = int ( q / 3 ) NEW_LINE minOperations += 1 NEW_LINE DEDENT if ( q == 1 ) : NEW_LINE INDENT return minOperations NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 NEW_LINE m = 51840 NEW_LINE print ( minOperations ( n , m ) ) NEW_LINE DEDENT
def fib ( n ) : NEW_LINE INDENT phi = ( ( 1 + ( 5 ** ( 1 / 2 ) ) ) / 2 ) ; NEW_LINE return round ( ( phi ** n ) / ( 5 ** ( 1 / 2 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += fib ( i ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r = 4 , 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE DEDENT
import math NEW_LINE def sphereSide ( h , r ) : NEW_LINE INDENT if h < 0 and r < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT R = ( ( ( h * r * math . sqrt ( 2 ) ) ) / ( h + math . sqrt ( 2 ) * r ) / 2 ) NEW_LINE return R NEW_LINE DEDENT h = 5 ; r = 6 NEW_LINE print ( sphereSide ( h , r ) ) NEW_LINE
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT return n // 4 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 ; NEW_LINE DEDENT DEDENT n = 20 ; NEW_LINE print ( possibleways ( n ) ) ; NEW_LINE
def countSubarrays ( arr , n , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT product = 1 NEW_LINE for x in range ( i , j + 1 ) : NEW_LINE INDENT product *= arr [ x ] NEW_LINE DEDENT if ( product % K == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 2 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE K = 4 NEW_LINE print ( countSubarrays ( arr , n , K ) ) NEW_LINE DEDENT
def printMaxValPair ( v , n ) : NEW_LINE INDENT v . sort ( ) NEW_LINE N = v [ n - 1 ] NEW_LINE if N % 2 == 1 : NEW_LINE INDENT first_maxima = N // 2 NEW_LINE second_maxima = first_maxima + 1 NEW_LINE ans1 , ans2 = 3 * ( 10 ** 18 ) , 3 * ( 10 ** 18 ) NEW_LINE from_left , from_right = - 1 , - 1 NEW_LINE _from = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if v [ i ] > first_maxima : NEW_LINE INDENT _from = i NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT diff = first_maxima - v [ i ] NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE from_left = v [ i ] NEW_LINE DEDENT DEDENT DEDENT from_right = v [ _from ] NEW_LINE diff1 = first_maxima - from_left NEW_LINE diff2 = from_right - second_maxima NEW_LINE if diff1 < diff2 : NEW_LINE INDENT print ( N , from_left ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , from_right ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT maxima = N // 2 NEW_LINE ans1 = 3 * ( 10 ** 18 ) NEW_LINE R = - 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT diff = abs ( v [ i ] - maxima ) NEW_LINE if diff < ans1 : NEW_LINE INDENT ans1 = diff NEW_LINE R = v [ i ] NEW_LINE DEDENT DEDENT print ( N , R ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT v = [ 1 , 1 , 2 , 3 , 6 , 1 ] NEW_LINE n = len ( v ) NEW_LINE printMaxValPair ( v , n ) NEW_LINE DEDENT
def Permutations ( n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE if k >= 2 : NEW_LINE INDENT ans += ( n ) * ( n - 1 ) // 2 NEW_LINE DEDENT if k >= 3 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * 2 // 6 ) NEW_LINE DEDENT if k >= 4 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 // 24 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE print ( Permutations ( n , k ) ) NEW_LINE DEDENT
def power ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if n & 1 : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT def countIntegers ( l , r ) : NEW_LINE INDENT ans , i = 0 , 1 NEW_LINE v = power ( 2 , i ) NEW_LINE while v <= r : NEW_LINE INDENT while v <= r : NEW_LINE INDENT if v >= l : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT v = v * 3 NEW_LINE DEDENT i += 1 NEW_LINE v = power ( 2 , i ) NEW_LINE DEDENT if l == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r = 12 , 21 NEW_LINE print ( countIntegers ( l , r ) ) NEW_LINE DEDENT
def findPairCount ( N , K ) : NEW_LINE INDENT count = 0 ; NEW_LINE rem = [ 0 ] * K ; NEW_LINE rem [ 0 ] = N // K ; NEW_LINE for i in range ( 1 , K ) : NEW_LINE INDENT rem [ i ] = ( N - i ) // K + 1 ; NEW_LINE DEDENT if ( K % 2 == 0 ) : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 ; NEW_LINE for i in range ( 1 , K // 2 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] ; NEW_LINE DEDENT count += ( rem [ K // 2 ] * ( rem [ K // 2 ] - 1 ) ) // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += ( rem [ 0 ] * ( rem [ 0 ] - 1 ) ) // 2 ; NEW_LINE for i in rage ( 1 , K // 2 + 1 ) : NEW_LINE INDENT count += rem [ i ] * rem [ K - i ] ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 ; K = 4 ; NEW_LINE print ( findPairCount ( N , K ) ) ; NEW_LINE DEDENT
N = 1000005 NEW_LINE prime = [ True for i in range ( N ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE prime [ 0 ] = False NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumTruncatablePrimes ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT num = i NEW_LINE flag = True NEW_LINE while ( num ) : NEW_LINE INDENT if ( prime [ num ] == False ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT num //= 10 NEW_LINE DEDENT num = i NEW_LINE power = 10 NEW_LINE while ( num // power ) : NEW_LINE INDENT if ( prime [ num % power ] == False ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT power *= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 25 NEW_LINE sieve ( ) NEW_LINE print ( sumTruncatablePrimes ( n ) ) NEW_LINE
import math NEW_LINE def nDigitPerfectSquares ( n ) : NEW_LINE INDENT print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , n - 1 ) ) ) , 2 ) , end = " ▁ " ) ; NEW_LINE print ( pow ( math . ceil ( math . sqrt ( pow ( 10 , n ) ) ) - 1 , 2 ) ) ; NEW_LINE DEDENT n = 4 ; NEW_LINE nDigitPerfectSquares ( n ) ; NEW_LINE
N = 3 NEW_LINE def MaxTraceSub ( mat ) : NEW_LINE INDENT max_trace = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT r = i NEW_LINE s = j NEW_LINE trace = 0 NEW_LINE while ( r < N and s < N ) : NEW_LINE INDENT trace += mat [ r ] NEW_LINE r += 1 NEW_LINE s += 1 NEW_LINE max_trace = max ( trace , max_trace ) NEW_LINE DEDENT DEDENT DEDENT return max_trace NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 10 , 2 , 5 ] , [ 6 , 10 , 4 ] , [ 2 , 7 , - 10 ] ] NEW_LINE print ( MaxTraceSub ( mat ) ) NEW_LINE DEDENT
n = 3 NEW_LINE m = 3 NEW_LINE def check ( a , b ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE r = i NEW_LINE col = 0 NEW_LINE while ( r >= 0 and col < m ) : NEW_LINE INDENT v1 . append ( a [ r ] [ col ] ) NEW_LINE v2 . append ( b [ r ] [ col ] ) NEW_LINE r -= 1 NEW_LINE col += 1 NEW_LINE DEDENT v1 . sort ( reverse = False ) NEW_LINE v2 . sort ( reverse = False ) NEW_LINE for i in range ( len ( v1 ) ) : NEW_LINE INDENT if ( v1 [ i ] != v2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT for j in range ( 1 , m ) : NEW_LINE INDENT v1 = [ ] NEW_LINE v2 = [ ] NEW_LINE r = n - 1 NEW_LINE col = j NEW_LINE while ( r >= 0 and col < m ) : NEW_LINE INDENT v1 . append ( a [ r ] [ col ] ) NEW_LINE v2 . append ( b [ r ] [ col ] ) NEW_LINE r -= 1 NEW_LINE col += 1 NEW_LINE DEDENT v1 . sort ( reverse = False ) NEW_LINE v2 . sort ( reverse = False ) NEW_LINE for i in range ( len ( v1 ) ) : NEW_LINE INDENT if ( v1 [ i ] != v2 [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE b = [ [ 1 , 4 , 7 ] , [ 2 , 5 , 6 ] , [ 3 , 8 , 9 ] ] NEW_LINE if ( check ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def lastDigit ( a , b ) : NEW_LINE INDENT lastDig = ( ( int ( a [ len ( a ) - 1 ] ) - int ( '0' ) ) * ( int ( b [ len ( b ) - 1 ] ) - int ( '0' ) ) ) NEW_LINE print ( lastDig % 10 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b = "1234567891233" , "1234567891233156" NEW_LINE lastDigit ( a , b ) NEW_LINE DEDENT
from math import pow NEW_LINE def printPalindrome ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Smallest ▁ Palindrome : ▁ 0" ) NEW_LINE print ( " Largest ▁ Palindrome : ▁ 9" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Smallest ▁ Palindrome : " , int ( pow ( 10 , n - 1 ) ) + 1 ) NEW_LINE print ( " Largest ▁ Palindrome : " , int ( pow ( 10 , n ) ) - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE printPalindrome ( n ) NEW_LINE DEDENT
def printSum ( a , b ) : NEW_LINE INDENT res , temp1 , temp2 = 0 , 0 , 0 NEW_LINE while a > 0 : NEW_LINE INDENT temp1 = temp1 * 10 + ( a % 10 ) NEW_LINE a //= 10 NEW_LINE DEDENT a = temp1 NEW_LINE while b > 0 : NEW_LINE INDENT temp2 = temp2 * 10 + ( b % 10 ) NEW_LINE b //= 10 NEW_LINE DEDENT b = temp2 NEW_LINE while a : NEW_LINE INDENT Sum = a % 10 + b % 10 NEW_LINE if Sum // 10 == 0 : NEW_LINE INDENT res = res * 10 + Sum NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = 0 NEW_LINE while Sum > 0 : NEW_LINE INDENT temp1 = temp1 * 10 + ( Sum % 10 ) NEW_LINE Sum //= 10 NEW_LINE DEDENT Sum = temp1 NEW_LINE while Sum > 0 : NEW_LINE INDENT res = res * 10 + ( Sum % 10 ) NEW_LINE Sum //= 10 NEW_LINE DEDENT DEDENT a //= 10 NEW_LINE b //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 7752 , 8834 NEW_LINE print ( printSum ( a , b ) ) NEW_LINE DEDENT
def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a // b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT a = 100 NEW_LINE b = 10 NEW_LINE print ( countDigits ( a , b ) ) NEW_LINE
import math NEW_LINE def countDigits ( a , b ) : NEW_LINE INDENT return math . floor ( math . log10 ( abs ( a ) ) - math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT a = 100 NEW_LINE b = 10 NEW_LINE print ( countDigits ( a , b ) ) NEW_LINE
def smallestOdd ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return pow ( 10 , n - 1 ) + 1 NEW_LINE DEDENT n = 4 NEW_LINE print ( smallestOdd ( n ) ) NEW_LINE
def findNumbers ( n ) : NEW_LINE INDENT odd = pow ( 10 , n ) - 1 NEW_LINE even = odd - 1 NEW_LINE print ( " Even ▁ = ▁ " , even ) NEW_LINE print ( " Odd ▁ = ▁ " , odd ) NEW_LINE DEDENT n = 4 NEW_LINE findNumbers ( n ) NEW_LINE
def longestSubArray ( arr , n ) : NEW_LINE INDENT isZeroPresent = False NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZeroPresent = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( isZeroPresent ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 0 , 1 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestSubArray ( arr , n ) ) NEW_LINE
def smallestEven ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return pow ( 10 , n - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( smallestEven ( n ) ) NEW_LINE
from math import gcd NEW_LINE def maxProfit ( n , a , b , x , y ) : NEW_LINE INDENT res = x * ( n // a ) ; NEW_LINE res += y * ( n // b ) ; NEW_LINE res -= min ( x , y ) * ( n // ( ( a * b ) // gcd ( a , b ) ) ) ; NEW_LINE return res ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 ; a = 6 ; b = 2 ; x = 8 ; y = 2 ; NEW_LINE print ( maxProfit ( n , a , b , x , y ) ) ; NEW_LINE DEDENT
from math import pow NEW_LINE MOD = 1000000007 NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT ans = pow ( n % MOD , 2 ) NEW_LINE return ( ans % MOD ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( int ( sumOfSeries ( n ) ) ) NEW_LINE DEDENT
def kthOdd ( arr , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT return arr [ i ] ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( kthOdd ( arr , n , k ) ) ; NEW_LINE
def lastFiveDigits ( n ) : NEW_LINE INDENT n = ( ( int ) ( n / 10000 ) * 10000 + ( ( int ) ( n / 100 ) % 10 ) * 1000 + ( n % 10 ) * 100 + ( ( int ) ( n / 10 ) % 10 ) * 10 + ( int ) ( n / 1000 ) % 10 ) NEW_LINE ans = 1 NEW_LINE for i in range ( 5 ) : NEW_LINE INDENT ans *= n NEW_LINE ans %= 100000 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12345 NEW_LINE lastFiveDigits ( n ) NEW_LINE DEDENT
def power ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) % mod NEW_LINE p = ( p * p ) % mod NEW_LINE if n & 1 == 1 : NEW_LINE INDENT p = ( p * a ) % mod NEW_LINE DEDENT return p NEW_LINE DEDENT def computeSum ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE Sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT maxs = ( power ( 2 , i ) - 1 + mod ) % mod NEW_LINE maxs = ( maxs * arr [ i ] ) % mod NEW_LINE mins = ( power ( 2 , n - 1 - i ) - 1 + mod ) % mod NEW_LINE mins = ( mins * arr [ i ] ) % mod NEW_LINE V = ( maxs - mins + mod ) % mod NEW_LINE Sum = ( Sum + V ) % mod NEW_LINE DEDENT return Sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mod = 1000000007 NEW_LINE arr = [ 4 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( computeSum ( arr , n ) ) NEW_LINE DEDENT
def countNumbers ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 9 * pow ( 10 , n // 2 - 1 ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT
def count ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE p = 1 NEW_LINE while ( p <= n ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE p *= 2 NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 7 NEW_LINE print ( count ( n ) ) ; NEW_LINE
def KthMinValAfterMconcatenate ( A , N , M , K ) : NEW_LINE INDENT V = [ ] NEW_LINE for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT V . append ( A [ j ] ) NEW_LINE DEDENT DEDENT V . sort ( ) NEW_LINE return V [ K - 1 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 3 , 1 , 2 ] NEW_LINE M , K = 3 , 4 NEW_LINE N = len ( A ) NEW_LINE print ( KthMinValAfterMconcatenate ( A , N , M , K ) ) NEW_LINE DEDENT
def sumN ( n ) : NEW_LINE INDENT n = ( n + 1 ) // 2 ; NEW_LINE return ( n * n ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( sumN ( n ) ) ; NEW_LINE
def countNumbers ( n ) : NEW_LINE INDENT return ( n - n // 2 - n // 3 - n // 5 - n // 7 + n // 6 + n // 10 + n // 14 + n // 15 + n // 21 + n // 35 - n // 30 - n // 42 - n // 70 - n // 105 + n // 210 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 20 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT
def maxPrmimes ( n ) : NEW_LINE INDENT return n // 2 NEW_LINE DEDENT n = 17 NEW_LINE print ( maxPrmimes ( n ) ) NEW_LINE
def Sum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( n + 2 ) // 3 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 ; NEW_LINE print ( Sum ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def findMinimum ( n , m ) : NEW_LINE INDENT mini , i = m , 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sec = n // i NEW_LINE if math . gcd ( m , i ) > 1 : NEW_LINE INDENT return i NEW_LINE DEDENT elif math . gcd ( sec , m ) > 1 : NEW_LINE INDENT mini = min ( sec , mini ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if mini == m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return mini NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m = 8 , 10 NEW_LINE print ( findMinimum ( n , m ) ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT nth += pow ( i , i ) NEW_LINE DEDENT return nth NEW_LINE DEDENT N = 3 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def kthSmallest ( n , k ) : NEW_LINE INDENT return 2 * k NEW_LINE DEDENT n = 8 ; k = 4 NEW_LINE print ( kthSmallest ( n , k ) ) NEW_LINE
def isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT n = 10 NEW_LINE if isSumOfPowersOfTwo ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findMinRemoval ( arr , n ) : NEW_LINE INDENT value = 0 NEW_LINE maximum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = ( abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 2 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinRemoval ( arr , n ) ) NEW_LINE DEDENT
def getTime ( u , v , x ) : NEW_LINE INDENT speed = u + v NEW_LINE time = x / speed NEW_LINE return time NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT u , v , x = 3 , 3 , 3 NEW_LINE print ( getTime ( u , v , x ) ) NEW_LINE DEDENT
import math NEW_LINE def number_of_teams ( M ) : NEW_LINE INDENT N1 , N2 , sqr = 0 , 0 , 0 NEW_LINE sqr = math . sqrt ( 1 + ( 8 * M ) ) NEW_LINE N1 = ( 1 + sqr ) / 2 NEW_LINE N2 = ( 1 - sqr ) / 2 NEW_LINE if ( N1 > 0 ) : NEW_LINE INDENT return int ( N1 ) NEW_LINE DEDENT return int ( N2 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT M = 45 NEW_LINE print ( number_of_teams ( M ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def LucasSum ( N ) : NEW_LINE INDENT Sum = 0 NEW_LINE a = 2 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE Sum += a NEW_LINE while ( b <= N ) : NEW_LINE INDENT Sum += b NEW_LINE c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return Sum NEW_LINE DEDENT N = 20 NEW_LINE print ( LucasSum ( N ) ) NEW_LINE
def countNumbers ( l , r ) : NEW_LINE INDENT return ( ( r // 6 ) - ( l - 1 ) // 6 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 1000 ; r = 6000 ; NEW_LINE print ( countNumbers ( l , r ) ) ; NEW_LINE DEDENT
def findMinSum ( arr , n ) : NEW_LINE INDENT occ = n - 1 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] * pow ( 2 , occ ) NEW_LINE occ -= 1 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinSum ( arr , n ) ) NEW_LINE
def countNumbers ( X , Y , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( ( i % X == 0 ) and ( i % Y != 0 ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT X = 2 ; NEW_LINE Y = 3 ; NEW_LINE N = 10 ; NEW_LINE print ( countNumbers ( X , Y , N ) ) ; NEW_LINE
def getPosition ( n , m ) : NEW_LINE INDENT if ( m > ( n // 2 ) ) : NEW_LINE INDENT return ( m - ( n // 2 ) ) NEW_LINE DEDENT return ( m + ( n // 2 ) ) NEW_LINE DEDENT n = 8 NEW_LINE m = 5 NEW_LINE print ( getPosition ( n , m ) ) NEW_LINE
def parity ( a ) : NEW_LINE INDENT return a % 3 NEW_LINE DEDENT def solve ( array , size ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( 0 , size - 1 ) : NEW_LINE INDENT if parity ( array [ i ] ) == parity ( array [ i + 1 ] ) : NEW_LINE INDENT operations += 1 NEW_LINE if i + 2 < size : NEW_LINE INDENT pari1 = parity ( array [ i ] ) NEW_LINE pari2 = parity ( array [ i + 2 ] ) NEW_LINE if pari1 == pari2 : NEW_LINE INDENT if pari1 == 0 : NEW_LINE INDENT array [ i + 1 ] = 1 NEW_LINE DEDENT elif pari1 == 1 : NEW_LINE INDENT array [ i + 1 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT array [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( pari1 == 0 and pari2 == 1 ) or ( pari1 == 1 and pari2 == 0 ) ) : NEW_LINE INDENT array [ i + 1 ] = 2 NEW_LINE DEDENT if ( ( pari1 == 1 and pari2 == 2 ) or ( pari1 == 2 and pari2 == 1 ) ) : NEW_LINE INDENT array [ i + 1 ] = 0 NEW_LINE DEDENT if ( ( pari1 == 2 and pari2 == 0 ) and ( pari1 == 0 and pari2 == 2 ) ) : NEW_LINE INDENT array [ i + 1 ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return operations NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ 2 , 1 , 3 , 0 ] NEW_LINE size = len ( array ) NEW_LINE print ( solve ( array , size ) ) NEW_LINE DEDENT
def submatrixXor ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT top_left = ( i + 1 ) * ( j + 1 ) NEW_LINE bottom_right = ( n - i ) * ( n - j ) NEW_LINE if ( top_left % 2 == 1 and bottom_right % 2 == 1 ) : NEW_LINE INDENT ans = ( ans ^ arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT n = 3 NEW_LINE arr = [ [ 6 , 7 , 13 ] , [ 8 , 3 , 4 ] , [ 9 , 7 , 6 ] ] NEW_LINE print ( submatrixXor ( arr , n ) ) NEW_LINE
import sys NEW_LINE def findDigitalRoot ( num ) : NEW_LINE INDENT sum = sys . maxsize ; NEW_LINE tempNum = num ; NEW_LINE while ( sum >= 10 ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( tempNum > 0 ) : NEW_LINE INDENT sum += tempNum % 10 ; NEW_LINE tempNum //= 10 ; NEW_LINE DEDENT tempNum = sum ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def findAnswer ( X , N ) : NEW_LINE INDENT counter = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( counter < N ) : NEW_LINE INDENT i += 1 ; NEW_LINE digitalRoot = findDigitalRoot ( i ) ; NEW_LINE if ( digitalRoot == X ) : NEW_LINE INDENT counter += 1 ; NEW_LINE DEDENT if ( counter == N ) : NEW_LINE INDENT print ( i ) ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 1 ; NEW_LINE N = 3 ; NEW_LINE findAnswer ( X , N ) ; NEW_LINE DEDENT
def findAnswer ( X , N ) : NEW_LINE INDENT return ( N - 1 ) * 9 + X ; NEW_LINE DEDENT X = 7 ; NEW_LINE N = 43 ; NEW_LINE print ( findAnswer ( X , N ) ) ; NEW_LINE
def count ( N , K , R ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % K == R ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE K = 4 NEW_LINE R = 3 NEW_LINE print ( count ( N , K , R ) ) NEW_LINE DEDENT
def getCount ( a , b , c ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , 82 ) : NEW_LINE INDENT cr = b * pow ( i , a ) + c NEW_LINE tmp = cr NEW_LINE sm = 0 NEW_LINE while ( tmp ) : NEW_LINE INDENT sm += tmp % 10 NEW_LINE tmp //= 10 NEW_LINE DEDENT if ( sm == i and cr < 10 ** 9 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT a , b , c = 3 , 2 , 8 NEW_LINE print ( getCount ( a , b , c ) ) NEW_LINE
def isSpiltPossible ( n , a ) : NEW_LINE INDENT Sum = 0 NEW_LINE c1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += a [ i ] NEW_LINE if ( a [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT DEDENT if ( Sum % 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( Sum // 2 ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( c1 > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 3 NEW_LINE a = [ 1 , 1 , 2 ] NEW_LINE if ( isSpiltPossible ( n , a ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
n = 3 NEW_LINE def matrixSum ( arr ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT top_left = ( i + 1 ) * ( j + 1 ) ; NEW_LINE bottom_right = ( n - i ) * ( n - j ) ; NEW_LINE sum += ( top_left * bottom_right * arr [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] , [ 1 , 1 , 1 ] ] ; NEW_LINE print ( matrixSum ( arr ) ) NEW_LINE DEDENT
def maxAND ( L , R ) : NEW_LINE INDENT maximum = L & R NEW_LINE for i in range ( L , R , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , R + 1 , 1 ) : NEW_LINE INDENT maximum = max ( maximum , ( i & j ) ) NEW_LINE DEDENT DEDENT return maximum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 1 NEW_LINE R = 632 NEW_LINE print ( maxAND ( L , R ) ) NEW_LINE DEDENT
def checkArray ( arr , n ) : NEW_LINE INDENT return ( ( arr [ 0 ] % 2 ) and ( arr [ n - 1 ] % 2 ) and ( n % 2 ) ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) ; NEW_LINE if checkArray ( arr , n ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
def findCount ( arr , n ) : NEW_LINE INDENT countOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT countOdd += 1 ; NEW_LINE DEDENT DEDENT if ( countOdd % 2 == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 5 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( findCount ( arr , n ) ) ; NEW_LINE DEDENT
import math as mt NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = mt . sqrt ( x ) NEW_LINE return ( ( sr - mt . floor ( sr ) ) == 0 ) NEW_LINE DEDENT def isSunnyNum ( n ) : NEW_LINE INDENT if ( isPerfectSquare ( n + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 3 NEW_LINE if ( isSunnyNum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import sqrt ; NEW_LINE N = 100005 ; NEW_LINE isprime = [ True ] * N ; NEW_LINE can = [ False ] * N ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT for p in range ( 2 , int ( sqrt ( N ) ) + 1 ) : NEW_LINE INDENT if ( isprime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , N , p ) : NEW_LINE INDENT isprime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT primes = [ ] ; NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( isprime [ i ] ) : NEW_LINE INDENT primes . append ( i ) ; NEW_LINE DEDENT DEDENT return primes ; NEW_LINE DEDENT def Prime_Numbers ( n ) : NEW_LINE INDENT primes = SieveOfEratosthenes ( ) ; NEW_LINE for i in range ( len ( primes ) - 1 ) : NEW_LINE INDENT if ( primes [ i ] + primes [ i + 1 ] + 1 < N ) : NEW_LINE INDENT can [ primes [ i ] + primes [ i + 1 ] + 1 ] = True ; NEW_LINE DEDENT DEDENT ans = 0 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( can [ i ] and isprime [ i ] ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 50 ; NEW_LINE print ( Prime_Numbers ( n ) ) ; NEW_LINE DEDENT
import math as mt NEW_LINE def findAndSum ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE mul = 1 NEW_LINE for i in range ( 30 ) : NEW_LINE INDENT count_on = 0 NEW_LINE l = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) > 0 ) : NEW_LINE INDENT if ( count_on ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_on = 1 NEW_LINE l += 1 NEW_LINE DEDENT DEDENT elif ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT DEDENT if ( count_on ) : NEW_LINE INDENT Sum += ( ( mul * l * ( l + 1 ) ) // 2 ) NEW_LINE count_on = 0 NEW_LINE l = 0 NEW_LINE DEDENT mul *= 2 NEW_LINE DEDENT return Sum NEW_LINE DEDENT arr = [ 7 , 1 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findAndSum ( arr , n ) ) NEW_LINE
def isPossible ( Sx , Sy , Dx , Dy , x , y ) : NEW_LINE INDENT if ( abs ( Sx - Dx ) % x == 0 and abs ( Sy - Dy ) % y == 0 and ( abs ( Sx - Dx ) / x ) % 2 == ( abs ( Sy - Dy ) / y ) % 2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT Sx = 0 ; NEW_LINE Sy = 0 ; NEW_LINE Dx = 0 ; NEW_LINE Dy = 0 ; NEW_LINE x = 3 ; NEW_LINE y = 4 ; NEW_LINE if ( isPossible ( Sx , Sy , Dx , Dy , x , y ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def getPairs ( a ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( a ) ) : NEW_LINE INDENT if ( a [ i ] < a [ j ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 4 , 3 , 1 ] NEW_LINE print ( getPairs ( a ) ) NEW_LINE DEDENT
def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return False NEW_LINE DEDENT def isDigitSumOne ( nm ) : NEW_LINE INDENT while ( nm > 9 ) : NEW_LINE INDENT sum_digit = 0 NEW_LINE while ( nm != 0 ) : NEW_LINE INDENT digit = nm % 10 NEW_LINE sum_digit = sum_digit + digit NEW_LINE nm = nm // 10 NEW_LINE DEDENT nm = sum_digit NEW_LINE DEDENT if ( nm == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def printValidNums ( m , n ) : NEW_LINE INDENT for i in range ( m , n + 1 ) : NEW_LINE INDENT if ( isComposite ( i ) and isDigitSumOne ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT l = 10 NEW_LINE r = 100 NEW_LINE printValidNums ( m , n ) NEW_LINE
def calcNodes ( N , I ) : NEW_LINE INDENT result = 0 NEW_LINE result = I * ( N - 1 ) + 1 NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE I = 2 NEW_LINE print ( " Leaf ▁ nodes ▁ = ▁ " , calcNodes ( N , I ) ) NEW_LINE DEDENT
mod = 1000000007 NEW_LINE arr = [ 0 ] * ( 1000001 ) NEW_LINE def cal_factorial ( ) : NEW_LINE INDENT arr [ 0 ] = 1 NEW_LINE for i in range ( 1 , 1000001 ) : NEW_LINE INDENT arr [ i ] = ( arr [ i - 1 ] * i ) % mod NEW_LINE DEDENT DEDENT def mod_exponent ( num , p ) : NEW_LINE INDENT if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( p & 1 ) : NEW_LINE INDENT return ( ( num % mod ) * ( mod_exponent ( ( num * num ) % mod , p // 2 ) ) % mod ) % mod NEW_LINE DEDENT elif ( not ( p & 1 ) ) : NEW_LINE INDENT return ( mod_exponent ( ( num * num ) % mod , p // 2 ) ) % mod NEW_LINE DEDENT DEDENT def getCount ( x , y ) : NEW_LINE INDENT ans = arr [ x + y - 1 ] NEW_LINE ans *= mod_exponent ( arr [ x ] , mod - 2 ) NEW_LINE ans %= mod NEW_LINE ans *= mod_exponent ( arr [ y ] , mod - 2 ) NEW_LINE ans %= mod NEW_LINE ans *= ( x - y ) NEW_LINE ans %= mod NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT cal_factorial ( ) NEW_LINE x = 3 NEW_LINE y = 1 NEW_LINE print ( getCount ( x , y ) ) NEW_LINE DEDENT
def findValues ( a , b ) : NEW_LINE INDENT if ( ( a - b ) % 2 == 1 ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE return ; NEW_LINE DEDENT print ( ( a - b ) // 2 , ( a + b ) // 2 ) ; NEW_LINE DEDENT a = 12 ; b = 8 ; NEW_LINE findValues ( a , b ) ; NEW_LINE
def countTriplets ( n , points ) : NEW_LINE INDENT pts = [ ] NEW_LINE ct = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT pts . append ( points [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = points [ i ] [ 0 ] + points [ j ] [ 0 ] ; NEW_LINE y = points [ i ] [ 1 ] + points [ j ] [ 1 ] ; NEW_LINE if ( x % 2 == 0 and y % 2 == 0 ) : NEW_LINE INDENT if [ x // 2 , y // 2 ] in pts : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT points = [ [ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 3 ] ] NEW_LINE n = len ( points ) NEW_LINE print ( countTriplets ( n , points ) ) NEW_LINE DEDENT
def mixtureConcentration ( n , p ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT res += p [ i ] ; NEW_LINE DEDENT res /= n ; NEW_LINE return res ; NEW_LINE DEDENT arr = [ 0 , 20 , 20 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( round ( mixtureConcentration ( n , arr ) , 4 ) ) ; NEW_LINE
def countOddSquares ( n , m ) : NEW_LINE INDENT return ( int ( pow ( m , 0.5 ) ) - int ( pow ( n - 1 , 0.5 ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 ; m = 100 ; NEW_LINE print ( " Count ▁ is " , ( m - n + 1 ) - countOddSquares ( n , m ) ) NEW_LINE DEDENT
def Square ( row , column , moves ) : NEW_LINE INDENT a = 0 ; b = 0 ; c = 0 ; NEW_LINE d = 0 ; total = 0 ; NEW_LINE a = row - moves ; NEW_LINE b = row + moves ; NEW_LINE c = column - moves ; NEW_LINE d = column + moves ; NEW_LINE if ( a < 1 ) : NEW_LINE INDENT a = 1 ; NEW_LINE DEDENT if ( c < 1 ) : NEW_LINE INDENT c = 1 ; NEW_LINE DEDENT if ( b > 8 ) : NEW_LINE INDENT b = 8 ; NEW_LINE DEDENT if ( d > 8 ) : NEW_LINE INDENT d = 8 ; NEW_LINE DEDENT total = ( b - a + 1 ) * ( d - c + 1 ) - 1 ; NEW_LINE return total ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT R = 4 ; C = 5 ; M = 2 ; NEW_LINE print ( Square ( R , C , M ) ) ; NEW_LINE DEDENT
def findNumber ( n , m ) : NEW_LINE INDENT num = ( m - 1 ) * 9 + n ; NEW_LINE return num ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 ; NEW_LINE m = 5 ; NEW_LINE print ( findNumber ( n , m ) ) NEW_LINE DEDENT
def checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT tri = list ( ) ; NEW_LINE i = 1 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT x = i * ( i + 1 ) // 2 ; NEW_LINE if ( x >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT tri . append ( x ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT for tm in tri : NEW_LINE INDENT if n - tm in tri : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 24 ; NEW_LINE if checkTriangularSumRepresentation ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def digitsCount ( n ) : NEW_LINE INDENT length = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT length += 1 ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return length ; NEW_LINE DEDENT def absoluteFirstLast ( n , x ) : NEW_LINE INDENT i = 0 ; NEW_LINE mod = 1 ; NEW_LINE while ( i < x ) : NEW_LINE INDENT mod *= 10 ; NEW_LINE i += 1 ; NEW_LINE DEDENT last = n % mod ; NEW_LINE length = digitsCount ( n ) ; NEW_LINE while ( length != x ) : NEW_LINE INDENT n //= 10 ; NEW_LINE length -= 1 ; NEW_LINE DEDENT first = n ; NEW_LINE return abs ( first - last ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 21546 ; NEW_LINE x = 2 ; NEW_LINE print ( absoluteFirstLast ( n , x ) ) ; NEW_LINE DEDENT
def make_sequence ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) NEW_LINE sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 1 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = 2 NEW_LINE DEDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % 2 == 1 ) : NEW_LINE INDENT arr [ 2 ] = 3 NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 9 NEW_LINE make_sequence ( N ) NEW_LINE DEDENT
def countOdd ( L , R ) : NEW_LINE INDENT N = ( R - L ) // 2 NEW_LINE if ( R % 2 != 0 or L % 2 != 0 ) : NEW_LINE INDENT N += 1 NEW_LINE DEDENT return N NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 3 NEW_LINE R = 7 NEW_LINE odds = countOdd ( L , R ) NEW_LINE evens = ( R - L + 1 ) - odds NEW_LINE print ( " Count ▁ of ▁ odd ▁ numbers ▁ is " , odds ) NEW_LINE print ( " Count ▁ of ▁ even ▁ numbers ▁ is " , evens ) NEW_LINE DEDENT
def getMinCost ( n , m ) : NEW_LINE INDENT cost = ( n - 1 ) * m + ( m - 1 ) * n NEW_LINE return cost NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m = 4 , 5 NEW_LINE print ( getMinCost ( n , m ) ) NEW_LINE DEDENT
def minOperation ( n , k , a ) : NEW_LINE INDENT for i in range ( k , n ) : NEW_LINE INDENT if ( a [ i ] != a [ k - 1 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT for i in range ( k - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ k - 1 ] ) : NEW_LINE INDENT return i + 1 NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE k = 3 NEW_LINE a = [ 2 , 1 , 1 , 1 , 1 ] NEW_LINE print ( minOperation ( n , k , a ) ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res //= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 NEW_LINE M = 1 NEW_LINE P = ( N * ( N - 1 ) ) // 2 NEW_LINE print ( binomialCoeff ( P , M ) ) NEW_LINE DEDENT
def generateSequence ( n , g ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i * g , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , g = 6 , 5 NEW_LINE generateSequence ( n , g ) NEW_LINE DEDENT
MAX = 1000 NEW_LINE f = [ 0 ] * MAX NEW_LINE def fib ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT f [ n ] = 1 NEW_LINE return f [ n ] NEW_LINE DEDENT if ( f [ n ] ) : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT k = ( n + 1 ) // 2 if ( n & 1 ) else n // 2 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT f [ n ] = ( fib ( k ) * fib ( k ) + fib ( k - 1 ) * fib ( k - 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT f [ n ] = ( 2 * fib ( k - 1 ) + fib ( k ) ) * fib ( k ) NEW_LINE DEDENT return f [ n ] NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findLCMFibonacci ( a , b ) : NEW_LINE INDENT return ( fib ( a ) * fib ( b ) ) // fib ( gcd ( a , b ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 NEW_LINE b = 12 NEW_LINE print ( findLCMFibonacci ( a , b ) ) NEW_LINE DEDENT
def isEvenOrOdd ( L , R ) : NEW_LINE INDENT oddCount = ( R - L ) / 2 NEW_LINE if ( R % 2 == 1 or L % 2 == 1 ) : NEW_LINE INDENT oddCount = oddCount + 1 NEW_LINE DEDENT if ( oddCount % 2 == 0 ) : NEW_LINE INDENT return " Even " NEW_LINE DEDENT else : NEW_LINE INDENT return " Odd " NEW_LINE DEDENT DEDENT L = 5 NEW_LINE R = 15 NEW_LINE print ( isEvenOrOdd ( L , R ) ) ; NEW_LINE
def trailing_zeros ( N ) : NEW_LINE INDENT count_of_two = 0 NEW_LINE count_of_five = 0 NEW_LINE for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT val = i NEW_LINE while ( val % 2 == 0 and val > 0 ) : NEW_LINE INDENT val /= 2 NEW_LINE count_of_two += i NEW_LINE DEDENT while ( val % 5 == 0 and val > 0 ) : NEW_LINE INDENT val /= 5 NEW_LINE count_of_five += i NEW_LINE DEDENT DEDENT ans = min ( count_of_two , count_of_five ) NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE print ( trailing_zeros ( N ) ) NEW_LINE DEDENT
def midptellipse ( rx , ry , xc , yc ) : NEW_LINE INDENT x = 0 ; NEW_LINE y = ry ; NEW_LINE d1 = ( ( ry * ry ) - ( rx * rx * ry ) + ( 0.25 * rx * rx ) ) ; NEW_LINE dx = 2 * ry * ry * x ; NEW_LINE dy = 2 * rx * rx * y ; NEW_LINE while ( dx < dy ) : NEW_LINE INDENT print ( " ( " , x + xc , " , " , y + yc , " ) " ) ; NEW_LINE print ( " ( " , - x + xc , " , " , y + yc , " ) " ) ; NEW_LINE print ( " ( " , x + xc , " , " , - y + yc , " ) " ) ; NEW_LINE print ( " ( " , - x + xc , " , " , - y + yc , " ) " ) ; NEW_LINE if ( d1 < 0 ) : NEW_LINE INDENT x += 1 ; NEW_LINE dx = dx + ( 2 * ry * ry ) ; NEW_LINE d1 = d1 + dx + ( ry * ry ) ; NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 ; NEW_LINE y -= 1 ; NEW_LINE dx = dx + ( 2 * ry * ry ) ; NEW_LINE dy = dy - ( 2 * rx * rx ) ; NEW_LINE d1 = d1 + dx - dy + ( ry * ry ) ; NEW_LINE DEDENT DEDENT d2 = ( ( ( ry * ry ) * ( ( x + 0.5 ) * ( x + 0.5 ) ) ) + ( ( rx * rx ) * ( ( y - 1 ) * ( y - 1 ) ) ) - ( rx * rx * ry * ry ) ) ; NEW_LINE while ( y >= 0 ) : NEW_LINE INDENT print ( " ( " , x + xc , " , " , y + yc , " ) " ) ; NEW_LINE print ( " ( " , - x + xc , " , " , y + yc , " ) " ) ; NEW_LINE print ( " ( " , x + xc , " , " , - y + yc , " ) " ) ; NEW_LINE print ( " ( " , - x + xc , " , " , - y + yc , " ) " ) ; NEW_LINE if ( d2 > 0 ) : NEW_LINE INDENT y -= 1 ; NEW_LINE dy = dy - ( 2 * rx * rx ) ; NEW_LINE d2 = d2 + ( rx * rx ) - dy ; NEW_LINE DEDENT else : NEW_LINE INDENT y -= 1 ; NEW_LINE x += 1 ; NEW_LINE dx = dx + ( 2 * ry * ry ) ; NEW_LINE dy = dy - ( 2 * rx * rx ) ; NEW_LINE d2 = d2 + dx - dy + ( rx * rx ) ; NEW_LINE DEDENT DEDENT DEDENT midptellipse ( 10 , 15 , 50 , 50 ) ; NEW_LINE
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 ; NEW_LINE sum += k ; NEW_LINE n /= 10 ; NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " ; NEW_LINE DEDENT return " NO " ; NEW_LINE DEDENT n = 123 ; NEW_LINE print ( isDivisible ( n ) ) ; NEW_LINE
import math as mt NEW_LINE def alter ( x , y ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT if ( x == 0 or y == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( x >= 2 * y ) : NEW_LINE INDENT x = x % ( 2 * y ) NEW_LINE DEDENT elif ( y >= 2 * x ) : NEW_LINE INDENT y = y % ( 2 * x ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " X ▁ = " , x , " , ▁ " , " Y ▁ = " , y ) NEW_LINE DEDENT x , y = 12 , 5 NEW_LINE alter ( x , y ) NEW_LINE
from math import sqrt NEW_LINE def digitProduct ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( n ) : NEW_LINE INDENT prod = prod * ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return prod NEW_LINE DEDENT def printMultiplicativePrimes ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ digitProduct ( i ) ] ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE printMultiplicativePrimes ( n ) NEW_LINE DEDENT
import math as mt NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def coPrime ( n1 , n2 ) : NEW_LINE INDENT if ( gcd ( n1 , n2 ) == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def largestCoprime ( N ) : NEW_LINE INDENT half = mt . floor ( N / 2 ) NEW_LINE while ( coPrime ( N , half ) == False ) : NEW_LINE INDENT half -= 1 NEW_LINE DEDENT return half NEW_LINE DEDENT n = 50 NEW_LINE print ( largestCoprime ( n ) ) NEW_LINE
def largestCoprime ( N ) : NEW_LINE INDENT if N == 6 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif N % 4 == 0 : NEW_LINE INDENT return N // 2 - 1 NEW_LINE DEDENT elif N % 2 == 0 : NEW_LINE INDENT return N // 2 - 2 NEW_LINE DEDENT else : NEW_LINE INDENT return ( N - 1 ) // 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 50 NEW_LINE print ( largestCoprime ( n ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def printSafePrimes ( n ) : NEW_LINE INDENT prime = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = 1 NEW_LINE DEDENT prime [ 0 ] = prime [ 1 ] = 0 NEW_LINE for p in range ( 2 , int ( sqrt ( n ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT if ( prime [ i ] != 0 ) : NEW_LINE INDENT temp = ( 2 * i ) + 1 NEW_LINE if ( temp <= n and prime [ temp ] != 0 ) : NEW_LINE INDENT prime [ temp ] = 2 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 5 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 20 NEW_LINE printSafePrimes ( n ) NEW_LINE DEDENT
def Divisors ( x ) : NEW_LINE INDENT c = 0 NEW_LINE v = [ ] NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 2 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 3 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 7 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 7 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( x ) NEW_LINE return v NEW_LINE DEDENT def MinOperations ( a , b ) : NEW_LINE INDENT va = Divisors ( a ) NEW_LINE vb = Divisors ( b ) NEW_LINE if ( va [ 3 ] != vb [ 3 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) NEW_LINE return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 14 NEW_LINE b = 28 NEW_LINE print ( MinOperations ( a , b ) ) NEW_LINE DEDENT
def largestOddDigit ( n ) : NEW_LINE INDENT maxOdd = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( digit % 2 == 1 and digit > maxOdd ) : NEW_LINE INDENT maxOdd = digit NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return maxOdd NEW_LINE DEDENT def getProduct ( n ) : NEW_LINE INDENT maxOdd = largestOddDigit ( n ) NEW_LINE if ( maxOdd == - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return ( n * maxOdd ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12345 NEW_LINE print ( getProduct ( n ) ) NEW_LINE DEDENT
n = 100002 ; NEW_LINE phi = [ 0 ] * ( n + 2 ) ; NEW_LINE ans = [ 0 ] * ( n + 2 ) ; NEW_LINE def ETF ( ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT phi [ i ] = i ; NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ i ] == i ) : NEW_LINE INDENT phi [ i ] = i - 1 ; NEW_LINE for j in range ( 2 * i , n + 1 , i ) : NEW_LINE INDENT phi [ j ] = ( phi [ j ] * ( i - 1 ) ) // i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def LcmSum ( m ) : NEW_LINE INDENT ETF ( ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 , i ) : NEW_LINE INDENT ans [ j ] += ( i * phi [ i ] ) ; NEW_LINE DEDENT DEDENT answer = ans [ m ] ; NEW_LINE answer = ( answer + 1 ) * m ; NEW_LINE answer = answer // 2 ; NEW_LINE return answer ; NEW_LINE DEDENT m = 5 ; NEW_LINE print ( LcmSum ( m ) ) ; NEW_LINE
def factorial ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def ncr ( n , r ) : NEW_LINE INDENT return factorial ( n ) // ( factorial ( r ) * factorial ( n - r ) ) NEW_LINE DEDENT def countWays ( string ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE nvowels , nconsonants = 0 , 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT if ( i == 0 or i == 4 or i == 8 or i == 14 or i == 20 ) : NEW_LINE INDENT nvowels += freq [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT nconsonants += freq [ i ] NEW_LINE DEDENT DEDENT vplaces = nconsonants + 1 NEW_LINE cways = factorial ( nconsonants ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( i != 0 and i != 4 and i != 8 and i != 14 and i != 20 and freq [ i ] > 1 ) : NEW_LINE INDENT cways = cways // factorial ( freq [ i ] ) NEW_LINE DEDENT DEDENT vways = ncr ( vplaces , nvowels ) * factorial ( nvowels ) NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( i == 0 or i == 4 or i == 8 or i == 14 or i == 20 and freq [ i ] > 1 ) : NEW_LINE INDENT vways = vways // factorial ( freq [ i ] ) NEW_LINE DEDENT DEDENT return cways * vways ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " permutation " NEW_LINE print ( countWays ( string ) ) NEW_LINE DEDENT
def setBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countPairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT setbits_x = setBits ( a [ i ] ) NEW_LINE for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT setbits_y = setBits ( a [ j ] ) NEW_LINE setbits_xor_xy = setBits ( a [ i ] ^ a [ j ] ) ; NEW_LINE if ( setbits_x + setbits_y == setbits_xor_xy ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( countPairs ( a , n ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def findPossibleDerivables ( arr , n , D , A , B ) : NEW_LINE INDENT gcdAB = gcd ( A , B ) NEW_LINE counter = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( abs ( arr [ i ] - D ) % gcdAB ) == 0 ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 7 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE D , A , B = 5 , 4 , 2 NEW_LINE print ( findPossibleDerivables ( arr , n , D , A , B ) ) NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE D , A , B = 6 , 3 , 2 NEW_LINE print ( findPossibleDerivables ( a , n , D , A , B ) ) NEW_LINE DEDENT
def calSum ( n ) : NEW_LINE INDENT return ( n * ( 2 * n * n * n + 12 * n * n + 25 * n + 21 ) ) / 2 ; NEW_LINE DEDENT n = 3 NEW_LINE print ( calSum ( n ) ) NEW_LINE
def getElements ( a , arr , n ) : NEW_LINE INDENT elements = [ 1 for i in range ( n + 1 ) ] NEW_LINE elements [ 0 ] = a NEW_LINE for i in range ( n ) : NEW_LINE INDENT elements [ i + 1 ] = arr [ i ] ^ elements [ i ] NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( elements [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 13 , 2 , 6 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE a = 5 NEW_LINE getElements ( a , arr , n ) NEW_LINE
def distinctDigitSum ( n ) : NEW_LINE INDENT used = [ False ] * 10 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 NEW_LINE if ( not used [ digit ] ) : NEW_LINE INDENT used [ digit ] = True NEW_LINE sum += digit NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def checkSum ( m , n ) : NEW_LINE INDENT sumM = distinctDigitSum ( m ) NEW_LINE sumN = distinctDigitSum ( n ) NEW_LINE if ( sumM == sumN ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT return " NO " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 2452 NEW_LINE n = 9222 NEW_LINE print ( checkSum ( m , n ) ) NEW_LINE DEDENT
from math import pow NEW_LINE def doubleFactorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def hermiteNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT number = ( ( pow ( 2 , n / 2 ) ) * doubleFactorial ( n - 1 ) ) NEW_LINE if ( ( n / 2 ) % 2 == 1 ) : NEW_LINE INDENT number = number * - 1 NEW_LINE DEDENT return number NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( int ( hermiteNumber ( n ) ) ) NEW_LINE DEDENT
def getSum ( n , d ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i % 10 == d ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , d = 30 , 3 NEW_LINE print ( getSum ( n , d ) ) NEW_LINE DEDENT
def printThreeParts ( N ) : NEW_LINE INDENT if ( N % 3 == 0 ) : NEW_LINE INDENT print ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 1 , ▁ z ▁ = ▁ " , N - 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " ▁ x ▁ = ▁ 1 , ▁ y ▁ = ▁ 2 , ▁ z ▁ = ▁ " , N - 3 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 10 NEW_LINE printThreeParts ( N ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isPrime ( N ) : NEW_LINE INDENT k = int ( sqrt ( N ) ) + 1 NEW_LINE for i in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def getDifference ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT elif ( N == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( isPrime ( N ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT aboveN = - 1 NEW_LINE belowN = - 1 NEW_LINE n1 = N + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPrime ( n1 ) ) : NEW_LINE INDENT aboveN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT DEDENT n1 = N - 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPrime ( n1 ) ) : NEW_LINE INDENT belowN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 -= 1 NEW_LINE DEDENT DEDENT diff1 = aboveN - N NEW_LINE diff2 = N - belowN NEW_LINE return min ( diff1 , diff2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE print ( getDifference ( N ) ) NEW_LINE DEDENT
import math NEW_LINE def check ( a , y ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT x = math . sqrt ( a [ i ] ) NEW_LINE if ( math . floor ( x ) == math . ceil ( x ) ) : NEW_LINE INDENT sum = sum + a [ i ] NEW_LINE DEDENT DEDENT if ( sum % y == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = [ 2 , 3 , 4 , 9 , 10 ] NEW_LINE x = 13 NEW_LINE if check ( a , x ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import ceil NEW_LINE def MinimumMaximumPairs ( n , m ) : NEW_LINE INDENT max_pairs = ( ( n - m + 1 ) * ( n - m ) ) // 2 ; NEW_LINE min_pairs = ( m * ( ( ( n - m ) // m + 1 ) * ( ( n - m ) // m ) ) // 2 + ceil ( ( n - m ) / ( m ) ) * ( ( n - m ) % m ) ) NEW_LINE print ( " Minimum ▁ no . ▁ of ▁ pairs ▁ = ▁ " , min_pairs ) NEW_LINE print ( " Maximum ▁ no . ▁ of ▁ pairs ▁ = ▁ " , max_pairs ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , m = 5 , 2 NEW_LINE MinimumMaximumPairs ( n , m ) NEW_LINE DEDENT
import math NEW_LINE def findGreater ( a , b ) : NEW_LINE INDENT x = a * ( math . log ( b ) ) ; NEW_LINE y = b * ( math . log ( a ) ) ; NEW_LINE if ( y > x ) : NEW_LINE INDENT print ( " a ^ b ▁ is ▁ greater " ) ; NEW_LINE DEDENT elif ( y < x ) : NEW_LINE INDENT print ( " b ^ a ▁ is ▁ greater " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Both ▁ are ▁ equal " ) ; NEW_LINE DEDENT DEDENT a = 3 ; NEW_LINE b = 5 ; NEW_LINE c = 2 ; NEW_LINE d = 4 ; NEW_LINE findGreater ( a , b ) ; NEW_LINE findGreater ( c , d ) ; NEW_LINE
m = 1000000007 NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def modexp ( x , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return modexp ( ( x * x ) % m , n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 ) % m ) NEW_LINE DEDENT DEDENT def getFractionModulo ( a , b ) : NEW_LINE INDENT c = gcd ( a , b ) NEW_LINE a = a // c NEW_LINE b = b // c NEW_LINE d = modexp ( b , m - 2 ) NEW_LINE ans = ( ( a % m ) * ( d % m ) ) % m NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 6 NEW_LINE print ( getFractionModulo ( a , b ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def maxPrimeFactors ( n ) : NEW_LINE INDENT num = n NEW_LINE maxPrime = - 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT maxPrime = 2 NEW_LINE n = n / 2 NEW_LINE DEDENT p = int ( sqrt ( n ) + 1 ) NEW_LINE for i in range ( 3 , p , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maxPrime = i NEW_LINE n = n / i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT sum = maxPrime + num NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE DEDENT
def sumOfDigits ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT res += n % 10 NEW_LINE n /= 10 NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findNumber ( n ) : NEW_LINE INDENT i = n - 1 ; NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 824 ; NEW_LINE print ( findNumber ( n ) ) NEW_LINE DEDENT
def findNth ( N ) : NEW_LINE INDENT b = 14 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT b = b * 2 NEW_LINE DEDENT else : NEW_LINE INDENT b = b - 8 NEW_LINE DEDENT DEDENT return b NEW_LINE DEDENT N = 6 NEW_LINE print ( findNth ( N ) ) NEW_LINE
N = 4 NEW_LINE def predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) : NEW_LINE INDENT c = 0 NEW_LINE while ( K ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT c = 0 NEW_LINE if ( i > 0 and arr [ i - 1 ] [ j ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j > 0 and arr [ i ] [ j - 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i > 0 and j > 0 and arr [ i - 1 ] [ j - 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i < N - 1 and arr [ i + 1 ] [ j ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j < N - 1 and arr [ i ] [ j + 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i < N - 1 and j < N - 1 and arr [ i + 1 ] [ j + 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i < N - 1 and j > 0 and arr [ i + 1 ] [ j - 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( i > 0 and j < N - 1 and arr [ i - 1 ] [ j + 1 ] == 1 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( arr [ i ] [ j ] == 1 ) : NEW_LINE INDENT if ( c >= range1a and c <= range1b ) : NEW_LINE INDENT b [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT if ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT if ( c >= range0a and c <= range0b ) : NEW_LINE INDENT b [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT b [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT K -= 1 NEW_LINE for k in range ( N ) : NEW_LINE INDENT for m in range ( N ) : NEW_LINE INDENT arr [ k ] [ m ] = b [ k ] [ m ] NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 0 , 0 , 0 , 0 ] , [ 0 , 1 , 1 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 1 , 0 , 1 ] ] NEW_LINE range1a = 2 NEW_LINE range1b = 2 NEW_LINE range0a = 2 NEW_LINE range0b = 3 NEW_LINE K = 3 NEW_LINE b = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE predictMatrix ( arr , range1a , range1b , range0a , range0b , K , b ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( ) NEW_LINE for j in range ( N ) : NEW_LINE INDENT print ( b [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT
def countMoves ( n ) : NEW_LINE INDENT ct = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ct += i * ( n - i ) NEW_LINE DEDENT ct += n NEW_LINE return ct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( countMoves ( n ) ) NEW_LINE DEDENT
def countNumber ( n ) : NEW_LINE INDENT return ( pow ( 10 , n ) - 1 ) - ( pow ( 10 , n ) - pow ( 8 , n ) ) // 2 NEW_LINE DEDENT n = 2 NEW_LINE print ( countNumber ( n ) ) NEW_LINE
def calcDeterminant ( arr , n ) : NEW_LINE INDENT determinant = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT determinant += pow ( arr [ i ] , 3 ) NEW_LINE DEDENT determinant -= 3 * arr [ 0 ] * arr [ 1 ] * arr [ 2 ] NEW_LINE return determinant NEW_LINE DEDENT arr = [ 4 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calcDeterminant ( arr , n ) ) NEW_LINE
def minimumMoves ( k , l , r ) : NEW_LINE INDENT count = r - l + 1 NEW_LINE if ( count % k == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( k - ( count % k ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 3 NEW_LINE l = 10 NEW_LINE r = 10 NEW_LINE print ( minimumMoves ( k , l , r ) ) NEW_LINE DEDENT
def sumNatural ( n ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) NEW_LINE return int ( sum ) NEW_LINE DEDENT def sumEven ( l , r ) : NEW_LINE INDENT return ( sumNatural ( int ( r / 2 ) ) - sumNatural ( int ( ( l - 1 ) / 2 ) ) ) NEW_LINE DEDENT l , r = 2 , 5 NEW_LINE print ( " Sum ▁ of ▁ Natural ▁ numbers " , " from ▁ L ▁ to ▁ R ▁ is " , sumEven ( l , r ) ) NEW_LINE
def isDivisibleRec ( x , a , b , n ) : NEW_LINE INDENT if ( x > n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % x == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return ( isDivisibleRec ( x * 10 + a , a , b , n ) or isDivisibleRec ( x * 10 + b , a , b , n ) ) NEW_LINE DEDENT def isDivisible ( a , b , n ) : NEW_LINE ' NEW_LINE INDENT return ( isDivisibleRec ( a , a , b , n ) or isDivisibleRec ( b , a , b , n ) ) NEW_LINE DEDENT a = 3 ; b = 5 ; n = 53 ; NEW_LINE if ( isDivisible ( a , b , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def MinSteps ( SourceX , SourceY , DestX , DestY ) : NEW_LINE INDENT print ( max ( abs ( SourceX - DestX ) , abs ( SourceY - DestY ) ) ) NEW_LINE while ( ( SourceX != DestX ) or ( SourceY != DestY ) ) : NEW_LINE INDENT if ( SourceX < DestX ) : NEW_LINE INDENT print ( ' U ' , end = " " ) NEW_LINE SourceX += 1 NEW_LINE DEDENT if ( SourceX > DestX ) : NEW_LINE INDENT print ( ' D ' , end = " " ) NEW_LINE SourceX -= 1 NEW_LINE DEDENT if ( SourceY > DestY ) : NEW_LINE INDENT print ( ' L ' ) NEW_LINE SourceY -= 1 NEW_LINE DEDENT if ( SourceY < DestY ) : NEW_LINE INDENT print ( ' R ' , end = " " ) NEW_LINE SourceY += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT sourceX = 4 NEW_LINE sourceY = 4 NEW_LINE destinationX = 7 NEW_LINE destinationY = 0 NEW_LINE MinSteps ( sourceX , sourceY , destinationX , destinationY ) NEW_LINE DEDENT
def getPerfectSquares ( n ) : NEW_LINE INDENT perfectSquares = [ ] ; NEW_LINE current = 1 ; NEW_LINE i = 1 ; NEW_LINE while ( current <= n ) : NEW_LINE INDENT perfectSquares . append ( current ) ; NEW_LINE i += 1 ; NEW_LINE current = int ( pow ( i , 2 ) ) ; NEW_LINE DEDENT return perfectSquares ; NEW_LINE DEDENT def maxPairSum ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = 0 ; NEW_LINE secondMax = 0 ; NEW_LINE if ( arr [ 0 ] > arr [ 1 ] ) : NEW_LINE INDENT max = arr [ 0 ] ; NEW_LINE secondMax = arr [ 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT max = arr [ 1 ] ; NEW_LINE secondMax = arr [ 0 ] ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT secondMax = max ; NEW_LINE max = arr [ i ] ; NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] ; NEW_LINE DEDENT DEDENT return ( max + secondMax ) ; NEW_LINE DEDENT def countPairsWith ( n , perfectSquares , nums ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( len ( perfectSquares ) ) : NEW_LINE INDENT temp = perfectSquares [ i ] - n ; NEW_LINE if ( temp > n and ( temp in nums ) ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countPairs ( arr ) : NEW_LINE INDENT n = len ( arr ) ; NEW_LINE max = maxPairSum ( arr ) ; NEW_LINE perfectSquares = getPerfectSquares ( max ) ; NEW_LINE nums = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT nums . append ( arr [ i ] ) ; NEW_LINE DEDENT count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count += countPairsWith ( arr [ i ] , perfectSquares , nums ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT arr = [ 2 , 3 , 6 , 9 , 10 , 20 ] ; NEW_LINE print ( countPairs ( arr ) ) ; NEW_LINE
def findEle ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == sum - arr [ i ] : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findEle ( arr , n ) ) NEW_LINE DEDENT
def sumNatural ( n ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 NEW_LINE return sum NEW_LINE DEDENT def suminRange ( l , r ) : NEW_LINE INDENT return sumNatural ( r ) - sumNatural ( l - 1 ) NEW_LINE DEDENT l = 2 ; r = 5 NEW_LINE print ( " Sum ▁ of ▁ Natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " , suminRange ( l , r ) ) NEW_LINE
def divisibleBy3 ( number ) : NEW_LINE INDENT sumOfDigit = 0 NEW_LINE for i in range ( 0 , len ( number ) , 1 ) : NEW_LINE INDENT sumOfDigit += ord ( number [ i ] ) - ord ( '0' ) NEW_LINE DEDENT if ( sumOfDigit % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def divisibleBy25 ( number ) : NEW_LINE INDENT if ( len ( number ) < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT length = len ( number ) NEW_LINE lastTwo = ( ( ord ( number [ length - 2 ] ) - ord ( '0' ) ) * 10 + ( ord ( number [ length - 1 ] ) - ord ( '0' ) ) ) NEW_LINE if ( lastTwo % 25 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def divisibleBy75 ( number ) : NEW_LINE INDENT if ( divisibleBy3 ( number ) and divisibleBy25 ( number ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT number = "754586672150" NEW_LINE divisible = divisibleBy75 ( number ) NEW_LINE if ( divisible ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def otherNumber ( a , Lcm , Hcf ) : NEW_LINE INDENT return ( Lcm * Hcf ) // A NEW_LINE DEDENT A = 8 ; Lcm = 8 ; Hcf = 1 NEW_LINE result = otherNumber ( A , Lcm , Hcf ) NEW_LINE print ( " B ▁ = " , result ) NEW_LINE
def successiveChange ( arr , N ) : NEW_LINE INDENT result = 0 ; NEW_LINE var1 = arr [ 0 ] ; NEW_LINE var2 = arr [ 1 ] ; NEW_LINE result = float ( var1 + var2 + ( float ( var1 * var2 ) / 100 ) ) ; NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT result = ( result + arr [ i ] + ( float ( result * arr [ i ] ) / 100 ) ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 10 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE result = successiveChange ( arr , N ) ; NEW_LINE print ( " Percentage ▁ change ▁ is ▁ = ▁ % .2f " % ( result ) , " % " ) ; NEW_LINE
def minimumNumbers ( n , s ) : NEW_LINE INDENT if ( s % n ) : NEW_LINE INDENT return s / n + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return s / n ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE s = 11 ; NEW_LINE print ( int ( minimumNumbers ( n , s ) ) ) ; NEW_LINE
from math import gcd , sqrt NEW_LINE def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) NEW_LINE return ( n ) * ( 1 + n ) * d / 2 NEW_LINE DEDENT def sumMultiples ( A , B , n ) : NEW_LINE INDENT n -= 1 NEW_LINE common = int ( ( A * B ) / gcd ( A , B ) ) NEW_LINE return ( sumAP ( n , A ) + sumAP ( n , B ) - sumAP ( n , common ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 100 NEW_LINE A = 5 NEW_LINE B = 10 NEW_LINE print ( " Sum ▁ = " , int ( sumMultiples ( A , B , n ) ) ) NEW_LINE DEDENT
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPossible ( n ) : NEW_LINE INDENT if isPrime ( n ) and isPrime ( n - 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 13 NEW_LINE if isPossible ( n ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def contiguousPerfectSquare ( arr , n ) : NEW_LINE INDENT current_length = 0 NEW_LINE max_length = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT b = sqrt ( arr [ i ] ) NEW_LINE a = int ( b ) NEW_LINE if ( a == b ) : NEW_LINE INDENT current_length += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 NEW_LINE DEDENT max_length = max ( max_length , current_length ) NEW_LINE DEDENT return max_length NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 75 , 4 , 64 , 121 , 25 ] NEW_LINE n = len ( arr ) NEW_LINE print ( contiguousPerfectSquare ( arr , n ) ) NEW_LINE DEDENT
def countPairs ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT for y in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( ( y * x ) % ( y + x ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT n = 15 NEW_LINE print ( countPairs ( n ) ) NEW_LINE
def getIndex ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ptrL = 0 NEW_LINE ptrR = n - 1 NEW_LINE sumL = a [ 0 ] NEW_LINE sumR = a [ n - 1 ] NEW_LINE while ( ptrR - ptrL > 1 ) : NEW_LINE INDENT if ( sumL < sumR ) : NEW_LINE INDENT ptrL += 1 NEW_LINE sumL += a [ ptrL ] NEW_LINE DEDENT elif ( sumL > sumR ) : NEW_LINE INDENT ptrR -= 1 NEW_LINE sumR += a [ ptrR ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return ptrL NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 7 , 9 , 8 , 7 ] NEW_LINE n = len ( a ) NEW_LINE print ( getIndex ( a , n ) ) NEW_LINE DEDENT
import math as mt NEW_LINE def getPosition ( a , n , m ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT a [ i ] = ( a [ i ] // m + ( a [ i ] % m != 0 ) ) NEW_LINE DEDENT ans , maxx = - 1 , - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( maxx < a [ i ] ) : NEW_LINE INDENT maxx = a [ i ] NEW_LINE ans = i NEW_LINE DEDENT DEDENT return ans + 1 NEW_LINE DEDENT a = [ 2 , 5 , 4 ] NEW_LINE n = len ( a ) NEW_LINE m = 2 NEW_LINE print ( getPosition ( a , n , m ) ) NEW_LINE
def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = pow ( i - mx , i - mx ) NEW_LINE finalDenominator = ( finalDenominator * denominator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE r = 2 NEW_LINE print ( "1 / " , end = " " ) NEW_LINE print ( calcFunction ( n , r ) ) NEW_LINE DEDENT
def findNum ( div , rem , N ) : NEW_LINE INDENT num = rem [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT num = num * div [ i ] + rem [ i ] NEW_LINE i -= 1 NEW_LINE DEDENT return num NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT div = [ 8 , 3 ] NEW_LINE rem = [ 2 , 2 ] NEW_LINE N = len ( div ) NEW_LINE print ( findNum ( div , rem , N ) ) NEW_LINE DEDENT
def profitLoss ( N , M ) : NEW_LINE INDENT if ( N == M ) : NEW_LINE INDENT print ( " No ▁ Profit ▁ nor ▁ Loss " ) NEW_LINE DEDENT else : NEW_LINE INDENT result = 0.0 NEW_LINE result = float ( abs ( N - M ) ) / M NEW_LINE if ( N - M < 0 ) : NEW_LINE INDENT print ( " Loss ▁ = ▁ - " , ' { 0 : . 6 } ' . format ( result * 100 ) , " % " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Profit ▁ = ▁ " , ' { 0 : . 6 } ' . format ( result * 100 ) , " % " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE M = 9 NEW_LINE profitLoss ( N , M ) NEW_LINE DEDENT
def countPieces ( N ) : NEW_LINE INDENT return 2 * N NEW_LINE DEDENT N = 100 NEW_LINE print ( countPieces ( N ) ) NEW_LINE
def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) ; NEW_LINE return ( n ) * ( 1 + n ) * ( d / 2 ) ; NEW_LINE DEDENT def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 ; NEW_LINE return int ( sumAP ( n , 3 ) + sumAP ( n , 7 ) - sumAP ( n , 21 ) ) ; NEW_LINE DEDENT n = 24 ; NEW_LINE print ( sumMultiples ( n ) ) ; NEW_LINE
def productSumDivisible ( n , size ) : NEW_LINE INDENT sum = 0 NEW_LINE product = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( size % 2 == 0 ) : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT else : NEW_LINE INDENT sum += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE size -= 1 NEW_LINE DEDENT if ( product % sum == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1234 NEW_LINE len = 4 NEW_LINE if ( productSumDivisible ( n , len ) ) : NEW_LINE INDENT print ( " TRUE " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " FALSE " ) NEW_LINE DEDENT DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powGCD ( a , n , b ) : NEW_LINE INDENT for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT a = a * a NEW_LINE DEDENT return gcd ( a , b ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 5 NEW_LINE n = 2 NEW_LINE print ( powGCD ( a , n , b ) ) NEW_LINE DEDENT
def lastCoordinate ( n , a , b ) : NEW_LINE INDENT return ( ( ( n + 1 ) // 2 ) * a - ( n // 2 ) * b ) NEW_LINE DEDENT n = 3 NEW_LINE a = 5 NEW_LINE b = 2 NEW_LINE print ( lastCoordinate ( n , a , b ) ) NEW_LINE
def findNum ( N , K ) : NEW_LINE INDENT rem = ( N + K ) % K ; NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return ( N + K - rem ) NEW_LINE DEDENT DEDENT N = 45 NEW_LINE K = 6 NEW_LINE print ( ' Smallest ▁ number ▁ greater ▁ than ' , ' or ▁ equal ▁ to ' , N , ' that ▁ is ▁ divisible ▁ by ' , K , ' is ' , findNum ( 45 , 6 ) ) NEW_LINE
def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 NEW_LINE product = 1 NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if ( d > 0 and n % d == 0 ) : NEW_LINE INDENT sum += d NEW_LINE product *= d NEW_LINE DEDENT DEDENT print ( " Sum ▁ = " , sum ) NEW_LINE print ( " Product ▁ = " , product ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1012 NEW_LINE countDigit ( n ) NEW_LINE DEDENT
def findNum ( N , K ) : NEW_LINE INDENT rem = N % K NEW_LINE if ( rem == 0 ) : NEW_LINE INDENT return N NEW_LINE DEDENT else : NEW_LINE INDENT return N - rem NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 45 NEW_LINE K = 6 NEW_LINE print ( " Largest ▁ number ▁ smaller ▁ than ▁ or ▁ equal ▁ to " + str ( N ) + " that ▁ is ▁ divisible ▁ by " + str ( K ) + " is " , findNum ( N , K ) ) NEW_LINE DEDENT
def isDivisiblePalindrome ( n ) : NEW_LINE INDENT hash = [ 0 ] * 10 NEW_LINE digitSum = 0 NEW_LINE while ( n ) : NEW_LINE INDENT digitSum += n % 10 NEW_LINE hash [ n % 10 ] += 1 NEW_LINE n //= 10 NEW_LINE DEDENT if ( digitSum % 3 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT oddCount = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( hash [ i ] % 2 != 0 ) : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT DEDENT if ( oddCount > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT n = 34734 NEW_LINE if ( isDivisiblePalindrome ( n ) ) : NEW_LINE INDENT print ( " True " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " False " ) NEW_LINE DEDENT
def productDivisible ( n , k ) : NEW_LINE INDENT product = 1 NEW_LINE position = 1 NEW_LINE while n > 0 : NEW_LINE INDENT if position % 2 == 0 : NEW_LINE INDENT product *= n % 10 NEW_LINE DEDENT n = n / 10 NEW_LINE position += 1 NEW_LINE DEDENT if product % k == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 321922 NEW_LINE k = 3 NEW_LINE if productDivisible ( n , k ) == True : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def npr ( n , r ) : NEW_LINE INDENT pnr = factorial ( n ) / factorial ( n - r ) ; NEW_LINE return pnr ; NEW_LINE DEDENT def countPermutations ( n , r , k ) : NEW_LINE INDENT return int ( factorial ( k ) * ( r - k + 1 ) * npr ( n - k , r - k ) ) ; NEW_LINE DEDENT n = 8 ; NEW_LINE r = 5 ; NEW_LINE k = 2 ; NEW_LINE print ( countPermutations ( n , r , k ) ) ; NEW_LINE
import math NEW_LINE def GIF ( n ) : NEW_LINE INDENT return int ( math . floor ( n ) ) ; NEW_LINE DEDENT n = 2.3 ; NEW_LINE print ( GIF ( n ) ) ; NEW_LINE
def factorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def ncr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) // ( factorial ( r ) * factorial ( n - r ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 3 NEW_LINE n = 4 NEW_LINE k = 5 NEW_LINE totalTriangles = ( ncr ( m + n + k , 3 ) - ncr ( m , 3 ) - ncr ( n , 3 ) - ncr ( k , 3 ) ) NEW_LINE print ( totalTriangles ) NEW_LINE DEDENT
def SumDivisible ( n , k ) : NEW_LINE INDENT sum = 0 NEW_LINE position = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( position % 2 == 1 ) : NEW_LINE INDENT sum += n % 10 NEW_LINE DEDENT n = n // 10 NEW_LINE position += 1 NEW_LINE DEDENT if ( sum % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 592452 NEW_LINE k = 3 NEW_LINE if ( SumDivisible ( n , k ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def isTriangleExists ( a , b , c ) : NEW_LINE INDENT if ( a != 0 and b != 0 and c != 0 and ( a + b + c ) == 180 ) : NEW_LINE INDENT if ( ( a + b ) >= c or ( b + c ) >= a or ( a + c ) >= b ) : NEW_LINE INDENT return " YES " NEW_LINE DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return " NO " NEW_LINE DEDENT DEDENT a , b , c = 50 , 60 , 70 NEW_LINE print ( isTriangleExists ( 50 , 60 , 70 ) ) NEW_LINE
import math NEW_LINE def findX ( n , k ) : NEW_LINE INDENT r = n NEW_LINE m = int ( math . sqrt ( k ) ) + 1 NEW_LINE i = 2 NEW_LINE while i <= m and k > 1 : NEW_LINE INDENT if ( i == m ) : NEW_LINE INDENT i = k NEW_LINE DEDENT u = 0 NEW_LINE v = 0 NEW_LINE while k % i == 0 : NEW_LINE INDENT k //= i NEW_LINE v += 1 NEW_LINE DEDENT if ( v > 0 ) : NEW_LINE INDENT t = n NEW_LINE while ( t > 0 ) : NEW_LINE INDENT t //= i NEW_LINE u += t NEW_LINE DEDENT r = min ( r , u // v ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return r NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findX ( n , k ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def ncr ( n , r ) : NEW_LINE INDENT ncr = fact ( n ) // ( fact ( r ) * fact ( n - r ) ) NEW_LINE return ncr NEW_LINE DEDENT def ways ( m , w , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( m >= k ) : NEW_LINE INDENT ans += ncr ( m , k ) * ncr ( w , n - k ) NEW_LINE k += 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT m = 7 NEW_LINE w = 6 NEW_LINE n = 5 NEW_LINE k = 3 NEW_LINE print ( ways ( m , w , n , k ) ) NEW_LINE
def square ( n ) : NEW_LINE INDENT return n * n ; NEW_LINE DEDENT def sum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( square ( int ( ( n + 1 ) / 2 ) ) + sum ( int ( n / 2 ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( square ( int ( n / 2 ) ) + sum ( int ( n / 2 ) ) ) ; NEW_LINE DEDENT DEDENT def oddDivSum ( a , b ) : NEW_LINE INDENT return sum ( b ) - sum ( a - 1 ) ; NEW_LINE DEDENT a , b = 3 , 9 ; NEW_LINE print ( oddDivSum ( a , b ) ) ; NEW_LINE
def countBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT count += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT n = 32 ; NEW_LINE print ( " Minimum ▁ value ▁ of ▁ K ▁ is ▁ = " , countBits ( n ) ) ; NEW_LINE
from math import sqrt , log NEW_LINE def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT p = int ( sqrt ( n ) ) + 1 NEW_LINE for factor in range ( 3 , p , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n / factor NEW_LINE power += 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT def isPower ( a ) : NEW_LINE INDENT if ( a == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = int ( sqrt ( a ) ) + 1 NEW_LINE for i in range ( 2 , a , 1 ) : NEW_LINE INDENT val = log ( a ) / log ( i ) NEW_LINE if ( ( val - int ( val ) ) < 0.00000001 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isAchillesNumber ( n ) : NEW_LINE INDENT if ( isPowerful ( n ) == True and isPower ( n ) == False ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 72 NEW_LINE if ( isAchillesNumber ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT n = 36 NEW_LINE if ( isAchillesNumber ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = 0 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT divCount += 1 NEW_LINE DEDENT DEDENT if ( divCount % 2 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 1 NEW_LINE b = 10 NEW_LINE print ( OddDivCount ( a , b ) ) NEW_LINE DEDENT
import math NEW_LINE def largestSquareFactor ( num ) : NEW_LINE INDENT answer = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( num ) ) ) : NEW_LINE INDENT cnt = 0 NEW_LINE j = i NEW_LINE while ( num % j == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE j *= i NEW_LINE DEDENT if ( cnt & 1 ) : NEW_LINE INDENT cnt -= 1 NEW_LINE answer *= pow ( i , cnt ) NEW_LINE DEDENT else : NEW_LINE INDENT answer *= pow ( i , cnt ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 420 NEW_LINE print ( largestSquareFactor ( N ) ) NEW_LINE DEDENT
def Nth_Term ( n ) : NEW_LINE INDENT return ( 3 * pow ( n , 2 ) - n + 2 ) // ( 2 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( Nth_Term ( N ) ) NEW_LINE
def countPermutations ( N , B ) : NEW_LINE INDENT x = B ** N NEW_LINE y = B ** ( N - 1 ) NEW_LINE print ( x - y ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , B = 6 , 4 NEW_LINE countPermutations ( N , B ) NEW_LINE DEDENT
def calculateDifference ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = ( max_val + 1 ) * [ True ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT P1 = 1 ; P2 = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT P1 *= arr [ i ] NEW_LINE DEDENT elif arr [ i ] != 1 : NEW_LINE INDENT P2 *= arr [ i ] NEW_LINE DEDENT DEDENT return abs ( P2 - P1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 10 , 15 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( calculateDifference ( arr , n ) ) NEW_LINE DEDENT
def EqualNumbers ( a , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] ; NEW_LINE DEDENT if ( sum % n ) : NEW_LINE INDENT return n - 1 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT a = [ 1 , 4 , 1 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( EqualNumbers ( a , n ) ) ; NEW_LINE
def count_odd_pair ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT even = even + 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT ans = odd * even * 2 NEW_LINE return ans NEW_LINE DEDENT def count_even_pair ( odd_sum_pairs , n ) : NEW_LINE INDENT total_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_pairs - odd_sum_pairs NEW_LINE return ans NEW_LINE DEDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_sum_pairs = count_odd_pair ( n , a ) NEW_LINE even_sum_pairs = count_even_pair ( odd_sum_pairs , n ) NEW_LINE print ( " Even ▁ Sum ▁ Pairs ▁ = " , even_sum_pairs ) NEW_LINE print ( " Odd ▁ Sum ▁ Pairs = " , odd_sum_pairs ) NEW_LINE
def findSteps ( n , m , a ) : NEW_LINE INDENT cur = 1 NEW_LINE steps = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT if ( a [ i ] >= cur ) : NEW_LINE INDENT steps += ( a [ i ] - cur ) NEW_LINE DEDENT else : NEW_LINE INDENT steps += ( n - cur + a [ i ] ) NEW_LINE DEDENT cur = a [ i ] NEW_LINE DEDENT return steps NEW_LINE DEDENT n = 3 NEW_LINE m = 3 NEW_LINE a = [ 2 , 1 , 2 ] NEW_LINE print ( findSteps ( n , m , a ) ) NEW_LINE
def HexToBin ( hexdec ) : NEW_LINE INDENT for i in hexdec : NEW_LINE INDENT if i == '0' : NEW_LINE INDENT print ( '0000' , end = ' ' ) NEW_LINE DEDENT elif i == '1' : NEW_LINE INDENT print ( '0001' , end = ' ' ) NEW_LINE DEDENT elif i == '2' : NEW_LINE INDENT print ( '0010' , end = ' ' ) NEW_LINE DEDENT elif i == '3' : NEW_LINE INDENT print ( '0011' , end = ' ' ) NEW_LINE DEDENT elif i == '4' : NEW_LINE INDENT print ( '0100' , end = ' ' ) NEW_LINE DEDENT elif i == '5' : NEW_LINE INDENT print ( '0101' , end = ' ' ) NEW_LINE DEDENT elif i == '6' : NEW_LINE INDENT print ( '0110' , end = ' ' ) NEW_LINE DEDENT elif i == '7' : NEW_LINE INDENT print ( '0111' , end = ' ' ) NEW_LINE DEDENT elif i == '8' : NEW_LINE INDENT print ( '1000' , end = ' ' ) NEW_LINE DEDENT elif i == '9' : NEW_LINE INDENT print ( '1001' , end = ' ' ) NEW_LINE DEDENT elif i == ' A ' or i == ' a ' : NEW_LINE INDENT print ( '1010' , end = ' ' ) NEW_LINE DEDENT elif i == ' B ' or i == ' b ' : NEW_LINE INDENT print ( '1011' , end = ' ' ) NEW_LINE DEDENT elif i == ' C ' or i == ' c ' : NEW_LINE INDENT print ( '1100' , end = ' ' ) NEW_LINE DEDENT elif i == ' D ' or i == ' d ' : NEW_LINE INDENT print ( '1101' , end = ' ' ) NEW_LINE DEDENT elif i == ' E ' or i == ' e ' : NEW_LINE INDENT print ( '1110' , end = ' ' ) NEW_LINE DEDENT elif i == ' F ' or i == ' f ' : NEW_LINE INDENT print ( '1111' , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Invalid hexadecimal digit   " + str ( hexdec [ i ] ) , end = ' ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT hexdec = "1AC5" ; NEW_LINE print ( " Equivalent ▁ Binary ▁ value ▁ is ▁ : ▁ " , end = ' ' ) NEW_LINE HexToBin ( hexdec ) NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT def Count_pairs ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if isPowerOfTwo ( a [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = ( count * ( count - 1 ) ) / 2 NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 2 , 5 , 8 , 16 , 128 ] NEW_LINE n = len ( a ) NEW_LINE Count_pairs ( a , n ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result *= i NEW_LINE DEDENT return result NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) // ( factorial ( r ) * factorial ( n - r ) ) ) NEW_LINE DEDENT def calculate_result ( n ) : NEW_LINE INDENT result = 2 * nCr ( ( n - 2 ) , ( n // 2 - 1 ) ) NEW_LINE return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b = 2 , 4 NEW_LINE print ( calculate_result ( 2 * a ) ) NEW_LINE print ( calculate_result ( 2 * b ) ) NEW_LINE DEDENT
def PossibleValues ( b , x , n ) : NEW_LINE INDENT leastdivisible = int ( b / x + 1 ) * x NEW_LINE flag = 1 NEW_LINE while ( leastdivisible <= n ) : NEW_LINE INDENT if ( leastdivisible - b >= 1 ) : NEW_LINE INDENT print ( leastdivisible - b , end = " ▁ " ) NEW_LINE leastdivisible += x NEW_LINE flag = 0 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( flag != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT b = 10 NEW_LINE x = 6 NEW_LINE n = 40 NEW_LINE PossibleValues ( b , x , n ) NEW_LINE DEDENT
def digitProduct ( digits , start , end ) : NEW_LINE INDENT pro = 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT pro *= digits [ i ] NEW_LINE DEDENT return pro NEW_LINE DEDENT def isDistinct ( N ) : NEW_LINE INDENT s = str ( N ) NEW_LINE length = len ( s ) NEW_LINE digits = [ None ] * length NEW_LINE products = set ( ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT digits [ i ] = int ( s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , length ) : NEW_LINE INDENT for j in range ( i , length ) : NEW_LINE INDENT val = digitProduct ( digits , i , j ) NEW_LINE if val in products : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT products . add ( val ) NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 324 NEW_LINE if isDistinct ( N ) == True : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def nthHilbertNumber ( n ) : NEW_LINE INDENT return 4 * ( n - 1 ) + 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( nthHilbertNumber ( n ) ) NEW_LINE
def nthKyneaNumber ( n ) : NEW_LINE INDENT n = ( 1 << n ) + 1 NEW_LINE n = n * n NEW_LINE n = n - 2 NEW_LINE return n NEW_LINE DEDENT n = 2 NEW_LINE print ( nthKyneaNumber ( n ) ) NEW_LINE
def nthKyneaNumber ( n ) : NEW_LINE INDENT return ( ( 1 << ( 2 * n ) ) + ( 1 << ( n + 1 ) ) - 1 ) NEW_LINE DEDENT n = 2 NEW_LINE print ( nthKyneaNumber ( n ) ) NEW_LINE
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def isProthNumber ( n ) : NEW_LINE INDENT k = 1 NEW_LINE while ( k < ( n // k ) ) : NEW_LINE INDENT if ( n % k == 0 ) : NEW_LINE INDENT if ( isPowerOfTwo ( n // k ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = k + 2 NEW_LINE DEDENT return False NEW_LINE int n = 25 ; NEW_LINE DEDENT if ( isProthNumber ( n - 1 ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def get_last_two_digit ( N ) : NEW_LINE INDENT if N <= 10 : NEW_LINE INDENT ans = 0 NEW_LINE fac = 1 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fac = fac * i NEW_LINE ans += fac NEW_LINE DEDENT ans = ans % 100 NEW_LINE return ans NEW_LINE DEDENT else : NEW_LINE INDENT return 13 NEW_LINE DEDENT DEDENT N = 1 NEW_LINE for N in range ( 1 , 11 ) : NEW_LINE INDENT print ( " For ▁ N ▁ = ▁ " , N , " : ▁ " , get_last_two_digit ( N ) , sep = ' ▁ ' ) NEW_LINE DEDENT
def isProductEven ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ i ] & 1 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isProductEven ( arr , n ) ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT
def calculateSquareSum ( n ) : NEW_LINE INDENT fibo = [ 0 ] * ( n + 1 ) ; NEW_LINE if ( n <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT fibo [ 0 ] = 0 ; NEW_LINE fibo [ 1 ] = 1 ; NEW_LINE sum = ( ( fibo [ 0 ] * fibo [ 0 ] ) + ( fibo [ 1 ] * fibo [ 1 ] ) ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = ( fibo [ i - 1 ] + fibo [ i - 2 ] ) ; NEW_LINE sum += ( fibo [ i ] * fibo [ i ] ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( " Sum ▁ of ▁ squares ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : " , calculateSquareSum ( n ) ) ; NEW_LINE
def fnMod ( n ) : NEW_LINE INDENT rem = n % 4 NEW_LINE if ( rem == 0 or rem == 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( rem == 1 or rem == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( fnMod ( n ) ) NEW_LINE DEDENT
def MinimumMoves ( a , n , x ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if a [ i ] <= a [ i - 1 ] : NEW_LINE INDENT p = ( a [ i - 1 ] - a [ i ] ) // x + 1 NEW_LINE ans += p NEW_LINE a [ i ] += p * x NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 3 , 3 , 2 ] NEW_LINE x = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( MinimumMoves ( arr , n , x ) ) NEW_LINE DEDENT
def SumOfDigits ( str , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += int ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def Divisible ( str , n ) : NEW_LINE INDENT if ( ( SumOfDigits ( str , n ) % 3 == 0 and str [ n - 1 ] == '0' ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = "263730746028908374890" NEW_LINE n = len ( str ) NEW_LINE if ( Divisible ( str , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def isPrime ( k ) : NEW_LINE INDENT if ( k <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , k ) : NEW_LINE INDENT if ( k % i == 0 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def check ( num , k ) : NEW_LINE INDENT flag = 1 NEW_LINE for i in range ( 2 , k ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT if ( num % k == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def findCount ( a , b , k ) : NEW_LINE INDENT count = 0 NEW_LINE if ( not isPrime ( k ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT ans = check ( i , k ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT continue NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2020 NEW_LINE b = 6300 NEW_LINE k = 29 NEW_LINE print ( findCount ( a , b , k ) ) NEW_LINE DEDENT
def NumberOfSolutions ( a , b , c , d ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if d >= max ( c , i + 1 ) : NEW_LINE INDENT ans += d - max ( c , i + 1 ) + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c , d = 2 , 3 , 3 , 4 NEW_LINE print ( NumberOfSolutions ( a , b , c , d ) ) NEW_LINE DEDENT
def findF_N ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = ans + ( i + 1 ) * ( n - i - 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 3 NEW_LINE print ( findF_N ( n ) ) NEW_LINE
def findNumber ( n , d ) : NEW_LINE INDENT ans = " " NEW_LINE if ( d != 10 ) : NEW_LINE INDENT ans += str ( d ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += '0' NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT ans += " Impossible " NEW_LINE DEDENT else : NEW_LINE INDENT ans += '1' NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += '0' NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE d = 3 NEW_LINE print ( findNumber ( n , d ) ) NEW_LINE DEDENT
MAX = 1000000 NEW_LINE sieve_Prime = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE sieve_count = [ 0 for i in range ( MAX + 4 ) ] NEW_LINE def form_sieve ( ) : NEW_LINE INDENT sieve_Prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if sieve_Prime [ i ] == 0 : NEW_LINE INDENT for j in range ( i * 2 , MAX + 1 , i ) : NEW_LINE INDENT if sieve_Prime [ j ] == 0 : NEW_LINE INDENT sieve_Prime [ j ] = 1 NEW_LINE sieve_count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT form_sieve ( ) NEW_LINE n = 2 NEW_LINE print ( " Count ▁ = " , sieve_count [ n ] + 1 ) NEW_LINE n = 3 NEW_LINE print ( " Count ▁ = " , sieve_count [ n ] + 1 ) NEW_LINE
def PrimeFactors ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE x = n NEW_LINE i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT v . append ( i ) NEW_LINE while ( x % i == 0 ) : NEW_LINE INDENT x //= i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT if ( x > 1 ) : NEW_LINE INDENT v . append ( x ) NEW_LINE DEDENT return v NEW_LINE DEDENT def GoodNumber ( n ) : NEW_LINE INDENT v = PrimeFactors ( n ) NEW_LINE ans = 1 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT ans *= v [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE print ( GoodNumber ( n ) ) NEW_LINE DEDENT
def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( not sieve [ num ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT num //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True ] * ( N + 10 ) NEW_LINE sieve [ 0 ] = sieve [ 1 ] = False ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT N -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT findSpecialPrime ( 379 ) NEW_LINE findSpecialPrime ( 100 ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 13 NEW_LINE if ( isPrime ( n ) and ( n % 4 == 1 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def heightCalculate ( H , n , m ) : NEW_LINE INDENT N = n * 1.0 NEW_LINE M = m * 1.0 NEW_LINE h = H * sqrt ( N / ( N + M ) ) NEW_LINE return h NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT H = 10 NEW_LINE n = 3 NEW_LINE m = 4 NEW_LINE print ( " { 0 : . 6 } " . format ( heightCalculate ( H , n , m ) ) ) ; NEW_LINE DEDENT
def isprime ( x ) : NEW_LINE INDENT for i in range ( 2 , math . sqrt ( x ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def isNSqMinusnMSqPrime ( m , n ) : NEW_LINE INDENT if ( n - m == 1 and isprime ( m + n ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT m = 13 ; NEW_LINE n = 16 ; NEW_LINE if ( isNSqMinusnMSqPrime ( m , n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def findsolution ( n , x , y ) : NEW_LINE INDENT if ( ( y - n + 1 ) * ( y - n + 1 ) + n - 1 < x or y < n ) : NEW_LINE INDENT print ( " No ▁ solution " ) ; NEW_LINE return ; NEW_LINE DEDENT print ( y - n + 1 ) ; NEW_LINE while ( n > 1 ) : NEW_LINE INDENT print ( 1 ) ; NEW_LINE n -= 1 ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE x = 15 ; NEW_LINE y = 15 ; NEW_LINE findsolution ( n , x , y ) ; NEW_LINE
def findPosition ( n , f , b ) : NEW_LINE INDENT return n - max ( f + 1 , n - b ) + 1 ; NEW_LINE DEDENT n , f , b = 5 , 2 , 3 NEW_LINE print ( findPosition ( n , f , b ) ) NEW_LINE
def nthOdd ( n ) : NEW_LINE INDENT return ( 2 * n - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( nthOdd ( n ) ) NEW_LINE DEDENT
def nthEven ( n ) : NEW_LINE INDENT return ( 2 * n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( nthEven ( n ) ) NEW_LINE DEDENT
def nthHarmonic ( N ) : NEW_LINE INDENT harmonic = 1.00 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT harmonic += 1 / i NEW_LINE DEDENT return harmonic NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 8 NEW_LINE print ( round ( nthHarmonic ( N ) , 5 ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + n - 3 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 5 * pow ( n , 2 ) - 5 * n NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + n - 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 4 * n - 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + 2 * n - 5 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) + 3 * n - 5 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 3 * n + 2 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
import math NEW_LINE PI = 3.1415926535 NEW_LINE def findAnglesA ( a , b , c ) : NEW_LINE INDENT A = math . acos ( ( b * b + c * c - a * a ) / ( 2 * b * c ) ) NEW_LINE return A * 180 / PI NEW_LINE DEDENT def findAnglesB ( a , b , c ) : NEW_LINE INDENT B = math . acos ( ( a * a + c * c - b * b ) / ( 2 * a * c ) ) NEW_LINE return B * 180 / PI NEW_LINE DEDENT def printAngles ( a , b , c ) : NEW_LINE INDENT x = a NEW_LINE y = b NEW_LINE z = c NEW_LINE A = findAnglesA ( x , y , z ) NEW_LINE B = findAnglesB ( x , y , z ) NEW_LINE print ( " Angles ▁ are ▁ A ▁ = ▁ " , A , " , ▁ B ▁ = ▁ " , B , " , ▁ C ▁ = ▁ " , "90 ▁ " ) NEW_LINE DEDENT def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) // 2 NEW_LINE c = ( n * n + 1 ) // 2 NEW_LINE print ( " Side ▁ b ▁ = ▁ " , b , " ▁ Side ▁ c ▁ = ▁ " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n // 4 - 1 ; NEW_LINE c = n * n // 4 + 1 ; NEW_LINE print ( " Side ▁ b ▁ = ▁ " , b , " , ▁ Side ▁ c ▁ = ▁ " , c ) NEW_LINE DEDENT DEDENT printAngles ( n , b , c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 12 NEW_LINE printOtherSides ( a ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) // 2 + n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( " Sum ▁ = ▁ " , calculateSum ( n ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return 2 * pow ( n , 2 ) - n - 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 4 * pow ( n , 2 ) - 7 * n + 3 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def checkIfPowerIsolated ( num ) : NEW_LINE INDENT input1 = num ; NEW_LINE count = 0 ; NEW_LINE factor = [ 0 ] * ( num + 1 ) ; NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= 2 ; NEW_LINE DEDENT factor [ 2 ] = count ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( num % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= i ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor [ i ] = count ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = 1 ; NEW_LINE DEDENT product = 1 ; NEW_LINE for i in range ( 0 , len ( factor ) ) : NEW_LINE INDENT if ( factor [ i ] > 0 ) : NEW_LINE INDENT product = product * factor [ i ] * i ; NEW_LINE DEDENT DEDENT if ( product == input1 ) : NEW_LINE INDENT print ( " Power - isolated ▁ Integer " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Power - isolated ▁ Integer " ) ; NEW_LINE DEDENT DEDENT checkIfPowerIsolated ( 12 ) ; NEW_LINE checkIfPowerIsolated ( 18 ) ; NEW_LINE checkIfPowerIsolated ( 35 ) ; NEW_LINE
def getNthTerm ( N ) : NEW_LINE INDENT return ( pow ( N , 2 ) + N + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 NEW_LINE print ( getNthTerm ( N ) ) NEW_LINE DEDENT
def findSum ( n ) : NEW_LINE INDENT sum2 = ( ( n // 2 ) * ( 4 + ( n // 2 - 1 ) * 2 ) ) // 2 NEW_LINE sum5 = ( ( n // 5 ) * ( 10 + ( n // 5 - 1 ) * 5 ) ) // 2 NEW_LINE sum10 = ( ( n // 10 ) * ( 20 + ( n // 10 - 1 ) * 10 ) ) // 2 NEW_LINE return sum2 + sum5 - sum10 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE DEDENT
def CalculateRatio ( m , n ) : NEW_LINE INDENT return ( 2 * m - 1 ) / ( 2 * n - 1 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 6 ; NEW_LINE n = 2 ; NEW_LINE print ( float ( CalculateRatio ( m , n ) ) ) ; NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) ** 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( calculateSum ( n ) ) NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 9 == 0 : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return n % 9 NEW_LINE DEDENT DEDENT def powerDigitSum ( a , n ) : NEW_LINE INDENT res = 1 NEW_LINE while ( n ) : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT res = res * digSum ( a ) NEW_LINE res = digSum ( res ) NEW_LINE DEDENT a = digSum ( digSum ( a ) * digSum ( a ) ) NEW_LINE n //= 2 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , n = 9 , 4 NEW_LINE print ( powerDigitSum ( a , n ) ) NEW_LINE DEDENT
def totEdge ( n ) : NEW_LINE INDENT result = ( n * ( n - 1 ) ) // 2 NEW_LINE return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE print ( totEdge ( n ) ) NEW_LINE DEDENT
def coin ( totalRupees , X , Y , Z ) : NEW_LINE INDENT one = X * 1 NEW_LINE fifty = ( ( Y * 1 ) / 2.0 ) NEW_LINE twentyfive = ( ( Z * 1 ) / 4.0 ) NEW_LINE total = one + fifty + twentyfive NEW_LINE result = ( ( totalRupees ) / total ) NEW_LINE return int ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT totalRupees = 1800 NEW_LINE X , Y , Z = 1 , 2 , 4 NEW_LINE Rupees = coin ( totalRupees , X , Y , Z ) NEW_LINE print ( "1 ▁ rupess ▁ coins ▁ = ▁ " , Rupees * 1 ) NEW_LINE print ( "50 ▁ paisa ▁ coins ▁ = ▁ " , Rupees * 2 ) NEW_LINE print ( "25 ▁ paisa ▁ coins ▁ = ▁ " , Rupees * 4 ) NEW_LINE DEDENT
def sumOfSeries ( x , k ) : NEW_LINE INDENT return ( float ( x ) / 81 ) * ( 9 * k - 1 + 10 ** ( ( - 1 ) * k ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 9 NEW_LINE k = 20 NEW_LINE print ( sumOfSeries ( x , k ) ) NEW_LINE DEDENT
def modExp ( a , b ) : NEW_LINE INDENT result = 1 NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( int ( b ) & 1 ) : NEW_LINE INDENT result = result * a NEW_LINE DEDENT a = a * a NEW_LINE b /= 2 NEW_LINE DEDENT return result NEW_LINE DEDENT def check ( num ) : NEW_LINE INDENT if ( num & 1 or num < 3 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( num % 4 == 0 ) : NEW_LINE INDENT return modExp ( num / 4 , 4 ) NEW_LINE DEDENT elif ( num % 6 == 0 ) : NEW_LINE INDENT return modExp ( num / 3 , 2 ) * modExp ( num / 6 , 2 ) NEW_LINE DEDENT elif ( num % 10 == 0 ) : NEW_LINE INDENT return modExp ( num / 5 , 2 ) * ( num / 10 ) * ( num / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 10 NEW_LINE print ( int ( check ( num ) ) ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n -= d * 5 NEW_LINE DEDENT return ( n % 17 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 19877658 NEW_LINE if isDivisible ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n and not ( n and ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while n != 0 : NEW_LINE INDENT n >>= 1 NEW_LINE count += 1 NEW_LINE DEDENT return 1 << count NEW_LINE DEDENT def removeElement ( n ) : NEW_LINE INDENT if n == 1 or n == 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = nextPowerOf2 ( n ) NEW_LINE if n == a or n == a - 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n == a - 2 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE print ( removeElement ( n ) ) NEW_LINE DEDENT
def bridge_length ( trainLength , Speed , Time ) : NEW_LINE INDENT return ( ( Time * Speed ) - trainLength ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT trainLength = 120 NEW_LINE Speed = 30 NEW_LINE Time = 18 NEW_LINE print ( " Length ▁ of ▁ bridge ▁ = ▁ " , bridge_length ( trainLength , Speed , Time ) , " meters " ) NEW_LINE DEDENT
MOD = 1000000007 ; NEW_LINE def modInv ( x ) : NEW_LINE INDENT n = MOD - 2 ; NEW_LINE result = 1 ; NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT result = result * x % MOD ; NEW_LINE DEDENT x = x * x % MOD ; NEW_LINE n = int ( n / 2 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def getSum ( n , k ) : NEW_LINE INDENT ans = 1 ; NEW_LINE for i in range ( n + 1 , n - k , - 1 ) : NEW_LINE INDENT ans = ans * i % MOD ; NEW_LINE DEDENT ans = ans * modInv ( k + 1 ) % MOD ; NEW_LINE return ans ; NEW_LINE DEDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE print ( getSum ( n , k ) ) ; NEW_LINE
def printCombination ( n ) : NEW_LINE INDENT print ( "1 ▁ " , end = " " ) ; NEW_LINE if ( ( n - 2 ) % 3 == 0 ) : NEW_LINE INDENT print ( "2" , n - 3 , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "1" , ( n - 2 ) , end = " " ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 233 ; NEW_LINE printCombination ( n ) ; NEW_LINE DEDENT
def checkPairs ( l , r ) : NEW_LINE INDENT if ( l - r ) % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r = 1 , 8 NEW_LINE if checkPairs ( l , r ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def isPalindrome ( n ) : NEW_LINE INDENT if n % 11 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 123321 NEW_LINE if isPalindrome ( n ) : NEW_LINE INDENT print ( " Palindrome " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Palindrome " ) NEW_LINE DEDENT DEDENT
target = 93 NEW_LINE arr = [ 1 , 31 , 3 , 1 , 93 , 3 , 31 , 1 , 93 ] NEW_LINE length = len ( arr ) NEW_LINE totalCount = 0 NEW_LINE for i in range ( length - 2 ) : NEW_LINE INDENT if target % arr [ i ] == 0 : NEW_LINE INDENT for j in range ( i + 1 , length - 1 ) : NEW_LINE INDENT if target % ( arr [ i ] * arr [ j ] ) == 0 : NEW_LINE INDENT toFind = target // ( arr [ i ] * arr [ j ] ) NEW_LINE for k in range ( j + 1 , length ) : NEW_LINE INDENT if arr [ k ] == toFind : NEW_LINE INDENT totalCount += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT print ( ' Total ▁ number ▁ of ▁ triplets ▁ found : ▁ ' , totalCount ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if k > n - k : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res // ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) NEW_LINE return c // ( n + 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( catalan ( n ) ) NEW_LINE
def isFascinating ( num ) : NEW_LINE INDENT freq = [ 0 ] * 10 NEW_LINE val = ( str ( num ) + str ( num * 2 ) + str ( num * 3 ) ) NEW_LINE for i in range ( len ( val ) ) : NEW_LINE INDENT digit = int ( val [ i ] ) NEW_LINE if freq [ digit ] and digit != 0 > 0 : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT freq [ digit ] += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if freq [ i ] == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT num = 192 NEW_LINE if num < 100 : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = isFascinating ( num ) NEW_LINE if ans : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT DEDENT
def binomial_coefficient ( n , m ) : NEW_LINE INDENT res = 1 NEW_LINE if m > n - m : NEW_LINE INDENT m = n - m NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT res *= ( n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT def calculate_ways ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT ways = binomial_coefficient ( n + m - 1 , n - 1 ) NEW_LINE return int ( ways ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 7 ; n = 5 NEW_LINE result = calculate_ways ( m , n ) NEW_LINE print ( result ) NEW_LINE DEDENT
N = 100005 NEW_LINE phi = [ 0 ] * N NEW_LINE S = [ 0 ] * N NEW_LINE def computeTotient ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , N ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def CoPrimes ( ) : NEW_LINE INDENT computeTotient ( ) NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT S [ i ] = S [ i - 1 ] + phi [ i ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT CoPrimes ( ) NEW_LINE q = [ 3 , 4 ] NEW_LINE n = len ( q ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( " Number of unordered coprime " ▁ + ▁ " pairs of integers from 1 to " , ▁ q [ i ] , ▁ " are   " , S [ q [ i ] ] ) NEW_LINE DEDENT DEDENT
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n NEW_LINE dec_value = 0 NEW_LINE base = 1 NEW_LINE l = len ( num ) NEW_LINE for i in range ( l - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( num [ i ] == '1' ) : NEW_LINE INDENT dec_value += base NEW_LINE DEDENT base = base * 2 NEW_LINE DEDENT return dec_value NEW_LINE DEDENT def numberSequence ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT s = " " NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += '1' NEW_LINE DEDENT s += '0' NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s += '1' NEW_LINE DEDENT num = binaryToDecimal ( s ) NEW_LINE return num NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( numberSequence ( n ) ) NEW_LINE DEDENT
def numberSequence ( n ) : NEW_LINE INDENT num = pow ( 4 , n ) - pow ( 2 , n ) - 1 NEW_LINE return num NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( numberSequence ( n ) ) NEW_LINE DEDENT
def prime ( num ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( 2 , num // 2 + 1 ) : NEW_LINE INDENT if num % i == 0 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def print_alternate_prime ( n ) : NEW_LINE INDENT counter = 0 NEW_LINE for num in range ( 2 , n ) : NEW_LINE INDENT if prime ( num ) == 1 : NEW_LINE INDENT if counter % 2 == 0 : NEW_LINE INDENT print ( num , end = " ▁ " ) NEW_LINE DEDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( " Following ▁ are ▁ the ▁ alternate ▁ prime " + " number ▁ smaller ▁ than ▁ or ▁ equal ▁ to " , n ) NEW_LINE print_alternate_prime ( n ) NEW_LINE DEDENT
def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime = [ None ] * ( n + 1 ) NEW_LINE for i in range ( len ( prime ) ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT flag = True NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT print ( str ( p ) , end = " ▁ " ) NEW_LINE flag = False NEW_LINE DEDENT else : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE print ( " Following ▁ are ▁ the ▁ alternate " + " ▁ prime ▁ numbers ▁ smaller ▁ " + " than ▁ or ▁ equal ▁ to ▁ " + str ( n ) ) NEW_LINE SieveOfEratosthenes ( n ) NEW_LINE DEDENT
def findGreater ( x , y ) : NEW_LINE INDENT if ( x > y ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT x = 4 ; NEW_LINE y = 9 ; NEW_LINE if ( findGreater ( x , y ) ) : NEW_LINE INDENT print ( "1" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "2" ) ; NEW_LINE DEDENT
def max_profit ( a , b , n , fee ) : NEW_LINE INDENT i , j , profit = 1 , n - 1 , 0 NEW_LINE l , r , diff_day = 0 , 0 , 1 NEW_LINE b [ 0 ] = 0 NEW_LINE b [ 1 ] = diff_day NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT l = 0 NEW_LINE r = diff_day NEW_LINE Sum = 0 NEW_LINE for j in range ( n - 1 , i - 1 , - 1 ) : NEW_LINE INDENT profit = ( a [ r ] - a [ l ] ) - fee NEW_LINE if ( profit > 0 ) : NEW_LINE INDENT Sum = Sum + profit NEW_LINE DEDENT l += 1 NEW_LINE r += 1 NEW_LINE DEDENT if ( b [ 0 ] < Sum ) : NEW_LINE INDENT b [ 0 ] = Sum NEW_LINE b [ 1 ] = diff_day NEW_LINE DEDENT DEDENT diff_day += 1 NEW_LINE return 0 NEW_LINE DEDENT arr = [ 6 , 1 , 7 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE b = [ 0 for i in range ( 2 ) ] NEW_LINE tranFee = 2 NEW_LINE max_profit ( arr , b , n , tranFee ) NEW_LINE print ( b [ 0 ] , " , " , b [ 1 ] ) NEW_LINE
def binomialCoeff ( x , n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE term = 1 ; NEW_LINE i = 1 ; NEW_LINE while ( i <= n and sum < k ) : NEW_LINE INDENT term *= x - i + 1 ; NEW_LINE term /= i ; NEW_LINE sum += term ; NEW_LINE i += 1 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def minTrials ( n , k ) : NEW_LINE INDENT low = 1 ; NEW_LINE high = k ; NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) ; NEW_LINE if ( binomialCoeff ( mid , n , k ) < k ) : NEW_LINE INDENT low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid ; NEW_LINE DEDENT DEDENT return int ( low ) ; NEW_LINE DEDENT print ( minTrials ( 2 , 10 ) ) ; NEW_LINE
import math as mt NEW_LINE def isPrime ( num ) : NEW_LINE INDENT if ( num < 2 or num % 2 == 0 ) : NEW_LINE INDENT return num == 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( num + 1 ) ) ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def primePalindrome ( N ) : NEW_LINE INDENT if ( 8 <= N and N <= 11 ) : NEW_LINE INDENT return 11 NEW_LINE DEDENT for x in range ( 1 , 100000 ) : NEW_LINE INDENT s = str ( x ) NEW_LINE d = s [ : : - 1 ] NEW_LINE y = int ( s + d [ 1 : ] ) NEW_LINE if ( y >= N and isPrime ( y ) ) : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT DEDENT print ( primePalindrome ( 112 ) ) NEW_LINE
def getsum ( a ) : NEW_LINE INDENT r = 0 NEW_LINE sum = 0 NEW_LINE while ( a > 0 ) : NEW_LINE INDENT r = a % 10 NEW_LINE sum = sum + r NEW_LINE a = a // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def value ( a , b , c ) : NEW_LINE INDENT x = 0 NEW_LINE q = 0 NEW_LINE w = 0 NEW_LINE v = [ ] NEW_LINE for i in range ( 1 , 82 ) : NEW_LINE INDENT no = pow ( i , a ) NEW_LINE no = b * no + c NEW_LINE if ( no > 0 and no < 1000000000 ) : NEW_LINE INDENT x = getsum ( no ) NEW_LINE if ( x == i ) : NEW_LINE INDENT q += 1 NEW_LINE v . append ( no ) NEW_LINE w += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 2 NEW_LINE c = - 1 NEW_LINE value ( a , b , c ) NEW_LINE DEDENT
def print_t ( p0 ) : NEW_LINE INDENT i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT flag = 1 ; NEW_LINE x = pow ( 2 , i ) ; NEW_LINE p1 = x * p0 - ( x - 1 ) ; NEW_LINE for k in range ( 2 , p1 ) : NEW_LINE INDENT if ( p1 % k == 0 ) : NEW_LINE INDENT flag = 0 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT print ( p1 , end = " ▁ " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT p0 = 19 ; NEW_LINE print_t ( p0 ) ; NEW_LINE
def findOddPair ( A , N ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT if ( ( A [ i ] % 2 == 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT return count * ( count - 1 ) / 2 NEW_LINE DEDENT a = [ 5 , 1 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( int ( findOddPair ( a , n ) ) ) NEW_LINE
def isSurd ( n ) : NEW_LINE INDENT i = 2 NEW_LINE for i in range ( 2 , ( i * i ) + 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n ) : NEW_LINE INDENT j = j * i NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 15 NEW_LINE if ( isSurd ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def LastTwoDigit ( num ) : NEW_LINE INDENT one = num % 10 NEW_LINE num //= 10 NEW_LINE tens = num % 10 NEW_LINE tens *= 10 NEW_LINE num = tens + one NEW_LINE return num NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE num = 1 NEW_LINE num = pow ( 2 , n ) ; NEW_LINE print ( " Last ▁ " + str ( 2 ) + " ▁ digits ▁ of ▁ " + str ( 2 ) + " ^ " + str ( n ) + " ▁ = ▁ " , end = " " ) NEW_LINE print ( LastTwoDigit ( num ) ) NEW_LINE DEDENT
def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def numberOfDigits ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x //= 10 NEW_LINE i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT def LastTwoDigit ( n ) : NEW_LINE INDENT print ( " Last ▁ " + str ( 2 ) + " ▁ digits ▁ of ▁ " + str ( 2 ) , end = " " ) NEW_LINE print ( " ^ " + str ( n ) + " ▁ = ▁ " , end = " " ) NEW_LINE temp = 1 NEW_LINE for i in range ( 1 , 3 ) : NEW_LINE INDENT temp *= 10 NEW_LINE DEDENT temp = power ( 2 , n , temp ) NEW_LINE for i in range ( 2 - numberOfDigits ( temp ) ) : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE DEDENT if temp : NEW_LINE INDENT print ( temp ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 72 NEW_LINE LastTwoDigit ( n ) NEW_LINE DEDENT
def modPower ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def gcdPow ( a , n , c ) : NEW_LINE INDENT if ( a % c == 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT modexpo = modPower ( a , n , c ) NEW_LINE return gcd ( modexpo , c ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 10248585 NEW_LINE n = 1000000 NEW_LINE c = 12564 NEW_LINE print ( gcdPow ( a , n , c ) ) NEW_LINE DEDENT
def countOddSum ( ar , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT val = val + ar [ j ] NEW_LINE if ( val % 2 != 0 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT ar = [ 5 , 4 , 4 , 5 , 1 , 3 ] NEW_LINE print ( " The ▁ Number ▁ of ▁ Subarrays " , " with ▁ odd " , end = " " ) NEW_LINE print ( " ▁ sum ▁ is ▁ " + str ( countOddSum ( ar , 6 ) ) ) NEW_LINE
def countOddSum ( ar , n ) : NEW_LINE INDENT temp = [ 1 , 0 ] NEW_LINE result = 0 NEW_LINE val = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = ( ( val + ar [ i ] ) % 2 + 2 ) % 2 NEW_LINE temp [ val ] += 1 NEW_LINE DEDENT result = ( temp [ 0 ] * temp [ 1 ] ) NEW_LINE return ( result ) NEW_LINE DEDENT ar = [ 5 , 4 , 4 , 5 , 1 , 3 ] NEW_LINE print ( " The ▁ Number ▁ of ▁ Subarrays " " ▁ with ▁ odd ▁ sum ▁ is ▁ " + str ( countOddSum ( ar , 6 ) ) ) NEW_LINE
def printPFsInPairs ( n ) : NEW_LINE INDENT for i in range ( 1 , int ( pow ( n , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT print ( str ( i ) + " * " + str ( int ( n / i ) ) ) NEW_LINE DEDENT DEDENT DEDENT n = 24 NEW_LINE printPFsInPairs ( n ) NEW_LINE
def rangesum ( n , l , r ) : NEW_LINE INDENT arr = [ 0 ] * n ; NEW_LINE c = 1 ; i = 0 ; NEW_LINE while ( c <= n ) : NEW_LINE INDENT arr [ i ] = c ; NEW_LINE i += 1 ; NEW_LINE c += 2 ; NEW_LINE DEDENT c = 2 ; NEW_LINE while ( c <= n ) : NEW_LINE INDENT arr [ i ] = c ; NEW_LINE i += 1 ; NEW_LINE c += 2 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for i in range ( l - 1 , r , 1 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 ; NEW_LINE l , r = 1 , 11 ; NEW_LINE print ( rangesum ( n , l , r ) ) ; NEW_LINE DEDENT
def findAngle ( n ) : NEW_LINE INDENT interiorAngle = int ( ( n - 2 ) * 180 / n ) NEW_LINE exteriorAngle = int ( 360 / n ) NEW_LINE print ( " Interior ▁ angle : ▁ " , interiorAngle ) NEW_LINE print ( " Exterior ▁ angle : ▁ " , exteriorAngle ) NEW_LINE DEDENT n = 10 NEW_LINE findAngle ( n ) NEW_LINE
import math NEW_LINE def distance ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT d = math . sqrt ( math . pow ( x2 - x1 , 2 ) + math . pow ( y2 - y1 , 2 ) + math . pow ( z2 - z1 , 2 ) * 1.0 ) NEW_LINE print ( " Distance ▁ is ▁ " ) NEW_LINE print ( d ) NEW_LINE DEDENT x1 = 2 NEW_LINE y1 = - 5 NEW_LINE z1 = 7 NEW_LINE x2 = 3 NEW_LINE y2 = 4 NEW_LINE z2 = 5 NEW_LINE distance ( x1 , y1 , z1 , x2 , y2 , z2 ) NEW_LINE
def DivisibleBy41 ( first , second , c , n ) : NEW_LINE INDENT digit = [ 0 ] * n NEW_LINE digit [ 0 ] = first NEW_LINE digit [ 1 ] = second NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 NEW_LINE DEDENT ans = digit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ans * 10 + digit [ i ] ) % 41 NEW_LINE DEDENT if ( ans % 41 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT first = 1 NEW_LINE second = 2 NEW_LINE c = 1 NEW_LINE n = 3 NEW_LINE if ( DivisibleBy41 ( first , second , c , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def findTetrahedralNumber ( n ) : NEW_LINE INDENT return ( int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) ) NEW_LINE DEDENT def printSeries ( n ) : NEW_LINE INDENT prev = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT curr = findTetrahedralNumber ( i ) NEW_LINE curr = curr + prev ; NEW_LINE print ( curr , end = ' ▁ ' ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printSeries ( n ) NEW_LINE
def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = int ( i * ( i + 1 ) * ( i + 2 ) * ( i + 3 ) // 24 ) NEW_LINE print ( num , end = ' ▁ ' ) ; NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printSeries ( n ) NEW_LINE
def No_Of_Pairs ( N ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( ( i * i * i ) + ( 2 * i * i ) + i <= N ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT return ( i - 1 ) ; NEW_LINE DEDENT def print_pairs ( pairs ) : NEW_LINE INDENT i = 1 ; NEW_LINE mul = 0 ; NEW_LINE for i in range ( 1 , pairs + 1 ) : NEW_LINE INDENT mul = i * ( i + 1 ) ; NEW_LINE print ( " Pair ▁ no . " , i , " ▁ - - > ▁ ( " , ( mul * i ) , " , ▁ " , mul * ( i + 1 ) , " ) " ) ; NEW_LINE DEDENT DEDENT N = 500 ; NEW_LINE i = 1 ; NEW_LINE pairs = No_Of_Pairs ( N ) ; NEW_LINE print ( " No . ▁ of ▁ pairs ▁ = ▁ " , pairs ) ; NEW_LINE print_pairs ( pairs ) ; NEW_LINE
def findTriangularNumber ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) / 2 NEW_LINE DEDENT def printSeries ( n ) : NEW_LINE INDENT prev = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT curr = findTriangularNumber ( i ) NEW_LINE curr = int ( curr + prev ) NEW_LINE print ( curr , end = ' ▁ ' ) NEW_LINE prev = curr NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printSeries ( n ) NEW_LINE
def printSeries ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT num = i * ( i + 1 ) * ( i + 2 ) // 6 NEW_LINE print ( num , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printSeries ( n ) NEW_LINE
def count_even_odd ( min , max , steps ) : NEW_LINE INDENT beven = True NEW_LINE aeven = False NEW_LINE n = 2 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT a = steps [ i ] [ 0 ] NEW_LINE b = steps [ i ] [ 1 ] NEW_LINE if ( not ( aeven or a & 1 ) ) : NEW_LINE INDENT aeven = True NEW_LINE DEDENT if ( beven ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = False NEW_LINE DEDENT DEDENT elif ( not ( a & 1 ) ) : NEW_LINE INDENT if ( not ( b & 1 ) ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT beven = True NEW_LINE DEDENT DEDENT DEDENT if ( beven ) : NEW_LINE INDENT even = ( int ( max / 2 ) - int ( ( min - 1 ) / 2 ) ) NEW_LINE odd = 0 NEW_LINE DEDENT else : NEW_LINE INDENT even = ( int ( max / 2 ) - int ( ( min - 1 ) / 2 ) ) NEW_LINE odd = 0 NEW_LINE DEDENT if ( not ( beven ^ aeven ) ) : NEW_LINE INDENT even += ( max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT odd += ( max - min + 1 - int ( max / 2 ) + int ( ( min - 1 ) / 2 ) ) NEW_LINE DEDENT print ( " even ▁ = ▁ " , even , " , ▁ odd ▁ = ▁ " , odd , sep = " " ) NEW_LINE DEDENT min = 1 NEW_LINE max = 4 NEW_LINE steps = [ [ 1 , 2 ] , [ 3 , 4 ] ] NEW_LINE count_even_odd ( min , max , steps ) NEW_LINE
def getMaxOnes ( n , x ) : NEW_LINE INDENT zeroes = ( int ) ( n / x ) ; NEW_LINE zeroes = zeroes * zeroes ; NEW_LINE total = n * n ; NEW_LINE ans = total - zeroes ; NEW_LINE return ans ; NEW_LINE DEDENT n = 5 ; NEW_LINE x = 2 ; NEW_LINE print ( getMaxOnes ( n , x ) ) ; NEW_LINE
def check ( n , m ) : NEW_LINE INDENT if ( n == 2 or m == 2 or n % m == 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE n = 9 NEW_LINE check ( n , m ) NEW_LINE
import math NEW_LINE def findSurfaceArea ( a , h ) : NEW_LINE INDENT Area = 0 ; NEW_LINE Area = ( 6 * a * h + 3 * math . sqrt ( 3 ) * a * a ) ; NEW_LINE print ( " Surface ▁ Area : " , round ( Area , 3 ) ) ; NEW_LINE DEDENT def findVolume ( a , h ) : NEW_LINE INDENT Volume = 0 ; NEW_LINE Volume = ( 3 * math . sqrt ( 3 ) * a * a * h / 2 ) ; NEW_LINE print ( " Volume : " , round ( Volume , 3 ) ) ; NEW_LINE DEDENT a = 5 ; NEW_LINE h = 10 ; NEW_LINE findSurfaceArea ( a , h ) ; NEW_LINE findVolume ( a , h ) ; NEW_LINE
import math NEW_LINE def MinimumMail ( n , k , x ) : NEW_LINE INDENT m = ( ( n - 1 ) + int ( math . ceil ( ( n - 1 ) * 1.0 / x ) * ( n - 1 ) + math . ceil ( n * 1.0 / x ) * ( k - n ) ) ) ; NEW_LINE return m ; NEW_LINE DEDENT N = 4 ; NEW_LINE K = 9 ; NEW_LINE X = 2 ; NEW_LINE print ( MinimumMail ( N , K , X ) ) ; NEW_LINE
def findArea ( a , b ) : NEW_LINE INDENT Area = 3.142 * a * b ; NEW_LINE print ( " Area : " , round ( Area , 2 ) ) ; NEW_LINE DEDENT a = 5 ; NEW_LINE b = 4 ; NEW_LINE findArea ( a , b ) ; NEW_LINE
import math NEW_LINE def calculate ( x , k , m ) : NEW_LINE INDENT result = x ; NEW_LINE k = k - 1 ; NEW_LINE while ( k ) : NEW_LINE INDENT result = math . pow ( result , x ) ; NEW_LINE if ( result > m ) : NEW_LINE INDENT result = result % m ; NEW_LINE DEDENT k = k - 1 ; NEW_LINE DEDENT return int ( result ) ; NEW_LINE DEDENT x = 5 ; NEW_LINE k = 2 ; NEW_LINE m = 3 ; NEW_LINE print ( calculate ( x , k , m ) ) ; NEW_LINE
def rev ( n , temp ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return temp ; NEW_LINE DEDENT temp = ( temp * 10 ) + ( n % 10 ) ; NEW_LINE return rev ( n / 10 , temp ) ; NEW_LINE DEDENT n = 121 ; NEW_LINE temp = rev ( n , 0 ) ; NEW_LINE if ( temp != n ) : NEW_LINE INDENT print ( " yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) ; NEW_LINE DEDENT
import math NEW_LINE def findGreater ( a , b , n ) : NEW_LINE INDENT if ( ( n & 1 ) > 0 ) : NEW_LINE INDENT a = abs ( a ) ; NEW_LINE b = abs ( b ) ; NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT print ( " a ^ n ▁ is ▁ equal ▁ to ▁ b ^ n " ) ; NEW_LINE DEDENT elif ( a > b ) : NEW_LINE INDENT print ( " a ^ n ▁ is ▁ greater ▁ than ▁ b ^ n " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " b ^ n ▁ is ▁ greater ▁ than ▁ a ^ n " ) ; NEW_LINE DEDENT DEDENT a = 12 ; NEW_LINE b = 24 ; NEW_LINE n = 5 ; NEW_LINE findGreater ( a , b , n ) ; NEW_LINE
import math NEW_LINE def fibonacci ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT fib = ( ( pow ( ( 1 + math . sqrt ( 5 ) ) , i ) - pow ( ( 1 - math . sqrt ( 5 ) ) , i ) ) / ( pow ( 2 , i ) * math . sqrt ( 5 ) ) ) ; NEW_LINE print ( int ( fib ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 8 ; NEW_LINE fibonacci ( n ) ; NEW_LINE
def center_hexadecagonal_num ( n ) : NEW_LINE INDENT return 8 * n * n - 8 * n + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , " nd ▁ centered ▁ hexadecagonal ▁ " + " number ▁ : ▁ " , center_hexadecagonal_num ( n ) ) NEW_LINE n = 12 NEW_LINE print ( n , " th ▁ centered ▁ hexadecagonal ▁ " + " number ▁ : ▁ " , center_hexadecagonal_num ( n ) ) NEW_LINE DEDENT
MAX = 100 ; NEW_LINE def findNature ( a , b , n ) : NEW_LINE INDENT seq = [ 0 ] * MAX ; NEW_LINE seq [ 0 ] = a ; NEW_LINE seq [ 1 ] = b ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT seq [ i ] = seq [ i - 1 ] + seq [ i - 2 ] ; NEW_LINE DEDENT return ( seq [ n ] & 1 ) ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 4 ; NEW_LINE n = 3 ; NEW_LINE if ( findNature ( a , b , n ) ) : NEW_LINE INDENT print ( " Odd " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Even " ) ; NEW_LINE DEDENT
import math NEW_LINE def check ( m , n ) : NEW_LINE INDENT RHS = m * math . log ( n ) ; NEW_LINE LHS = n * math . log ( m ) ; NEW_LINE if ( LHS > RHS ) : NEW_LINE INDENT print ( " m ^ n ▁ > ▁ n ^ m " ) ; NEW_LINE DEDENT elif ( LHS < RHS ) : NEW_LINE INDENT print ( " m ^ n ▁ < ▁ n ^ m " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " m ^ n ▁ = ▁ n ^ m " ) ; NEW_LINE DEDENT DEDENT m = 987654321 ; NEW_LINE n = 123456987 ; NEW_LINE check ( m , n ) ; NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return gcd ( b , a % b ) ; NEW_LINE DEDENT def maxDivisorRange ( a , b , l , h ) : NEW_LINE INDENT g = gcd ( a , b ) ; NEW_LINE res = - 1 ; NEW_LINE i = l ; NEW_LINE while ( i * i <= g and i <= h ) : NEW_LINE INDENT if ( g % i == 0 ) : NEW_LINE INDENT res = max ( res , max ( i , g / i ) ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return int ( res ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 3 ; NEW_LINE b = 27 ; NEW_LINE l = 1 ; NEW_LINE h = 5 ; NEW_LINE print ( maxDivisorRange ( a , b , l , h ) ) ; NEW_LINE DEDENT
def checksum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT print ( " - 2 ▁ - 1 ▁ 0 ▁ 1 ▁ 2" ) NEW_LINE return 0 NEW_LINE DEDENT inc = 0 NEW_LINE if n > 0 : NEW_LINE INDENT inc = 1 NEW_LINE DEDENT else : NEW_LINE INDENT inc = - 1 NEW_LINE DEDENT for i in range ( 0 , n - 3 , inc ) : NEW_LINE INDENT if i + i + 1 + i + 2 + i + 3 + i + 4 == n : NEW_LINE INDENT print ( i , " ▁ " , i + 1 , " ▁ " , i + 2 , " ▁ " , i + 3 , " ▁ " , i + 4 ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT n = 15 NEW_LINE checksum ( n ) NEW_LINE
def checksum ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if n % 5 == 0 : NEW_LINE INDENT print ( int ( n / 5 - 2 ) , " ▁ " , int ( n / 5 - 1 ) , " ▁ " , int ( n / 5 ) , " ▁ " , int ( n / 5 + 1 ) , " ▁ " , int ( n / 5 + 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE checksum ( n ) NEW_LINE
def sumOfSeries ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans + i * i * i * i NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 4 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
def countUnmarked ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return N / 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return N / 2 + 1 ; NEW_LINE DEDENT DEDENT N = 4 ; NEW_LINE print ( " Number ▁ of ▁ unmarked ▁ elements : " , int ( countUnmarked ( N ) ) ) ; NEW_LINE
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def calculateSeries ( n ) : NEW_LINE INDENT return factorial ( n + 1 ) - 1 NEW_LINE DEDENT n = 3 NEW_LINE print ( calculateSeries ( n ) ) NEW_LINE
import math NEW_LINE def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE i = 2 NEW_LINE for i in ( n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def calculateSeries ( n ) : NEW_LINE INDENT return ( 2 + ( n * n + n - 2 ) * math . factorial ( n + 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( calculateSeries ( n ) ) NEW_LINE
def minimumLength ( x , y , z ) : NEW_LINE INDENT return ( 1 + abs ( x - y ) + abs ( y - z ) ) NEW_LINE DEDENT x = 3 NEW_LINE y = 1 NEW_LINE z = 2 NEW_LINE print ( minimumLength ( x , y , z ) ) NEW_LINE
def endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) : NEW_LINE INDENT print ( " x2 ▁ = " , ( 2 * c1 - x1 ) , end = " ▁ " ) NEW_LINE print ( " y2 ▁ = " , ( 2 * c2 - y1 ) ) NEW_LINE DEDENT x1 = - 4 NEW_LINE y1 = - 1 NEW_LINE c1 = 3 NEW_LINE c2 = 5 NEW_LINE endPointOfDiameterofCircle ( x1 , y1 , c1 , c2 ) NEW_LINE
def proterm ( i , value , x ) : NEW_LINE INDENT pro = 1 ; NEW_LINE for j in range ( i ) : NEW_LINE INDENT pro = pro * ( value - x [ j ] ) ; NEW_LINE DEDENT return pro ; NEW_LINE DEDENT def dividedDiffTable ( x , y , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT y [ j ] [ i ] = ( ( y [ j ] [ i - 1 ] - y [ j + 1 ] [ i - 1 ] ) / ( x [ j ] - x [ i + j ] ) ) ; NEW_LINE DEDENT DEDENT return y ; NEW_LINE DEDENT def applyFormula ( value , x , y , n ) : NEW_LINE INDENT sum = y [ 0 ] [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum = sum + ( proterm ( i , value , x ) * y [ 0 ] [ i ] ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def printDiffTable ( y , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n - i ) : NEW_LINE INDENT print ( round ( y [ i ] [ j ] , 4 ) , " TABSYMBOL " , end = " ▁ " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT n = 4 ; NEW_LINE y = [ [ 0 for i in range ( 10 ) ] for j in range ( 10 ) ] ; NEW_LINE x = [ 5 , 6 , 9 , 11 ] ; NEW_LINE y [ 0 ] [ 0 ] = 12 ; NEW_LINE y [ 1 ] [ 0 ] = 13 ; NEW_LINE y [ 2 ] [ 0 ] = 14 ; NEW_LINE y [ 3 ] [ 0 ] = 16 ; NEW_LINE y = dividedDiffTable ( x , y , n ) ; NEW_LINE printDiffTable ( y , n ) ; NEW_LINE value = 7 ; NEW_LINE print ( " Value at " , ▁ value , ▁ " is " , round ( applyFormula ( value , x , y , n ) , 2 ) ) NEW_LINE
def centered_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( " % sth ▁ Centered ▁ heptagonal ▁ number ▁ : ▁ " % n , centered_heptagonal_num ( n ) ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ = ( summ + ( ( i * ( i + 1 ) * ( 2 * i + 1 ) ) / 6 ) ) NEW_LINE DEDENT return summ NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( findSum ( n ) ) ) NEW_LINE
N = 4 NEW_LINE def checkHankelMatrix ( n , m ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT if ( i + j < n ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ i + j ] [ 0 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ i + j - n + 1 ] [ n - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT n = 4 NEW_LINE m = [ [ 1 , 2 , 3 , 5 , ] , [ 2 , 3 , 5 , 8 , ] , [ 3 , 5 , 8 , 0 , ] , [ 5 , 8 , 0 , 9 ] ] NEW_LINE ( print ( " Yes " ) if checkHankelMatrix ( n , m ) else print ( " No " ) ) NEW_LINE
import math NEW_LINE def isPower ( n ) : NEW_LINE INDENT for x in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT f = math . log ( n ) / math . log ( x ) ; NEW_LINE if ( ( f - int ( f ) ) == 0.0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
N = 100 NEW_LINE digitSum = [ 0 ] * N NEW_LINE factorDigitSum = [ 0 ] * N NEW_LINE def sumOddDigit ( ) : NEW_LINE INDENT global N , digitSum , factorDigitSum NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT digitSum [ i ] = ( digitSum [ int ( i / 10 ) ] + int ( i & 1 ) * ( i % 10 ) ) NEW_LINE DEDENT DEDENT def sumFactor ( ) : NEW_LINE INDENT global N , digitSum , factorDigitSum NEW_LINE j = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT j = i NEW_LINE while ( j < N ) : NEW_LINE INDENT factorDigitSum [ j ] = ( factorDigitSum [ j ] + digitSum [ i ] ) NEW_LINE j = j + i NEW_LINE DEDENT DEDENT DEDENT def wrapper ( q , n ) : NEW_LINE INDENT global N , digitSum , factorDigitSum NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT digitSum [ i ] = 0 NEW_LINE factorDigitSum [ i ] = 0 NEW_LINE DEDENT sumOddDigit ( ) NEW_LINE sumFactor ( ) NEW_LINE for i in range ( 0 , q ) : NEW_LINE INDENT print ( " { } ▁ " . format ( factorDigitSum [ n [ i ] ] ) , end = " " ) NEW_LINE DEDENT DEDENT q = 2 NEW_LINE n = [ 10 , 36 ] NEW_LINE wrapper ( q , n ) NEW_LINE
def number_of_digits ( n ) : NEW_LINE INDENT i = 4 NEW_LINE res = 1 NEW_LINE sum = 0 NEW_LINE while ( True ) : NEW_LINE INDENT i *= 4 NEW_LINE res += 1 NEW_LINE sum += i NEW_LINE if ( sum >= n ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT n = 21 NEW_LINE print ( number_of_digits ( n ) ) NEW_LINE
def Reverseorder ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( ( p * 2 ) , ( n + 1 ) , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( n , 1 , - 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT print ( p , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT N = 25 ; NEW_LINE print ( " Prime ▁ number ▁ in ▁ reverse ▁ order " ) ; NEW_LINE if ( N == 1 ) : NEW_LINE INDENT print ( " No ▁ prime ▁ no ▁ exist ▁ in ▁ this ▁ range " ) ; NEW_LINE DEDENT else : NEW_LINE
def magicOfSequence ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += ( i * i * i + i * 2 ) NEW_LINE DEDENT return sum ; NEW_LINE DEDENT N = 4 NEW_LINE print ( magicOfSequence ( N ) ) NEW_LINE
def countOddFactors ( n ) : NEW_LINE INDENT odd_factors = 0 NEW_LINE i = 1 NEW_LINE while ( ( 1 * i * i ) <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( 1 * i * i == n ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT odd_factors = odd_factors + 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( ( i & 1 ) ) : NEW_LINE INDENT odd_factors = odd_factors + 1 NEW_LINE DEDENT factor = int ( n / i ) NEW_LINE if ( factor & 1 ) : NEW_LINE INDENT odd_factors = odd_factors + 1 NEW_LINE DEDENT DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return odd_factors - 1 NEW_LINE DEDENT N = 15 NEW_LINE print ( countOddFactors ( N ) ) NEW_LINE N = 10 NEW_LINE print ( countOddFactors ( N ) ) NEW_LINE
def isPossibleToZero ( a , n ) : NEW_LINE INDENT even = 0 ; NEW_LINE odd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT odd += a [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT even += a [ i ] ; NEW_LINE DEDENT DEDENT return ( odd == even ) ; NEW_LINE DEDENT arr = [ 0 , 1 , 1 , 0 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE if ( isPossibleToZero ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
PI = 3.142 ; NEW_LINE def cosXSertiesSum ( x , n ) : NEW_LINE INDENT x = x * ( PI / 180.0 ) ; NEW_LINE res = 1 ; NEW_LINE sign = 1 ; NEW_LINE fact = 1 ; NEW_LINE pow = 1 ; NEW_LINE for i in range ( 1 , 5 ) : NEW_LINE INDENT sign = sign * ( - 1 ) ; NEW_LINE fact = fact * ( 2 * i - 1 ) * ( 2 * i ) ; NEW_LINE pow = pow * x * x ; NEW_LINE res = res + sign * pow / fact ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT x = 50 ; NEW_LINE n = 5 ; NEW_LINE print ( round ( cosXSertiesSum ( x , 5 ) , 6 ) ) ; NEW_LINE
def solve ( n , base ) : NEW_LINE INDENT result = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE result = result + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return result NEW_LINE DEDENT def printSumsOfDigits ( n ) : NEW_LINE INDENT for base in range ( 2 , n ) : NEW_LINE INDENT print ( solve ( n , base ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 8 NEW_LINE printSumsOfDigits ( n ) NEW_LINE
def check ( N , D ) : NEW_LINE INDENT temp = N * ( N + 1 ) // 2 + D NEW_LINE return ( bool ( temp % 2 == 0 ) ) NEW_LINE DEDENT N = 5 NEW_LINE M = 7 NEW_LINE if check ( N , M ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT
import math NEW_LINE def perfectSquare ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE ans = - 1 NEW_LINE num = " " NEW_LINE for i in range ( 1 , ( 1 << n ) ) : NEW_LINE INDENT str = " " NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( i >> j ) & 1 ) : NEW_LINE INDENT str = str + s [ j ] NEW_LINE DEDENT DEDENT if ( str [ 0 ] != '0' ) : NEW_LINE INDENT temp = 0 ; NEW_LINE for j in range ( 0 , len ( str ) ) : NEW_LINE INDENT temp = ( temp * 10 + ( ord ( str [ j ] ) - ord ( '0' ) ) ) NEW_LINE DEDENT k = int ( math . sqrt ( temp ) ) NEW_LINE if ( k * k == temp ) : NEW_LINE INDENT if ( ans < len ( str ) ) : NEW_LINE INDENT ans = len ( str ) NEW_LINE num = str NEW_LINE DEDENT DEDENT DEDENT DEDENT if ( ans == - 1 ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT print ( " { } ▁ " . format ( num ) , end = " " ) NEW_LINE return n - ans NEW_LINE DEDENT DEDENT print ( perfectSquare ( "8314" ) ) NEW_LINE print ( perfectSquare ( "753" ) ) ; NEW_LINE
def printFourSquares ( a ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i * i <= a ) : NEW_LINE INDENT j = i NEW_LINE while ( j * j <= a ) : NEW_LINE INDENT k = j NEW_LINE while ( k * k <= a ) : NEW_LINE INDENT l = k NEW_LINE while ( l * l <= a ) : NEW_LINE INDENT if ( i * i + j * j + k * k + l * l == a ) : NEW_LINE INDENT print ( " { } ▁ = ▁ { } * { } ▁ + ▁ { } * { } ▁ + " . format ( a , i , i , j , j ) , end = " ▁ " ) NEW_LINE print ( " { } * { } ▁ + ▁ { } * { } " . format ( k , k , l , l ) , end = " " ) NEW_LINE DEDENT l = l + 1 NEW_LINE DEDENT k = k + 1 NEW_LINE DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT a = 74 NEW_LINE printFourSquares ( a ) NEW_LINE
import math NEW_LINE def exactPrimeFactorCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT DEDENT i = 3 NEW_LINE while ( i <= int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE DEDENT DEDENT i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 51242183 NEW_LINE print ( " The ▁ number ▁ of ▁ distinct ▁ prime ▁ factors ▁ is / are ▁ { } " . format ( exactPrimeFactorCount ( n ) , end =   " " ) ) NEW_LINE print ( " The ▁ value ▁ of ▁ log ( log ( n ) ) ▁ is ▁ { 0 : . 4f } " . format ( math . log ( math . log ( n ) ) ) ) NEW_LINE
import math NEW_LINE def no_of_digit ( a , b ) : NEW_LINE INDENT return ( ( int ) ( b * math . log10 ( a ) ) + 1 ) NEW_LINE DEDENT a = 2 NEW_LINE b = 100 NEW_LINE print ( " no ▁ of ▁ digits ▁ = ▁ " , no_of_digit ( a , b ) ) NEW_LINE
def checkSemiprime ( num ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE i = 2 ; NEW_LINE while ( cnt < 2 and ( i * i ) <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num /= i ; NEW_LINE cnt += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT return cnt == 2 ; NEW_LINE DEDENT def isEmirpimes ( n ) : NEW_LINE INDENT if ( checkSemiprime ( n ) == False ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT r = 0 ; NEW_LINE t = n ; NEW_LINE while ( t != 0 ) : NEW_LINE INDENT r = r * 10 + t % 10 ; NEW_LINE t = t / n ; NEW_LINE DEDENT if ( r == n ) : NEW_LINE INDENT return false ; NEW_LINE DEDENT return ( checkSemiprime ( r ) ) ; NEW_LINE DEDENT n = 15 ; NEW_LINE if ( isEmirpimes ( n ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def printNComposite ( n ) : NEW_LINE INDENT fact = factorial ( n + 1 ) ; NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT print ( fact + i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT n = 4 ; NEW_LINE printNComposite ( n ) ; NEW_LINE
def primes ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT j = i * 2 ; NEW_LINE while ( j <= n ) : NEW_LINE INDENT prime [ j ] = False ; NEW_LINE j += i ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT arr = [ ] ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT arr . append ( i ) ; NEW_LINE DEDENT DEDENT return arr ; NEW_LINE DEDENT def countDigits ( n ) : NEW_LINE INDENT temp = n ; NEW_LINE c = 0 ; NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT temp = int ( temp / 10 ) ; NEW_LINE c += 1 ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT def frugal ( n ) : NEW_LINE INDENT r = primes ( n ) ; NEW_LINE t = n ; NEW_LINE s = 0 ; NEW_LINE for i in range ( len ( r ) ) : NEW_LINE INDENT if ( t % r [ i ] == 0 ) : NEW_LINE INDENT k = 0 ; NEW_LINE while ( t % r [ i ] == 0 ) : NEW_LINE INDENT t = int ( t / r [ i ] ) ; NEW_LINE k += 1 ; NEW_LINE DEDENT if ( k == 1 ) : NEW_LINE INDENT s = s + countDigits ( r [ i ] ) ; NEW_LINE DEDENT elif ( k != 1 ) : NEW_LINE INDENT s = ( s + countDigits ( r [ i ] ) + countDigits ( k ) ) ; NEW_LINE DEDENT DEDENT DEDENT return ( countDigits ( n ) > s and s != 0 ) ; NEW_LINE DEDENT n = 343 ; NEW_LINE if ( frugal ( n ) ) : NEW_LINE INDENT print ( " A ▁ Frugal ▁ number " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ frugal ▁ number " ) ; NEW_LINE DEDENT
def nthSquareCube ( n ) : NEW_LINE INDENT return n * n * n * n * n * n NEW_LINE DEDENT n = 5 NEW_LINE print ( nthSquareCube ( n ) ) NEW_LINE
def findS ( s ) : NEW_LINE INDENT _sum = 0 NEW_LINE n = 1 NEW_LINE while ( _sum < s ) : NEW_LINE INDENT _sum += n * n * n NEW_LINE n += 1 NEW_LINE DEDENT n -= 1 NEW_LINE if _sum == s : NEW_LINE INDENT return n NEW_LINE DEDENT return - 1 NEW_LINE DEDENT s = 9 NEW_LINE n = findS ( s ) NEW_LINE if n == - 1 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
def findKthGoodNo ( n ) : NEW_LINE INDENT lastDig = n % 10 NEW_LINE if ( lastDig >= 0 and lastDig <= 4 ) : NEW_LINE INDENT return n << 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n << 1 ) + 1 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE print ( findKthGoodNo ( n ) ) NEW_LINE
def NicomachuTheorum_sum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for k in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += k * k * k ; NEW_LINE DEDENT triNo = n * ( n + 1 ) / 2 ; NEW_LINE if ( sum == triNo * triNo ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE NicomachuTheorum_sum ( n ) ; NEW_LINE
def checkDigits ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def largestNumber ( n ) : NEW_LINE INDENT for i in range ( n , - 1 , - 1 ) : NEW_LINE INDENT if ( checkDigits ( i ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT N = 23 ; NEW_LINE print ( largestNumber ( N ) ) ; NEW_LINE
import math as mt NEW_LINE def largestNumber ( n ) : NEW_LINE INDENT s = " " NEW_LINE duplicate = n NEW_LINE while ( n > 0 ) : NEW_LINE INDENT s = chr ( n % 10 + 48 ) + s NEW_LINE n = n // 10 NEW_LINE DEDENT index = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ( ord ( s [ i ] ) - ord ( '0' ) ) % 2 & 1 ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return duplicate NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( index ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT num = num * 10 + ( ord ( s [ index ] ) - ord ( '0' ) - 1 ) NEW_LINE for i in range ( index + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 + 8 NEW_LINE DEDENT return num NEW_LINE DEDENT N = 24578 NEW_LINE print ( largestNumber ( N ) ) NEW_LINE
import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT return int ( n * math . log10 ( 2 ) + 1 ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( countDigits ( n ) ) ; NEW_LINE
def check_digits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT def smallest_number ( n ) : NEW_LINE INDENT for i in range ( n , 2401 ) : NEW_LINE INDENT if ( check_digits ( i ) == 1 ) : NEW_LINE INDENT return ( i ) NEW_LINE DEDENT DEDENT DEDENT N = 2397 NEW_LINE print ( str ( smallest_number ( N ) ) ) NEW_LINE
import math NEW_LINE def findBucketNo ( p ) : NEW_LINE INDENT return math . ceil ( ( math . sqrt ( 8 * p + 1 ) - 1 ) / 2 ) NEW_LINE DEDENT p = 10 NEW_LINE print ( findBucketNo ( p ) ) NEW_LINE
def factorial ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * factorial ( n - 1 ) NEW_LINE DEDENT def LCMOfNeighbourFact ( n ) : NEW_LINE INDENT return factorial ( n + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( LCMOfNeighbourFact ( N ) ) NEW_LINE
import math NEW_LINE def sumofFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 ; curr_sum = 1 ; curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n // i NEW_LINE curr_term *= i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res *= curr_sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res *= ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def checkFriendly ( n , m ) : NEW_LINE INDENT sumFactors_n = sumofFactors ( n ) NEW_LINE sumFactors_m = sumofFactors ( m ) NEW_LINE gcd_n = gcd ( n , sumFactors_n ) NEW_LINE gcd_m = gcd ( m , sumFactors_m ) NEW_LINE if ( n // gcd_n == m // gcd_m and sumFactors_n // gcd_n == sumFactors_m // gcd_m ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 6 ; m = 28 NEW_LINE if ( checkFriendly ( n , m ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : return False NEW_LINE if ( n <= 3 ) : return True NEW_LINE if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def primorial ( n ) : NEW_LINE INDENT p = 2 ; n -= 1 ; i = 3 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( isPrime ( i ) ) : NEW_LINE INDENT p = p * i NEW_LINE n -= 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return p NEW_LINE DEDENT def findNextPrime ( n ) : NEW_LINE INDENT nextPrime = n + 2 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPrime ( nextPrime ) ) : NEW_LINE INDENT break NEW_LINE DEDENT nextPrime += 1 NEW_LINE DEDENT return nextPrime NEW_LINE DEDENT def fortunateNumber ( n ) : NEW_LINE INDENT p = primorial ( n ) NEW_LINE return findNextPrime ( p ) - p NEW_LINE DEDENT n = 5 NEW_LINE print ( fortunateNumber ( n ) ) NEW_LINE
def procal ( n ) : NEW_LINE INDENT return ( 3.0 * n ) / ( 4.0 * ( n * n ) - 1 ) NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE print ( round ( procal ( n ) , 6 ) ) NEW_LINE
def testSomeNumbers ( limit , n ) : NEW_LINE INDENT if ( n < 3 ) : NEW_LINE INDENT return NEW_LINE DEDENT for a in range ( 1 , limit + 1 ) : NEW_LINE INDENT for b in range ( a , limit + 1 ) : NEW_LINE INDENT pow_sum = pow ( a , n ) + pow ( b , n ) NEW_LINE c = pow ( pow_sum , 1.0 / n ) NEW_LINE c_pow = pow ( int ( c ) , n ) NEW_LINE if ( c_pow == pow_sum ) : NEW_LINE INDENT print ( " Count ▁ example ▁ found " ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " No ▁ counter ▁ example ▁ within ▁ given ▁ range ▁ and ▁ data " ) NEW_LINE DEDENT testSomeNumbers ( 10 , 3 ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def productReduce ( n , num , den ) : NEW_LINE INDENT new_num = 1 ; NEW_LINE new_den = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT new_num = new_num * num [ i ] ; NEW_LINE new_den = new_den * den [ i ] ; NEW_LINE DEDENT GCD = gcd ( new_num , new_den ) ; NEW_LINE new_num = new_num / GCD ; NEW_LINE new_den = new_den / GCD ; NEW_LINE print ( int ( new_num ) , " / " , int ( new_den ) ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE num = [ 1 , 2 , 5 ] ; NEW_LINE den = [ 2 , 1 , 6 ] ; NEW_LINE productReduce ( n , num , den ) ; NEW_LINE
def fnMod ( n ) : NEW_LINE INDENT if ( n % 5 == 1 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT n = 10 NEW_LINE print ( fnMod ( n ) ) NEW_LINE n = 11 NEW_LINE print ( fnMod ( n ) ) NEW_LINE
def digSum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( n % 9 == 0 ) and 9 or ( n % 9 ) NEW_LINE DEDENT def repeatedNumberSum ( n , x ) : NEW_LINE INDENT sum = x * digSum ( n ) NEW_LINE return digSum ( sum ) NEW_LINE DEDENT n = 24 ; x = 3 NEW_LINE print ( repeatedNumberSum ( n , x ) ) NEW_LINE
' NEW_LINE def totalSumDivisibleByNum ( n , number ) : NEW_LINE INDENT firstnum = pow ( 10 , n - 1 ) NEW_LINE lastnum = pow ( 10 , n ) NEW_LINE sum = 0 NEW_LINE for i in range ( firstnum , lastnum ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 3 ; num = 7 NEW_LINE print ( totalSumDivisibleByNum ( n , num ) ) NEW_LINE
import math NEW_LINE def numberofterm ( n , number ) : NEW_LINE INDENT firstnum = math . pow ( 10 , n - 1 ) NEW_LINE lastnum = math . pow ( 10 , n ) NEW_LINE count = 0 NEW_LINE for i in range ( int ( firstnum ) , int ( lastnum ) ) : NEW_LINE INDENT if ( i % number == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE num = 7 NEW_LINE print ( numberofterm ( n , num ) ) NEW_LINE
def georgeCantor ( n ) : NEW_LINE INDENT i = 1 NEW_LINE j = 1 NEW_LINE k = 1 NEW_LINE while k < n : NEW_LINE INDENT j += 1 NEW_LINE k += 1 NEW_LINE if k == n : NEW_LINE INDENT break NEW_LINE DEDENT while j > 1 and k < n : NEW_LINE INDENT i += 1 NEW_LINE j -= 1 NEW_LINE k += 1 NEW_LINE DEDENT if k == n : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE k += 1 NEW_LINE if k == n : NEW_LINE INDENT break NEW_LINE DEDENT while i > 1 and k < n : NEW_LINE INDENT i -= 1 NEW_LINE j += 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT print ( " N - th ▁ term ▁ : ▁ % d / % d " % ( i , j ) ) NEW_LINE DEDENT n = 15 NEW_LINE georgeCantor ( n ) NEW_LINE
def isDivisible ( n ) : NEW_LINE INDENT while ( int ( n / 100 ) ) : NEW_LINE INDENT last_digit = int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE n += last_digit * 3 NEW_LINE DEDENT return ( n % 29 == 0 ) NEW_LINE DEDENT n = 348 NEW_LINE if ( isDivisible ( n ) != 0 ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def solveEquation ( equation ) : NEW_LINE INDENT n = len ( equation ) NEW_LINE sign = 1 NEW_LINE coeff = 0 NEW_LINE total = 0 NEW_LINE i = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( equation [ j ] == ' + ' or equation [ j ] == ' - ' ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT total = ( total + sign * int ( equation [ i : j ] ) ) NEW_LINE DEDENT i = j NEW_LINE DEDENT elif ( equation [ j ] == ' x ' ) : NEW_LINE INDENT if ( ( i == j ) or equation [ j - 1 ] == ' + ' ) : NEW_LINE INDENT coeff += sign NEW_LINE DEDENT elif ( equation [ j - 1 ] == ' - ' ) : NEW_LINE INDENT coeff = coeff - sign NEW_LINE DEDENT else : NEW_LINE INDENT coeff = ( coeff + sign * int ( equation [ i : j ] ) ) NEW_LINE DEDENT i = j + 1 NEW_LINE DEDENT elif ( equation [ j ] == ' = ' ) : NEW_LINE INDENT if ( j > i ) : NEW_LINE INDENT total = ( total + sign * int ( equation [ i : j ] ) ) NEW_LINE DEDENT sign = - 1 NEW_LINE i = j + 1 NEW_LINE DEDENT DEDENT if ( i < n ) : NEW_LINE INDENT total = ( total + sign * int ( equation [ i : len ( equation ) ] ) ) NEW_LINE DEDENT if ( coeff == 0 and total == 0 ) : NEW_LINE INDENT return " Infinite ▁ solutions " NEW_LINE DEDENT if ( coeff == 0 and total ) : NEW_LINE INDENT return " No ▁ solution " NEW_LINE DEDENT ans = - total / coeff NEW_LINE return int ( ans ) NEW_LINE DEDENT equation = " x + 5-3 + x = 6 + x - 2" NEW_LINE print ( " x ▁ = ▁ { } " . format ( solveEquation ( equation ) ) ) NEW_LINE
import math NEW_LINE def pronic_check ( n ) : NEW_LINE INDENT x = ( int ) ( math . sqrt ( n ) ) NEW_LINE if ( x * ( x + 1 ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 56 NEW_LINE if ( pronic_check ( n ) == True ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
MAX = 100000 NEW_LINE def multiply ( x , res , res_size ) : NEW_LINE INDENT carry = 0 NEW_LINE for i in range ( res_size ) : NEW_LINE INDENT prod = res [ i ] * x + carry NEW_LINE res [ i ] = prod % 10 NEW_LINE carry = prod // 10 NEW_LINE DEDENT while ( carry ) : NEW_LINE INDENT res [ res_size ] = carry % 10 NEW_LINE carry = carry // 10 NEW_LINE res_size += 1 NEW_LINE DEDENT return res_size NEW_LINE DEDENT def power ( x , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT print ( "1" ) NEW_LINE return NEW_LINE DEDENT res = [ 0 for i in range ( MAX ) ] NEW_LINE res_size = 0 NEW_LINE temp = x NEW_LINE while ( temp != 0 ) : NEW_LINE INDENT res [ res_size ] = temp % 10 ; NEW_LINE res_size += 1 NEW_LINE temp = temp // 10 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res_size = multiply ( x , res , res_size ) NEW_LINE DEDENT print ( x , " ^ " , n , " ▁ = ▁ " , end = " " ) NEW_LINE for i in range ( res_size - 1 , - 1 , - 1 ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) NEW_LINE DEDENT DEDENT exponent = 100 NEW_LINE base = 2 NEW_LINE power ( base , exponent ) NEW_LINE
import math NEW_LINE def check ( n , p ) : NEW_LINE INDENT maximum = - 1 NEW_LINE while ( not ( n % 2 ) ) : NEW_LINE INDENT maximum = max ( maximum , 2 ) NEW_LINE n = int ( n / 2 ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT maximum = max ( maximum , i ) NEW_LINE n = int ( n / i ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT maximum = max ( maximum , n ) NEW_LINE DEDENT return ( maximum <= p ) NEW_LINE DEDENT n = 24 NEW_LINE p = 7 NEW_LINE if ( check ( n , p ) ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT
def find_time ( h1 ) : NEW_LINE INDENT theta = 30 * h1 NEW_LINE print ( " ( " , end = " " ) NEW_LINE print ( ( theta * 2 ) , " / ▁ 11 ) ▁ minutes " ) NEW_LINE DEDENT h1 = 3 NEW_LINE find_time ( h1 ) NEW_LINE
def sum_series ( n ) : NEW_LINE INDENT nSquare = n * n NEW_LINE return int ( nSquare * ( nSquare - 1 ) / 4 ) NEW_LINE DEDENT n = 2 NEW_LINE print ( sum_series ( n ) ) NEW_LINE
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE return False NEW_LINE root = int ( math . sqrt ( n ) ) NEW_LINE for i in range ( 2 , root + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isSandwitched ( n ) : NEW_LINE INDENT return ( isPrime ( n - 1 ) and isPrime ( n + 1 ) ) NEW_LINE DEDENT n = 642 NEW_LINE print ( n , end = " ▁ : ▁ " ) NEW_LINE if ( isSandwitched ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT n = 9 NEW_LINE print ( n , end = " ▁ : ▁ " ) NEW_LINE if ( isSandwitched ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def day_of_the_week ( y , m , d ) : NEW_LINE INDENT t = [ 0 , 3 , 2 , 5 , 0 , 3 , 5 , 1 , 4 , 6 , 2 , 4 ] NEW_LINE if ( m < 3 ) : NEW_LINE INDENT y = y - 1 NEW_LINE DEDENT return ( y + y // 4 - y // 100 + y // 400 + t [ m - 1 ] + d ) % 7 NEW_LINE DEDENT day = 13 NEW_LINE month = 7 NEW_LINE year = 2017 NEW_LINE print ( day_of_the_week ( year , month , day ) ) NEW_LINE
def isPrime ( n , i = 2 ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT return True if ( n == 2 ) else False NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( i * i > n ) : NEW_LINE INDENT return true NEW_LINE DEDENT return isPrime ( n , i + 1 ) NEW_LINE DEDENT n = 15 NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isSquareFree ( n ) : NEW_LINE INDENT if n % 2 == 0 : NEW_LINE INDENT n = n / 2 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT n = n / i NEW_LINE DEDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if isSquareFree ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findArea ( d ) : NEW_LINE INDENT return ( d * d ) / 2 NEW_LINE DEDENT d = 10 NEW_LINE print ( " % .2f " % findArea ( d ) ) NEW_LINE
import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum = sum + ( 2 * i - 1 ) * ( 2 * i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( 2 * n - 1 ) * ( 2 * n + 1 ) ) / 3 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
import math NEW_LINE def mean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm / n NEW_LINE DEDENT def SSD ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) NEW_LINE DEDENT return ( math . sqrt ( sm / ( n - 1 ) ) ) NEW_LINE DEDENT def sampleError ( arr , n ) : NEW_LINE INDENT return SSD ( arr , n ) / ( math . sqrt ( n ) ) NEW_LINE DEDENT arr = [ 78.53 , 79.62 , 80.25 , 81.05 , 83.21 , 83.46 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sampleError ( arr , n ) ) NEW_LINE
import math NEW_LINE def StepstoReachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE n = math . ceil ( ( - 1.0 + math . sqrt ( 1 + 8.0 * target ) ) / 2 ) NEW_LINE sum = n * ( n + 1 ) / 2 NEW_LINE if ( sum == target ) : NEW_LINE INDENT return n NEW_LINE DEDENT d = sum - target NEW_LINE if ( ( int ( d ) & 1 ) == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if ( int ( d ) & 1 ) : NEW_LINE INDENT return n + 2 NEW_LINE DEDENT return n + 1 NEW_LINE DEDENT DEDENT target = 5 NEW_LINE print ( StepstoReachTarget ( target ) ) NEW_LINE
def seriesSum ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE res = 0.0 ; NEW_LINE sign = True ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n - 1 ; NEW_LINE if ( sign ) : NEW_LINE INDENT sign = False ; NEW_LINE res = res + ( i + 1 ) / ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT sign = True ; NEW_LINE res = res - ( i + 1 ) / ( i + 2 ) ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( round ( seriesSum ( n ) , 6 ) ) ; NEW_LINE
def countSymmetric ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( 1 << ( ( n * ( n + 1 ) ) // 2 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( countSymmetric ( n ) ) NEW_LINE
def centeredNonagonal ( n ) : NEW_LINE INDENT return ( 3 * n - 2 ) * ( 3 * n - 1 ) // 2 NEW_LINE DEDENT n = 10 NEW_LINE print ( centeredNonagonal ( n ) ) NEW_LINE
def Mean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm // n NEW_LINE DEDENT def meanAbsoluteDeviation ( arr , n ) : NEW_LINE INDENT absSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT absSum = absSum + abs ( arr [ i ] - Mean ( arr , n ) ) NEW_LINE DEDENT return absSum / n NEW_LINE DEDENT arr = [ 10 , 15 , 15 , 17 , 18 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( meanAbsoluteDeviation ( arr , n ) ) NEW_LINE
def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upQuant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= upCost ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 ; upCost = 30 NEW_LINE lowQuant = 5 ; upQuant = 12 ; r = 9 NEW_LINE if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def pattern ( n , d ) : NEW_LINE INDENT for i in range ( 0 , n - 2 ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE DEDENT print ( "2" , end = " ▁ " ) NEW_LINE print ( n + d ) NEW_LINE DEDENT N = 3 NEW_LINE D = 5 NEW_LINE pattern ( N , D ) NEW_LINE ' NEW_LINE
def oddNumSum ( n ) : NEW_LINE INDENT return ( n * ( 2 * n + 1 ) * ( 24 * n * n * n - 12 * n * n - 14 * n + 7 ) ) / 15 NEW_LINE DEDENT n = 4 NEW_LINE print ( int ( oddNumSum ( n ) ) ) NEW_LINE
def trailingZero ( x ) : NEW_LINE INDENT i = 5 NEW_LINE count = 0 NEW_LINE while ( x > i ) : NEW_LINE INDENT count = count + x // i NEW_LINE i = i * 5 NEW_LINE DEDENT return count NEW_LINE DEDENT def countProductTrailing ( M , N ) : NEW_LINE INDENT return trailingZero ( N ) + trailingZero ( M ) NEW_LINE DEDENT N = 67 NEW_LINE M = 98 NEW_LINE print ( countProductTrailing ( N , M ) ) NEW_LINE
def isTrimorphic ( N ) : NEW_LINE INDENT cube = N * N * N NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 != cube % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT N = N // 10 NEW_LINE cube = cube // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT N = 24 NEW_LINE if ( isTrimorphic ( N ) ) : NEW_LINE INDENT print ( " trimorphic " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " not ▁ trimporphic " ) NEW_LINE DEDENT
import sys NEW_LINE def checkTrimorphic ( num ) : NEW_LINE INDENT cube = num * num * num NEW_LINE while ( num > 0 ) : NEW_LINE INDENT if ( num % 10 != cube % 10 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = int ( num / 10 ) NEW_LINE cube = int ( cube / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def nthTrimorphic ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( sys . maxsize ) : NEW_LINE INDENT if ( checkTrimorphic ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 9 NEW_LINE print ( nthTrimorphic ( n ) ) NEW_LINE DEDENT
def reachTarget ( target ) : NEW_LINE INDENT target = abs ( target ) NEW_LINE sum = 0 NEW_LINE step = 0 NEW_LINE while ( sum < target or ( sum - target ) % 2 != 0 ) : NEW_LINE INDENT step = step + 1 NEW_LINE sum = sum + step NEW_LINE DEDENT return step NEW_LINE DEDENT target = 5 NEW_LINE print ( reachTarget ( target ) ) NEW_LINE
def fifthPowerSum ( n ) : NEW_LINE INDENT return ( ( 2 * n * n * n * n * n * n ) + ( 6 * n * n * n * n * n ) + ( 5 * n * n * n * n ) - ( n * n ) ) // 12 NEW_LINE DEDENT n = 5 NEW_LINE print ( fifthPowerSum ( n ) ) NEW_LINE
def unitDigitXRaisedY ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( y ) : NEW_LINE INDENT res = ( res * x ) % 10 NEW_LINE DEDENT return res NEW_LINE DEDENT print ( unitDigitXRaisedY ( 4 , 2 ) ) NEW_LINE
def findDivisor ( x , y ) : NEW_LINE INDENT if ( x == y ) : NEW_LINE INDENT return y NEW_LINE DEDENT return 2 NEW_LINE DEDENT x = 3 NEW_LINE y = 16 NEW_LINE print ( findDivisor ( x , y ) ) NEW_LINE
def AvgofSquareN ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( i * i ) NEW_LINE DEDENT return sum / n NEW_LINE DEDENT n = 2 NEW_LINE print ( AvgofSquareN ( n ) ) NEW_LINE
import math NEW_LINE def sumofFactors ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 1 NEW_LINE for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE n = n // i NEW_LINE if ( i == 2 and count == 1 ) : NEW_LINE INDENT curr_sum = 0 NEW_LINE DEDENT curr_term = curr_term * i NEW_LINE curr_sum = curr_sum + curr_term NEW_LINE DEDENT res = res * curr_sum NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res = res * ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 18 NEW_LINE print ( sumofFactors ( n ) ) NEW_LINE
def focal_length_concave ( R ) : NEW_LINE INDENT return R / 2 NEW_LINE DEDENT def focal_length_convex ( R ) : NEW_LINE INDENT return - ( R / 2 ) NEW_LINE DEDENT R = 30 ; NEW_LINE print ( " Focal ▁ length ▁ of ▁ spherical ▁ concave ▁ mirror ▁ is ▁ : " , focal_length_concave ( R ) , " ▁ units " ) NEW_LINE print ( " Focal ▁ length ▁ of ▁ spherical ▁ convex ▁ mirror ▁ is ▁ : ▁ " , focal_length_convex ( R ) , " ▁ units " ) NEW_LINE
import math NEW_LINE def sumofoddFactors ( n ) : NEW_LINE INDENT res = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT count = 0 NEW_LINE curr_sum = 1 NEW_LINE curr_term = 1 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n = n // i NEW_LINE curr_term *= i NEW_LINE curr_sum += curr_term NEW_LINE DEDENT res *= curr_sum NEW_LINE DEDENT if n >= 2 : NEW_LINE INDENT res *= ( 1 + n ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 30 NEW_LINE print ( sumofoddFactors ( n ) ) NEW_LINE
def countSolutions ( n , val ) : NEW_LINE INDENT total = 0 NEW_LINE if n == 1 and val >= 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( val + 1 ) : NEW_LINE INDENT total += countSolutions ( n - 1 , val - i ) NEW_LINE DEDENT return total NEW_LINE DEDENT n = 5 NEW_LINE val = 20 NEW_LINE print ( countSolutions ( n , val ) ) NEW_LINE
N = 6 ; NEW_LINE def fib ( f , n ) : NEW_LINE INDENT f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f [ i ] = f [ i - 1 ] + f [ i - 2 ] ; NEW_LINE DEDENT DEDENT def fibcoef ( fc , f , n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT fc [ i ] [ 0 ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT k = j ; NEW_LINE while ( k > 0 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE fc [ i ] [ j ] *= f [ k ] ; NEW_LINE DEDENT k = 1 ; NEW_LINE while ( ( j + 1 ) != k ) : NEW_LINE INDENT fc [ i ] [ j ] /= f [ k ] ; NEW_LINE k += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def printFibonomialTriangle ( n ) : NEW_LINE INDENT f = [ 0 ] * ( N + 1 ) ; NEW_LINE fib ( f , n ) ; NEW_LINE dp = [ [ 0 for x in range ( N + 1 ) ] for y in range ( N + 1 ) ] ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 ; NEW_LINE dp [ i ] [ i ] = 1 ; NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT dp [ i ] [ j ] = ( f [ i - j + 1 ] * dp [ i - 1 ] [ j - 1 ] + f [ j - 1 ] * dp [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( dp [ i ] [ j ] , end = " ▁ " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT n = 6 ; NEW_LINE printFibonomialTriangle ( n ) ; NEW_LINE
import math NEW_LINE def sumofNterm ( a , d , b , r , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( ( a + ( i - 1 ) * d ) * ( b * math . pow ( r , i - 1 ) ) ) NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT a = 1 NEW_LINE d = 1 NEW_LINE b = 2 NEW_LINE r = 2 NEW_LINE n = 3 NEW_LINE print ( sumofNterm ( a , d , b , r , n ) ) NEW_LINE
def sumOfTheSeries ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT k = 2 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT sum = sum + k ; NEW_LINE k = k + 2 NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT n = 5 NEW_LINE ans = sumOfTheSeries ( n ) ; NEW_LINE print ( ans ) NEW_LINE
def sumOfSeries ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE i = 1 ; NEW_LINE while i <= n : NEW_LINE INDENT sum = sum + i * ( i + 1 ) * ( i + 2 ) NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
import math NEW_LINE def Series ( x , n ) : NEW_LINE INDENT sum = 1 NEW_LINE term = 1 NEW_LINE y = 2 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fct = 1 NEW_LINE for j in range ( 1 , y + 1 ) : NEW_LINE INDENT fct = fct * j NEW_LINE DEDENT term = term * ( - 1 ) NEW_LINE m = term * math . pow ( x , y ) / fct NEW_LINE sum = sum + m NEW_LINE y += 2 NEW_LINE DEDENT return sum NEW_LINE DEDENT x = 9 NEW_LINE n = 10 NEW_LINE print ( ' % .4f ' % Series ( x , n ) ) NEW_LINE
def Series ( x , n ) : NEW_LINE INDENT sum = 1 NEW_LINE term = 1 NEW_LINE fct = 1 NEW_LINE p = 1 NEW_LINE multi = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT fct = fct * multi * ( multi + 1 ) NEW_LINE p = p * x * x NEW_LINE term = ( - 1 ) * term NEW_LINE multi += 2 NEW_LINE sum = sum + ( term * p ) / fct NEW_LINE DEDENT return sum NEW_LINE DEDENT x = 9 NEW_LINE n = 10 NEW_LINE print ( ' % .4f ' % Series ( x , n ) ) NEW_LINE
def two_factor ( n ) : NEW_LINE INDENT twocount = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT twocount += 1 NEW_LINE n = int ( n / 2 ) NEW_LINE DEDENT return twocount NEW_LINE DEDENT def five_factor ( n ) : NEW_LINE INDENT fivecount = 0 NEW_LINE while n % 5 == 0 : NEW_LINE INDENT fivecount += 1 NEW_LINE n = int ( n / 5 ) NEW_LINE DEDENT return fivecount NEW_LINE DEDENT def find_con_zero ( arr , n ) : NEW_LINE INDENT twocount = 0 NEW_LINE fivecount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT twocount += two_factor ( arr [ i ] ) NEW_LINE fivecount += five_factor ( arr [ i ] ) NEW_LINE DEDENT if twocount < fivecount : NEW_LINE INDENT return twocount NEW_LINE DEDENT else : NEW_LINE INDENT return fivecount NEW_LINE DEDENT DEDENT arr = [ 100 , 10 , 5 , 25 , 35 , 14 ] NEW_LINE n = 6 NEW_LINE print ( find_con_zero ( arr , n ) ) NEW_LINE
def first ( a , b , c ) : NEW_LINE INDENT a %= b NEW_LINE for i in range ( 1 , b + 1 ) : NEW_LINE INDENT a = a * 10 NEW_LINE if int ( a / b ) == c : NEW_LINE INDENT return i NEW_LINE DEDENT a %= b NEW_LINE DEDENT return - 1 NEW_LINE DEDENT a = 1 NEW_LINE b = 4 NEW_LINE c = 5 NEW_LINE print ( first ( a , b , c ) ) NEW_LINE
def subsetDifference ( n ) : NEW_LINE INDENT s = int ( n * ( n + 1 ) / 2 ) NEW_LINE if n % 4 == 0 : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Difference ▁ = ▁ " , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT if n % 4 == 1 or n % 4 == 2 : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) + 1 ) NEW_LINE print ( " Difference ▁ = ▁ " , 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " First ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Second ▁ subset ▁ sum ▁ = ▁ " , int ( s / 2 ) ) NEW_LINE print ( " Difference ▁ = ▁ " , 0 ) NEW_LINE DEDENT DEDENT DEDENT n = 6 NEW_LINE subsetDifference ( n ) NEW_LINE
def timeToMeet ( s , v ) : NEW_LINE INDENT V = 3 * v / 2 ; NEW_LINE time = s / V ; NEW_LINE print ( time ) ; NEW_LINE DEDENT s = 25 ; NEW_LINE v = 56 ; NEW_LINE timeToMeet ( s , v ) ; NEW_LINE
def checksum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT print ( " - 1 ▁ 0 ▁ 1" ) NEW_LINE return 0 NEW_LINE DEDENT inc = 0 NEW_LINE if n > 0 : NEW_LINE INDENT inc = 1 NEW_LINE DEDENT else : NEW_LINE INDENT inc = - 1 NEW_LINE DEDENT for i in range ( 0 , n - 1 , inc ) : NEW_LINE INDENT if i + i + 1 + i + 2 == n : NEW_LINE INDENT print ( i , " ▁ " , i + 1 , " ▁ " , i + 2 ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT n = 6 NEW_LINE checksum ( n ) NEW_LINE
' NEW_LINE ' NEW_LINE def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= i : NEW_LINE INDENT if i % j == 0 : NEW_LINE INDENT if i / j == j : NEW_LINE INDENT sum += j NEW_LINE DEDENT else : NEW_LINE INDENT sum += j + i / j NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE DEDENT DEDENT return int ( sum ) NEW_LINE DEDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE
def printbinomial ( max ) : NEW_LINE INDENT for m in range ( max + 1 ) : NEW_LINE INDENT print ( ' % ▁ 2d ' % m , end = ' ▁ ' ) NEW_LINE binom = 1 NEW_LINE for x in range ( m + 1 ) : NEW_LINE INDENT if m != 0 and x != 0 : NEW_LINE INDENT binom = binom * ( m - x + 1 ) / x NEW_LINE DEDENT print ( ' % ▁ 4d ' % binom , end = ' ▁ ' ) NEW_LINE DEDENT print ( " " , end = ' ' ) NEW_LINE DEDENT DEDENT max = 10 NEW_LINE printbinomial ( max ) NEW_LINE
import math NEW_LINE def maxPrimeFactors ( n ) : NEW_LINE INDENT maxPrime = - 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT maxPrime = 2 NEW_LINE DEDENT while n % 3 == 0 : NEW_LINE INDENT maxPrime = 3 NEW_LINE n = n / 3 NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) ) + 1 , 6 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT maxPrime = i NEW_LINE n = n / i NEW_LINE DEDENT while n % ( i + 2 ) == 0 : NEW_LINE INDENT maxPrime = i + 2 NEW_LINE n = n / ( i + 2 ) NEW_LINE DEDENT DEDENT if n > 4 : NEW_LINE INDENT maxPrime = n NEW_LINE DEDENT return int ( maxPrime ) NEW_LINE DEDENT n = 15 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE n = 25698751364526 NEW_LINE print ( maxPrimeFactors ( n ) ) NEW_LINE
' NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countUnsetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE DEDENT ' NEW_LINE INDENT return ( r - l + 1 ) - countSetBits ( n & num ) NEW_LINE DEDENT n = 80 NEW_LINE l = 1 NEW_LINE r = 4 NEW_LINE print ( countUnsetBitsInGivenRange ( n , l , r ) ) NEW_LINE
def evenPowerSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = 2 * i ; NEW_LINE sum = sum + ( j * j * j * j ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( evenPowerSum ( n ) ) ; NEW_LINE
def evenPowerSum ( n ) : NEW_LINE INDENT return ( 8 * n * ( n + 1 ) * ( 2 * n + 1 ) * ( 3 * n * n + 3 * n - 1 ) ) / 15 ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( int ( evenPowerSum ( n ) ) ) ; NEW_LINE
MAX = 501 NEW_LINE def balancedprime ( n ) : NEW_LINE INDENT prime = [ True ] * ( MAX + 1 ) NEW_LINE p = 2 NEW_LINE while p * p <= MAX : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT i = p * 2 NEW_LINE while i <= MAX : NEW_LINE INDENT prime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT v = list ( ) NEW_LINE p = 3 NEW_LINE while p <= MAX : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT v . append ( p ) NEW_LINE DEDENT p = p + 2 NEW_LINE DEDENT count = 0 NEW_LINE i = 1 NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if v [ i ] == ( v [ i + 1 ] + v [ i - 1 ] ) / 2 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if count == n : NEW_LINE INDENT return v [ i ] NEW_LINE DEDENT DEDENT DEDENT n = 4 NEW_LINE print ( balancedprime ( n ) ) NEW_LINE
MAX = 100001 ; NEW_LINE factor = [ 0 ] * MAX ; NEW_LINE def generatePrimeFactors ( ) : NEW_LINE INDENT factor [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i ; NEW_LINE DEDENT i = 4 NEW_LINE while ( i < MAX ) : NEW_LINE INDENT factor [ i ] = 2 ; NEW_LINE i += 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i < MAX ) : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT j = i * i ; NEW_LINE while ( j < MAX ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i ; NEW_LINE DEDENT j += i ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def calculateNoOFactors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT ans = 1 ; NEW_LINE dup = factor [ n ] ; NEW_LINE c = 1 ; NEW_LINE j = int ( n / factor [ n ] ) ; NEW_LINE while ( j != 1 ) : NEW_LINE INDENT if ( factor [ j ] == dup ) : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT dup = factor [ j ] ; NEW_LINE ans = ans * ( c + 1 ) ; NEW_LINE c = 1 ; NEW_LINE DEDENT j = int ( j / factor [ j ] ) ; NEW_LINE DEDENT ans = ans * ( c + 1 ) ; NEW_LINE return ans ; NEW_LINE DEDENT def smallest ( n ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( calculateNoOFactors ( i ) >= n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT generatePrimeFactors ( ) ; NEW_LINE n = 4 ; NEW_LINE print ( smallest ( n ) ) ; NEW_LINE
def squaresum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sm = sm + ( i * i ) NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 4 NEW_LINE print ( squaresum ( n ) ) NEW_LINE
def isPrime ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def minimumSum ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( isPrime ( n - 2 ) ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return 3 NEW_LINE DEDENT n = 27 NEW_LINE print ( minimumSum ( n ) ) NEW_LINE
def firstDigit ( n ) : NEW_LINE INDENT while n >= 10 : NEW_LINE INDENT n = n / 10 ; NEW_LINE DEDENT return int ( n ) NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT n = 98562 ; NEW_LINE print ( firstDigit ( n ) , end = " ▁ " ) NEW_LINE print ( lastDigit ( n ) ) NEW_LINE
import math NEW_LINE def firstDigit ( n ) : NEW_LINE INDENT digits = ( int ) ( math . log10 ( n ) ) NEW_LINE n = ( int ) ( n / pow ( 10 , digits ) ) NEW_LINE return n ; NEW_LINE DEDENT def lastDigit ( n ) : NEW_LINE INDENT return ( n % 10 ) NEW_LINE DEDENT n = 98562 ; NEW_LINE print ( firstDigit ( n ) , end = " ▁ " ) NEW_LINE print ( lastDigit ( n ) ) NEW_LINE
def isPrime ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 2 NEW_LINE while i * i <= x : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def findPrimes ( n ) : NEW_LINE INDENT if ( isPrime ( n ) ) : NEW_LINE INDENT print ( n , end = " ▁ " ) NEW_LINE DEDENT elif ( isPrime ( n - 2 ) ) : NEW_LINE INDENT print ( "2" , end = " ▁ " ) NEW_LINE print ( n - 2 , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "3" , end = " ▁ " ) NEW_LINE n = n - 3 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT if ( isPrime ( i ) and isPrime ( n - i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE print ( ( n - i ) , end = " ▁ " ) NEW_LINE break NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT DEDENT n = 27 ; NEW_LINE findPrimes ( n ) ; NEW_LINE
c = [ 0 ] * 100 ; NEW_LINE def coef ( n ) : NEW_LINE INDENT c [ 0 ] = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ 1 + i ] = 1 ; NEW_LINE for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT c [ j ] = c [ j - 1 ] - c [ j ] ; NEW_LINE DEDENT c [ 0 ] = - c [ 0 ] ; NEW_LINE DEDENT DEDENT def isPrime ( n ) : NEW_LINE INDENT coef ( n ) ; NEW_LINE c [ 0 ] = c [ 0 ] + 1 ; NEW_LINE c [ n ] = c [ n ] - 1 ; NEW_LINE i = n ; NEW_LINE while ( i > - 1 and c [ i ] % n == 0 ) : NEW_LINE INDENT i = i - 1 ; NEW_LINE DEDENT return True if i < 0 else False ; NEW_LINE DEDENT n = 37 ; NEW_LINE if ( isPrime ( n ) ) : NEW_LINE INDENT print ( " Prime " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Prime " ) ; NEW_LINE DEDENT
def motzkin ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( ( 2 * n + 1 ) * motzkin ( n - 1 ) + ( 3 * n - 3 ) * motzkin ( n - 2 ) ) / ( n + 2 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( motzkin ( n ) ) NEW_LINE
import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return ( ( 0.666 ) * ( 1 - 1 / pow ( 10 , n ) ) ) ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( sumOfSeries ( n ) ) ; NEW_LINE
def countDigit ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 1 + countDigit ( n // 10 ) ) NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT l = countDigit ( n ) NEW_LINE dup = n ; sm = 0 NEW_LINE while ( dup ) : NEW_LINE INDENT sm = sm + pow ( dup % 10 , l ) NEW_LINE dup = dup // 10 NEW_LINE DEDENT return ( n == sm ) NEW_LINE DEDENT n = 1634 NEW_LINE if ( check ( n ) ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT
def summation ( n ) : NEW_LINE INDENT return sum ( [ i ** 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def leyland ( n ) : NEW_LINE INDENT ans = [ ] NEW_LINE x = 2 NEW_LINE y = 2 NEW_LINE while x <= n : NEW_LINE INDENT y = 2 NEW_LINE while y <= x : NEW_LINE INDENT temp = pow ( x , y ) + pow ( y , x ) NEW_LINE ans . append ( temp ) ; NEW_LINE y = y + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT ans . sort ( ) ; NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT n = 6 NEW_LINE leyland ( n ) NEW_LINE
def kthgroupsum ( k ) : NEW_LINE INDENT cur = int ( ( k * ( k - 1 ) ) + 1 ) NEW_LINE sum = 0 NEW_LINE while k : NEW_LINE INDENT sum += cur NEW_LINE cur += 2 NEW_LINE k = k - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT k = 3 NEW_LINE print ( kthgroupsum ( k ) ) NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT n = 4 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE
def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE
def cal_speed ( dist , time ) : NEW_LINE INDENT print ( " ▁ Distance ( km ) ▁ : " , dist ) ; NEW_LINE print ( " ▁ Time ( hr ) ▁ : " , time ) ; NEW_LINE return dist / time ; NEW_LINE DEDENT def cal_dis ( speed , time ) : NEW_LINE INDENT print ( " ▁ Time ( hr ) ▁ : " , time ) ; NEW_LINE print ( " ▁ Speed ( km ▁ / ▁ hr ) ▁ : " , speed ) ; NEW_LINE return speed * time ; NEW_LINE DEDENT def cal_time ( dist , speed ) : NEW_LINE INDENT print ( " ▁ Distance ( km ) ▁ : " , dist ) ; NEW_LINE print ( " ▁ Speed ( km ▁ / ▁ hr ) ▁ : " , speed ) ; NEW_LINE return speed * dist ; NEW_LINE DEDENT print ( " ▁ The ▁ calculated ▁ Speed ( km ▁ / ▁ hr ) ▁ is ▁ : " , cal_speed ( 45.9 , 2.0 ) ) ; NEW_LINE print ( " " ) ; NEW_LINE print ( " ▁ The ▁ calculated ▁ Distance ( km ) ▁ : " , cal_dis ( 62.9 , 2.5 ) ) ; NEW_LINE print ( " " ) ; NEW_LINE print ( " ▁ The ▁ calculated ▁ Time ( hr ) ▁ : " , cal_time ( 48.0 , 4.5 ) ) ; NEW_LINE
def term ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = ans + i NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 4 NEW_LINE print ( term ( n ) ) NEW_LINE
def avgOfFirstN ( n ) : NEW_LINE INDENT return ( float ) ( 1 + n ) / 2 ; NEW_LINE DEDENT n = 20 NEW_LINE print ( avgOfFirstN ( n ) ) NEW_LINE
import math NEW_LINE def summation ( n ) : NEW_LINE INDENT return int ( ( pow ( 10 , n + 1 ) - 10 - ( 9 * n ) ) / 81 ) ; NEW_LINE DEDENT print ( summation ( 5 ) ) ; NEW_LINE
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE multi = x NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT total = total + multi / i NEW_LINE multi = multi * x NEW_LINE DEDENT return total NEW_LINE DEDENT x = 2 NEW_LINE n = 5 NEW_LINE print ( round ( sum ( x , n ) , 2 ) ) NEW_LINE
import math NEW_LINE def term ( n ) : NEW_LINE INDENT x = ( ( ( 1 ) + math . sqrt ( 1 + ( 8 * n ) ) ) / 2 ) NEW_LINE return x NEW_LINE DEDENT n = 5 NEW_LINE print ( int ( term ( n ) ) ) NEW_LINE
def countDigits ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return c NEW_LINE DEDENT def isDeserium ( x ) : NEW_LINE INDENT temp = x NEW_LINE p = countDigits ( x ) NEW_LINE sum = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = int ( x % 10 ) NEW_LINE sum += pow ( digit , p ) NEW_LINE p -= 1 NEW_LINE x = int ( x / 10 ) NEW_LINE DEDENT return ( sum == temp ) NEW_LINE DEDENT x = 135 NEW_LINE if ( isDeserium ( x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def sameRemainder ( a , b , c ) : NEW_LINE INDENT a1 = ( b - a ) NEW_LINE b1 = ( c - b ) NEW_LINE c1 = ( c - a ) NEW_LINE return gcd ( a1 , gcd ( b1 , c1 ) ) NEW_LINE DEDENT a = 62 NEW_LINE b = 132 NEW_LINE c = 237 NEW_LINE print ( sameRemainder ( a , b , c ) ) NEW_LINE
def mean ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + arr [ i ] ; NEW_LINE DEDENT mean = sum / n ; NEW_LINE return mean ; NEW_LINE DEDENT def sd ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + ( ( arr [ i ] - mean ( arr , n ) ) * ( arr [ i ] - mean ( arr , n ) ) ) ; NEW_LINE DEDENT sdd = sum / n ; NEW_LINE return sdd ; NEW_LINE DEDENT def combinedVariance ( arr1 , arr2 , n , m ) : NEW_LINE INDENT mean1 = mean ( arr1 , n ) ; NEW_LINE mean2 = mean ( arr2 , m ) ; NEW_LINE print ( " Mean1 : ▁ " , round ( mean1 , 2 ) , " ▁ mean2 : ▁ " , round ( mean2 , 2 ) ) ; NEW_LINE sd1 = sd ( arr1 , n ) ; NEW_LINE sd2 = sd ( arr2 , m ) ; NEW_LINE print ( " StandardDeviation1 : ▁ " , round ( sd1 , 2 ) , " ▁ StandardDeviation2 : ▁ " , round ( sd2 , 2 ) ) ; NEW_LINE combinedMean = ( n * mean1 + m * mean2 ) / ( n + m ) ; NEW_LINE print ( " Combined ▁ Mean : ▁ " , round ( combinedMean , 2 ) ) ; NEW_LINE d1_square = ( ( mean1 - combinedMean ) * ( mean1 - combinedMean ) ) ; NEW_LINE d2_square = ( ( mean2 - combinedMean ) * ( mean2 - combinedMean ) ) ; NEW_LINE print ( " d1 ▁ square : ▁ " , round ( d1_square , 2 ) , " ▁ d2 _ square : ▁ " , round ( d2_square , 2 ) ) ; NEW_LINE combinedVar = ( n * ( sd1 + d1_square ) + m * ( sd2 + d2_square ) ) / ( n + m ) ; NEW_LINE print ( " Combined ▁ Variance : ▁ " , round ( combinedVar , 2 ) ) ; NEW_LINE DEDENT arr1 = [ 23 , 45 , 34 , 78 , 12 , 76 , 34 ] ; NEW_LINE arr2 = [ 65 , 67 , 34 , 23 , 45 ] ; NEW_LINE n = len ( arr1 ) ; NEW_LINE m = len ( arr2 ) ; NEW_LINE combinedVariance ( arr1 , arr2 , n , m ) ; NEW_LINE
def checkDivisibility ( num ) : NEW_LINE INDENT length = len ( num ) NEW_LINE if ( length == 1 and num [ 0 ] == '0' ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( length % 3 == 1 ) : NEW_LINE INDENT num = str ( num ) + "00" NEW_LINE length += 2 NEW_LINE DEDENT elif ( length % 3 == 2 ) : NEW_LINE INDENT num = str ( num ) + "0" NEW_LINE length += 1 NEW_LINE DEDENT sum = 0 NEW_LINE p = 1 NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT group = 0 NEW_LINE group += ord ( num [ i ] ) - ord ( '0' ) NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 10 NEW_LINE i -= 1 NEW_LINE group += ( ord ( num [ i ] ) - ord ( '0' ) ) * 100 NEW_LINE sum = sum + group * p NEW_LINE p *= ( - 1 ) NEW_LINE DEDENT sum = abs ( sum ) NEW_LINE return ( sum % 13 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT number = "83959092724" NEW_LINE if ( checkDivisibility ( number ) ) : NEW_LINE INDENT print ( number , " is ▁ divisible ▁ by ▁ 13 . " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( number , " is ▁ not ▁ divisible ▁ by ▁ 13 . " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def modularEquation ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT print ( " No ▁ solution ▁ possible ▁ " ) NEW_LINE return NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT print ( " Infinite ▁ Solution ▁ possible ▁ " ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE n = a - b NEW_LINE y = ( int ) ( math . sqrt ( a - b ) ) NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT if ( y * y == n and y > b ) : NEW_LINE INDENT count = count - 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT a = 21 NEW_LINE b = 5 NEW_LINE modularEquation ( a , b ) NEW_LINE
def judgeSquareSum ( n ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( i % 4 == 3 and count % 2 != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return n % 4 != 3 ; NEW_LINE DEDENT n = 17 ; NEW_LINE if ( judgeSquareSum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT divider = i * 10 ; NEW_LINE countr += ( int ( n / divider ) * i + min ( max ( n % divider - i + 1 , 0 ) , i ) ) ; NEW_LINE i *= 10 ; NEW_LINE DEDENT return countr ; NEW_LINE DEDENT n = 13 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE n = 113 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE n = 205 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE
def isPrime ( c ) : NEW_LINE INDENT return ( c == '2' or c == '3' or c == '5' or c == '7' ) NEW_LINE DEDENT def decrease ( s , i ) : NEW_LINE INDENT if ( s [ i ] <= '2' ) : NEW_LINE INDENT s . pop ( i ) NEW_LINE s [ i ] = '7' NEW_LINE DEDENT elif ( s [ i ] == '3' ) : NEW_LINE INDENT s [ i ] = '2' NEW_LINE DEDENT elif ( s [ i ] <= '5' ) : NEW_LINE INDENT s [ i ] = '3' NEW_LINE DEDENT elif ( s [ i ] <= '7' ) : NEW_LINE INDENT s [ i ] = '5' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = '7' NEW_LINE DEDENT DEDENT def primeDigits ( s ) : NEW_LINE INDENT s = [ i for i in s ] NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ( isPrime ( s [ i ] ) == False ) : NEW_LINE INDENT while ( s [ i ] <= '2' and i >= 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i < 0 ) : NEW_LINE INDENT i = 0 NEW_LINE decrease ( s , i ) NEW_LINE DEDENT else : NEW_LINE INDENT decrease ( s , i ) NEW_LINE DEDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT s [ j ] = '7' NEW_LINE DEDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return " " . join ( s ) NEW_LINE DEDENT s = "45" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = "1000" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = "7721" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = "7221" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = "74545678912345689748593275897894708927680" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE
import math as mt NEW_LINE def greatest ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE a = [ 0 for i in range ( n ) ] NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE Sum += a [ i ] NEW_LINE if ( a [ n - 2 ] % 2 != 0 or ( Sum - a [ n - 1 ] ) % 3 != 0 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT re = Sum % 3 NEW_LINE dell = - 1 NEW_LINE flag = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( ( a [ i ] ) % 3 == re ) : NEW_LINE INDENT if ( a [ i + 1 ] > a [ i ] ) : NEW_LINE INDENT dell = i NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT dell = i NEW_LINE DEDENT DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT if ( a [ n - 2 ] % 2 == 0 and re == a [ n - 1 ] % 3 ) : NEW_LINE INDENT dell = n - 1 NEW_LINE DEDENT DEDENT if ( dell == - 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( dell + 1 ) NEW_LINE DEDENT DEDENT DEDENT s = "7510222" NEW_LINE greatest ( s ) NEW_LINE
def asPowerSum ( w , m ) : NEW_LINE INDENT while ( m > 0 ) : NEW_LINE INDENT if ( ( m - 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m - 1 ) / w ; NEW_LINE DEDENT elif ( ( m + 1 ) % w == 0 ) : NEW_LINE INDENT m = ( m + 1 ) / w ; NEW_LINE DEDENT elif ( m % w == 0 ) : NEW_LINE INDENT m = m / w ; NEW_LINE DEDENT else : NEW_LINE DEDENT return ( m == 0 ) ; NEW_LINE DEDENT w = 3 ; NEW_LINE m = 7 ; NEW_LINE if ( asPowerSum ( w , m ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def divisible ( num ) : NEW_LINE INDENT n = len ( num ) NEW_LINE sum_ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum_ += int ( num [ i ] ) NEW_LINE DEDENT if ( sum_ % 3 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( sum_ % 3 == int ( num [ i ] ) % 3 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( n == 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = "1234" NEW_LINE print ( divisible ( num ) ) NEW_LINE DEDENT
n = 3 NEW_LINE def dotProduct ( vect_A , vect_B ) : NEW_LINE INDENT product = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product + vect_A [ i ] * vect_B [ i ] NEW_LINE DEDENT return product NEW_LINE DEDENT def crossProduct ( vect_A , vect_B , cross_P ) : NEW_LINE INDENT cross_P . append ( vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ) NEW_LINE cross_P . append ( vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ) NEW_LINE cross_P . append ( vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT vect_A = [ 3 , - 5 , 4 ] NEW_LINE vect_B = [ 2 , 6 , 5 ] NEW_LINE cross_P = [ ] NEW_LINE print ( " Dot ▁ product : " , end = " ▁ " ) NEW_LINE print ( dotProduct ( vect_A , vect_B ) ) NEW_LINE print ( " Cross ▁ product : " , end = " ▁ " ) NEW_LINE crossProduct ( vect_A , vect_B , cross_P ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( cross_P [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
MOD = 1e9 + 7 NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( 1 * res * x ) % p NEW_LINE DEDENT x = ( 1 * x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def countEvenWays ( n ) : NEW_LINE INDENT return power ( 2 , n / 2 - 1 , MOD ) NEW_LINE DEDENT n = 6 NEW_LINE print ( int ( countEvenWays ( n ) ) ) NEW_LINE n = 8 NEW_LINE print ( int ( countEvenWays ( n ) ) ) NEW_LINE
MAX = 1000001 NEW_LINE factor = [ 0 ] * MAX NEW_LINE def cal_factor ( ) : NEW_LINE INDENT factor [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT factor [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAX , 2 ) : NEW_LINE INDENT factor [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while i * i < MAX : NEW_LINE INDENT if ( factor [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAX , i ) : NEW_LINE INDENT if ( factor [ j ] == j ) : NEW_LINE INDENT factor [ j ] = i NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def no_of_representations ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE flag = 0 NEW_LINE while ( factor [ temp ] != 1 ) : NEW_LINE INDENT flag = - 1 NEW_LINE count += 1 NEW_LINE temp = temp // factor [ temp ] NEW_LINE DEDENT count += flag NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT cal_factor ( ) NEW_LINE a = [ 4 , 4 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( no_of_representations ( a , n ) ) NEW_LINE DEDENT
def coutSubSeq ( A , N , M ) : NEW_LINE INDENT sum = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT for k in range ( j + 1 , N ) : NEW_LINE INDENT sum = A [ i ] + A [ j ] + A [ k ] NEW_LINE if ( sum % M == 0 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT M = 3 NEW_LINE A = [ 1 , 2 , 4 , 3 ] NEW_LINE N = len ( A ) NEW_LINE print coutSubSeq ( A , N , M ) NEW_LINE
def countSubSeq ( A , N , M ) : NEW_LINE INDENT ans = 0 NEW_LINE h = [ 0 ] * M NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT A [ i ] = A [ i ] % M NEW_LINE h [ A [ i ] ] = h [ A [ i ] ] + 1 NEW_LINE DEDENT for i in range ( 0 , M ) : NEW_LINE INDENT for j in range ( i , M ) : NEW_LINE INDENT rem = ( M - ( i + j ) % M ) % M NEW_LINE if ( rem < j ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == j and rem == j ) : NEW_LINE INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * ( h [ i ] - 2 ) / 6 NEW_LINE DEDENT elif ( i == j ) : NEW_LINE INDENT ans = ans + ( h [ i ] * ( h [ i ] - 1 ) * h [ rem ] / 2 ) NEW_LINE DEDENT elif ( i == rem ) : NEW_LINE INDENT ans = ans + h [ i ] * ( h [ i ] - 1 ) * h [ j ] / 2 NEW_LINE DEDENT elif ( rem == j ) : NEW_LINE INDENT ans = ans + h [ j ] * ( h [ j ] - 1 ) * h [ i ] / 2 NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + h [ i ] * h [ j ] * h [ rem ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT M = 3 ; NEW_LINE A = [ 1 , 2 , 4 , 3 ] NEW_LINE N = len ( A ) NEW_LINE print ( countSubSeq ( A , N , M ) ) NEW_LINE
def findTerm ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT term = 7 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT term = term * 2 + ( i - 1 ) ; NEW_LINE DEDENT DEDENT return term ; NEW_LINE DEDENT print ( findTerm ( 5 ) ) NEW_LINE
def findNumber ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE i = 1 NEW_LINE while n >= 0 : NEW_LINE INDENT n -= i NEW_LINE i += 1 NEW_LINE DEDENT return ( n + i ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findNumber ( n ) ) NEW_LINE
import math NEW_LINE def correlationCoefficient ( X , Y , n ) : NEW_LINE INDENT sum_X = 0 NEW_LINE sum_Y = 0 NEW_LINE sum_XY = 0 NEW_LINE squareSum_X = 0 NEW_LINE squareSum_Y = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum_X = sum_X + X [ i ] NEW_LINE sum_Y = sum_Y + Y [ i ] NEW_LINE sum_XY = sum_XY + X [ i ] * Y [ i ] NEW_LINE squareSum_X = squareSum_X + X [ i ] * X [ i ] NEW_LINE squareSum_Y = squareSum_Y + Y [ i ] * Y [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT corr = ( float ) ( n * sum_XY - sum_X * sum_Y ) / NEW_LINE INDENT ( float ) ( math . sqrt ( ( n * squareSum_X - sum_X * sum_X ) * ( n * squareSum_Y - sum_Y * sum_Y ) ) ) NEW_LINE DEDENT return corr NEW_LINE DEDENT X = [ 15 , 18 , 21 , 24 , 27 ] NEW_LINE Y = [ 25 , 25 , 27 , 31 , 32 ] NEW_LINE n = len ( X ) NEW_LINE print ( ' { 0 : . 6f } ' . format ( correlationCoefficient ( X , Y , n ) ) ) NEW_LINE
def result ( n , k , t ) : NEW_LINE INDENT if ( t <= k ) : NEW_LINE INDENT print ( t ) NEW_LINE DEDENT elif ( t <= n ) : NEW_LINE INDENT print ( k ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = t - n NEW_LINE temp = k - temp NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE k = 5 NEW_LINE t = 12 NEW_LINE result ( n , k , t ) NEW_LINE
def weightedMean ( X , W , n ) : NEW_LINE INDENT sum = 0 NEW_LINE numWeight = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT numWeight = numWeight + X [ i ] * W [ i ] NEW_LINE sum = sum + W [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT return ( float ) ( numWeight / sum ) NEW_LINE DEDENT X = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE W = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( X ) NEW_LINE m = len ( W ) NEW_LINE if ( n == m ) : NEW_LINE INDENT print weightedMean ( X , W , n ) NEW_LINE DEDENT else : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT
import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT return gcd ( b , a ) NEW_LINE DEDENT if ( abs ( b ) < 0.001 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( b , a - math . floor ( a / b ) * b ) ) NEW_LINE DEDENT DEDENT a = 1.20 NEW_LINE b = 22.5 NEW_LINE print ( ' { 0 : . 1f } ' . format ( gcd ( a , b ) ) ) NEW_LINE
def harmonicMean ( arr , n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + ( 1 ) / arr [ i ] ; NEW_LINE DEDENT return n / sm NEW_LINE DEDENT arr = [ 13.5 , 14.5 , 14.8 , 15.2 , 16.1 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( harmonicMean ( arr , n ) ) NEW_LINE
def harmonicMean ( arr , freq , n ) : NEW_LINE INDENT sm = 0 NEW_LINE frequency_sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sm = sm + freq [ i ] / arr [ i ] NEW_LINE frequency_sum = frequency_sum + freq [ i ] NEW_LINE DEDENT return ( round ( frequency_sum / sm , 4 ) ) NEW_LINE DEDENT num = [ 13 , 14 , 15 , 16 , 17 ] NEW_LINE freq = [ 2 , 5 , 13 , 7 , 3 ] NEW_LINE n = len ( num ) NEW_LINE print ( harmonicMean ( num , freq , n ) ) NEW_LINE
def point ( a , b , c , d , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT x = b + i * a NEW_LINE if ( x - d ) % c == 0 and x - d >= 0 : NEW_LINE INDENT print x NEW_LINE return NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print " No ▁ collision ▁ point " NEW_LINE DEDENT DEDENT a = 20 NEW_LINE b = 2 NEW_LINE c = 9 NEW_LINE d = 19 NEW_LINE n = 20 NEW_LINE point ( a , b , c , d , n ) NEW_LINE
import math NEW_LINE def findArmstrong ( low , high ) : NEW_LINE INDENT for i in range ( low + 1 , high ) : NEW_LINE INDENT x = i NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x / 10 NEW_LINE n = n + 1 NEW_LINE DEDENT pow_sum = 0 NEW_LINE x = i NEW_LINE while ( x != 0 ) : NEW_LINE INDENT digit = x % 10 NEW_LINE pow_sum = pow_sum + math . pow ( digit , n ) NEW_LINE x = x / 10 NEW_LINE DEDENT if ( pow_sum == i ) : NEW_LINE INDENT print ( str ( i ) + " ▁ " ) , NEW_LINE DEDENT DEDENT DEDENT num1 = 100 NEW_LINE num2 = 400 NEW_LINE findArmstrong ( num1 , num2 ) NEW_LINE print ( " " ) NEW_LINE
def gcdMax ( a , b , n , N ) : NEW_LINE INDENT cnt = [ 0 ] * N NEW_LINE first = [ 0 ] * N NEW_LINE second = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ a [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] ) : NEW_LINE INDENT first [ i ] = max ( first [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT cnt = [ 0 ] * N NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ b [ i ] ] = 1 NEW_LINE DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT if ( cnt [ j ] > 0 ) : NEW_LINE INDENT second [ i ] = max ( second [ i ] , j ) NEW_LINE DEDENT DEDENT DEDENT i = N - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if ( first [ i ] > 0 and second [ i ] > 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( str ( first [ i ] ) + " ▁ " + str ( second [ i ] ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 1 , 4 , 2 , 8 ] NEW_LINE b = [ 5 , 2 , 12 , 8 , 3 ] NEW_LINE n = len ( a ) NEW_LINE N = 20 NEW_LINE gcdMax ( a , b , n , N ) NEW_LINE DEDENT
def printPierpont ( n ) : NEW_LINE INDENT arr = [ False ] * ( n + 1 ) ; NEW_LINE two = 1 ; NEW_LINE three = 1 ; NEW_LINE while ( two + 1 < n ) : NEW_LINE INDENT arr [ two ] = True ; NEW_LINE while ( two * three + 1 < n ) : NEW_LINE INDENT arr [ three ] = True ; NEW_LINE arr [ two * three ] = True ; NEW_LINE three *= 3 ; NEW_LINE DEDENT three = 1 ; NEW_LINE two *= 2 ; NEW_LINE DEDENT v = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT v . append ( i + 1 ) ; NEW_LINE DEDENT DEDENT arr1 = [ False ] * ( len ( arr ) ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p < n ) : NEW_LINE INDENT if ( arr1 [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT arr1 [ i ] = True ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT if ( not arr1 [ v [ i ] ] ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT n = 200 ; NEW_LINE printPierpont ( n ) ; NEW_LINE
def isWoodall ( x ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( x == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT p = 0 NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x / 2 NEW_LINE p = p + 1 NEW_LINE if ( p == x ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT x = 383 NEW_LINE if ( isWoodall ( x ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def print_result ( a , n , k , m ) : NEW_LINE INDENT v = [ [ ] for i in range ( m ) ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT rem = a [ i ] % m NEW_LINE v [ rem ] . append ( a [ i ] ) NEW_LINE if ( len ( v [ rem ] ) == k ) : NEW_LINE INDENT for j in range ( 0 , k ) : NEW_LINE INDENT print ( v [ rem ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 8 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print_result ( a , n , 2 , 3 ) NEW_LINE DEDENT
def smallestX ( n ) : NEW_LINE INDENT temp = [ 0 ] * 10 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT count = 0 NEW_LINE x = 1 NEW_LINE while ( count < 10 ) : NEW_LINE INDENT y = x * n NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( temp [ y % 10 ] == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE temp [ y % 10 ] = 1 NEW_LINE DEDENT y = int ( y / 10 ) NEW_LINE DEDENT x += 1 NEW_LINE DEDENT return x - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( smallestX ( n ) ) NEW_LINE DEDENT
def digSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE rem = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE sum = sum + rem ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def findX ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT if ( i + digSum ( i ) == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT n = 43 ; NEW_LINE print ( " x ▁ = ▁ " , findX ( n ) ) ; NEW_LINE
def complement ( number ) : NEW_LINE INDENT for i in range ( 0 , len ( number ) ) : NEW_LINE INDENT if ( number [ i ] != ' . ' ) : NEW_LINE INDENT a = 9 - int ( number [ i ] ) NEW_LINE number = ( number [ : i ] + str ( a ) + number [ i + 1 : ] ) NEW_LINE DEDENT DEDENT print ( "9 ' s ▁ complement ▁ is ▁ : ▁ " , number ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT number = "345.45" NEW_LINE complement ( number ) NEW_LINE DEDENT
def countWays ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while ( ( i * i ) < n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT n = 12 NEW_LINE print ( countWays ( n ) ) NEW_LINE
import math NEW_LINE def isDigitPresent ( m , Hash ) : NEW_LINE INDENT while ( m ) : NEW_LINE INDENT if ( Hash [ m % 10 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT m = m // 10 NEW_LINE DEDENT return False NEW_LINE DEDENT def countDivisibles ( n ) : NEW_LINE INDENT Hash = [ False for i in range ( 10 ) ] NEW_LINE m = n NEW_LINE while ( m ) : NEW_LINE INDENT Hash [ m % 10 ] = True NEW_LINE m = m // 10 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( isDigitPresent ( i , Hash ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if ( n // i != i ) : NEW_LINE INDENT if ( isDigitPresent ( n // i , Hash ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT n = 15 NEW_LINE print ( countDivisibles ( n ) ) NEW_LINE
MAX = 100 NEW_LINE def luDecomposition ( mat , n ) : NEW_LINE INDENT lower = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE upper = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for k in range ( i , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ( lower [ i ] [ j ] * upper [ j ] [ k ] ) NEW_LINE DEDENT upper [ i ] [ k ] = mat [ i ] [ k ] - sum NEW_LINE DEDENT for k in range ( i , n ) : NEW_LINE INDENT if ( i == k ) : NEW_LINE else : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ( lower [ k ] [ j ] * upper [ j ] [ i ] ) NEW_LINE DEDENT lower [ k ] [ i ] = int ( ( mat [ k ] [ i ] - sum ) / upper [ i ] [ i ] ) NEW_LINE DEDENT DEDENT DEDENT print ( " Lower ▁ Triangular TABSYMBOL TABSYMBOL Upper ▁ Triangular " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( lower [ i ] [ j ] , end = " TABSYMBOL " ) NEW_LINE DEDENT print ( " " , end = " TABSYMBOL " ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT print ( upper [ i ] [ j ] , end = " TABSYMBOL " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT DEDENT mat = [ [ 2 , - 1 , - 2 ] , [ - 4 , 6 , 3 ] , [ - 4 , - 2 , 8 ] ] NEW_LINE luDecomposition ( mat , 3 ) NEW_LINE
' NEW_LINE def printTwoDivisibleParts ( num , f , s ) : NEW_LINE INDENT N = len ( num ) ; NEW_LINE prefixReminder = [ 0 ] * ( N + 1 ) ; NEW_LINE suffixReminder = [ 0 ] * ( N + 1 ) ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT suffixReminder [ i ] = ( suffixReminder [ i - 1 ] * 10 + ( ord ( num [ i - 1 ] ) - 48 ) ) % f ; NEW_LINE DEDENT base = 1 ; NEW_LINE for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT prefixReminder [ i ] = ( prefixReminder [ i + 1 ] + ( ord ( num [ i ] ) - 48 ) * base ) % s ; NEW_LINE base = ( base * 10 ) % s ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( prefixReminder [ i ] == 0 and suffixReminder [ i ] == 0 and num [ i ] != '0' ) : NEW_LINE INDENT print ( num [ 0 : i ] , num [ i : N ] ) ; NEW_LINE return 0 ; NEW_LINE DEDENT DEDENT print ( " Not ▁ Possible " ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = "246904096" ; NEW_LINE f = 12345 ; NEW_LINE s = 1024 ; NEW_LINE printTwoDivisibleParts ( num , f , s ) ; NEW_LINE DEDENT
def sum ( n ) : NEW_LINE INDENT rem = 0 NEW_LINE sum_of_digits = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT rem = n % 10 NEW_LINE sum_of_digits += rem NEW_LINE n = n // 10 NEW_LINE DEDENT return sum_of_digits NEW_LINE DEDENT def count ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( n - 97 , n + 1 ) : NEW_LINE INDENT a = sum ( i ) NEW_LINE b = sum ( a ) NEW_LINE if ( ( i + a + b ) == n ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT n = 9939 NEW_LINE print ( count ( n ) ) NEW_LINE
def isPowerOfK ( n , k ) : NEW_LINE INDENT oneSeen = False NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % k NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( digit == 1 ) : NEW_LINE INDENT if ( oneSeen ) : NEW_LINE INDENT return False NEW_LINE DEDENT oneSeen = True NEW_LINE DEDENT n //= k NEW_LINE DEDENT return True NEW_LINE DEDENT n = 64 NEW_LINE k = 4 NEW_LINE if ( isPowerOfK ( n , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
MAX_DIGITS = 20 ; NEW_LINE def isOctal ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) >= 8 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT n = int ( n / 10 ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divide = 8 if ( isOctal ( n ) == False ) else 10 NEW_LINE octal = [ ] NEW_LINE while ( n != 0 ) : NEW_LINE INDENT octal . append ( n % divide ) NEW_LINE n = int ( n / divide ) NEW_LINE DEDENT j = len ( octal ) - 1 NEW_LINE k = 0 NEW_LINE while ( k <= j ) : NEW_LINE INDENT if ( octal [ j ] != octal [ k ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT j -= 1 NEW_LINE k += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 97 ; NEW_LINE if ( isPalindrome ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printFactorialNums ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE x = 2 NEW_LINE while fact <= n : NEW_LINE INDENT print ( fact , end = " ▁ " ) NEW_LINE fact = fact * x NEW_LINE x += 1 NEW_LINE DEDENT DEDENT n = 100 NEW_LINE printFactorialNums ( n ) NEW_LINE
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT k = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 5 , k , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isThreeDisctFactors ( n ) : NEW_LINE INDENT sq = int ( sqrt ( n ) ) NEW_LINE if ( 1 * sq * sq != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( isPrime ( sq ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = 9 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 15 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT num = 12397923568441 NEW_LINE if ( isThreeDisctFactors ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def computeLastDigit ( A , B ) : NEW_LINE INDENT variable = 1 NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( ( B - A ) >= 5 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( A + 1 , B + 1 ) : NEW_LINE INDENT variable = ( variable * ( i % 10 ) ) % 10 NEW_LINE DEDENT return variable % 10 NEW_LINE DEDENT DEDENT print ( computeLastDigit ( 2632 , 2634 ) ) NEW_LINE
def sumOfAP ( a , d , n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT sum = sum + a NEW_LINE a = a + d NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 20 NEW_LINE a = 2.5 NEW_LINE d = 1.5 NEW_LINE print ( sumOfAP ( a , d , n ) ) NEW_LINE
M = 1000000007 NEW_LINE def multiplyFactors ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE DEDENT else : NEW_LINE INDENT prod = ( prod * i ) % M NEW_LINE prod = ( prod * n / i ) % M NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return prod NEW_LINE DEDENT n = 12 NEW_LINE print ( multiplyFactors ( n ) ) NEW_LINE
M = 1000000007 NEW_LINE def power ( x , y ) : NEW_LINE INDENT res = 1 NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % M NEW_LINE DEDENT y = ( y >> 1 ) % M NEW_LINE x = ( x * x ) % M NEW_LINE DEDENT return res NEW_LINE DEDENT def countFactors ( n ) : NEW_LINE INDENT count = 0 NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 2 NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def multiplyFactors ( n ) : NEW_LINE INDENT numFactor = countFactors ( n ) NEW_LINE product = power ( n , numFactor / 2 ) NEW_LINE if ( numFactor % 2 == 1 ) : NEW_LINE INDENT product = ( product * ( int ) ( math . sqrt ( n ) ) ) % M NEW_LINE DEDENT return product NEW_LINE DEDENT n = 12 NEW_LINE print multiplyFactors ( n ) NEW_LINE
def printTrib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT first = 0 NEW_LINE second = 0 NEW_LINE third = 1 NEW_LINE print ( first , " ▁ " , end = " " ) NEW_LINE if ( n > 1 ) : NEW_LINE INDENT print ( second , " ▁ " , end = " " ) NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( second , " ▁ " , end = " " ) NEW_LINE DEDENT for i in range ( 3 , n ) : NEW_LINE INDENT curr = first + second + third NEW_LINE first = second NEW_LINE second = third NEW_LINE third = curr NEW_LINE print ( curr , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE
' NEW_LINE import math as m NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT lis = [ ] NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT lis . append ( p ) NEW_LINE DEDENT DEDENT return lis NEW_LINE DEDENT def setBits ( n ) : NEW_LINE INDENT return bin ( n ) [ 2 : ] . count ( '1' ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y = [ 4 , 8 ] NEW_LINE count = 0 NEW_LINE primeArr = SieveOfEratosthenes ( int ( m . ceil ( m . log ( y , 2 ) ) ) ) NEW_LINE for i in range ( x , y + 1 ) : NEW_LINE INDENT temp = setBits ( i ) NEW_LINE if temp in primeArr : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT
def count_square ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT k = n - i + 1 ; NEW_LINE count += ( k * k ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT N = 8 ; NEW_LINE print ( count_square ( N ) ) ; NEW_LINE
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE i , Sum = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] - ( Sum - arr [ i ] ) ) > k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 1 NEW_LINE print ( countAnomalies ( arr , n , k ) ) NEW_LINE
from math import sqrt ; NEW_LINE N = 100005 NEW_LINE d = [ 0 ] * N NEW_LINE pre = [ 0 ] * N NEW_LINE def Positive_Divisors ( ) : NEW_LINE INDENT for i in range ( N ) : NEW_LINE INDENT for j in range ( 1 , int ( sqrt ( i ) ) + 1 ) : NEW_LINE INDENT if ( i % j == 0 ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT d [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT d [ i ] += 2 NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( d [ i ] == d [ i - 1 ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT pre [ i ] = ans NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Positive_Divisors ( ) NEW_LINE n = 15 NEW_LINE print ( pre [ n ] ) NEW_LINE DEDENT
def numLen ( K ) : NEW_LINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT number = 0 ; NEW_LINE len = 1 ; NEW_LINE for len in range ( 1 , K + 1 ) : NEW_LINE INDENT number = number * 10 + 1 ; NEW_LINE if ( ( number % K == 0 ) ) : NEW_LINE INDENT return len ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT K = 7 ; NEW_LINE print ( numLen ( K ) ) ; NEW_LINE
def doesContainB ( a , b , c ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( ( b - a ) * c > 0 and ( b - a ) % c == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b , c = 1 , 7 , 3 NEW_LINE if ( doesContainB ( a , b , c ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printPermutation ( n , k ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT x = 2 * i - 1 ; NEW_LINE y = 2 * i ; NEW_LINE if ( i <= k ) : NEW_LINE INDENT print ( y , x , end = " ▁ " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , y , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 ; k = 1 ; NEW_LINE printPermutation ( n , k ) ; NEW_LINE DEDENT
def maxSum ( N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for u in range ( 1 , N + 1 ) : NEW_LINE INDENT for v in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( u == v ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT degreeU = 2 ; NEW_LINE if ( u == 1 or u == N ) : NEW_LINE INDENT degreeU = 1 ; NEW_LINE DEDENT degreeV = 2 ; NEW_LINE if ( v == 1 or v == N ) : NEW_LINE INDENT degreeV = 1 ; NEW_LINE DEDENT ans += ( degreeU * degreeV ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 ; NEW_LINE print ( maxSum ( N ) ) ; NEW_LINE DEDENT
def maximumFactor ( arr ) : NEW_LINE INDENT rank , factors = [ ] , [ ] NEW_LINE for i in range ( 2 , max ( arr ) + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in arr : NEW_LINE INDENT if j % i == 0 : count += 1 NEW_LINE DEDENT rank . append ( count ) NEW_LINE factors . append ( i ) NEW_LINE DEDENT m = max ( rank ) NEW_LINE for i in range ( len ( rank ) ) : NEW_LINE INDENT if rank [ i ] == m : NEW_LINE INDENT print ( factors [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 120 , 15 , 24 , 63 , 18 ] NEW_LINE maximumFactor ( arr ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE x = 1 NEW_LINE while x <= n : NEW_LINE INDENT sum = sum + x NEW_LINE x = x + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print findSum ( n ) NEW_LINE
def findMedian ( a , n ) : NEW_LINE INDENT sorted ( a ) NEW_LINE if n % 2 != 0 : NEW_LINE INDENT return float ( a [ n // 2 ] ) NEW_LINE DEDENT return float ( ( a [ int ( ( n - 1 ) / 2 ) ] + a [ int ( n / 2 ) ] ) / 2.0 ) NEW_LINE DEDENT a = [ 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Median ▁ = " , findMedian ( a , n ) ) NEW_LINE
def findMean ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT return float ( sum / n ) NEW_LINE DEDENT a = [ 1 , 3 , 4 , 2 , 7 , 5 , 8 , 6 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Mean ▁ = " , findMean ( a , n ) ) NEW_LINE
import math NEW_LINE def CheckArray ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE freq = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq . append ( arr [ i ] ) NEW_LINE prod *= arr [ i ] NEW_LINE DEDENT root = math . sqrt ( prod ) NEW_LINE if ( root * root == prod ) : NEW_LINE INDENT if root in freq : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 12 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE if ( CheckArray ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def hasConsecutiveZeroes ( N , K ) : NEW_LINE INDENT z = toK ( N , K ) NEW_LINE if ( check ( z ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT def toK ( N , K ) : NEW_LINE INDENT w = 1 NEW_LINE s = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT r = N % K NEW_LINE N = N // K NEW_LINE s = r * w + s NEW_LINE w * = 10 NEW_LINE DEDENT return s NEW_LINE DEDENT def check ( N ) : NEW_LINE INDENT fl = False NEW_LINE while ( N != 0 ) : NEW_LINE INDENT r = N % 10 NEW_LINE N = N // 10 NEW_LINE if ( fl == True and r == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( r > 0 ) : NEW_LINE INDENT fl = False NEW_LINE continue NEW_LINE DEDENT fl = True NEW_LINE DEDENT return True NEW_LINE DEDENT N , K = 15 , 8 NEW_LINE hasConsecutiveZeroes ( N , K ) NEW_LINE
MAX = 100000 ; NEW_LINE prime = [ True ] * ( MAX + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE prime [ 0 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def SumOfKthPrimes ( arr , n , k ) : NEW_LINE INDENT c = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT c += 1 ; NEW_LINE if ( c % k == 0 ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE c = 0 ; NEW_LINE DEDENT DEDENT DEDENT print ( sum ) ; NEW_LINE DEDENT SieveOfEratosthenes ( ) ; NEW_LINE arr = [ 2 , 3 , 5 , 7 , 11 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE SumOfKthPrimes ( arr , n , k ) ; NEW_LINE
MAX = 100000 ; NEW_LINE prime = [ True ] * 100002 ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT p = 2 ; NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= MAX ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT DEDENT def superpower ( n ) : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE superPower = 0 ; NEW_LINE factor = 0 ; NEW_LINE i = 2 ; NEW_LINE while ( n > 1 and i <= MAX ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT factor = 0 ; NEW_LINE while ( n % i == 0 and n > 1 ) : NEW_LINE INDENT factor += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( superPower < factor ) : NEW_LINE INDENT superPower = factor ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return superPower ; NEW_LINE DEDENT n = 256 ; NEW_LINE print ( superpower ( n ) ) ; NEW_LINE
def smallestDivisor ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT n = 31 ; NEW_LINE print ( smallestDivisor ( n ) ) ; NEW_LINE
def countRabbits ( Heads , Legs ) : NEW_LINE INDENT count = 0 NEW_LINE count = ( Legs ) - 2 * ( Heads ) NEW_LINE count = count / 2 NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Heads = 100 NEW_LINE Legs = 300 NEW_LINE Rabbits = countRabbits ( Heads , Legs ) NEW_LINE print ( " Rabbits ▁ = " , Rabbits ) NEW_LINE print ( " Pigeons ▁ = " , Heads - Rabbits ) NEW_LINE DEDENT
import math NEW_LINE def calculateSum ( n ) : NEW_LINE INDENT a = int ( n ) NEW_LINE return ( 2 * ( pow ( n , 6 ) + 15 * pow ( n , 4 ) + 15 * pow ( n , 2 ) + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 1.4142 NEW_LINE DEDENT print ( math . ceil ( calculateSum ( n ) ) ) NEW_LINE
def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT return ( 1 - pow ( - 2 , n ) ) NEW_LINE DEDENT N = 5 NEW_LINE print ( Sum_upto_nth_Term ( N ) ) NEW_LINE
def xorEqualsOrCount ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT bit = N % 2 NEW_LINE if bit == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT return int ( pow ( 2 , count ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 7 NEW_LINE print ( xorEqualsOrCount ( N ) ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n * fact ( n - 1 ) NEW_LINE DEDENT DEDENT def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT total = total + ( pow ( x , i ) / fact ( i + 1 ) ) NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 NEW_LINE n = 4 NEW_LINE print ( " Sum ▁ is : ▁ { 0 : . 4f } " . format ( sum ( x , n ) ) ) NEW_LINE DEDENT
def sum_of_series ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT result = result - pow ( i , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT result = result + pow ( i , 2 ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE print ( sum_of_series ( n ) ) NEW_LINE n = 10 NEW_LINE print ( sum_of_series ( n ) ) NEW_LINE DEDENT
def findSum ( N ) : NEW_LINE INDENT return ( 2 * N * ( N + 1 ) * ( 4 * N + 17 ) + 54 * N ) / 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE print ( findSum ( N ) ) NEW_LINE DEDENT
import math NEW_LINE MAX = 16 NEW_LINE nCr = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def binomial ( ) : NEW_LINE for i in range ( MAX ) : for j in range ( 0 , i + 1 ) : if j == 0 or j == i : NEW_LINE INDENT nCr [ i ] [ j ] = 1 NEW_LINE DEDENT else : nCr [ i ] [ j ] = nCr [ i - 1 ] [ j ] + nCr [ i - 1 ] [ j - 1 ] NEW_LINE def findCosNTheta ( sinTheta , n ) : NEW_LINE cosTheta = math . sqrt ( 1 - sinTheta * sinTheta ) NEW_LINE ans = 0 NEW_LINE INDENT toggle = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : ans = ( ans + nCr [ n ] [ i ] * ( cosTheta ** ( n - i ) ) * ( sinTheta ** i ) * toggle ) toggle = toggle * - 1 NEW_LINE return ans NEW_LINE if __name__ == ' _ _ main _ _ ' : binomial ( ) NEW_LINE INDENT sinTheta = 0.5 NEW_LINE n = 10 NEW_LINE print ( findCosNTheta ( sinTheta , n ) ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT return ( ( 2 * N + 3 ) * ( 2 * N + 3 ) - 2 * N ) ; NEW_LINE DEDENT n = 4 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE
def solve_sum ( n ) : NEW_LINE INDENT return ( pow ( 10 , n + 1 ) * ( 9 * n - 1 ) + 10 ) / pow ( 9 , 3 ) - n * ( n + 1 ) / 18 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( solve_sum ( n ) ) ) NEW_LINE
def solve_sum ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return ( n + 1 ) / 2 NEW_LINE DEDENT return - n / 2 NEW_LINE DEDENT n = 8 NEW_LINE print ( int ( solve_sum ( n ) ) ) NEW_LINE
from math import * NEW_LINE def isPower ( a ) : NEW_LINE INDENT if a == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( a ) ) + 1 ) : NEW_LINE INDENT val = log ( a ) / log ( i ) NEW_LINE if ( round ( ( val - int ( val ) ) , 8 ) < 0.00000001 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 16 NEW_LINE if isPower ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
import math NEW_LINE def rmsValue ( arr , n ) : NEW_LINE INDENT square = 0 NEW_LINE mean = 0.0 NEW_LINE root = 0.0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT square += ( arr [ i ] ** 2 ) NEW_LINE DEDENT mean = ( square / ( float ) ( n ) ) NEW_LINE root = math . sqrt ( mean ) NEW_LINE return root NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 4 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( rmsValue ( arr , n ) ) NEW_LINE DEDENT
def Mixture ( X , Y , Z ) : NEW_LINE INDENT result = 0.0 NEW_LINE result1 = 0.0 NEW_LINE result1 = ( ( X - Y ) / X ) NEW_LINE result = pow ( result1 , Z ) NEW_LINE result = result * X NEW_LINE return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 10 NEW_LINE Y = 2 NEW_LINE Z = 2 NEW_LINE print ( " { : . 1f } " . format ( Mixture ( X , Y , Z ) ) + " ▁ litres " ) NEW_LINE DEDENT
mod = ( int ) ( 1e9 + 7 ) NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT n = n - 1 NEW_LINE ans = n * n NEW_LINE if ( ans >= mod ) : NEW_LINE INDENT ans %= mod NEW_LINE DEDENT ans += n + 2 NEW_LINE if ( ans >= mod ) : NEW_LINE INDENT ans %= mod NEW_LINE DEDENT ans = ( pow ( 2 , n , mod ) % mod * ans % mod ) % mod NEW_LINE ans = ( ans - 1 + mod ) % mod NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( check ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE def findLCM ( a , b ) : NEW_LINE INDENT lar = max ( a , b ) NEW_LINE small = min ( a , b ) NEW_LINE i = lar NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( i % small == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += lar NEW_LINE DEDENT DEDENT a = 5 NEW_LINE b = 7 NEW_LINE print ( " LCM ▁ of ▁ " , a , " ▁ and ▁ " , b , " ▁ is ▁ " , findLCM ( a , b ) , sep = " " ) NEW_LINE
from __future__ import print_function NEW_LINE def primes ( n ) : NEW_LINE INDENT i , j = 2 , 0 NEW_LINE result = [ ] NEW_LINE while j < n : NEW_LINE INDENT flag = True NEW_LINE for item in range ( 2 , int ( i ** 0.5 ) + 1 ) : NEW_LINE INDENT if i % item == 0 and i != item : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT result . append ( i ) NEW_LINE j += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT def smar_wln ( n ) : NEW_LINE INDENT arr = primes ( n ) NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT for j in range ( 0 , i + 1 ) : NEW_LINE INDENT print ( arr [ j ] , end = ' ' ) NEW_LINE DEDENT print ( end = ' ▁ ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( ' First { } terms of the Sequence are ' . format ( n ) ) NEW_LINE smar_wln ( n ) NEW_LINE DEDENT
def Pentatope_number ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) * ( n + 3 ) // 24 ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " % sth ▁ Pentatope ▁ number ▁ : ▁ " % n , Pentatope_number ( n ) ) NEW_LINE n = 12 NEW_LINE print ( " % sth ▁ Pentatope ▁ number ▁ : ▁ " % n , Pentatope_number ( n ) ) NEW_LINE
def centeredIcosahedralNum ( n ) : NEW_LINE INDENT return ( ( 2 * n + 1 ) * ( 5 * n * n + 5 * n + 3 ) // 3 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( centeredIcosahedralNum ( n ) ) NEW_LINE n = 12 NEW_LINE print ( centeredIcosahedralNum ( n ) ) NEW_LINE
def centered_square_num ( n ) : NEW_LINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " % sth ▁ Centered ▁ square ▁ number : ▁ " % n , centered_square_num ( n ) ) NEW_LINE
def seriesSum ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( seriesSum ( n ) ) NEW_LINE
def Dodecagonal_number ( n ) : NEW_LINE INDENT return 5 * n * n - 4 * n NEW_LINE DEDENT n = 7 NEW_LINE print ( Dodecagonal_number ( n ) ) NEW_LINE n = 12 NEW_LINE print ( Dodecagonal_number ( n ) ) NEW_LINE
import math NEW_LINE def SieveOfEratosthenes ( n , prime , primesquare , a ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True ; NEW_LINE DEDENT for i in range ( ( n * n + 1 ) + 1 ) : NEW_LINE INDENT primesquare [ i ] = False ; NEW_LINE DEDENT prime [ 1 ] = False ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT j = 0 ; NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT a [ j ] = p ; NEW_LINE primesquare [ p * p ] = True ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT DEDENT def countDivisors ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT prime = [ False ] * ( n + 2 ) ; NEW_LINE primesquare = [ False ] * ( n * n + 3 ) ; NEW_LINE a = [ 0 ] * n ; NEW_LINE SieveOfEratosthenes ( n , prime , primesquare , a ) ; NEW_LINE ans = 1 ; NEW_LINE for i in range ( 0 , True ) : NEW_LINE INDENT if ( a [ i ] * a [ i ] * a [ i ] > n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT cnt = 1 ; NEW_LINE while ( n % a [ i ] == 0 ) : NEW_LINE INDENT n //= a [ i ] ; NEW_LINE cnt = cnt + 1 ; NEW_LINE DEDENT ans = ans * cnt ; NEW_LINE DEDENT if ( prime [ n ] ) : NEW_LINE INDENT ans = ans * 2 ; NEW_LINE DEDENT elif ( primesquare [ n ] ) : NEW_LINE INDENT ans = ans * 3 ; NEW_LINE DEDENT elif ( n != 1 ) : NEW_LINE INDENT ans = ans * 4 ; NEW_LINE DEDENT DEDENT def sumofFactors ( n ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr_sum = 1 ; NEW_LINE curr_term = 1 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n //= i ; NEW_LINE curr_term *= i ; NEW_LINE curr_sum += curr_term ; NEW_LINE DEDENT res *= curr_sum ; NEW_LINE DEDENT if ( n >= 2 ) : NEW_LINE INDENT res *= ( 1 + n ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def checkArithmetic ( n ) : NEW_LINE INDENT count = countDivisors ( n ) ; NEW_LINE sum = sumofFactors ( n ) ; NEW_LINE return ( sum % count == 0 ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE if ( checkArithmetic ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
def magicOfSequence ( N ) : NEW_LINE INDENT return ( N * ( N + 1 ) / 2 ) + 2 * N NEW_LINE DEDENT N = 6 NEW_LINE print ( int ( magicOfSequence ( N ) ) ) NEW_LINE
power = [ ] NEW_LINE def nextPower ( N ) : NEW_LINE INDENT global power NEW_LINE carry = 0 NEW_LINE for i in range ( 0 , len ( power ) ) : NEW_LINE INDENT prod = ( power [ i ] * N ) + carry NEW_LINE power [ i ] = prod % 10 NEW_LINE carry = ( int ) ( prod / 10 ) NEW_LINE DEDENT while ( carry ) : NEW_LINE INDENT power . append ( carry % 10 ) NEW_LINE carry = ( int ) ( carry / 10 ) NEW_LINE DEDENT DEDENT def printPowerNumber ( X , N ) : NEW_LINE INDENT global power NEW_LINE power . append ( 1 ) NEW_LINE res = [ ] NEW_LINE for i in range ( 1 , X + 1 ) : NEW_LINE INDENT nextPower ( N ) NEW_LINE res . append ( power [ - 1 ] ) NEW_LINE res . append ( power [ 0 ] ) NEW_LINE DEDENT for i in range ( 0 , len ( res ) ) : NEW_LINE INDENT print ( res [ i ] , end = " " ) NEW_LINE DEDENT DEDENT N = 19 NEW_LINE X = 4 NEW_LINE printPowerNumber ( X , N ) NEW_LINE
import math NEW_LINE def firstDigit ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE while ( fact % 10 == 0 ) : NEW_LINE INDENT fact = int ( fact / 10 ) NEW_LINE DEDENT DEDENT while ( fact >= 10 ) : NEW_LINE INDENT fact = int ( fact / 10 ) NEW_LINE DEDENT return math . floor ( fact ) NEW_LINE DEDENT n = 5 NEW_LINE print ( firstDigit ( n ) ) NEW_LINE
def sumofseries ( n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res += ( i ) * ( i + 1 ) * ( i + 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT print ( sumofseries ( 3 ) ) NEW_LINE
import math NEW_LINE def printGMeans ( A , B , N ) : NEW_LINE INDENT R = ( math . pow ( ( B / A ) , 1.0 / ( N + 1 ) ) ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( int ( A * math . pow ( R , i ) ) , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT A = 3 ; NEW_LINE B = 81 ; NEW_LINE N = 2 ; NEW_LINE printGMeans ( A , B , N ) ; NEW_LINE
def digitSum ( n ) : NEW_LINE INDENT digSum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digSum += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return digSum NEW_LINE DEDENT def countInteger ( n , s ) : NEW_LINE INDENT if ( n < s ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( s , min ( n , s + 163 ) + 1 ) : NEW_LINE INDENT if ( ( i - digitSum ( i ) ) > s ) : NEW_LINE INDENT return ( n - i + 1 ) NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT n = 1000 NEW_LINE s = 100 NEW_LINE print ( countInteger ( n , s ) ) NEW_LINE
def division ( num1 , num2 ) : NEW_LINE INDENT if ( num1 == 0 ) : return 0 NEW_LINE if ( num2 == 0 ) : return INT_MAX NEW_LINE negResult = 0 NEW_LINE if ( num1 < 0 ) : NEW_LINE INDENT num1 = - num1 NEW_LINE if ( num2 < 0 ) : NEW_LINE INDENT num2 = - num2 NEW_LINE DEDENT else : NEW_LINE INDENT negResult = true NEW_LINE DEDENT DEDENT elif ( num2 < 0 ) : NEW_LINE INDENT num2 = - num2 NEW_LINE negResult = true NEW_LINE DEDENT quotient = 0 NEW_LINE while ( num1 >= num2 ) : NEW_LINE INDENT num1 = num1 - num2 NEW_LINE quotient += 1 NEW_LINE DEDENT if ( negResult ) : NEW_LINE INDENT quotient = - quotient NEW_LINE DEDENT return quotient NEW_LINE DEDENT num1 = 13 ; num2 = 2 NEW_LINE print ( division ( num1 , num2 ) ) NEW_LINE
def Nonagonal ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( int ( i * ( 7 * i - 5 ) / 2 ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE Nonagonal ( n ) NEW_LINE
def seriesFunc ( n ) : NEW_LINE INDENT sumSquare = ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE sumNatural = ( n * ( n + 1 ) / 2 ) NEW_LINE return ( sumSquare + sumNatural + 1 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( int ( seriesFunc ( n ) ) ) NEW_LINE n = 13 NEW_LINE print ( int ( seriesFunc ( n ) ) ) NEW_LINE
import math NEW_LINE def checkplusperfect ( x ) : NEW_LINE INDENT temp = x NEW_LINE n = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x // 10 NEW_LINE n = n + 1 NEW_LINE DEDENT x = temp NEW_LINE sm = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT sm = sm + ( int ) ( math . pow ( x % 10 , n ) ) NEW_LINE x = x // 10 NEW_LINE DEDENT return ( sm == temp ) NEW_LINE DEDENT x = 9474 NEW_LINE if ( checkplusperfect ( x ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def subsetCount ( arr , n ) : NEW_LINE INDENT return 1 << n NEW_LINE DEDENT A = [ 1 , 2 , 3 ] NEW_LINE n = len ( A ) NEW_LINE print ( subsetCount ( A , n ) ) NEW_LINE
def Calculate_GST ( org_cost , N_price ) : NEW_LINE INDENT return ( ( ( N_price - org_cost ) * 100 ) / org_cost ) ; NEW_LINE DEDENT org_cost = 100 NEW_LINE N_price = 120 NEW_LINE print ( " GST ▁ = ▁ " , end = ' ' ) NEW_LINE print ( round ( Calculate_GST ( org_cost , N_price ) ) , end = ' ' ) NEW_LINE print ( " % " ) NEW_LINE
def centeredHexagonalNumber ( n ) : NEW_LINE INDENT return 3 * n * ( n - 1 ) + 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( n , " th ▁ centered ▁ hexagonal ▁ number : ▁ " , centeredHexagonalNumber ( n ) ) NEW_LINE DEDENT ' NEW_LINE
def find_distance ( n ) : NEW_LINE INDENT return n * ( ( 3 * n ) + 7 ) NEW_LINE DEDENT n = 5 NEW_LINE ans = find_distance ( n ) NEW_LINE print ( ans ) NEW_LINE
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) + 1 ) , 6 ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def twinPrime ( n1 , n2 ) : NEW_LINE INDENT return ( isPrime ( n1 ) and isPrime ( n2 ) and abs ( n1 - n2 ) == 2 ) NEW_LINE DEDENT n1 = 137 NEW_LINE n2 = 139 NEW_LINE if twinPrime ( n1 , n2 ) : NEW_LINE INDENT print ( " Twin ▁ Prime " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Twin ▁ Prime " ) NEW_LINE DEDENT
import math NEW_LINE def sumOfSeries ( n ) : NEW_LINE INDENT return 0.0246 * ( math . pow ( 10 , n ) - 1 - ( 9 * n ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE
import math NEW_LINE def evenbinomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << ( n - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print evenbinomialCoeffSum ( n ) NEW_LINE DEDENT
def triangular_series ( n ) : NEW_LINE INDENT j = 1 NEW_LINE k = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( k , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT j = j + 1 NEW_LINE INDENT k = k + j NEW_LINE DEDENT n = 5 NEW_LINE triangular_series ( n ) NEW_LINE
def sumOfTheSeries ( n ) : NEW_LINE INDENT return int ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT n = 5 NEW_LINE print ( " Sum ▁ = " , sumOfTheSeries ( n ) ) NEW_LINE
def sumOfSeries ( n ) : NEW_LINE INDENT return sum ( [ i * ( i + 1 ) / 2 for i in range ( 1 , n + 1 ) ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE DEDENT
def numberOfTriangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 ; NEW_LINE return ans ; NEW_LINE DEDENT n = 2 NEW_LINE print ( numberOfTriangles ( n ) ) NEW_LINE
def motzkin ( n ) : NEW_LINE INDENT dp = [ None ] * ( n + 1 ) NEW_LINE dp [ 0 ] = dp [ 1 ] = 1 ; NEW_LINE i = 2 NEW_LINE while i <= n : NEW_LINE INDENT dp [ i ] = ( ( 2 * i + 1 ) * dp [ i - 1 ] + ( 3 * i - 3 ) * dp [ i - 2 ] ) / ( i + 2 ) ; NEW_LINE i = i + 1 NEW_LINE DEDENT return dp [ n ] ; NEW_LINE DEDENT n = 8 NEW_LINE print ( motzkin ( n ) ) NEW_LINE
def kthgroupsum ( k ) : NEW_LINE INDENT return k * k * k NEW_LINE DEDENT k = 3 NEW_LINE print ( kthgroupsum ( k ) ) NEW_LINE
def printXYZ ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " x ▁ is ▁ " , n ) NEW_LINE print ( " y ▁ is ▁ " , n + 1 ) NEW_LINE print ( " z ▁ is ▁ " , n * ( n + 1 ) ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE printXYZ ( n ) NEW_LINE
def term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) / 2 NEW_LINE DEDENT n = 4 NEW_LINE print term ( n ) NEW_LINE
import math NEW_LINE def compute ( a , b ) : NEW_LINE INDENT AM = ( a + b ) / 2 NEW_LINE GM = math . sqrt ( a * b ) NEW_LINE HM = ( GM * GM ) / AM NEW_LINE return HM NEW_LINE DEDENT a = 5 NEW_LINE b = 15 NEW_LINE HM = compute ( a , b ) NEW_LINE print ( " Harmonic ▁ Mean ▁ between ▁ " , a , " ▁ and ▁ " , b , " ▁ is ▁ " , HM ) NEW_LINE
def series ( n ) : NEW_LINE INDENT print ( ( 8 * n ** 2 ) + 1 ) NEW_LINE DEDENT series ( 5 ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def isDivisible ( x , y ) : NEW_LINE INDENT if ( y == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT z = gcd ( x , y ) ; NEW_LINE if ( z == 1 ) : NEW_LINE INDENT return false ; NEW_LINE DEDENT return isDivisible ( x , y / z ) ; NEW_LINE DEDENT x = 18 NEW_LINE y = 12 NEW_LINE if ( isDivisible ( x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from __future__ import division NEW_LINE def sumOfSeries ( a , num ) : NEW_LINE INDENT res = 0 NEW_LINE prev = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prev *= ( a / i ) NEW_LINE res = res + prev NEW_LINE DEDENT return res NEW_LINE DEDENT n = 5 NEW_LINE a = 2 NEW_LINE print ( round ( sumOfSeries ( a , n ) , 4 ) ) NEW_LINE
def Cel_To_Fah ( n ) : NEW_LINE INDENT return ( n * 1.8 ) + 32 NEW_LINE DEDENT n = 20 NEW_LINE print ( int ( Cel_To_Fah ( n ) ) ) NEW_LINE
def print_sequence ( n , k ) : NEW_LINE INDENT b = int ( n / ( k * ( k + 1 ) / 2 ) ) ; NEW_LINE if b == 0 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 ; NEW_LINE x = 1 NEW_LINE while x ** 2 <= n : NEW_LINE INDENT if n % x != 0 : NEW_LINE INDENT continue ; NEW_LINE DEDENT elif x <= b and x > r : NEW_LINE INDENT r = x NEW_LINE DEDENT elif n / x <= b and n / x > r : NEW_LINE INDENT r = n / x NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < k : NEW_LINE INDENT print ( r * i , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) NEW_LINE print ( last_term ) NEW_LINE DEDENT DEDENT print_sequence ( 24 , 4 ) NEW_LINE print_sequence ( 24 , 5 ) NEW_LINE print_sequence ( 6 , 4 ) NEW_LINE
def countCompositions ( n ) : NEW_LINE INDENT return ( 2 ** ( n - 1 ) ) NEW_LINE DEDENT print ( countCompositions ( 4 ) ) NEW_LINE
def countDigit ( n ) : NEW_LINE INDENT if n / 10 == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 1 + countDigit ( n // 10 ) NEW_LINE DEDENT n = 345289467 NEW_LINE print ( " Number ▁ of ▁ digits ▁ : ▁ % ▁ d " % ( countDigit ( n ) ) ) NEW_LINE
def printTrib ( n ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE dp [ 0 ] = dp [ 1 ] = 0 ; NEW_LINE dp [ 2 ] = 1 ; NEW_LINE for i in range ( 3 , n ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] + dp [ i - 3 ] ; NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( dp [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE printTrib ( n ) NEW_LINE
def multiply ( T , M ) : NEW_LINE INDENT a = ( T [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 0 ] ) NEW_LINE b = ( T [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 1 ] ) NEW_LINE c = ( T [ 0 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 0 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 0 ] [ 2 ] * M [ 2 ] [ 2 ] ) NEW_LINE d = ( T [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 0 ] ) NEW_LINE e = ( T [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 1 ] ) NEW_LINE f = ( T [ 1 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 1 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 1 ] [ 2 ] * M [ 2 ] [ 2 ] ) NEW_LINE g = ( T [ 2 ] [ 0 ] * M [ 0 ] [ 0 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 0 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 0 ] ) NEW_LINE h = ( T [ 2 ] [ 0 ] * M [ 0 ] [ 1 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 1 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 1 ] ) NEW_LINE i = ( T [ 2 ] [ 0 ] * M [ 0 ] [ 2 ] + T [ 2 ] [ 1 ] * M [ 1 ] [ 2 ] + T [ 2 ] [ 2 ] * M [ 2 ] [ 2 ] ) NEW_LINE T [ 0 ] [ 0 ] = a NEW_LINE T [ 0 ] [ 1 ] = b NEW_LINE T [ 0 ] [ 2 ] = c NEW_LINE T [ 1 ] [ 0 ] = d NEW_LINE T [ 1 ] [ 1 ] = e NEW_LINE T [ 1 ] [ 2 ] = f NEW_LINE T [ 2 ] [ 0 ] = g NEW_LINE T [ 2 ] [ 1 ] = h NEW_LINE T [ 2 ] [ 2 ] = i NEW_LINE DEDENT def power ( T , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT M = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE power ( T , n // 2 ) NEW_LINE multiply ( T , T ) NEW_LINE if ( n % 2 ) : NEW_LINE INDENT multiply ( T , M ) NEW_LINE DEDENT DEDENT def tribonacci ( n ) : NEW_LINE INDENT T = [ [ 1 , 1 , 1 ] , [ 1 , 0 , 0 ] , [ 0 , 1 , 0 ] ] NEW_LINE if ( n == 0 or n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT power ( T , n - 2 ) NEW_LINE DEDENT return T [ 0 ] [ 0 ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( tribonacci ( i ) , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
import math NEW_LINE def geometricMean ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = sum + math . log ( arr [ i ] ) ; NEW_LINE DEDENT sum = sum / n ; NEW_LINE return math . exp ( sum ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( geometricMean ( arr , n ) ) ; NEW_LINE
import math as mt NEW_LINE def smallestNumber ( n ) : NEW_LINE INDENT if ( n >= 0 and n <= 9 ) : NEW_LINE INDENT return n NEW_LINE DEDENT digits = list ( ) NEW_LINE for i in range ( 9 , 1 , - 1 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT digits . append ( i ) NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT k = 0 NEW_LINE while ( len ( digits ) != 0 ) : NEW_LINE INDENT k = k * 10 + digits [ - 1 ] NEW_LINE digits . pop ( ) NEW_LINE DEDENT return k NEW_LINE DEDENT n = 100 NEW_LINE print ( smallestNumber ( n ) ) NEW_LINE
def isMagic ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum ; NEW_LINE sum = 0 ; NEW_LINE DEDENT sum = sum + n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return True if ( sum == 1 ) else False ; NEW_LINE DEDENT n = 1234 ; NEW_LINE if ( isMagic ( n ) ) : NEW_LINE INDENT print ( " Magic ▁ Number " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ magic ▁ Number " ) ; NEW_LINE DEDENT
def printSequence ( n ) : NEW_LINE a = 1 NEW_LINE ans = 2 NEW_LINE INDENT N = 1000000007 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT print ans , NEW_LINE ans = ( ( a % N ) * ( ans % N ) ) % N NEW_LINE a = ans NEW_LINE ans = ( ans + 1 ) % N NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT n = 6 NEW_LINE printSequence ( n ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE x = 1 NEW_LINE while x <= n : NEW_LINE INDENT sum = sum + x NEW_LINE x = x + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 5 NEW_LINE print findSum ( n ) NEW_LINE
def HailstoneNumbers ( N , c ) : NEW_LINE INDENT print ( N , end = " ▁ " ) NEW_LINE if ( N == 1 and c == 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT elif ( N == 1 and c != 0 ) : NEW_LINE INDENT c = c + 1 NEW_LINE DEDENT elif ( N % 2 == 0 ) : NEW_LINE INDENT c = c + 1 NEW_LINE c = HailstoneNumbers ( int ( N / 2 ) , c ) NEW_LINE DEDENT elif ( N % 2 != 0 ) : NEW_LINE INDENT c = c + 1 NEW_LINE c = HailstoneNumbers ( 3 * N + 1 , c ) NEW_LINE DEDENT return c NEW_LINE DEDENT N = 7 NEW_LINE x = HailstoneNumbers ( N , 0 ) NEW_LINE print ( " Number of Steps :   " , x ) NEW_LINE
def xorCalc ( k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT if ( ( ( k + 1 ) & k ) == 0 ) : NEW_LINE INDENT return k / 2 NEW_LINE DEDENT return 1 ; NEW_LINE DEDENT k = 31 NEW_LINE print ( int ( xorCalc ( k ) ) ) NEW_LINE
def reverse ( s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return s NEW_LINE DEDENT else : NEW_LINE INDENT return reverse ( s [ 1 : ] ) + s [ 0 ] NEW_LINE DEDENT DEDENT def findNthNo ( n ) : NEW_LINE INDENT res = " " ; NEW_LINE while ( n >= 1 ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT res = res + "4" ; NEW_LINE n = ( int ) ( ( n - 1 ) / 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT res = res + "7" ; NEW_LINE n = ( int ) ( ( n - 2 ) / 2 ) ; NEW_LINE DEDENT DEDENT return reverse ( res ) ; NEW_LINE DEDENT n = 13 ; NEW_LINE print ( findNthNo ( n ) ) ; NEW_LINE
def divCount ( n ) : NEW_LINE INDENT hh = [ 1 ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( ( p * p ) < n ) : NEW_LINE INDENT if ( hh [ p ] == 1 ) : NEW_LINE INDENT for i in range ( ( p * 2 ) , n , p ) : NEW_LINE INDENT hh [ i ] = 0 ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT total = 1 ; NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( hh [ p ] == 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n % p == 0 ) : NEW_LINE INDENT while ( n % p == 0 ) : NEW_LINE INDENT n = int ( n / p ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT total *= ( count + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT return total ; NEW_LINE DEDENT n = 24 ; NEW_LINE print ( divCount ( n ) ) ; NEW_LINE
def maxPrimefactorNum ( N ) : NEW_LINE INDENT arr = [ 0 ] * ( N + 1 ) ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= N ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT for j in range ( 2 * i , N + 1 , i ) : NEW_LINE INDENT arr [ j ] += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE arr [ i ] = 1 ; NEW_LINE DEDENT return max ( arr ) ; NEW_LINE DEDENT N = 40 ; NEW_LINE print ( maxPrimefactorNum ( N ) ) ; NEW_LINE
def arraySum ( arr , n ) : NEW_LINE INDENT x = ( n + 1 ) / 2 NEW_LINE return ( arr [ 0 ] - 1 ) * n + x * x NEW_LINE DEDENT arr = [ 10 , 11 , 12 , 13 , 12 , 11 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( arraySum ( arr , n ) ) NEW_LINE
import math NEW_LINE def countDigits ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return math . floor ( math . log10 ( abs ( a ) ) + math . log10 ( abs ( b ) ) ) + 1 NEW_LINE DEDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( countDigits ( a , b ) ) NEW_LINE
def lastPosition ( n , m , k ) : NEW_LINE INDENT if ( m <= n - k + 1 ) : NEW_LINE return m + k - 1 NEW_LINE m = m - ( n - k + 1 ) NEW_LINE if ( m % n == 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT return m % n NEW_LINE DEDENT DEDENT n = 5 NEW_LINE m = 8 NEW_LINE k = 2 NEW_LINE print lastPosition ( n , m , k ) NEW_LINE
def primesInRange ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for k in range ( 2 , n ) : NEW_LINE INDENT fact = fact * ( k - 1 ) NEW_LINE if ( ( fact + 1 ) % k == 0 ) : NEW_LINE INDENT print k NEW_LINE DEDENT DEDENT DEDENT n = 15 NEW_LINE primesInRange ( n ) NEW_LINE
import math NEW_LINE EPS = 1e-9 NEW_LINE def productPuzzle ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += math . log10 ( a [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print int ( ( EPS + pow ( 10.00 , sum - math . log10 ( a [ i ] ) ) ) ) , NEW_LINE DEDENT return NEW_LINE DEDENT a = [ 10 , 3 , 5 , 6 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print " The ▁ product ▁ array ▁ is : ▁ " NEW_LINE productPuzzle ( a , n ) NEW_LINE
def changeEvenBits ( n ) : NEW_LINE INDENT to_subtract = 0 NEW_LINE m = 0 NEW_LINE x = n NEW_LINE while ( x ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT to_subtract += ( 1 << m ) NEW_LINE DEDENT m += 2 NEW_LINE x >>= 2 NEW_LINE DEDENT return n - to_subtract NEW_LINE DEDENT n = 30 NEW_LINE print changeEvenBits ( n ) NEW_LINE
def closestNumber ( n , m ) : NEW_LINE INDENT q = int ( n / m ) NEW_LINE n1 = m * q NEW_LINE if ( ( n * m ) > 0 ) : NEW_LINE INDENT n2 = ( m * ( q + 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT n2 = ( m * ( q - 1 ) ) NEW_LINE DEDENT if ( abs ( n - n1 ) < abs ( n - n2 ) ) : NEW_LINE INDENT return n1 NEW_LINE DEDENT return n2 NEW_LINE DEDENT n = 13 ; m = 4 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = - 15 ; m = 6 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 0 ; m = 8 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE n = 18 ; m = - 7 NEW_LINE print ( closestNumber ( n , m ) ) NEW_LINE
import math NEW_LINE def checkPronic ( x ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i <= ( int ) ( math . sqrt ( x ) ) ) : NEW_LINE INDENT if ( x == i * ( i + 1 ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return False NEW_LINE DEDENT i = 0 NEW_LINE while ( i <= 200 ) : NEW_LINE INDENT if checkPronic ( i ) : NEW_LINE INDENT print i , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT
def findMinSum ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 2 NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT sum += i NEW_LINE num /= i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT sum += num NEW_LINE return sum NEW_LINE DEDENT num = 12 NEW_LINE print findMinSum ( num ) NEW_LINE
def findMin ( s ) : NEW_LINE INDENT a , b = 0 , 0 NEW_LINE while ( s > 0 ) : NEW_LINE INDENT if ( s % 7 == 0 ) : NEW_LINE INDENT b += 1 NEW_LINE s -= 7 NEW_LINE DEDENT elif ( s % 4 == 0 ) : NEW_LINE INDENT a += 1 NEW_LINE s -= 4 NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE s -= 4 NEW_LINE DEDENT DEDENT string = " " NEW_LINE if ( s < 0 ) : NEW_LINE INDENT string = " - 1" NEW_LINE return string NEW_LINE DEDENT string += "4" * a NEW_LINE string += "7" * b NEW_LINE return string NEW_LINE DEDENT print findMin ( 15 ) NEW_LINE
def minNum ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT if ( odd % 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print minNum ( arr , n ) NEW_LINE
def printMaximum ( inum ) : NEW_LINE INDENT count = [ 0 for x in range ( 10 ) ] NEW_LINE string = str ( num ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT count [ int ( string [ i ] ) ] = count [ int ( string [ i ] ) ] + 1 NEW_LINE DEDENT result = 0 NEW_LINE multiplier = 1 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT while count [ i ] > 0 : NEW_LINE INDENT result = result + ( i * multiplier ) NEW_LINE count [ i ] = count [ i ] - 1 NEW_LINE multiplier = multiplier * 10 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT num = 38293367 NEW_LINE print printMaximum ( num ) NEW_LINE
def nCr ( n , r ) : NEW_LINE INDENT if ( r > n / 2 ) : NEW_LINE INDENT r = n - r ; NEW_LINE DEDENT answer = 1 ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT answer *= ( n - r + i ) ; NEW_LINE answer /= i ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT def binomialProbability ( n , k , p ) : NEW_LINE INDENT return ( nCr ( n , k ) * pow ( p , k ) * pow ( 1 - p , n - k ) ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE k = 5 ; NEW_LINE p = 1.0 / 3 ; NEW_LINE probability = binomialProbability ( n , k , p ) ; NEW_LINE print ( " Probability ▁ of " , k , " heads ▁ when ▁ a ▁ coin ▁ is ▁ tossed " , end = " ▁ " ) ; NEW_LINE print ( n , " times ▁ where ▁ probability ▁ of ▁ each ▁ head ▁ is " , round ( p , 6 ) ) ; NEW_LINE print ( " is ▁ = ▁ " , round ( probability , 6 ) ) ; NEW_LINE
import math NEW_LINE def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT divisors = [ 0 ] * ( high + 1 ) NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = 1 NEW_LINE while j <= math . sqrt ( arr [ i ] ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] = divisors [ j ] + 1 NEW_LINE if ( j != arr [ i ] / j ) : NEW_LINE INDENT divisors [ arr [ i ] / j ] = divisors [ arr [ i ] / j ] NEW_LINE INDENT + 1 NEW_LINE DEDENT DEDENT DEDENT j = j + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT i = high NEW_LINE while i >= 1 : NEW_LINE INDENT if ( divisors [ i ] > 1 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i = i - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print findMaxGCD ( arr , n ) NEW_LINE
def findMaxGCD ( arr , n ) : NEW_LINE INDENT high = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT high = max ( high , arr [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count [ arr [ i ] ] += 1 NEW_LINE DEDENT counter = 0 NEW_LINE for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT j = i NEW_LINE while ( j <= high ) : NEW_LINE INDENT if ( count [ j ] > 0 ) : NEW_LINE INDENT counter += count [ j ] NEW_LINE DEDENT j += i NEW_LINE if ( counter == 2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT counter = 0 NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxGCD ( arr , n ) ) NEW_LINE
def count_one ( n ) : NEW_LINE INDENT c_one = 0 NEW_LINE while n != 0 : NEW_LINE INDENT rem = n % 10 NEW_LINE if rem == 1 : NEW_LINE INDENT c_one = c_one + 1 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT return c_one NEW_LINE DEDENT def checkEvil ( n ) : NEW_LINE INDENT i = 0 NEW_LINE binary = 0 NEW_LINE while n != 0 : NEW_LINE INDENT r = n % 2 NEW_LINE binary = binary + r * ( int ( 10 ** i ) ) NEW_LINE n = n / 2 NEW_LINE DEDENT n_one = count_one ( binary ) NEW_LINE if n_one % 2 == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT num = 32 NEW_LINE check = checkEvil ( num ) NEW_LINE if check : NEW_LINE INDENT print num , " is ▁ Evil ▁ Number " NEW_LINE DEDENT else : NEW_LINE INDENT print num , " is ▁ Odious ▁ Number " NEW_LINE DEDENT
def CountPairs ( n ) : NEW_LINE INDENT k = n NEW_LINE imin = 1 NEW_LINE ans = 0 NEW_LINE while ( imin <= n ) : NEW_LINE INDENT imax = n / k NEW_LINE ans += k * ( imax - imin + 1 ) NEW_LINE imin = imax + 1 NEW_LINE k = n / imin NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( CountPairs ( 1 ) ) NEW_LINE print ( CountPairs ( 2 ) ) NEW_LINE print ( CountPairs ( 3 ) ) NEW_LINE
def powermod ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( ( y & 1 ) > 0 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def modInverse ( a , m ) : NEW_LINE INDENT m0 = m ; NEW_LINE x0 = 0 ; NEW_LINE x1 = 1 ; NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = int ( a / m ) ; NEW_LINE t = m ; NEW_LINE m = a % m ; NEW_LINE a = t ; NEW_LINE t = x0 ; NEW_LINE x0 = x1 - q * x0 ; NEW_LINE x1 = t ; NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 += m0 ; NEW_LINE DEDENT return x1 ; NEW_LINE DEDENT def evaluteExpression ( n ) : NEW_LINE INDENT firstsum = 0 ; NEW_LINE mod = 10 ; NEW_LINE i = 2 ; NEW_LINE j = 0 ; NEW_LINE while ( ( 1 << j ) <= n ) : NEW_LINE INDENT firstsum = ( firstsum + i ) % mod ; NEW_LINE i *= i ; NEW_LINE j += 1 ; NEW_LINE DEDENT secondsum = ( powermod ( 4 , n + 1 , mod ) - 1 ) * modInverse ( 3 , mod ) ; NEW_LINE return ( firstsum * secondsum ) % mod ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( evaluteExpression ( n ) ) ; NEW_LINE n = 10 ; NEW_LINE print ( evaluteExpression ( n ) ) ; NEW_LINE
def PowerOFPINnfactorial ( n , p ) : NEW_LINE INDENT ans = 0 NEW_LINE temp = p NEW_LINE while ( temp <= n ) : NEW_LINE INDENT ans += n / temp NEW_LINE temp = temp * p NEW_LINE DEDENT return int ( ans ) NEW_LINE DEDENT print ( PowerOFPINnfactorial ( 4 , 2 ) ) NEW_LINE
def binaryToDecimal ( n ) : NEW_LINE INDENT num = n ; NEW_LINE dec_value = 0 ; NEW_LINE base = 1 ; NEW_LINE temp = num ; NEW_LINE while ( temp ) : NEW_LINE INDENT last_digit = temp % 10 ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE dec_value += last_digit * base ; NEW_LINE base = base * 2 ; NEW_LINE DEDENT return dec_value ; NEW_LINE DEDENT num = 10101001 ; NEW_LINE print ( binaryToDecimal ( num ) ) ; NEW_LINE
import math NEW_LINE def stirlingFactorial ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT e = 2.71 NEW_LINE z = ( math . sqrt ( 2 * 3.14 * n ) * math . pow ( ( n / e ) , n ) ) NEW_LINE return math . floor ( z ) NEW_LINE DEDENT print ( stirlingFactorial ( 1 ) ) NEW_LINE print ( stirlingFactorial ( 2 ) ) NEW_LINE print ( stirlingFactorial ( 3 ) ) NEW_LINE print ( stirlingFactorial ( 4 ) ) NEW_LINE print ( stirlingFactorial ( 5 ) ) NEW_LINE print ( stirlingFactorial ( 6 ) ) NEW_LINE print ( stirlingFactorial ( 7 ) ) NEW_LINE
def countXorPair ( arr , n ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] % 2 == 0 : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT DEDENT return odd * even NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countXorPair ( arr , n ) ) NEW_LINE DEDENT
MAX_ITERATIONS = 20 ; NEW_LINE def isLychrel ( number ) : NEW_LINE INDENT for i in range ( MAX_ITERATIONS ) : NEW_LINE INDENT number = number + reverse ( number ) ; NEW_LINE if ( isPalindrome ( number ) ) : NEW_LINE INDENT return " false " ; NEW_LINE DEDENT DEDENT return " true " ; NEW_LINE DEDENT def isPalindrome ( number ) : NEW_LINE INDENT return number == reverse ( number ) ; NEW_LINE DEDENT def reverse ( number ) : NEW_LINE INDENT reverse = 0 ; NEW_LINE while ( number > 0 ) : NEW_LINE INDENT remainder = number % 10 ; NEW_LINE reverse = ( reverse * 10 ) + remainder ; NEW_LINE number = int ( number / 10 ) ; NEW_LINE DEDENT return reverse ; NEW_LINE DEDENT number = 295 ; NEW_LINE print ( number , " ▁ is ▁ lychrel ? ▁ " , isLychrel ( number ) ) ; NEW_LINE
def findRectNum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) NEW_LINE DEDENT n = 6 NEW_LINE print ( findRectNum ( n ) ) NEW_LINE
import math ; NEW_LINE MAX_ITERATIONS = 10000 ; NEW_LINE def f ( x ) : NEW_LINE INDENT return ( 1 * pow ( x , 3 ) + 2 * x * x + 10 * x - 20 ) ; NEW_LINE DEDENT def Muller ( a , b , c ) : NEW_LINE INDENT res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT f1 = f ( a ) ; f2 = f ( b ) ; f3 = f ( c ) ; NEW_LINE d1 = f1 - f3 ; NEW_LINE d2 = f2 - f3 ; NEW_LINE h1 = a - c ; NEW_LINE h2 = b - c ; NEW_LINE a0 = f3 ; NEW_LINE a1 = ( ( ( d2 * pow ( h1 , 2 ) ) - ( d1 * pow ( h2 , 2 ) ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; NEW_LINE a2 = ( ( ( d1 * h2 ) - ( d2 * h1 ) ) / ( ( h1 * h2 ) * ( h1 - h2 ) ) ) ; NEW_LINE x = ( ( - 2 * a0 ) / ( a1 + abs ( math . sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; NEW_LINE y = ( ( - 2 * a0 ) / ( a1 - abs ( math . sqrt ( a1 * a1 - 4 * a0 * a2 ) ) ) ) ; NEW_LINE if ( x >= y ) : NEW_LINE INDENT res = x + c ; NEW_LINE DEDENT else : NEW_LINE INDENT res = y + c ; NEW_LINE DEDENT m = res * 100 ; NEW_LINE n = c * 100 ; NEW_LINE m = math . floor ( m ) ; NEW_LINE n = math . floor ( n ) ; NEW_LINE if ( m == n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT a = b ; NEW_LINE b = c ; NEW_LINE c = res ; NEW_LINE if ( i > MAX_ITERATIONS ) : NEW_LINE INDENT print ( " Root ▁ cannot ▁ be ▁ found ▁ using " , " Muller ' s ▁ method " ) ; NEW_LINE break ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT if ( i <= MAX_ITERATIONS ) : NEW_LINE INDENT print ( " The ▁ value ▁ of ▁ the ▁ root ▁ is " , round ( res , 4 ) ) ; NEW_LINE DEDENT DEDENT a = 0 ; NEW_LINE b = 1 ; NEW_LINE c = 2 ; NEW_LINE Muller ( a , b , c ) ; NEW_LINE
MAX = 100001 ; NEW_LINE p = [ ] ; NEW_LINE def sieve ( ) : NEW_LINE INDENT isPrime = [ 0 ] * ( MAX + 1 ) ; NEW_LINE for i in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( isPrime [ i ] == 0 ) : NEW_LINE INDENT p . append ( i ) ; NEW_LINE j = 2 ; NEW_LINE while ( i * j <= MAX ) : NEW_LINE INDENT isPrime [ i * j ] = 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def phi ( n ) : NEW_LINE INDENT res = n ; NEW_LINE i = 0 ; NEW_LINE while ( p [ i ] * p [ i ] <= n ) : NEW_LINE INDENT if ( n % p [ i ] == 0 ) : NEW_LINE INDENT res -= int ( res / p [ i ] ) ; NEW_LINE while ( n % p [ i ] == 0 ) : NEW_LINE INDENT n = int ( n / p [ i ] ) ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT if ( n > 1 ) : NEW_LINE INDENT res -= int ( res / n ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT sieve ( ) ; NEW_LINE print ( phi ( 11 ) ) ; NEW_LINE print ( phi ( 21 ) ) ; NEW_LINE print ( phi ( 31 ) ) ; NEW_LINE print ( phi ( 41 ) ) ; NEW_LINE print ( phi ( 51 ) ) ; NEW_LINE print ( phi ( 61 ) ) ; NEW_LINE print ( phi ( 91 ) ) ; NEW_LINE print ( phi ( 101 ) ) ; NEW_LINE
import math NEW_LINE def nthprimedigitsnumber ( n ) : NEW_LINE INDENT len = 1 ; NEW_LINE prev_count = 0 ; NEW_LINE while ( 1 ) : NEW_LINE INDENT curr_count = ( prev_count + math . pow ( 4 , len ) ) ; NEW_LINE if ( prev_count < n and curr_count >= n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT len += 1 ; NEW_LINE prev_count = curr_count ; NEW_LINE DEDENT for i in range ( 1 , len + 1 ) : NEW_LINE INDENT for j in range ( 1 , 5 ) : NEW_LINE INDENT if ( prev_count + pow ( 4 , len - i ) < n ) : NEW_LINE INDENT prev_count += pow ( 4 , len - i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( j == 1 ) : NEW_LINE INDENT print ( "2" , end = " " ) ; NEW_LINE DEDENT elif ( j == 2 ) : NEW_LINE INDENT print ( "3" , end = " " ) ; NEW_LINE DEDENT elif ( j == 3 ) : NEW_LINE INDENT print ( "5" , end = " " ) ; NEW_LINE DEDENT elif ( j == 4 ) : NEW_LINE INDENT print ( "7" , end = " " ) ; NEW_LINE DEDENT break ; NEW_LINE DEDENT DEDENT DEDENT print ( ) ; NEW_LINE DEDENT nthprimedigitsnumber ( 10 ) ; NEW_LINE nthprimedigitsnumber ( 21 ) ; NEW_LINE
def cassini ( n ) : NEW_LINE INDENT return - 1 if ( n & 1 ) else 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( cassini ( n ) ) NEW_LINE
def findNoIsDivisibleOrNot ( n , l = [ ] ) : NEW_LINE INDENT for i in range ( 0 , len ( l ) ) : NEW_LINE INDENT if l [ i ] % n != 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT l = [ 14 , 12 , 4 , 18 ] NEW_LINE n = 2 NEW_LINE if findNoIsDivisibleOrNot ( n , l ) == 1 : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT a = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT a *= i NEW_LINE DEDENT return a NEW_LINE DEDENT def printRange ( n ) : NEW_LINE INDENT a = factorial ( n + 2 ) + 2 NEW_LINE b = a + n - 1 NEW_LINE print ( " [ " + str ( a ) + " , ▁ " + str ( b ) + " ] " ) NEW_LINE DEDENT n = 3 NEW_LINE printRange ( n ) NEW_LINE
import math NEW_LINE def findMinValue ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT val += ( math . log ( arr [ i ] ) ) NEW_LINE DEDENT left = arr [ 0 ] NEW_LINE right = arr [ n - 1 ] + 1 NEW_LINE while ( left <= right ) : NEW_LINE INDENT mid = ( left + right ) // 2 NEW_LINE temp = n * ( math . log ( mid ) ) NEW_LINE if ( val < temp ) : NEW_LINE INDENT ans = mid NEW_LINE right = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = mid + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 2 , 1 , 10 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinValue ( arr , n ) ) NEW_LINE DEDENT
from math import pow NEW_LINE def sumOfTermsInNthRow ( n ) : NEW_LINE INDENT sum = n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( " Sum ▁ of ▁ all ▁ the ▁ terms ▁ in ▁ nth ▁ row ▁ = " , int ( sumOfTermsInNthRow ( n ) ) ) NEW_LINE DEDENT
def firstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x = x // 10 NEW_LINE DEDENT return x NEW_LINE DEDENT print ( firstDigit ( 12345 ) ) NEW_LINE print ( firstDigit ( 5432 ) ) NEW_LINE
import math ; NEW_LINE def getOccurence ( n , d ) : NEW_LINE INDENT result = 0 ; NEW_LINE itr = d ; NEW_LINE while ( itr <= n ) : NEW_LINE INDENT if ( itr % 10 == d ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT if ( itr != 0 and math . floor ( itr / 10 ) == d ) : NEW_LINE INDENT result += 1 ; NEW_LINE itr += 1 ; NEW_LINE DEDENT elif ( math . floor ( itr / 10 ) == d - 1 ) : NEW_LINE INDENT itr = itr + ( 10 - d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT itr = itr + 10 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT n = 11 ; NEW_LINE d = 1 ; NEW_LINE print ( getOccurence ( n , d ) ) ; NEW_LINE
from math import fabs , cos NEW_LINE def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = 1 NEW_LINE cosx = x1 NEW_LINE cosval = cos ( n ) NEW_LINE i = 1 NEW_LINE denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE while ( accuracy <= fabs ( cosval - cosx ) ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT print ( ' { 0 : . 6 } ' . format ( cosx ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 30 NEW_LINE cal_cos ( n ) NEW_LINE DEDENT
def multiply ( v , x ) : NEW_LINE INDENT carry = 0 NEW_LINE size = len ( v ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT res = carry + v [ i ] * x NEW_LINE v [ i ] = res % 10 NEW_LINE carry = res // 10 NEW_LINE DEDENT while ( carry != 0 ) : NEW_LINE INDENT v . append ( carry % 10 ) NEW_LINE carry //= 10 NEW_LINE DEDENT DEDENT def findSumOfDigits ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT multiply ( v , i ) NEW_LINE DEDENT sum = 0 NEW_LINE size = len ( v ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT sum += v [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1000 NEW_LINE print ( findSumOfDigits ( n ) ) NEW_LINE DEDENT
def printOtherSides ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = ( n * n - 1 ) // 2 NEW_LINE c = ( n * n + 1 ) // 2 NEW_LINE print ( " b ▁ = " , b , " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT b = n * n // 4 - 1 NEW_LINE c = n * n // 4 + 1 NEW_LINE print ( " b ▁ = " , b " , ▁ c ▁ = " , c ) NEW_LINE DEDENT DEDENT DEDENT a = 3 NEW_LINE printOtherSides ( a ) NEW_LINE
def makeOdd ( n ) : NEW_LINE INDENT if n % 2 != 0 : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( n % i == 0 and ( int ) ( n / i ) % 2 == 1 ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT DEDENT n = 36 ; NEW_LINE print ( makeOdd ( n ) ) ; NEW_LINE
def getTotalXorOfSubarrayXors ( arr , N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( 0 , N , 2 ) : NEW_LINE INDENT res ^= arr [ i ] NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE print ( getTotalXorOfSubarrayXors ( arr , N ) ) NEW_LINE DEDENT
def countIterations ( arr , n ) : NEW_LINE INDENT oneFound = False ; NEW_LINE res = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT oneFound = True ; NEW_LINE DEDENT while ( i < n and arr [ i ] == 1 ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT count_zero = 0 ; NEW_LINE while ( i < n and arr [ i ] == 0 ) : NEW_LINE INDENT count_zero += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT if ( oneFound == False and i == n ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT curr_count = 0 ; NEW_LINE if ( i < n and oneFound == True ) : NEW_LINE INDENT if ( ( count_zero & 1 ) == 0 ) : NEW_LINE INDENT curr_count = count_zero // 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT curr_count = ( count_zero + 1 ) // 2 ; NEW_LINE DEDENT count_zero = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT curr_count = count_zero ; NEW_LINE count_zero = 0 ; NEW_LINE DEDENT res = max ( res , curr_count ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT arr = [ 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 1 , 0 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countIterations ( arr , n ) ) ; NEW_LINE
def printConsecutive ( last , first ) : NEW_LINE INDENT print ( first , end = " " ) NEW_LINE first += 1 NEW_LINE for x in range ( first , last + 1 ) : NEW_LINE INDENT print ( " ▁ + " , x , end = " " ) NEW_LINE DEDENT DEDENT def findConsecutive ( N ) : NEW_LINE INDENT for last in range ( 1 , N ) : NEW_LINE INDENT for first in range ( 0 , last ) : NEW_LINE INDENT if 2 * N == ( last - first ) * ( last + first + 1 ) : NEW_LINE INDENT print ( N , " = ▁ " , end = " " ) NEW_LINE printConsecutive ( last , first + 1 ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT n = 12 NEW_LINE findConsecutive ( n ) NEW_LINE
def printNthElement ( n ) : NEW_LINE INDENT arr = [ 0 ] * ( n + 1 ) ; NEW_LINE arr [ 1 ] = 4 NEW_LINE arr [ 2 ] = 7 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT if ( i % 2 != 0 ) : NEW_LINE INDENT arr [ i ] = arr [ i // 2 ] * 10 + 4 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = arr [ ( i // 2 ) - 1 ] * 10 + 7 NEW_LINE DEDENT DEDENT return arr [ n ] NEW_LINE DEDENT n = 6 NEW_LINE print ( printNthElement ( n ) ) NEW_LINE
def maxSumLCM ( n ) : NEW_LINE INDENT max_sum = 0 NEW_LINE i = 1 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT max_sum = max_sum + i NEW_LINE if ( n // i != i ) : NEW_LINE INDENT max_sum = max_sum + ( n // i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return max_sum NEW_LINE DEDENT n = 2 NEW_LINE print ( maxSumLCM ( n ) ) NEW_LINE
import math NEW_LINE if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE print ( math . sqrt ( n ) ) NEW_LINE DEDENT
import sys NEW_LINE def findMaxValue ( ) : NEW_LINE INDENT res = 2 ; NEW_LINE fact = 2 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( fact < 0 or fact > sys . maxsize ) : NEW_LINE INDENT break ; NEW_LINE DEDENT res += 1 ; NEW_LINE fact = fact * res ; NEW_LINE DEDENT return res - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " Maximum ▁ value ▁ of ▁ integer : " , findMaxValue ( ) ) ; NEW_LINE DEDENT
def func ( a , k , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % k == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT a = [ 14 , 27 , 38 , 76 , 84 ] NEW_LINE k = 19 NEW_LINE res = func ( a , k , 5 ) NEW_LINE if ( res ) : NEW_LINE INDENT print ( " true " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " false " ) NEW_LINE DEDENT
def tidyNum ( str , len ) : NEW_LINE INDENT for i in range ( len - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] > str [ i + 1 ] ) : NEW_LINE INDENT str [ i ] -= 1 NEW_LINE for j in range ( i + 1 , len ) : NEW_LINE INDENT str [ j ] = 9 NEW_LINE DEDENT DEDENT DEDENT return str NEW_LINE DEDENT str = [ 1 , 1 , 3 , 3 , 3 , 4 , 4 , 5 , 5 , 3 , 8 ] NEW_LINE len = len ( str ) NEW_LINE num = tidyNum ( str , len ) NEW_LINE for i in range ( 0 , len ) : NEW_LINE INDENT print ( str [ i ] , end = " " ) NEW_LINE DEDENT
def findCount ( m , n ) : NEW_LINE INDENT num1 = 0 NEW_LINE for i in range ( 0 , m ) : NEW_LINE INDENT num1 = ( num1 * 10 ) + 9 NEW_LINE DEDENT num2 = 0 NEW_LINE for i in range ( 0 , ( m - 1 ) ) : NEW_LINE INDENT num2 = ( num2 * 10 ) + 9 NEW_LINE DEDENT return int ( ( num1 / n ) - ( num2 / n ) ) NEW_LINE DEDENT m = 2 ; n = 6 NEW_LINE print ( findCount ( m , n ) ) NEW_LINE
def findNthEvenDigitNumber ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( True ) : NEW_LINE INDENT curr = i ; NEW_LINE isCurrEvenDigit = True ; NEW_LINE while ( curr != 0 ) : NEW_LINE INDENT if ( curr % 10 == 1 or curr % 10 == 3 or curr % 10 == 5 or curr % 10 == 7 or curr % 10 == 9 ) : NEW_LINE INDENT isCurrEvenDigit = False ; NEW_LINE DEDENT curr = curr // 10 ; NEW_LINE DEDENT if ( isCurrEvenDigit == True ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT print ( findNthEvenDigitNumber ( 2 ) ) ; NEW_LINE print ( findNthEvenDigitNumber ( 10 ) ) ; NEW_LINE
def findNthEvenDigitNumber ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT v = [ ] NEW_LINE n = n - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT v . append ( n % 5 ) NEW_LINE n = n // 5 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( len ( v ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT result = result * 10 NEW_LINE result = result + v [ i ] NEW_LINE DEDENT return 2 * result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( findNthEvenDigitNumber ( 2 ) ) NEW_LINE print ( findNthEvenDigitNumber ( 10 ) ) NEW_LINE DEDENT
def isDivisibleBy25 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( int ) ( st [ n - 1 ] ) == 0 and ( ( int ) ( st [ n - 2 ] ) == 0 ) or ( ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) % 25 == 0 ) ) NEW_LINE DEDENT st = "76955" NEW_LINE if ( isDivisibleBy25 ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 and n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( st [ n - 1 ] ) % 16 == 0 ) ) NEW_LINE DEDENT if ( n == 3 ) : NEW_LINE INDENT return ( ( ( int ) ( st [ n - 3 ] ) * 100 + ( int ) ( st [ n - 2 ] ) * 10 + ( int ) ( st [ n - 1 ] ) ) % 16 == 0 ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE fourth_last = ( int ) ( st [ n - 4 ] ) NEW_LINE return ( ( fourth_last * 1000 + third_last * 100 + second_last * 10 + last ) % 16 == 0 ) NEW_LINE DEDENT st = "769528" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findIndex ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT a = 0 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE res = 1 NEW_LINE while ( c < n ) : NEW_LINE INDENT c = a + b NEW_LINE res = res + 1 NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return res NEW_LINE DEDENT result = findIndex ( 21 ) NEW_LINE print ( result ) NEW_LINE
import math NEW_LINE def divisorSum ( N , K ) : NEW_LINE INDENT Sum = 0 NEW_LINE for i in range ( 2 , math . ceil ( math . sqrt ( N ) ) ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT Sum += ( i + int ( N / i ) ) NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n == 1 or n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isHyperPerfect ( N , K ) : NEW_LINE INDENT Sum = divisorSum ( N , K ) NEW_LINE if ( ( 1 + K * ( Sum ) ) == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT N1 = 1570153 NEW_LINE K1 = 12 NEW_LINE N2 = 321 NEW_LINE K2 = 3 NEW_LINE if ( isHyperPerfect ( N1 , K1 ) ) : NEW_LINE INDENT print ( N1 , " ▁ is ▁ " , K1 , " - HyperPerfect " , sep = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N1 , " ▁ is ▁ not ▁ " , K1 , " - HyperPerfect " , sep = " " ) NEW_LINE DEDENT if ( isHyperPerfect ( N2 , K2 ) ) : NEW_LINE INDENT print ( N2 , " ▁ is ▁ " , K2 , " - HyperPerfect " , sep = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( N2 , " ▁ is ▁ not ▁ " , K2 , " - HyperPerfect " , sep = " " ) NEW_LINE DEDENT
import math NEW_LINE def firstkdigits ( n , k ) : NEW_LINE INDENT product = n * math . log ( n , 10 ) ; NEW_LINE decimal_part = product - math . floor ( product ) ; NEW_LINE decimal_part = pow ( 10 , decimal_part ) ; NEW_LINE digits = pow ( 10 , k - 1 ) ; NEW_LINE return math . floor ( decimal_part * digits ) ; NEW_LINE DEDENT n = 1450 ; NEW_LINE k = 6 ; NEW_LINE print ( firstkdigits ( n , k ) ) ; NEW_LINE
def printWellOrdered ( number , x , k ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT print ( number , end = " ▁ " ) NEW_LINE return NEW_LINE DEDENT for i in range ( ( x + 1 ) , 10 ) : NEW_LINE INDENT printWellOrdered ( number * 10 + i , i , k - 1 ) NEW_LINE DEDENT DEDENT def generateWellOrdered ( k ) : NEW_LINE INDENT printWellOrdered ( 0 , 0 , k ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT k = 3 NEW_LINE generateWellOrdered ( k ) NEW_LINE DEDENT
def moduloMultiplication ( a , b , mod ) : NEW_LINE INDENT a = a % mod ; NEW_LINE while ( b ) : NEW_LINE INDENT if ( b & 1 ) : NEW_LINE INDENT res = ( res + a ) % mod ; NEW_LINE DEDENT a = ( 2 * a ) % mod ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT a = 10123465234878998 ; NEW_LINE b = 65746311545646431 ; NEW_LINE m = 10005412336548794 ; NEW_LINE print ( moduloMultiplication ( a , b , m ) ) ; NEW_LINE
def count2sinRangeAtDigit ( number , d ) : NEW_LINE INDENT powerOf10 = int ( pow ( 10 , d ) ) ; NEW_LINE nextPowerOf10 = powerOf10 * 10 ; NEW_LINE right = number % powerOf10 ; NEW_LINE roundDown = number - number % nextPowerOf10 ; NEW_LINE roundup = roundDown + nextPowerOf10 ; NEW_LINE digit = ( number // powerOf10 ) % 10 ; NEW_LINE if ( digit < 2 ) : NEW_LINE INDENT return roundDown // 10 ; NEW_LINE DEDENT if ( digit == 2 ) : NEW_LINE INDENT return roundDown // 10 + right + 1 ; NEW_LINE DEDENT return roundup // 10 ; NEW_LINE DEDENT def numberOf2sinRange ( number ) : NEW_LINE INDENT s = str ( number ) ; NEW_LINE len1 = len ( s ) ; NEW_LINE count = 0 ; NEW_LINE for digit in range ( len1 ) : NEW_LINE INDENT count += count2sinRangeAtDigit ( number , digit ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT print ( numberOf2sinRange ( 22 ) ) ; NEW_LINE print ( numberOf2sinRange ( 100 ) ) ; NEW_LINE
def findStarNum ( n ) : NEW_LINE INDENT return ( 6 * n * ( n - 1 ) + 1 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findStarNum ( n ) ) NEW_LINE
def isDivisibleBy5 ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE return ( ( st [ n - 1 ] == '0' ) or ( st [ n - 1 ] == '5' ) ) NEW_LINE DEDENT st = "76955" NEW_LINE if isDivisibleBy5 ( st ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No ▁ " NEW_LINE DEDENT
def isTidy ( num ) : NEW_LINE INDENT prev = 10 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE num /= 10 NEW_LINE if rem > prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = rem NEW_LINE DEDENT return True NEW_LINE DEDENT num = 1556 NEW_LINE if isTidy ( num ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def squareFree ( n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT isSqFree = True ; NEW_LINE j = 2 ; NEW_LINE while ( j * j <= i ) : NEW_LINE INDENT if ( i % ( j * j ) == 0 ) : NEW_LINE INDENT isSqFree = False ; NEW_LINE break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( isSqFree == True ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE if ( cnt == n ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( squareFree ( n ) ) ; NEW_LINE
import math as mt NEW_LINE def kFactors ( n , k ) : NEW_LINE INDENT a = list ( ) NEW_LINE while n % 2 == 0 : NEW_LINE INDENT a . append ( 2 ) NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( n ) ) , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n / i ; NEW_LINE a . append ( i ) NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT a . append ( n ) NEW_LINE DEDENT if len ( a ) < k : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( k - 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " , ▁ " ) NEW_LINE DEDENT product = 1 NEW_LINE for i in range ( k - 1 , len ( a ) ) : NEW_LINE INDENT product *= a [ i ] NEW_LINE DEDENT print ( product ) NEW_LINE DEDENT n , k = 54 , 3 NEW_LINE kFactors ( n , k ) NEW_LINE
def nondecdigits ( n ) : NEW_LINE INDENT x = 0 NEW_LINE for x in range ( n , 0 , - 1 ) : NEW_LINE INDENT no = x NEW_LINE prev_dig = 11 NEW_LINE flag = True NEW_LINE while ( no != 0 ) : NEW_LINE INDENT if ( prev_dig < no % 10 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT prev_dig = no % 10 NEW_LINE no //= 10 NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 200 NEW_LINE print ( nondecdigits ( n ) ) NEW_LINE DEDENT
def nondecdigits ( s ) : NEW_LINE INDENT m = len ( s ) ; NEW_LINE a = [ 0 ] * m ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT a [ i ] = ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE DEDENT level = m - 1 ; NEW_LINE for i in range ( m - 1 , 0 , - 1 ) : NEW_LINE INDENT if ( a [ i ] < a [ i - 1 ] ) : NEW_LINE INDENT a [ i - 1 ] -= 1 ; NEW_LINE level = i - 1 ; NEW_LINE DEDENT DEDENT if ( a [ 0 ] != 0 ) : NEW_LINE INDENT for i in range ( level + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) ; NEW_LINE DEDENT for i in range ( level + 1 , m ) : NEW_LINE INDENT print ( "9" , end = " " ) ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 1 , level ) : NEW_LINE INDENT print ( a [ i ] , end = " " ) ; NEW_LINE DEDENT for i in range ( level + 1 , m ) : NEW_LINE INDENT print ( "9" , end = " " ) ; NEW_LINE DEDENT DEDENT DEDENT n = "200" ; NEW_LINE nondecdigits ( n ) ; NEW_LINE
import math NEW_LINE def countDivisors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE cnt = cnt + 2 NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT print ( " Total ▁ distinct ▁ divisors ▁ of ▁ 100 ▁ are ▁ : ▁ " , countDivisors ( 100 ) ) NEW_LINE
import math NEW_LINE def hasEvenNumberOfFactors ( n ) : NEW_LINE INDENT root_n = math . sqrt ( n ) NEW_LINE if ( ( root_n * root_n ) == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def printStatusOfDoors ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( hasEvenNumberOfFactors ( i ) == True ) : NEW_LINE INDENT print ( " closed " , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " open " , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE printStatusOfDoors ( n ) NEW_LINE
def validate ( n ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT temp = n ; NEW_LINE count = 0 ; NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 10 == i ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count > i ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT temp //= 10 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT n = 1552793 ; NEW_LINE geek = " True " if validate ( n ) else " False " ; NEW_LINE print ( geek ) ; NEW_LINE
def divisibleBy36 ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT if ( l == 1 and num [ 0 ] != '0' ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT two_digit_num = ( ( ( int ) ( num [ l - 2 ] ) ) * 10 + ( int ) ( num [ l - 1 ] ) ) NEW_LINE if ( two_digit_num % 4 != 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT sm = 0 NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT sm = sm + ( int ) ( num [ i ] ) NEW_LINE DEDENT if ( sm % 9 != 0 ) : NEW_LINE INDENT return ( " No " ) NEW_LINE DEDENT return ( " Yes " ) NEW_LINE DEDENT num = "92567812197966231384" NEW_LINE print ( divisibleBy36 ( num ) ) NEW_LINE
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return ( ( int ) ( st [ 0 ] ) % 8 == 0 ) NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return ( ( int ) ( st [ n - 2 ] ) * 10 + ( ( int ) ( str [ n - 1 ] ) % 8 == 0 ) ) NEW_LINE DEDENT last = ( int ) ( st [ n - 1 ] ) NEW_LINE second_last = ( int ) ( st [ n - 2 ] ) NEW_LINE third_last = ( int ) ( st [ n - 3 ] ) NEW_LINE return ( ( third_last * 100 + second_last * 10 + last ) % 8 == 0 ) NEW_LINE DEDENT st = "76952" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) NEW_LINE DEDENT
def countDigits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def checkPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def printPrimePoints ( n ) : NEW_LINE INDENT count = countDigits ( n ) NEW_LINE if ( count == 1 or count == 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT found = False NEW_LINE for i in range ( 1 , ( count - 1 ) ) : NEW_LINE INDENT left = n // ( pow ( 10 , count - i ) ) NEW_LINE right = n % ( pow ( 10 , count - i - 1 ) ) NEW_LINE if ( checkPrime ( left ) == 0 and checkPrime ( right ) == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE found = True NEW_LINE DEDENT DEDENT if ( found == False ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2317 NEW_LINE printPrimePoints ( n ) NEW_LINE DEDENT
def power ( num , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT return power ( num , n // 2 ) * power ( num , n // 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return num * power ( num , n // 2 ) * power ( num , n // 2 ) NEW_LINE DEDENT DEDENT def checkRecursive ( x , n , curr_num = 1 , curr_sum = 0 ) : NEW_LINE INDENT results = 0 NEW_LINE DEDENT ' NEW_LINE INDENT p = power ( curr_num , n ) NEW_LINE while ( p + curr_sum < x ) : NEW_LINE INDENT results += checkRecursive ( x , n , curr_num + 1 , p + curr_sum ) NEW_LINE curr_num = curr_num + 1 NEW_LINE p = power ( curr_num , n ) NEW_LINE DEDENT if ( p + curr_sum == x ) : NEW_LINE INDENT results = results + 1 NEW_LINE DEDENT return results NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE n = 2 NEW_LINE print ( checkRecursive ( x , n ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def printGenerators ( n ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) ; NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( gcd ( i , n ) == 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT n = 10 ; NEW_LINE printGenerators ( n ) ; NEW_LINE
def check ( num ) : NEW_LINE INDENT digitSum = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rem = num % 10 NEW_LINE digitSum = digitSum + rem NEW_LINE num = num / 10 NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT num = 1332 NEW_LINE if ( check ( num ) ) : NEW_LINE INDENT print " Yes " NEW_LINE DEDENT else : NEW_LINE INDENT print " No " NEW_LINE DEDENT
MAX = 100001 NEW_LINE perfectDiv = [ 0 ] * MAX NEW_LINE def precomputeCounts ( ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i < MAX : NEW_LINE INDENT for j in range ( i * i , MAX , i * i ) : NEW_LINE INDENT perfectDiv [ j ] += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def countPerfectDivisors ( n ) : NEW_LINE INDENT return perfectDiv [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT precomputeCounts ( ) NEW_LINE n = 16 NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ of ▁ " , n , " ▁ = ▁ " , countPerfectDivisors ( n ) ) NEW_LINE n = 12 NEW_LINE print ( " Total ▁ perfect ▁ divisors ▁ of ▁ " , n , " ▁ = ▁ " , countPerfectDivisors ( n ) ) NEW_LINE DEDENT
import math as mt NEW_LINE MAXN = 100001 NEW_LINE spf = [ 0 for i in range ( MAXN ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAXN ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , MAXN , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT for i in range ( 3 , mt . ceil ( mt . sqrt ( MAXN ) ) ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * i , MAXN , i ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def getFactorization ( x ) : NEW_LINE INDENT ret = list ( ) NEW_LINE while ( x != 1 ) : NEW_LINE INDENT ret . append ( spf [ x ] ) NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT return ret NEW_LINE DEDENT sieve ( ) NEW_LINE x = 12246 NEW_LINE print ( " prime ▁ factorization ▁ for " , x , " : ▁ " , end = " " ) NEW_LINE p = getFactorization ( x ) NEW_LINE for i in range ( len ( p ) ) : NEW_LINE INDENT print ( p [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def largestGCDSubsequence ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE maxele = max ( arr ) NEW_LINE for i in range ( 2 , maxele + 1 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % i == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans = max ( ans , count ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 2 , 5 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE print ( largestGCDSubsequence ( arr , size ) ) NEW_LINE DEDENT
MAX = 100006 ; NEW_LINE count = [ 0 ] * MAX ; NEW_LINE def sieve ( ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( i * i <= MAX ) : NEW_LINE INDENT if ( count [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT count [ j ] += 1 ; NEW_LINE DEDENT count [ i ] = 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += count [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT sieve ( ) ; NEW_LINE print ( query ( 6 , 10 ) , query ( 1 , 5 ) ) ; NEW_LINE
def generateNumbers ( factor , n , k ) : NEW_LINE INDENT next = [ 0 ] * k ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT toincrement = 0 ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( next [ j ] < next [ toincrement ] ) : NEW_LINE INDENT toincrement = j ; NEW_LINE DEDENT DEDENT if ( output != next [ toincrement ] ) : NEW_LINE INDENT output = next [ toincrement ] ; NEW_LINE print ( next [ toincrement ] , end = " ▁ " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT next [ toincrement ] += factor [ toincrement ] ; NEW_LINE DEDENT DEDENT factor = [ 3 , 5 , 7 ] ; NEW_LINE n = 10 ; NEW_LINE k = len ( factor ) ; NEW_LINE generateNumbers ( factor , n , k ) ; NEW_LINE
def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return GCD ( b , a % b ) NEW_LINE DEDENT def multiplicativeOrder ( A , N ) : NEW_LINE INDENT if ( GCD ( A , N ) != 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT result = 1 NEW_LINE K = 1 NEW_LINE while ( K < N ) : NEW_LINE INDENT result = ( result * A ) % N NEW_LINE if ( result == 1 ) : NEW_LINE INDENT return K NEW_LINE DEDENT K = K + 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT A = 4 NEW_LINE N = 7 NEW_LINE print ( multiplicativeOrder ( A , N ) ) NEW_LINE
import math NEW_LINE def sumOfRange ( a , b ) : NEW_LINE INDENT i = ( a * ( a + 1 ) ) >> 1 ; NEW_LINE j = ( b * ( b + 1 ) ) >> 1 ; NEW_LINE return ( i - j ) ; NEW_LINE DEDENT def sumofproduct ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE root = int ( math . sqrt ( n ) ) ; NEW_LINE for i in range ( 1 , root + 1 ) : NEW_LINE INDENT up = int ( n / i ) ; NEW_LINE low = max ( int ( n / ( i + 1 ) ) , root ) ; NEW_LINE sum += ( i * sumOfRange ( up , low ) ) ; NEW_LINE sum += ( i * int ( n / i ) ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT n = 10 ; NEW_LINE print ( sumofproduct ( n ) ) ; NEW_LINE
def minPower ( n , x ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT ans = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT ans += ( n % x ) NEW_LINE n //= x NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 5 NEW_LINE x = 3 NEW_LINE print ( minPower ( n , x ) ) NEW_LINE
def calSum ( n ) : NEW_LINE INDENT a = 3 NEW_LINE b = 0 NEW_LINE c = 2 NEW_LINE INDENT return 3 NEW_LINE return 3 NEW_LINE return 5 NEW_LINE DEDENT sum = 5 NEW_LINE while ( n > 2 ) : NEW_LINE INDENT d = a + b NEW_LINE sum = sum + d NEW_LINE a = b NEW_LINE b = c NEW_LINE c = d NEW_LINE n = n - 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 9 NEW_LINE print ( calSum ( n ) ) NEW_LINE
def findKHCF ( x , y , k ) : NEW_LINE INDENT small = min ( x , y ) NEW_LINE count = 1 NEW_LINE for i in range ( 2 , small + 1 ) : NEW_LINE INDENT if ( x % i == 0 and y % i == 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( count == k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT x = 4 NEW_LINE y = 24 NEW_LINE k = 3 NEW_LINE print ( findKHCF ( x , y , k ) ) NEW_LINE
import math NEW_LINE def findMinNumber ( n ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 1 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT count += 1 NEW_LINE n //= 2 NEW_LINE DEDENT if count % 2 is not 0 : NEW_LINE INDENT ans *= 2 NEW_LINE DEDENT for i in range ( 3 , ( int ) ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT count = 0 NEW_LINE while n % i == 0 : NEW_LINE INDENT count += 1 NEW_LINE n //= i NEW_LINE DEDENT if count % 2 is not 0 : NEW_LINE INDENT ans *= i NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT ans *= n NEW_LINE DEDENT return ans NEW_LINE DEDENT n = 72 NEW_LINE print ( findMinNumber ( n ) ) NEW_LINE
def isToOne ( n ) : NEW_LINE INDENT return ( n > 0 ) NEW_LINE DEDENT n = 5 NEW_LINE if isToOne ( n ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findgcd ( n , x , y ) : NEW_LINE INDENT g = gcd ( x , y ) NEW_LINE for i in range ( g ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT n = 123 NEW_LINE x = 5 NEW_LINE y = 2 NEW_LINE findgcd ( n , x , y ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT i = 1 NEW_LINE new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x /= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT def countFactorialXNotY ( x , y ) : NEW_LINE INDENT return ( firstFactorialDivisibleNumber ( y ) - firstFactorialDivisibleNumber ( x ) ) NEW_LINE DEDENT x = 15 NEW_LINE y = 25 NEW_LINE print ( countFactorialXNotY ( x , y ) ) NEW_LINE
def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT fact = fact * i NEW_LINE if ( fact % x == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE
def SieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * p NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i += p NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def findPrimePair ( n ) : NEW_LINE INDENT isPrime = [ 0 ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , isPrime ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( isPrime [ i ] and isPrime [ n - i ] ) : NEW_LINE INDENT print ( i , ( n - i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT n = 74 NEW_LINE findPrimePair ( n ) NEW_LINE
def getFirstDigit ( x ) : NEW_LINE INDENT while ( x >= 10 ) : NEW_LINE INDENT x //= 10 NEW_LINE DEDENT return x NEW_LINE DEDENT def getCountWithSameStartAndEndFrom1 ( x ) : NEW_LINE INDENT if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT tens = x // 10 NEW_LINE res = tens + 9 NEW_LINE firstDigit = getFirstDigit ( x ) NEW_LINE lastDigit = x % 10 NEW_LINE if ( lastDigit < firstDigit ) : NEW_LINE INDENT res = res - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def getCountWithSameStartAndEnd ( start , end ) : NEW_LINE INDENT return ( getCountWithSameStartAndEndFrom1 ( end ) - getCountWithSameStartAndEndFrom1 ( start - 1 ) ) NEW_LINE DEDENT start = 5 NEW_LINE end = 40 NEW_LINE print ( getCountWithSameStartAndEnd ( start , end ) ) NEW_LINE
def sieveOfEratosthenes ( n , isPrime ) : NEW_LINE INDENT isPrime [ 0 ] = isPrime [ 1 ] = False NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT isPrime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( isPrime [ p ] == True ) : NEW_LINE INDENT i = p * 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT isPrime [ i ] = False NEW_LINE i = i + p NEW_LINE DEDENT DEDENT p = p + 1 NEW_LINE DEDENT DEDENT def rightTruPrime ( n ) : NEW_LINE INDENT isPrime = [ None ] * ( n + 1 ) NEW_LINE sieveOfEratosthenes ( n , isPrime ) NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( isPrime [ n ] ) : NEW_LINE INDENT n = n // 10 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 59399 NEW_LINE if ( rightTruPrime ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def SieveOfEratosthenes ( n , prime ) : NEW_LINE INDENT for i in range ( 0 , n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT p = 2 NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def mersennePrimes ( n ) : NEW_LINE INDENT prime = [ 0 ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( n , prime ) NEW_LINE k = 2 NEW_LINE while ( ( ( 1 << k ) - 1 ) <= n ) : NEW_LINE INDENT num = ( 1 << k ) - 1 NEW_LINE if ( prime [ num ] ) : NEW_LINE INDENT print ( num , end = " ▁ " ) NEW_LINE DEDENT k += 1 NEW_LINE DEDENT DEDENT n = 31 NEW_LINE print ( " Mersenne ▁ prime ▁ numbers ▁ smaller " , " than ▁ or ▁ equal ▁ to ▁ " , n ) NEW_LINE mersennePrimes ( n ) NEW_LINE
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT ans += ( i % K ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT N = 10 ; NEW_LINE K = 2 ; NEW_LINE print ( findSum ( N , K ) ) ; NEW_LINE
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE y = N / K ; NEW_LINE x = N % K ; NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT N = 10 ; NEW_LINE K = 2 ; NEW_LINE print ( findSum ( N , K ) ) ; NEW_LINE
import math NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def findnum ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count_after_dot = 0 NEW_LINE dot_seen = 0 NEW_LINE num = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] != ' . ' ) : NEW_LINE INDENT num = num * 10 + int ( str [ i ] ) NEW_LINE if ( dot_seen == 1 ) : NEW_LINE INDENT count_after_dot += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dot_seen = 1 NEW_LINE DEDENT DEDENT if ( dot_seen == 0 ) : NEW_LINE return 1 NEW_LINE dem = int ( math . pow ( 10 , count_after_dot ) ) NEW_LINE return ( dem / gcd ( num , dem ) ) NEW_LINE DEDENT str = "5.125" NEW_LINE print findnum ( str ) NEW_LINE
def maxHandshake ( n ) : NEW_LINE INDENT return int ( ( n * ( n - 1 ) ) / 2 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( maxHandshake ( n ) ) NEW_LINE
def divisible ( N , digit ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT ans = ( ans * 10 + ( ord ( N [ i ] ) - ord ( '0' ) ) ) ; NEW_LINE ans %= digit ; NEW_LINE DEDENT return ( ans == 0 ) ; NEW_LINE DEDENT def allDigits ( N ) : NEW_LINE INDENT divide = [ False ] * 10 ; NEW_LINE for digit in range ( 2 , 10 ) : NEW_LINE INDENT if ( divisible ( N , digit ) ) : NEW_LINE INDENT divide [ digit ] = True ; NEW_LINE DEDENT DEDENT result = 0 ; NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT if ( divide [ ( ord ( N [ i ] ) - ord ( '0' ) ) ] == True ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT N = "122324" ; NEW_LINE print ( allDigits ( N ) ) ; NEW_LINE
def countNums ( n , x , y ) : NEW_LINE INDENT arr = [ False for i in range ( n + 2 ) ] NEW_LINE if ( x <= n ) : NEW_LINE INDENT arr [ x ] = True NEW_LINE DEDENT if ( y <= n ) : NEW_LINE INDENT arr [ y ] = True NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( min ( x , y ) , n + 1 ) : NEW_LINE INDENT if ( arr [ i ] ) : NEW_LINE INDENT if ( i + x <= n ) : NEW_LINE INDENT arr [ i + x ] = True NEW_LINE DEDENT if ( i + y <= n ) : NEW_LINE INDENT arr [ i + y ] = True NEW_LINE DEDENT result = result + 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT n = 15 NEW_LINE x = 5 NEW_LINE y = 7 NEW_LINE print ( countNums ( n , x , y ) ) NEW_LINE
def reverse ( x ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT rev = ( rev * 10 ) + x % 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def printEmirp ( n ) : NEW_LINE INDENT prime = [ 1 ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = 0 ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] == 1 ) : NEW_LINE INDENT rev = reverse ( p ) ; NEW_LINE if ( p != rev and rev <= n and prime [ rev ] == 1 ) : NEW_LINE INDENT print ( p , rev , end = " ▁ " ) ; NEW_LINE prime [ rev ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 100 ; NEW_LINE printEmirp ( n ) ; NEW_LINE
import math NEW_LINE def getSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE i = 1 NEW_LINE while i <= ( math . sqrt ( n ) ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + i NEW_LINE sum = sum + ( n / i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT sum = sum - n NEW_LINE return sum NEW_LINE DEDENT def checkAbundant ( n ) : NEW_LINE INDENT if ( getSum ( n ) > n ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( checkAbundant ( 12 ) == 1 ) : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT if ( checkAbundant ( 15 ) == 1 ) : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT
import math NEW_LINE def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for factor in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT power = 0 NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n // factor NEW_LINE power = power + 1 NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return false NEW_LINE DEDENT DEDENT return ( n == 1 ) NEW_LINE DEDENT print ( " YES " if isPowerful ( 20 ) else " NO " ) NEW_LINE print ( " YES " if isPowerful ( 27 ) else " NO " ) NEW_LINE
import math NEW_LINE def divisorsSum ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT sum = sum + i NEW_LINE sum = sum + i ; NEW_LINE sum = sum + ( n / i ) NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT def isDeficient ( n ) : NEW_LINE INDENT return ( divisorsSum ( n ) < ( 2 * n ) ) NEW_LINE DEDENT if ( isDeficient ( 12 ) ) : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT if ( isDeficient ( 15 ) ) : NEW_LINE INDENT print " YES " NEW_LINE DEDENT else : NEW_LINE INDENT print " NO " NEW_LINE DEDENT
import math NEW_LINE MAX = 10000 NEW_LINE primes = [ ] NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ 0 ] * ( ( MAX / 2 ) + 100 ) NEW_LINE i = 1 NEW_LINE while i <= ( ( math . sqrt ( MAX ) - 1 ) / 2 ) : NEW_LINE INDENT j = ( i * ( i + 1 ) ) << 1 NEW_LINE while j <= MAX / 2 : NEW_LINE INDENT marked [ j ] = 1 NEW_LINE j = j + 2 * i + 1 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT primes . append ( 2 ) NEW_LINE i = 1 NEW_LINE while i <= MAX / 2 : NEW_LINE INDENT if marked [ i ] == 0 : NEW_LINE INDENT primes . append ( 2 * i + 1 ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT DEDENT def isSmith ( n ) : NEW_LINE INDENT original_no = n NEW_LINE pDigitSum = 0 ; NEW_LINE i = 0 NEW_LINE while ( primes [ i ] <= n / 2 ) : NEW_LINE INDENT while n % primes [ i ] == 0 : NEW_LINE INDENT p = primes [ i ] NEW_LINE n = n / p NEW_LINE while p > 0 : NEW_LINE INDENT pDigitSum += ( p % 10 ) NEW_LINE p = p / 10 NEW_LINE DEDENT DEDENT i = i + 1 NEW_LINE DEDENT if not n == 1 and not n == original_no : NEW_LINE INDENT while n > 0 : NEW_LINE INDENT pDigitSum = pDigitSum + n % 10 NEW_LINE n = n / 10 NEW_LINE DEDENT DEDENT sumDigits = 0 NEW_LINE while original_no > 0 : NEW_LINE INDENT sumDigits = sumDigits + original_no % 10 NEW_LINE original_no = original_no / 10 NEW_LINE DEDENT return pDigitSum == sumDigits NEW_LINE DEDENT sieveSundaram ( ) ; NEW_LINE print " Printing ▁ first ▁ few ▁ Smith ▁ Numbers ▁ using ▁ isSmith ( ) " NEW_LINE i = 1 NEW_LINE while i < 500 : NEW_LINE INDENT if isSmith ( i ) : NEW_LINE INDENT print i , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT
import math NEW_LINE def iskaprekar ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT sq_n = n * n NEW_LINE count_digits = 1 NEW_LINE while not sq_n == 0 : NEW_LINE INDENT count_digits = count_digits + 1 NEW_LINE sq_n = sq_n / 10 NEW_LINE DEDENT r_digits = 0 NEW_LINE while r_digits < count_digits : NEW_LINE INDENT r_digits = r_digits + 1 NEW_LINE eq_parts = ( int ) ( math . pow ( 10 , r_digits ) ) NEW_LINE if eq_parts == n : NEW_LINE INDENT continue NEW_LINE DEDENT sum = sq_n / eq_parts + sq_n % eq_parts NEW_LINE if sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT i = 1 NEW_LINE while i < 10000 : NEW_LINE INDENT if ( iskaprekar ( i ) ) : NEW_LINE INDENT print i , " ▁ " , NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT
def isKeith ( x ) : NEW_LINE INDENT terms = [ ] ; NEW_LINE temp = x ; NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT terms . append ( temp % 10 ) ; NEW_LINE temp = int ( temp / 10 ) ; NEW_LINE n += 1 ; NEW_LINE DEDENT terms . reverse ( ) ; NEW_LINE next_term = 0 ; NEW_LINE i = n ; NEW_LINE while ( next_term < x ) : NEW_LINE INDENT next_term = 0 ; NEW_LINE for j in range ( 1 , n + 1 ) : NEW_LINE INDENT next_term += terms [ i - j ] ; NEW_LINE DEDENT terms . append ( next_term ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return ( next_term == x ) ; NEW_LINE DEDENT print ( " Yes " ) if ( isKeith ( 14 ) ) else print ( " No " ) ; NEW_LINE print ( " Yes " ) if ( isKeith ( 12 ) ) else print ( " No " ) ; NEW_LINE print ( " Yes " ) if ( isKeith ( 197 ) ) else print ( " No " ) ; NEW_LINE
def canBeSumofConsec ( n ) : NEW_LINE INDENT return ( ( n & ( n - 1 ) ) and n ) NEW_LINE DEDENT n = 15 NEW_LINE if ( canBeSumofConsec ( n ) ) : NEW_LINE INDENT print ( " true " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " false " ) NEW_LINE DEDENT
def evenFibSum ( limit ) : NEW_LINE INDENT if ( limit < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ef1 = 0 NEW_LINE ef2 = 2 NEW_LINE sm = ef1 + ef2 NEW_LINE while ( ef2 <= limit ) : NEW_LINE INDENT ef3 = 4 * ef2 + ef1 NEW_LINE if ( ef3 > limit ) : NEW_LINE INDENT break NEW_LINE DEDENT ef1 = ef2 NEW_LINE ef2 = ef3 NEW_LINE sm = sm + ef2 NEW_LINE DEDENT return sm NEW_LINE DEDENT limit = 400 NEW_LINE print ( evenFibSum ( limit ) ) NEW_LINE
import math NEW_LINE def isPerfect ( n ) : NEW_LINE INDENT s = math . sqrt ( n ) NEW_LINE return ( s * s == n ) NEW_LINE DEDENT def divisorsCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , ( int ) ( math . sqrt ( n ) + 2 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = count + 2 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def kDivisors ( a , b , k ) : NEW_LINE INDENT for i in range ( a , b + 1 ) : NEW_LINE INDENT if ( isPerfect ( i ) ) : NEW_LINE INDENT if ( divisorsCount ( i ) == k ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT a = 2 NEW_LINE b = 49 NEW_LINE k = 3 NEW_LINE print ( kDivisors ( a , b , k ) ) NEW_LINE
def evenFib ( n ) : NEW_LINE INDENT if ( n < 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return ( ( 4 * evenFib ( n - 1 ) ) + evenFib ( n - 2 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( evenFib ( n ) ) NEW_LINE
MAX = 3000 ; NEW_LINE def smartNumber ( n ) : NEW_LINE INDENT primes = [ 0 ] * MAX ; NEW_LINE result = [ ] ; NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( primes [ i ] == 0 ) : NEW_LINE INDENT primes [ i ] = 1 ; NEW_LINE j = i * 2 ; NEW_LINE while ( j < MAX ) : NEW_LINE INDENT primes [ j ] -= 1 ; NEW_LINE if ( ( primes [ j ] + 3 ) == 0 ) : NEW_LINE INDENT result . append ( j ) ; NEW_LINE DEDENT j = j + i ; NEW_LINE DEDENT DEDENT DEDENT result . sort ( ) ; NEW_LINE return result [ n - 1 ] ; NEW_LINE DEDENT n = 50 ; NEW_LINE print ( smartNumber ( n ) ) ; NEW_LINE
import math NEW_LINE def countSteps ( x , y ) : NEW_LINE INDENT if ( x % y == 0 ) : NEW_LINE INDENT return math . floor ( x / y ) ; NEW_LINE DEDENT return math . floor ( ( x / y ) + countSteps ( y , x % y ) ) ; NEW_LINE DEDENT x = 100 ; NEW_LINE y = 19 ; NEW_LINE print ( countSteps ( x , y ) ) ; NEW_LINE
def findCountOfSolutions ( n , p ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for x in range ( 1 , p ) : NEW_LINE INDENT if ( ( x * x ) % p == 1 ) : NEW_LINE INDENT last = x + p * ( n / p ) ; NEW_LINE if ( last > n ) : NEW_LINE INDENT last -= p ; NEW_LINE DEDENT ans += ( ( last - x ) / p + 1 ) ; NEW_LINE DEDENT DEDENT return int ( ans ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE p = 5 ; NEW_LINE print ( findCountOfSolutions ( n , p ) ) ; NEW_LINE
def kaprekarRec ( n , prev ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT prev = n ; NEW_LINE digits = [ 0 ] * 4 ; NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT digits [ i ] = n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT digits . sort ( ) ; NEW_LINE asc = 0 ; NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT asc = asc * 10 + digits [ i ] ; NEW_LINE DEDENT digits . sort ( ) ; NEW_LINE desc = 0 ; NEW_LINE for i in range ( 3 , - 1 , - 1 ) : NEW_LINE INDENT desc = desc * 10 + digits [ i ] ; NEW_LINE DEDENT diff = abs ( asc - desc ) ; NEW_LINE if ( diff == prev ) : NEW_LINE INDENT return diff ; NEW_LINE DEDENT return kaprekarRec ( diff , prev ) ; NEW_LINE DEDENT def kaprekar ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE return kaprekarRec ( n , rev ) ; NEW_LINE DEDENT print ( kaprekar ( 1000 ) ) ; NEW_LINE print ( kaprekar ( 1112 ) ) ; NEW_LINE print ( kaprekar ( 9812 ) ) ; NEW_LINE
def sqroot ( s ) : NEW_LINE INDENT pSq = 0 ; NEW_LINE N = 0 ; NEW_LINE for i in range ( int ( s ) , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i ) : NEW_LINE INDENT if ( j * j == i ) : NEW_LINE INDENT pSq = i ; NEW_LINE N = j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( pSq > 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT d = s - pSq ; NEW_LINE P = d / ( 2.0 * N ) ; NEW_LINE A = N + P ; NEW_LINE INDENT sqrt_of_s = A - ( ( P * P ) / ( 2.0 * A ) ) ; NEW_LINE return sqrt_of_s ; NEW_LINE DEDENT num = 9.2345 ; NEW_LINE sqroot_of_num = sqroot ( num ) ; NEW_LINE print ( " Square ▁ root ▁ of ▁ " , num , " = " , round ( ( sqroot_of_num * 100000.0 ) / 100000.0 , 5 ) ) ; NEW_LINE
def power ( x , a ) : NEW_LINE INDENT res = 1 NEW_LINE while ( a ) : NEW_LINE INDENT if ( a & 1 ) : NEW_LINE INDENT res = res * x NEW_LINE DEDENT x = x * x NEW_LINE a >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def breakInteger ( N ) : NEW_LINE INDENT if ( N == 2 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT maxProduct = 0 NEW_LINE if ( N % 3 == 0 ) : NEW_LINE INDENT maxProduct = power ( 3 , int ( N / 3 ) ) NEW_LINE return maxProduct NEW_LINE DEDENT elif ( N % 3 == 1 ) : NEW_LINE INDENT maxProduct = 2 * 2 * power ( 3 , int ( N / 3 ) - 1 ) NEW_LINE return maxProduct NEW_LINE DEDENT elif ( N % 3 == 2 ) : NEW_LINE INDENT maxProduct = 2 * power ( 3 , int ( N / 3 ) ) NEW_LINE return maxProduct NEW_LINE DEDENT DEDENT maxProduct = breakInteger ( 10 ) NEW_LINE print ( maxProduct ) NEW_LINE
import math NEW_LINE def digSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 or sum > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = sum NEW_LINE sum = 0 NEW_LINE DEDENT sum += n % 10 NEW_LINE n /= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 1234 NEW_LINE print ( digSum ( n ) ) NEW_LINE
def digSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n % 9 == 0 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE return ( n % 9 ) NEW_LINE DEDENT n = 9999 NEW_LINE print ( digSum ( n ) ) NEW_LINE
def countMultiples ( n ) : NEW_LINE INDENT return n / 3 + n / 7 - n / 21 ; NEW_LINE DEDENT n = ( ( int ) ( countMultiples ( 25 ) ) ) ; NEW_LINE print ( " Count ▁ = " , n ) ; NEW_LINE
def reversDigits ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num / 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def isPalindrome ( num ) : NEW_LINE INDENT return ( reversDigits ( num ) == num ) NEW_LINE DEDENT def ReverseandAdd ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while ( num <= 4294967295 ) : NEW_LINE INDENT rev_num = reversDigits ( num ) NEW_LINE num = num + rev_num NEW_LINE if ( isPalindrome ( num ) ) : NEW_LINE INDENT print num NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT if ( num > 4294967295 ) : NEW_LINE INDENT print " No ▁ palindrome ▁ exist " NEW_LINE DEDENT DEDENT DEDENT DEDENT ReverseandAdd ( 195 ) NEW_LINE ReverseandAdd ( 265 ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( ( ~ a & 1 ) == 1 ) : NEW_LINE INDENT if ( ( b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a >> 1 , b ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( gcd ( a >> 1 , b >> 1 ) << 1 ) NEW_LINE DEDENT DEDENT if ( ( ~ b & 1 ) == 1 ) : NEW_LINE INDENT return gcd ( a , b >> 1 ) NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( ( a - b ) >> 1 , b ) NEW_LINE DEDENT return gcd ( ( b - a ) >> 1 , a ) NEW_LINE DEDENT a , b = 34 , 17 NEW_LINE print ( " Gcd ▁ of ▁ given ▁ numbers ▁ is ▁ " , gcd ( a , b ) ) NEW_LINE
def findNDigitNumsUtil ( n , sum , out , index ) : NEW_LINE INDENT if ( index > n or sum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT f = " " NEW_LINE if ( index == n ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT out [ index ] = " \0" NEW_LINE for i in out : NEW_LINE INDENT f = f + i NEW_LINE DEDENT print ( f , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , index + 1 ) NEW_LINE DEDENT DEDENT def findNDigitNums ( n , sum ) : NEW_LINE INDENT out = [ False ] * ( n + 1 ) NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out [ 0 ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , sum - i , out , 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE sum = 3 NEW_LINE findNDigitNums ( n , sum ) NEW_LINE DEDENT
def oneDigit ( num ) : NEW_LINE INDENT return ( num >= 0 and num < 10 ) ; NEW_LINE DEDENT def isPalUtil ( num , dupNum ) : NEW_LINE INDENT if ( oneDigit ( num ) ) : NEW_LINE INDENT return ( num == ( dupNum ) % 10 ) ; NEW_LINE DEDENT if ( not isPalUtil ( int ( num / 10 ) , dupNum ) ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT dupNum = int ( dupNum / 10 ) ; NEW_LINE return ( num % 10 == ( dupNum ) % 10 ) ; NEW_LINE DEDENT def isPal ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT num = - num ; NEW_LINE DEDENT return isPalUtil ( num , dupNum ) ; NEW_LINE DEDENT def printPalPrimesLessThanN ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] and isPal ( p ) ) : NEW_LINE INDENT print ( p , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT n = 100 ; NEW_LINE print ( " Palindromic ▁ primes ▁ smaller " , " than ▁ or ▁ equal ▁ to " , n , " are ▁ : " ) ; NEW_LINE printPalPrimesLessThanN ( n ) ; NEW_LINE
import math NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 ; NEW_LINE count += 1 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i <= math . sqrt ( n ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n / i ; NEW_LINE count += 1 ; NEW_LINE DEDENT i = i + 2 ; NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return ( count ) ; NEW_LINE DEDENT def printKAlmostPrimes ( k , n ) : NEW_LINE INDENT i = 1 ; NEW_LINE num = 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if ( countPrimeFactors ( num ) == k ) : NEW_LINE INDENT print ( num , end = " " ) ; NEW_LINE print ( " ▁ " , end = " " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT num += 1 ; NEW_LINE DEDENT return ; NEW_LINE DEDENT n = 10 ; NEW_LINE k = 2 ; NEW_LINE print ( " First ▁ n ▁ k - almost ▁ prime ▁ numbers : " ) ; NEW_LINE printKAlmostPrimes ( k , n ) ; NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def lowest ( den3 , num3 ) : NEW_LINE INDENT common_factor = gcd ( num3 , den3 ) ; NEW_LINE den3 = int ( den3 / common_factor ) ; NEW_LINE num3 = int ( num3 / common_factor ) ; NEW_LINE print ( num3 , " / " , den3 ) ; NEW_LINE DEDENT def addFraction ( num1 , den1 , num2 , den2 ) : NEW_LINE INDENT den3 = gcd ( den1 , den2 ) ; NEW_LINE den3 = ( den1 * den2 ) / den3 ; NEW_LINE num3 = ( ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ) ; NEW_LINE lowest ( den3 , num3 ) ; NEW_LINE DEDENT num1 = 1 ; den1 = 500 ; NEW_LINE num2 = 2 ; den2 = 1500 ; NEW_LINE print ( num1 , " / " , den1 , " ▁ + ▁ " , num2 , " / " , den2 , " ▁ is ▁ equal ▁ to ▁ " , end = " " ) ; NEW_LINE addFraction ( num1 , den1 , num2 , den2 ) ; NEW_LINE
def findPieces ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) ) // 2 + 1 NEW_LINE DEDENT print ( findPieces ( 1 ) ) NEW_LINE print ( findPieces ( 2 ) ) NEW_LINE print ( findPieces ( 3 ) ) NEW_LINE print ( findPieces ( 50 ) ) NEW_LINE
import math NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT x = ( ( n * math . log10 ( n / math . e ) + math . log10 ( 2 * math . pi * n ) / 2.0 ) ) ; NEW_LINE return math . floor ( x ) + 1 ; NEW_LINE DEDENT print ( findDigits ( 1 ) ) ; NEW_LINE print ( findDigits ( 50000000 ) ) ; NEW_LINE print ( findDigits ( 1000000000 ) ) ; NEW_LINE print ( findDigits ( 120 ) ) ; NEW_LINE
import math NEW_LINE def findDigits ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n <= 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT digits = 0 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT digits += math . log10 ( i ) ; NEW_LINE DEDENT return math . floor ( digits ) + 1 ; NEW_LINE DEDENT print ( findDigits ( 1 ) ) ; NEW_LINE print ( findDigits ( 5 ) ) ; NEW_LINE print ( findDigits ( 10 ) ) ; NEW_LINE print ( findDigits ( 120 ) ) ; NEW_LINE
def countEvenSum ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT sum = sum + arr [ j ] NEW_LINE if ( sum % 2 == 0 ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ Number ▁ of ▁ Subarrays " , " with ▁ even ▁ sum ▁ is " , countEvenSum ( arr , n ) ) NEW_LINE DEDENT
def countEvenSum ( arr , n ) : NEW_LINE INDENT temp = [ 1 , 0 ] NEW_LINE result = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = ( ( sum + arr [ i ] ) % 2 + 2 ) % 2 NEW_LINE temp [ sum ] += 1 NEW_LINE DEDENT result = result + ( temp [ 0 ] * ( temp [ 0 ] - 1 ) // 2 ) NEW_LINE result = result + ( temp [ 1 ] * ( temp [ 1 ] - 1 ) // 2 ) NEW_LINE return ( result ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ even " " ▁ sum ▁ is " , countEvenSum ( arr , n ) ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT fibo = [ 0 ] * ( n + 1 ) NEW_LINE fibo [ 1 ] = 1 NEW_LINE sm = fibo [ 0 ] + fibo [ 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fibo [ i ] = fibo [ i - 1 ] + fibo [ i - 2 ] NEW_LINE sm = sm + fibo [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 4 NEW_LINE print ( " Sum ▁ of ▁ Fibonacci ▁ numbers ▁ is ▁ : ▁ " , calculateSum ( n ) ) NEW_LINE
def findCombinationsUtil ( arr , index , num , reducedNum ) : NEW_LINE INDENT if ( reducedNum < 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( reducedNum == 0 ) : NEW_LINE INDENT for i in range ( index ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE return NEW_LINE DEDENT prev = 1 if ( index == 0 ) else arr [ index - 1 ] NEW_LINE for k in range ( prev , num + 1 ) : NEW_LINE INDENT arr [ index ] = k NEW_LINE findCombinationsUtil ( arr , index + 1 , num , reducedNum - k ) NEW_LINE DEDENT DEDENT def findCombinations ( n ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE findCombinationsUtil ( arr , 0 , n , n ) NEW_LINE DEDENT n = 5 ; NEW_LINE findCombinations ( n ) ; NEW_LINE
def pow1 ( base , exponent , modulus ) : NEW_LINE INDENT result = 1 ; NEW_LINE base = base % modulus ; NEW_LINE while ( exponent > 0 ) : NEW_LINE INDENT if ( exponent % 2 == 1 ) : NEW_LINE INDENT result = ( result * base ) % modulus ; NEW_LINE DEDENT exponent = int ( exponent ) >> 1 ; NEW_LINE base = ( base * base ) % modulus ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) ; NEW_LINE DEDENT DEDENT def order ( p , b ) : NEW_LINE INDENT if ( gcd ( p , b ) != 1 ) : NEW_LINE INDENT print ( " p and b are not co - prime . " ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT k = 3 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( pow1 ( b , k , p ) == 1 ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT k += 1 ; NEW_LINE DEDENT DEDENT def convertx2e ( x ) : NEW_LINE INDENT z = 0 ; NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT x = x / 2 ; NEW_LINE z += 1 ; NEW_LINE DEDENT return [ x , z ] ; NEW_LINE DEDENT def STonelli ( n , p ) : NEW_LINE INDENT if ( gcd ( n , p ) != 1 ) : NEW_LINE INDENT print ( " a and p are not coprime " ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT if ( pow1 ( n , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) : NEW_LINE INDENT print ( " no sqrt possible " ) ; NEW_LINE return - 1 ; NEW_LINE DEDENT ar = convertx2e ( p - 1 ) ; NEW_LINE s = ar [ 0 ] ; NEW_LINE e = ar [ 1 ] ; NEW_LINE q = 2 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( pow1 ( q , ( p - 1 ) / 2 , p ) == ( p - 1 ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT q += 1 ; NEW_LINE DEDENT x = pow1 ( n , ( s + 1 ) / 2 , p ) ; NEW_LINE b = pow1 ( n , s , p ) ; NEW_LINE g = pow1 ( q , s , p ) ; NEW_LINE r = e ; NEW_LINE while ( True ) : NEW_LINE INDENT m = 0 ; NEW_LINE while ( m < r ) : NEW_LINE INDENT if ( order ( p , b ) == - 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( order ( p , b ) == pow ( 2 , m ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT m += 1 ; NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT x = ( x * pow1 ( g , pow ( 2 , r - m - 1 ) , p ) ) % p ; NEW_LINE g = pow1 ( g , pow ( 2 , r - m ) , p ) ; NEW_LINE b = ( b * g ) % p ; NEW_LINE if ( b == 1 ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT r = m ; NEW_LINE DEDENT DEDENT n = 2 ; NEW_LINE p = 113 ; NEW_LINE x = STonelli ( n , p ) ; NEW_LINE if ( x == - 1 ) : NEW_LINE INDENT print ( " Modular square root is not exist " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Modular ▁ square ▁ root ▁ of " , n , " and " , p , " is " , x ) ; NEW_LINE DEDENT
import math NEW_LINE def isPower ( x , y ) : NEW_LINE INDENT res1 = math . log ( y ) // math . log ( x ) ; NEW_LINE res2 = math . log ( y ) / math . log ( x ) ; NEW_LINE return 1 if ( res1 == res2 ) else 0 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( isPower ( 27 , 729 ) ) ; NEW_LINE DEDENT
import math NEW_LINE def findRoots ( a , b , c ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE return - 1 NEW_LINE DEDENT d = b * b - 4 * a * c NEW_LINE sqrt_val = math . sqrt ( abs ( d ) ) NEW_LINE if d > 0 : NEW_LINE INDENT print ( " Roots ▁ are ▁ real ▁ and ▁ different ▁ " ) NEW_LINE print ( ( - b + sqrt_val ) / ( 2 * a ) ) NEW_LINE print ( ( - b - sqrt_val ) / ( 2 * a ) ) NEW_LINE DEDENT elif d == 0 : NEW_LINE INDENT print ( " Roots ▁ are ▁ real ▁ and ▁ same " ) NEW_LINE print ( - b / ( 2 * a ) ) NEW_LINE print ( " Roots ▁ are ▁ complex " ) NEW_LINE print ( - b / ( 2 * a ) , " ▁ + ▁ i " , sqrt_val ) NEW_LINE print ( - b / ( 2 * a ) , " ▁ - ▁ i " , sqrt_val ) NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = - 7 NEW_LINE c = 12 NEW_LINE findRoots ( a , b , c ) NEW_LINE
def isPerfectSquare ( n ) : NEW_LINE INDENT i = 1 NEW_LINE the_sum = 0 NEW_LINE while the_sum < n : NEW_LINE INDENT the_sum += i NEW_LINE if the_sum == n : NEW_LINE INDENT return True NEW_LINE DEDENT i += 2 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( ' Yes ' ) if isPerfectSquare ( 35 ) else print ( ' NO ' ) NEW_LINE print ( ' Yes ' ) if isPerfectSquare ( 49 ) else print ( ' NO ' ) NEW_LINE DEDENT
import math NEW_LINE def findCount ( d ) : NEW_LINE INDENT return 9 * ( ( int ) ( math . pow ( 10 , d - 1 ) ) - ( int ) ( math . pow ( 9 , d - 1 ) ) ) ; NEW_LINE DEDENT d = 1 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 2 NEW_LINE print ( findCount ( d ) ) NEW_LINE d = 4 NEW_LINE print ( findCount ( d ) ) NEW_LINE
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " , str ( int ( countDyckPaths ( n ) ) ) ) NEW_LINE
def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT sum , n = 0 , 1 NEW_LINE while ( sum <= num ) : NEW_LINE INDENT sum = sum + n NEW_LINE if ( sum == num ) : NEW_LINE INDENT return True NEW_LINE DEDENT n += 1 NEW_LINE DEDENT return False NEW_LINE DEDENT n = 55 NEW_LINE if ( isTriangular ( n ) ) : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT
import math NEW_LINE def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT c = ( - 2 * num ) NEW_LINE b , a = 1 , 1 NEW_LINE d = ( b * b ) - ( 4 * a * c ) NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE root2 = ( - b - math . sqrt ( d ) ) / ( 2 * a ) NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 55 NEW_LINE if ( isTriangular ( n ) ) : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ number ▁ is ▁ NOT ▁ a ▁ triangular ▁ number " ) NEW_LINE DEDENT
' NEW_LINE def val ( c ) : NEW_LINE INDENT if c >= '0' and c <= '9' : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( c ) - ord ( ' A ' ) + 10 ; NEW_LINE DEDENT DEDENT def toDeci ( str , base ) : NEW_LINE INDENT llen = len ( str ) NEW_LINE DEDENT power = 1 NEW_LINE num = 0 NEW_LINE INDENT for i in range ( llen - 1 , - 1 , - 1 ) : NEW_LINE INDENT if val ( str [ i ] ) >= base : NEW_LINE INDENT print ( ' Invalid ▁ Number ' ) NEW_LINE return - 1 NEW_LINE DEDENT num += val ( str [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT strr = "11A " NEW_LINE base = 16 NEW_LINE print ( ' Decimal ▁ equivalent ▁ of ' , strr , ' in ▁ base ' , base , ' is ' , toDeci ( strr , base ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT while ( a != 0 ) : NEW_LINE INDENT c = a ; NEW_LINE a = b % a ; NEW_LINE b = c ; NEW_LINE DEDENT return b ; NEW_LINE DEDENT def forbenius ( X , Y ) : NEW_LINE INDENT if ( gcd ( X , Y ) != 1 ) : NEW_LINE INDENT print ( " NA " ) ; NEW_LINE return ; NEW_LINE DEDENT A = ( X * Y ) - ( X + Y ) ; NEW_LINE N = ( X - 1 ) * ( Y - 1 ) // 2 ; NEW_LINE print ( " Largest ▁ Amount ▁ = " , A ) ; NEW_LINE print ( " Total ▁ Count ▁ = " , N ) ; NEW_LINE DEDENT X = 2 ; NEW_LINE Y = 5 ; NEW_LINE forbenius ( X , Y ) ; NEW_LINE X = 5 ; NEW_LINE Y = 10 ; NEW_LINE print ( " " ) ; NEW_LINE forbenius ( X , Y ) ; NEW_LINE
def xor_c ( a , b ) : NEW_LINE INDENT return '0' if ( a == b ) else '1' ; NEW_LINE DEDENT def flip ( c ) : NEW_LINE INDENT return '1' if ( c == '0' ) else '0' ; NEW_LINE DEDENT def binarytoGray ( binary ) : NEW_LINE INDENT gray = " " ; NEW_LINE gray += binary [ 0 ] ; NEW_LINE for i in range ( 1 , len ( binary ) ) : NEW_LINE INDENT gray += xor_c ( binary [ i - 1 ] , binary [ i ] ) ; NEW_LINE DEDENT return gray ; NEW_LINE DEDENT def graytoBinary ( gray ) : NEW_LINE INDENT binary = " " ; NEW_LINE binary += gray [ 0 ] ; NEW_LINE for i in range ( 1 , len ( gray ) ) : NEW_LINE INDENT if ( gray [ i ] == '0' ) : NEW_LINE INDENT binary += binary [ i - 1 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT binary += flip ( binary [ i - 1 ] ) ; NEW_LINE DEDENT DEDENT return binary ; NEW_LINE DEDENT binary = "01001" ; NEW_LINE print ( " Gray ▁ code ▁ of " , binary , " is " , binarytoGray ( binary ) ) ; NEW_LINE gray = "01101" ; NEW_LINE print ( " Binary ▁ code ▁ of " , gray , " is " , graytoBinary ( gray ) ) ; NEW_LINE
def seriesSum ( calculated , current , N ) : NEW_LINE INDENT i = calculated ; NEW_LINE cur = 1 ; NEW_LINE if ( current == N + 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT while ( i < calculated + current ) : NEW_LINE INDENT cur *= i ; NEW_LINE i += 1 ; NEW_LINE DEDENT return cur + seriesSum ( i , current + 1 , N ) ; NEW_LINE DEDENT N = 5 ; NEW_LINE print ( seriesSum ( 1 , 1 , N ) ) ; NEW_LINE
def modFact ( n , p ) : NEW_LINE INDENT if n >= p : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT result = ( result * i ) % p NEW_LINE DEDENT return result NEW_LINE DEDENT n = 25 ; p = 29 NEW_LINE print ( modFact ( n , p ) ) NEW_LINE
def inv ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE x0 = 0 NEW_LINE x1 = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = x0 NEW_LINE x0 = x1 - q * x0 NEW_LINE x1 = t NEW_LINE DEDENT if ( x1 < 0 ) : NEW_LINE INDENT x1 = x1 + m0 NEW_LINE DEDENT return x1 NEW_LINE DEDENT def findMinX ( num , rem , k ) : NEW_LINE INDENT prod = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT prod = prod * num [ i ] NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT pp = prod // num [ i ] NEW_LINE result = result + rem [ i ] * inv ( pp , num [ i ] ) * pp NEW_LINE DEDENT return result % prod NEW_LINE DEDENT num = [ 3 , 4 , 5 ] NEW_LINE rem = [ 2 , 3 , 1 ] NEW_LINE k = len ( num ) NEW_LINE print ( " x ▁ is ▁ " , findMinX ( num , rem , k ) ) NEW_LINE
def findMinX ( num , rem , k ) : NEW_LINE INDENT while ( True ) : NEW_LINE INDENT j = 0 ; NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( x % num [ j ] != rem [ j ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( j == k ) : NEW_LINE INDENT return x ; NEW_LINE DEDENT x += 1 ; NEW_LINE DEDENT DEDENT num = [ 3 , 4 , 5 ] ; NEW_LINE rem = [ 2 , 3 , 1 ] ; NEW_LINE k = len ( num ) ; NEW_LINE print ( " x ▁ is " , findMinX ( num , rem , k ) ) ; NEW_LINE
' NEW_LINE def isValid ( n , d ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE sum = digit ; NEW_LINE if ( digit == d ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT digit = n % 10 ; NEW_LINE if ( digit == d or digit <= sum ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += digit ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def printGoodNumber ( L , R , d ) : NEW_LINE INDENT for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( isValid ( i , d ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT L = 410 ; NEW_LINE R = 520 ; NEW_LINE d = 3 ; NEW_LINE printGoodNumber ( L , R , d ) ; NEW_LINE
def nearestSmallerEqFib ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT f1 , f2 , f3 = 0 , 1 , 1 NEW_LINE while ( f3 <= n ) : NEW_LINE INDENT f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE f3 = f1 + f2 ; NEW_LINE DEDENT return f2 ; NEW_LINE DEDENT def printFibRepresntation ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT f = nearestSmallerEqFib ( n ) ; NEW_LINE print f , NEW_LINE n = n - f NEW_LINE DEDENT DEDENT n = 30 NEW_LINE print " Non - neighbouring ▁ Fibonacci ▁ Representation ▁ of " , n , " is " NEW_LINE printFibRepresntation ( n ) NEW_LINE
dp = [ [ [ - 1 for i in range ( 5 ) ] for i in range ( 501 ) ] for i in range ( 501 ) ] NEW_LINE def countWaysUtil ( n , parts , nextPart ) : NEW_LINE INDENT if ( parts == 0 and n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n <= 0 or parts <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ nextPart ] [ parts ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ nextPart ] [ parts ] NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for i in range ( nextPart , n + 1 ) : NEW_LINE INDENT ans += countWaysUtil ( n - i , parts - 1 , i ) NEW_LINE DEDENT dp [ n ] [ nextPart ] [ parts ] = ans NEW_LINE return ( ans ) NEW_LINE DEDENT def countWays ( n ) : NEW_LINE INDENT return countWaysUtil ( n , 4 , 1 ) NEW_LINE DEDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE
import math NEW_LINE def printTwins ( low , high ) : NEW_LINE INDENT prime = [ True ] * ( high + 1 ) ; NEW_LINE twin = False ; NEW_LINE prime [ 0 ] = prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( math . floor ( math . sqrt ( high ) ) + 2 ) ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , high + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( low , high + 1 ) : NEW_LINE INDENT if ( prime [ i ] and prime [ i + 2 ] ) : NEW_LINE INDENT print ( " Smallest ▁ twins ▁ in ▁ given ▁ range : ▁ ( " , i , " , " , ( i + 2 ) , " ) " ) ; NEW_LINE twin = True ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( twin == False ) : NEW_LINE INDENT print ( " No ▁ such ▁ pair ▁ exists " ) ; NEW_LINE DEDENT DEDENT printTwins ( 10 , 100 ) ; NEW_LINE
def nextSparse ( x ) : NEW_LINE INDENT bin = [ ] NEW_LINE while ( x != 0 ) : NEW_LINE INDENT bin . append ( x & 1 ) NEW_LINE x >>= 1 NEW_LINE DEDENT bin . append ( 0 ) NEW_LINE last_final = 0 NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( ( bin [ i ] == 1 and bin [ i - 1 ] == 1 and bin [ i + 1 ] != 1 ) ) : NEW_LINE INDENT bin [ i + 1 ] = 1 NEW_LINE for j in range ( i , last_final - 1 , - 1 ) : NEW_LINE INDENT bin [ j ] = 0 NEW_LINE DEDENT last_final = i + 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans += bin [ i ] * ( 1 << i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 38 NEW_LINE print ( " Next ▁ Sparse ▁ Number ▁ is " , nextSparse ( x ) ) NEW_LINE DEDENT
def sumBitDifferences ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans += ( count * ( n - count ) * 2 ) ; NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumBitDifferences ( arr , n ) ) NEW_LINE
def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT def generateUtil ( x , arr , curr_sum , curr_idx ) : NEW_LINE INDENT if ( curr_sum == x ) : NEW_LINE INDENT printArr ( arr , curr_idx ) NEW_LINE return NEW_LINE DEDENT num = 1 NEW_LINE while ( num <= x - curr_sum and ( curr_idx == 0 or num <= arr [ curr_idx - 1 ] ) ) : NEW_LINE INDENT arr [ curr_idx ] = num NEW_LINE generateUtil ( x , arr , curr_sum + num , curr_idx + 1 ) NEW_LINE num += 1 NEW_LINE DEDENT DEDENT def generate ( x ) : NEW_LINE INDENT arr = [ 0 ] * x NEW_LINE generateUtil ( x , arr , 0 , 0 ) NEW_LINE DEDENT x = 5 NEW_LINE generate ( x ) NEW_LINE
def isPerfect ( n ) : NEW_LINE INDENT sum = 1 NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == n and n != 1 else False ) NEW_LINE DEDENT print ( " Below ▁ are ▁ all ▁ perfect ▁ numbers ▁ till ▁ 10000" ) NEW_LINE n = 2 NEW_LINE for n in range ( 10000 ) : NEW_LINE INDENT if isPerfect ( n ) : NEW_LINE INDENT print ( n , " ▁ is ▁ a ▁ perfect ▁ number " ) NEW_LINE DEDENT DEDENT
' NEW_LINE def checkUtil ( num , dig , base ) : NEW_LINE INDENT if ( dig == 1 and num < base ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( dig > 1 and num >= base ) : NEW_LINE INDENT return checkUtil ( num / base , - - dig , base ) NEW_LINE DEDENT return False NEW_LINE DEDENT def check ( num , dig ) : NEW_LINE INDENT for base in range ( 2 , 33 ) : NEW_LINE INDENT if ( checkUtil ( num , dig , base ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT num = 8 NEW_LINE dig = 3 NEW_LINE if ( check ( num , dig ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def mod ( num , a ) : NEW_LINE INDENT res = 0 NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) ) % a NEW_LINE DEDENT return res NEW_LINE DEDENT num = "12316767678678" NEW_LINE print ( mod ( num , 10 ) ) NEW_LINE
' NEW_LINE def modInverse ( a , m ) : NEW_LINE INDENT for x in range ( 1 , m ) : NEW_LINE INDENT if ( ( ( a % m ) * ( x % m ) ) % m == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( modInverse ( a , m ) ) NEW_LINE
def modInverse ( a , m ) : NEW_LINE INDENT m0 = m NEW_LINE y = 0 NEW_LINE x = 1 NEW_LINE if ( m == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( a > 1 ) : NEW_LINE INDENT q = a // m NEW_LINE t = m NEW_LINE m = a % m NEW_LINE a = t NEW_LINE t = y NEW_LINE y = x - q * y NEW_LINE x = t NEW_LINE DEDENT if ( x < 0 ) : NEW_LINE INDENT x = x + m0 NEW_LINE DEDENT return x NEW_LINE DEDENT a = 3 NEW_LINE m = 11 NEW_LINE print ( " Modular ▁ multiplicative ▁ inverse ▁ is " , modInverse ( a , m ) ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def phi ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( gcd ( i , n ) == 1 ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT for n in range ( 1 , 11 ) : NEW_LINE INDENT print ( " phi ( " , n , " ) ▁ = ▁ " , phi ( n ) , sep = " " ) NEW_LINE DEDENT
def phi ( n ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if n % p == 0 : NEW_LINE INDENT while n % p == 0 : NEW_LINE INDENT n = n // p NEW_LINE DEDENT result = result * ( 1.0 - ( 1.0 / float ( p ) ) ) NEW_LINE DEDENT p = p + 1 NEW_LINE DEDENT if n > 1 : NEW_LINE INDENT result = result * ( 1.0 - ( 1.0 / float ( n ) ) ) NEW_LINE DEDENT return int ( result ) NEW_LINE DEDENT for n in range ( 1 , 11 ) : NEW_LINE INDENT print ( " phi ( " , n , " ) ▁ = ▁ " , phi ( n ) ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT def sum ( n ) : NEW_LINE INDENT s = 0.0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT s += 1.0 / factorial ( i ) NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT n = 5 NEW_LINE sum ( n ) NEW_LINE
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) ; NEW_LINE res /= ( i + 1 ) ; NEW_LINE DEDENT return int ( res ) ; NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) ; NEW_LINE return int ( c / ( n + 1 ) ) ; NEW_LINE DEDENT def findWays ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return catalan ( int ( n / 2 ) ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( " Total ▁ possible ▁ expressions ▁ of ▁ length " , n , " is " , findWays ( 6 ) ) ; NEW_LINE
def isOperand ( c ) : NEW_LINE INDENT return ( c >= '0' and c <= '9' ) ; NEW_LINE DEDENT def value ( c ) : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) ; NEW_LINE DEDENT def evaluate ( exp ) : NEW_LINE INDENT len1 = len ( exp ) ; NEW_LINE if ( len1 == 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT res = value ( exp [ 0 ] ) ; NEW_LINE for i in range ( 1 , len1 , 2 ) : NEW_LINE INDENT opr = exp [ i ] ; NEW_LINE opd = exp [ i + 1 ] ; NEW_LINE if ( isOperand ( opd ) == False ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( opr == ' + ' ) : NEW_LINE INDENT res += value ( opd ) ; NEW_LINE DEDENT elif ( opr == ' - ' ) : NEW_LINE INDENT res -= int ( value ( opd ) ) ; NEW_LINE DEDENT elif ( opr == ' * ' ) : NEW_LINE INDENT res *= int ( value ( opd ) ) ; NEW_LINE DEDENT elif ( opr == ' / ' ) : NEW_LINE INDENT res /= int ( value ( opd ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT expr1 = "1 + 2*5 + 3" ; NEW_LINE res = evaluate ( expr1 ) ; NEW_LINE print ( expr1 , " is ▁ Invalid " ) if ( res == - 1 ) else print ( " Value ▁ of " , expr1 , " is " , res ) ; NEW_LINE expr2 = "1 + 2*3" ; NEW_LINE res = evaluate ( expr2 ) ; NEW_LINE print ( expr2 , " is ▁ Invalid " ) if ( res == - 1 ) else print ( " Value ▁ of " , expr2 , " is " , res ) ; NEW_LINE expr3 = "4-2 + 6*3" ; NEW_LINE res = evaluate ( expr3 ) ; NEW_LINE print ( expr3 , " is ▁ Invalid " ) if ( res == - 1 ) else print ( " Value ▁ of " , expr3 , " is " , res ) ; NEW_LINE expr4 = "1 + + 2" ; NEW_LINE res = evaluate ( expr4 ) ; NEW_LINE print ( expr4 , " is ▁ Invalid " ) if ( res == - 1 ) else print ( " Value ▁ of " , expr4 , " is " , res ) ; NEW_LINE
def printFibonacciNumbers ( n ) : NEW_LINE INDENT f1 = 0 NEW_LINE f2 = 1 NEW_LINE if ( n < 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT print ( f1 , end = " ▁ " ) NEW_LINE for x in range ( 1 , n ) : NEW_LINE INDENT print ( f2 , end = " ▁ " ) NEW_LINE next = f1 + f2 NEW_LINE f1 = f2 NEW_LINE f2 = next NEW_LINE DEDENT DEDENT printFibonacciNumbers ( 7 ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lcm ( a , b ) : NEW_LINE INDENT return ( a / gcd ( a , b ) ) * b NEW_LINE DEDENT a = 15 NEW_LINE b = 20 NEW_LINE print ( ' LCM ▁ of ' , a , ' and ' , b , ' is ' , lcm ( a , b ) ) NEW_LINE
def convert_to_words ( num ) : NEW_LINE INDENT l = len ( num ) NEW_LINE if ( l == 0 ) : NEW_LINE INDENT print ( " empty ▁ string " ) NEW_LINE return NEW_LINE DEDENT if ( l > 4 ) : NEW_LINE INDENT print ( " Length ▁ more ▁ than ▁ 4 ▁ is ▁ not ▁ supported " ) NEW_LINE return NEW_LINE DEDENT single_digits = [ " zero " , " one " , " two " , " three " , " four " , " five " , " six " , " seven " , " eight " , " nine " ] NEW_LINE two_digits = [ " " , " ten " , " eleven " , " twelve " , " thirteen " , " fourteen " , " fifteen " , " sixteen " , " seventeen " , " eighteen " , " nineteen " ] NEW_LINE tens_multiple = [ " " , " " , " twenty " , " thirty " , " forty " , " fifty " , " sixty " , " seventy " , " eighty " , " ninety " ] NEW_LINE tens_power = [ " hundred " , " thousand " ] NEW_LINE print ( num , " : " , end = " ▁ " ) NEW_LINE if ( l == 1 ) : NEW_LINE INDENT print ( single_digits [ ord ( num [ 0 ] ) - 48 ] ) NEW_LINE return NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT x = 0 NEW_LINE while ( x < len ( num ) ) : NEW_LINE INDENT if ( l >= 3 ) : NEW_LINE INDENT if ( ord ( num [ x ] ) - 48 != 0 ) : NEW_LINE INDENT print ( single_digits [ ord ( num [ x ] ) - 48 ] , end = " ▁ " ) NEW_LINE print ( tens_power [ l - 3 ] , end = " ▁ " ) NEW_LINE DEDENT l -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ord ( num [ x ] ) - 48 == 1 ) : NEW_LINE INDENT sum = ( ord ( num [ x ] ) - 48 + ord ( num [ x + 1 ] ) - 48 ) NEW_LINE print ( two_digits [ sum ] ) NEW_LINE return NEW_LINE DEDENT elif ( ord ( num [ x ] ) - 48 == 2 and ord ( num [ x + 1 ] ) - 48 == 0 ) : NEW_LINE INDENT print ( " twenty " ) NEW_LINE return NEW_LINE DEDENT else : NEW_LINE INDENT i = ord ( num [ x ] ) - 48 NEW_LINE if ( i > 0 ) : NEW_LINE INDENT print ( tens_multiple [ i ] , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " " , end = " " ) NEW_LINE DEDENT x += 1 NEW_LINE if ( ord ( num [ x ] ) - 48 != 0 ) : NEW_LINE INDENT print ( single_digits [ ord ( num [ x ] ) - 48 ] ) NEW_LINE DEDENT DEDENT DEDENT x += 1 NEW_LINE DEDENT DEDENT
MAX = 11 ; NEW_LINE def isMultipleof5 ( n ) : NEW_LINE INDENT s = str ( n ) ; NEW_LINE l = len ( s ) ; NEW_LINE if ( s [ l - 1 ] == '5' or s [ l - 1 ] == '0' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 19 ; NEW_LINE if ( isMultipleof5 ( n ) == True ) : NEW_LINE INDENT print ( n , " is ▁ multiple ▁ of ▁ 5" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is ▁ not ▁ a ▁ multiple ▁ of ▁ 5" ) ; NEW_LINE DEDENT
def pairORSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] | arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE
def multiplyByFifteen ( n ) : NEW_LINE INDENT prod = ( n << 4 ) NEW_LINE prod = prod - n NEW_LINE return prod NEW_LINE DEDENT n = 7 NEW_LINE print ( multiplyByFifteen ( n ) ) NEW_LINE
def minAND ( arr , n ) : NEW_LINE INDENT s = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s = s & arr [ i ] NEW_LINE DEDENT print ( s ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE minAND ( arr , n ) NEW_LINE
def check ( a , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 0 , 1 , 0 , 1 ] NEW_LINE n = len ( a ) NEW_LINE if ( check ( a , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def findArray ( q , n ) : NEW_LINE INDENT arr = [ None ] * n NEW_LINE k = 0 NEW_LINE for j in range ( int ( n / 4 ) ) : NEW_LINE INDENT ans = q [ k ] ^ q [ k + 3 ] NEW_LINE arr [ k + 1 ] = q [ k + 1 ] ^ ans NEW_LINE arr [ k + 2 ] = q [ k + 2 ] ^ ans NEW_LINE arr [ k ] = q [ k ] ^ ( ( arr [ k + 1 ] ) ^ ( arr [ k + 2 ] ) ) NEW_LINE arr [ k + 3 ] = q [ k + 3 ] ^ ( arr [ k + 1 ] ^ arr [ k + 2 ] ) NEW_LINE k += 4 NEW_LINE DEDENT printArray ( arr , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT q = [ 4 , 1 , 7 , 0 ] NEW_LINE n = len ( q ) NEW_LINE findArray ( q , n ) NEW_LINE DEDENT
def isEqualBlock ( n ) : NEW_LINE INDENT first_bit = n % 2 NEW_LINE first_count = 1 NEW_LINE n = n // 2 NEW_LINE while n % 2 == first_bit and n > 0 : NEW_LINE INDENT n = n // 2 NEW_LINE first_count += 1 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while n > 0 : NEW_LINE INDENT first_bit = n % 2 NEW_LINE curr_count = 1 NEW_LINE n = n // 2 NEW_LINE while n % 2 == first_bit : NEW_LINE INDENT n = n // 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if curr_count != first_count : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 51 NEW_LINE if isEqualBlock ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def binToDecimal3 ( n ) : NEW_LINE INDENT last_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) ; NEW_LINE n = n >> 3 NEW_LINE while ( n > 7 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE DEDENT first_3 = ( ( n & 4 ) + ( n & 2 ) + ( n & 1 ) ) NEW_LINE print ( first_3 , last_3 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 86 NEW_LINE binToDecimal3 ( n ) NEW_LINE DEDENT
def isPowerOfTwo ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( ( x & ( x - 1 ) ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def countNum ( a , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( isPowerOfTwo ( a [ i ] ) or isPowerOfTwo ( a [ i ] + 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 6 , 9 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countNum ( arr , n ) ) NEW_LINE DEDENT
def checkEvenParity ( x ) : NEW_LINE INDENT parity = 0 NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE parity += 1 NEW_LINE DEDENT if ( parity % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def sumlist ( a , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkEvenParity ( a [ i ] ) ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 4 , 3 , 5 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( sumlist ( arr , n ) ) NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT A = [ 5 , 6 , 2 , 8 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT evenPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] ^ A [ j ] ) % 2 == 0 ) : NEW_LINE INDENT evenPair += 1 NEW_LINE DEDENT DEDENT DEDENT return evenPair ; NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT A = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE N = len ( A ) NEW_LINE print ( findevenPair ( A , N ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findEvenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT totalPairs = ( N * ( N - 1 ) / 2 ) NEW_LINE oddEvenPairs = count * ( N - count ) NEW_LINE return ( int ) ( totalPairs - oddEvenPairs ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findEvenPair ( a , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT evenPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) : NEW_LINE INDENT evenPair += 1 NEW_LINE DEDENT DEDENT DEDENT return evenPair NEW_LINE DEDENT a = [ 5 , 1 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( findevenPair ( a , n ) ) NEW_LINE
def findevenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT oddCount = count * ( count - 1 ) / 2 NEW_LINE return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount ) NEW_LINE DEDENT a = [ 5 , 1 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( findevenPair ( a , n ) ) NEW_LINE
def calculate ( X ) : NEW_LINE INDENT number_of_bits = 8 NEW_LINE return ( ( 1 << number_of_bits ) - 1 ) ^ X NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 4 NEW_LINE print ( " Required ▁ Number ▁ is : " , calculate ( X ) ) NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT X = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT X ^= arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = X ^ arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 3 , 3 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def alternate ( a , b , x ) : NEW_LINE INDENT x = a ^ b ^ x NEW_LINE print ( " After ▁ exchange " ) NEW_LINE print ( " x ▁ is " , x ) NEW_LINE DEDENT a = - 10 NEW_LINE b = 15 NEW_LINE x = a NEW_LINE print ( " x ▁ is " , x ) NEW_LINE alternate ( a , b , x ) NEW_LINE
def countZeros ( x ) : NEW_LINE INDENT n = 32 ; NEW_LINE y = x >> 16 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 16 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 8 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 8 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 4 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 4 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 2 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT n = n - 2 ; NEW_LINE x = y ; NEW_LINE DEDENT y = x >> 1 ; NEW_LINE if ( y != 0 ) : NEW_LINE INDENT return n - 2 ; NEW_LINE DEDENT return n - x ; NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 101 ; NEW_LINE print ( countZeros ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def LeadingZeros ( x , y ) : NEW_LINE INDENT if ( ( x ^ y ) <= ( x & y ) ) : NEW_LINE INDENT print ( " Equal " ) NEW_LINE DEDENT elif ( ( x & ( ~ y ) ) > y ) : NEW_LINE INDENT print ( y ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE y = 16 NEW_LINE LeadingZeros ( x , y ) NEW_LINE DEDENT
def solve ( A , B ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , 32 ) : NEW_LINE INDENT if ( ( ( A >> i ) & 1 ) != ( ( B >> i ) & 1 ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT print ( " Number ▁ of ▁ different ▁ bits ▁ : " , count ) NEW_LINE DEDENT A = 12 NEW_LINE B = 15 NEW_LINE solve ( A , B ) NEW_LINE
def setRightmostUnsetBit ( n ) : NEW_LINE INDENT if n & ( n + 1 ) == 0 : NEW_LINE INDENT return n NEW_LINE DEDENT return n | ( n + 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 21 NEW_LINE print ( setRightmostUnsetBit ( n ) ) NEW_LINE DEDENT
def AND ( a , n ) : NEW_LINE INDENT ans = a [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans &= a [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( AND ( a , n ) ) NEW_LINE DEDENT
def TwoscomplementbyXOR ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE check_bit = 0 NEW_LINE i = n - 1 NEW_LINE s = list ( str ) NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == '0' and check_bit == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT if ( check_bit == 1 ) : NEW_LINE INDENT s [ i ] = chr ( ( ord ( s [ i ] ) - 48 ) ^ 1 + 48 ) NEW_LINE DEDENT check_bit = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT str = " " . join ( s ) NEW_LINE if ( check_bit == 0 ) : NEW_LINE INDENT return "1" + str NEW_LINE DEDENT else : NEW_LINE INDENT return str NEW_LINE DEDENT DEDENT str = "101" NEW_LINE print ( TwoscomplementbyXOR ( str ) ) NEW_LINE
def increment ( i ) : NEW_LINE INDENT i = - ( ~ i ) ; NEW_LINE return i ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; NEW_LINE print ( increment ( n ) ) ; NEW_LINE DEDENT
def bit_count ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = n & ( n - 1 ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def maxsum ( arr , n ) : NEW_LINE INDENT bits = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT bits [ i ] = bit_count ( arr [ i ] ) ; NEW_LINE DEDENT sum = [ 0 ] * 32 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum [ bits [ i ] ] += arr [ i ] ; NEW_LINE DEDENT maximum = 0 ; NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT maximum = max ( sum [ i ] , maximum ) ; NEW_LINE DEDENT return maximum ; NEW_LINE DEDENT arr = [ 2 , 3 , 8 , 5 , 6 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxsum ( arr , n ) ) ; NEW_LINE
def xor_pair_sum ( ar , n ) : NEW_LINE INDENT total = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT total = total ^ ar [ i ] NEW_LINE DEDENT return 2 * total NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT data = [ 1 , 2 , 3 ] NEW_LINE print ( xor_pair_sum ( data , len ( data ) ) ) NEW_LINE DEDENT
def findEvenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( not ( A [ i ] & 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count * ( count - 1 ) // 2 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 5 , 6 , 2 , 8 ] NEW_LINE N = len ( A ) NEW_LINE print ( findEvenPair ( A , N ) ) NEW_LINE DEDENT
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return false NEW_LINE DEDENT n = 17 NEW_LINE l = 2 NEW_LINE r = 4 NEW_LINE if ( allBitsSetInTheGivenRange ( n , l , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def checkSame ( n ) : NEW_LINE INDENT set , unset = 0 , 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n and 1 ) : NEW_LINE INDENT set + 1 NEW_LINE DEDENT else : NEW_LINE INDENT unset += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT if ( set == unset ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE if ( checkSame ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def KthCharacter ( m , n , k ) : NEW_LINE INDENT distance = pow ( 2 , n ) NEW_LINE Block_number = int ( k / distance ) NEW_LINE remaining = k % distance NEW_LINE s = [ 0 ] * 32 NEW_LINE x = 0 NEW_LINE while ( m > 0 ) : NEW_LINE INDENT s [ x ] = m % 2 NEW_LINE m = int ( m / 2 ) NEW_LINE x += 1 NEW_LINE DEDENT root = s [ x - 1 - Block_number ] NEW_LINE if ( remaining == 0 ) : NEW_LINE INDENT print ( root ) NEW_LINE return NEW_LINE DEDENT flip = True NEW_LINE while ( remaining > 1 ) : NEW_LINE INDENT if ( remaining & 1 ) : NEW_LINE INDENT flip = not ( flip ) NEW_LINE DEDENT remaining = remaining >> 1 NEW_LINE DEDENT if ( flip ) : NEW_LINE INDENT print ( not ( root ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( root ) NEW_LINE DEDENT DEDENT m = 5 NEW_LINE k = 5 NEW_LINE n = 3 NEW_LINE KthCharacter ( m , n , k ) NEW_LINE
def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return ( ( ( n - 1 ) & ( n - 2 ) ) == 0 ) NEW_LINE DEDENT n = 9 NEW_LINE if ( onlyFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
from math import pow NEW_LINE def getInteger ( L , R ) : NEW_LINE INDENT number = 0 NEW_LINE for i in range ( L , R + 1 , 1 ) : NEW_LINE INDENT number += pow ( 2 , i ) NEW_LINE DEDENT return number NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 2 NEW_LINE R = 5 NEW_LINE print ( int ( getInteger ( L , R ) ) ) NEW_LINE DEDENT
def setbitsfromLtoR ( L , R ) : NEW_LINE INDENT return ( ( 1 << ( R + 1 ) ) - ( 1 << L ) ) NEW_LINE DEDENT L = 2 NEW_LINE R = 5 NEW_LINE print ( setbitsfromLtoR ( L , R ) ) NEW_LINE
def findXor ( arr , n ) : NEW_LINE INDENT xoR = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xoR = xoR ^ arr [ i ] NEW_LINE DEDENT return xoR * 2 NEW_LINE DEDENT arr = [ 1 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findXor ( arr , n ) ) NEW_LINE
def printOdds ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res = res ^ arr [ i ] NEW_LINE DEDENT set_bit = res & ( ~ ( res - 1 ) ) NEW_LINE x = 0 NEW_LINE y = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] & set_bit ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( x , y , end = " " ) NEW_LINE DEDENT arr = [ 2 , 3 , 3 , 4 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printOdds ( arr , n ) NEW_LINE
def subsetBitwiseORk ( arr , n , k ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ i ] k ) == k ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT ans |= v [ i ] NEW_LINE DEDENT if ( ans != k ) : NEW_LINE INDENT print ( " Subset does not exist " ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT print ( " { } ▁ " . format ( v [ i ] ) , end = " " ) NEW_LINE DEDENT DEDENT k = 3 NEW_LINE arr = [ 1 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE subsetBitwiseORk ( arr , n , k ) NEW_LINE
def findEletobeInserted ( A , n , k ) : NEW_LINE INDENT ans = k NEW_LINE for i in range ( n ) : NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( A ) NEW_LINE k = 10 NEW_LINE print ( findEletobeInserted ( A , n , k ) , " has ▁ to ▁ be ▁ inserted ▁ in ▁ the ▁ given " , " array ▁ to ▁ make ▁ xor ▁ sum ▁ of " , k ) NEW_LINE DEDENT
BITS = 32 ; NEW_LINE def andSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , BITS ) : NEW_LINE INDENT countSetBits = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT countSetBits = ( countSetBits + 1 ) NEW_LINE DEDENT DEDENT subset = ( ( 1 << countSetBits ) - 1 ) NEW_LINE subset = ( subset * ( 1 << i ) ) NEW_LINE ans = ans + subset NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE size = len ( arr ) NEW_LINE print ( andSum ( arr , size ) ) NEW_LINE
def _popcnt32 ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def maximize ( a ) : NEW_LINE INDENT n = _popcnt32 ( a ) NEW_LINE if ( n == 32 ) : NEW_LINE INDENT return a NEW_LINE DEDENT res = ( 1 << n ) - 1 NEW_LINE return ( res << ( 32 - n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE print ( maximize ( a ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT i = 3 NEW_LINE print ( countSetBits ( i ) ) NEW_LINE
def isEven ( n ) : NEW_LINE INDENT isEven = True ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if isEven == True : NEW_LINE INDENT isEven = False ; NEW_LINE DEDENT else : NEW_LINE INDENT isEven = True ; NEW_LINE DEDENT DEDENT return isEven ; NEW_LINE DEDENT n = 101 ; NEW_LINE if isEven ( n ) == True : NEW_LINE INDENT print ( " Even " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) ; NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT return ( int ( n / 2 ) * 2 == n ) NEW_LINE DEDENT n = 101 NEW_LINE if ( isEven ( n ) != False ) : NEW_LINE INDENT print ( " Even " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Odd " ) NEW_LINE DEDENT
def add ( x , y ) : NEW_LINE INDENT keep = ( x & y ) << 1 ; NEW_LINE res = x ^ y ; NEW_LINE if ( keep == 0 ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT return add ( keep , res ) ; NEW_LINE DEDENT print ( add ( 15 , 38 ) ) ; NEW_LINE
def checkValidPair ( num1 , num2 ) : NEW_LINE INDENT s1 = str ( num1 ) NEW_LINE s2 = str ( num2 ) NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ j ] ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT DEDENT return False ; NEW_LINE DEDENT def countPairs ( arr , n ) : NEW_LINE INDENT numberOfPairs = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( checkValidPair ( arr [ i ] , arr [ j ] ) ) : NEW_LINE INDENT numberOfPairs += 1 NEW_LINE DEDENT DEDENT DEDENT return numberOfPairs NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 12 , 24 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
NUM_BITS = 32 NEW_LINE def isPowerOf2 ( num ) : NEW_LINE INDENT return ( num and ( num & ( num - 1 ) ) == 0 ) NEW_LINE DEDENT def checkSubsequence ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return isPowerOf2 ( arr [ 0 ] ) NEW_LINE DEDENT total = 0 NEW_LINE for i in range ( 0 , NUM_BITS ) : NEW_LINE INDENT total = total | ( 1 << i ) NEW_LINE DEDENT for i in range ( 0 , NUM_BITS ) : NEW_LINE INDENT ans = total NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ j ] & ( 1 << i ) ) : NEW_LINE INDENT ans = ans & arr [ j ] NEW_LINE DEDENT DEDENT if ( isPowerOf2 ( ans ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT arr = [ 12 , 13 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE if ( checkSubsequence ( arr , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def findWinner ( A , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res ^= A [ i ] NEW_LINE DEDENT if ( res == 0 or n % 2 == 0 ) : NEW_LINE INDENT return " Alice " NEW_LINE DEDENT else : NEW_LINE INDENT return " Bob " NEW_LINE DEDENT DEDENT A = [ 1 , 4 , 3 , 5 ] NEW_LINE n = len ( A ) NEW_LINE print ( " Winner ▁ = ▁ " , findWinner ( A , n ) ) NEW_LINE
def isFibbinaryNum ( n ) : NEW_LINE INDENT if ( ( n & ( n >> 1 ) ) == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 10 NEW_LINE if ( isFibbinaryNum ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import math NEW_LINE def maxXOR ( n , k ) : NEW_LINE INDENT c = int ( math . log ( n , 2 ) ) + 1 NEW_LINE return ( ( 1 << c ) - 1 ) NEW_LINE DEDENT n = 12 ; k = 3 NEW_LINE print ( maxXOR ( n , k ) ) NEW_LINE
def divide ( dividend , divisor ) : NEW_LINE INDENT sign = ( - 1 if ( ( dividend < 0 ) ^ ( divisor < 0 ) ) else 1 ) ; NEW_LINE dividend = abs ( dividend ) ; NEW_LINE divisor = abs ( divisor ) ; NEW_LINE quotient = 0 ; NEW_LINE temp = 0 ; NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT if ( temp + ( divisor << i ) <= dividend ) : NEW_LINE INDENT temp += divisor << i ; NEW_LINE quotient |= 1 << i ; NEW_LINE DEDENT DEDENT if sign == - 1 : NEW_LINE quotient = - quotient ; NEW_LINE return quotient ; NEW_LINE DEDENT a = 10 ; NEW_LINE b = 3 ; NEW_LINE print ( divide ( a , b ) ) ; NEW_LINE a = 43 ; NEW_LINE b = - 8 ; NEW_LINE print ( divide ( a , b ) ) ; NEW_LINE
def count ( n ) : NEW_LINE INDENT c = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return c NEW_LINE DEDENT def XOR ( a , b ) : NEW_LINE INDENT c = min ( a , b ) NEW_LINE d = max ( a , b ) NEW_LINE if ( count ( c ) < count ( d ) ) : NEW_LINE INDENT c = c << ( count ( d ) - count ( c ) ) NEW_LINE DEDENT return ( c ^ d ) NEW_LINE DEDENT a = 13 ; b = 5 NEW_LINE print ( XOR ( a , b ) ) NEW_LINE
import math NEW_LINE def swapBitsInPair ( x ) : NEW_LINE INDENT return ( ( x & 0b10101010 ) >> 1 ) or ( ( x & 0b01010101 ) << 1 ) NEW_LINE DEDENT x = 4 ; NEW_LINE print ( swapBitsInPair ( x ) ) NEW_LINE
def setevenbits ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE res = 0 NEW_LINE while temp > 0 : NEW_LINE INDENT if count % 2 : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( n & res ) NEW_LINE DEDENT def setoddbits ( m ) : NEW_LINE INDENT temp = m NEW_LINE count = 0 NEW_LINE res = 0 NEW_LINE while temp > 0 : NEW_LINE INDENT if not count % 2 : NEW_LINE INDENT res |= ( 1 << count ) NEW_LINE DEDENT count += 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return ( m & res ) NEW_LINE DEDENT def getAlternateBits ( n , m ) : NEW_LINE INDENT tempn = setevenbits ( n ) NEW_LINE tempm = setoddbits ( m ) NEW_LINE return ( tempn tempm ) NEW_LINE DEDENT n = 10 NEW_LINE m = 11 NEW_LINE print ( getAlternateBits ( n , m ) ) NEW_LINE
def toggleBits ( n1 , n2 ) : NEW_LINE INDENT return ( n1 ^ n2 ) NEW_LINE DEDENT n1 = 2 NEW_LINE n2 = 5 NEW_LINE print ( toggleBits ( n1 , n2 ) ) NEW_LINE
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 NEW_LINE count = 0 NEW_LINE temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 1 ) : NEW_LINE INDENT res = res | ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT n = 11 NEW_LINE print ( evenbittogglenumber ( n ) ) NEW_LINE
def takeLandFsetbits ( n ) : NEW_LINE INDENT n = n | n >> 1 NEW_LINE n = n | n >> 2 NEW_LINE n = n | n >> 4 NEW_LINE n = n | n >> 8 NEW_LINE n = n | n >> 16 NEW_LINE return ( ( n + 1 ) >> 1 ) + 1 NEW_LINE DEDENT def toggleFandLbits ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return n ^ takeLandFsetbits ( n ) NEW_LINE DEDENT n = 10 NEW_LINE print ( toggleFandLbits ( n ) ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def checkOdious ( n ) : NEW_LINE INDENT return ( countSetBits ( n ) % 2 == 1 ) NEW_LINE DEDENT num = 32 NEW_LINE if ( checkOdious ( num ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def setleftmostunsetbit ( n ) : NEW_LINE INDENT if not ( n & ( n + 1 ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT pos , temp , count = 0 , n , 0 NEW_LINE while temp : NEW_LINE INDENT if not ( temp & 1 ) : NEW_LINE INDENT pos = count NEW_LINE DEDENT count += 1 ; temp >>= 1 NEW_LINE DEDENT return ( n | ( 1 << ( pos ) ) ) NEW_LINE DEDENT n = 10 NEW_LINE print ( setleftmostunsetbit ( n ) ) NEW_LINE
def maxXorSum ( n , k ) : NEW_LINE INDENT if k == 1 : NEW_LINE INDENT return n NEW_LINE DEDENT res = 1 NEW_LINE while res <= n : NEW_LINE INDENT res <<= 1 NEW_LINE DEDENT return res - 1 NEW_LINE DEDENT n = 4 NEW_LINE k = 3 NEW_LINE print ( maxXorSum ( n , k ) ) NEW_LINE
import math NEW_LINE def getPosOfRightmostSetBit ( n ) : NEW_LINE INDENT return math . log2 ( n & - n ) NEW_LINE DEDENT def toggleLastKBits ( n , k ) : NEW_LINE INDENT num = ( 1 << ( int ) ( k ) ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def incrementByOne ( n ) : NEW_LINE INDENT k = getPosOfRightmostSetBit ( ~ n ) NEW_LINE n = ( ( 1 << ( int ) ( k ) ) n ) NEW_LINE if ( k != 0 ) : NEW_LINE INDENT n = toggleLastKBits ( n , k ) NEW_LINE DEDENT return n NEW_LINE DEDENT n = 15 NEW_LINE print ( incrementByOne ( n ) ) NEW_LINE
import math NEW_LINE def swap ( a , b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT def xnor ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT a_rem = 0 NEW_LINE b_rem = 0 NEW_LINE count = 0 NEW_LINE xnornum = 0 NEW_LINE while ( a != 0 ) : NEW_LINE INDENT a_rem = a & 1 NEW_LINE b_rem = b & 1 NEW_LINE if ( a_rem == b_rem ) : NEW_LINE INDENT xnornum |= ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE DEDENT return xnornum ; NEW_LINE DEDENT a = 10 NEW_LINE b = 50 NEW_LINE print ( xnor ( a , b ) ) NEW_LINE
import math NEW_LINE def togglebit ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT i = n NEW_LINE n = n | ( n >> 1 ) NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return i ^ n NEW_LINE DEDENT def xnor ( num1 , num2 ) : NEW_LINE INDENT if ( num1 < num2 ) : NEW_LINE INDENT temp = num1 NEW_LINE num1 = num2 NEW_LINE num2 = temp NEW_LINE DEDENT num1 = togglebit ( num1 ) NEW_LINE return num1 ^ num2 NEW_LINE DEDENT a = 10 NEW_LINE b = 20 NEW_LINE print ( xnor ( a , b ) ) NEW_LINE
def MaximumSum ( a , b , n ) : NEW_LINE INDENT sum1 = 0 NEW_LINE sum2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum1 |= a [ i ] NEW_LINE sum2 |= b [ i ] NEW_LINE DEDENT print ( sum1 + sum2 ) NEW_LINE DEDENT A = [ 1 , 2 , 4 , 3 , 2 ] NEW_LINE B = [ 2 , 3 , 3 , 12 , 1 ] NEW_LINE n = len ( A ) NEW_LINE MaximumSum ( A , B , n ) NEW_LINE
def isPowerOfTwo ( x ) : NEW_LINE INDENT return x and ( not ( x & ( x - 1 ) ) ) NEW_LINE DEDENT def differAtOneBitPos ( a , b ) : NEW_LINE INDENT return isPowerOfTwo ( a ^ b ) NEW_LINE DEDENT a = 13 NEW_LINE b = 9 NEW_LINE if ( differAtOneBitPos ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def power2 ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT return power2 ( n / 2 ) * NEW_LINE INDENT power2 ( n / 2 ) ; NEW_LINE DEDENT DEDENT def multiply ( x , n ) : NEW_LINE INDENT return x * power2 ( n ) ; NEW_LINE DEDENT x = 70 NEW_LINE n = 2 NEW_LINE print ( multiply ( x , n ) ) NEW_LINE
def multiply ( x , n ) : NEW_LINE INDENT return x << n NEW_LINE DEDENT x = 70 NEW_LINE n = 2 NEW_LINE print ( multiply ( x , n ) ) NEW_LINE
def isDivBy2PowerM ( n , m ) : NEW_LINE INDENT if ( n & ( ( 1 << m ) - 1 ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n = 8 NEW_LINE m = 2 NEW_LINE if isDivBy2PowerM ( n , m ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findWinner ( N ) : NEW_LINE INDENT return N & 1 NEW_LINE DEDENT N = 15 NEW_LINE print ( " Player ▁ A " if findWinner ( N ) else " Player ▁ B " ) NEW_LINE
def evenbittogglenumber ( n ) : NEW_LINE INDENT res = 0 ; count = 0 ; temp = n NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( count % 2 == 0 ) : NEW_LINE INDENT res = res | ( 1 << count ) NEW_LINE DEDENT count = count + 1 NEW_LINE temp >>= 1 NEW_LINE DEDENT return n ^ res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 11 NEW_LINE print ( evenbittogglenumber ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def divide ( n , m ) : NEW_LINE INDENT print ( " Remainder ▁ = ▁ " , ( ( n ) & ( m - 1 ) ) ) NEW_LINE print ( " Quotient ▁ = ▁ " , ( n >> ( int ) ( math . log2 ( m ) ) ) ) NEW_LINE DEDENT n = 43 NEW_LINE m = 8 NEW_LINE divide ( n , m ) NEW_LINE
def maxAND ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT res = max ( res , arr [ i ] & arr [ j ] ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT arr = [ 4 , 8 , 6 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Maximum ▁ AND ▁ Value ▁ = ▁ " , maxAND ( arr , n ) ) NEW_LINE
def index ( i ) : NEW_LINE INDENT return 1 + ( i >> 31 ) - ( - i >> 31 ) NEW_LINE DEDENT def check ( n ) : NEW_LINE INDENT s = " negative " , " zero " , " positive " NEW_LINE val = index ( n ) NEW_LINE print ( n , " is " , s [ val ] ) NEW_LINE DEDENT check ( 30 ) NEW_LINE check ( - 20 ) NEW_LINE check ( 0 ) NEW_LINE
def checking ( s ) : NEW_LINE INDENT c = 0 NEW_LINE n = len ( s ) NEW_LINE i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c >= 6 and s [ i ] == '1' ) : NEW_LINE INDENT return True NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "100010001" NEW_LINE if ( checking ( s ) ) : NEW_LINE INDENT print ( " Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT
def modifyBit ( n , p , b ) : NEW_LINE INDENT mask = 1 << p NEW_LINE return ( n & ~ mask ) | ( ( b << p ) & mask ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT print ( modifyBit ( 6 , 2 , 0 ) ) NEW_LINE print ( modifyBit ( 6 , 5 , 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
' NEW_LINE def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n &= ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countSetBitsInGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE DEDENT ' NEW_LINE INDENT return countSetBits ( n & num ) NEW_LINE DEDENT n = 42 NEW_LINE l = 2 NEW_LINE r = 5 NEW_LINE ans = countSetBitsInGivenRange ( n , l , r ) NEW_LINE print ( ans ) NEW_LINE
' NEW_LINE def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def isOnesComplementOfOther ( a , b ) : NEW_LINE INDENT return areAllBitsSet ( a ^ b ) NEW_LINE DEDENT a = 1 NEW_LINE b = 14 NEW_LINE if ( isOnesComplementOfOther ( a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE def findUnique ( a , n , k ) : NEW_LINE INDENT INT_SIZE = 8 * sys . getsizeof ( int ) NEW_LINE count = [ 0 ] * INT_SIZE NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( ( a [ j ] & ( 1 << i ) ) != 0 ) : NEW_LINE INDENT count [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT res = 0 NEW_LINE for i in range ( INT_SIZE ) : NEW_LINE INDENT res += ( count [ i ] % k ) * ( 1 << i ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 6 , 2 , 5 , 2 , 2 , 6 , 6 ] NEW_LINE n = len ( a ) NEW_LINE k = 3 NEW_LINE print ( findUnique ( a , n , k ) ) ; NEW_LINE DEDENT
def powerOfTwo ( n ) : NEW_LINE INDENT return ( not ( n & n - 1 ) ) NEW_LINE DEDENT def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return powerOfTwo ( n - 1 ) NEW_LINE DEDENT n = 9 NEW_LINE if ( onlyFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
' NEW_LINE def allBitsAreSet ( n ) : NEW_LINE INDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def bitsAreInAltOrder ( n ) : NEW_LINE INDENT num = n ^ ( n >> 1 ) ; NEW_LINE DEDENT ' NEW_LINE INDENT return allBitsAreSet ( num ) ; NEW_LINE DEDENT n = 10 ; NEW_LINE if ( bitsAreInAltOrder ( n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
import math NEW_LINE def setBit ( xorValue ) : NEW_LINE INDENT count = 0 NEW_LINE while ( xorValue ) : NEW_LINE INDENT if ( xorValue % 2 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT xorValue = int ( xorValue / 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT def minFlip ( n , k ) : NEW_LINE INDENT size = int ( math . log ( n ) / math . log ( 2 ) + 1 ) NEW_LINE max = pow ( 2 , k ) - 1 NEW_LINE max = max << ( size - k ) NEW_LINE xorValue = ( n ^ max ) NEW_LINE return ( setBit ( xorValue ) ) NEW_LINE DEDENT n = 27 NEW_LINE k = 3 NEW_LINE print ( " Min ▁ Flips ▁ = ▁ " , minFlip ( n , k ) ) NEW_LINE
def setallbitgivenrange ( n , l , r ) : NEW_LINE INDENT range = ( ( ( 1 << ( l - 1 ) ) - 1 ) ^ ( ( 1 << ( r ) ) - 1 ) ) NEW_LINE return ( n range ) NEW_LINE DEDENT n , l , r = 17 , 2 , 3 NEW_LINE print ( setallbitgivenrange ( n , l , r ) ) NEW_LINE
import math NEW_LINE def countBits ( number ) : NEW_LINE INDENT return int ( ( math . log ( number ) / math . log ( 2 ) ) + 1 ) ; NEW_LINE DEDENT num = 65 ; NEW_LINE print ( countBits ( num ) ) ; NEW_LINE
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 17 NEW_LINE l = 2 NEW_LINE r = 4 NEW_LINE print ( allBitsSetInTheGivenRange ( n , l , r ) ) NEW_LINE DEDENT
def setAllBitsAfterMSB ( n ) : NEW_LINE INDENT n |= n >> 1 NEW_LINE n |= n >> 2 NEW_LINE n |= n >> 4 NEW_LINE n |= n >> 8 NEW_LINE n |= n >> 16 NEW_LINE return n NEW_LINE DEDENT def toggle ( n ) : NEW_LINE INDENT n = n ^ setAllBitsAfterMSB ( n ) NEW_LINE return n NEW_LINE DEDENT n = 10 NEW_LINE n = toggle ( n ) NEW_LINE print ( n ) NEW_LINE
import math NEW_LINE ' NEW_LINE def getRightMostSetBit ( n ) : NEW_LINE INDENT return int ( math . log2 ( n & - n ) ) + 1 NEW_LINE DEDENT ' NEW_LINE def posOfRightMostSameBit ( m , n ) : NEW_LINE INDENT return getRightMostSetBit ( ~ ( m ^ n ) ) NEW_LINE DEDENT m , n = 16 , 7 NEW_LINE print ( " Position ▁ = ▁ " , posOfRightMostSameBit ( m , n ) ) NEW_LINE
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( num == new_num ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT n , l , r = 22 , 2 , 3 NEW_LINE print ( allBitsSetInTheGivenRange ( n , l , r ) ) NEW_LINE
def printNonConsecutive ( n ) : NEW_LINE INDENT p = ( 1 << n ) NEW_LINE for i in range ( 1 , p ) : NEW_LINE INDENT if ( ( i & ( i << 1 ) ) == 0 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT n = 3 NEW_LINE printNonConsecutive ( n ) NEW_LINE
INT_SIZE = 32 NEW_LINE def constructNthNumber ( group_no , aux_num , op ) : NEW_LINE INDENT a = [ 0 ] * INT_SIZE NEW_LINE num , i = 0 , 0 NEW_LINE if op == 2 : NEW_LINE INDENT len_f = 2 * group_no NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT elif op == 0 : NEW_LINE INDENT len_f = 2 * group_no + 1 NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE a [ group_no ] = 0 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT len_f = 2 * group_no + 1 NEW_LINE a [ len_f - 1 ] = a [ 0 ] = 1 NEW_LINE a [ group_no ] = 1 NEW_LINE while aux_num : NEW_LINE INDENT a [ group_no + 1 + i ] = a [ group_no - 1 - i ] = aux_num & 1 NEW_LINE aux_num = aux_num >> 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , len_f ) : NEW_LINE INDENT num += ( 1 << i ) * a [ i ] NEW_LINE DEDENT return num NEW_LINE DEDENT def getNthNumber ( n ) : NEW_LINE INDENT group_no = 0 NEW_LINE count_upto_group , count_temp = 0 , 1 NEW_LINE while count_temp < n : NEW_LINE INDENT group_no += 1 NEW_LINE count_upto_group = count_temp NEW_LINE count_temp += 3 * ( 1 << ( group_no - 1 ) ) NEW_LINE DEDENT group_offset = n - count_upto_group - 1 NEW_LINE if ( group_offset + 1 ) <= ( 1 << ( group_no - 1 ) ) : NEW_LINE INDENT aux_num = group_offset NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( group_offset + 1 ) - ( 1 << ( group_no - 1 ) ) ) % 2 ) : NEW_LINE else : NEW_LINE aux_num = ( ( ( group_offset ) - ( 1 << ( group_no - 1 ) ) ) // 2 ) NEW_LINE DEDENT return constructNthNumber ( group_no , aux_num , op ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 9 NEW_LINE print ( getNthNumber ( n ) ) NEW_LINE DEDENT
def countSetBits ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def findSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( countSetBits ( i ) == 2 ) : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( findSum ( n ) ) NEW_LINE
def toggleLastMBits ( n , m ) : NEW_LINE INDENT num = ( 1 << m ) - 1 NEW_LINE return ( n ^ num ) NEW_LINE DEDENT n = 107 NEW_LINE m = 4 NEW_LINE print ( toggleLastMBits ( n , m ) ) NEW_LINE
import math NEW_LINE def getFirstSetBitPos ( n ) : NEW_LINE INDENT return ( int ) ( math . log ( n & - n ) / math . log ( 2 ) ) + 1 NEW_LINE DEDENT def previousSmallerInteger ( n ) : NEW_LINE INDENT pos = getFirstSetBitPos ( n ) NEW_LINE DEDENT ' NEW_LINE INDENT return ( n & ~ ( 1 << ( pos - 1 ) ) ) NEW_LINE DEDENT n = 25 NEW_LINE print ( " Previous ▁ small ▁ Integer ▁ = ▁ " , previousSmallerInteger ( n ) ) NEW_LINE
' NEW_LINE def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return " Yes " NEW_LINE DEDENT n = 7 NEW_LINE print ( areAllBitsSet ( n ) ) NEW_LINE
' NEW_LINE def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT if ( ( ( n + 1 ) & n ) == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT n = 7 NEW_LINE print ( areAllBitsSet ( n ) ) NEW_LINE
import math NEW_LINE def getFirstSetBitPos ( n ) : NEW_LINE INDENT return ( ( int ) ( math . log ( n & - n ) / math . log ( 2 ) ) + 1 ) - 1 NEW_LINE DEDENT def nextGreaterWithOneMoreSetBit ( n ) : NEW_LINE INDENT pos = getFirstSetBitPos ( ~ n ) NEW_LINE if ( pos > - 1 ) : NEW_LINE INDENT return ( 1 << pos ) | n NEW_LINE DEDENT return ( ( n << 1 ) + 1 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( " Next ▁ greater ▁ integer ▁ = ▁ " , nextGreaterWithOneMoreSetBit ( n ) ) NEW_LINE
def CountZeroBit ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT if ( ( x & 1 ) == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT x >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def CountXORandSumEqual ( x ) : NEW_LINE INDENT count = CountZeroBit ( x ) NEW_LINE return ( 1 << count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 10 NEW_LINE print ( CountXORandSumEqual ( x ) ) NEW_LINE DEDENT
def missingNumber ( arr1 , arr2 , n ) : NEW_LINE ' NEW_LINE INDENT mnum = 0 NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT mnum = mnum ^ arr1 [ i ] NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT mnum = mnum ^ arr2 [ i ] NEW_LINE DEDENT return mnum NEW_LINE DEDENT arr1 = [ 4 , 8 , 1 , 3 , 7 ] NEW_LINE arr2 = [ 7 , 4 , 3 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( " Missing ▁ number ▁ = ▁ " , missingNumber ( arr1 , arr2 , n ) ) NEW_LINE
def countValues ( x ) : NEW_LINE INDENT count = 0 ; NEW_LINE n = 1 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 2 == 0 ) : NEW_LINE INDENT count += n ; NEW_LINE DEDENT n *= 2 ; NEW_LINE x /= 2 ; NEW_LINE x = int ( x ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT x = 10 ; NEW_LINE print ( countValues ( x ) ) ; NEW_LINE
def constructXOR ( A , n ) : NEW_LINE INDENT XOR = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT XOR ^= A [ i ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT A [ i ] = XOR ^ A [ i ] NEW_LINE DEDENT DEDENT A = [ 2 , 4 , 1 , 3 , 5 ] NEW_LINE n = len ( A ) NEW_LINE constructXOR ( A , n ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def bitCount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def countPairsWithKDiff ( arr , n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n - 1 , 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT xoredNum = arr [ i ] ^ arr [ j ] NEW_LINE if ( k == bitCount ( xoredNum ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 2 NEW_LINE arr = [ 2 , 4 , 1 , 3 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Total ▁ pairs ▁ for ▁ k ▁ = " , k , " are " , countPairsWithKDiff ( arr , n , k ) ) NEW_LINE DEDENT
def multiply ( n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE count = 0 NEW_LINE while ( m ) : NEW_LINE INDENT if ( m % 2 == 1 ) : NEW_LINE INDENT ans += n << count NEW_LINE DEDENT count += 1 NEW_LINE m = int ( m / 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 20 NEW_LINE m = 13 NEW_LINE print ( multiply ( n , m ) ) NEW_LINE DEDENT
def EqualNumber ( A , B ) : NEW_LINE INDENT return ( A ^ B ) NEW_LINE DEDENT A = 5 ; B = 6 NEW_LINE print ( int ( not ( EqualNumber ( A , B ) ) ) ) NEW_LINE
import sys NEW_LINE def areSetBitsIncreasing ( n ) : NEW_LINE INDENT prev_count = sys . maxsize NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( n > 0 and n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE DEDENT curr_count = 1 NEW_LINE while ( n > 0 and n % 2 == 1 ) : NEW_LINE INDENT n = n / 2 NEW_LINE curr_count += 1 NEW_LINE DEDENT if ( curr_count >= prev_count ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_count = curr_count NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if ( areSetBitsIncreasing ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findPattern ( n ) : NEW_LINE INDENT prev = n % 2 NEW_LINE n = n // 2 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT curr = n % 2 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE print ( " Yes " ) if ( findPattern ( n ) ) else print ( " No " ) NEW_LINE
def countXOR ( n ) : NEW_LINE INDENT count0 , count1 = 0 , 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT n //= 2 NEW_LINE DEDENT return ( count0 ^ count1 ) NEW_LINE DEDENT n = 31 NEW_LINE print ( countXOR ( n ) ) NEW_LINE
def msbPos ( n ) : NEW_LINE INDENT msb_p = - 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT n = n >> 1 NEW_LINE msb_p += 1 NEW_LINE DEDENT return msb_p NEW_LINE DEDENT def andOperator ( x , y ) : NEW_LINE INDENT while ( x > 0 and y > 0 ) : NEW_LINE INDENT msb_p1 = msbPos ( x ) NEW_LINE msb_p2 = msbPos ( y ) NEW_LINE if ( msb_p1 != msb_p2 ) : NEW_LINE INDENT break NEW_LINE DEDENT msb_val = ( 1 << msb_p1 ) NEW_LINE res = res + msb_val NEW_LINE x = x - msb_val NEW_LINE y = y - msb_val NEW_LINE DEDENT return res NEW_LINE DEDENT x , y = 10 , 15 NEW_LINE print ( andOperator ( x , y ) ) NEW_LINE
def multiplyTen ( n ) : NEW_LINE INDENT return ( n << 1 ) + ( n << 3 ) NEW_LINE DEDENT n = 50 NEW_LINE print ( multiplyTen ( n ) ) NEW_LINE
def countValues ( n ) : NEW_LINE INDENT countV = 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( ( n + i ) == ( n ^ i ) ) : NEW_LINE INDENT countV += 1 ; NEW_LINE DEDENT DEDENT return countV ; NEW_LINE DEDENT n = 12 ; NEW_LINE print ( countValues ( n ) ) ; NEW_LINE
def countValues ( n ) : NEW_LINE INDENT unset_bits = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if n & 1 == 0 : NEW_LINE INDENT unset_bits += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return 1 << unset_bits NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE print ( countValues ( n ) ) NEW_LINE DEDENT
def findProffesion ( level , pos ) : NEW_LINE INDENT if ( level == 1 ) : NEW_LINE INDENT return ' e ' NEW_LINE DEDENT if ( findProffesion ( level - 1 , ( pos + 1 ) // 2 ) == ' d ' ) : NEW_LINE INDENT if ( pos % 2 ) : NEW_LINE INDENT return ' d ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' e ' NEW_LINE DEDENT DEDENT if ( pos % 2 ) : NEW_LINE INDENT return ' e ' NEW_LINE DEDENT else : NEW_LINE INDENT return ' d ' NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT level = 3 NEW_LINE pos = 4 NEW_LINE if ( findProffesion ( level , pos ) == ' e ' ) : NEW_LINE INDENT print ( " Engineer " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Doctor " ) NEW_LINE DEDENT DEDENT
def printTwoSetBitNums ( n ) : NEW_LINE INDENT x = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT y = 0 NEW_LINE while ( y < x ) : NEW_LINE INDENT print ( ( 1 << x ) + ( 1 << y ) , end = " ▁ " ) NEW_LINE n -= 1 NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT y += 1 NEW_LINE DEDENT x += 1 NEW_LINE DEDENT DEDENT printTwoSetBitNums ( 4 ) NEW_LINE
def printRepeatingEven ( arr , n ) : NEW_LINE INDENT axor = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT pos = 1 << arr [ i ] ; NEW_LINE axor ^= pos ; NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT pos = 1 << arr [ i ] ; NEW_LINE if ( not ( pos & axor ) ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE axor ^= pos ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 9 , 12 , 23 , 10 , 12 , 12 , 15 , 23 , 14 , 12 , 15 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE printRepeatingEven ( arr , n ) ; NEW_LINE
def countSetBits ( x ) : NEW_LINE INDENT count = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x = x & ( x - 1 ) NEW_LINE count = count + 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def isBleak ( n ) : NEW_LINE INDENT for x in range ( 1 , n ) : NEW_LINE INDENT if ( x + countSetBits ( x ) == n ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if ( isBleak ( 3 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT if ( isBleak ( 4 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findXOR ( Set , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return Set [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT Set = [ 1 , 2 , 3 ] NEW_LINE n = len ( Set ) NEW_LINE print ( " XOR ▁ of ▁ XOR ' s ▁ of ▁ all ▁ subsets ▁ is ▁ " , findXOR ( Set , n ) ) ; NEW_LINE
def myXOR ( x , y ) : NEW_LINE INDENT return ( ( x y ) & ( ~ x ~ y ) ) NEW_LINE DEDENT x = 3 NEW_LINE y = 5 NEW_LINE print ( " XOR ▁ is " , myXOR ( x , y ) ) NEW_LINE
import random NEW_LINE N = 2 NEW_LINE def freivald ( a , b , c ) : NEW_LINE INDENT r = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT r [ i ] = ( int ) ( random . randrange ( 509090009 ) % 2 ) NEW_LINE DEDENT br = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT br [ i ] = br [ i ] + b [ i ] [ j ] * r [ j ] NEW_LINE DEDENT DEDENT cr = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT cr [ i ] = cr [ i ] + c [ i ] [ j ] * r [ j ] NEW_LINE DEDENT DEDENT axbr = [ 0 ] * N NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( 0 , N ) : NEW_LINE INDENT axbr [ i ] = axbr [ i ] + a [ i ] [ j ] * br [ j ] NEW_LINE DEDENT DEDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( axbr [ i ] - cr [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isProduct ( a , b , c , k ) : NEW_LINE INDENT for i in range ( 0 , k ) : NEW_LINE INDENT if ( freivald ( a , b , c ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT a = [ [ 1 , 1 ] , [ 1 , 1 ] ] NEW_LINE b = [ [ 1 , 1 ] , [ 1 , 1 ] ] NEW_LINE c = [ [ 2 , 2 ] , [ 2 , 2 ] ] NEW_LINE k = 2 NEW_LINE if ( isProduct ( a , b , c , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def calc_Expectation ( a , n ) : NEW_LINE INDENT prb = 1 / n NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += ( a [ i ] * prb ) NEW_LINE DEDENT return float ( sum ) NEW_LINE DEDENT n = 6 ; NEW_LINE a = [ 1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 ] NEW_LINE expect = calc_Expectation ( a , n ) NEW_LINE print ( " Expectation ▁ of ▁ array ▁ E ( X ) ▁ is ▁ : ▁ " , expect ) NEW_LINE
def findPoints ( l1 , r1 , l2 , r2 ) : NEW_LINE INDENT x = min ( l1 , l2 ) if ( l1 != l2 ) else - 1 NEW_LINE y = max ( r1 , r2 ) if ( r1 != r2 ) else - 1 NEW_LINE print ( x , y ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l1 = 5 NEW_LINE r1 = 10 NEW_LINE l2 = 1 NEW_LINE r2 = 7 NEW_LINE findPoints ( l1 , r1 , l2 , r2 ) NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return n * fact ( n - 1 ) NEW_LINE DEDENT print ( fact ( 5 ) ) NEW_LINE
def printElements ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE cnt = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( a [ i ] != a [ i + 1 ] ) : NEW_LINE INDENT print ( a [ i ] , " ▁ occurs ▁ " , cnt , " times " ) NEW_LINE cnt = 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT print ( a [ n - 1 ] , " occurs " , cnt , " times " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 1 , 1 , 2 , 3 , 4 , 9 , 9 , 10 ] NEW_LINE n = len ( a ) NEW_LINE printElements ( a , n ) NEW_LINE DEDENT
from math import log2 , floor NEW_LINE SMALL_N = 1000000 NEW_LINE LARGE_N = 1000000000000000 NEW_LINE def func ( a , b , c , n ) : NEW_LINE INDENT res = a * n NEW_LINE logVlaue = floor ( log2 ( n ) ) NEW_LINE res += b * n * logVlaue NEW_LINE res += c * ( n * n * n ) NEW_LINE return res NEW_LINE DEDENT def getPositionInSeries ( a , b , c , k ) : NEW_LINE INDENT start = 1 NEW_LINE end = SMALL_N NEW_LINE if ( c == 0 ) : NEW_LINE INDENT end = LARGE_N NEW_LINE DEDENT ans = 0 NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE val = func ( a , b , c , mid ) NEW_LINE if ( val == k ) : NEW_LINE INDENT ans = mid NEW_LINE break NEW_LINE DEDENT elif ( val > k ) : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT start = mid + 1 NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 2 NEW_LINE b = 1 NEW_LINE c = 1 NEW_LINE k = 12168587437017 NEW_LINE print ( getPositionInSeries ( a , b , c , k ) ) NEW_LINE DEDENT
def checkIndices ( Arr , N ) : NEW_LINE INDENT for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( Arr [ i ] != Arr [ j ] ) : NEW_LINE INDENT if ( Arr [ Arr [ i ] - 1 ] == Arr [ Arr [ j ] - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Arr = [ 3 , 2 , 1 , 1 , 4 ] NEW_LINE N = len ( Arr ) NEW_LINE if checkIndices ( Arr , N ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
' NEW_LINE def printPairs ( arr , n , sum ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] == sum ) : NEW_LINE INDENT print ( " ( " , arr [ i ] , " , ▁ " , arr [ j ] , " ) " , sep = " " ) NEW_LINE DEDENT DEDENT DEDENT DEDENT arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE printPairs ( arr , n , sum ) NEW_LINE
def minSum ( arr , n ) : NEW_LINE INDENT sm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] == arr [ i - 1 ] : NEW_LINE INDENT j = i NEW_LINE while j < n and arr [ j ] <= arr [ j - 1 ] : NEW_LINE INDENT arr [ j ] = arr [ j ] + 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT sm = sm + arr [ i ] NEW_LINE DEDENT return sm NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minSum ( arr , n ) ) NEW_LINE
def minSum ( arr , n ) : NEW_LINE INDENT sum = arr [ 0 ] ; prev = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] <= prev : NEW_LINE INDENT prev = prev + 1 NEW_LINE sum = sum + prev NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE prev = arr [ i ] NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT arr = [ 2 , 2 , 3 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minSum ( arr , n ) ) NEW_LINE
def PandigitalProduct_1_9 ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( ( n % i == 0 ) and bool ( isPandigital ( str ( n ) + str ( i ) + str ( n // i ) ) ) ) : NEW_LINE INDENT return bool ( True ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return bool ( False ) NEW_LINE DEDENT def isPandigital ( Str ) : NEW_LINE INDENT if ( len ( Str ) != 9 ) : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT ch = " " . join ( sorted ( Str ) ) NEW_LINE if ( ch == "123456789" ) : NEW_LINE INDENT return bool ( True ) NEW_LINE DEDENT else : NEW_LINE INDENT return bool ( False ) NEW_LINE DEDENT DEDENT n = 6952 NEW_LINE if ( bool ( PandigitalProduct_1_9 ( n ) ) ) : NEW_LINE INDENT print ( " yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " no " ) NEW_LINE DEDENT
def printModeMedian ( a , n ) : NEW_LINE INDENT b = [ 0 ] * n NEW_LINE Max = max ( a ) NEW_LINE t = Max + 1 NEW_LINE count = [ 0 ] * t NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT mode = 0 NEW_LINE k = count [ 0 ] NEW_LINE for i in range ( 1 , t ) : NEW_LINE INDENT if ( count [ i ] > k ) : NEW_LINE INDENT k = count [ i ] NEW_LINE mode = i NEW_LINE DEDENT DEDENT for i in range ( 1 , t ) : NEW_LINE INDENT count [ i ] = count [ i ] + count [ i - 1 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT b [ count [ a [ i ] ] - 1 ] = a [ i ] NEW_LINE count [ a [ i ] ] -= 1 NEW_LINE DEDENT median = 0.0 NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT median = b [ n // 2 ] NEW_LINE DEDENT else : NEW_LINE INDENT median = ( ( b [ ( n - 1 ) // 2 ] + b [ n // 2 ] ) / 2.0 ) NEW_LINE DEDENT print ( " median ▁ = " , median ) NEW_LINE print ( " mode ▁ = " , mode ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 1 , 2 , 7 , 1 , 2 , 5 , 3 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE printModeMedian ( arr , n ) NEW_LINE DEDENT
MAX = 26 NEW_LINE def function ( st ) : NEW_LINE INDENT global MAX NEW_LINE l = len ( st ) NEW_LINE counter1 , counter2 = [ 0 ] * MAX , [ 0 ] * MAX NEW_LINE for i in range ( l // 2 ) : NEW_LINE INDENT counter1 [ ord ( st [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( l // 2 , l ) : NEW_LINE INDENT counter2 [ ord ( st [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( counter2 [ i ] != counter1 [ i ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT st = " abcasdsabcae " NEW_LINE if function ( st ) : print ( " Yes , ▁ both ▁ halves ▁ differ ▁ " , " by ▁ at ▁ least ▁ one ▁ character " ) NEW_LINE else : print ( " No , ▁ both ▁ halves ▁ do ▁ not ▁ differ ▁ at ▁ all " ) NEW_LINE
def minDifferenceAmongMaxMin ( arr , N , K ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE res = 2147483647 NEW_LINE for i in range ( ( N - K ) + 1 ) : NEW_LINE INDENT curSeqDiff = arr [ i + K - 1 ] - arr [ i ] NEW_LINE res = min ( res , curSeqDiff ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 100 , 101 , 102 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( minDifferenceAmongMaxMin ( arr , N , K ) ) NEW_LINE
def getIndexInSortedArray ( arr , n , idx ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < arr [ idx ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT if ( arr [ i ] == arr [ idx ] and i < idx ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT arr = [ 3 , 4 , 3 , 5 , 2 , 3 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE idxOfEle = 5 NEW_LINE print getIndexInSortedArray ( arr , n , idxOfEle ) NEW_LINE
def getMaxValue ( arr , arr_size ) : NEW_LINE INDENT if ( arr_size < 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT first = - sys . maxsize - 1 NEW_LINE second = - sys . maxsize - 1 NEW_LINE for i in range ( arr_size ) : NEW_LINE INDENT if ( arr [ i ] > first ) : NEW_LINE INDENT second = first NEW_LINE first = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > second and arr [ i ] != first ) : NEW_LINE INDENT second = arr [ i ] NEW_LINE DEDENT DEDENT if ( second == - sys . maxsize - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return second NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 5 , 1 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxValue ( arr , n ) ) NEW_LINE DEDENT
def maximumResult ( a , b , c ) : NEW_LINE INDENT countOfNegative = 0 NEW_LINE Sum = a + b + c NEW_LINE product = a * b * c NEW_LINE largest = max ( a , b , c ) NEW_LINE smallest = min ( a , b , c ) NEW_LINE if a < 0 : NEW_LINE INDENT countOfNegative += 1 NEW_LINE DEDENT if b < 0 : NEW_LINE INDENT countOfNegative += 1 NEW_LINE DEDENT if c < 0 : NEW_LINE INDENT countOfNegative += 1 NEW_LINE DEDENT if countOfNegative == 0 : NEW_LINE INDENT return ( Sum - largest ) * largest NEW_LINE DEDENT elif countOfNegative == 1 : NEW_LINE INDENT return ( product // smallest ) + smallest NEW_LINE DEDENT elif countOfNegative == 2 : NEW_LINE INDENT return ( product // largest ) + largest NEW_LINE DEDENT elif countOfNegative == 3 : NEW_LINE INDENT return ( Sum - smallest ) * smallest NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c = - 2 , - 1 , - 4 NEW_LINE print ( maximumResult ( a , b , c ) ) NEW_LINE DEDENT
def check ( n , marks ) : NEW_LINE INDENT x = max ( marks ) NEW_LINE bonus = 100 - x NEW_LINE c = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( marks [ i ] + bonus >= 50 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT n = 5 NEW_LINE marks = [ 0 , 21 , 83 , 45 , 64 ] NEW_LINE print ( check ( n , marks ) ) NEW_LINE
def find_sum ( n , k ) : NEW_LINE INDENT total_sum = ( n * ( n + 1 ) ) // 2 NEW_LINE power = k NEW_LINE while power <= n : NEW_LINE INDENT total_sum -= power NEW_LINE power *= k NEW_LINE DEDENT return total_sum NEW_LINE DEDENT n = 11 ; k = 2 NEW_LINE print ( find_sum ( n , k ) ) NEW_LINE
MAX = 10000 NEW_LINE hashTable = [ 0 ] * MAX NEW_LINE def minOperations ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hashTable [ arr [ i ] ] += 1 NEW_LINE DEDENT res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( hashTable [ arr [ i ] ] ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( arr [ j ] % arr [ i ] == 0 ) : NEW_LINE INDENT hashTable [ arr [ j ] ] = 0 NEW_LINE DEDENT DEDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 6 , 2 , 8 , 7 , 21 , 24 , 49 , 44 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
def ifPossible ( arr , n ) : NEW_LINE INDENT cp = [ 0 ] * n NEW_LINE cp = arr NEW_LINE cp . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( not ( arr [ i ] == cp [ i ] ) and not ( arr [ n - 1 - i ] == cp [ i ] ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 1 , 7 , 6 , 4 , 5 , 3 , 2 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE if ( ifPossible ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE def FindMinimumCost ( ind , a , n , k , dp ) : NEW_LINE INDENT if ( ind == ( n - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( dp [ ind ] != - 1 ) : NEW_LINE INDENT return dp [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = sys . maxsize NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ind + i < n ) : NEW_LINE INDENT ans = min ( ans , abs ( a [ ind + i ] - a [ ind ] ) + FindMinimumCost ( ind + i , a , n , k , dp ) ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp [ ind ] = ans NEW_LINE return ans NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 10 , 30 , 40 , 50 , 20 ] NEW_LINE k = 3 NEW_LINE n = len ( a ) NEW_LINE dp = [ - 1 for i in range ( n ) ] NEW_LINE print ( FindMinimumCost ( 0 , a , n , k , dp ) ) NEW_LINE DEDENT
def sieve_modified ( ) : NEW_LINE INDENT for i in range ( 2 , MAX , 2 ) : NEW_LINE INDENT for j in range ( i , MAX , i ) : NEW_LINE INDENT prefix [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT prefix [ i ] += prefix [ i - 1 ] NEW_LINE DEDENT DEDENT def sumEvenFactors ( L , R ) : NEW_LINE INDENT return ( prefix [ R ] - prefix [ L - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT MAX = 100000 NEW_LINE prefix = [ 0 ] * MAX NEW_LINE sieve_modified ( ) NEW_LINE l , r = 6 , 10 NEW_LINE print ( sumEvenFactors ( l , r ) ) NEW_LINE DEDENT
N = 1000 ; NEW_LINE dp = [ [ - 1 for x in range ( N ) ] for y in range ( N ) ] ; NEW_LINE adj = [ 1 , 0 , 0 , 0 ] ; NEW_LINE def find ( index , openbrk , n ) : NEW_LINE INDENT if ( openbrk < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT if ( openbrk == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if ( dp [ index ] [ openbrk ] != - 1 ) : NEW_LINE INDENT return dp [ index ] [ openbrk ] ; NEW_LINE DEDENT if ( adj [ index ] == 1 ) : NEW_LINE INDENT dp [ index ] [ openbrk ] = find ( index + 1 , openbrk + 1 , n ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ index ] [ openbrk ] = ( find ( index + 1 , openbrk + 1 , n ) + find ( index + 1 , openbrk - 1 , n ) ) ; NEW_LINE DEDENT return dp [ index ] [ openbrk ] ; NEW_LINE DEDENT n = 2 ; NEW_LINE print ( find ( 0 , 0 , 2 * n ) ) ; NEW_LINE
ans = 0 ; NEW_LINE def findMaxValUtil ( arr , n , num , maxLimit , ind ) : NEW_LINE INDENT global ans NEW_LINE if ( ind == n ) : NEW_LINE INDENT ans = max ( ans , num ) NEW_LINE return NEW_LINE DEDENT if ( num - arr [ ind ] >= 0 ) : NEW_LINE INDENT findMaxValUtil ( arr , n , num - arr [ ind ] , maxLimit , ind + 1 ) NEW_LINE DEDENT if ( num + arr [ ind ] <= maxLimit ) : NEW_LINE INDENT findMaxValUtil ( arr , n , num + arr [ ind ] , maxLimit , ind + 1 ) NEW_LINE DEDENT DEDENT def findMaxVal ( arr , n , num , maxLimit ) : NEW_LINE INDENT global ans NEW_LINE ind = 0 NEW_LINE findMaxValUtil ( arr , n , num , maxLimit , ind ) NEW_LINE return ans NEW_LINE DEDENT num = 1 NEW_LINE arr = [ 3 , 10 , 6 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE maxLimit = 15 NEW_LINE print ( findMaxVal ( arr , n , num , maxLimit ) ) NEW_LINE
def printSets ( set1 , set2 ) : NEW_LINE INDENT for i in range ( 0 , len ( set1 ) ) : NEW_LINE INDENT print ( " { } ▁ " . format ( set1 [ i ] ) , end = " " ) ; NEW_LINE DEDENT print ( " " ) NEW_LINE for i in range ( 0 , len ( set2 ) ) : NEW_LINE INDENT print ( " { } ▁ " . format ( set2 [ i ] ) , end = " " ) ; NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT def findSets ( arr , n , set1 , set2 , sum1 , sum2 , pos ) : NEW_LINE INDENT if ( pos == n ) : NEW_LINE INDENT if ( sum1 == sum2 ) : NEW_LINE INDENT printSets ( set1 , set2 ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT set1 . append ( arr [ pos ] ) NEW_LINE res = findSets ( arr , n , set1 , set2 , sum1 + arr [ pos ] , sum2 , pos + 1 ) NEW_LINE if ( res ) : NEW_LINE INDENT return res NEW_LINE DEDENT set1 . pop ( ) NEW_LINE set2 . append ( arr [ pos ] ) NEW_LINE res = findSets ( arr , n , set1 , set2 , sum1 , sum2 + arr [ pos ] , pos + 1 ) NEW_LINE if not res : NEW_LINE INDENT set2 . pop ( ) NEW_LINE DEDENT return res NEW_LINE DEDENT def isPartitionPoss ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT set1 = [ ] NEW_LINE set2 = [ ] NEW_LINE return findSets ( arr , n , set1 , set2 , 0 , 0 , 0 ) NEW_LINE DEDENT arr = [ 5 , 5 , 1 , 11 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isPartitionPoss ( arr , n ) == False ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT
import math NEW_LINE def maximumSumSubarray ( arr , n ) : NEW_LINE INDENT min_prefix_sum = 0 NEW_LINE res = - math . inf NEW_LINE prefix_sum = [ ] NEW_LINE prefix_sum . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix_sum . append ( prefix_sum [ i - 1 ] + arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT res = max ( res , prefix_sum [ i ] - min_prefix_sum ) NEW_LINE min_prefix_sum = min ( min_prefix_sum , prefix_sum [ i ] ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr1 = [ - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE print ( maximumSumSubarray ( arr1 , n1 ) ) NEW_LINE arr2 = [ 4 , - 8 , 9 , - 4 , 1 , - 8 , - 1 , 6 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( maximumSumSubarray ( arr2 , n2 ) ) NEW_LINE
DP_s = 9 NEW_LINE def getNumMonotone ( ln ) : NEW_LINE INDENT DP = [ [ 0 ] * DP_s for i in range ( ln ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( ln ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT print ( getNumMonotone ( 10 ) ) NEW_LINE
import array NEW_LINE def sequence ( n ) : NEW_LINE INDENT f = array . array ( ' i ' , [ 0 , 1 , 1 ] ) NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT r = f [ f [ i - 1 ] ] + f [ i - f [ i - 1 ] ] NEW_LINE f . append ( r ) ; NEW_LINE DEDENT return r NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 10 NEW_LINE print sequence ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def Hosoya ( n , m ) : NEW_LINE INDENT if ( ( n == 0 and m == 0 ) or ( n == 1 and m == 0 ) or ( n == 1 and m == 1 ) or ( n == 2 and m == 1 ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n > m : NEW_LINE INDENT return Hosoya ( n - 1 , m ) NEW_LINE INDENT + Hosoya ( n - 2 , m ) NEW_LINE DEDENT DEDENT elif m == n : NEW_LINE INDENT return Hosoya ( n - 1 , m - 1 ) NEW_LINE INDENT + Hosoya ( n - 2 , m - 2 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def printHosoya ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 ) : NEW_LINE INDENT print ( Hosoya ( i , j ) , end = " ▁ " ) NEW_LINE DEDENT print ( " " , ▁ end ▁ = ▁ " " ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE printHosoya ( n ) NEW_LINE
def eulerian ( n , m ) : NEW_LINE INDENT if ( m >= n or n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return ( ( n - m ) * eulerian ( n - 1 , m - 1 ) + ( m + 1 ) * eulerian ( n - 1 , m ) ) NEW_LINE DEDENT n = 3 NEW_LINE m = 1 NEW_LINE print ( eulerian ( n , m ) ) NEW_LINE
def largestSubset ( a , n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n ) ] NEW_LINE dp [ n - 1 ] = 1 ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT mxm = 0 ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] % a [ i ] == 0 or a [ i ] % a [ j ] == 0 : NEW_LINE INDENT mxm = max ( mxm , dp [ j ] ) NEW_LINE DEDENT DEDENT dp [ i ] = 1 + mxm NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT a = [ 1 , 3 , 6 , 13 , 17 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestSubset ( a , n ) ) NEW_LINE
def countFriendsPairings ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( i <= 2 ) : NEW_LINE INDENT dp [ i ] = i NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT n = 4 NEW_LINE print ( countFriendsPairings ( n ) ) NEW_LINE
def countFriendsPairings ( n ) : NEW_LINE INDENT a , b , c = 1 , 2 , 0 ; NEW_LINE if ( n <= 2 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT for i in range ( 3 , n + 1 ) : NEW_LINE INDENT c = b + ( i - 1 ) * a ; NEW_LINE a = b ; NEW_LINE b = c ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT n = 4 ; NEW_LINE print ( countFriendsPairings ( n ) ) ; NEW_LINE
def lcsOf3 ( X , Y , Z , m , n , o ) : NEW_LINE INDENT L = [ [ [ 0 for i in range ( o + 1 ) ] for j in range ( n + 1 ) ] for k in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT for k in range ( o + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 or k == 0 ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] and X [ i - 1 ] == Z [ k - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] [ k ] = L [ i - 1 ] [ j - 1 ] [ k - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] [ k ] = max ( max ( L [ i - 1 ] [ j ] [ k ] , L [ i ] [ j - 1 ] [ k ] ) , L [ i ] [ j ] [ k - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return L [ m ] [ n ] [ o ] NEW_LINE DEDENT X = ' AGGT12' NEW_LINE Y = '12TXAYB ' NEW_LINE Z = '12XBA ' NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE o = len ( Z ) NEW_LINE print ( ' Length ▁ of ▁ LCS ▁ is ' , lcsOf3 ( X , Y , Z , m , n , o ) ) NEW_LINE
def findLongestRepeatingSubSeq ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE dp = [ [ 0 for i in range ( n + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( str [ i - 1 ] == str [ j - 1 ] and i != j ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 + dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j - 1 ] , dp [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " aabb " NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ largest ▁ subsequence ▁ that ▁ repeats ▁ itself ▁ is ▁ : ▁ " , findLongestRepeatingSubSeq ( str ) ) NEW_LINE DEDENT
def numberOfPaths ( p , q ) : NEW_LINE INDENT dp = [ 1 for i in range ( q ) ] NEW_LINE for i in range ( p - 1 ) : NEW_LINE INDENT for j in range ( 1 , q ) : NEW_LINE INDENT dp [ j ] += dp [ j - 1 ] NEW_LINE DEDENT DEDENT return dp [ q - 1 ] NEW_LINE DEDENT print ( numberOfPaths ( 3 , 3 ) ) NEW_LINE
def factorial ( N ) : NEW_LINE INDENT if N == 0 or N == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return N * factorial ( N - 1 ) NEW_LINE DEDENT def nthTerm ( N ) : NEW_LINE INDENT return ( factorial ( N ) * ( N + 2 ) // 2 ) NEW_LINE DEDENT N = 6 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
def isFrequencyEqual ( string , length ) : NEW_LINE INDENT if length % 2 == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if freq [ i ] == length // 2 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " NEW_LINE length = len ( string ) NEW_LINE if isFrequencyEqual ( string , length ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countMinimalReplacements ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == s [ i - 1 ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE if ( i != ( n - 1 ) ) : NEW_LINE INDENT s = list ( s ) NEW_LINE for j in "012" : NEW_LINE INDENT if ( j != s [ i + 1 ] and j != s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = j NEW_LINE break NEW_LINE DEDENT DEDENT s = ' ' . join ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT s = list ( s ) NEW_LINE for k in "012" : NEW_LINE INDENT if ( k != s [ i - 1 ] ) : NEW_LINE INDENT s [ i ] = k NEW_LINE break NEW_LINE DEDENT DEDENT s = ' ' . join ( s ) NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "201220211" NEW_LINE print ( countMinimalReplacements ( s ) ) NEW_LINE DEDENT
def minimize ( string ) : NEW_LINE INDENT mstr = " ▁ " NEW_LINE flagchar = [ 0 ] * 26 NEW_LINE l = len ( string ) NEW_LINE for i in range ( 0 , len ( string ) ) : NEW_LINE INDENT ch = string [ i ] NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if flagchar [ ord ( ch ) - 97 ] == 0 : NEW_LINE INDENT mstr = mstr + ch NEW_LINE flagchar [ ord ( ch ) - 97 ] = 1 NEW_LINE DEDENT DEDENT def replaceMinimizeUtil ( string ) : NEW_LINE INDENT finalStr = " " NEW_LINE l = len ( string ) NEW_LINE for i in range ( 0 , len ( minimizedStr ) ) : NEW_LINE INDENT ch = ord ( minimizedStr [ i ] ) NEW_LINE index = ( ch * ch ) % l NEW_LINE finalStr = finalStr + string [ index ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeks " NEW_LINE replaceMinimizeUtil ( string ) NEW_LINE DEDENT
def cipher ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] . isalpha ( ) == 0 and str [ i ] != " ▁ " : NEW_LINE INDENT print ( " Enter ▁ only ▁ alphabets ▁ and ▁ space " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " Encrypted ▁ Code ▁ using ▁ Latin ▁ Alphabet " ) NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] >= " A " and str [ i ] <= " Z " : NEW_LINE INDENT print ( ord ( str [ i ] ) - ord ( " A " ) + 1 , end = " ▁ " ) NEW_LINE DEDENT elif str [ i ] >= " a " and str [ i ] <= ' z ' : NEW_LINE INDENT print ( ord ( str [ i ] ) - ord ( " a " ) + 1 , end = " ▁ " ) NEW_LINE DEDENT if str [ i ] == " ▁ " : NEW_LINE INDENT print ( str [ i ] ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE cipher ( str ) NEW_LINE DEDENT
def round ( n ) : NEW_LINE INDENT a = ( n // 10 ) * 10 NEW_LINE b = a + 10 NEW_LINE return ( b if n - a > b - n else a ) NEW_LINE DEDENT n = 4722 NEW_LINE print ( round ( n ) ) NEW_LINE
def findString ( n , k ) : NEW_LINE INDENT res = " " NEW_LINE for i in range ( k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - k ) : NEW_LINE INDENT res = res + chr ( ord ( ' a ' ) + count ) NEW_LINE count += 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT count = 0 ; NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE print ( findString ( n , k ) ) NEW_LINE DEDENT
def isVowel ( ch ) : NEW_LINE INDENT return ch . upper ( ) in [ ' A ' , ' E ' , ' I ' , ' O ' , ' U ' ] NEW_LINE DEDENT def countVovels ( str , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return isVowel ( str [ n - 1 ] ) ; NEW_LINE DEDENT return ( countVovels ( str , n - 1 ) + isVowel ( str [ n - 1 ] ) ) ; NEW_LINE DEDENT str = " abc ▁ de " ; NEW_LINE print ( countVovels ( str , len ( str ) ) ) NEW_LINE
def printRotatedString ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE temp = string + string NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT print ( temp [ i + j ] , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeks " NEW_LINE printRotatedString ( string ) NEW_LINE DEDENT
M = 26 NEW_LINE def getIdx ( ch ) : NEW_LINE INDENT return ( ord ( ch ) - ord ( ' a ' ) ) NEW_LINE DEDENT def allSame ( freq , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT same = freq [ i ] NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( freq [ j ] > 0 and freq [ j ] != same ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def possibleSameCharFreqByOneRemoval ( str1 ) : NEW_LINE INDENT l = len ( str1 ) NEW_LINE freq = [ 0 ] * M NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT freq [ getIdx ( str1 [ i ] ) ] += 1 NEW_LINE DEDENT if ( allSame ( freq , M ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT freq [ i ] -= 1 NEW_LINE if ( allSame ( freq , M ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT freq [ i ] += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " xyyzz " NEW_LINE if ( possibleSameCharFreqByOneRemoval ( str1 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE oddDigSum = 0 NEW_LINE evenDigSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT oddDigSum = oddDigSum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT else : NEW_LINE INDENT evenDigSum = evenDigSum + ( ( int ) ( st [ i ] ) ) NEW_LINE DEDENT DEDENT return ( ( oddDigSum - evenDigSum ) % 11 == 0 ) NEW_LINE DEDENT st = "76945" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ " ) NEW_LINE DEDENT
def hammingDist ( str1 , str2 ) : NEW_LINE INDENT i = 0 NEW_LINE count = 0 NEW_LINE while ( i < len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT str1 = " geekspractice " NEW_LINE str2 = " nerdspractise " NEW_LINE print ( hammingDist ( str1 , str2 ) ) NEW_LINE
MAX_CHAR = 26 NEW_LINE def arekAnagrams ( str1 , str2 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE if ( len ( str2 ) != n ) : NEW_LINE INDENT return False NEW_LINE DEDENT count1 = [ 0 ] * MAX_CHAR NEW_LINE count2 = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( count1 [ i ] > count2 [ i ] ) : NEW_LINE INDENT count = count + abs ( count1 [ i ] - count2 [ i ] ) NEW_LINE DEDENT DEDENT return ( count <= k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str1 = " anagram " NEW_LINE str2 = " grammar " NEW_LINE k = 2 NEW_LINE if ( arekAnagrams ( str1 , str2 , k ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countSubStr ( st , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT m = m + 1 NEW_LINE DEDENT DEDENT return m * ( m - 1 ) // 2 NEW_LINE DEDENT st = "00100101" ; NEW_LINE list ( st ) NEW_LINE n = len ( st ) NEW_LINE print ( countSubStr ( st , n ) , end = " " ) NEW_LINE
def count9s ( number ) : NEW_LINE INDENT n = len ( number ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum = ord ( number [ i ] ) - ord ( '0' ) NEW_LINE if ( number [ i ] == '9' ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT sum = ( sum + ord ( number [ j ] ) - ord ( '0' ) ) % 9 NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( count9s ( "4189" ) ) NEW_LINE print ( count9s ( "1809" ) ) NEW_LINE DEDENT
def minStepsRecur ( height , l , r , h ) : NEW_LINE INDENT if l >= r : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT m = l NEW_LINE for i in range ( l , r ) : NEW_LINE INDENT if height [ i ] < height [ m ] : NEW_LINE INDENT m = i NEW_LINE DEDENT DEDENT return min ( r - l , minStepsRecur ( height , l , m , height [ m ] ) + minStepsRecur ( height , m + 1 , r , height [ m ] ) + height [ m ] - h ) NEW_LINE DEDENT def minSteps ( height , N ) : NEW_LINE INDENT return minStepsRecur ( height , 0 , N , 0 ) NEW_LINE DEDENT height = [ 2 , 1 , 2 , 5 , 1 ] NEW_LINE N = len ( height ) NEW_LINE print ( minSteps ( height , N ) ) NEW_LINE
def ReuleauxArea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = 0.70477 * pow ( a , 2 ) ; NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 6 NEW_LINE print ( ReuleauxArea ( a ) ) NEW_LINE DEDENT
def hexagonside ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT x = 0.5176 * a ; NEW_LINE return x ; NEW_LINE DEDENT a = 6 ; NEW_LINE print ( hexagonside ( a ) ) ; NEW_LINE
def hexagonside ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = a // 3 NEW_LINE return x NEW_LINE DEDENT a = 6 NEW_LINE print ( hexagonside ( a ) ) NEW_LINE
def findSegment ( n , m , segment_length ) : NEW_LINE INDENT meet_point = ( 1.0 * n ) / 2.0 NEW_LINE sum = 0 NEW_LINE segment_number = 0 NEW_LINE for i in range ( 0 , m , 1 ) : NEW_LINE INDENT sum += segment_length [ i ] NEW_LINE if ( sum == meet_point ) : NEW_LINE INDENT segment_number = - 1 NEW_LINE break NEW_LINE DEDENT if ( sum > meet_point ) : NEW_LINE INDENT segment_number = i + 1 NEW_LINE break NEW_LINE DEDENT DEDENT return segment_number NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE m = 3 NEW_LINE segment_length = [ 3 , 2 , 8 ] NEW_LINE ans = findSegment ( n , m , segment_length ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def countMaxIntersect ( n ) : NEW_LINE INDENT return int ( n * ( n - 1 ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE print ( countMaxIntersect ( n ) ) NEW_LINE DEDENT
def surfaceArea ( a , b , h ) : NEW_LINE INDENT return 5 * a * b + 5 * b * h NEW_LINE DEDENT def volume ( b , h ) : NEW_LINE INDENT return ( 5 * b * h ) / 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 3 NEW_LINE h = 7 NEW_LINE print ( " surface ▁ area ▁ = " , surfaceArea ( a , b , h ) , " , " , " volume ▁ = " , volume ( b , h ) ) NEW_LINE DEDENT
def checkpoint ( h , k , x , y , a ) : NEW_LINE INDENT p = pow ( ( y - k ) , 2 ) - 4 * a * ( x - h ) NEW_LINE return p NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT h = 0 NEW_LINE k = 0 NEW_LINE x = 2 NEW_LINE y = 1 NEW_LINE a = 4 NEW_LINE if checkpoint ( h , k , x , y , a ) > 0 : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT elif checkpoint ( h , k , x , y , a ) == 0 : NEW_LINE INDENT print ( " On the parabola " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Inside " ) ; NEW_LINE DEDENT DEDENT
import math NEW_LINE def checkpoint ( h , k , x , y , a , b ) : NEW_LINE INDENT p = ( ( math . pow ( ( x - h ) , 2 ) // math . pow ( a , 2 ) ) + ( math . pow ( ( y - k ) , 2 ) // math . pow ( b , 2 ) ) ) NEW_LINE return p NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT h = 0 NEW_LINE k = 0 NEW_LINE x = 2 NEW_LINE y = 1 NEW_LINE a = 4 NEW_LINE b = 5 NEW_LINE if ( checkpoint ( h , k , x , y , a , b ) > 1 ) : NEW_LINE INDENT print ( " Outside " ) NEW_LINE DEDENT elif ( checkpoint ( h , k , x , y , a , b ) == 1 ) : NEW_LINE INDENT print ( " On ▁ the ▁ ellipse " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Inside " ) NEW_LINE DEDENT DEDENT
def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 8 NEW_LINE b = 10 NEW_LINE print ( circlearea ( a , b ) ) NEW_LINE DEDENT
def circlearea ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( l < b ) : NEW_LINE INDENT return 3.14 * pow ( l // 2 , 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return 3.14 * pow ( b // 2 , 2 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 4 NEW_LINE b = 8 NEW_LINE print ( circlearea ( l , b ) ) NEW_LINE DEDENT
def centered_cube ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) * ( n * n + n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , " th ▁ Centered ▁ cube ▁ " + " number ▁ : ▁ " , centered_cube ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , " th ▁ Centered ▁ cube ▁ " + " number ▁ : ▁ " , centered_cube ( n ) ) NEW_LINE DEDENT
def center ( x1 , x2 , y1 , y2 ) : NEW_LINE INDENT print ( int ( ( x1 + x2 ) / 2 ) , end = " " ) NEW_LINE print ( " , " , int ( ( y1 + y2 ) / 2 ) ) NEW_LINE DEDENT x1 = - 9 ; y1 = 3 ; x2 = 5 ; y2 = - 7 NEW_LINE center ( x1 , x2 , y1 , y2 ) NEW_LINE
import math NEW_LINE def vol_of_octahedron ( side ) : NEW_LINE INDENT return ( ( side * side * side ) * ( math . sqrt ( 2 ) / 3 ) ) NEW_LINE DEDENT side = 3 NEW_LINE print ( " Volume ▁ of ▁ octahedron ▁ = " , round ( vol_of_octahedron ( side ) , 4 ) ) NEW_LINE
import math NEW_LINE def volumeOfEllipsoid ( r1 , r2 , r3 ) : NEW_LINE INDENT return 1.33 * math . pi * r1 * r2 * r3 NEW_LINE DEDENT r1 = float ( 2.3 ) NEW_LINE r2 = float ( 3.4 ) NEW_LINE r3 = float ( 5.7 ) NEW_LINE print ( " Volume ▁ of ▁ ellipsoid ▁ is ▁ : ▁ " , volumeOfEllipsoid ( r1 , r2 , r3 ) ) NEW_LINE
import math NEW_LINE def areaOctagon ( side ) : NEW_LINE INDENT return ( 2 * ( 1 + ( math . sqrt ( 2 ) ) ) * side * side ) NEW_LINE DEDENT side = 4 NEW_LINE print ( " Area ▁ of ▁ Regular ▁ Octagon ▁ = " , round ( areaOctagon ( side ) , 4 ) ) NEW_LINE
def areaCube ( a ) : NEW_LINE INDENT return ( a * a * a ) NEW_LINE DEDENT def surfaceCube ( a ) : NEW_LINE INDENT return ( 6 * a * a ) NEW_LINE DEDENT a = 5 NEW_LINE print ( " Area ▁ = " , areaCube ( a ) ) NEW_LINE print ( " Total ▁ surface ▁ area ▁ = " , surfaceCube ( a ) ) NEW_LINE
import math NEW_LINE def minRevolutions ( r , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT d = math . sqrt ( ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 ) ) NEW_LINE return math . ceil ( d / ( 2 * r ) ) NEW_LINE DEDENT r = 2 NEW_LINE x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 0 NEW_LINE y2 = 4 NEW_LINE print ( minRevolutions ( r , x1 , y1 , x2 , y2 ) ) NEW_LINE
import math NEW_LINE def getArea ( base , hypotenuse ) : NEW_LINE INDENT height = math . sqrt ( hypotenuse * hypotenuse - base * base ) ; NEW_LINE return 0.5 * base * height NEW_LINE DEDENT def printRightAngleTriangle ( hypotenuse , area ) : NEW_LINE INDENT hsquare = hypotenuse * hypotenuse NEW_LINE sideForMaxArea = math . sqrt ( hsquare / 2.0 ) NEW_LINE maxArea = getArea ( sideForMaxArea , hypotenuse ) NEW_LINE if ( area > maxArea ) : NEW_LINE INDENT print ( " Not ▁ possiblen " ) NEW_LINE return NEW_LINE DEDENT low = 0.0 NEW_LINE high = sideForMaxArea NEW_LINE while ( abs ( high - low ) > 1e-6 ) : NEW_LINE INDENT base = ( low + high ) / 2.0 NEW_LINE if ( getArea ( base , hypotenuse ) >= area ) : NEW_LINE INDENT high = base NEW_LINE DEDENT else : NEW_LINE INDENT low = base NEW_LINE DEDENT DEDENT height = math . ceil ( math . sqrt ( hsquare - base * base ) ) NEW_LINE base = math . floor ( base ) NEW_LINE print ( base , height ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT hypotenuse = 5 NEW_LINE area = 6 NEW_LINE printRightAngleTriangle ( hypotenuse , area ) NEW_LINE DEDENT
import math NEW_LINE def countLattice ( r ) : NEW_LINE INDENT if ( r <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT result = 4 NEW_LINE for x in range ( 1 , r ) : NEW_LINE INDENT ySquare = r * r - x * x NEW_LINE y = int ( math . sqrt ( ySquare ) ) NEW_LINE if ( y * y == ySquare ) : NEW_LINE INDENT result += 4 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT r = 5 NEW_LINE print ( countLattice ( r ) ) NEW_LINE
def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT L = 2 ; P = pow ( 10 , 9 ) ; NEW_LINE ans = power ( 325 , L , P ) ; NEW_LINE print ( ans ) ; NEW_LINE
MAXN = 30 NEW_LINE def countMaxLength ( N ) : NEW_LINE INDENT pre = [ 0 for i in range ( MAXN ) ] NEW_LINE p = 1 NEW_LINE pre [ 0 ] = 0 NEW_LINE for i in range ( 1 , MAXN , 1 ) : NEW_LINE INDENT p *= 2 NEW_LINE pre [ i ] = pre [ i - 1 ] + i * p NEW_LINE DEDENT for i in range ( 1 , MAXN , 1 ) : NEW_LINE INDENT if ( pre [ i ] >= N ) : NEW_LINE INDENT ind = i NEW_LINE break NEW_LINE DEDENT DEDENT x = N - pre [ ind - 1 ] NEW_LINE y = 2 * ind - 1 NEW_LINE if ( x >= y ) : NEW_LINE INDENT res = min ( x , y ) NEW_LINE DEDENT else : NEW_LINE INDENT res = max ( x , 2 * ( ind - 2 ) + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 25 NEW_LINE print ( countMaxLength ( N ) ) NEW_LINE DEDENT
def factorialUsingRecursion ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return n * factorialUsingRecursion ( n - 1 ) ; NEW_LINE DEDENT def factorialUsingIteration ( n ) : NEW_LINE INDENT res = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res *= i ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT num = 5 ; NEW_LINE print ( " Factorial ▁ of " , num , " using ▁ Recursion ▁ is : " , factorialUsingRecursion ( 5 ) ) ; NEW_LINE print ( " Factorial ▁ of " , num , " using ▁ Iteration ▁ is : " , factorialUsingIteration ( 5 ) ) ; NEW_LINE
def maxSum ( arr , n , K ) : NEW_LINE INDENT maximum = - 2 ** 32 ; NEW_LINE sum = [ 0 ] * n NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i + K < n ) : NEW_LINE INDENT sum [ i ] = sum [ i + K ] + arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT sum [ i ] = arr [ i ] ; NEW_LINE DEDENT maximum = max ( maximum , sum [ i ] ) NEW_LINE DEDENT return maximum ; NEW_LINE DEDENT arr = [ 3 , 6 , 4 , 7 , 2 ] NEW_LINE n = len ( arr ) ; NEW_LINE K = 2 NEW_LINE print ( maxSum ( arr , n , K ) ) NEW_LINE
def findpair ( l , r ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT if ( j % i == 0 and j != i ) : NEW_LINE INDENT print ( i , " , ▁ " , j ) NEW_LINE c = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( c == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE findpair ( l , r ) NEW_LINE DEDENT
def check ( arr , N , K ) : NEW_LINE INDENT unique = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT unique [ arr [ i ] ] = 1 NEW_LINE DEDENT if len ( unique ) == K : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT arr = [ 1 , 1 , 2 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE if ( check ( arr , N , K ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def minIndex ( arr , n , pos ) : NEW_LINE INDENT num = arr [ pos ] NEW_LINE i = pos - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( arr [ i ] != num ) : NEW_LINE INDENT break NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return i + 1 NEW_LINE DEDENT arr = [ 2 , 1 , 1 , 1 , 5 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE pos = 4 NEW_LINE print ( minIndex ( arr , n , pos ) ) NEW_LINE
import math as mt NEW_LINE def findAnswer ( str1 , str2 , n ) : NEW_LINE INDENT l , r = 0 , 0 NEW_LINE ans = 2 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT l = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i ] ) : NEW_LINE INDENT r = i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT / * If str1 = str2 * / NEW_LINE INDENT if ( r < l ) : NEW_LINE INDENT return 26 * ( n + 1 ) NEW_LINE DEDENT elif ( l == r ) : NEW_LINE INDENT return ans NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ i - 1 ] ) : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( l + 1 , r + 1 ) : NEW_LINE INDENT if ( str1 [ i - 1 ] != str2 [ i ] ) : NEW_LINE INDENT ans -= 1 NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT str1 = " toy " NEW_LINE str2 = " try " NEW_LINE n = len ( str1 ) NEW_LINE print ( findAnswer ( str1 , str2 , n ) ) NEW_LINE
def findMinDifference ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff1 = arr [ n - 1 ] - arr [ 1 ] NEW_LINE diff2 = arr [ n - 2 ] - arr [ 0 ] NEW_LINE return min ( diff1 , diff2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDifference ( arr , n ) ) NEW_LINE DEDENT
def findMinDifference ( arr , n ) : NEW_LINE INDENT if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT min__ = secondMax = arr [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT min__ = secondMax = arr [ 1 ] NEW_LINE DEDENT if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT max__ = secondMin = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT max__ = secondMin = arr [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] > max__ ) : NEW_LINE INDENT secondMax = max__ NEW_LINE max__ = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > secondMax ) : NEW_LINE INDENT secondMax = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < min__ ) : NEW_LINE INDENT secondMin = min__ NEW_LINE min__ = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < secondMin ) : NEW_LINE INDENT secondMin = arr [ i ] NEW_LINE DEDENT DEDENT diff = min ( max__ - secondMin , secondMax - min__ ) NEW_LINE return diff NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDifference ( arr , n ) ) NEW_LINE DEDENT
def checkDistinct ( x ) : NEW_LINE INDENT last = x % 10 NEW_LINE while ( x ) : NEW_LINE INDENT if ( x % 10 != last ) : NEW_LINE INDENT return False NEW_LINE DEDENT x = x // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def findCount ( L , R ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( checkDistinct ( i ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT L = 10 NEW_LINE R = 50 NEW_LINE print ( findCount ( L , R ) ) NEW_LINE
import sys NEW_LINE def smallest_pair ( a , n ) : NEW_LINE INDENT min = sys . maxsize NEW_LINE secondMin = sys . maxsize NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( a [ j ] < min ) : NEW_LINE INDENT secondMin = min NEW_LINE min = a [ j ] NEW_LINE DEDENT elif ( ( a [ j ] < secondMin ) and a [ j ] != min ) : NEW_LINE INDENT secondMin = a [ j ] NEW_LINE DEDENT DEDENT return ( secondMin + min ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( smallest_pair ( arr , n ) ) NEW_LINE DEDENT
def longestsubarray ( arr , n , k ) : NEW_LINE INDENT current_count = 0 NEW_LINE max_count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] % k == 0 ) : NEW_LINE INDENT current_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT current_count = 0 NEW_LINE DEDENT max_count = max ( current_count , max_count ) NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 5 , 11 , 32 , 64 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE k = 8 NEW_LINE print ( longestsubarray ( arr , n , k ) ) NEW_LINE DEDENT
def check ( s ) : NEW_LINE INDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = " xzyyz " NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT j = 0 NEW_LINE while j < n : NEW_LINE INDENT if i != j and abs ( arr [ i ] - arr [ j ] ) <= k : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if j == n : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 7 , 1 , 8 ] NEW_LINE k = 5 NEW_LINE n = len ( arr ) NEW_LINE print ( countAnomalies ( arr , n , k ) ) NEW_LINE DEDENT
def colMaxDiff ( mat ) : NEW_LINE INDENT max_diff = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT max_val = mat [ 0 ] [ i ] NEW_LINE min_val = mat [ 0 ] [ i ] NEW_LINE for j in range ( 1 , N ) : NEW_LINE INDENT max_val = max ( max_val , mat [ j ] [ i ] ) NEW_LINE min_val = min ( min_val , mat [ j ] [ i ] ) NEW_LINE DEDENT max_diff = max ( max_diff , max_val - min_val ) NEW_LINE DEDENT return max_diff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 , 4 , 5 ] , [ 5 , 3 , 5 , 4 , 0 ] , [ 5 , 6 , 7 , 8 , 9 ] , [ 0 , 6 , 3 , 4 , 12 ] , [ 9 , 7 , 12 , 4 , 3 ] ] NEW_LINE print ( " Max ▁ difference ▁ : " , colMaxDiff ( mat ) ) NEW_LINE DEDENT
def search ( ar , size ) : NEW_LINE INDENT a = 0 NEW_LINE b = size - 1 NEW_LINE mid = 0 NEW_LINE while b > a + 1 : NEW_LINE INDENT mid = ( a + b ) // 2 NEW_LINE if ( ar [ a ] - a ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT b = mid NEW_LINE DEDENT elif ( ar [ b ] - b ) != ( ar [ mid ] - mid ) : NEW_LINE INDENT a = mid NEW_LINE DEDENT DEDENT return ar [ a ] + 1 NEW_LINE DEDENT a = [ 1 , 2 , 3 , 4 , 5 , 6 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Missing ▁ number : " , search ( a , n ) ) NEW_LINE
def deleteElement ( A , L , R , N ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i <= L or i >= R : NEW_LINE INDENT A [ j ] = A [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 ] NEW_LINE L , R = 2 , 7 NEW_LINE n = len ( A ) NEW_LINE res_size = deleteElement ( A , L , R , n ) NEW_LINE for i in range ( res_size ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findmissing ( ar , N ) : NEW_LINE INDENT l = 0 NEW_LINE r = N - 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) / 2 NEW_LINE mid = int ( mid ) NEW_LINE if ( ar [ mid ] != mid + 1 and ar [ mid - 1 ] == mid ) : NEW_LINE INDENT return ( mid + 1 ) NEW_LINE DEDENT elif ( ar [ mid ] != mid + 1 ) : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return ( - 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT ar = [ 1 , 2 , 3 , 4 , 5 , 7 , 8 ] NEW_LINE N = len ( ar ) NEW_LINE res = findmissing ( ar , N ) NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
import math NEW_LINE def findFirst ( arr , n , x ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ptr = lowerBound ( arr , 0 , n , x ) NEW_LINE return 1 if ( ptr != x ) else ( ptr - arr ) NEW_LINE DEDENT def lowerBound ( a , low , high , element ) : NEW_LINE INDENT while ( low < high ) : NEW_LINE INDENT middle = low + ( high - low ) // 2 NEW_LINE if ( element > a [ middle ] ) : NEW_LINE INDENT low = middle + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = middle NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 20 NEW_LINE arr = [ 10 , 30 , 20 , 50 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findFirst ( arr , n , x ) ) NEW_LINE DEDENT
def findFirst ( arr , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE isX = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == x ) : NEW_LINE INDENT isX = True NEW_LINE DEDENT elif ( arr [ i ] < x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return - 1 if ( isX == False ) else count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 20 NEW_LINE arr = [ 10 , 30 , 20 , 50 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findFirst ( arr , n , x ) ) NEW_LINE DEDENT
def findDuplicate ( arr ) : NEW_LINE INDENT slow = arr [ 0 ] NEW_LINE fast = arr [ 0 ] NEW_LINE while True : NEW_LINE INDENT slow = arr [ slow ] NEW_LINE fast = arr [ arr [ fast ] ] NEW_LINE if slow == fast : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT ptr1 = arr [ 0 ] NEW_LINE ptr2 = slow NEW_LINE while ptr1 != ptr2 : NEW_LINE INDENT ptr1 = arr [ ptr1 ] NEW_LINE ptr2 = arr [ ptr2 ] NEW_LINE DEDENT return ptr1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 1 ] NEW_LINE print ( findDuplicate ( arr ) ) NEW_LINE DEDENT
MAX_CHAR = 26 ; NEW_LINE def printGreaterCount ( str1 ) : NEW_LINE INDENT len1 = len ( str1 ) ; NEW_LINE ans = [ 0 ] * len1 ; NEW_LINE count = [ 0 ] * MAX_CHAR ; NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE for j in range ( ord ( str1 [ i ] ) - ord ( ' a ' ) + 1 , MAX_CHAR ) : NEW_LINE INDENT ans [ i ] += count [ j ] ; NEW_LINE DEDENT DEDENT for i in range ( len1 ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT str1 = " abcd " ; NEW_LINE printGreaterCount ( str1 ) ; NEW_LINE
import sys NEW_LINE def maxProduct ( arr , n ) : NEW_LINE INDENT if ( n < 4 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT maxA = - sys . maxsize - 1 NEW_LINE maxB = - sys . maxsize - 1 NEW_LINE maxC = - sys . maxsize - 1 NEW_LINE maxD = - sys . maxsize - 1 NEW_LINE minA = sys . maxsize NEW_LINE minB = sys . maxsize NEW_LINE minC = sys . maxsize NEW_LINE minD = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > maxA ) : NEW_LINE INDENT maxD = maxC NEW_LINE maxC = maxB NEW_LINE maxB = maxA NEW_LINE maxA = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxB ) : NEW_LINE INDENT maxD = maxC NEW_LINE maxC = maxB NEW_LINE maxB = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxC ) : NEW_LINE INDENT maxD = maxC NEW_LINE maxC = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] > maxD ) : NEW_LINE INDENT maxD = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < minA ) : NEW_LINE INDENT minD = minC NEW_LINE minC = minB NEW_LINE minB = minA NEW_LINE minA = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < minB ) : NEW_LINE INDENT minD = minC NEW_LINE minC = minB NEW_LINE minB = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < minC ) : NEW_LINE INDENT minD = minC NEW_LINE minC = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] < minD ) : NEW_LINE INDENT minD = arr [ i ] NEW_LINE DEDENT DEDENT x = maxA * maxB * maxC * maxD NEW_LINE y = minA * minB * minC * minD NEW_LINE z = minA * minB * maxA * maxB NEW_LINE return max ( x , max ( y , z ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , - 4 , 3 , - 6 , 7 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE max1 = maxProduct ( arr , n ) NEW_LINE if ( max1 == - 1 ) : NEW_LINE INDENT print ( " No ▁ Quadruple ▁ Exists " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Maximum ▁ product ▁ is " , max1 ) NEW_LINE DEDENT DEDENT
def countTripletsLessThanL ( n , L , arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ways = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT for k in range ( j + 1 , n ) : NEW_LINE INDENT mostDistantDistance = arr [ k ] - arr [ i ] NEW_LINE if ( mostDistantDistance <= L ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ways NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE L = 3 NEW_LINE ans = countTripletsLessThanL ( n , L , arr ) NEW_LINE print ( " Total ▁ Number ▁ of ▁ ways ▁ = " , ans ) NEW_LINE DEDENT
def missingNum ( arr , n ) : NEW_LINE INDENT minvalue = min ( arr ) NEW_LINE xornum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT xornum ^= ( minvalue ) ^ arr [ i ] NEW_LINE minvalue = minvalue + 1 NEW_LINE DEDENT return xornum ^ minvalue NEW_LINE DEDENT arr = [ 13 , 12 , 11 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( missingNum ( arr , n ) ) NEW_LINE
def findLastIndex ( str , x ) : NEW_LINE INDENT index = - 1 NEW_LINE for i in range ( 0 , len ( str ) ) : NEW_LINE INDENT if str [ i ] == x : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE x = ' e ' NEW_LINE index = findLastIndex ( str , x ) NEW_LINE if index == - 1 : NEW_LINE INDENT print ( " Character ▁ not ▁ found " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Last ▁ index ▁ is ' , index ) NEW_LINE DEDENT
def findLastIndex ( str , x ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT str = " geeksforgeeks " NEW_LINE x = ' e ' NEW_LINE index = findLastIndex ( str , x ) NEW_LINE if ( index == - 1 ) : NEW_LINE INDENT print ( " Character ▁ not ▁ found " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Last ▁ index ▁ is ▁ " , index ) NEW_LINE DEDENT
def countMaxSetBits ( left , right ) : NEW_LINE INDENT while ( left | ( left + 1 ) ) <= right : NEW_LINE INDENT left |= left + 1 NEW_LINE DEDENT return left NEW_LINE DEDENT l = 1 NEW_LINE r = 5 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE l = 1 NEW_LINE r = 10 NEW_LINE print ( countMaxSetBits ( l , r ) ) NEW_LINE
def findS ( s ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( s / 2 ) + 1 NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = int ( ( l + r ) / 2 ) NEW_LINE sum = int ( mid * ( mid + 1 ) / 2 ) NEW_LINE if ( sum == s ) : NEW_LINE INDENT return mid NEW_LINE DEDENT elif ( sum > s ) : NEW_LINE INDENT r = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT s = 15 NEW_LINE n = findS ( s ) NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT
def pendulumArrangement ( arr , n ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE pos = n - 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT odd = n - 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = n - 2 NEW_LINE DEDENT while ( odd > 0 ) : NEW_LINE INDENT temp = arr [ odd ] NEW_LINE in1 = odd NEW_LINE while ( in1 != pos ) : NEW_LINE INDENT arr [ in1 ] = arr [ in1 + 1 ] NEW_LINE in1 += 1 NEW_LINE DEDENT arr [ in1 ] = temp NEW_LINE odd = odd - 2 NEW_LINE pos = pos - 1 NEW_LINE DEDENT start = 0 NEW_LINE end = int ( ( n - 1 ) / 2 ) NEW_LINE while ( start < end ) : NEW_LINE INDENT temp = arr [ start ] NEW_LINE arr [ start ] = arr [ end ] NEW_LINE arr [ end ] = temp NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 11 , 2 , 4 , 55 , 6 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE pendulumArrangement ( arr , n ) NEW_LINE DEDENT
def findNumber ( arr , n ) : NEW_LINE INDENT arr = sorted ( arr ) NEW_LINE Max = arr [ n - 1 ] NEW_LINE table = [ 10 ** 9 for i in range ( ( 2 * Max ) + 1 ) ] NEW_LINE table [ 0 ] = 0 NEW_LINE ans = - 1 NEW_LINE for i in range ( 1 , 2 * Max + 1 ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] <= i ) : NEW_LINE INDENT res = table [ i - arr [ j ] ] NEW_LINE if ( res != 10 ** 9 and res + 1 < table [ i ] ) : NEW_LINE INDENT table [ i ] = res + 1 NEW_LINE DEDENT DEDENT DEDENT if ( i > arr [ n - 1 ] and table [ i ] == 10 ** 9 ) : NEW_LINE INDENT ans = i NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 6 , 7 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findNumber ( arr , n ) ) NEW_LINE
def countPoints ( n , m , a , b , x , y ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE j , count = 0 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while j < m : NEW_LINE INDENT if a [ i ] + y < b [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT if ( b [ j ] >= a [ i ] - x and b [ j ] <= a [ i ] + y ) : NEW_LINE INDENT count += 1 NEW_LINE j += 1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y = 1 , 4 NEW_LINE a = [ 1 , 5 ] NEW_LINE n = len ( a ) NEW_LINE b = [ 1 , 1 , 2 ] NEW_LINE m = len ( b ) NEW_LINE print ( countPoints ( n , m , a , b , x , y ) ) NEW_LINE DEDENT
import sys NEW_LINE def minSubarray ( A , n ) : NEW_LINE INDENT minValue = min ( A ) NEW_LINE maxValue = max ( A ) NEW_LINE pos_min , pos_max , ans = - 1 , - 1 , sys . maxsize NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if A [ i ] == minValue : NEW_LINE INDENT pos_min = i NEW_LINE DEDENT if A [ i ] == maxValue : NEW_LINE INDENT pos_max = i NEW_LINE DEDENT if pos_max != - 1 and pos_min != - 1 : NEW_LINE INDENT ans = min ( ans , abs ( pos_min - pos_max ) + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT A = [ 1 , 5 , 9 , 7 , 1 , 9 , 4 ] NEW_LINE n = len ( A ) NEW_LINE print ( minSubarray ( A , n ) ) NEW_LINE
def countSequences ( arr , n ) : NEW_LINE INDENT count = 1 NEW_LINE arr . sort ( ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] + 1 != arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 7 , 3 , 5 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSequences ( arr , n ) ) NEW_LINE DEDENT
def minimumMoves ( a , n ) : NEW_LINE INDENT operations = 0 NEW_LINE a . sort ( reverse = False ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT operations = operations + abs ( a [ i ] - ( i + 1 ) ) NEW_LINE DEDENT return operations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 5 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minimumMoves ( arr , n ) ) NEW_LINE DEDENT
def printCase ( n ) : NEW_LINE INDENT if ( n <= 2 ) : NEW_LINE INDENT print ( " - 1" ) NEW_LINE return NEW_LINE DEDENT for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE printCase ( n ) NEW_LINE DEDENT
def findMissingNumber ( ranges , m ) : NEW_LINE INDENT ranges . sort ( ) NEW_LINE ans = [ ] NEW_LINE prev = 0 NEW_LINE for j in range ( len ( ranges ) ) : NEW_LINE INDENT start = ranges [ j ] [ 0 ] NEW_LINE end = ranges [ j ] [ 1 ] NEW_LINE for i in range ( prev + 1 , start ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT prev = end NEW_LINE DEDENT for i in range ( prev + 1 , m + 1 ) : NEW_LINE INDENT ans . append ( i ) NEW_LINE DEDENT for i in range ( len ( ans ) ) : NEW_LINE INDENT if ans [ i ] <= m : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , M = 2 , 6 NEW_LINE ranges = [ ] NEW_LINE ranges . append ( [ 1 , 2 ] ) NEW_LINE ranges . append ( [ 4 , 5 ] ) NEW_LINE findMissingNumber ( ranges , M ) NEW_LINE DEDENT
def check ( n , k , a , b ) : NEW_LINE INDENT a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE fl = False NEW_LINE ind = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT if ( fl == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT fl = True NEW_LINE ind = i NEW_LINE DEDENT DEDENT if ( ind == - 1 or abs ( a [ ind ] - b [ ind ] ) <= k ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT n , k = 2 , 4 NEW_LINE a = [ 1 , 5 ] NEW_LINE b = [ 1 , 1 ] NEW_LINE if ( check ( n , k , a , b ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def SubseqWidths ( A ) : NEW_LINE INDENT MOD = 10 ** 9 + 7 NEW_LINE N = len ( A ) NEW_LINE A . sort ( ) NEW_LINE pow2 = [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT pow2 . append ( pow2 [ - 1 ] * 2 % MOD ) NEW_LINE DEDENT ans = 0 NEW_LINE for i , x in enumerate ( A ) : NEW_LINE INDENT ans = ( ans + ( pow2 [ i ] - pow2 [ N - 1 - i ] ) * x ) % MOD NEW_LINE DEDENT return ans NEW_LINE DEDENT A = [ 5 , 6 , 4 , 3 , 8 ] NEW_LINE print ( SubseqWidths ( A ) ) NEW_LINE
def maxArrayCover ( a , n , x ) : NEW_LINE INDENT a . sort ( ) NEW_LINE cc = 0 NEW_LINE s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT s += a [ i ] NEW_LINE if ( s > x ) : NEW_LINE INDENT break NEW_LINE DEDENT cc += 1 NEW_LINE DEDENT if ( sum ( a ) == x ) : NEW_LINE INDENT return n NEW_LINE DEDENT else : NEW_LINE INDENT if ( cc == n ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return cc NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n , x = 3 , 70 NEW_LINE a = [ 10 , 20 , 30 ] NEW_LINE print ( maxArrayCover ( a , n , x ) ) NEW_LINE DEDENT
def maximumSOP ( a , b ) : NEW_LINE INDENT sop = 0 NEW_LINE n = len ( a ) NEW_LINE a . sort ( ) NEW_LINE b . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT sop += a [ i ] * b [ i ] NEW_LINE DEDENT return sop NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 2 , 3 ] NEW_LINE B = [ 4 , 5 , 1 ] NEW_LINE print ( maximumSOP ( A , B ) ) NEW_LINE DEDENT
def countTriplets ( arr , n , m ) : NEW_LINE INDENT count = 0 NEW_LINE arr . sort ( ) NEW_LINE for end in range ( n - 1 , 1 , - 1 ) : NEW_LINE INDENT start = 0 NEW_LINE mid = end - 1 NEW_LINE while ( start < mid ) : NEW_LINE INDENT prod = ( arr [ end ] * arr [ start ] * arr [ mid ] ) NEW_LINE if ( prod > m ) : NEW_LINE INDENT mid -= 1 NEW_LINE DEDENT elif ( prod < m ) : NEW_LINE INDENT start += 1 NEW_LINE DEDENT elif ( prod == m ) : NEW_LINE INDENT count += 1 NEW_LINE mid -= 1 NEW_LINE start += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE m = 1 NEW_LINE print ( countTriplets ( arr , n , m ) ) NEW_LINE DEDENT
def sort3 ( arr ) : NEW_LINE INDENT if ( arr [ 1 ] < arr [ 0 ] ) : NEW_LINE INDENT arr [ 0 ] , arr [ 1 ] = arr [ 1 ] , arr [ 0 ] NEW_LINE DEDENT if ( arr [ 2 ] < arr [ 1 ] ) : NEW_LINE INDENT arr [ 1 ] , arr [ 2 ] = arr [ 2 ] , arr [ 1 ] NEW_LINE if ( arr [ 1 ] < arr [ 0 ] ) : NEW_LINE INDENT arr [ 1 ] , arr [ 0 ] = arr [ 0 ] , arr [ 1 ] NEW_LINE DEDENT DEDENT DEDENT a = [ 10 , 12 , 5 ] NEW_LINE sort3 ( a ) NEW_LINE for i in range ( 3 ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def printTriplets ( arr , n , sum ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT ( j , k ) = ( i + 1 , n - 1 ) NEW_LINE while ( j < k ) : NEW_LINE INDENT if ( arr [ i ] + arr [ j ] + arr [ k ] >= sum ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT for x in range ( j + 1 , k + 1 ) : NEW_LINE INDENT print ( str ( arr [ i ] ) + " , ▁ " + str ( arr [ j ] ) + " , ▁ " + str ( arr [ x ] ) ) NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 1 , 3 , 4 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 12 NEW_LINE printTriplets ( arr , n , sum ) ; NEW_LINE DEDENT
def checkFittingArrays ( A , B , N ) : NEW_LINE INDENT A = sorted ( A ) NEW_LINE B = sorted ( B ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] > B [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT A = [ 7 , 5 , 3 , 2 ] NEW_LINE B = [ 5 , 4 , 8 , 7 ] NEW_LINE N = len ( A ) NEW_LINE if ( checkFittingArrays ( A , B , N ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def maximum_toys ( cost , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE sum = 0 NEW_LINE cost . sort ( reverse = False ) NEW_LINE for i in range ( 0 , N , 1 ) : NEW_LINE INDENT if ( sum + cost [ i ] <= K ) : NEW_LINE INDENT sum = sum + cost [ i ] NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 50 NEW_LINE cost = [ 1 , 12 , 5 , 111 , 200 , 1000 , 10 , 9 , 12 , 15 ] NEW_LINE N = len ( cost ) NEW_LINE print ( maximum_toys ( cost , N , K ) ) NEW_LINE DEDENT
def almostSort ( A , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT if A [ i ] > A [ i + 1 ] : NEW_LINE INDENT A [ i ] , A [ i + 1 ] = A [ i + 1 ] , A [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if A [ i ] > A [ i + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 1 , 3 , 2 , 4 , 6 , 5 ] NEW_LINE n = len ( A ) NEW_LINE if almostSort ( A , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def nextGap ( gap ) : NEW_LINE INDENT if ( gap <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( gap // 2 ) + ( gap % 2 ) NEW_LINE DEDENT def merge ( arr1 , arr2 , n , m ) : NEW_LINE INDENT gap = n + m NEW_LINE gap = nextGap ( gap ) NEW_LINE while gap > 0 : NEW_LINE INDENT i = 0 NEW_LINE while i + gap < n : NEW_LINE INDENT if ( arr1 [ i ] > arr1 [ i + gap ] ) : NEW_LINE INDENT arr1 [ i ] , arr1 [ i + gap ] = arr1 [ i + gap ] , arr1 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT j = gap - n if gap > n else 0 NEW_LINE while i < n and j < m : NEW_LINE INDENT if ( arr1 [ i ] > arr2 [ j ] ) : NEW_LINE INDENT arr1 [ i ] , arr2 [ j ] = arr2 [ j ] , arr1 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE j += 1 NEW_LINE DEDENT if ( j < m ) : NEW_LINE INDENT j = 0 NEW_LINE while j + gap < m : NEW_LINE INDENT if ( arr2 [ j ] > arr2 [ j + gap ] ) : NEW_LINE INDENT arr2 [ j ] , arr2 [ j + gap ] = arr2 [ j + gap ] , arr2 [ j ] NEW_LINE DEDENT j += 1 NEW_LINE DEDENT DEDENT gap = nextGap ( gap ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a1 = [ 10 , 27 , 38 , 43 , 82 ] NEW_LINE a2 = [ 3 , 9 ] NEW_LINE n = len ( a1 ) NEW_LINE m = len ( a2 ) NEW_LINE merge ( a1 , a2 , n , m ) NEW_LINE print ( " First ▁ Array : ▁ " , end = " " ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( a1 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE print ( " Second ▁ Array : ▁ " , end = " " ) NEW_LINE for i in range ( m ) : NEW_LINE INDENT print ( a2 [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT
def mergeArrays ( arr1 , arr2 , n1 , n2 ) : NEW_LINE INDENT arr3 = [ None ] * ( n1 + n2 ) NEW_LINE i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while i < n1 and j < n2 : NEW_LINE INDENT if arr1 [ i ] < arr2 [ j ] : NEW_LINE INDENT arr3 [ k ] = arr1 [ i ] NEW_LINE k = k + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr3 [ k ] = arr2 [ j ] NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT DEDENT while i < n1 : NEW_LINE INDENT arr3 [ k ] = arr1 [ i ] ; NEW_LINE k = k + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT while j < n2 : NEW_LINE INDENT arr3 [ k ] = arr2 [ j ] ; NEW_LINE k = k + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT print ( " Array ▁ after ▁ merging " ) NEW_LINE for i in range ( n1 + n2 ) : NEW_LINE INDENT print ( str ( arr3 [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr1 = [ 1 , 3 , 5 , 7 ] NEW_LINE n1 = len ( arr1 ) NEW_LINE arr2 = [ 2 , 4 , 6 , 8 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE mergeArrays ( arr1 , arr2 , n1 , n2 ) ; NEW_LINE
def findMinDiff ( arr , n , m ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT arr . sort ( ) NEW_LINE if ( n < m ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT min_diff = arr [ n - 1 ] - arr [ 0 ] NEW_LINE for i in range ( len ( arr ) - m + 1 ) : NEW_LINE INDENT min_diff = min ( min_diff , arr [ i + m - 1 ] - arr [ i ] ) NEW_LINE DEDENT return min_diff NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 12 , 4 , 7 , 9 , 2 , 23 , 25 , 41 , 30 , 40 , 28 , 42 , 30 , 44 , 48 , 43 , 50 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ difference ▁ is " , findMinDiff ( arr , n , m ) ) NEW_LINE DEDENT
def distinctCount ( arr , n ) : NEW_LINE INDENT count = n ; NEW_LINE i = 0 ; j = n - 1 ; sum = 0 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT while ( i != j and arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT count = count - 1 ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT while ( i != j and arr [ j ] == arr [ j - 1 ] ) : NEW_LINE INDENT count = count - 1 ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT break ; NEW_LINE DEDENT sum = arr [ i ] + arr [ j ] ; NEW_LINE if ( sum == 0 ) : NEW_LINE INDENT count = count - 1 ; NEW_LINE i = i + 1 ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT elif ( sum < 0 ) : NEW_LINE INDENT i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT j = j - 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT arr = [ - 2 , - 1 , 0 , 1 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( " Count ▁ of ▁ absolute ▁ distinct ▁ values ▁ : ▁ " , distinctCount ( arr , n ) ) ; NEW_LINE
def flip ( arr , i ) : NEW_LINE INDENT start = 0 NEW_LINE while start < i : NEW_LINE INDENT temp = arr [ start ] NEW_LINE arr [ start ] = arr [ i ] NEW_LINE arr [ i ] = temp NEW_LINE start += 1 NEW_LINE i -= 1 NEW_LINE DEDENT DEDENT def findMax ( arr , n ) : NEW_LINE INDENT mi = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if arr [ i ] > arr [ mi ] : NEW_LINE INDENT mi = i NEW_LINE DEDENT DEDENT return mi NEW_LINE DEDENT def pancakeSort ( arr , n ) : NEW_LINE INDENT curr_size = n NEW_LINE while curr_size > 1 : NEW_LINE INDENT mi = findMax ( arr , curr_size ) NEW_LINE if mi != curr_size - 1 : NEW_LINE INDENT flip ( arr , mi ) NEW_LINE flip ( arr , curr_size - 1 ) NEW_LINE DEDENT curr_size -= 1 NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( " % d " % ( arr [ i ] ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 23 , 10 , 20 , 11 , 12 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE pancakeSort ( arr , n ) ; NEW_LINE print ( " Sorted ▁ Array ▁ " ) NEW_LINE printArray ( arr , n ) NEW_LINE
def get_maximum ( s , a ) : NEW_LINE INDENT s = list ( s ) NEW_LINE n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ord ( s [ i ] ) - ord ( '0' ) < a [ ord ( s [ i ] ) - ord ( '0' ) ] ) : NEW_LINE INDENT j = i NEW_LINE while ( j < n and ( ord ( s [ j ] ) - ord ( '0' ) <= a [ ord ( s [ j ] ) - ord ( '0' ) ] ) ) : NEW_LINE INDENT s [ j ] = chr ( ord ( '0' ) + a [ ord ( s [ j ] ) - ord ( '0' ) ] ) NEW_LINE j += 1 NEW_LINE DEDENT return " " . join ( s ) ; NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = "1337" NEW_LINE a = [ 0 , 1 , 2 , 5 , 4 , 6 , 6 , 3 , 1 , 9 ] NEW_LINE print ( get_maximum ( s , a ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def countSteps ( n ) : NEW_LINE INDENT steps = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT largest = int ( sqrt ( n ) ) ; NEW_LINE n -= ( largest * largest ) ; NEW_LINE steps += 1 ; NEW_LINE DEDENT return steps ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 85 ; NEW_LINE print ( countSteps ( n ) ) ; NEW_LINE DEDENT
def sumArr ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT def maxSum ( arr , n , k ) : NEW_LINE INDENT arr . sort ( reverse = False ) NEW_LINE i = 0 NEW_LINE while ( i < n and k > 0 and arr [ i ] < 0 ) : NEW_LINE INDENT arr [ i ] *= - 1 NEW_LINE k -= 1 NEW_LINE i += 1 NEW_LINE DEDENT if ( k % 2 == 1 ) : NEW_LINE INDENT min = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ min ] > arr [ i ] ) : NEW_LINE INDENT min = i NEW_LINE DEDENT DEDENT arr [ min ] *= - 1 NEW_LINE DEDENT return sumArr ( arr , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ - 5 , 4 , 1 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 4 NEW_LINE print ( maxSum ( arr , n , k ) ) NEW_LINE DEDENT
def Maxsum ( c1 , c2 , c3 , c4 ) : NEW_LINE INDENT sum = 0 NEW_LINE two34 = min ( c2 , min ( c3 , c4 ) ) NEW_LINE sum = two34 * 234 NEW_LINE c2 -= two34 NEW_LINE sum += min ( c2 , c1 ) * 12 NEW_LINE return sum NEW_LINE DEDENT c1 = 5 ; c2 = 2 ; c3 = 3 ; c4 = 4 NEW_LINE print ( Maxsum ( c1 , c2 , c3 , c4 ) ) NEW_LINE
def findCountOfPairs ( a , b , n ) : NEW_LINE INDENT ans = 0 NEW_LINE ans += n * int ( a / n ) * int ( b / n ) NEW_LINE ans += int ( a / n ) * ( b % n ) NEW_LINE ans += ( a % n ) * int ( b / n ) NEW_LINE ans += int ( ( ( a % n ) + ( b % n ) ) / n ) ; NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE b = 13 NEW_LINE n = 3 NEW_LINE print ( findCountOfPairs ( a , b , n ) ) NEW_LINE DEDENT
def findArray ( N , P ) : NEW_LINE INDENT ans = ( P * ( P + 1 ) ) // 2 + ( N - P ) ; NEW_LINE arr = [ 0 ] * ( N + 1 ) ; NEW_LINE for i in range ( 1 , P + 1 ) : NEW_LINE INDENT arr [ i ] = i ; NEW_LINE DEDENT for i in range ( P + 1 , N + 1 ) : NEW_LINE INDENT arr [ i ] = 1 ; NEW_LINE DEDENT print ( " The ▁ Minimum ▁ Possible ▁ Sum ▁ is : ▁ " , ans ) ; NEW_LINE print ( " The ▁ Array ▁ Elements ▁ are : ▁ " ) ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT N = 5 ; NEW_LINE P = 3 ; NEW_LINE findArray ( N , P ) ; NEW_LINE
def findIntersection ( intervals , N ) : NEW_LINE INDENT l = intervals [ 0 ] [ 0 ] NEW_LINE r = intervals [ 0 ] [ 1 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( intervals [ i ] [ 0 ] > r or intervals [ i ] [ 1 ] < l ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l = max ( l , intervals [ i ] [ 0 ] ) NEW_LINE r = min ( r , intervals [ i ] [ 1 ] ) NEW_LINE DEDENT DEDENT print ( " [ " , l , " , ▁ " , r , " ] " ) NEW_LINE DEDENT intervals = [ [ 1 , 6 ] , [ 2 , 8 ] , [ 3 , 10 ] , [ 5 , 8 ] ] NEW_LINE N = len ( intervals ) NEW_LINE findIntersection ( intervals , N ) NEW_LINE
def cmp ( a , b ) : NEW_LINE INDENT return ( a > b ) - ( a < b ) NEW_LINE DEDENT def maxSubarraySize ( arr ) : NEW_LINE INDENT N = len ( arr ) NEW_LINE ans = 1 NEW_LINE anchor = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT c = cmp ( arr [ i - 1 ] , arr [ i ] ) NEW_LINE if c == 0 : NEW_LINE INDENT anchor = i NEW_LINE DEDENT elif i == N - 1 or c * cmp ( arr [ i ] , arr [ i + 1 ] ) != - 1 : NEW_LINE INDENT ans = max ( ans , i - anchor + 1 ) NEW_LINE anchor = i NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 9 , 4 , 2 , 10 , 7 , 8 , 8 , 1 , 9 ] NEW_LINE print ( maxSubarraySize ( arr ) ) NEW_LINE
def ValidPairs ( arr ) : NEW_LINE INDENT count = [ 0 ] * 121 NEW_LINE for ele in arr : NEW_LINE INDENT count [ ele ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for eleX , countX in enumerate ( count ) : NEW_LINE INDENT for eleY , countY in enumerate ( count ) : NEW_LINE INDENT if eleX < eleY : NEW_LINE INDENT continue NEW_LINE DEDENT if ( abs ( eleX - eleY ) % 2 == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT ans += countX * countY NEW_LINE if eleX == eleY : NEW_LINE INDENT ans -= countX NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 16 , 17 , 18 ] NEW_LINE print ( ValidPairs ( arr ) ) NEW_LINE
def minChanges ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( ( i - 1 >= 0 ) and A [ i - 1 ] == 1 and A [ i + 1 ] == 1 and A [ i ] == 0 ) : NEW_LINE INDENT A [ i + 1 ] = 0 NEW_LINE cnt = cnt + 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 1 , 1 , 0 , 1 , 1 , 0 , 1 , 0 , 1 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minChanges ( A , n ) ) NEW_LINE
def completeSequence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE open = 0 NEW_LINE close = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT open += 1 NEW_LINE DEDENT else : NEW_LINE INDENT close += 1 NEW_LINE DEDENT if ( close > open ) : NEW_LINE INDENT print ( " IMPOSSIBLE " ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( s , end = " " ) NEW_LINE for i in range ( open - close ) : NEW_LINE INDENT print ( " ) " , end = " " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ( ( ) ( ( ) ( " NEW_LINE completeSequence ( s ) NEW_LINE DEDENT
def smallestPermute ( n ) : NEW_LINE INDENT res = [ " " ] * ( n + 1 ) NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for i in range ( n - 2 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT res [ i ] = chr ( 48 + i + 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = chr ( 48 + i ) NEW_LINE DEDENT DEDENT res [ n - 1 ] = chr ( 48 + n - 2 ) NEW_LINE res [ n - 2 ] = chr ( 48 + n ) NEW_LINE res [ n - 3 ] = chr ( 48 + n - 1 ) NEW_LINE DEDENT res = ' ' . join ( res ) NEW_LINE return res NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE print ( smallestPermute ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def minInsertions ( H , n , K ) : NEW_LINE INDENT inser = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( H [ i ] - H [ i - 1 ] ) ; NEW_LINE if ( diff <= K ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT inser += math . ceil ( diff / K ) - 1 ; NEW_LINE DEDENT DEDENT return inser ; NEW_LINE DEDENT H = [ 2 , 4 , 8 , 16 ] ; NEW_LINE K = 3 ; NEW_LINE n = len ( H ) ; NEW_LINE print ( minInsertions ( H , n , K ) ) ; NEW_LINE
def count_minimum_operations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 1 ) : NEW_LINE INDENT if ( n % 3 == 0 ) : NEW_LINE INDENT n //= 3 NEW_LINE DEDENT elif ( n % 3 == 1 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT n += 1 NEW_LINE DEDENT DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE ans = count_minimum_operations ( n ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def maxSum ( arr , n ) : NEW_LINE INDENT s = 0 NEW_LINE l = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT s += abs ( a [ i ] ) NEW_LINE if ( a [ i ] >= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT l . append ( i + 1 ) NEW_LINE l . append ( i ) NEW_LINE DEDENT DEDENT print ( s ) NEW_LINE print ( * l ) NEW_LINE DEDENT n = 4 NEW_LINE a = [ 1 , - 2 , - 3 , 4 ] NEW_LINE maxSum ( a , n ) NEW_LINE
def LengthLCP ( x , y ) : NEW_LINE INDENT fr = [ 0 ] * 26 NEW_LINE for i in range ( b ) : NEW_LINE INDENT fr [ ord ( y [ i ] ) - 97 ] += 1 NEW_LINE DEDENT c = 0 NEW_LINE for i in range ( a ) : NEW_LINE INDENT if ( fr [ ord ( x [ i ] ) - 97 ] > 0 ) : NEW_LINE INDENT c += 1 NEW_LINE fr [ ord ( x [ i ] ) - 97 ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( c ) NEW_LINE DEDENT x , y = " here " , " there " NEW_LINE LengthLCP ( x , y ) NEW_LINE
def CountPair ( L , R ) : NEW_LINE INDENT x = ( R - L + 1 ) NEW_LINE print ( x // 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , R = 1 , 8 NEW_LINE CountPair ( L , R ) NEW_LINE DEDENT
def problemsLeft ( K , P , N ) : NEW_LINE INDENT if ( K <= P ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( K - P ) * N ) NEW_LINE DEDENT DEDENT K , P , N = 4 , 1 , 10 NEW_LINE print ( problemsLeft ( K , P , N ) ) NEW_LINE
def results ( n , k ) : NEW_LINE INDENT return round ( pow ( n , ( 1.0 / pow ( 2 , k ) ) ) ) NEW_LINE DEDENT k = 3 NEW_LINE n = 100000000 NEW_LINE print ( " Chocolates ▁ left ▁ after " ) , NEW_LINE print ( k ) , NEW_LINE print ( " iterations ▁ are " ) , NEW_LINE print ( int ( results ( n , k ) ) ) NEW_LINE
def steps ( N , M ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( N == 2 ) : NEW_LINE INDENT return M NEW_LINE DEDENT return 2 * M + ( N - 3 ) NEW_LINE DEDENT N = 4 NEW_LINE M = 4 NEW_LINE print ( steps ( N , M ) ) NEW_LINE
def survival ( S , N , M ) : NEW_LINE INDENT if ( ( ( N * 6 ) < ( M * 7 ) and S > 6 ) or M > N ) : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT days = ( M * S ) / N NEW_LINE if ( ( ( M * S ) % N ) != 0 ) : NEW_LINE INDENT days += 1 NEW_LINE DEDENT print ( " Yes ▁ " ) , NEW_LINE print ( days ) NEW_LINE DEDENT DEDENT S = 10 ; N = 16 ; M = 2 NEW_LINE survival ( S , N , M ) NEW_LINE
